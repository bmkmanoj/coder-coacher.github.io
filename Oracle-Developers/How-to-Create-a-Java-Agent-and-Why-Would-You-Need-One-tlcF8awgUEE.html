<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How to Create a Java Agent and Why Would You Need One? | Coder Coacher - Coaching Coders</title><meta content="How to Create a Java Agent and Why Would You Need One? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How to Create a Java Agent and Why Would You Need One?</b></h2><h5 class="post__date">2016-09-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tlcF8awgUEE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone I'm really happy to see
you all here and today we're gonna talk
about Joe agents and how when why would
you need the great one my name is Alex
wife and I come from Estonia which is
far far away and I work for zero turn
around the company so it's a word but
myself why would you why should be here
and what I say and why should you trust
me I am a developer advocate currently
at the rear turnaround before that I was
a software developer for about six to
seven years and then suddenly I felt an
urge to help the community more so I
transitioned and has a developer
advocate one of my main responsibilities
is to talk to the community and try to
make you work as efficiently as smart as
possible so one of my main
responsibilities is to maintain the
rebel apps blog where we try to publish
technical opinionated content so if you
would like to read articles about the
technology you're welcome to check that
out and one other effort I'm involved
with is the virtual drug so if you are
members of a normal Java users group you
know that they create meetups and
deliver the content and sessions to use
of virtual jack is an online-only java
user group so if you have one if you
don't have one in vicinity you can just
join that and twice a months we try to
deliver the best the best sessions and
best speakers from the general community
to do presentations online so you can
enjoy that from the comfort of your own
home and if you have any questions or if
you want to chat with me the best way
would be to ping me on Twitter I go by
ads live there hopefully we'll talk so a
word about your turnaround there's a
company that they make stool for Java
developers currently we have T one is
Garibaldi that can reload classes in the
running Java process so you don't have
to restart it all the way all the time
when you develop so it
boost your productivity as a developer
and we have extra wool which is a
performance tool for developers doing
job web apps so if you would check those
out my employer would be happy and they
will send it to more conferences to talk
to more awesome people and now we'll be
happy as well so and if he would like to
join another conference just the last
announcement the virtual drug the only
only drug runs the 24 hour straight
conference on September 27th so since
you are at the conference here maybe you
would love to join the next one and you
can just go register and all the videos
will be streamed at YouTube so you can
you can this is a week after German one
so when you'll feel that downside of not
being at the conference you continue and
become happy again so hopefully that
would be great fun so with all that said
let's talk about Joe agents and the real
reason why why we came here so Joe agent
is very powerful concept and how many of
you know what a giant is or have written
one quite well here so hopefully we'll
we'll cover the easy parts quickly and
then try to go a little bit deeper so
which our agent as a concept originated
somewhere at Java five
I guess they they added that to the
official API and this is the thin layer
that can sit between the JVM and your
application so it separates the
application from from the underlying
platform and gives the unique
opportunity to be in the middle of all
things so this wonderful opportunity has
created a chance to to create very cool
tools that you Joe agents and all those
all those companies and the libraries
and tools of their user Joe agent to do
things that will not be able to do with
just a library or framework within
normal way how do you add code to your
java application so from testing
libraries to build tools to
all kinds of profilers and ATM tools to
things like Jarrell and we'll talk a
little bit how durable utilizes Java
agents later to see the real power so at
first I would like to start with a with
a simple problem that maybe will get
into a mindset of what what what you can
do or the problem that you cannot easily
solve without a tool like a Java agent
so imagine you have a code in the
application and you want to build build
a tracer so for every method invocation
you want to log a statement when you
enter the method body and maybe you can
you want to log the parameter values and
then when you exit the method you want
to also know that oh at this precise
time with with we have exited in the
method so you can get kind of like a
representation of how your program works
if you want to be able to tracer and
it's a fairly normal idea it is fairly
useful tool that you might want to build
at some point of time and obviously
there are well since the problem is not
that complicated or unique the
resolutions that that built specifically
stuff like that is solution for that so
one of them is bite man by JBoss and
this is a a tool that allows you to
specify rules declaratively
for enhancing your java code so and if
you imagine that you have a Java app
that sits looks like something like this
and you have like main methods and
multiple threads running what you want
to do maybe is to print stuff and you
won't not change the actual code of your
java program right because change in the
code of the application you're going to
put in production to enable something
some small enhancement might not be the
best idea ever every line of code that
sleeps into production contains possible
bugs and can can decrease the
performance or whatnot so you would like
to avoid changing the actual code of
your application so what you would like
to do you would like to supply something
from from the side you would like to you
cannot change the underlying platform
you run on a JVM and your operation
symbol would not be very happy if you
say oh let's let's you know let's have
this enhanced version of of the genome
and run that but what you want to do you
want to inject some logic from from the
side and whiteman allows you to specify
rules in a way like that where you have
a DSL that says oh do this when
something happens or do that when
something happens so this particular
rule tells us that when the third method
of the thread class is executed then
please trace that line and this is kind
of when you run your java process with
the Java agent of the bite man and it
will run the application on top and you
if you provide some parameters like that
you will exactly see that tracing being
established so you can use bite man for
simple tasks but then at some point of
time you will realize that you want to
solve problems that the established
tools for where libraries have not yet
touched and you would like to express
your your creativity of that how to
solve various problems so maybe for
example you would like to dump every
loaded class file into a certain folder
to know what classes are exactly loaded
or something like this and then you
don't have the ready ready
out-of-the-box solution to do that and
you will need to - to start writing Java
agents for itself
so and the Java agent will will allow
you to do all that all the tools are
many many tools use that approach and
they hide the actual or sometimes hide
that the actual fact the fact that they
use Java agent underneath but if you if
you when you think about this at every
tool which use a Java at some point of
time will execute the Java command and
they will will run some class and they
will have the class pass
and everything so to enable the Java
agent and you just need to supply a job
agent parameter to your Jawa and since
Java 5 so like what 15 years ago you can
do that so if you are running more or
less well not not ancient not super dead
dinosaur version Java this is the
possibility that you would need to you
might consider so the configuration
that's simple and this is why this
approach has been so so successfully
used by many tools if we look at what
consists what the job agent consists of
there are a couple of things so first of
all a general agent is a program it's a
Java program which you write using Java
language or other languages but probably
you would you would like to use plain
Java and obviously a Java program
consists of classes and one of the main
things that you will you will need in
the Java agent inside the jar file is an
agent class an agent class should be a
class just like normal main class of
your application just entry point into
the code is just any it like there are
no conventions how to name the class you
just need they can follow the convention
that it has to have the main method that
is the public static void main which
takes an array of strings as a parameter
and your agent class will have two
methods like that one of them is agent
Wayne and one of them is a pre main so
as the name specifies the pre main will
be executed before the control flow will
be given to the application classes so
you are created with the Java agent
you're creating this thin layer between
the JVM and and the actual program and
you will be given the control flow
before the actual application so and the
pre main class of the Joe agent will be
executed then you will need to package
this to make use of a Java agent it has
to be packaged to the dart file
and you will have to provide a specific
manifest file with with a couple of
properties specified so we'll see we'll
see an example of packaging in a little
bit bit when we talk about an actual
demo of the Java agent and how to you
how to create that using build tools
that developers typically use and after
that you will need to specify the avid
Java agent parameter and you will need
to point both to the jar file that is a
Java agent and specify the arguments
that you won't like to pass through the
Java agent so it's a fairly simple jar
file that you will create it can contain
any amount of code so you can go as
crazy or as complicated as you would
like to but in nutshell to create a very
simple Java agent that does one simple
thing you don't have to build enterprise
applications of all thousands of
conventions so let's look at the Joe
agents more so why the Java Djinn
technology became possible since Java 5
because they introduced the
instrumentation API so when you specify
a Java agent it would receive an
instrumentation instance an instance of
the instrumentation class when the pre
main method is executed and you can use
that to you to do one very special thing
you can register transformers for the
class files so as you know any Java
program can it contains Java classes and
this classes specified the behavior what
exactly the program does so a class file
transformer is the thing that will
receive at the class loading time it
will receive the bytecode of the you are
over the classes of your application and
it can modify that the word transform it
on the fly during loading so the dynamic
loading of the classes was in the main
thing that made Java the platform that
is today so we started packaging
everything as a pre-built
DLL files or something and started
distributing jar files with byte code
that is precompiled but it will be
dynamically loaded and linked at the run
time and at the same time this enabled
us to create transformers to change the
behavior of the application without
actually changing the source code of the
other application so the class file
transformer is very important thing and
it would be most probably the main thing
that you you will need to use from the
instrumentation API and how the how the
JVM figures out what classes to execute
and what classes is a is a Java agent
with the pre main method you specify
that information in the manifest so and
when you just run and point the JVM at
your jar file it goes and unloads the
the manifest figures out what classes
are the agent classes finds the pre main
method and executes that if you fail to
do that correctly or he referenced the
non-existent class it will crash with a
fairly comprehensive message error
message better than many error messages
so this is quite simple the second thing
which is even more impressive about Joe
agents that not only you can specify
Java agent at the beginning of time when
when your JVM starts but you can attach
that later to the running Jamiel process
and which is fairly cool
you can turn off turn on the agent
somewhere introduction when you would
like and then it can sit there before
that you can see there so if you're keen
on building a debugger or something you
might want to take this virtual machine
agent mind approach the most important
parameters in the manifest file they
further simple as well and most probably
you will just copy paste that from some
example that you found somewhere on
Stack Overflow or somewhere in github
but what you need to specify you need to
specify the agent main class if you use
the attach if you want to attach your
agent on-the-fly you
to specify the pre main class so the JVM
knows where to give the control flow
when the application is loading you need
to specify the boot class pass for the
Java agent to know to get access to the
code that you've written in it so you
can package everything in there or you
can specify additional boot class pass
and to you important properties that you
need is if the Java agent is allowed to
redefine classes on the on the fly and
if the Joe agent can greet transform
classes that were already transformed
once so you can chain multiple Java
agents and you can you can put the class
file data loading through all of them
once one by one and then they all those
tools can work together possibly if
they're written to do that if we're
looking at a manifest file then well
manifest file is just the text file
where it just all that information is
written in plain text and this is the
example of the manifest from the durable
tool you can see that there are a bunch
of more or less irrelevant stuff that is
auto-generated but those things are as
the pre main class and if it's it can
redefine the classes definitely has to
have to be there so if you just created
any jar file and forget the manifest it
will not work and you will have to debug
that small example if you want to attach
the Joe agent on the fly to the target
me M you will need to so imagine you
have two JVMs and one of them is running
and the second one creates the Java
agent on the fly and attaches to the
first one so the API is super simple and
if you think about this this is exactly
how the picture works so the green JVM
is running and you want to instrument
that on the fly and start retransform in
classes in there so you start another
Java process that contains the code for
the Joe agent and then he attached using
the fire notify all the process ID just
you have attached it to different so you
inject the code into running JVM and
this is it this is how the Java juggs
from from the above it's just a simple
jar file that contains some bunch of
Java code and some specifications in a
manifest now the important part now the
cool part now to the instrumentation API
so instrumentation API it's a Java
package java.lang instrument and most
probably you will need to consider T
class of two main classes in the in that
package one of them is the
instrumentation which can give you
access to the loaded classes inside your
JVM or give you the values returning
your values of the flags if this
particular instrumentation is allowed to
redefine classes or something and the
most important method is the ad
transformer for which you will have to
provide class file transformers which is
an interface and we'll see that in a
second so the instrumentation the
instrumentation isn't is an interface so
the implementation that interest will be
provided for you by the JVM and need not
have to do anything to figure out how to
do that so you just use the API and most
interesting things or the ad transformer
as I as a set and you can specify if it
if the transformation is final or can be
a pre transform and you can eagerly
specifically command the instrumentation
to redefine the class definitions that
have been loaded before so using that is
fairly simple we'll look at the code in
in some time the class file transformer
is an interface that contains a single
method transform that returns an array
of bytes that array of bytes as you can
probably have guessed already is the
actual bytes of the new class the
should be loaded so the class file
transformer sets between the whites that
jvm find somewhere in a file system and
tries to load and between the actual
bytes of the class file that will be
loaded so you receive the class file
buffer which is the definition of the
class that you've seen before and you
know the class loader that is trying to
load the class and you have the class
name for the class so you can filter it
if you would like to transform this
particular class this way or that way
and it's pretty pretty pretty simple
stuff so an implementation of the class
file transform it could look something
like this and it's a quite a bit of code
but if we can try to condense that into
the important part so you intermit
implement the class file transformer and
then you just work somehow on the class
file buffer to modify that so if you use
library something like Java assist or
what it what's another one ASM you will
just modify that class file buffer
directly we in this session we'll look
at bind body which takes a little bit
different approach to creating georgians
and that is that that approach is more
fun and I like it more so whatever you
specify inside the class file
transformer and what classes you would
like to use there util classes or other
interfaces it's entirely up to you
imagination so but you have to provide
this in the class file transform form so
if you imagine the instrumentations
integer and the class loading process
being the right
you can register multiple class file
transformers and they can all intercept
the class loading process and every one
of them can add a little bit work remove
a little bit or somehow modify the
behavior of the program so if you
consider the example that we looked at
before if you want to build a small
tracer for all the methods it's fairly
simple one class file straight
we can add logging statements at the
beginning of every method another class
file transfer he wished to separate
those concerns can add the log
statements to the end and everything he
will do you will have to modify and work
on the Java bytecode so this is fairly
different from the Java source code that
we all know and love to create
boilerplate classes with but there are
libraries to leverage that so you don't
have to actually manually specify up
code 77 up code 75 a load based or and
stuff like that
however it makes so the question was if
we can configure multiple agents for the
single JVM and yes we can consider
configure multiple agents you just
specify Java agent parameters in the row
and in the same order that they were
specified they will be loaded and their
code will be executed so if the
registers are class file transformers
all of them will be executed at the same
time and they can manipulate the same
class one after each other
so there is a danger that one of them
will create code that is unreadable by
the other one or there is a danger that
you will say make incompatible changes
and then everything will break or it
will explode or it will just silently
ignore what you want to do but that is
definitely possible
cool thank you so the comment was that
it is indeed possible and the experience
shows that it is possible so oh yeah it
is possible it is possible definitely
should be possible so back to the
bytecode so the JVM is a stack machine
so somewhere in the in the JVM there is
a stack of instructions and the bytecode
works on those individual instructions
and you can add values on the stack or
execute the operations and this is a
fairly low-level thing that was created
and it is very efficient for the
machines to read and execute and
understand and interpret but it's really
uncomfortable for human beings to think
about creating programs on that level so
if you have experience with assembly for
example you know that writing large
programs that the complex enterprise
business logic and assembly is a very
challenging task so Java bytecode is way
higher than the assembly a little bit
higher than that assembly but it's still
it's not something that they would like
create programs in so what you wanna do
you want to actually use some kind of
library and in the past I've been I've
been talking about how to manipulate the
Java bytecode and my one of my favorite
things worse Java assist this is library
also under the JBoss and the best thing
about Java Syst
is that it provides you the source level
API so you can use your java code and
you just specify your java code in a
string basically you you you can write
quotes and then java code within quotes
and the Java system pile that on the fly
during the runtime and and you can add
stuff like that the the add code on the
fly using plain java language but then
with with some experience in that I
realized that that's not the best
approach because a strangely type
language where you just write everything
in a string with no IDE
support over anything it's kind of like
a quickly growing into a big mess when
you add code so imagine just having no
compiler support until the runtime and
you have to write all the Java code
imagine having very mysterious error
messages when you forget to add a
semicolon which you will forget to add
because there is no idea support for
writing Java in a string but this is
probably the easiest way T to to
manipulate the byte code and it doesn't
require any like paradigm shift in your
mind however more recently I fell to I
started to like bite buddy much more so
by body is a cogeneration library and it
was specifically created at first to
create Java classes at the runtime and
without the help of the Java C compiler
so if you know the the rest the ability
you can create proxy classes at runtime
from and the support to that is inside
the JDK but proxies will will be able to
you will be able to implement the
interfaces and by body will allow you to
create arbitrary classes and it contains
a very nice DSL types a DSL for writing
out classes using byte code and wide
body then grew for a couple of years and
last year it received two deep choice of
word and many many applications
currently that use Joe agent try to
either already moved from other byte
code manipulation libraries towards by
body or consider moving so Rafael winter
halter is the main author of the byte
body and he's a good friend of mine from
Oslo Norway and his idea when he started
dividing by body one of the main goals
of the function was to create an API
that is as non-intrusive as possible and
that does not leave any traces of itself
in the in the classes that it generates
so imagine you generate the class and
you have the compiled output so by body
it makes a really good effort at not
leaving any marks that this class is
actually generated by by by day and not
compiled from Java source code as you do
normally who were not created as by you
by hand so the benefit of that is that
you can use those classes at runtime
without bite by the being on a class
pass so you just can use them as typical
class files and together with the types
of DSL and incredible API for from
manipulation of bytecode and classes it
made by by the amazing and also this
non-intrusive this inspired the logo to
be a ghost which comes and you see that
but then it goes away and you don't see
that and now we are ready to to look at
the actual implementation of of a Java
agent and how to build one so while I'm
trying to switch to the mirror mode we
can maybe have a question if you if you
have one you'll have a question no good
I'll try to
mirror mount arrangement mirror displace
you can see that right let me try to
make it a little larger so this is
incorrect we'll see well doesn't compile
so I have a small project called cold
spicy Rin in Eclipse and this is a
project the code source for that is
available in github so if you would like
to check that later
it is possible so this Java agent that
will try to build here will be doing
exactly what we want it will be printing
stuff when we enter the method and
bringing stuff alone leaving the method
so you can see that it is this Gradle
what you need to do to create a Java G
you will need to somehow figure out the
dependency that you will use for the
bytecode manipulation and well it's
fairly easy both Java system by body and
all the other crafts are available
through the normal Gradle Nathan maven
repositories and then the important part
was the manifest if you remember we
talked that you actually absolutely have
to have the manifest in the in the jar
file that is your job agent and that you
have to specify properties so you can
see in Gradle you specify the manifest
as easy well in this easy way and the
important bit is here that we specified
the pre main class the class that will
receive the control when we start this
as a Joe agent and we say that oh you
know what we want to have the ultimate
power on the JVM and we want to be able
to change the buy code of any class that
that goes through the loading mechanism
so building this is fairly simple and
after that we'll need to use byte by DT
to do things so let's see how by body
helps you to create classes and types at
the runtime so the API is super simple
what you create you need to create a new
PI body and think about this white body
is
the body of the class that you want to
create or or intimate then you have to
specify all the things that you will
specify normally in the source code of
the Java file if you think of the Java
file it has you start with class X
extends something or the default
extension superclass would be the object
and then you implement the interfaces
and then you say oh there will be
methods and then you have fields and
Bide body allows you to use Java level
API to do that so we create and we say
oh will like to have a class that is a
dynamic type and we want it to be a
subclass of the object then you you see
that you just in the very type safe
manner you've referenced the existing
classes and you get the whole full
support of the IDE view if you if you
want that on the implementing that and
then we would like that class that we
are dynamic type creating we want to say
that whoa when we access the to string
method of that class and we know that
there is a too strong method because any
any any class extends an object and the
to string method comes from the object
itself so for the methods that are named
to string which is the single method
please intercept that method and return
the fixed value of the hello world back
so create a method called to string that
returns a single value then you say make
this class and you load load that class
as you would load any class into the JVM
using some sort of class loader and you
can receive a dynamic type so now with
this small code hopefully when I will
print out the new instance of this
dynamic type I will not receive the
unintelligible hash number something as
as I could but I would get the hello
world so what I can have to do I have to
execute this save files yes
I need to see that there is hello world
right here we can be for the world
John one so you see that there is no
trickery going on and this class is
actually dynamically created this
electron don't do that so and indeed the
new class is loaded so if we just try to
print out the nav attack this is very
interesting so is this an actual class
or is this is this something oh I'm not
sure what's happening here and we're
really sorry about this so you can see
that the class that we created is the
byte by the class and resides in the
body by the package that expands the
object and it's just some random
unintelligible class seeking somewhere
but it's indeed not a class that we load
it somewhere from source of the room a
class file but this is the class that
we're creating dynamically returning
fixed Valis is probably not the most
interesting thing here so I will comment
this out and I will show you a different
example this is a way more interesting
example because what you want to do you
don't want to to specify the code
hard-coded somewhere but you want to use
the normally written classes that you
create and you want to use the code from
there at runtime so the difference
between this example in the previous is
that when we intercept instead of just
returning some value that we have we
delegate and we delegate that to the
hello world class so all the rest in
this example is the same except for this
method delegation thing so if we look at
the whole world class we just have a
single method called intercept and when
basically what by body does by body
figures out that when the to string
method is called we should execute the
code in the hello world class so if you
think that when we run this the
different hello world will will will
show then you're probably true when
you're probably correct
problem persists you can see that there
is an intercept until the world now this
is more like a proper application we use
multiple classes so if we would like to
in create logic at the runtime we could
just create a normal class and then
refer to that class at the runtime what
is I mean better and I'm sorry about
this because probably it will throw this
dialogue at us again but what you can do
you can have the conditional the
conditional interception so the same
example as before
oh no the conditional intercept device
much more interesting interception
strategy so the example is the same as
before but we just used a different
class here so if we look at that we have
the same intercept method but we provide
the method parameters talked to that so
this is one of the things that is
amazing about the bite body it uses
annotations and type annotations on the
parameters to provide particular and
inject particular arguments into the
parameters of the Mattituck hole so the
origin for the for the for the method of
the for the thing here we'll we want to
have the access to the method that was
intercepted and this is very important
that we not only we just can execute the
code dynamically and load the code
dynamically in the JVM and create that
at runtime but we also want to tie that
as strictly as possible to the code that
is in the application and use some some
some types or some some information
about what we're actually intercepting
or transforming in our code because
because of that well we can make
different decisions what we want to do
so if we run this third piece of this
amazing program here you would see what
we would expect we would expect the
intercept that will detect the hello
world from and then the method name of
the method intercepted so that should be
the to string
method we intercept the two string and
the information about that method will
come into the our origin hello world
class stupidity of Eclipse and indeed
indeed we see that what do we see worse
console we see that the intercepted
hello world from string has been held in
given to us and we can do more things
with that we can on that method this is
the normal just java.lang reflect method
we can say get declaring class and get
the ability TT to see what actually what
class we are intercepting and you see
that the method was declared in the
object because it was and then it was
inherited so my body provides you the
the reason for this example to be here
is that by body provides you the API to
to that mirrors what you would deal with
the class file on the source code level
and gives you type safe way to
manipulate that not only just like
create and manipulate and write byte
codes but actually very easy way to
refer to the actual code that Java code
that you have somewhere and and and use
that inside the Java agent so now when
we a little bit accustomed with the byte
buddy let me just delete this class I
don't like it
delete it shouldn't be there amazing now
we are ready to look at the actual Java
agent that is the agent that will do the
call loading call tracing so as we
remember from the manifest here we have
to look at the pre main class and that
would be our agent if we look at the
agent it is just a public class that
declares the pre main method with the
specified arguments that follows the
specification that follows the
convention how to create Joe agents and
then we we just execute a couple of
lines of code and then we create the
byte body agent
so the bite body allows you to simplify
the transformation logic with the DSL of
sorts so if we just want to create the
agent builder we will look at the
creation in a second but we create the
AI agent builder that is abide by this
class and we install that agent builder
onto the instrumentation API so it will
take care of registering the correct
transformers class file transformers for
you and you just need to take care of
writing the logic of the actual
transformation using the by by the DSL
so if we look at the create Asian
Builder here that takes the
instrumentation why does it take an
instrumentation not sure so we just use
the API and we say we want all the
default strategies and luckily enough
bide body counts is a very reasonable
set of the default strategies and we say
that we would like to transform some
classes and we would like to transform
classes for types that match the certain
element matcher to give so one of the
most important element measures four
types would be that you want to
instrument just a part of your
application so probably you don't want
to redefine the classes of the JDK
itself and probably you don't want to
mess with the classes of your Joe agent
when they are loaded so you you filter
what you want to work on and then you
say how to transform a class and by body
provides you with an advice API and
advice is something that will will give
a life cycle from IDE and implement the
life cycle for the methods
instrumentations so we just say oh we
want to create advice and we'll
reference my advice class and we would
like to impose that transformations on
all the all the members so this would be
another matter that says that for any
method that we we are trying to we asked
me if we should instrument it or not
we shouldn't rent so if you would do
something like this that requires just
adding code around the methods were
before the methods then you would just
need to create a proper advice and you
can see that advice class is super
simple
fairly simple it comes with the
annotations and you've seen that by body
it makes an excellent use of annotations
so you just have a couple of static
methods and you mark them that oh the
enter method I would like to specify
when the when the code is entering the
method and it can have access to the
class that is instrumented and it can
have the access to the method name of
the method and well currently we just we
will just increase the we'll use the
stack class this is a very simple class
will increase the intonation that we
will use for the logging and we will
print out the actual class name and the
method name that is entered and at the
same time when we exit the method we
would like to decrease the intonation so
when we run the Java program with this
Joe agent we would like to just create a
nice tree of the invitations so after
that after you have all that ready or
you download this from github and build
the own Joe agent what you need to do
you just need to avoid where's my cradle
you need to build this with a cradle and
then you will have the jar file that you
add as a Java agent add to your jar
process so we just say Joe agent Java
Java agent so if we call some kind of
class that is available somewhere you
will see that it indeed prints a tree of
all kinds of methods that just call each
other I can show you the source for that
it's it's not that particular
interesting I just
Just Cause methods on to class sample
classes VNA and they call the methods
back through the extension mechanism DNA
so but the thing is every time we
transformed you can see that when the
age of gel agent run we see the that it
can indeed transformed the classes and
then we when the JVM started loading the
class random class colon things we
intercepted that class loading process
and we need instrumented that and you
can see that immediately after that the
new code was the logging tracing
statements we was there and then at some
point later when the JVM started loading
two classes DNA we intercepted that as
well so this example shows both the
laziness of the dynamic loading the JVM
gives and how this particular Java agent
works so now having this code you can
very easily extend that to do whatever
you would like for example you can take
the timings how much method has taken at
the execution of certain matter has
taken because instead of just printing
out stuff you can store the timestamp
and then subtract that from the current
time on the method exit or he can send a
text message to the boss when some
inappropriate API has been touched or
you can do whatever your imagination
requires so yeah this was the example of
the code bye buddy
try to with the very nice DSL it
provides it was a set of annotation that
you can use to do almost whatever you
want to Rafael and releases new versions
of that frequently it's it's always has
the support for the upcoming job
versions so I think currently has Java 9
support making up as Java 9 is is being
baked up in the process as well and it
has great documentation so if you look
for the class file or bytecode
manipulation library by body is probably
the good way to go
know that maketo has recently changed to
using by body from whatever they were
using before so if we just go back to
the presentation you have any questions
about the code so the question is called
hard to undo the transformations the
transformations to undo the difference
formation you have to literally do a
little bit less than nothing so if to
enable the transformations which will
happen at the run time you have to
specify the Java agent parameter on your
common line so if you admit that then
your application will be load it as
usually and it will not receive any
transformations to undo the
transformations the question if you have
so the question is to undo the
transformation at a given runtime in
this inside the given Java process if
that's hard or not you will need to you
yeah I think it's it's harder than to
create the transformation initially
especially if you have multiple Java
agents running at the same time so you
stored the initial class files you can
store them right so and they have still
have access to them and you can call the
instrumentation redefine and say now I
want those classes to be this again and
that is possible and that is actually
quite easy yes
but I'm doing the transformations in the
sense that oh we modified this bit and
then that bit and going back through all
the changes again is not as easy so for
example if you think about that adding
code to the beginning at the end of the
every method is easy because you say
slap something on top add something from
the bottom when you want to delete that
and you just have like a code that is
given to you as just a byte code then
figuring out oh I have to delete just
those instructions is much harder but if
you have access to the original class
files that should be pretty easy
the question is if there are
transformers registered and if you
redefine the class the transference will
be called again that's a good point
actually so what you will have to do you
will have your transform it to be the
last image chain and just have the last
word that oh this is the class files
again and you can do that by saying that
Oh after this transform please do not
read transform the classes and then the
JVM will put that at the end of the
Transformers chain I think at least I
think it does so so I'm another question
well can the Transformers an agent know
about each other
that's a great question we you have to
make sure that they do so I really there
is no API that will say oh am I the
first Java agent and with the second one
but you will receive the classes and he
can query the runtime and say oh is this
class present just as like you would
usually do and you know if that class is
present and most probably class has been
transformed or you will have to like set
markers and you know add a field that I
am gyroball and I have transformed this
class and now it's transformed and then
you will have to make sure that
different tools work together and but
you can do all kinds of things and one
of the best thing about that is well
first you have one of the best yeast for
the Java agents is to provide seamless
integrations with the frameworks and
libraries that are already there so when
you don't have the chance to modify the
code yourself but you still have to make
sure that it integrates with your
application correctly you can provide
that missing functionality and kind of
make the library that you don't control
to conform to your interfaces or to your
idea how the API should be with the Java
agent so
for example adverts around what we do we
have to reload the classes to the
runtime and that there is a core thing
that makes use of that but then we have
to integrate with all kinds of
frameworks and know about their life
cycles and things so for that we will
need to create the plugins that know of
the library that we want to transform
and know of the library of those classes
and then somehow fix both that library
to the core so so they work together
well so in a sense for the use case of
the durable the Cornell's have reload
how to reload classes and the plugins
know how to reload the configuration for
the frameworks and they all work
together using a single interface which
is maybe a little bit specific case but
it's a it's a very nice example of how
to when you would use to Joe agents so
there are two main things first you need
when you need to add the functionality
to your JVM process without changing the
application itself and second is when
you cannot control the application in a
same way for example that could be a
proprietary well from probably
proprietary source is not the best
example because it might be incorrect to
do so under the license agreements and
everything but if you cannot control the
source of the library but you want to
make it conform to your expectations you
can use Java agent to to add that
missing functionality or change that
functionality for for yourself and to do
that you will either need to use a Java
cyst or by body or well jariabek
currently use the Java C for that would
love probably to make use of bite body
and you can shape the application
without actually changing that so once
you start using Java agents or you once
you've written a couple of those they
become a very powerful weapon that you
can solve any problem with so imagine
the power since you are below the
application level you are kind of you
can change how the JVM and application
interact and it gives you
amazing ability to do everything you
want so if something doesn't doesn't
look right for you
and you want to change that you have the
ability to do that on the byte code on
the byte code level if there are
multiple systems that you want to
integrate together and conform to a
single interface you are oh I will slap
a Java agent above that if you need to
find out what classes have been loaded
into your JVM and dump their byte code
while they were loading you can do that
using same tools but you also can create
a Java agent for that and when that
power is not enough for you and you're
like oh I would like to go deeper there
is a really cool thing you can go native
so there is a java virtual machine tool
interface and together with J&amp;amp;I and the
classes in the instrumentation in Java
line instrument package you can create
native Java agents that will have much
deeper access to the internals of JVM
you will have to write a little bit of C
code or C++ code I'm not sure both
probably both and the the thing will go
like that you will have your Java code
and you will have your C++ code that
implements the agent and the raw I won't
show the code because I'm not very
proficient with stars and ampersands and
the reference and operation but in a
nutshell it goes like that you have Java
code that you want to utilize from your
normal job agent of your application and
then it makes generate call to the C
code that makes use of gem MTI interface
that can do a lot of stuff for you so if
your Java developer this can be
simplified into you have the Java code
and then there are things that you have
to do probably following the tutorials
or documentation and simplify this C
code to the minimal and the benefits of
going negative is that you get really
cool operations that you can do you can
get you get access to threads so you can
stop any threats or thread groups you
can count threads so if you ever
if you ever imagined that you would need
to count threats and you're like oh let
me just use threat get all stack traces
dot lengths and you're like oh I have
that many threats in my JVM running no
you are not correct
those are your application threats so if
you count them through a native agent
you will get the garbage collection
threats and other things listed there
which is a cool bit of information
you'll get the heap operations which is
the mind-blowing power you will be able
to iterate the heap you will be able to
find all the objects of the given class
obviously that has the performance
performance repercussions and it might
be a little bit slow especially on
larger heaps but you can do that and you
will have access to breakpoints you will
get access to monitors and everything
through the native you will definitely
have to have some skills at writing C
code to make that actually usable but
once you were done that you can use that
from the java application and you
probably should not go native from the
scratch so probably probably if the
problem is there and you want to try to
solve that you can start thinking out
can I solve this with Java code first
and then maybe if you can't then
consider Joe agent and if you really
really can it then you consider it going
native but going with the this power
hammer on every problem would be not the
best problem so this is it
if you want interesting talking more
about Joe agents or the tools that use
Java agents you can either find me or
your own people by the booth at the expo
hall and he would get free swag or you
can just contact me and find me on the
internet and send me a tweet or you can
get the code for the Joe agent that we
lived here with the byte buddy
instrumentation going on on the github
thank you
we have would have two minutes and we
have a question so am i familiar with
project Lombok the dust also class
transformations but it doesn't use the
Java agent but it does a different thing
yes so Lombok is an amazing project that
can simplify your java code any is they
use annotations and annotation
processing to generate code for you so
you can put annotations in class and or
something or in the fields and they will
generate getter setters for you
so the code will actually go through the
method calling but you can just use that
as a plain thing and the yeah the I
don't think they are using a Java agent
they generate code during the completion
of phase this is the the yet the
annotation processing tool inside the
compilation process and it's a very
powerful tool as well but when this is
at a different SAP at the compile time
so with Java ancient will generate code
at the runtime for you
if I had know any library to help with
native Java agents I honestly don't know
so I've we have a quite small jaw native
damage and at work the power durable and
I've written a couple of sample Java
agents native but I don't know any
library that probably has to be like in
C and I'm not very familiar with that
echo system but if you want to start and
probably want to start small it's a
fairly simple there is a convention that
what functions you want to create and
there is convention what parameters they
take and the documentation is reasonable
so even not your experience then see
person like I could could make sense of
that so probably you have to do that
yourself or this is a great thing to to
try if you want to contribute to open
source 3
so the question
yes so if you the question is how you
would make your Java agent to use the
third-party code from a library so for
example I don't know yeah you want to
create Network also something and you
would like to use that from your Java
agent so you you have Java agent is not
it doesn't get the access by default to
the well it doesn't use the classes from
your application or from your class pass
because when you typically when you want
to load those classes you want to
transform them so what you want to do
you want to load classes from a
different source and not transform them
to use them yourself to totals from
other classes so there are two main
things how to do that either you would
like to specify the boot class pass that
will be provided and it will serve as a
class pass to the Joe agent as well or
what you want to do and the boot class
pass would be initialized for the
generation or what you can I do
you're gonna shade and shadow repackage
the dependencies that you want to use
inside your Java agent I think
personally I think messing with the boot
class class is not a very good idea so I
would repackage everything and many
tools that do repackage so for example
my body uses the ASM and think by the
body repackages ASM to include that as a
dependency so it's just a couple of
lines of code in your build script and
it works fairly well and then you
separate yourself completely from the
application which allows you to you even
kind of avoid very hard to find and fix
bugs yep thank you for coming
find me on Twitter and talk to me</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>