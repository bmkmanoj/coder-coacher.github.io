<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Modular Architectures Using Microservices | Coder Coacher - Coaching Coders</title><meta content="Modular Architectures Using Microservices - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Modular Architectures Using Microservices</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/P2E1o5AMwVg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everybody to the session about
modular architectures using micro
services I'll start with a brief
introduction my name is Marshall phones
i am the director at luminous
technologies which is a dutch company
with also a few foreign employees as
well nowadays we are mostly focused on
doing joint ventures with customers
developing technology for them and also
very active in open source and I'm also
a member of the apache software
foundation and there i'm mainly working
on Apache Felix seelix and ace the
agenda for today I'm going to start with
a short introduction of modular
architectures in general and then switch
to microservices try to do a quick 60
second or a little bit more introduction
of osgi and um dot 0 and then I'll end
up with a live demo I hope the demo gods
are with me today well show the
different mechanisms in inaction and a
short wrap-up at the end if anybody has
any questions while I'm talking just
raise your hand and ask them right away
or wait until the end I hope to finish a
little bit early to have some time for
that as well so let's start with modular
architectures modularity is really
nothing new it's nothing new in software
engineering and it's certainly nothing
new in engineering in general it's a
principle that is probably good to apply
if you're building any larger software
product make sure that you can keep
changing things right and in the long
term it also helps you to allow for
stuff like maintainability and also
important adaptability I mean these are
fairly
generic principles I guess they fit well
with a more agile approach of software
engineering in general and the benefits
of modularity they are most mostly long
term I mean there are some short-term
benefits as well but mostly when
products are developed over a longer
number of years you'll really see the
benefits of applying modularity because
it ensures that you can still change
stuff even a couple of years later
without having to worry oh if I'm going
to change this one thing here is it
going to affect my whole application is
everything gonna fall over and another
aspect of modularity is reused and we've
been trying to do reuse in software for
quite some time now probably the
best-known and maybe even the most
popular form of reuse is just copy paste
where we take some existing code or
maybe a whole project I copy paste it
and adapted to our own needs and well
there are some obvious downsides to that
because you're creating copies so code
is no longer in sync so you end up with
a lot of issues when you have to do
maintenance on search code already a
couple of years ago object-oriented
programming came along and it promised
us well if you just design your code
into these classes and interfaces you
can easily reuse those in different
scenarios and that will help you reuse
code in practice that didn't work that
well either classes often had all kinds
of dependencies there were inheritance
graphs so it wasn't that easy to just
take a single class and reuse it
somewhere else usually a lot of stuff
had to come along for that class to
really work and then more recently I
think we also looked at other
engineering disciplines we went to
component-based
modeling and reusing whole components
and components are a little bit more
coarse grained they're usually a set of
classes that work together that perform
some function and it turns out that it's
a lot easier to reuse such components so
that's probably our best bet at software
reuse still not going to be easy but at
least it's working a little bit for us
now so that's really short introduction
to modularity now let's move on to micro
services and probably good to first come
up with some kind of definition because
it's a fairly new topic and I stole the
definition from Martin follows website
who says a micro surface architecture is
basically a suite of independently
deployable services and there's a lot of
common characteristics in this
architecture and I'll get to each of
those in a couple of minutes it's
probably the opposite to a monolithic
architecture where you end up assembling
all your code into one big jar file or
ear file or executable and deploying
that but if you are using a micro
surface architecture there's a couple of
things that that are sort of aspects of
this architecture that I want to briefly
go into starting with so how are we
going to create these different
components and if you look at maybe a
more traditional software architecture
you often have a layered architecture
with at least user interface layer maybe
some application logic in the middle and
a database below and then you have
different components in each of those
layers and you also see that you more
often than not them end up with teams
that are specialized in doing front-end
doing application and doing database
that's not really in general the best
way of
approaching this modularity when looking
at microservices probably a better
approach is to more look at business
capabilities and try to use those as
your building blocks in an application
and that means that each component has a
little bit of you I may be some logic
and maybe some database in there and
there's an interesting law regarding
that that's Conway's law that says that
any organization that designs the system
will more or less design the system the
way the organization is modeled so if
you have an organization where you have
one you I team one test team one
database team usually end up designing
applications like that it also means the
other way around that if you want to
change that you probably also want to
change your organization to to reflect
that another interesting aspect is that
in this architecture each component owns
its own data so we no longer have a
single database underneath all these
components but each component has its
own database and can make its own choice
on what the best type of database
actually is for for this component so in
a lot of situations you end up with some
form of polyglot persistence where one
component might use a relational
database the other no sequel or
something else and if you are looking at
okay how am I going to actually break up
my application into components another
methodology to use there is domain
driven design and if you look at that
domain driven design has the concept of
a bounded context and usually it's good
to have a more or less one-to-one
mapping between these bounded context
that you have there and the components
another question that often comes up is
so what about transactions because now I
have all these different components they
each maintain their own data and now I
want to change something in two places
in two different
opponents and I need to make sure that
it Ida happens in both places or nowhere
at all so logical reaction is to dance
say okay I need transactions I'm going
to start a distributed transaction for
that and that way I'm going to make it
work but in general those two
transactions in cloud-based or order
systems where there's lots of different
nodes tend to not work that well the I
just lower the whole process down or
break another interesting way so if you
can always try to get a question over
there it could lead to a duplication of
both data encode depending on how you
split the code up and how we split the
data whether or not that's a problem
depends a little bit on a case-by-case
basis I mean in general for code it's
not that bad to have a duplicated unless
you need to maintain it in two different
places but there's ways to avoid that
for data sort of the same trade off are
they duplicated so more it's more or
less like you want to fully normalize
your relational model etc or not so best
option try to design your system so it
doesn't need transactions that means it
probably becomes a system that's
eventually consistent and you might need
to design different ways of correcting
mistakes so if you want to do something
in two places one of them fails you
might actually need to create some new
operation or event that corrects the
mistake a little bit later or in some
cases you might even get away with not
fixing it at all and just dealing with
the inconsistency another aspect is sort
of a shift from a more project point of
view towards more product point of view
and that's probably best illustrated by
the example in Amazon where they say if
you build some kind of component you're
also responsible for running it
and maintaining it and that means that
the team who builds it also needs to
make sure it keeps running in a
production environment so if the
component goes down they're actually
just going to call somebody from the
team in the middle of the night to fix
it I think that's for everybody a good
motivation to make sure that that never
happens it also has another interesting
side effect that it brings the
development teams a little bit closer
towards the customers because they're
actually more involved in how the
customers use these components and what
their needs are I already talked a
little bit about services in a modular
architecture and surfaces are the best
way for a component to expose the
functionality that a component provides
makes sense to version those services as
well so you can actually change them
later and do some reasoning about
whether or not a version of a surface
can be used by a certain component so
that's something to keep in mind and
services like components have their own
life cycle so they can be deployed
separately they can go up and down and
you need to actually make sure you can
deal with that and by only providing the
service to the outside you're
automatically also hiding everything
else inside the component so there's no
way to get to any part of the components
that's not meant to be used from the
outside then a little bit about
communication because we end up with
lots of different components and they
somehow need to communicate and there's
all kinds of different styles for doing
that and in a micro services
architectural you usually end up picking
either or both of the ones on this slide
either HTTP rest-based request response
or some form of lightweight messaging
there are also options like Enterprise
Service buses and other
early complicated mechanisms of routing
data through a system these things
usually don't end up in a micro services
architecture because the reasoning there
is let's just stick all the logic inside
of the components and keep the plumbing
between the components fairly
straightforward another aspect is being
decentralized and while we're
distributed so automatically a little
bit more decentralized but it also means
that because we have services that
abstract away all the implementation
details of a component it also means
that we're free to choose a
implementation for each component and we
might end up choosing different
programming languages to solve different
problems I'm not actually advocating
that we must use a different language
for each component but sometimes it
makes sense to pick a different language
it also means that you probably have
less standards that are global to the
whole application so you can focus more
on picking whatever components work for
that single components or external
libraries and things like that and
obviously we see a lot of people using
all kinds of open-source technology
there to make sure they end up with a
system that works well where in the past
maybe people were looking more at
choosing certain standards official
standards and making sure that they were
used everywhere in in the application so
because we end up with lots of different
components deployment becomes an
important issue and in fact beyond any
simple demo that you give about this
you're not going to be able to deploy
stuff by hand anymore bigger
applications might end up with tens or
even hundreds of these different micro
services and making sure they all get
deployed and scaling up and down
these things becomes more difficult and
has to be automated for for that reason
and that automation should start in your
development environment so you have a
continuous build system and that
continuous build system after running
all the tests should already start
deploying your applications to different
testing and QA environments where it can
then be further tested and eventually
the same mechanism should be used to
deploy systems to production so that
essential to use good tooling for that
and then there are some some design
principles that are important I touched
on them a little bit already the first
is to design for change I mean you're
already doing that by breaking a system
into components and the rate of change
the cohesion the coupling those are
factors that determine how to select
your individual components and which
things to stick together or not stick
together inside a single component
another thing is to to version whatever
services you have I already mentioned
that but you also see that people try to
make services as tolerant to change as
possible because you you might have to
change something to a surface API every
now and then but the bigger the change
the more problems you create for all
your consumers who might also need to
adapt to that change so if you can
design the surface in such a way that it
can cope with those differences then you
have a system that's easier to evolve so
in general I mean stay flexible the only
constant in a project is changed as is
the same for the world around us and
finally another design principle is to
design for failure you have a
distributed system many different
components and they can all fail they
can all be started and stopped
different times they can scale up or
down so you need to deal with failure
and you need to deal with changes in
services being available and that's
important always needs to be in the back
of your mind I'm talking to this surface
it might break what am I going to do if
that happens I'm not going to retry a
couple of times and I can just going to
tell my users okay I gave up I can't
perform this function now try again
later or something like that and in
order to see if your system is properly
working you need to also take care of
monitoring it and monitoring should be
something that you design into the
system right from the start there's some
some examples netflix has chaos monkey
which is actually a system that just
kills instances in production and make
sure that customers don't really notice
that so something like that is good to
do make sure you often have these
changes in your application these
failures in the application so you know
you can deal with those actively test
for that scenario and also do it in
production once you're confident enough
that it works in your testing
environment and famous quote by Michael
Jordan he made a lot of mistakes but he
ended up being pretty good probably an
understatement right so we're at a Java
conference here so I'm talking about
micro surfaces and all kinds of
different languages that we can choose
to implement them but probably a lot of
you are going to choose Java or at least
a language that runs on the JVM and if
we focus on Java four minutes then Java
already has a system for doing modular
developments called osgi and I'm not
quite sure how many of you are familiar
with osgi can I see some hands
reasonable then I actually might make it
in 60 seconds without Lou
in all of you so osgi is a framework
where you can deploy different modules
or bundles as they're called in osgi and
you can easily version them and deploy
them and upgrade them in a running
system these components are just jar
files and they can hide their
implementation details they can only
publish a known API and there's actually
a service registry where components can
publish services and others going to
look them up by default that service
registry works only in one JVM but
there's a standard called distributed
osgi that also allows you to publish
surfaces in a whole cluster of
applications and we're going to see that
later in the demo and for java at the
moment this is the module system it's
been around for more than 10 years it
might get partially replaced by jigsaw
once we get through java 9 will so have
to see how that works out but I don't
think jigsaw will provide all the
features that osgi have so I think they
will coexist in in Java 9 just a brief
look at how these bundles in OC I look
the jar files and the only thing that's
different is that there's a manifest
inside the jar file that contains some
extra metadata and here is an example of
that metadata and for example there is a
bundle activator in there and that's
more or less comparable to your main
class your main entry point you would
have in a normal java application an
activator is actually a class that has a
start and a stop method so it's a little
bit different than main because you also
can shut down in an orderly fashion and
that's really your starting point for
when you're coding
and other things in this manifest our
import and export package statements and
those you can use to share certain
things with other components other
bundles anything that you're not
explicitly sharing stays within your
bundle and you cannot use that so you
can export stuff you can also import
stuff and that will only work if
somebody else actually exported that and
if all that works out and there's a
resolver in oci that that make sure of
that then eventually it will instantiate
a bundle activator and run your code and
in this example the bundle activator
there's only one thing and that is to
publish a service in the service
registry that can then be used by other
bundles in that same vm i briefly talked
about remoting the remote services and
is actually a very simple example of
that let's say we have three different
virtual machines and they're all
configured in a cluster and there's some
kind of discovery mechanism that will
detect all these different frameworks
then you can mark certain surfaces as
being remote services and that's
literally just setting a property on the
surface and then it will be available in
all the other virtual machines so it
will be published and other components
in different VMs can see the surface and
can just invoke it as if it were a local
surface actually just install some kind
of stuff for that so it just seems like
a normal Java interface that you can
invoke under the covers it uses REST
calls to actually make the calls but
that's really an implementation detail
and you can even plug that out and use
some other protocol if you like that
better
so onto and Otto which is a community
effort to create all kinds of osgi
bundles that help you build cloud
applications maybe some of you have been
in the session by my colleagues this
morning that an Paul they have actually
built such an application this morning
but it's really just a website and a
open source foundation that provides all
kinds of components that help you build
cloud service so it has stuff to do rest
endpoints it has multi-tenancy it has
all kinds of database support like JPA
and no sequel Mongo and things like that
so it's really a place to look for
components if you're building this types
of application and the development model
that we use for it is that we of course
base everything on osgi so that's our
modular design that we use the IDE is
actually at the moment always eclipse
with a B&amp;amp;D tools plug in 2 duo CI
development at the moment the guys from
JetBrains are also working on providing
and same tool support for IntelliJ but
that's still in the work so available at
this moment we support a workflow based
on on gates and feature branches and
inside the indata project itself we have
atlassian tooling to automatically
billed to record issues etc our
automated deployment is based on apache
ace not going to talk about that in this
session that would take probably another
hour but that's our tool to automate
deployments in development and in
production and you can fully script that
too to create all kinds of deployment
scenarios and always cool we have a
greater based build and at least I think
that's cool so
that's what I wanted to talk about now
it's time for a demo so I'm going to
switch to to eclipse and add to of
course some kind of example application
I kept it fairly simple i created a
weather service where you can ask for
the weather in a certain city and it
will return some kind of prediction so
it's really an application with one
single surface and we have a client that
actually in folks that service but we
can split that in different nodes and do
all kinds of stuff like load balancing
etc so I'll start with the simple
application in a switch to eclipse here
so inside Eclipse I already set up my
project I'm not going to write all the
code because then i'll definitely run
out of time but I set up a project a
workspace with three different projects
in there CNF is more where all the
settings and dependencies are defined so
I'm not going to go into detail about
that I created a bit of launcher glue
codes to be able to quickly launch
different JVM instances and make sure
that they all run on different web
server port so I can actually run all
the demos on my machine have multiple
instances there and weather service is
the project that contains all the
information all the code that's more or
less interesting and so I'm going to
start out with just showing the code for
a simple client and server where we have
one surface and it's being invoked by
actually a client it's just a shell
commands that will invoke the service so
we always start out with designing the
API already said it's quite simple so it
has one single method to predict the
temperature in the future in some City
and that's in our API package and then
we have an implementation and there's a
bit of osgi logic in here to actually
publish a surface and that's being done
here where we set up the interface for
the surface and i already prepared it so
we can lay the use remote service as
well so there's a single property that
will make sure that this surface gets
exported to the other VMS and i declared
the implementation for this service and
i'll go to that and show you how that
works this that's probably a excellent
algorithm for determining the
temperature of a city I'm just going to
sleep for two seconds to simulate that
it's a really complex operation and then
I'm just going to take the length of the
name of the city at 20 degrees and
that's the temperature so excellent
stuff I hope so that's my second package
and the third is the client that will
actually invoke this surface it also has
an activator that sets up a shell
command and the implementation of that
is actually this class it has two
methods one whack and type city and
provide the name of a city and it will
invoke the service and just to show some
of the load balancing stuff i also
created the command that will ask the
weather in different cities and just go
over the list i have here at the top so
i can simulate some load on the system
so as a first step after i've written
such pieces of code i need to make sure
that the code ends up in bundles and for
this simple example I've split up the
code in three bundles i'm going to make
one bundle out of the API i'm going to
make a bundle out of the clients and i'm
going to make a bundle out of the
implementation of the service and if I
scroll down in the project you will
actually see there are different B&amp;amp;D
files these are more or less the files
that describe how these bundles are
built so we have an ABI bundle here and
it will just include the API package and
I gave it a name we have the client
which has the client package and the
activator so it knows what to start and
we have the implementation and nice
thing about B&amp;amp;D tools is it will
automatically generate those bundles for
you while you're developing and while
you're changing your coat so if I just
look in the generated folder i will see
all the different bundles here and i can
just use those to start applications
sure and even double-clicking you see
the manifest and the data that's in
there so it's not very much but that's
our bundle so my next step is to just
take all these bundles deploy them in
one single JVM just to test and see if
my application runs at all so no
remoting yets just all in a single VM
and for that I've created a be in the
run file
is actually a descriptor that tells how
to assemble an osgi framework which
components to install and here you see
the API the client and the
implementation and actually had to
install a couple of other bundles to
make this thing work some shell bundles
to create a shell so i can type some
commands some dependency injection
mechanism and a bundle with some extra
external api's and i can just run this
and i'll just run it in Eclipse for now
and see if it works so it's running here
I have a shell and like with any shell
that you don't know you can type help
and you get a list of commands and here
is my city commands and I can just ask
for the weather in houston and i get 27
degrees back from the surface
implementation that was running in the
same jvm so this is just plain osgi
nothing really special now let's split
up the application in two different
parts using remote services I'm going to
just make sure that I stop this one and
jump off my screen so that's better so I
created two other be in the run files
one for the client and as you can see
the client only has the API and client
bundle but not the implementation
anymore I have a second be in the Iran
file that has just the API and the
implementation and if I run both of them
at the same time I should be able to do
the same demo that I just did and for
that I'm going to quickly switch to a
shell environment and try to show all
the different shells on one screen which
is going to be a bit of a challenge okay
and I'll start with building all the
executable jar files using Gradle so I'm
just going to launch the bill that
belongs to this Eclipse workspace and it
takes a couple of seconds and then it
assembles all these jar files for me and
as soon as it's done I should end up
with a list of jar files and there's
some extra ones in there for the later
examples there's also the single
framework but now I can actually go out
and say I'm just going to start my
servers or I'll start my client here
first let that run take another shell
and run the service here and now i have
both of them running and i can even
check to see if the service has been
found on the client side which obviously
in a demo it hasn't when I want that so
when I do City i probably will fail no
it has discovered it while I'm talking
it always takes a couple of seconds to
do the actual discovery so what you see
now is only client I'm invoking the
service and you see the service here
printing out that it actually served
that call and returned it back to the
client and let's just start another one
because we can i'll add another surface
and well i can still type my command who
like that and it will still use the
first surface that came up let's see if
i can try and make it switch I'll just
quit this one so it's no longer running
back in the shell here I'm going to
invoke it again and now you see it has
switched to the other surface it had
both available and normally in osgi if
it has more than one surface it will
just invoke the first one all the time
so if we want to do something else we
need to come up with some kind of
mechanism for example to do load
balancing so let's go back to eclipse
and see how that looks so I've created a
simple load balancer here which is going
to be another bundle it has an activator
and this activator does something a
little bit special because it also
publishes a weather service but uses a
service ranking of 100 and service
ranking in OC is a mechanism that allows
you to say this surface is more
important than the others so if you have
the choice out of multiple choose the
one with the highest ranking and I use
this because then I can publish a
surface locally with a higher ranking
and have that implementation do the load
balancing and actually figure out which
remote service to go so this is the
component that implements that load
balancer and the load balancer actually
also needs to know what remote services
are available so it sets up the service
dependency with to call back methods and
these will be invoked whenever a remote
surface appears or disappears and this
is just a filter condition that says I
only want to see surfaces that are
remote surfaces so otherwise it would
the load balancer would also see itself
and we would get all kinds of nasty
loops where it tries to invoke itself so
that's a little bit of osgi set up to
make that work and our load balance our
implementation then looks like this
actually create a simple list and every
time a new weather service gets added I
added to the list and I do a print
statement so you can actually also see
that happen and when it is removed i
remove it and here is my implementation
of a very simple round-robin algorithm
for load balancing it will just invoke
each of the surface it has available in
turn and that's it I'm just going to
show how that works I'm going to go back
to my shell and I have still one
server running here I need to start a
new client because i had a new B&amp;amp;D run
file that includes the load balancer so
as soon as I start that one up I'll have
a client that has a load balancer and
then I need to also make sure that I
start a couple of services so we can see
the effect of that so let's go with
three different services and you can
already see it found two of them already
and probably in a second it will found
find the third one as well oh and it
won't I am yeah thank you very much and
now let's do our cities command which
will actually also temperature for many
different cities and the third one was
also discovered now and now you can
nicely see how it's round-robin style
asking each of these different services
for the temperature which makes the
whole list process a little bit faster
than when we had to wait two seconds for
each to complete and let's also try and
do it again and then stop one of them
kill this one and maybe kill the second
one as well so you can see it gets a
callback for that and it slows down the
algorithm and now the only remaining
implementation will have to deal with
all the calls I can start it again sure
from inning be quick enough for that
it's already mostly done yeah there's
still a few calls going to the newly
start at once
so that's a simple load balancer and I
can just start and stop instances and it
keeps working now that I have a load
balancer I want to make it a little bit
more advanced because I for example want
to know how quick each service response
because right now they all have a delay
of two seconds but in real life one
service might be a lot quicker than
another because it runs on faster
Hardware orbit because it has less load
in general so let's add a system to
measure sort of the quality of service
and let's just measure the average time
that it takes to do a service invocation
so for that I actually introduced a new
package and I will publish a service
called quality of service yep in osgi a
surface is really just a Java interface
but with remote services you can also
publish them remotely and then obviously
there's going to be some magic that
creates a stub on the client side uses
some kind of protocol to do the call and
then return the result
yep
yeah actually the question was so what
if you have rest surfaces and and how
does that map to this example in each
example I'm actually running northern
instance of Tomcat that of jetty but
that's similar so each each JVM has a
web server and that is actually handling
all the calls under the covers so I
created a second service called quality
of service and it can return the name of
the service the service ID which is just
a way to uniquely identify service in
osgi and more importantly if we can
return the average invocation time and I
also created an implementation for that
and this is actually all those two
things in here I'll start with the one
at the bottom what i'm doing here is
actually introducing what is called an
aspect surface and an aspect service in
oci is really just a interceptor that
you can place on top of any existing
surface and all calls to that surface
will first then go through the aspect
that you defined so in our case that's a
nice way to intercept all calls through
weather services and to actually just
measure how quickly they respond yet
another question
yeah so the jetty server running inside
the osgi framework can also be used can
also be accessed normally and used to
publish rest endpoints or maybe some web
interface or they're actually not all
running on the same port because I
created a little bit of glucose in my
launcher I didn't show it but it
actually seeks for a free port and
publishes it on a different otherwise my
demo would work yeah yeah I run into
that pretty quickly yeah so I'm
publishing an aspect so I can intercept
all calls to weather services and that
aspect is actually also going to publish
a quality of service service itself so i
end up with a couple of those one for
each weather service that it finds and
the implementation is actually a bit of
code that will just measure the
invocation time of any call to predict
temperature so this is the call and just
going to measure the system time invoke
the method and measure the time again
and then keep up keep some stats up to
date so I can actually calculate the
average time later and the average is
calculated here that's also no rocket
science but that gives us a nice way to
measure how quickly or slowly each
invocation is and let's add that to our
example as well so now we have a client
that uses a round-robin mechanism to
load balance and it will also measure
what the info average invocation time
for each service was so going back here
I need to start yet another client not
number three but number four
and I can leave the actual service
running because measuring the quality of
service is done in the client not in the
different servers because it's
ultimately to serve the client that
determines how quick the call is and it
can best measure that and it can also
measure network latency and stuff like
that that's a good question what if you
have multiple clients then each client
right now in how I implement this will
measure its own quality of service
because it might be different for a
client running in the US vs running in
Europe so it's always the quality of
service from the perspective of that
client but you could also do it
differently and do an average of all the
clients you have you have remote
services here you can make those calls
and discover those but that was a little
bit too complex for the example so
everything is up and running again and i
can again invoke my cities command it
will do some invitations and the other
thing that i did not show is that the
bundle largest deployed that measures
the quality of service also has a new
shell command that will allow me to view
what the quality of service for each
service was so i'm just going to wait
until it's done and then i have called
that average like that and it will
simply show me a list of all the three
different surfaces and the average call
time might be a bit surprised that it's
not two seconds for each of them that's
because I synchronized the method so if
there's multiple calls waiting they will
all block until the previous one was
done so he actually end up with slower
times if more things end up in the queue
yep
yeah actually when when I start up the
different servers on my local machine
each other looks for a free port and
binds to that and the discovery
mechanism i use is based on sob that's a
service discovery protocol and it can
discover anything on the local network
so definitely everything a local host
but yeah there's a little bit of
trickery to make sure that stuff ends up
on different boards yeah so now i have
the average for each surface but i still
have my load balancer doing round robin
so if i were to have one implementation
that is very slow and another one that
is very fast and i'm just going to
quickly simulate that i created a system
property delay that i can set i'll make
this one really quick like this i'll
make this one really slow
No
I'm not sure if this won't work
correctly to sell us a little bit
exactly ah
that looks better
okay I'll wait a little bit until
everything is started up again and i'll
type cities again and you see the shell
here whenever it gets a call it responds
really quickly and this one over here is
very slow takes about 10 seconds for
each call but yeah the load balance is
still using round robin so it doesn't
really take advantage of fast and slow
surface another question I forgot the
minus D somewhere lower left it does
seem to wait for 10 seconds so I have a
clue that it's somehow working the shell
is a little bit crazy with longer lines
in this small screen so i think i might
have typed it but it didn't display but
it's still processing and utrecht is
also tough to calculate and also is
coming have to wait a couple of seconds
so what i can do now i'll just let it
complete and switch back to eclipse is
to create a load balancer that's a
little bit smarter that actually takes
into account this quality of service
data that we have so created a new load
balancer it works more or less like the
old one but it uses the quality of
service data to determine some kind of
chance that a service gets selected and
the chance increases when the response
time is lower so show a little bit about
that that's this implementation it
actually collects all the quality of
service services to find out the
averages and whenever it needs to info
predict temperature it will randomly
based on a weight selection select one
of the implementations that available
is available so let's go back to our
example here and let's actually see if
that works I have to go to my next
client for that again that's this one
I'm going to run it need to wait a
little bit for it to discover all the
other services again I'm just going to
see try euston to see if yeah we still
have a problem now it's working and
let's now try our cities call again and
hopefully we'll we'll see it will select
the first one more often if I did it
correctly yeah it's starting to measure
and it's noticing that the one at the
top right is fast so it's redirecting a
lot of calls to that one and we actually
had a socket failure here that's all so
nice to see recovers from that so it's
not really a problem but there's still
one slow call here that it's waiting for
another slow one because initially it
has no data so it thinks all are equal
so it starts doing calls or some end up
in the in the buffer anyway but
eventually it figures out that this one
is really fast so if I wait for this one
to complete then run it again you will
see it almost exclusively will use this
service because it's quick
you see almost everything goes there and
it's dumb
I think I have time to squeeze in the
last one as well ok so I did one more
thing I said monitoring is important
measuring quality of service is a form
of monitoring but another thing you can
do is to have some kind of health check
for each node and you probably implement
that by actually making sure that
whatever runs on that note is actually
working but I had a very naive
implementation here and if you just
publish every node as a service you have
an easy way of finding out if all the
notes in your system are healthy so
using the same mechanism i created a an
interface again and i create an
interface with a name so i can
distinguish the nodes and i have some
kind of health check that i need to
implement that says yes i'm healthy or
no i'm not have a client so i can
actually again use a shell command to
find out which notes are healthy and i
have an implementation of that surface
and that implementation actually calls
an mbean and figures out what the
average load of the system was at the
moment and if it's less than three then
it's healthy and if not then it's not
healthy and that's not going to give us
a lot of real information here because
we don't have a lot of load in the
system because we're simulating load
with the sleep commands which doesn't
really give us any cpu but it shows the
principle so let me just start that last
example and for that I need to actually
restart all of them like this
I'll start the client here and let me
just start one here and maybe one more
here
and now I have a new command as well let
me check if it's actually in my list
yeah it's check and it will check and
see if all the nodes are healthy and at
the moment they are because if i look at
my system load all the way at the bottom
here it's less than three so if I load
up my system you would see that actually
going to report as not being healthy but
I'm not doing anything with that in the
demo okay that was all of the demo all
of the code for that is actually on
bitbucket also show the link in in a
minute it's also in the slide deck so a
couple of minutes to wrap up so just
looking at what we've seen I've given a
short introduction into both modularity
and micro services and a little bit more
than 60 seconds into OC I and I'm dotto
and I've actually shown how you can
develop and run a modular application
based on our CI and I've probably I
don't know if I've convinced you but
I've tried to convince you that osgi is
a good fit for building microservices
because it promotes building modules and
you can really make fine grained modules
and you have the flexibility to decide
how you're going to actually group those
modules into small containers and deploy
those containers and you can even easily
change your mind if you later think you
want to do that differently yep
the impact of performance of using osgi
probably the biggest impact you have is
when you start replacing normal surfaces
with remote services because the normal
service call in osgi is just a direct
method call so it has no overhead but as
soon as it's remotes going to be a lot
slower in general the overhead of the
OSGi framework is very small I would say
you only see a little bit of overhead if
you are actually deploying new
components and publishing new services
because then that will trigger certain
listeners and other components start
responding to that so that creates a
little bit of overhead compared to a
completely static application but other
than that it's very hard to even measure
that overhead I think so and the runtime
is I think 200k or something so that's
not that big either so okay any other
questions this is by the way the slide
with all the links I'll start there on
the left at the moment it's rest-based
and Jason so but you can plug in
different implementations for that so
you can change that if you want yes
yeah the client talking to the server is
all GI based on remote services so
literally you have a stub and that will
invoke a rest call to the server that
will be unmarked the OSHA I component
will be called and then the result is
sent back yep yep yep
I
yeah that's good question so let me
repeat it if you have a web interface
where you have a certain user logged in
and you need to make sure that they're
the context of the logged in user is
propagated properly throughout such an
application you're gonna have to
actually have to write something in osgi
for that because you need to make sure
that you can hold onto that context if
you compare it to a more traditional
java ee application you would probably
stick that in a threadlocal and retrieve
it that way that's obviously not going
to survive boundaries to other systems
so you need to make sure that you
somehow propagated and there's there's
different solutions for that probably a
little bit takes a little bit longer to
explain how that works but we can do
that offline I guess yeah yeah that's
the same thing yeah yeah at the back
yeah
so the question is why would somebody
choose osgi over basically many
different other options that you have in
Java drop wizard spring stuff so there's
many different different options out
there obviously that's going to be a
another black and white choice and I'm
not from the best and most independent
person to ask but I think the modularity
that osgi provides and the proper
versioning you have and all the ways of
dealing with the dynamism inside the oci
framework itself gives you a very good
basis to start doing microservices
because you're already doing all the
things that's required to deal with
failure to deal with version conflicts
etc yes over there
that's still possible you can still use
spring or other frameworks inside oci
and you don't need to do everything with
OSHA obviously so yeah okay I think we
ran out of time so thanks very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>