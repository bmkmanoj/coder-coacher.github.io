<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Laziness is the Ultimate Sophistication, both in Life and in Programming | Coder Coacher - Coaching Coders</title><meta content="Laziness is the Ultimate Sophistication, both in Life and in Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Laziness is the Ultimate Sophistication, both in Life and in Programming</b></h2><h5 class="post__date">2017-12-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jvH17AI7ncU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello there welcome to the keynote our
laziness the ultimate sophistication
both in life and programming my name is
Becca Subramanyam I'm gonna talk about
my excitement around functional style of
programming how practical is it to
really achieve that and how language is
like Java make it really easy for us
well we've been programming in the
imperative style most of the predominant
mainstream languages provide impetus
Tylar programming for a very long time
well in the impetus trail of programming
we focus on what to do but unfortunately
mostly on how to do let's talk about
this with a really small little example
a trivial example but nevertheless place
with illustrates the point really well
so let's get started with a little
example here here's a list of names half
of which we cannot see but I'm curious
either a friend Nemo in the list how do
we solve this problem well an imperative
style it starts with a ceremony right
off the bat so first of all say boolean
thousand is equal to in this case false
we want to then say for pick one name at
a time from the list of course and then
we gonna examine given each of the name
we're gonna ask you that name is equal
to well of course the word Nemo well if
it is found we declare the victory by
setting found equal to true but not so
fast you better remember to break out of
this as well otherwise we'll be cut into
process even after we found the result
which is not very good for performance
especially when we have a very large
collection but not quite done yet we
still have to come back and examine the
found and then we have to say output
Nemo found and celebrate about it of
course sadly we couldn't find Nemo will
then declare saying oh maybe that Nemo
was not found quite here in this case so
we'll say Nemo not found maybe play sad
music let's go ahead and run this code
and see yay good news we found Nemo
that's imperative style of programming
well I call this accidental complexity
because in the imperative style we focus
on what to do but also on how to do it
we could drag into the details of how we
had to take every single element we have
to compare the
element we have to set a flag and don't
remember to break out of the loop every
single piece is your responsibility our
responsibility when it comes to coding
in the style of programming so introduce
style of programming is where we get
pumped down with the details that
introduces accidental complexity makes
code really hard to change that's the
past
every single mainstream language did
this to us but it's not our fault as
programmers but we had to really work
with tools given to us and what's mostly
available and popular as well but the
good news is the future is moving in a
different direction almost every new
mainstream language today is moving
towards the functional style of
programming well the future isn't
decorated style and function of style
let's talk about technologies file first
going back to this example this was a
lot of ceremony a lot of noise to find
Nemo let's get rid of all the noise and
ceremony in this code right here and I
will just come down to the found right
here and change it to let's say name
start contains and then of course ask
for Nemo what all that effort we had to
put in is gone we can quickly come here
and get the result that's an example of
decorative style of programming so what
is a decorative style salt in the Tecla
relative style we can focus on what to
do and not on how to do it so we focus
on what to do that is our main focus
whatever we interested in so focus on
what to do not on how to do it well the
decorative style removes all the
accidental complicity in the code we
might ask the question how does
containers really do the work
what answer possibly is it's doing
exactly this we come up with all other
kinds of ideas as to how contains works
and different languages may implement
contains differently but I like a better
answer and that is I don't care okay
maybe that's a little rude but rather
than saying I don't care we can say it's
encapsulated well that sounds so much
better well meaning
I don't care well true we can all agree
that there are times we absolutely care
but the beauty with the Declaration of
programming is we can get to the details
when we care about it we don't care
about it it's not on our face in the
imperative style we have no choice
whatsoever the details are in front of
us whether we like it or not we have
absolutely no escape from the details so
in the decorative style we focus on what
to do not on how to do it well that's
decorated so think decorative leave
first functional comes next in
functional style of programming we are
also using decorative style functional
style programming is not new thank
goodness it's not new it's not a
newfangled idea invented last night it's
been around for a very long time
it's been tried it tested and been
practiced quite a bit it just was not
popular in the mainstream languages but
almost all mainstream languages now are
providing functional style of
programming which is really phenomenal
so this is a very old idea but with
renewed interest what are some of the
reasons for it well the world we live in
has changed quite a bit the type of
applications we develop the type of data
we process and deal with a lot of these
things are different from applications
we develop 20-30 years ago but what is
the charm of functional style of
programming let's talk about that right
here for that let's take slightly
different example here than the names
let's start with a list of numbers let's
say one to ten given these numbers I'll
say finally total of the double of even
numbers well great I want to find the
title of double of even numbers well
what's the imperative style do it beats
you down from the beginning isn't it
result is equal to zero for integer
element coming from the numbers
collection we then say if element Mar 2
is equal to 0 then of course we'll say
result plus equal to and then e times 2
and when we are done with this whole
thing we can display the output of the
result right here in the very end so we
can see the result is 60
that's quite a bit of work again an
imperative style of programming we will
switch here to a rather a functional
style of programming or what in the
world is functional style not all
declarative code declarative code is
functional remember the contains method
that contains method is declarative but
not functional but all functional code
is declarative so this is declarative
plus higher order functions so what in
the world is higher order functions what
decorated is where we say what to do and
not how to do it let's go to that being
real quick and see the example so it
started with an output right off the bat
number start stream per stream is a
fancy internal iterator what's on a
filter given an element element ma du is
equal to 0 so we get only even values
from the collection then we perform a
map to let's say double right here and
then in this case our map to intruder
map to end and we will go ahead and
double the element times two and once we
of course double the value will call the
sum off it and get the total of the
double of the even values when we run
the code notice the result is still the
same in this code example it is
decorated because we told what to do
grandpa from the some operating perform
filter perform mapping or transformation
of the data but it's high in order
because we are passing a function to
another function the highlighted code of
course is a lambda expression and
expressions are lambdas or anonymous
functions we're passing a function to
this filter method or filter function so
in higher order functions we can pass
functions around we can pass a function
to a function create a function with our
function even return a function from a
function those make in higher order so
this line of code is functional meaning
it is declared a plus higher order on
the other hand similarly this one is
functional as well but this one is
purely declarative so this of course is
focused on telling what to do we're not
passing any functions to these functions
and
basically the functional style of
programming but what's the charm of a
functional style of programming the
charm of functional programming is
highly expressive code so the code
becomes a lot more easier to work with
easier to write let's look at one
example of this to see how beautifully
the code begins to flow I was teaching
the Java eight cores for a client and
they have been using Java 8 already and
what if the developer said can you take
a look at our code and critique it
usually I get scared when people ask
this question what if the code is really
highly complex and I cannot understand
it I don't want to insult them by saying
anything well in this case the code was
written using Java 8 streams I just
started reading the code and even I who
doesn't have any understanding of their
domain was able to quickly understand
what they were doing that's one of the
biggest charms of functional style of
programming let's start with a create
people list right here and given a list
of people let's say I want to go ahead
and store that here into list let's say
person people is equal to create people
but I want to find the names let's say
get the names all in uppercase let's say
and then of course of everyone who is
younger than 18 oh that should be easy
isn't get the names in all in uppercase
of everyone younger than 18 well we
could start again with the list string
over here so we could say string and we
could say juniors just to call them as
juniors or kids if you want to call them
kids though 17 year old may really
object to it but let's call it as kids
is equal to new arrays and in this case
ArrayList and we create an empty list
look at the ceremony again we're
spending time telling how to do things
and then far a person and given a person
coming from the people collection and
what are we going to do with every
single person we say if the person d'art
get age is greater than well less than
18 then of course we're going to say a
kid start and well then of course get
the name of the person get name and then
to uppercase
and then of course added to the kids
collection when they're done with that
we'll go ahead and I don't put the
values for kids and quickly glancing at
this we see that there is Jack Jack what
are the Jack's and Jill who are less
than 18 let's see if the court produces
that result and sure enough it's Jack
and Jill but if you look at this code
there is a few different there are few
different problems in this code it's
verbose to begin with
second it lacks cohesion what in the
world am I talking about well look at
this one line of code it's doing one too
many things it had to get the name it
actor turns for me to uppercase it had
to Hat to the collection that's a lot of
work and of course that somebody comes
along and says it's a very long list
make it parallel you're gonna find the
nearest exit to get out a lot of work to
make this chord parallel of course but
we can save a lot of effort by going
functional on this that's the charm of
functional the style so what is the
charm in this example we can now again
start once once more output but this
time we would start with people
collection I don't look at the stream
again
we'll do a filter given a person will
simply say person dot get age is less
than 18 but then we'll perform a map
would say given a person give me the
person dot get name right here or as we
would do with refactor this to using
method references in just a minute we
can then say given a name we'll say name
to uppercase right here and then once we
get the upper case we can say collect
and we will collect it into a nice
little list if you will so here is to
list and of course to list comes from
the collectors of utility method so
we'll say collectors and right there is
the to list coming from the collectors
let's go ahead and run this code and see
what it does and of course in this case
given a person I should spell it
properly here is a person and of course
go ahead and run this code and see
that's a jack-and-jill but look at the
function composition we see right here
give it a collection of person
we get all the people in more than 18
get their name convert to uppercase and
put it back into a list it becomes a one
flow to top to bottom we don't have to
go back and forth to understand there is
no need for the breaks and continues and
all that thing we do it becomes a lot
easier of course we could take this one
and say string colon colon and use a
method reference as well and likewise we
could use a method reference here do so
we can save quite a bit of effort and
reading this code and make it really
elegant if you want so in this case of
course given a person we are going to
get the person's name and then we're
going to convert it to uppercase and get
the result this function composition is
extremely compelling and so that's one
of the biggest benefits we can out of
this but of course the question is
what's the catch
that's what intelligent programmers
always ask what's the catch well let's
talk about the big elephant in the room
I've never walked into a client site
where the minute I talk about Java 8 and
functional programming the immediate
question is gosh but what about
performance performance is something
extremely important but it turns out not
all languages are created equal
let's just take a detour and take a look
at Ruby real quick before I get started
though on this I want to emphasize one
thing I love Ruby I don't want me saying
negative things about a language to be
taken as a hateful comment I'm I'm
objective I want to show good things and
I want to show not-so-good things as
well in fact I would even point that
about Java 8 in the end I love Ruby I
use Ruby extensively our god
applications I maintain in production
using Ruby as well as much as a lot of
other languages however from the
language point of view I looked like to
learn from what the strengths and
weaknesses of languages are the
strengths of Ruby is pure elegance it's
beautiful
no ceremony so it's a really good
language for a certain type of things we
do kind of like a bicycle versus serve
rocket if you want to think about it
that way there are planes when
rocket is maybe the right vehicle to use
a lot of times bicycle is awesome to use
and I want to be able to pick and choose
what may make sense let's talk about
Ruby real quick so here I'm in the Ruby
source code let's talk about a little
transformation I want to do let's do
numbers is equal to and I want to save
one two three maybe a few numbers right
here I don't want to take these numbers
but what do I want to do I'm gonna say
find the first let's say what find E
let's say double off are all even
numbers so I want to find the double of
all even numbers well that shouldn't be
really hard to do is it well if I want
to find the double of all even numbers
I'm gonna just take every number fine
which is even double it and then of
course you know total it well okay
that's not really that hard but to
change the problem a little bit what if
this collection we're to have our
different values along the way say maybe
some things along these lines I'm gonna
change it to some arbitrary values that
I'm going to work with so in this
example of course I've got a bunch of
different values but find that let's say
find thee a double let's say double and
off the first number a greater than o
let's say in this case greater than what
of 50 so I want to find the double of
the first number greater than 50 so how
would I do this well we are like
function of style of programming it's
charming it's beautiful its elegant how
easy it is to understand the code and
Ruby has been supporting the functional
side of programming as much as
imperative style of programming from day
one so in that sense Ruby is beings been
doing what Java has been recently doing
providing both imperative and functional
style of programming well let's give it
a try so numbers dart map just like how
we used a map function right here for
transforming we could use a map function
oh but wait a minute we want numbers
greater than 50 isn't it so we could say
we could say filter
and give an element over here so here is
an element this is Ruby syntax we could
say a greater than will say is greater
than well is greater than in in this
case 50 and we're going to ask if it's
greater than 50 for this particular
element so we'll go ahead and write that
function e is greater than 50 given a
number n I want to simply return this
value will say return n is greater than
50
how charming that's great then we'd say
a map function in this case of course
given an element we will say we want to
double the element so we'll double the
element right off the back so this
requires us to write a double function
which takes a number n and all that it's
going to do is return n times 2 that's
awesome so far but remember all I don't
I don't want all of the values I want
just the first value and we will of
course print this result when we are
done right here so let's say puts and
ask it to print the result so let's go
ahead and try this my number 13 has an
error we'll fix it so in this case
numbers in this case of course we gonna
say find are all we're gonna ask for
every single value and then double it
well find out is equal into our filter
right here in Ruby well the first number
that's greater than 50 is 54 so the
times 2 is 108 we can see that so that's
doing the work but remember in this
example we really wanted the first value
that meet just meets the criteria but
how much work did Ruby really do in this
particular case well it turns out ruby
was very eager it did a lot of work so
if you go over here and print if you
will in this case we'll say e is greater
than and then we'll print the value that
we are asking for and then we'll go to
the double and then ask it to print the
result of double and then of course
specify what the value is
notice all the processing we did we
computed we checked if every single
value is greater than 50 all the way
from the one to the end 20 then we
doubled all the values greater than 50
54 61 77 98 and finally we discarded
everything and just get the first value
what a waste of performance nothing is
great for what it does but what if I'm
dealing with a large amount of data in
some projects I'm working with we are
dealing with literally millions and
millions of data this would not work
really well in such situations isn't it
so what really attracted me to Java 8 is
not the fact that it actually has the
function of style of programming in all
honesty I kind of discarded what Java it
provided to begin with because I said
what's the big deal other languages have
lambdas Java now has lambdas why should
I care but I found there's a lot more
than lambdas in Java 8 and that's what
really drew me towards Java 8 elegance
is very useful we would not discard them
beautiful code is great code that is
expressive code that is easier to
communicate with awesome that's great
but performance is critical give me four
famines or give me death is probably a
slogan we can all say so elegance in the
admins of performance is not gonna scale
really well so what gives what we do are
we doomed with this kind of programming
then where we can have either
performance or we can have elegance but
not both well it turns out that's not
entirely true
let's look at other languages to learn
from let's turn to a truly functional
programming language Haskell I really
love Haskell for what it does let's take
a look at Haskell really quickly if you
look at Haskell right here I'm gonna
write a method call a function called
add a B equals a plus B so in this case
it's gonna return the result total of a
plus B but these functions and hostel
are known as pure functions now we write
an evaluate function when it takes a
value and returns a value and of course
I'm gonna write a main function which
has a side-effect
I put an equal right there and then I'm
gonna say rent and the print is going to
print evaluate let's go to print add one
and three what I run this of course it
says four however in this example I have
still had to do all the work
unlike a lot of other languages applies
what is called by normal order while a
lot of of other languages are languages
including Java use what is called
applicative order so what in the world
is the difference between those two
normal order is quite abnormal as you
can see not a lot of languages do this
is the evaluation of the function is
postponed untilled the value of that
evaluation is actually needed in this
example ad is not going to be called
until we step in to evaluate so if ad is
not needed at all it would never get
executed let's prove this in this case
I'm gonna show that ad is going to be
actually called well I can't put a print
statement in there because prints are
side effects so what are we gonna do
here well the way we'll work through
this is to bring up the GHC I the
compiler and I'm gonna load up the
Haskell file into it I'm gonna put a
breakpoint on line number one character
16 and I'm gonna ask me to be evaluated
notice it stopped on line number 1 when
I say continue now you can see it
produce the result of 4 so I just proved
that it executed the add function ignore
that we'll come back to it now let's go
back to the score and simply return at
42 now when I run the code it produced
42 but how has still is smart a normal
order it says I don't have to evaluate
ad after all because you're never using
the result of ad that's only possible
when functions are pure I'll talk about
that in a minute so because of that ad
is never evaluated in this example let's
prove it so let's go back here and run
the Haskell GHz I Rapala gain let's go
ahead and say in this case put a
breakpoint on line number one character
16 but called main this time and notice
it never stepped into the function and
that's because hostile says there is no
reason to evaluate that method add a
function and because you're never using
the result of it
that's efficiency is entered efficiency
is
avoiding work that shouldn't be done in
the first place you don't want to be
fast you want to be efficient when
you're efficient you're automatically
going to have better performance because
you're not doing unnecessary work so how
is this even possible how would a skill
do this that's because we have what are
called pure functions so what are really
pure functions we are functions give
exactly the same result as long as the
input is exactly the same every single
time pure functions will never give us a
different result for the given subset of
input we are functions don't have any
side effects so when you run the
function you wouldn't know if they ran
or not anyway matter you wouldn't know
how what their effect was because they
have no side effects so they take an
input they give an output if you don't
use the output it doesn't matter it's as
if they were never actually run so what
are benefits of pure functions the first
benefit is their idempotent you can call
them any number of times for example you
call your bank and say what's my balance
and then immediately what's your balance
assuming it didn't really deposit any
money I would draw the balance will be
the same in this particular case usually
that's not an idempotent operation
because the money in the bank keeps
changing in a lot of cases keeps
decreasing frustratingly but the point
really is it keeps changing so
idempotency is when you can do the same
work repeatedly and gives the same
result like the add function
preferentially transparent you can call
a function and you can replace the
function or expression with its value so
for example in this eggs in this
particular case has to put I have
decided to replace this add 1/3 with the
value of 4 if it wanted to it could do
this and that's referential transparency
in fact Java compiler does that but it
knows that the functions are evaluations
expressions are pure it's easy to
memorize the result memorization is
storing them so you can put them into a
cache and say the next time you call
this function I won't evaluate it I'll
just give you this result back this is
used in what are called as dynamic
programming problems an algorithmic
approach where we use excess amount of
recursion but we save
performance by memorizing code is easier
to test as long as the input is the same
output is the same don't have any
external dependencies awesome
that's the dreamland for really having
ability to test it very easily and
finally of course it's easier to
paralyze the code as well you can throw
concurrency into a pure function because
it has no side effects it's not going to
run into any race conditions and mess
with some shared global mutable state
and it's not gonna be affected by state
outside as well but for our purpose the
most interesting part here is it can be
lazy so it can take it easy and wait
until it doesn't have to execute it or
until the last responsible moment
laziness is the real charm in this case
and what you just saw here was Haskell
being lazy about implementing the add
functions of evaluation so it postponed
it long enough that it didn't have to do
it at all other languages that use
applicative order eagerly evaluate those
things but like I said not like law
language that weird equal haskell faults
on what I call a save the false it
assumes all the functions are pure
unless otherwise stated like we're just
like Java Scala and so on rely on you
know fearing that functions are mutable
unless otherwise stated so let's talk
about Scala just for a little bit let's
go to Scala real coin I'm going to
create a function right here called and
compute this takes a value int and it's
going to return let's say n times 2 well
I'm gonna go ahead and say Val X equal
to 4 if X is greater than 5 and compute
a for let's say is greater than 10 I
want to go ahead an output print 1 let's
say result 1 otherwise I'm going to
print out let's say a result 2 when I
run this code the question really to ask
us is color gonna run the compute method
we all know the answer foreign compute
will not run Y so that's called
short-circuiting hey great shot securing
is another example of laziness
it doesn't evaluate compute unless this
one turned out to be true after all
so we know that conditionals have shots
of queuing and laziness in place so if I
go back here and say called right here
you will notice that it was actually
never called that's awesome but what if
we take this out of here and call it him
and we say over here valid temp is equal
to compute sadly though this time how
what were when you run this Scala called
the compute method should it have called
no of course not we're not using the
result of compute but Scala evaluated
compute eagerly why did it really do it
the reason is Scala is worried that
compute may have a side effect but wait
a minute
it had a side effect a minute ago when
we called it with compute right here so
why did it not call it here but why does
it call it now the answer is very simple
language spec the language
specifications rule language
specifications say even if a function
were to have a side effect we will make
we may not call them if those are in a
short-circuit situation so language spec
language say is there you know times we
will call methods if they have side
effect here are times when we may not
even call it even if it has side effect
so it really boils down to language
specifications and in Scala chose to
call methods unless you are using in a
short circuited situation are you
predominantly tell Scala it's okay by
marking it as lazy by saying lazy you
are saying don't bother running this if
you really don't need it as you can see
in this example if I change it to a one
you will notice that it did call it but
if I put a five here it doesn't call it
that's being lazy as we can see really
beautiful as ended so you
have these tweaks and languages which
you can use to control whether the
language is gonna exercise something or
it's not going to exercise something
very powerful as you can see but what's
really special about Java though well
Java has been predominantly a imperative
style an object-oriented style of
programming language so this has been
our experience in the past so when it
comes to Java 7 and earlier we did
imperative plus object-oriented and
that's been the real mode of programming
in Java itself but starting with Java 8
what we can do is sure you can program
and later let's say Sheree can program
an interactive style if you want to but
you can also do functional +
object-oriented with the hope that we
will do predominantly a functional
rather than object rather than
imperative rather so the real culprit
here is not object-oriented the real
culprit here is the imperative style of
programming by replacing the imperative
with functional we could still use
infrared if you wanted to but we have
the ability to replace at ports we can
get some really good benefits and the
benefit as you can see in this case is
that charming feature of how we could do
this in the function composition style
but before we talk about this though
let's talk about one benefit and how we
can achieve that benefit so the real
charm here in Java 8 is that Java 8
actually does something a lot more than
providing just a functional style of
programming Java did not walk away
saying here are lambdas good luck what
was right in the Java 8 book I don't
something in the book which really
surprised me that even I wrote it but my
statement was that lambdas of the
gateway drug but streams are the real
addiction so the point really is that
the lambdas really draw you in
but the streams are the ones that are
going to keep you and because if you
don't have performance you're gonna
leave as soon as you come in but how do
streams give us performance let's talk
about
real quick let's get back to this
example real fast and understand a one
key difference notice that an exam in
this example we have stream a stream is
very different from a list let's talk
about these two for a minute put the
word list down for a second and also for
the word stream list is concrete on the
other hand stream is an abstraction yeah
what does that really mean
list is a container well this is a
series of functions that still doesn't
ring the bell think of the word bucket I
can have a bucket with a pile of water
the bucket contains water in it I can
store the water in a bucket I can come
back and use the water stored in the
bucket list is a container we store
stuff into it a stream on the other hand
is a pipe it liquid flows through it
data flows through this pipe it's not
for storing things it's for transforming
and moving things a list is a container
like a bucket a stream is a series of
pipeline of functions to transform the
data along the way so in that regard
what is that what does it really mean to
us what it means to us is a streams a
series of transformations to understand
this a little bit better let's go back
to another example we saw earlier and
then we will relate back to this real
quick let's bring back our sample dot RB
code right here and take a look at the
Ruby code one more time if you look at
this example watch carefully the
execution path this Court took it
executed the is greater than function on
every single value so what did Ruby do
apply the first function on the entire
collection then it said apply the second
function on the result collection so in
other words that's eager
keep that in mind we'll see how Java
does things very differently in the case
of Java Java is assuming that the lambda
expressions are pure this is one big
difference between Haskell and Java has
got a bit boring in my opinion Haskell
will come back and beat you down and say
you will not mutate you will not have
side effects
Haskell will emphasize and verify and
confirm and follow you home sit next to
you stare at you and say it better be
pure Java is a lot better in my opinion
for that reason because Java assumes
that lambdas are pure what happens when
a language assumes things when you and
Java disagree you know who wins so this
is one of the reasons why if you
programmed in Haskell you'll go home on
time and your kids ask you how does that
work mom and you're gonna say it was
pouring everything I wrote word there's
no fun on the other hand you already
code in Java and maybe you forgot that
these lambdas are pure you go home late
after a very tiring day at work and you
go home and the kids ask you how was
work how was the day and you say let me
tell you all about it we had a monster
we had to tackle and other stories to
tell that's one of the reasons why I
love these kinds of languages okay I'm a
little bit being kiddush here but the
point really though is don't forget Java
may not really warn you may not give you
a error if you make mutations in lambdas
because Java assumes lambdas are pure
the purity gives us laziness we talked
about so streams are inherently lazy so
what is the benefit of that approach
let's talk about this now as different
in Java versus language like Ruby so in
the case of Java the a collection of
functions are applied on each element as
as necessary so in
of a function being up being a flight so
being applied applied upon each on the
entire collection so let's revisit this
one more time in the case of Ruby a
function was applied on the entire
collection not so in Java a collection
of functions are applied on each element
as necessary so what Java does is it
takes these functions these are called
intermediate operations so intermediate
operations and these of course are
called
our terminal operations so in the case
of Java
it'll take all the intermediate
operations and what does do are fused
together so it is going to take all
these intermediate operations and it's
going to fuse them together into one
collection of functions it dem applies
the collection of functions on each
element but only as necessary so to
understand this a little bit better
let's take a look at a slightly
different example here and work with it
so rather than asking for all the people
who are younger than 18 and their name
in uppercase let's say we want only the
first one so we'll go back here and we
will simply say dart find first and what
if we don't have a value what are we
gonna do would say our elves will say no
one found so when I run this little code
now you can see that it produced Jack as
the result of course in this case we can
go back and remove this operation right
here
that's the imperative style and we will
simply use the function of style code
right here an except Jack well it found
the first value in this collection in
this output let's go back and remove the
commented out code and run this how does
this go really work well imagine you are
at work and on
the 15 the boss calls you and says I can
produce for you
you got a project you're gonna start on
it and it's due on April the 15th do you
come out of the boss's office on January
the 15th and start on it right away of
course not
you will start on it promptly on April
the 14th isn't it because it's due on
the 15
that's called efficiency well the point
really is we don't do things until those
become relevant and imminent in fact if
you know you're gonna quit on March 1st
why would you even start on this any any
sooner than that the point really is we
have by not doing things you don't have
to do right now you are able to focus on
things that have to be done right now
and if things are not relevant
eventually you don't have to do it and
that's called efficiency so I'll find
somebody was really really busy and give
them work and they get done but how
because they prioritize and they don't
waste time doing things that are
unnecessary that's exactly the point is
that you want to be efficient in what
you do not just simply faster so both
wise and in programming laziness is the
ultimate sophistication as we can see
here let's prove that right now so when
you run the code you see you got Jack
but let's go to the person class real
quick in the person class I remember we
asked for the age first and then the
name so let's go to the age function and
we will output right here get age called
for and in this case we'll output the
name of the person likewise we'll go
ahead and say in this case then name
itself will say get name called for so
this will be get name for then of course
we'll print out the neat and details of
that but if this were eager remember
what happened in language like Ruby
it was eager and executed the first
method for every single thing if John
was eager it will ask for the age of
every single person including this jack
and this Jill however in this particular
case because jack is the result we
looking for it we'll never have to touch
this tack and this joke may not be such
a big deal in this case but what if this
were a million elements a lot of
elements after this one we don't want to
evaluate them once we find a result so
in this case the get age is going to be
called on on what it will be called on
Sarah Sarah Bob para Paul and Jack
however there's one big difference
though it's not going to call the get a
john all the elements first again if you
go back to this example and run this
notice that evaluated YZ g t-54 all
elements only after that it started
evaluating the double function not so in
Java it evaluate the group of these
functions as necessary on one element at
a time so I run this code notice it
called get age on Sarah Sarah Bob Paula
Paul Jack but then it calls get name on
Jack but it never touched the second
Jack and B and the Jill hmm doesn't
quite illustrate what I wanted to show
here yet isn't it let's try a little
different example let's say I want the
first person who was older than 20 but
it was also a female older than 20 well
that's Sarah but also a female that's
Sarah - let's make it all in the man 30
that'll be this Paula great so let's
evaluate that
so get H is greater than 30 and then I
want to say that filter in this case of
course and we want to say given a person
will say person dark get gender and in
this case of course is equal to gender
dot female when I run this little code
let's go ahead and comment these out for
just a second we'll come back to this
and we will go ahead and put the print
children the gender as well so we can
look at it to here so here is the Jo get
gender so we'll say get gender call for
so
and then of course the name let's go
ahead and run this real example that's
Paula if this were eager you were asked
for age of everyone gender for everyone
or than 30 name of everyone older than
30 and female convert all the names only
to throw away most of the work but not
so in this example if I go back in
uncomment these print statements though
what you notice right here is that when
we Wonder's look at the sequence of the
output it called get a John Sarah it
called get 8 on the second Sarah it
called on Bob and Paula then gender and
Paula name are para and done if I were
to flip this over asking for all the
females first and then the age then you
notice it asks for gender on Sarah and
age on Sarah right away gender innate on
the second Sarah right away gender
gender on Bob and Paula age on Paula and
Mayman Paula look at only the first four
lines for me notice get gender get age
then again get gender and get age then
again get gender in other words unlike
Ruby where all of the methods of one
line were executed eagerly this is being
absolutely lazy it evaluates a little
bit of the first function and the second
and goes as long as it can go in other
words it fuses these functions
collection of function apply on one
element Sarah and if necessary on the
second and the third but the minute it
finds the answer it no longer applies it
in fact let's go to the next level to
see how laziness really plays a role in
here if we were to go back to this
example and let's remove the print line
for a second and in this case I'm going
to go ahead and say done right here when
I execute the code you can see all that
output and they're done however if I
were to go back and comment out just the
last two lines over here then we're not
calling the terminal method we have this
collection of this terminal functions
fused together but we never call the
terminal method it's a terminal method
that triggers the evaluation as you can
see in here the result is simply done it
doesn't really execute all the
intermediate functions
it's absolutely lazy I've been working
on a project where we are dealing with
literally millions and millions of
pieces of data we've been running it
through the functional pipeline through
lambdas in fact a lot of lambdas and
we're not seeing any performance
degradation due to lambdas or due to
pipeline in fact there's a benefit we
get right off the bat not only can we
have efficiency through lace evaluation
we can also paralyze the scored also
more easily to get there as a faster if
we have a lot of data to process so in
other words the function of style of
programming is very charming the
function pipelining
is beautiful it removes the accidental
complexity from the code compared to a
imperative style code a function of
style code is a single pass through the
code begins to read like the problem
statement we can relate to what the code
is doing and we can quickly understand
it it removes that accidental complexity
and makes the code easier to understand
the code is cookies every single line of
code that's one thing only this line
checks if a person is a female or male
this checks if the a age is greater than
30 this gets the name this transforms
the name to uppercase compare this to
the previous code we wrote where a line
was doing multiple things lack of
cohesion this one is easier to remove
some pieces or to add some pieces it's
cohesive a cohesive code is easier to
modify the code removes the impedance
mismatch of trying to figure out and
extract the details of business logic
from the code the code becomes the
business logic the code becomes easier
to
understand and see what it's doing but
of course we cannot claim all this
beauty is great but we can't give
performance so to me what really grabbed
my attention in Java was not the fact
that Java has lambda expressions have
you slammed as in other languages Ruby
groovy Python to name a few and Scala of
course in closure and so on however
these all these beautiful function
pipelining and expressive code these
things we can only frame and celebrate
but can't really use on big projects and
big data projects if the language does
not support lazy evaluation so the fact
that Java supports laziness is one of
the most charming features streams are
really powerful but there are
limitations to stream as well in Java
Java streams unfortunately don't handle
exceptions really well and if you really
want to do powerful streaming there are
other things you can do for example the
reactive programming model observables
and flow those ideas are not very
different from streams just the streams
implemented in Java has a few
limitations we do use streams quite
extensively when we don't really have to
worry about those limitations depends on
the case but just like I said languages
are created different one of the reasons
I got really excited about Java was not
the fact that Java has lambdas what
really got me who don't Java was that
streams are lazy in fact it's the
laziness that drew me into Java 8 and
I've been singing its praise ever since
if Java had not implemented laziness
into streams API we wouldn't be talking
about and getting excited about Java 8
and so I'll conclude by saying laziness
is the ultimate sophistication both in
programming and in life hope that was
useful thank you
you
you
you
you
you
you
you
you
you
you
you
you
you
you
you
you
you
you
you
you
you
you
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>