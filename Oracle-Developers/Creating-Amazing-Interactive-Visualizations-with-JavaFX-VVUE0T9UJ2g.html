<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Creating Amazing Interactive Visualizations with JavaFX | Coder Coacher - Coaching Coders</title><meta content="Creating Amazing Interactive Visualizations with JavaFX - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Creating Amazing Interactive Visualizations with JavaFX</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VVUE0T9UJ2g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to the session it's about
creating amazing interactive
visualizations with JavaFX the agenda
for today is we briefly talk about
interactive visualization in general and
while we choose Java X and then the
first type of visualizations have to do
with classification categories and also
search so we don't discuss the search
algorithms themselves but the
visualization technique that you could
use as an alternative to like lists like
search for salt viewers then we go on
with graphs and workflows there we will
discuss how to visualize graphs with
Java effects and also how to optimize
the scene graph for for large graph
visualizations so that you could
adaptively add more details or remove
details from the scene graph and then we
do some physics that's really funny so
you have physics based layout for Java
effects that use like spring mechanics
and force fields
yeah and that's it has been implemented
by one of our students
Christopher booshka he has done that in
an internship ok
just a few words about me I'm currently
doing my PhD at the Goethe Center for
scientific computing at the University
of Frankfurt and my research interests
are developing the visual programming
concepts for complex simulation
workflows and I also developed a visual
compiler plugin for groovy that can use
the ast and yeah has a bi-directional
mapping between source code and
visualization and I'm looking yeah Dan
integration into like NetBeans IDE kind
of things and my software projects are
visual here else to do the this one here
it's interactive IDE that uses groovy at
runtime to
extend the program and is able to create
interactive user interfaces on the fly
by using reflection and the second one
we workflows is a workflow visualization
library for Java X and this is one we
will use today and I also contributed
some controls and layout pains to the
joy of extras project yeah
you find me on Twitter Mia soft is my
twitter handle and also my my webpage is
neo soft in you so interactive
visualization first of all I think of
interactive visualization as something
where you visualize data and gives the
user controlled over the visualization
parameters like colors or other
parameters like zoom levels and so on or
you can give it the possibility to
actually edit the data with the
visualization so here's a very basic
example so we have two sliders here
these two values are our data model and
we can interactively change the
visualization we see here so why do we
choose JavaFX
first of all it has a modern scene graph
API it has really nice 2d controls 3d
controls media web support so you can
easily add a video to your scene graph
or even html5 based web application and
also the controls you saw earlier here
is part of job of X it's part of the
charting API so it's really easy to add
that to your like in this case the slide
software that I wrote for today also
what I like is the 3d notes really
behave like a 2d notes so you can just
register normal Mouse listeners and they
respond to layout and everything so this
is really convenient and the second
thing is the retained mode rendering I
mean some people don't like it because
they are concerned about performance
but we will show today that you can
actually solve that issue and we have
also immediate mode rendering via the
canvas node and you can use that as well
if you don't have other options or you
prefer it for some reason and I think
there are also some Java 2d graphics
contexts that map to the canvas node so
you can even do your like immediate mode
rendering that you did in swing in Java
2d and can do that in Java effects as
well so this is an example plotting
application based on Beaver flows it's
also interactive I mean I have an online
video that explains how develop to
develop such an application and this is
I mean Java X you have really good
support for zooming for for scaling
content so if you're interested in that
I can give you a link later on so search
in categories I mean usually when you
get search results you get one
dimensional list of the results like if
I search for Java X I get these these
search results here and I only can see
how well they match the the search term
but I don't see the relations between
the different results here and as I'm
developing visual programming
environments I'd like to have more
possibilities to express the relation
between different words and use it for
for showing category networks and also
classification so why don't we use more
dimensions I mean we could have the
search term here in the middle we use
the distance for how well the the the
actual results matches the search term
and then we have a rotational axis that
we can use in addition and frameworks
like leucine for example they allow you
to to return the cosine similarity for
example of different documents and you
could use the
angular information to place your
controls so there is an algorithm that
helps us with a developing section
visualization and we use force fields
for that so like if we have a search
term like here we exonerate a force
field and what we'd like to have is if
we use more than than just one circle
here then we'd like to to create
boundaries like contour lines and
therefore we use the marching cubes
marching squares algorithm in this case
I haven't seen it in Java X so I
developed my own version of it and I
will briefly explain it so we have force
fields and we have now to discretize
that force field like so and we choose a
threshold so and now I go to the to the
drawing application because it's a bit
easier to explain it's this one so we
had this visualization here we
discretized our force field and now what
we can do based on the threshold we can
actually create a binary representation
like we have zeros here and we have ones
here okay and then we create as cells
for we take four pixels and have one
cell and you see all 16 cases that we
can use to create a boundary path and
the cool thing about Java X is that it
has actually paths in the scene graph
because they respond to Mouse events and
we will see later what that really means
so I create cells like this and now I
can choose from these cases like if they
have black corners or white corners and
then I create the
the boundary so and we can't go into
detail here because it's not a tutorial
we don't have two hours here but if you
like to see more about that I'm really
happy to to also create a video like
last year we also did that then some of
you responded to to the topics and said
I would like to know more about it and
then yeah I can again create videos for
that so the visualization we get if we
use the algorithm is this control line
visualization it's very responsive and
you can use it for search results but
not only for that you could even create
controls that actually have a dynamic
boundary so as you saw before I mean I
can can interact with this visualization
and if we come back to this problem of
search and categories you see we could
use these boundaries as like artificial
categories that the algorithm gives us
you know if you say we want like 10
artificial categories then we have 10
boundaries here and we see these three
are in the highest level they are in one
category but on lower levels they they
only these share for example the next
contour line and so on so you can really
express relations and also when you do
search I mean I have done that as a
application for for multi-touch support
so you can even give notes like more
influence you know and then maybe some
are not that influential than others and
also we can have negative fields like
this one here which is not related maybe
to the search term or or gives a
negative value to the to the field so
all the I will release the code shortly
after
the session so you can really look at
the implementation it's also completely
open-source because I would like you to
create interesting visualizations with
it
and I mean I do it for I want to do it
for my source code analysis and I would
like to create new search controls that
are alternative to lists and tables so
do you have any questions about these
contour lines and visualization of
categories yeah excuse me
I mean the boundary changes as I move
the content so this is what I mean
because and you always get a closed job
of XPath so I can feel it you know you
don't have to fill it yourself usually
if you do it manually then without a
path API then you'd have to find
interior and exterior yourself and I was
very surprised to see that it works so
fluently because we have many many small
elements and in the past and with early
versions of Java of X it was really
painful to do that but but now it works
reliably so and I'm really yeah yeah
it's a visualization so I'm not not now
not here but we can talk about it later
and yeah because I'm concentrating on
the visualization I don't want to go too
deeply into the data thing but of course
it's it's a valid question
and I can also submit some some data I
mean we have a new scene database at
university and there I can feed that
into this visualization so yeah but just
drop me a line and I send you that stuff
okay yeah
is it's basically a linear path but I do
some I have some B spline algorithm that
even smooth is it a little more so in
Java X we had at the moment I only have
this linear but we use splines and then
to do a linear approximation here and
the discretized field here is like a 64
by 64 pixels for the whole control and
still you get really nice round
boundaries so it works in real time okay
then we move on to graphs and workflows
first of all what is a graph a graph is
a bunch of objects we call them nodes or
vertices and we have edges if we go back
here so it's like we have our nodes and
we can create connections these are the
nodes these are the edges okay so this
is the structure that we use and yeah
here just some examples of graphs for
example class and heritance graphs are a
good example the scene graph itself or
even abstract syntax trees which is a
special type of graph compilers use that
to as internal data structure and yeah
so how do we visualize graphs I actually
I'm working with workflows a lot so I
created library called Weber flows and
it uses a graph model inside and
you can use it for a job of X and can
also create other language bindings and
toolkit bindings if you like so how does
that work
here I just press the panic button
because I don't want to make mistakes
and I always do them yeah so it's good
to have a panic button if I run that
example I get two notes just ordinary
travel effects internal windows and
actually the window control here is part
of Jeff extras because Java effects
doesn't come with an internal window
like the internal change journal frame
that you know from swing maybe so this
is also a control that is available so
what do we here we create a flow by
calling the new flow method in the flow
Factory and then we can create nodes
like the flow note here give it a title
can you read that is it ok so ok no
problem so we can create notes by
calling new node on the flow we do that
two times and then we have a skin
factory because I wanted to keep that
independent from Java effects you can
have multiple skin factories and you
just give it the parent control and you
can also do that with other bindings
like you could create a html5 or swing
binding or whatever you like and you can
use all the bindings at once you can
just register different skin factories
but I'm concentrating on job of X so and
then at the end we just tell the flow to
be visible another example
so how do we create connections
we do it by adding outputs and inputs to
the notes and you can specify the the
type of the connection or the connector
so Note one gets an output connector of
type data you can just use your own
names and this also will create CSS
properties for these types so you can
have different colors for your
connections and yeah we have an input on
node two and then we tell the flow to
connect output one and input one and
this is what we get and of course we can
manipulate that as well so I can remove
the connection here so maybe we should
create another connection type
so we just only control for control flow
so we don't connect them just click run
so and we get the second pair of
connectors we can can connect them as
well and if we try to make connections
between incompatible types it also
responds very nicely it's completely
open framework you can download that
also on github and it uses chaff extras
for certain controls and also a special
thing is it zooms very nicely if it
needs more space it just zooms out and
we also do all the computations for for
handling the mouse tracking and so on
and I will explain that in a minute and
also if you remember the example here
this one you can also of course have
content in the notes this is also the
same framework but it has a very nice
separation between UI and the actual
model behind and you can register
different visualizations for the we call
it value object that is in the node okay
so how about scalable content Java X
gives you easy access to transformations
like scaling rotation translation so
here's another very basic example so
scale that a bit here we have the create
a new scale transformation 0.5 so we
scale down the circle here and you have
this transformations list it's an
observable list you can just add your
scale to it and the control or node will
instantly respond to it and here we have
a rotation that we apply to the
rectangle okay so if I run that these
controls here
change immediately like this one thing I
like about Java X is also that the mouse
coordinates they are transformed
automatically so this is quite easy to
get responsive visualizations and still
applying transformations so I told you
earlier that you need to optimize the
scene graph if you have lots of nodes in
it I mean each node in the graph that I
visualized has like 10 job of X nodes
I mean of course you could optimize that
as well but if you have complicated
content then this is still a problem
so therefore I created a scalable
content pane which is also part of Chive
extra slabs this does all the scaling
and it's basically an alternative to
scroll paints so if you have if you have
like a parent pane or something that
gives you this rectangle of space okay
and your control actually needs more
because your control needs like that
much of space then you would usually use
a stroll pane to scroll through the
content but what you can also do is you
can share just scale that down apply a
scale so this control will utilize
exactly with this bounding box okay and
I like it as an alternative for for
workflows because you don't always need
to see the details it's just for
orientation like in Google Maps for
example it's also very intuitive because
you can zoom in and zoom out and it
changes the level of detail so how to
use it you just create a scalable
content pane you throw some content into
it and then everything inside will be
scaled and you can say something like
scale scaleable content panes that
preferred size and everything it
responds to default
JavaFX layout
properties but this doesn't optimized
yet so therefore there is an optimizable
content pane it's also in save extra
slabs and reverb flows and you can
specify optimization rules for that pain
so this decides whether to show its
content or not and these rules look like
this so unfortunately I created that
interface before lambdas otherwise I
would have used functional interfaces
I will also fix that so I have that on
the on the roadmap but still you can
decide when to visualize a note or even
to attach or detach a note from the
scene graph and you get the optimizable
content pane as parameter and the
transformation so you can compute how
many square pixels the control uses you
know you can convert it back to the
screen resolution screen coordinate
system so if we are like in here in this
original size we may have controls that
occupy that many space that much space
like this here and in the scale example
it's smaller okay and if it goes below a
predefined threshold that you can use
like if it only uses 25 pixels or
something then you probably don't need
to visualize it and you don't have to to
go through all the layout passes because
you can't see anything and then you just
set the visible Falls or manage Falls
that the scene graph doesn't grow that
much and yeah you can also attach and
detach stuff and also you can specify
your own rules like if you have content
that has more
performance requirements like 3d content
you can remove that earlier than the
other content or you could also respond
to it and do something like just replace
it by a canvas and drawing that in meter
mode rendering so here is a demo
actually we just call this this method
here we don't show the source code I
mean if you are interested then just ask
questions and we can go into NetBeans
and I show you the source code of that
if I run that you see we get 10 notes on
each level and what I forgot to mention
that we workflows has like hierarchical
visualization of graphs so each node can
also be a graph itself and this is what
we see here and we have like 7810 nodes
in the graph model and like maybe 10
times as many JavaFX nodes and it takes
a lot of time to to load that
application if you have real content in
it but by using adaptive visualization
this is this works much better so I just
remove these notes because they are
ordinary nodes they don't contain any
any other sub graphs so I just remove
them we have some more space here and
now I increase the size of this control
here and please carefully watch it you
see here we have the next level and I
can modify that as well it's completely
responsive and we can do that even
further so if I scale that down
you see they they're gone again
and we removed them in here as well you
just keep that one maybe we scale that
and you see we get another level that we
can use so I mean this from transparent
style gets a bit confusing maybe but you
have seen the the earlier one that you
can also use them you can of course
everything responds to CSS properties
that you can use yeah so any questions
about that part about the library yeah
yeah
we are no I don't ya
no no I mean this is for workflows at
the moment so yeah but but you could of
course you could apply that to other
types you only have to to change maybe
the the the control types in here so
maybe but you could share the same model
yeah what you can also do is you can
zoom deeper so I have a new full-screen
view of like this level here can go even
deeper so I can zoom down as much as I
like until no nodes are left so
I used this yeah another person
you've got thousands of crap
no that's no problem and III have I have
a graph model and I associate the job of
X nodes with that and we have a skin
layer between that is almost like the
job of X skin but just a more bit more
lightweight so that we can bind to other
technologies because some people prefer
to use that with html5 or something and
when we have this maybe I go back from
full screen for just a bit
what you see here is let me open that
one so if I change something here it
also changes in the other visualization
you can have multiple visualizations of
the same content and this is also very
fast you see so you can visualize any
kind of levels you like you can have
like minimaps of everything and I think
this is important because visual
programming language is often lack this
kind of orientation at least I get lost
in stuff like LabVIEW because they show
just one level at once so for the next
version of your story I will use this
kind of visualizations and yeah it's
quite fast but I have my own model
behind it so it's very you can quickly
find notes and skins for nodes because
they have properties for that and even
though I don't wrote it for Java X only
I use the property framework because I
like it very much and main bindings and
everything because even though people
don't like to use two of X they still
can use properties with our problems I
think you know so interactive after
synthesis trees or or workflows so I can
go back to full screen now
all that was correct an abstract syntax
tree is just a compiler data structure
you take in an expression you tokenize
it and then you create a tree like
structure from that like in this case we
have 1 plus 2 times 3 we tokenize that
and then have plus as the root node and
it has a leaf node 1 and another leaf
node x and then we have a sub graph and
that's why we have this hierarchical
visualization 2 times 3 and the compiler
can use it or an interpreter can use it
to evaluate that expression like we have
1 plus and then we evaluate that sub
expression like 2 times 3 which is 6 and
in total we get 7 so why is programming
not interactive at all yeah this is
punch card I mean I haven't used them in
daily work so but as I work at
university many of the professors there
they remember that and that's why I use
these these pictures and they they
remember their Fortran times and kind of
programming but still I think that
programming is non interactive because
of historic reasons mainly I mean people
edit it on punch cards even on different
machines than on the machines that they
were running their code and after that
they compiled the code and in many cases
the compiler itself was deployed on
punch cards you had to load the compiler
first and then the data and then compile
it then you got your binary
representation if you're lucky and then
you could run the application I mean it
didn't look like that but it's still you
had these three steps and of course they
have yeah I mean they are are useful in
in in many cases but I think not in all
and what people did is they just deleted
this valuable information the ast I mean
each compiler has its internal
representation and then after that
languages began to integrate a
as part of the language specification in
Java you have this annotation processors
in groovy you have this compile time
meter programming and so on but still I
mean we're moving to that not as fast as
I would like to have it so I mean one
exception of course we use it in IDs for
auto completion and syntax highlighting
and refactoring and things like that so
you're not completely throwing it away
anymore but still we don't use it as
much as I would like to use it
so with vrl I try to create a language
model that sits between the ast and
creates a bit directional mapping
between the ast and the language model
and also from the language model to the
visualization and therefore I use this
vivere flows library so the language
model is just at the moment because I'm
doing research it's it's a subset of
Java so it doesn't have the full Java 8
specification in it so it's just a
subset a common subset of groovy and
Java so that I can switch between
compilers and and see what fits best but
of course you can extend that in the
future so it's it's something like like
the JDT for example or all that but not
really directly tightly coupled to Java
itself it's more of a generic language
model so here's an example we have the
model API and again just we panic and
get that source code here we declare a
class in this case and we declare a few
methods like method 1 method 2 and then
we invoke method 1 inside method 2 two
times and if I compile that with now
with the groovy compiler I instantly get
a graphical representation of that
because I wrote a compiler plugin for
groovy and it gives me the
flow model that are used behind the
workflows and I can just attach like
earlier a skin factory to it and say
visualize it in Java vex please and I
also get source code so I can render
source code again and compile it again
so maybe a second time demo outside the
the slide software it's here you see
already that the source code we have
here it's quite complicated to visualize
if you do that in in something like
LabVIEW it looks like complicated
circuits like like a computer main board
or something like that so I mean you you
I mean at least I can't really read it
therefore we can dive in I mean it's
still quite complex but a lot easier so
we're now in the in the main method and
I don't know if you can see it here we
have for example an operator assign in
if I change that to like 10 I don't know
if you could see that but here this just
changed I mean it's a bit difficult to
see because maybe I go here a little and
we can also change this value here so
you see it instantly responds to source
code changes and also if I remove things
you know it just instantly changes the
source code of that and this also works
the other way around so if I'm here in
an editor for example and we want to
introduce a new class
and we can introduce a method for
example so it just reloads and here we
have a class ABC with a method so it's
complete bi-directional mapping between
source code and the visual programming
thing and I don't like a program in
environments where you can only either
program visually or text-based I want to
combine that and at the moment I mean we
have a lot of visual state also and I
just add it as comment here below that
and we have some information for for
NetBeans to collapse that if we
integrate that into the NetBeans
platform which is kind of the plan so
you want to add something okay cool so I
think your NetBeans experts right yeah I
very cool yeah I mean this is this is of
course a long way to go but I think it's
possible yeah okay got lost here we are
so do you have questions about that
well yeah no problem but you can also
come back later or just drop me a line
if you have ideas because this is a
research topic I mean if you don't like
certain aspects I would like to
contribute other things then of course
this is this is possible and if you yeah
I don't know but so here is the next
topic it's physics and JavaFX
so the first thing when we talk about
physics is how do we discretize time you
know this is something that we would
like to have here very fluent movement
very smooth but depending on how well we
estimate that it looks different so we
have to decide based on the requirements
of the actual algorithm for the
simulation and the user interface to
choose carefully choose the
approximation of time okay so we think
of a continuous world but actually in
the computer everything is discrete so
we have to use a proclamation for that
and what's what I do usually is maybe
let's go to the drawing application
again what I like doing is to use the
yeah who produces time and who consumes
time I mean you could think of like
synchronizing the adaptive framework of
like frame rate of like a table of X
with the simulation but sometimes the
simulation has different requirements
than the visuals okay and therefore I
like to use a different approach so you
use an animation time and draw of X and
it adds time slices like this so if this
is the complete interval we just add to
that yeah maybe we
just to do it like this and this is
maybe the framework in Java X and then
we have a delta T which is like the time
slice we would like to use for each step
in the numerical simulation and it's
this big for example because the
algorithms requires it then we just
accumulate the time that JavaFX gives us
in an animation timer and then we the
the numerical simulation consumes that
time and takes this step here and
removes it from that one until it gets
here and of course if everything goes
well we get new time by the visuals and
if not we have to wait and if this is to
not I mean if we have a delta T that is
too big for the visualization like this
big here and we have so many frames in
Java X then we can use interpolation
between use those two states to get a
fluent visualization so that's what we
did okay I actually had a slide and this
is an example for spring visualization
and this is completely interactive so if
the if we drag something around the
visualization and simulation always
synchronize it's very much fun to play
around with that so I spent a lot of
hours because teaching at university is
not always fun but this one was
especially fun because I could play
around with it for like half an hour and
say hey at this place and that place and
play again so this was really fun yeah
okay okay I mean we talked about that
later
yeah I mean we used a box2d yeah we have
actually we have we have done our own
implementations like doing all the Eau
de computations ourselves but then we
thought we might just use the box to
deport to Java the che box2d
and use that instead and it works really
well so here we have like a standard
layouts this is an H box and it responds
to the normal H box properties so Java X
really layouts that thing we just do add
Springs to that and we can change to
between V box and H box and we can of
course add nodes to that we can remove
nodes and it's really responsive
something else we have is a real pain
so this has infinite mass here and these
have some I don't know which mass but
some massive at least and you can add
spring connections between them and you
also could use that for for the work
flow visualization so if you drag
windows around then you really have like
a cable like behavior where you drag
also the the attached windows and also
we have force fields interesting for
NASA for example I mean this is just for
playing around but you have we have
force fields we have could even use it
for like simulating a small fun solar
system or something that you can destroy
so let me try if I can throw that
somewhere ok now I thrown it away
eventually it will come back but so this
is also just an experiment but I'd love
to integrate that in a standard library
maybe Jeff extras or some extra
libraries so that people can really use
responsive physics based multi-touch API
is also and I mean in respect to to
mobile development this is also quite
interesting yep
yeah I know
I mean what I like is mine I mean we do
that all in Java so we have quite good
performance I think I mean so we just
finished that I mean to be honest
expecially this force field thing we
finished this with a box 2d like only
two days ago or so but I have the
original implementation was manually
done and this one contained like we also
only used like circle like note into of
X but we had at least like five thousand
nodes for I don't know where I have it
because I throw that away because I'd
like to use a standard library like a
box 2d which is I think better than
always we invent the wheel but doing it
manually can have advantages because
there we had like five thousand nodes
for this force field thing and we had
some collapsing thing we try to simulate
just for fun something like seeing
whether there are some stable systems
like planetary systems or something like
that but it was just for fun so yeah so
we're at the end now so feel free to ask
further questions if you like so we have
a couple of minutes left
yeah thanks fun
I think yeah I just ignore that but yes
we do so yeah I mean most of it is
already open and if it's not then it's
just me being too lazy to push it to
github but most things are already on
github I mean the graphitization is
totally open at the moment it's on
github it's we've air flows and you can
just download it it has the job of X
binding and I mean it needs some
improvement but it's there
yeah and we have a company in in Munich
that uses this library already for
database workflows and they even
contribute some some features to that so
but I'd like to keep that open it's I
think it's even BSD licensed and some
parts for like the visual programming
things are LGPL but still it's all open
source because we I mean at the
University we believe that we want to do
research and want to keep that openness
as much as possible so yeah and also I
mean just give me a couple of hours I
will upload this slide software which
contains everything and I will push that
to github as well
yeah so you can download it from there
and you have all the samples
no further questions or remarks I mean
if not then thanks a lot for attending</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>