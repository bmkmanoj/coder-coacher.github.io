<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Graal: How to Use the New JVM JIT Compiler in Real Life | Coder Coacher - Coaching Coders</title><meta content="Graal: How to Use the New JVM JIT Compiler in Real Life - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Graal: How to Use the New JVM JIT Compiler in Real Life</b></h2><h5 class="post__date">2018-03-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oxUpDJjXLVY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Kris Olinger I work for
Twitter I live in Hawaii as well so
that's pretty nice it's pretty cold
you're in Chicago but I'm coming from
Europe right now and Europe's cold it so
number one question who has a Twitter
account okay there are a bunch of people
who need to create one right now
so Twitter has um has a small DM team so
we are four people in the VM team we
have three to see engineers these are
mostly busy with making sure that all of
our micro services are run fine you know
everyone has to see issues and so they
are taking care of that and then there's
me and I'm a compiler engineer okay so
who in this room knows what a cheat
compiler is okay that's good
so JIT compiler just very briefly takes
Java bytecode and translates it into
native code and then you run on that
native because it makes your whatever
language you run on top of the JVM
faster right good so if you're going to
tweet about this talk which I encourage
you to do please add that hashtag than
my team at home they will know okay I
was really here and some people were in
the room and we're very very interested
as I can see in your faces
so why am i doing my talks in general
and this talk in particular so I want
people to try growl who knows what brawl
is oh okay all right I'm going to talk
about this more later but growl is also
a JIT compiler so people know what
hotspot is the JVM of OpenJDK yes we all
know that people know what c1 and c2 is
no okay so hotspot has to cheat
compilers right now they are called c1
or client compiler or c2 and server
compiler you might have heard this
client-server before there was like a
switch back in the day so there are two
different compilers and one is c1 is a
high throughput compiler that produces
native code as quickly as it can so you
you get away from interpreting byte
codes to run on some native code and
then there see
- and c2 is a hi-hi optimizing compiler
so it produces the peak performance code
that you want them eventually and and
growl is like c2 it's basically it
should be a replacement for c2 so I want
people to try Gras number one why you
should you could save money potentially
that's what we do at Twitter I have
another talk about this I'll briefly
bring it up later I want to fix bugs in
growl so if more people try it you know
will find bugs um and then we can fix
more and then we make we can make the
compiler more mature and stable and also
improve it in terms of you know find
code patterns that are used regularly
and then improve them and and so that
drokken can produce better code when I
give my presentations then people come
up to me after and ask me so is it is it
safe to use right it's still it's still
the experimental phase and so people are
not sure okay if I'm running it will it
burn down my data center or what's going
to happen so I can tell you know it's
not
we are Twitter we run our most important
services the biggest ones we have this
is the tweet service the social graph
service and the user service it's
basically everything to do with reading
and writing tweets and your social
interactions and who you are following
and all that stuff we run these services
for in 100% in production on gras for
about eight months and anyone lost any
tweets no still working great perfect so
it works fine for us and I think it will
it also does work fine for us
so then and then people ask me how do
they use it right not everyone knows how
how to turn it on and where to get it
and so on and so on
and so this talk will answer these
questions okay I will do a lot of demos
which is a little scary but so far it
worked out great
and then later some some of these people
they sent me emails as well you know the
people who actually try it they send me
emails that they're mostly complaining
about benchmark numbers and they say
well growl really sucks right so this
talk should help you understand the
differences
between c2 and Gras so that you're not
making the mistake running the benchmark
you're running for ten years and you
know expecting certain things that are
not really true with Gras we'll get to a
lot of that later okay so if you want to
know more about that money-saving part
that I was talking about I have this
presentation called Twitter's quest for
the Holy Grail runtime super Pawnee
title doesn't tell you anything what
it's really about
but I'll basically show you what we've
done at Twitter I show a lot of graphs
and you can see where we where we save
money where we save GC cycles where we
save CPU utilization and things like
that yeah you can see you can find that
on YouTube and it probably looks
something like this so I'm presenting my
talk you know and so what is Gras I've
already said that's a java virtual
machine just-in-time compiler it's
actively developed at Oracle labs right
now so they were working on this for a
couple years now and it's still being
developed it's it has an official open
JDK project the source code though lifts
on github whatever everything is going
to get up these days and it uses JVM CI
I'll come to that more later it's the
java virtual machine compiler interface
that growl uses and it's written in java
compared to C 1 and C 2
they are both written in C++ growl is
written in Java and one thing throughout
this talk that you should always
remember is it's written in Java it's
very very important because that's the
main difference that's where people make
mistakes Java applications have very
different properties than C++
applications right you have to you have
to think about this you have to know ok
whereas it allocated memory and how does
it work you know we talked about this so
where do I get it number one okay so as
always the answer is it depends just a
minute ago I saw the tweet by mark where
I know that JDK 10 is GA now so so I can
change my slide back after this talk
because the it depends part comes from
the fact that it's different it depends
on which
rating system you're running on
yesterday today is different so JDK 9
has a feature called ahead of time
compilation that's quick
go to this don't do this to this chap
okay
so ahead of time compilation it's in
release 9 it's obviously delivered to
the nines out for a long time so if we
scroll all the way back down
it says dependencies and and it also so
here it says chapter four the three JVM
see how we saw that earlier and then it
uses growl as the co generating back-end
so it uses grout generate a shared
library and then it also says the
project will emerge growl core that's
the open source Brian into the JDK and
delivers it in Linux x64 build and and
that's the important part that's the it
depends part so if you're running on
Linux x64 which pretty much everyone is
especially in the cloud or your data
center right I mean on your laptop it
might be different but everyone's
running a Linux x64 then you can just
grab gdk9 and you're fine
this is what we're going to do today if
you want to run on Windows or Mac there
is a ticket that's already been fixed so
it's at support for Windows and Mac
system so it writes out yet libraries on
these systems and then you can use it
there too and so that depends again you
need a JDK with JVM CI and a ot and that
to yesterday yeah I usually say today
yesterday I was Linux x64 grade-a equal
than 89 or Mac Windows critical
etiquette and since J 10 is out now I
can scrap all these slides and and do it
with ten so you can get JDK 9 and 10
builds there and we are going to do that
pretty soon so the way I'm doing this
talk is very unusual I think at least I
do everything from scratch like I have
nothing prepared will fire up so I'm an
Oracle it's kind of cut off Oracle
developer champion and so food
program I get free Oracle cloud credit
so I can use the cloud and this is what
we're going to do so we are there will
be you know mr. pros and cons number one
I have to switch the browser because it
doesn't work there will be a bunch of
awkward pauses because we have to wait
for things as always a little unnerving
I have to so the reason why I'm doing it
this way is you know you've you've seen
presentations where people show stuff
they show you demos or they do live
coding or whatever it's usually demos
and I always want to win I see
presentations like this I wonder how
many hours did these people spend to
make sure that the demos really run
right you know setting up this
environment that and you know installing
this in that package I don't want that I
want you to see how easy it is to
download the JDK and turn Brawl on and
run with it so we're doing everything
from scratch I'm firing up a cloud
instance right now it does not even have
get a Java installed there's nothing on
it okay so we're doing this and just
bear with me a little bit so there will
be some awkward process but you know
it's all good
so let's call this Chicago then we do it
in this domain we select Oracle Linux
7.4 we use depends io 1 because it has
the most CPU cores some networks set up
that's not really interesting and then
we need some SSH keys oh yeah there's
also a lot of typing involved today and
I don't know if you have you know done
this before typing in front of people
it's you really you know ok here we go
so we are provisioning this instance
called Chicago will take a little bit
all I'm waiting for right now is the
public IP address should be here right
yeah here we go
ok and then we can log in here with that
it doesn't work now because it's not up
yet the provisioning is usually pretty
quick but then it needs to image the
the instance and then it needs to start
it up so this just takes a little bit so
in the meantime while we were waiting
for this to come up I'll tell you a
little bit about me so as I said I'm
Chris I'm working on TV aims for over 13
years so back in the day I don't know I
call people out now who can remember
canoe glass paths but who are the old
people in the room that was back in the
day when we were you know this was Wild
West some microsystem was was still
holding back Java the source code was an
open source yet they were the bad guys
we were the good guys so that's where it
all started I was working on a different
TV I'm back then it was a lot of fun to
be honest and then 2007 2008 I think Sun
Microsystems didn't finally open source
java and then they showed up at
conferences like Faust mmm and said oh
look it's free and we said yeah great
and then we had a beer so that was
pretty cool and then a few years later I
started working for some Microsystems
you know I thought they're pretty cool
guys they have interesting stuff so I
started working for them
I was always part of the hospital
competitive team so I was always working
on compilers mostly on c2 and this is
also what the reason why I'm trying to
you know get Brawl out because c2 is a
very very complex software and it's it
has a very steep learning curve and it's
very difficult to hire people for for c2
and work on it and so gras on the other
hand is much much easier this I talk
more about this in my other talk but I
just want you to understand that there's
a there's a goal behind this I want to
move to a compiler that's easier to
understand is it more easily
approachable easier to to learn but for
other people like you you know will
download if we have time we download
correlator from github we'll build it
and I'll show you how to run it with on
the latest bleeding edge version so we
do all this the three major things that
I've worked on besides fixing a trillion
bucks I think was chase our 292 that's
invokedynamic
and method handles so I was working I
was basically John and I we started
working on it and we we did all the work
so if it doesn't work you could
technically blame me but a lot of other
people touched it in between so I think
they made the bucks so I did that and we
did a chapter for the three the Trivium
compiled interface and I did this in in
9 because I wanted the ability in JDK 9
for people to try grow and and then we
did ahead of time compilation because a
lot of customers were asking Sun and
Oracle for many many years they want
something like this and so we thought
okay let's do it now because we need it
as well because we want to alt compile
growl - we're not going to do this today
we don't have time but you can it's it's
not that complicated
and yeah I left Oracle and now I'm at
Twitter that's it that's the story and
now we hope that it's done we'll see
usually I talk too fast and it's not
done yet
yes it is here we go so we log in
logging in the second window because we
are we are going to compare C 2 and Gua
later and benchmarks and then you can
see there's nothing install ok number
one on the site I have to do a couple
things in parallel because you know
time's running out
we need to get we don't have to get so
we have to install kit and we go here
and then we go to the link word that I
showed you earlier so we're with
download JDK 9 we grab this guy and get
it here and we hope these are the the
awkward pauses that can yeah that was
much faster in Europe I don't know it's
weird but but I think some other things
will be a little faster later so we just
have to wait until this is done
that's the downside of my talk but it's
usually fine everyone needs to you know
process what I just said yes please
yes I can and also bring it down a
little bit because you can't see what's
going on up there this is ugly
how about now better yes next okay let
me do it like this because I want you to
see everything side by side lift it out
here hey you screwed me up
pretty much yeah I mean it it's not it
doesn't you know it's not Oracle cloud
instant specific but it's any any Linux
system yeah yeah yeah absolutely
so okay like there's a little small
hairy install this yes so we have dolkun
try to get downloaded here now we unzip
it
oh no the typing starts okay here we go
so JDK 8 9 we go here we set Java home
because we'll need that a couple times
later we also put it on the path because
we are going to need that too and we do
the same stuff over here and here we go
so now technically we should have Java
yes we do do we have kit yes we do
perfect okay then one other thing I'm
going to do is you might know that JDK
10 at 89 the default garbage collector
is g1 now but we are going to set
parallel as our collector in an
environment variable called Java tools
options which is picked up automatically
and we're using parallel GC because we
are looking at some GC output later and
it's easier to read parallel output and
it also I don't want the g1 heuristics
to kick in so we we use a
a small heap size we only use 512
megabytes and we use it the maximum and
the minimum the start size 512 and we do
this because we want to compare apples
to apples so not not all of your heap is
it is immediately allocated and grout
just because it's Java will do a
different allocation on the heath and
then when you when we run something we
see two and if we step if we set this
the start size to the maximum size then
we have kind of a level playing field
and we really compare apples to apples
okay good so over here Java there is
something called list modules here we go
list all the modules that are in your
JDK this should be like 75 modules or
something in JDK 9 and we are looking
for the module called Ã¤Ã´t here it is and
then there is something called describe
module let's call it jdk Ã¤Ã´t so we
describe that okay here we go
so it requires a bunch of other modules
okay and number one is jdk dodd internal
dot b m dot c hi that's JVM CI that's
the compiler interface it has the Java
code in it the Java interface that's the
that's the interface where an external
compiler can connect to ok
and then there's something called jdk
dot internal dot b m dot compiler and
that's grah
it just has if you would you know look
into the module the the content of the
module you would see cross source code
ok so if we have these two modules or we
have jdk dot Ã¤Ã´t that's what us saying
earlier if we have unity we have draw so
if you download jdk 9 or 10 you have it
right good now let me see what are we
talking about next ok two slides I'm a
little jet-lagged because I'm just
coming back from Europe so if I forget
anything I'm sorry but I don't think I
will
so how do you use it get a chatty cave
with JVM CI and Ã¤Ã´t we just verified
this so yes we have one and
just turn it on that's really all you
need to okay so let's look at this if we
go to the chips begin and go to chapter
43 that's the that's the JVM CI and
again scroll all the way back down it
tells you how to turn on achieving MCI
compiler so JVM CI itself in nine and
ten is an experimental feature so you
have to unlock experimental vm options
and then is you tell it okay please
enable JVM CI which doesn't
automatically mean use draw or replace C
to withdrawal it just says okay make the
API available make touch a VM CIF API
available and then you have to tell it
use the JVM CI compiler that's that's
turning on ground the rest you know the
the property telling the name of the
compiler doesn't really matter because
we only have one and so it will just
automatically pick wrong okay so we
copied these we can't beat that and we
copy DS oops here we gonna stick it in
here and then when we run Java dash
version or if we could type we would we
can see okay it's picking up these
environment variable options and then
it's just running - mer okay that's it
but nothing really happened right so we
turn it on we turn Jamie MCI and we turn
rolla nothing what's going on
nothing's going on that's that's
perfectly fine
so let's look let's look at this dumb
there is something called print flags
final and we do it version and they're a
bunch of KVM CI options in here namely
these and for example we enable JVM say
I just wants true so yeah we are picking
our options up it's all fine we're
looking for one it's called JVM CI print
properties this one and so we are
running this together properties it's a
long list of properties and there are a
few KB mci properties here
and then the rest is all Gras there's
our girl stuff you can turn on different
compiler whatever right like c2 has a
lot of options as well
there there are properties because growl
is written in Java and so we pass in
options as Java properties - capital B
you know the whole thing that's that's
how it works and we are looking for at
JVM CI properly called in init time at
this one so we want this one
and then we run that capital D in a time
line and we have to say equals true
because there's a Java property and then
we say - version let's see what happens
hmm
nothing happens that's weird why not so
what happens is if we turn on print
compilation and look at the compilations
that are happening you see okay add a
few compilations happening but not
really many and this who knows what tier
compilation is okay oh yeah
one person so when I was talking earlier
about c1 and c2 that there are two
different compilers in hotspot cured
compilation uses so you start out
interpreting code in your interpreter
and then you compile it with c1 you run
in c1 for a while you collect profiling
information and then later Yury compiled
with c2 these are the tears that your
method goes through right so but in peer
compilation we can we can gather all
this information but like the profiling
data but we already run on native
compiled code and then later we can kick
into high gear into into peak
performance code that c2 produces or
draw and so this third column here tells
us the tiered level and tier level one
two three are all c1 and 4 would be c2
or growl ok so when we look at this
there is no tier four compilation no no
code gets hot enough when we do -
version that we would actually do it
here for compilation and so since JV m
CI and gras is lazily initialized we're
never initializing it okay so what we
have to do is we have to run something
that that
runs a little more code and we are going
to download something called SCADA the
COPO benchmark here we go
and we grab this version here and we
really hope that it's going to be fast
otherwise I have an issue no that's fine
okay we can wait step in seconds that's
not too awkward should read that perfect
okay here we go so if we run this and we
say scholar benchmark and we do with SEL
with which just lists all the benchmarks
that it has okay so it lists them here
at the bottom and we see okay there's
some initialization going on here of JVM
CI but it looks like it's not really
finishing and that's correct because the
bash shell exits sooner than the JVM CI
initialization is finished so we never
get to the point where we initialize JVM
CI and growl and actually do a broad
compilation so we have to run even more
than that okay so we're running a small
Aurora run so let's do this ah much
better
okay this is what we want so we see the
benchmark running down here and up here
we can see hav MC is being initialized
what's that part until here and then
we're done
it took 79 milliseconds and here you can
see the compiler factory selects the
compiler and that as I told the early we
have one so it automatically picks raw
okay and then it initializes this class
called hotspot brawl runtime and then
initially okay and you can see all on
you know the back end stuff is being
initialized we are in MV 64 and so on
and so on and then we're up and running
and the benchmark that was run here was
was running with crawl that's really so
you have to just stick these flags on
your command line or in this environment
variable that I'm using and then you
oughta turn it on growling you're
running on it so if we are gonna run the
same thing over here we say wait the
scala benchmark and we say a small run
of Aurora Aurora and it should be about
the same I think it's a little bit
faster but the yeah it's four point four
there's a five point four okay the
benchmark itself is a little flaky but
it's a c2 is faster and we we get to
that why it is okay here we go so we
have to talk about bootstrapping now how
am i doing with time by the way oh my
god I'm running out of time so
bootstrapping is corral is just another
java application that's running in your
JD yeah and you only have byte code for
it it it's basically there was a chopper
module the only left Java bytecode for
it there's no native code because we
didn't know to compile it so what
happens is if you run with it yes I
should say that it loads it loads Java
classes right because it's it's Java
code it has Java methods obviously in
these methods at some point need to be
compiled you cannot be running your
chick compiler and interpreter mode all
the time that would be freaking ly slow
right that doesn't work so it's not what
we need to compile these and that's
what's called bootstrapping because if
if you only had one compiler if you're
not running tiered you would have to
compile draw with growl itself so that's
the meta-circular approach here and
that's what's called bootstrapping okay
so let's look at bootstrapping real
quick there is a flag where you can do
an explicit bootstrap so you tell the VM
bootstrap my JVM CIA and then dash
version okay here we go so it does that
it's bootstrapping every dot is like a
hundred compilations so it does that for
about ten seconds if every month yes
yeah yeah yeah yeah it's check compiling
it yes so it took about ten seconds
who's compiling roughly 2,400 methods
and then it says okay I'm done the way
boots that the weight the bootstrap JVM
CI flag works it's it schedules all the
methods of java java lang
checked which are very small methods if
you know these and while it compels
these very simple methods hotspot growl
code itself gets hot while it's doing
the job and then it compiles itself it
compares it's its own methods and it
gets more and more and more hot and
that's the bootstrapping part okay so in
an explicit bootstrapping run this takes
ten seconds when you remember the
benchmark I was running with growl took
five point four seconds roughly and if
we run it with c2 it takes four point
four so that's much less than ten
seconds difference right no one would
wait an additional ten seconds for
something to start up and then everyone
would say I'm not using the scroll
because it's not worth doing it right
but that's not the case because what no
one
you should not really I'm just showing
to you that bootstrapping involves a lot
of compilations I also want to show you
what I'm talking I'm going to show you
if I turn off tiered compilation it's
even worse right because we are not
compiling with c1 we're compiling only
with Gras we're only interpreting and
compiling with growl itself takes I
can't remember like 25 seconds or
something like this and compiles 4800
methods or something like this so it's a
lot okay but you I don't know really of
a case where you have to explicitly
bootstrap it because there's something
called an implicit bootstrap where it
happens automatically in the background
while you just start up your application
it will just compile itself and the way
yeah here we go so it was you slower 27
4600 methods when you start up your
application whatever it is in almost all
of your compilations will happen in the
first one two minutes I would say if
it's if it's a rather big application so
all these calculations happen in and at
the very beginning while your
application is not even fully fully up
yet right it's you start up your thing
however big it is if it's smaller and
it's comes up faster it's it's not that
much to compile so it won't take a
minute or two probably maybe even 30
seconds or something
if we get to the demo later you will see
that so in the very beginning you know
the microservices we have a Twitter you
bring up the micro service then it has
to connect to a trillion of other micro
services before it even can accept the
request and then what the most of the
time do they warm themselves up a little
bit and you know at that point you're
already done with all your compilations
and and at that point or until at that
point you're not using all your Java
heap memory or all your course and so
that's where that's why it's only one
second because what what the champion
does it takes up all the other three
cores that are laying around that are
not used by your application threads and
just compile stuff right okay good let's
go back to the slides real quick
no yes let me show you this real quick
how much time yeah now let me show you
this I think it's important so if we do
the print flax final no not print flex
final G of the MCI properties that guy
and then there's a flat called
c1 only here we go it's called growl
compile growl with c1 only so in the
default setup you're running tiered I
explain to you what that is and and then
this flag is by default true so in an
implicit bootstrap growl will never
compile itself drow code growl methods
will only be compiled by c1 and the
reason for that is because c1 is a much
faster faster through compiler so if we
would compile you've seen the difference
the nine seconds versus the twenty seven
right if we would compile with Gras it
would take much longer to get there and
see one does a pretty good job and that
the code that comes out of c1 is usually
fast enough so we never for example I
can always say at Twitter we'd never had
an issue with this why we never have had
a compiler throughput issue or anything
like this
good okay back to the slides
so we learned that bootstrap encompasses
a lot methods like 2500 and the tr90 at
4800 rough like this you can do it
eat up
which I don't suggest I was just showing
to you how much that would be or doing
on-demand during runtime just let it
happen by itself and then by default it
compels draw with c1 only and forget
that last part it's it's not that
important okay
Java heap usage very important so growl
is who remembers yes exactly that's the
main difference
right so c2 is written in C++ but Corral
is written in Java and so when we are
compiling the application we are running
with Gras it will use Java heap memory
to do these compilations you know you
when you compile a method basically all
you do is you parse your Java bytecode
into a graph and the graph can be pretty
big when you do a lot of inlining or
loop unrolling
I throw it a bunch of things here if you
don't understand them it's it's not that
important so and that can make a graph
pretty big I know a very you know worst
case compilation situations we've seen
we see two for example compilations that
took 500 megabytes of memory it can
happen I've even seen more but that's
not the normal compilation normal
compilations taken in the maybe tens of
megabytes or something like this but you
know it can it can get pretty pretty big
so and then it's not only the
applications it's the application itself
that we're compiling could be brought to
if we turn that flag off as you remember
okay let's quickly look at this so we
are running this guy yes exactly that's
what we're running and we're logging TC
and we do because it's a we're doing
three three rounds
okay the Aurora benchmark is a very
compute intensive benchmark it doesn't
really allocate a lot and you can see
there are these four cc's before and
after a benchmark iteration and that's
the hardness the hardness is calling
system GC to clean up the memory but you
can see all the benchmark runs here here
and here there are no GCS happening
during the
time and we are not really collecting
anything after it's like we were
collecting 40 down to three years oh but
it's really not allocating a lot so if
we run the same thing over here we will
see the situation is a little different
so their GC is happening and they're GC
is happening because growl is compiling
the benchmark code and for that it needs
to use Java heap memory that's where
it's coming in but if you if you look at
this so in the in the first iteration
you see the one that takes like 4.5
seconds we have a bunch of T sees and
then in the second iteration
there's no GC anymore but we're
collecting from 425 from 124 down to
seven so it is there's some some garbage
around and then a third iteration also
no collection so that's what I meant
when I said you're compiling stuff at
the very beginning right this this is
reusing the code the iteration so in the
first benchmark round we compile stuff
yes and we collect because we have to
but then later there are no compilations
happening anymore or Ali and then that's
what I'm saying it's usually not an
issue right in the very beginning it's
fine you use a little bit of Java heap
memory I know everyone's tuning the heap
size to exactly how much you need plus
maybe one megabyte more because you know
and then a compilation could kick you
over the edge yes it could it could
happen but in a cloud world if you tune
your child the heap size don't in the
wrong way you have the same problem
because if C 2 suddenly kicks in and
takes 300 megabytes of memory to compile
something and you didn't expect that
your clock container will get out right
it's just different where the memory is
being allocated C 2 allocates it on with
malloc on the native C heap while Grodd
allocates it on the childhood it's just
different where it is but you will use
that memory you cannot escape that good
going back here so growl uses Java heap
memory there's no heap isolations yet
this will come we we haven't had time to
implement this but basically we what we
want is we want to isolate the memory
that's being allocated by growl
the application because what could
happen is that you you triggered out of
memory situation and the out of memory
error gets signal into your application
the application will get done so we
don't want that but if you're in out of
memory situation let's say oh you're
compilation takes 500 megabytes and you
don't have it and you get an out of
memory error in the ingre of the
compiler
it's fine we don't do the competition
whatever we run and see one code it's
perfectly fine so we'll get there we're
working on it most memory usage as I
said is during startup because that's
where most of the compilations are
happening and at that point the
application is very likely not fully up
yet so you shouldn't worry too much
about this and then they use the
memories use to anyway
need a malloc which I'll keep okay so
let's do how much time do I have seven
minutes maybe I can do it
so I want to show you how to run with
bleeding edge crawl to download it from
github and build it but I also want to
show you a production demo and the
production demo it's um I shouldn't talk
so much I should just do it it's a thing
called fenetre scene not true it's um
it's a framework I usually just read
what it says here because I can never
remember it's okay lightweight framework
for building fast testable Scala
applications bla bla bla I don't even
know what that is I cannot even write
Scala code okay everything of all of our
micro services are written in Scala but
I cannot even write it so I don't have
to all I have to know is Java bytecode
that's that's all I really care about it
has a few examples wait let me go back
let me grab this here before I start
talking about it and we clone this and
then there's a bunch of examples here
and one is called Twitter clone so it
has a Twitter clone on example super
simple Twitter eh you know store it weed
and read it and stuff but I want to use
this because it's the closest to
something that's production code that I
can show you right I cannot show you the
Twitter production code or anything else
I could use a benchmark but that's all
stupid so I'm just using that but it's
written in Scala obviously here
obviously written in Scala 92 percent
and compiling Scala code takes a long
time so we have to do this on the side
so we cloned that we go here fenetre and
then you remember so I have to go back
to my notes this is this is exactly the
part that I was talking about earlier I
would have set this up before if it
would be another you know regular talk
and I wouldn't have to do this and but
since fenÃªtre is not really Java 9 ready
you have to edit this one build script
here and then no no don't do that
and and then I have to do this which is
crazy I really tried to figure it out
because I thought okay maybe maybe I I
can figure it out so I can quickly do it
during during the presentation but I
have to pass in a different trust so
because otherwise he cannot access HTTPS
URLs and whatnot so these are the things
that I was talking earlier I would have
spent hours to set this up just for you
to say oh look I just typed build and it
works which is not really true because I
have to spend hours to do it so you see
the truth here that's the truth so we're
building this Twitter clone thingy and
not one more thing I have to unset these
because it's not really happy with the
parallettes you see here we go so that
should work we have Java home set so
it's picking Java 9 up it looks like
it's worth it okay over here
we go to github and we go to Gras and
then there's Oracle crawl and we copy
that and we clone it and what was it
called well let's see how fast it is
yeah okay yeah I can't wait for this and
Europe had problems because the repo
grow too big and then I have to say
depth 1 and was kind of faster to Chloe
but I think it should be fine
so we are cloning growl it grew over
time because it's not when I say growl
there's unfortunately an overloading of
terminology here back in the day brow
was growl the JIT compiler and now
Oracle labs decided to grow to call
everything growl VM unfortunately
confusing and that includes truffle and
substrate VM but I'm not talking about
these things every time I say graaah' I
mean the compiler and nothing else
okay and we have to clone one other
thing and that one's called MX and it's
a script that Oracle apps is using here
krabi MMX it's a script they are using
to do everything literally everything
like MX you can build with it you can
run tests you can run the gate you you
know all of all of that so we go in here
we put it on the path and then we go Rob
and then you can see in here as I said
but a substrate DM in here it has
truffle in here blah blah blah we don't
want that on the only thing we want is
to compile so we go into your compiler
and then always say is MX built that's
it and the script do you know we have
Java home set oh yeah I want to turn
that off because it's a little noisy
sorry about that
there we answer one set this real okay
here we go
so MX built downloading a bunch of
dependencies it needs and then it builds
all the that's what's odd sorry about
that I have to clean it let's try again
it could be that it's not working right
it's all it's like upstream code yeah
that's not what I want that's really not
good um what are the what's called tack
let's try this guy
when they were working on it all the
time right I was just cloning tip could
be anything it's not working we have to
skip that one so far it always worked
we'll see
looks better okay I can deal with that
so we're building brawl now from from
github don't use today's tip because it
doesn't work it's always better to use
one of the tags anyway but I skipped
that so we're building this and it this
build will fail and that's expected and
the reason why it will fail is because
it wants to build truffle - and truffle
have some Lib FFI part and so it needs
TCC - or a C compiler to do that but
remember our cloud instance is
completely naked there is no TCC
installed I could install GCC it would
take forever and that's the error we
want but I don't think it's done yet
what was it a little quick sometimes
there's a race condition it builds the
C++ part sure yeah no it's not done yet
okay how is our other build doing well I
want fail - and that's not good they
have tags I'm always worried about this
guy yeah but so far I work fine let's
see I can skip that one and show you
that's called a benchmark that's also
very interesting so if I have time no I
don't I'm already out of time
Oh No okay we have to go over a little
bit okay here we go and there should be
somewhere there should be 8 + MX build
modules right so this is this is our
modular Charcot that modular Java will
replace the JDK dot internal gobby m dot
compiler module that we've seen earlier
okay we have to we can't do this one and
so yes MX if you do MX VM then you just
run the VM and it
you know you can do that and say -
version well and we have to turn this on
okay here we go same as earlier then if
you say - V we actually see what it's
doing and the command line we're
interested in is this one and it what it
does it upgrades the module path with
this modular Java
yeah if we run X log class load and we
do whatever we do the scallop inch mark
again
yeah wait yeah so it's correct
so we do this I have to do it like that
it's called benchmark we say small round
of Aurora here we go and we grab because
it's too much regret for gravi m okay
here we go so we see all the classes
that are grah are being loaded from this
internal module like jrt is the internal
file system for the module system okay
if we run the same command with MX vm
we'll see okay all of our our classes
are being picked up from our modular
Java so that's really all you need if
you want to run on the latest version of
drol you only from github you build it
which was you know more or less easy
laughter I really clean it up and
checked out the right tag and then you
can run with it and then you can you
know import it in your IDE and you know
play around with it and do whatever you
want it's it's very easy to do and then
all you have to do is have your travel
home set to achieve ek9 or later and it
will automatically pick it up so we can
let's just quickly run this benchmark
with the latest garage version here
oopsy p.m. to see if it really works it
should I'm always hoping that it's
faster it's usually not but it would be
nice it's a little faster but you know
as I said it's flaky okay so since I'm
out of time and the built-in finish over
there I can show you that but what I
would have shown you is the production
demo would be
they show you that the bootstrapping
during the starting up the Twitter clone
server it there's no difference it it
starts a mid and then in about the same
time because as I said the CPUs you're
not using while you start up your
applications they're just being used to
compile code there's really no
difference that's what we are seeing at
Twitter as well
we start our stuff all the time we
deploy a bunch of times per week and
there's no issue we never had an issue
okay summary since I'm over already
very simple that just turn it on that's
really all you know as I as I told you I
showed you everything that you you have
to do to use it I there were there were
no tricks I didn't didn't hide anything
like everything I did is what you need I
downloaded the JDK I showed you how to
turn it on I showed you how to run
benchmarks what to look out for look
look out for Java heap memory usage
don't you know don't just blindly look
at GCS because you have to remember okay
yeah it's Java so it's a little
different he's all the the errors or
mistakes that people before you make and
that's why I'm giving this talk to tell
you not to make that mistake again but I
would really really appreciate if you
run whatever you have preferably in
production immediately don't even think
about it just a ploy it and of course
not but just give it a try right the
worst thing that can happen is it
crashes that would be actually to be
honest that would be great because then
we found a bug and it would you know
encourage you to file that upstream you
don't have to fix it yourself you could
because I showed you how to download the
source code how to build it
you could fix it yourself that would be
amazing so if you need help
tweet me DM me sent me an email tell me
if it works if it doesn't work I will
help you out if you need some help thank
you very much
I'm not sure if we can I think we can it
seems to be much of that for all this
design the same well I wouldn't say it
was designed to save money just it saves
Twitter a lot of money you would have to
watch my other talk but the short answer
is scroll can optimize very very well
Scala code and through that we are
reducing CPU utilization by about 10%
and that's the money we're saving and at
a big scale you know in my other talk
you'd see I'll give examples I kind of
walk you through ok how much money could
that be technically but it's it's a lot
Java code is I always say it's like a
50-50 chance if it's better or not
because Java code is much more I'd like
to say static if you understand what I
mean like Scala code is much more
polymorphic so inlining metis much more
with Java code I've seen benchmarks that
are fast I can show you benchmarks that
are faster I can show you benchmarks
that are actually slower so it depends
oh I could if I if I had an hour and 30
minutes I could yes no no I'm just
saying because I already ran out and it
couldn't show you all the bit demos the
other demos I had no it's it compiles in
about a couple minutes and then yes all
the bootstrapping goes away yep exactly
the same way I see - no no no as soon as
as soon as the method is compiled and
installing the code cache growl is not
involved anymore because then it's just
in the code cache and the VM just takes
care of it it's it's exactly the same it
the the only difference between c2 and
growl in that case is how to install the
compiled code right c2 just cause the
C++ method installs it in the code cache
raagh you get a byte array back red-eyed
array is the compiled method and you
take it transform it into an end method
installing the code cache that's all
yeah absolutely the same thing I think
people are here for the next talk sorry</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>