<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advanced Modular Development | Coder Coacher - Coaching Coders</title><meta content="Advanced Modular Development - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advanced Modular Development</b></h2><h5 class="post__date">2016-09-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WWbw8u5jaaU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone to the last jigsaw talk
of the day this is advanced modular
development my name is Alex Buckley I'm
in the Java platform group at Oracle I
do the first half of this talk and then
my colleague Alan Bateman does the
second half mark is here for emotional
support
this is believe it or not even though
it's the end of the day this is the
third of five jigsaw talks Alan will
have the times dates and times of these
at the end of the presentation but
modules and services and projects are
under the hood are tomorrow in this room
and then we also start the repeats of
the whole cycle with prepare for JDK 9
and I think that's on Wednesday that
that's that's not getting repeated
tomorrow so anyway this talk is in two
parts and they're really both about
migration because there are there's a
whole module system API you can look at
the Javadoc for that but the the first
and most existential question when
modularizing an application for jdk 9 is
is where do the modules come from and
that's really what this talk is about so
I'm going to talk about migrating your
application top-down and then Alan will
speak about migrating libraries that sit
closer to the JDK than your application
so that's bottom-up migration so
application migration at heart a typical
application has three layers at the top
are your jar files at the bottom is the
JDK and in the middle of this sandwich
is the filling a bunch of jars
downloaded from the internet in the
nicest possible way and thrown on your
class path in project jigsaw we've
turned the JDK into modules such as Java
base Java logging Java sequel and
or XML modules are good things they're
always in greetin their benefits are
strong encapsulation so that no one
outside a module can access its
internals and reliable configuration so
modules know what they need and there's
no need to set the class path if this
sounds good you might be wondering how
to turn your application into modules
let's put some names on the jars at the
top to get started let's assume that the
main application is my app jar and it
has some helper code in my Lib jar and
let's assume that the cloud of
third-party jars that filling in the
sandwich can be simplified to just
Jackson the JSON processing library
Jackson comes as three jars core data
bind and annotations of course to run
the application today you have to ensure
the classpath is set up like this
everything's in the Lib directory I'm
gonna have my things first and then the
Jackson jars and then my main class no
problem JDK AIDS now you wouldn't have
to bother with that long invocation that
sets the class path to this and that and
the other if my APR and my lib car
turned into modules now turning each jar
into a module one for one is a fairly
natural way to proceed is not always
possible especially if jars have cyclic
dependencies among their classes but
let's go with it for now whenever you
see a module you should ask two
questions what does it require and what
does it exports let's ask that for each
of our prospective modules my app and my
Lib
one way to find out what a module might
require is to run Jade EPS on the jar
file that you have Jade EPS is a tool in
JDK 8 that analyzes classes in jar files
and finds whatever classes they refer to
in other jar files here are the results
of running Jade EPS
on my jaw and my Libby are the classes
of my apt jar make use of classes in
jackson core and jackson data bind jar
and of course in my live jar that's the
helper plus my app dot jar uses classes
from the java base module I'm pretty
sure java.lang object is among them
since that's down in base and string as
an Ullman and for sake of argument it
uses Java sequel as well
my lib jar turns out to only use classes
from the java base module so that's nice
and simple the arrows are my app depends
on all sorts of things and my lib and
then my lib is just for sake of argument
depending on on the JDK itself so with
this knowledge we can write the module
declarations here's the module info Java
file from my Lib our helper library all
it requires is Java dot base now you
never actually need to write Java base
since it's literally impossible to write
a Java program without indirectly
relying on java.lang object so we always
give you the dependency on Java base for
free even if you don't write it in
source but put it out here to be clear
now there's an exports here which which
I've written by hand
Jade EPS cannot realistically help you
determine the exports of your jar we
could just say it exports everything but
when you're writing the module
declaration you still have to choose so
let's say that my lib exports a package
comm my apt Lib util to the my app
module we're going to make now this is a
qualified X
but because it's specific about which
other modules namely my app can access
this exported package in particular the
public types of that exported package
let's now turn to the module info dot
Java file for my app it requires my Lib
our newly created module and it requires
Java base and Java sequel and of course
we know that it's going to use Jackson
so we'd like to write requires Jackson
core and requires Jackson data bind does
that mean that the I is the developer of
my app have to write module info dot
Java files for Jackson as well that
would be a pain I don't control those
jar files if only there was some way for
the Jackson jar files to become modules
automatically in that case we could then
write the Declaration of the my app
module module effort of Java like this
we just require those jars like any
other module we would have a beautiful
module growth with my app depending on
my lib those are two explicit modules
and my app depending on some of the
Jackson modules and then also down on
JDK modules you can do this
the solution is automatic modules an
automatic module is a jar file that you
put on the module path rather than on
the class path once you do that you have
a real module you don't change someone
else's jar file you don't put you don't
change its manifest you don't put any
class files into it the name of that
module is derived from the jar file name
in a fairly obvious way it strips the
version off the end another thing
that automatic module exports all of the
packages there's like sure there's
nothing else you can do really it
exports all the packages from the
automatic module and that automatic
module requires all other modules that
are in the system
so in effect automatic modules mean that
today's jar files do running on JDK
eight are tomorrow's modules they can
act as modules in JDK 9 very often
without you doing anything without you
doing anything to them rather so once
automatic modules spring into existence
for jackson core jax and data bind and
jackson annotations the module graph
looks quite different
the automatic modules basically require
everything that's a feature not a bug
they require each other they require all
the modules in the JDK image and all of
your modules that the errors are going
up as well now this is to provide the
maximum possible that maximum possible
compatibility surface for code in all
the jar files you might think that the
module system could run Jade EPS on the
the jar files those three jar files at
startup and try to figure out what
modules they require but that wouldn't
really help and the reason it held we
reason it wouldn't help is a bit subtle
the thing is that the libraries that you
typically find in the filling of the
sandwich often make use of core
reflection that is the java.lang reflect
api and they use it to inspect classes
dynamically now Jade EPS can see the
invocations of the core reflection API
but it can't can't very well predict
aesthetically what classes will be
inspected dynamically and in fact the
Jackson data bind module does exact
makes exactly this use of Cora flexion
when code in my app here it is doing an
import of the jackson api and then calls
the jackson api object mapper it passes
there it is the final argument it passes
it's own class object the intent is that
Jackson data binds can create an
instance of the my value class which is
an application class why so that it can
then assign the field name to Bob and
age to 13 because that's doing JSON
object mapping now on Jenna key nine
this code won't succeed because we never
actually got round to saying what the
module my app exports my app doesn't
really have an API it's the top node
it's the application yet it needs to
export some packages anyway and you may
find if you're using any frameworks at
all
even if you don't think as an
application that you have an API that
other people call you have this implicit
API anyway you add it at inject right or
at entity or at path per am or you pass
any of your own class objects down to a
library the solution is to declare my
app as a weak module a week module
exports all of its packages in a way
that allows a framework like Jackson
data bind to reflect over its internals
you do not need to manually export the
packages one by one and then keep this
module declaration up-to-date with the
source tree of my app with a weak module
in effect you get the benefit of
reliable dependencies but without the
full strength or the full power of
strong encapsulation frameworks that
reflect over application code are a
reality in everyday Java developments
and they aren't going away so
application code like my app can't
always be strongly encapsulated there is
business value in the frameworks that
call back in to you reflectively so we
think this weak modifier at the very
beginning of a module declaration is a
clear statement about the nature of this
module it's it's open for reflection but
it doesn't have an API
without the weak modifier a module is
strong it explicitly defines an API via
exports statements so let's come back to
the module graph it is pretty messy but
it's better than when everything was a
jar on the class path by the way because
my app I should say because my app is
now exporting what it needs to do that
arrow that says data bind is gonna
require implicitly my app there's that
and then there's the export from my app
because it's a week module and all the
reflection from data bind will just work
but the overall graph is still pretty
messy but better than the class part
because for example there is no arrow
from my lib to my app so there is no
danger of code in my Lib accidentally
reaching into my apps internals on the
class path code in my live jar could
access code in my app jar quite easily
it's just in scan the class path until
you find the class and that kind of
chaos is what causes maintenance
headaches down the road in fact if you
think about it the class path at the end
please the class path is crazy with just
10 jars you get 100 possible ways for
classes in those jars to interact the
class path is the ultimate in airasia
whatever you know about the structure of
your system the class path throws it
away and connects everything to everyone
else and that means conflicting classes
and missing classes and duplicate
classes in different jars and generally
slow sequential look up every time the
VM needs a class which is often with
modules you're telling the compiler and
VM about the structure of your system
and automatic modules you know there is
a tension between the cleanliness and
the usability but it all works out
you're telling the compiler ovm about
the structure of your system and finally
they make use of that information
speaking of the compiler let's see how
you run it for these module declarations
I've been talking about we've got the
Jax and jar files in the Lib directory
where they always were and we're going
to treat them at compile time as
automatic modules by putting them on the
module path to the compiler then we've
got the my app and my lip source in the
source directory and we tell Java C
about that directory with this new
module source path option and that's
necessary because there is a there's a
new level in the directory hierarchy for
the modules so we go you can see sort my
app and my lib are a new level in the
traditional compiled time hierarchy so
that we can put in source module name
and then module info dot Java and then
the package hierarchy at the same level
as module inferred on Java the result
then is class files minus D in the mods
directory we can run jar to build my
Libby are based on the classes in mods
my lip we could run jar to build my app
jar from the classes in mods my app and
because it's going to be the main class
we specify that on the command line here
and then because these jar files have
module info dot class files in them
compiled from the to module in photo
java files we call them modular jars
modular jars is a term you will hear a
lot in the the the succeeding talks in
this in this sequence so you can then
run the module Erised application with
this simple command-line all the stuff
passed to minus CP in the past is now
wrapped up in the module inferred or
class files the explicit modules are in
Emily but I think I'm moving there from
mods and the automatic Jack's and
modules are in Lib where they always
were and so that's it
so we modular raised an application with
two techniques first we built modular
jar files for our own application code
by writing and compiling module in photo
Java files and we also created automatic
modules for third-party code for library
code simply by putting their jar files
on the module path passing that Lib
directory to module path rather than to
class path so if you like you can think
of this as top-down migration I wrote
the module declarations for the
application and then kind of worried
about what was underneath it later so if
I say top-down you should think what
does bottom-up migration look like and
for that I will hand over to Allen
library migration so this is the second
part so we will roll back to where we
were at the beginning of the
presentation where we had the modular
platform at the bottom or sandwich of
jar files in the middle and our
application whatever libraries it comes
with at the top so what we're going to
do is we're going to start at the bottom
now and try and move these de Jackson
jar files that we have we want to move
and migrate those two modules so that we
end up with this picture green is module
Maya I'm sorry orange is the is the
class path exactly as Alex did in the
first part of the presentation when
you're when you're migrating and you're
and you see a module you have to ask us
the questions what do they require what
did they say what are they export so for
each of our three Jackson jar files if
we're going to think of them as modules
we need to think about what do they
require and what did they export we
start with the report with the with by
running what we call the Jade EPS tool
so if you're at the earlier talks you
will see that we use the Jade EPS tune
to actually do some static analysis on
existing libraries alex sees it in his
part of the presentation to to look at
Maya Pande my lip we do the same thing
with the Jackson jar files here to
understand what they require so we see
that the Jackson annotations and jar
file has code in there that makes use of
types that are in Java base that makes
sense java jackson core also has some
code in there that makes use of some
types in Java base jackson data bind is
much more interesting there is code in
that jar file that has references to
types that are injects and annotations
there's also references that types that
hurt in in jackson core there's also a
couple of other references to two types
that are in java base of course java
sequel and java x xml
I should say is is that when you're when
you're trying to understand what a
module depends on you don't need to of
course use the the J tips - there's all
the ways if it's a maven project than
you've already got a palm and that could
give you some idea what what it depends
on
so this is the dependency graph from
from the J tips output and just keep
just keep this in mind because we will
be coming back to us in the later slides
and I want to run J tips again this time
with a new option gen module info which
is a way basically to get your starting
point on your starting module info dot
Java now in the earlier talks we had J
Depp's being usable on JDK 8 to be able
to look at your jar files in your
applications as using with jdk age and
older
the diversion of j tips that's in jdk 9
has a bunch of additional options that
that aren't available in the eighth
version and this is one of the
command-line options that is that is new
in the jdk 9 version when you run j
depp's
on on a bunch of jar files with the gen
module info it will generate you a
starting Java info sorry module info so
I've run it on these three jar files and
it has created me 3 module info sworn
for each of the jar files and we look at
that in the next slide so for Jackson
data by which is probably the most
interesting one in this set of jar files
this is the module info that the J tips
tool created for me does a bunch of
requires at the top that that is based
on the static analysis of what's in the
jar file and J depths has no idea which
which which M parts of the jar file are
in the exported API and which are
internal so it assumes that every type
is part of the API therefore every
package is exported so it generates a
little exports director for error for
every one of the
the packages in the jar file if you look
closely at the requires it also looks at
the signature of the methods that are
and that's able to determine whether to
you whether to generator requires or
requires transitive so in the previous
talk we talked about improve requires
transitive and so here you're seeing an
example of it in a generation module
info for this part of the talk assume
that we are the maintainer z' of this
library so we have much more knowledge
about this library than then then J tips
does so and and as as maintainer z' of
this library one of the things we will
want to do is are not want to do is we
don't want to be exporting our input
packages that's where our turn olympian
implementation is it's not part of the
API and for this library we'll assume so
what I might do is I might edit this
this generation module info and delete
the exports that don't make sense so J
tips generates me a module info that
where everything is declared as being
exported but assume that as maintain
errs that we know better and these
simple packages don't make sense so we
will delete these as part of creating
the right module descriptor right margin
declaration for this Jackson data bind
module now we do the similar to what
Alex did and will start to compile this
so what I've done is I've generated
these module info into the source tree
for these three modules that I'm going
to compile remember with with our our
modules we have an additional directory
now in the in the file path that is the
module name so all my source code for
these three modules is organized SRC
slash module name and then my
traditional hierarchy of classes and
organized by package in that tree my
module info is in the top-level
directory of each one of the modules so
for Jackson core the location of the
module info is SRC slash module named
Jackson core slash module info Java
same for the other three the other two
modules
I'm now going to compile all of these
three modules together so I'm
recompiling all of Jackson in this case
all three of them and I'm do the multi
module compilation so what one Java C
command I'm compiling and all three
modules together I'm giving it the D an
output directory of mods that's where
all the class files are going to be
generated and the input to it I'm just
giving it a fine command where to find
all of the the Java source so that will
that will compile I've now got a Mazda
rectory with three directories in it and
all of the class files I'm going to run
the jar command three times and because
I'm going to create a jar file for each
one of my modules this is these are
these are modular jars the options
you're seeing on here is the isdon't is
his new options in jdk 9 so and the jar
tool has historically and had very
obscure and very uniquely Java
options and bit like the the zip tool
some of them they be modernized and in
JDK 9 and particularly to use the canoe
style format at least close to it as you
saw that and maybe in the introduction
talked earlier on with some of the other
tools so the jar tool has - - options so
- - creation - - file so i'm creating a
jar file i'm telling what jar file to
creation this is a modular jar and going
to creation in the envelope directory
I'm naming it Jackson core and a version
number and telling it the dirt the
location of the class files I'm going to
package in and I'm creating three
modular jars so that's really really
nice exactly as Alex did with my app and
my lid in the first part of the
presentation now this is what we've got
now
so we've recompiled Jackson core Jackson
annotations and JAXA data bind we've
packaged them up as modular jars this is
the module graph that we have some the
platform modules at the bottom and then
our three Jackson modules as explicit
modules their dependencies are clear
they're exports are clear this is a nice
module graph
just a recap for how we ran these on the
classpath right at the beginning of the
presentation we're now going to change
this command so that we're running with
these these three libraries as modules
so that's the old command now we've got
the new command so there if for those
that attended the intro talked earlier
on I talked about how to mix the module
path and the class path together this is
exactly a scenario where you have to do
this because my app and my lib are on
the class path r3 Jackson libraries are
now modules on the module path so this
both a module path and a class path
specified to the Java command here my
three Jackson modules are in the MU Lib
directory and I'm specify the EM Lib
directory to the module path option my
class path has been has Maya and my Lib
so I'm specifying those with this - CP
or - class path but exactly like the the
intro talked earlier on there is nothing
to say in in Maya or my lib to say that
they depend on Jackson data bind
there's no dependency information
available on the class path so I'm
having to help the wrong time with the
add modules our option to tell it to
resolve the Jackson data buying module
this is one of the complications when
you're trying to mix the the class path
and the module path together there's
nothing on the class path to tell you
what in it what the dependencies are so
I'm helping the runtime with the add
modules option to tell it I was all V
the Jackson data bind so that is a
command line that I've ended up with
with modules on the module path and my
application on the class path questions
at the end right so now we're going to
put it all together so I've got modules
on the bottom I'm going to take the
modules that Alex generated in the first
part of the talk and I'm going to
combine everything together this is what
we have for the second
TAF now we've got Alex's modules with my
app and my lip and we have this nice
module graph everything is green
everything is modules it's very very
clear what the dependencies are in this
graph so now let's go and run this now
that we have everything as modules
just to recap everything is modules so
if I look in my M Lib directory I have
five modular jars my app my Lib and my
three Jackson and modules my command to
run this has shrunk because I'm just
telling it the module path and the
initial module then the initial module
our main module is my app so I'm going
to ask it to run the to run my app that
will resolve what does my app depend on
life depends on on my lab depends on
Jackson data byte we will generate the
transitive closure all of these modules
will get loaded in order to run and my
app we can go further so if we combine
in the intro talk we had some simple
options are some simple examples using J
link to create runtime images now we
have our application and the Jackson
libraries as modules we can actually do
the same kind of thing this is the
advanced talk so I have a couple of
Advanced Options on the J link option so
what I'm producing here is a runtime
image that will have my app and all of
its transitive dependencies in a runtime
image so this is this is something that
can be distributed with just the mount
modules that it needs so the options are
giving two to J link just like Java C
just like the Java launcher and giving
it the module path as to where to find
the modules I'm using the the add
modules option telling J link what
modules I'd like in the runtime image J
link will generate the transitive
closure and link all of those modules to
create the runtime image
I want a relatively small image so I'm
giving some options to do compression to
do some stripping there's like any
linker there's much more complicated
options I could give it to to do other
customizations of the run time image but
I'm just sticking with the size for now
and what I ended up with is a run time
image that's hat that is in this case
it's twenty six thousand yeah so just
about twenty five and a half megabytes
if I look in the bin directory I see in
there only a small set of tools and the
Java launcher I've CCC's something for
my app that has been generated by the
linker if I run the list mod the lists
are list modules option on this
generated runtime then we see that it
has this is the list of the modules that
are in that runtime image my app and my
Lib the Jackson libraries and then in
this case there's four platform modules
that have been M linked in so this is
quite nice either I've ended up with a
small runtime that for my application
and I can just run it with this there's
no module pack specified because they're
all linked into the runtime image I can
just do Java - M my app and my
application will will will run in
addition the linker will generate a
little launcher script for my
application as well based on the module
name and so I can make the command line
even shorter if I wish and that is a
quick run-through of things from the
bottom up and then combining the modules
that were generated from top down and so
that everything is modules and then we
go further and actually create a custom
runtime image so the main thing we've
got through in this presentation is I
hope that we've actually demonstrated is
that you have the freedom to adopt and
migrate to modules at your own pace alex
has shown how to how to migrate and
marginalize applications before the
libraries have had been migrated it's
possible as we saw in the second half of
the presentation to marginalize
libraries completely independently
in addition you've got a flavor for the
different kinds of modules so um Alex
started off with explicit modules for my
up and my lib and then made use of the
Jackson libraries as automatic modules
that gives you a flavor of explicit
versus automatic modules and also and
showed you what the current proposals on
the table which is weak modules and how
that they can be actually used as well
for especially for applications that
don't export any in the api's so
hopefully that is giving you a flavor of
what of what's there just to support and
migration to modules so we'll just
finish up with a nice catch line and go
forth and modulized so we have a couple
of other sessions and we're mostly in
this room so we did with this is our
third one today and we starting to
repeat this tomorrow at 2:30 and but the
important talks that haven't been done
yet are the modules and services at
11:00 tomorrow and then alex is going to
do project chick saw under the hood at
4:00 p.m. tomorrow and there's also a
hack session which is then I think bring
along questions bring along your laptop
if you want to try things out that's on
Wednesday at 8:30 one of the rooms here
I'm not sure exactly sure which and
that's the two are and more information
so this is the link to the project
jigsaw page we're working on the
implementation of project jigsaw there's
also a link to them there the mailing
list and where the early access bills
and let's see so as I said in the
earlier talks earlier on is JDK 9 still
in development and it doesn't ship and
it's not scheduled to ship until next
year so many of the things that were
actually showing here are things that
are just not finally yet nothing is
final yet they're still just ours is
still discussion they're still early
access everything is is is still in
progress so what we've shown here may be
the final JDK 9 isn't exactly like that
so I think we're we've got about ten
minutes for questions if not
we go 15 minutes if if people have
questions so protocol for questions will
be if you can make it as far as the
front then call into the microphone so
that people can hear otherwise we'll
have to repeat the the questions so Marc
is available for questions as well we
can't actually hear when wouldn't yeah
yeah
in the first one with the automatic
module Jackson automatically depended on
the my app which allowed it to do the
reflection in the second one how does
Jackson rely or reference this is a good
question so the question is I was
wondering if someone would spot this in
the first parts when Jax and data bind
is an automatic module list it's
requiring implicitly actually Maya and
my lib because it requires everything
but then when Allen modularized it's
altogether the arrows are all down yes
so so the thing is so data bind is using
core reflection to access the classes
the exported classes from my app my app
passes a class object to data binds that
was in the little eight the person the
data bind API and that means the code
and data binds can access all as almost
a class as X that class is exported from
my app data bind can reflect over it it
doesn't need it it actually gets an
arrow for free going back up to my app
even even even when data bind is an
explicit module with the module
declaration but clearly it doesn't know
what modules it will be what classes in
what modules it will be reflecting over
so it can't possibly say requires them
when it reflects over them as long as
the class is exported to it's the
reflection just works which if you're
paying very close attention is a change
from last year but pretend I didn't say
that it just works
Lincoln clearly means in effect he said
to upgrade one of the jars
do I need to start from scratch for the
chair or for that module to rebuild
image how the main is the version of
groups of individuals right so I think
what you're asking is you need to rerun
the late the the j-link command yeah
yeah exactly
and J link will actually record the all
the options that are actually used to
make it easy to rerun uh so if you have
a new versions of the modules
I was wondering if you could quickly go
over again what required transitive
exposes about didn't say okay so this is
so the question is about what what's
different about requires transitive
versus requires java logging the full
answer is in jigsaw under the hood but
it's it's not a complicated feature it's
not an advanced feature so fair question
so you'll see Jackson data bind requires
java logging it's an emoji is an
implementation detail of data bind it's
just it's just calling Logging's methods
it's not exposing it in any way the data
bind requires transitive Java XML now I
haven't looked at the data bind Java doc
in detail but what the requires
transitive java xml tells me is that the
way that data bind depends on java xml
isn't for just an implementation purpose
it's because the api of jackson data
bind somewhere in all these exports has
in a public signature a type from java
xml yes what do i write so if you write
a module that requires checks and data
binds the fact that data bind says I
depend transitivity on XML means your
module you could say requires Java XML
is nothing wrong with that if you don't
it will be as if you had said requires
java xml what do you get from java xml
whatever it exports everything it's how
you get module leveled modular
granularity dependencies while still
allowing refactoring by the way there's
a couple of slides on this and the the
intro talked from earlier you may have
missed that but it's you want to catch
up
two questions one one is save got three
third-party libraries and they were all
built with slightly different versions
of Jackson
3/3 okay sure or maybe okay so different
parts of your application maybe even yes
using different versions of Jackson
they're compatible they're just slightly
different bug fixes pick one does that
mean everything else will still let me
ask the first let me ask another
question your application Tran them it's
not your code necessarily the
transitively uses different versions of
Jackson yeah how do you put those jars
on the classpath enjoy decades but if
you specify version one of some
third-party jar and later on on the
classpath version two of then we're done
if you just so you don't in in what
whatever you used to put on the
classpath you were now the exact same
jar that you picked to put on the
classpath just put it on the module path
yeah and then it magically I mean really
it's magic just becomes an automatic
module with the name and we drop the
version qualifier according to some
heuristic that's in the Javadoc so these
are these are the real module names I
can get from that from the real jars the
maven mr. main she kind you is behind
you and has an entire talk about that
once you've upgraded an existing library
system is it still possible to compile
it using the class path rather than the
new module so if you so so let's bring
the applicant let's bring it up let's
bring the Java C in vacation right so
here we are
recompiling the library for jdk 9 right
so this is the source that this is this
is the library source I'm gonna compile
it put it into the mods directory the
class files that come out of this will
be version 53 class files Java SE 9
class files clearly they won't run
earlier than gdk9 what you can do right
so so what you can so what you can do is
compile the source once with - release
seven for example and then compile again
just the module in futur Java file files
in this case don't specify - release the
default will be nine so that will that
will give you class files where module
in for class is version 53 which has to
be the rest of the classes from from
these three source trees will be 51
run them through jar the resulting files
will run on ya if if you're running
jetty q9 the that the class path will
still take modular jars just nothing
will read the module in footer class
files right with all with all of the
dependent with the N factorial
dependencies just to clarify what Alex
it is is you can take a larger jar you
can put it on the class path and it'll
just work as a library in the class path
as as it would have always done yeah I
would in the nicest possible way
question why you want to do that if
you've made if you're running on jelly
canine and you've made a module you
written module for Java or you
found one why you would then want to put
it on the classpath on a on a JDK
installation clearly on a JDK 9
installation I'm trying to work out what
you're trying to do in time though I
think you would expect the tools will
eventually had support for modules yes
start with the follow-up to his which is
it appears that if you put a module on a
regular class but in JDK 9 you are
actually breaking the protections the
access protections yes so yeah so the
access protections are actually not as
tight as they may appear otherwise on
the class path there is no such thing as
a modular jar on the class path they're
just jars and because they're not
modular jars we're ignoring modular
fertile class we're ignoring the exports
so there's no way for a publisher to
kind of begin the protection into it's
only protecting the really the runtime
as as you configure it but the publisher
cannot they actually protect that's
correct
no that's true and and if you're in
control of the on disk layouts the on
displacement of jar files you you are in
control of everything even if the
modular jar files are put on the module
path if you're controlling the command
leaf or controlling the environment you
can just say - - at exports and decides
that you wish to as the the system
configurator overrule the exports in the
modular jars okay you can do that a new
first example legacy Charles if I wanted
to protect my app for not being a weak
I could actually have a qualified export
to Jackson yes yeah so so you know if
you don't say week the default is that
the module is strong
you then have to enumerate your exports
you can choose to have them being
exported qualified to not just to
Jackson but to Jackson data bind in
particular yeah yeah and the rules for
reflection and regular access of these
signals exactly okay also they are
dominated by the exports that aren't on
this slide because they're they're
implicit but those providers to those
module or job we are we are hoping that
framework developers like the Jackson
developers will write module info dot
Java files for their code and produce
modular jar files they're still jar
files but they have this module info dot
class file in them so that on jdk nine
the runtime knows to do the strong
encapsulation and the public it doesn't
mean they will expose so is public
that's right so so if you look look at
the crossed outlines so calm foster XML
Jackson data bind DISA in pull that
package I'm pretty sure has public types
in it those public types will only be
accessible within the data bind module
which should be exposed but when when
when another another provider they
mainly use this job but they define
their own module then they expose this
one when you use it even they are you
the same version but that you don't know
exactly what was it I'm confused sorry
it's amazing in some ways it's always so
simple when you look at the artifacts
but he did this and she did that well so
and so but don't don't reversions into
this you're saying this through his data
bind that has chosen to export a
particular API right the author the
author of data bind is saying export the
first four packages and then there's
another one
etc etc you said you said another module
another one when they define that
Jackson annotation model infer file they
say they expose this class okay so this
was used by the define but another class
maybe my application I also use the
Jackson a notation but I decided to use
another the same version of annotation
but the IP said I don't expose this
class then another one they use my
application they also used a Jackson
data ban when they look at the module
information they will see the same
information because they use the same
version then they learn to me pick one
then then they don't expect the what the
real result I understand you're saying
that the Jackson annotations module one
version exports package and another
version of Jackson annotation doesn't
export the same package that's your
scenario I think that's a little unusual
that you can you could imagine it
happening but let's assume it happens
Jackson whoever is picking the version
of Jackson data binds to go on the
system
because my app requires it also has to
pick the version of jackson annotations
that that record that very first
requires clause will resolve against
there's only one version of anything on
the system if there are two versions
jackson annotations pick one because i
think it's a good feature to have those
decided to expose which package you
can't do it on the classpath today you
can't do versions on the classpath if
the next five questions are about
versions it's still gonna be pick one
sorry thank you okay so you've shown how
to do top-down yeah when you're the
application owner yes you know to do
bottom-up yeah when you're a library
developer that has just Java modules
dependency mm-hmm
what's the story if you in the middle so
you have library you'd like to move it
to be module but sadly some of your
dependencies are not yet modules should
you do it or should you wait until the
the graph underneath you is clean you
should do it yes okay you should do it
and you should document and when you do
it let me bring up take turbines so if
data binds required guava for example
and guava is not yet an explicit module
you are presumably testing your library
against some version of guava you can
write requires guava in here I'll assume
it's it's not exposing guava types and
signatures and you need to put in your
documentation that please put guava
download some version of guava and put
it on the module path because you are
being a good citizen but your this this
is the the issue of issues if if if if
you wait to modularize
then some other libraries correctly
tragedy of the Commons
and it's important thing is is that
libraries can actually migrate
independently that's that's really what
the first part of the person Park is
there's just a small type in the in the
way you and the the modules end up being
named so you need to pay attention I was
gonna say the next question that people
then ask is okay I'm data bind I'm a
good modular citizen who hopes to be
linked into an image one day that would
be nice but I require guava and guava is
working as an automatic module on my
system in there for everyone's what
about when the vendor of that module of
that jar makes it into a modular jar
when they declare a module and they
decide to call it something else that
would be that would be impolite of them
okay so in a way in a way the name that
your jar as today yes and the way you
have automatic naming yes is be
respected in the part of the public API
we should the second question is much
simpler so I missed the intro table so
what I understand from here is the if
you're just a regular you know
application they will apply just depends
on libraries like Jackson and stuff so
then probably you should you should just
do the top down which it seems much less
work mm-hm and it's just if your app is
there you just set it Eclair it as a
week so that's the contact but then if
you just do top down and get up and
ready at least for your module I mean
your app to be modularized and that
should be good enough to go it is very
common to be able to download a jar from
the internet such as Jackson there like
they might be JDK six five or six zero
class files in those jars put the jar on
the module path it will very often work
as an automatic module
which gives itself it's a name it
springs into existence so so that your
module info dot Java in your application
can require it that works surprisingly
often and if it doesn't work don't call
us
call the author of and I can tell you
some of the reasons they are either they
are either accessing JDK internals which
is nothing there nothing to do with the
modules it's not really the module
system it's not automatic modules that
are the problem they're accessing some
internal thing and their jar won't work
on the classpath either if they're not
accessing JDK internals you occasionally
find traditional jar files that contain
classes in the Java X annotation
namespace in the Java X XML registry
namespace and so on and so on
they should not be including those
classes but they do and the module
system at startup detects that there are
some package that has classes in the jdk
image classes in this automatic module
that's a bad thing something funny is
going on so the system will stop and if
that happens don't call us call the
creator of that traditional jar to say
why have you got Java SE types in your
random jar file that's never been a
supported thing can be it's actually
relatively rare but when it happens you
are in trouble someone else has got you
in trouble thank you thank you UH one
more question yeah I think said we'll
have to wrap up them in this last
question outside of like smoothing over
some of the class path issues is there
any other benefits that these modules
would give you are you developing is
your jar an application jar that no one
calls or is is your code a library that
lots of other people have both okay
how many jars are there in your
application
something there's probably maybe 30 50
50 just in our application how do you
track the dependencies of code between
classes in those jars is it a big ball
of mud yeah that's what the JDK used to
look like the ability not only to
express the ability in a module to say
not only what it depends on but also
what its API is now there are some jars
at the very top of the graph that don't
have an API there they got the main
class but for everyone else there's an
API that it is worth declaring
explicitly you can declare these exports
are to everyone if you have a nest of
jar files you can export to your friends
and what that means is you will never
again it's an investment you make once
and once you made it you will never
backslide into why is he are you the
business partner why is why is he
calling this type in my package it was
meant to be internal protected as a
whole mess of access control complexity
in order to share anything between
sometimes you want to share between
packages with public yeah you want to
share with him other times you have
types impact you you have a package that
you don't want to go outside a jar you
I'm pretty sure you at some point said
this package is just for other packages
in the same jar file that's it that's
what the module system gives you okay
thank you by the way on the ball of mud
we had a slide showing that in the intro
talked earlier well the ball of mud is
kind of that's a ball of mud
very symmetrical okay I think we're done
we're wrapping up thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>