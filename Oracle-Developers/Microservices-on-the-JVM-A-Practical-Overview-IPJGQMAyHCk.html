<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Microservices on the JVM: A Practical Overview | Coder Coacher - Coaching Coders</title><meta content="Microservices on the JVM: A Practical Overview - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Microservices on the JVM: A Practical Overview</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IPJGQMAyHCk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everybody to our talk
microservices on the JVM where we'd like
to give you a little more practical
overview on what you could do with micro
services on the JVM my name is Alexander
housing field and i'm martin i can book
we're both from E to Q Germany so there
are some assumptions that we made when
when we actually set up the talk that
for example that you heard about the
password microservices before and that
you are actually sort of familiar with
the micro service architectural style
that has been discussed around the the
internet for example by James Lewis and
that you know about the let's say
different opinions and discussions going
on like the ones we mentioned here
whether microservices are actually
defined by lines of code or whether
microservices need to have a separate UI
or whether the UI is contained with the
service or whether microservices are
actually just password and it's actually
service oriented architecture just in
new clothes so we kind of need some work
this definition for our talk today I'm
dumb so we okay so here's what we are
going for ya we found some some points
that are actually important for us from
derived from from the whole discussions
around this and the first and most
important topic for us is that micro
services are actually build around
business capabilities this means for us
that you actually should focus on the
business use cases and that a micro
service actually tackles only a certain
set of business use cases within the
same domain leather something that is
very important for us in the first point
that we want to want to underline okay
so we believe microservices shouldn't
share process so each microservice
should have its own process like
a rice process so that means
microservices have their own life cycle
in terms of deployment you can start or
stop one micro servers without touching
different services so that's important
because it emphasizes the self contained
on the isolation between microservices
another point that goes very well along
with this is that micro services should
be self-contained that means that
actually a micro service shouldn't have
any dependency on something that is
pre-installed on the system it should
bring everything that is needed to run
it with itself that is actually also a
very good very good preposition for for
deployment to means you don't couple you
oh sorry question
okay so the question was what does that
mean for java programs should they bring
their own JVM what does self containment
mean here so my opinion is at the end of
your like built pipeline you should
provide an a PM or debian package or
something and within that you can
express your need for a game for example
but we will tackle exactly this later on
okay so being set contains also means
you don't couple yourself to like an
application server which expect to be
already deployed so if you need some
containers and software container
something bundle it with the application
so that we are already it by loose
coupling so don't cover yourself to to
like a platform but also don't couple
microservices against each other tightly
yeah that is best done in our point of
view if you couple by data format or if
you depend on certain data formats and
of course on the transport and service
discovery another point would be
independent life cycles life cycle in
terms of when you think about the
application lifecycle not about the
runtime but actually did the development
time the idea of independent life cycles
is that your micro services can be
versioned independently from each other
that means if you for example have a
product catalog that can be versioned
and have a faster pace and development
than for example a user service or a
user management so the life cycles of
microservices shouldn't depend on each
other so the last point on our slightest
decentralized management sometimes when
we talk to customers about micro
services they come up with the idea of
like a very central um USB for example
for orchestrating with services and we
believe that when doing microservices
you actually want smart endpoints that's
your services are smart but the pipes
between this
should be dumped so yell do maybe you
use like a message queue but you don't
put much routing logic or something
moving within your bus keep that logic
and your clients in your services and
because this is the let's say a very
specific view we when we talk about this
we actually try to try to name it a
little bit differently basically like
self-contained system because
microservice as we said is a very open
open word actually buzzword that
everyone puts his own meaning into it
and this would be like a very
self-contained system system bringing
everything with it that's actually
needed to run it but for the for the
sake of it we're going on and the in the
talk to to call it microservices so to
be specific we're not talking about
certain things because this would easily
break the the timeline of the talk and
what we're not talking about is for
example the microarchitecture what we
mean by this is there is yeah that's
correct the question is if you say that
the the services are self-contained and
only loosely coupled how do you manage
dependencies like when a user bicep
product and the you said that the the
product service should have a dependency
on the on the user but that's not
necessarily the case and actually we
have an example following up that will
explain what this what what this is
about well the more general answer may
be of course you have dependencies
between services you can't decouple them
totally because they there would be no
yeah no coherence between them so the
the goal is to define the interfaces and
such a way that you can have downwards
comfortable changes so you can advance
them with different life cycles so you
will have dependencies but you try to
reduce
for example as I said you depend on on
certain data formats that's your
exchange actually we are moving bit off
from where we wanted to go because we
planned to not talk too much about
slicing because we want to go into the
library and tooling and slicing
microservice is a whole topic on its own
and we would need another talk to take
care of this yeah the point is that
actually the the slicing is certainly
varies project specific because as we
said in our point of view you should
slice based on business use cases and if
you say that your business use cases are
so tightly coupled that you cannot split
them you probably shouldn't split
separate microservices from it but that
needs to be looked into into detail so
yeah it's not something that's something
that would seriously yeah get they get
the talk too long yeah slicing is
something that we that we just like take
an approach and might not be the best
but we're not talking about it and
another thing is the communication
protocol that is for for our demo that
we're doing it's currently set okay so
let's put that into some some pictures
so we have some different services and
all of these services may have their own
decisions for the internal architecture
or tooling so some of them might have
your eyes so that's why we prefer to
talk about self-contained systems the
service may not have a UI but our
microservices have your eyes but some of
them maybe have not your eyes like the
value right one and some of them might
have persistence some might not so
obviously these services would like to
talk to each other so when in this talk
we've chosen HTTP we think that HTTP is
a reasonable default protocol form for
communication because it was designed
for as application level protocol for
distributed systems which actually
that's what we have here of course there
are other choices you might have but
that's
well beyond this talk okay too to
summarize the let's say the theory and
to get in to get into the practice we
actually thought about listing the the
challenges that we find as developers
when we think about micro services and
we want to build microservices in to get
microservices into production the first
challenge that we have to face certainly
sorry certainly service registration and
discovery because as we don't want to
tightly coupled systems we need to find
a way to discover and register services
at runtime so for example if you scale
your product catalog and say okay my
load on the system is so high that i
don't need eight instances but i need 15
now then the system should self register
itself and make the other services aware
that there are now more instances
available that they can send requests to
that would be service registration and
discovery that we have to think about
when we develop microservices another
problem is resilience so obviously you
want your whole system of systems your
whole application to be resilient but if
you slice your introducing network
everywhere and network calls for
problems because it kind of sometimes
not works that you want to
compartmentalize your application to to
keep failures isolated and to avoid
having them spread all over the place so
you have to think about resilience more
than you do when you just deploy one
single monolithic application another
point would be distributed configuration
so for example if you think about the
product catalog that I mentioned this
will certainly have some specific
configuration values for the for the
micro service but usually if you deploy
more instances you want to have almost
the same configuration for those
different instances and you don't want
them don't want this to be tightly
coupled to your 2-yard to your micro
services because if you want to
change one configuration value you don't
want to change it on all the systems but
the system should like pull it from a
from a central configuration repository
or something like this so this would be
distributed configuration will be a
topic of configuration management so if
you increase the number of units you
have to deploy automated deployment
becomes more important than ever so if
you're doing microservices you certainly
want fully automated deployment to your
production instance so on because we're
talking about development frameworks we
believe that the boundary to
configuration management should just be
packages so we expect our development
frameworks to produce maybe rpms or
Debian packages and have the
configuration management pick it up from
there and the last but very important
point metrics actually without proper
metrics of your application in
production you are literally blind
because without the metrics you don't
know whether your application is
actually healthy or not and you have to
certainly find a way to publish your
metrics and then make it available by a
matrix collector or something like this
so if we look at the frameworks to
develop my own micro services we
certainly expect them to support
developers with an easy way to expose
metrics to to the operations team so we
would like to show some code and to do
that we need some example use case so
here's our use case that's buy something
so what do you need to buy something
well first step would be like to select
product yeah the second step would be to
put the product into some kind of
shopping cart currently just with a
within a session without any user
context then maybe you repeat yet stuff
to your cart and then finally you want
to pay yeah so you're going to check out
you place your ad um what you're done um
well for this case we just said okay we
just make three services out of this
we are aware that this slicing decision
what could be discussed but it's enough
to to have some problems and to present
some code here so each of our services
contains a UI in this case and because
we wanted to showcase different
frameworks we've chosen different
technologies for each of this so be
armed yeah here's you see play too for
the product catalog the drop wizard for
a choke by the shopping cart show cut ok
ok and spring boot for the Orang system
yeah the coupling is basically that the
systems have to know each other by a
configuration or via service discovery
and that they only rely on the data
format which at this point would be the
Jason of the of the product that should
be bought ok so let's have a look at the
opposite so what does drop wizard
actually it's not a framework but it's a
collection of libraries and some glue
code for that at some Java framework so
everything is done in Java that's
looking to the different libraries so
the HTTP server and drop wizard is just
to jetty so that's a very fast HTTP
server and we can easily bundle it with
an move our application on top of jetty
we use Jersey that subjects s reference
implementation so we can have invest
relay p I or web sites so HTML on top of
our server unfortunately the current
version of crop wizard bundles an older
Jack CS version or just lieberson
version so wheels do one point something
here um then there's metrics that's a
library that some not so well known but
it's included we've been dropped with it
and enables us to yeah gather metrics at
various points we will see that later
and then there's a whole bunch of other
stuff which perhaps is well familiar to
you like for example Jackson for Jason
marshalling and done marshaling so most
of this should not be a surprise section
okay so here's what we see from the UI
that's a shopping cart it's very easy as
so that's just a list of things we've
put into the cart and what's interesting
here is that the the persistence of our
card will not store all these details
but it's does an ID special specifically
on URL for each product and when
displaying the card it will resolve the
details from the catalog so it needs to
do a call to the product catalog we see
if the data via Jason okay let's have a
look at code so in jax is armed mapping
of your else or purpose to code is some
stunt via annotations i try to try to
step you so you see these paths
annotations from each access that map me
code to the URL we also see an
annotation do you hear me ok so we've
seen an annotation for the method that's
they get here and we see a way to bind
parameters like this idea OMG so if you
have a look into the method you see that
we first look up the items for one car
tidy that's the line saying find items
for car ID that actually gets gives us a
list of your else and then we resolve
each of these URLs against the product
once we have all those items we put them
into a shopping cart view that's just a
simple Java Bean and drop with it comes
with a way to render this beans that's
via standard jack says message body
writer be some this Venus rental /
template so drop was at bundles mustache
and free market templates but you could
easily roll your own um message body
writer if you want to use another
templating language okay I'd like to
have a look into actually resolving the
products because that's that's typical
use case you want to do it HTTP call so
we are an HTTP server but if you do
micro servers it becomes more often the
case that you actually have to do a call
to
to a different HTTP service so Jersey
comes with an HTTP client and you can on
configure the underlying technical
client and drop wizard bundles this move
the apache HTTP comments client and
makes it easy to configure Vegas so if
you ever use HP client you certainly
want to be able to configure for example
timeouts that's possible here by a
common configuration approach in the
opposite so how do we use a chip here we
see that we just say client dot resource
give it a URL then we set the accept me
the type we want and actually do a get
and the woman to get we tell it we want
a product so someone is going to
deserialize the jason into a class here
so again that's done by message body
readers from jax is and behind the scene
it's jackson that's working here so we
have a product class that's annotated
with jackson annotations to tell us how
to do the marshalling okay so um that's
all final well actually it isn't because
it's very dangerous what we do here
that's a cross system call and that can
and will go wrong so what happens if if
this recurse blows up we got an
exception for example well we the whole
page basically we are going to render
will blow up so that's bad but there are
things that are even more better than a
fading call and that's call that fails
late so now imagine if this call just
takes a very very long time before
fading that means we will block a thread
shield because that's a blocking car and
one of our application splits is some
thought into this client code and it can
be very easier the case that just a few
of these calls are eat up all of our
threats and the complete service becomes
unresponsive and responsible so we don't
want that topic we are talking about
this resilience we want to isolate for
here so if one of these services fail
the rest of the application should still
work somehow
we want to find a way to provide maybe
fallbacks all from yeah so if we can
treat your service maybe there's a way
we can deal with this on in terms of
business logic like providing an
alternative but technically we need a
way to provide that to the library so
that's what we call graceful degradation
and we want to be responsive in case of
failure Exley actually that's the
definition of resilience so I already
said on the last slide even worse than
failing is failing up to a long time so
if this other service were depending on
it does not respond we should at some
point in time noticed that and stop
calling it we can then just fail right
away that call instead of doing the call
wasting of that waiting for a long time
and then fail anyway so there's actually
a pattern for doing this and that's the
circuit breaker ah if there's a picture
of this book from mcelligott it defines
a lot of stability anti-patterns and
patterns and one of these patterns as
the circuit breaker the idea of circuit
breaker is to put between your requests
or by a client and the actual service
that might be UV the HTTP call but that
might also be access to a file system or
anything that's dangerous we put the
circuit breaker so usually if everything
is fine the circuit breakers closed
calls just go through to the service and
the answer goes back but if at some
point in time called start failing the
circuit breaker will notice and switch
to open state that's the second line
here and an open state the circuit
breaker will fail fast but that's
whenever your client doesn't say as well
I want to make a call that make us ser
failed so and this means we can yeah
fail fast we reduce load on that
external service yeah so we hopefully
that other purpose recovers at some
point in time so we can configure like a
reset period and after that the circuit
breakers which is to a half-open state
it will then allow one call to proceed
to that other service and if that
succeeds it will
which back to closed and all walcott's
can work as normally it's important that
you actually get to know this this
pattern assess Martin said it's just one
of the patterns that is defined in the
book but it's important to understand
that this is one of the the main
concepts that really saves your life in
distributed systems right so yeah this
is this is the reason why we were
presented here and actually the problem
with with drop wizard is that there is
nothing that provides resilience for us
except for the time outs of the HTTP
client well that's not totally true okay
so other patterns you would yeah timeout
itself as a pattern because it means
you're on protect yourself from draining
all threads forever and what you
certainly want to do is Park heading
like if you do something dangerous you
would not allow this dangerous part to
eat all of your applications that's but
you assign it a different that pool and
say okay if this pool is eaten up you
can't do that call anymore but the rest
of the application stays responsive and
actually there's the question
the question was when do we know whether
the service she'll go from open to a
half open state and the answer is that's
configurable so after a certain amount
of time by default the the system will
switch to half open alone bellowing
exactly one request to go through and
check whether the request is successful
that actually is a very good pattern
also I think you mention it for the
other service to be able to recover
because there's there's no point and
actually firing more requests today to
the service this is actually not able to
cope with the amount of requests already
there's actually more things you would
like to configure perhaps for circuit
breaker for example you won't switch
from closed to open just because one
failing call because that might be like
business logic failure so but if if it
keeps failing and yes like in the time
we know a number of failures you will
dance which so all these should be
configurable so in Java there's actually
one very important the famous
implementation of a lot of stability
patterns and also for example of the
circuit breaker that's history so it's
done by Netflix and it provides a
commander with orientated integration of
services that is every dangerous thing
you want to do you wrap in command and
hand this command over to hystrix and
say run it and it will provide the by
carrying will provide a circuit breaker
and timeouts so you get a lot of
isolation just by using this library
armed robbery which comes with a rapper
round hystrix called tenacity and
basically hooks up hystrix to the
contribution library and the metrics
library within drop wizard so let's look
at some some co diem so this is command
have talked about and the the core of
this commanders the run method it's very
similar to what you think runnable is so
within the run method we have the code
we've already seen on the slide baseball
so that's the call HTTP call and the
rest at the top is just just constructor
stuff and we have the way to provide a
fallback of this get fallback method in
this case i've choosen a real
bet fall back that's just now but you
might have a better fall back in in real
business use cases okay so that's how
you implement in command we'd like to
see you be how do you use the command
well that's in this case very simple you
just after constructing the the command
can just go command execute and this is
a blocking call so at some point you
will get get the product or you will get
the fall back and the actual execution
happens in its own thread pool and this
you have the spike heading exact breaker
advantage okay istics comes with its own
metrics so it's collecting the data of
the number of failed calls and so and
you actually can visualize listen
despots so you get an overview of the
health of your system in this way okay
that was hystrix metrics but drop with
it also has metrics for other parts of
the system so bundled célèbre and
provides easy hooks to integrate them
for example you can annotate your
resource controller with a net timed and
so you then get metrics about how often
your your resource was called healthy
response time sound so on the HTTP
client that we use is also already
instrumented so you can also get a
feeling from the metrics about the
behavior of the other systems you're
calling and you can see that in
dashboards whenever they start to
behavior that basic JVM data has also
provided like heap size as normal stuff
so how do you get the matrix the can for
example arm reach them as Jason from
from HTTP resources that's what's done
by default and drop wizard but there's a
lot of other ways to expose them so you
can read them over j mix you can even
write them just to file or CSV or
standard out but you can also hook them
up to two other yeah like matrix service
okay let's do a roundup of crop was that
we have seen it several annotation drift
we seen it includes metrics and arm has
a history x integration we haven't seen
how to build packages out of that but
since it's built with maiden you can use
standard maven plugins to do this and it
actually works fine because we complete
live with self-contained it brings its
own HTTP server so that's not not a huge
problem in building these rpms what we
haven't seen is here support for like
service discovery or distributed
configuration so that's what is kind of
missing if you're using job wizard the
next framework we looked into is spring
boot and we actually used it to build
the the order system spring boot is last
year's newcomer to the rapid application
development race and yeah let's say
actually for the for the spring stack
it's uh it's awesome really because
let's say it takes an opinionated
approach to the to the default
configuration one of you ever wrote a
spring application you always want to
configure stuff and the nice thing about
spring boot is actually that it comes
with a with a set of decent presets for
most of the configurations that you will
have to do but you can always override
it now I will show this later spring
boots can be used to write applications
in Java groovy or Scala and you build it
with maven or Gradle and it puts out a
self-contained jar or wall file and as
Martin already said for drop with it it
also relies on maven or Grail to build
something like an RPM so you can specify
what should be inside the RPM inside
your Gradle or maven build script
otherwise it depends on jdk six or
higher to be pre-installed on on your
machine and something that as a spring
developer i actually like is that it
finally tackles the dependency hell
and this is done via pre-packaging what
this actually means this if you ever
built a spring application you'd
certainly have something like this so if
you want to build a spring web
application you will have to have
dependencies on spring core spring NBC
you want to have Jackson High van and
validator some kind of logging framework
hopefully you want to do testing so you
have dependencies on J unit you have
hamcrest smoke eat or whatever but the
point is that you were responsible for
picking the correct versions that will
actually run together what spring boot
or the spring team did with with spring
boot is to actually build some starter
packages to get you started fast which
means they built for example a starter
package for web applications just comes
with all the dependencies that you
actually need and some more of them for
example them a prepackaged tomcat 7 and
they are actually pre-tested which means
that you can just get it off from the
from the starter web and build your
spring application upon this which is
really really time-saving the problem at
first will be okay what if I don't want
the versions well they actually took the
approach to write maven and ungraded
properties for this so you can always
override the versions in your Gradle or
maven script if you want but of course
then you're again responsible for
picking the correct versions that will
work together so what I meant with the
pre set of configurations is this is a
let's say the typical started class for
spring boot and you will notice the ed
enable auto configuration up there this
is actually enabling an opinionated
preset for all the configuration
properties that will be there so for
example if you chose the spring boot
starter web dependency in your Gradle
script the enable auto configuration
will act
they detect that there is a tomcat on
the classpath and we'll actually at the
configuration property for the config
for the Tomcats HTTP port to your
configuration as you might not know what
actually is inside the inside the
starter bundles you will certainly want
to know what kind of presets spring boot
took there and they expose it by an HTTP
resource which is called auto config and
you can see all the properties that are
that are there and if you don't like
some of the properties you can actually
override it via a file that's called
applications or properties that you have
to put into your resources folder or you
can simply override it as startup
parameters so this is actually great for
for cloud deployments where you can
actually say okay my application starts
with following set of pre-configured
parameters what you cannot do as far as
I know at the moment to say my
application properties lies on this
other servers so distributed
configuration is not pre bundled but I'm
going to come back to this later another
thing that spring boot comes with is its
own idea on metrics they actually have a
actuator dependency that you have to put
into your into your Gradle or maven a
build script this will enable so-called
production-ready features what this
actually means is that they expose a
health and info and metrics endpoint so
on HTTP resource that you can query and
it also adds like metrics services to
your application context so if you are
familiar with the the spring dependency
injection all your beans are in your
application context and you can via the
actuator you can actually inject a
counter service or a gauge service and
add
some custom metrics this will look like
the following so you will actually add
your counter service to with the ad auto
wired for example then simply call
increment or decrement and provide a
name for the property that you that you
want to add and if you look at this what
I wanted to find out with the order
service is I wanted to get a statistic
on how many calls I had to the to the
order service with a cards with a
shopping cart that contained three
products how many calls I had with the
with a with a card that had four
products and so on and you can finally
do an HTTP call to the to the metrics
HTTP resource and you will find this
line inside your inside the adjacent
that is returned by the biometrics HTTP
resource if you look at this this is
actually a perfect example for an
histogram but unfortunately as I said
the the spring team decided to take
their own approach on on metrics and
they didn't use for example Dakota Hale
metrics that are built into drop wizard
there is no histogram they only have a
counter service and engage service so if
you want to build histograms or other
kind of kind of metrics you will
actually have to add the dependency of
for example code 'hail metrics and then
the the other like services or like
metric metric types will be available to
your application but by default it only
has the counter service and the gauge
service so this is yeah now to
satisfying but at least there's
something so yeah
the question is if I could abstract my
metrics from the business logic so at
like annotations to two methods like the
Dakota Hale metrics library would if you
use the Dakota Hale metrics library
inside your spring application you can
actually use the the metrics annotations
but as you might see in a second as I
said spring boot is very tightly coupled
to the spring ecosystem it leverages all
the stuff that you have inside Springs
so if you didn't want to use spring
anytime soon then yeah you're not that
well off let's say so if you take the
decision to build your application with
spring it's perfect if you one day
decide that your application shouldn't
be built with spring you will probably
have to rebuild it and that's actually
one of the one of the things that you
that the idea of micro services are
actually that you have to say you build
your application the smallest and the
thinnest way that you can depending on
use business use cases and if you have
like different use cases or want to use
a different technology you either build
a new service or yeah you build a new
service okay as I said you might see in
a second how does it look on the inside
this is very familiar to what Martin
already showed it's actually a finally
finally template which is the first
class citizen in spring MVC and as you
see here this is just a typical
controller in spring MVC there is
nothing spring boot specific so
actually most of the stuff that that
spring boot provides is in the
application class but you wouldn't have
anything except for for example the
counter service that is put in by the
actuator that actually reminds you that
this is a spring boot application that
could just be a normal spring MVC
application there's nothing special
about it what you see here is actually
the the call of the of the Auris service
that receives the list of products that
should be ordered and what it does it it
tries to resolve the products via the
product URI get the Jason back and this
one does it actually get the jason and
marshall it into a into a product class
this is as i say a typical spring coat
is nothing special about it i just
leverage java 8 and the streams to get
the get an async call here if you look
at exactly those two parts of the code
you will actually notice that i didn't
use spring asynchronous support the
reason for this is that spring boot
currently only supports spring 40 and
not the latest version which is going to
come soon someone whatever and that the
async support will actually only return
future and not the for example the
listenable future or completa bellucci
and yeah the normal jdk six futures are
like not that usable yeah very good yeah
exactly that's why it's the topic is
resilience so the question is there is
no circuit breaker here so we have an
asynchronous call that will actually not
block our request thread so all the the
products are resolved asynchronous
Lee in a separate thread pool and we
only block the the request thread to
actually combine all the all the futures
and get the list of products there but
if we look closer at how the call is
done this is actually not too resilient
right there are no timeouts configured
here and there is no circuit breaker and
nothing and that is actually because
there is nothing in spring boot to
support it you will have to code it by
hand or if you're completely into the
spring stack you could also leverage the
power of spring integration but there
would be a different spring product and
not something that you would have and
let's say in the default but actually
I'm let's say I managed I mentioned
different problems that that I have with
it with the current approach but it's
not too fair because spring boot was not
built to build microservices but to be a
rapid application development framework
that is a competitor to the let's say
previous or standard way to build spring
applications and turns out that the
spring team noticed about the problem
when you use this in in distributed
applications and only recently like at
the spring one conference they announced
a different project that is called
spring cloud what that brings is
actually a focus on cloud deployments so
it's the new umbrella project for they
call it cloud connectors which means
there are many sub-projects focusing on
the problems that you actually have with
distributed applications and some what I
personally like about it is okay it's on
top of spring boots so you would
actually have to use spring boo to to to
use it but it's not only focused on for
example the netflix tag as others would
do it right because if you if you couple
yourself or your distribute
systems to only the products that
Netflix provides then what if Netflix
goes into a direction with the product
that you don't like or your company or
your applications do not support or you
don't want to support this so the idea
of this of this umbrella project is
actually to get you a little bit a way
of the from the dependency on on Netflix
but yeah it's actually the first stack
that they support so what will come with
spring booed and that is as I said
Justin just been announced and inside
the the github project and they have a
configuration server for distributed
configuration that is built on get that
means you can that you can check in your
configuration and a git repository and
it's available via HTTP they provide
convenience annotations for Eureka which
is Netflix version of service discovery
and registration and they also provide
convenience annotations for histories
and Martin just showed you the way that
you will have to implement the the
district's command which is quite a lot
of code and the spring cloud version of
this history will just be an annotation
which is called hystrix command and then
this method that is nowhere different
from what we had before will be wrapped
inside the Mystics command and will
definitely be called asynchronously
that's different to the explicit usage
of history because there you can
actually decide whether you want to call
the method asynchronously or
synchronously another thing that came
into my eye when I looked at this is
that this is supposed to be a method
reference and I don't know how many of
you actually do refactoring the Ides but
I can already see that this will not be
changed when i change this method name
right so
oh hopefully as this is beyond bleeding
edge I hope that they they will change
the strategy but this is currently in
place because they they still have I
think job 5 support for this project and
yeah we'll see right so what can we save
the of the spring boot roundup so said
it's definitely focused on the spring
ecosystem and provide better start up
time for building applications with with
spring but yeah let's say it's not not
too not too well prepared for actually
building yeah distributed systems in
spite of having already the
configuration externalized and support
for metrics but you will do you will
have to do a lot of resilience stuff by
hand and using for example hystrix at
the moment because spring cloud is still
bleeding edge though there are some
concepts that actually am looking
forward to to try out yeah that's
actually the way that that i know of
yeah that you can you can specify the
property else sorry the question was
whether there is no way to to have your
properties file located somewhere else
and as far as i know you can define the
properties on the command line but
that's that's it yeah
correct the the the guy over there
mentioned that Netflix actually provides
our chaos which is a configuration
server or approach to distributed
configuration I'm not sure that that's
possible to use this with spring boot
because spring boot actually wants to
wants to have the configuration inside
the application properties I'm
personally more looking forward to the
to the configuration server that that
they build because they took the
concerts for our chaos and yeah let's
say it took the features that you have
with get and just made it like
technology independent and our chaos is
very tightly coupled into your
application as far as I know and the
idea to just have the the configuration
available via HTTP and that your
application just doesn't HTTP call to to
query the the configuration is a lot of
less inver civ to your application code
yeah the the the next framework we
looked into is actually play two and
Scala okay so play two is a bit
different from what we've seen before so
it's not less like the other one has the
Sanitation driven approach and for these
of these examples i've choosen scalars
implementation language here so play two
is based on top of a current which is an
implementation of the the actor model if
you don't know what that its you can
think of it as a easy and different way
to reason about concurrent um
computation and it makes it easier to
make a synchronous apart and to build
resilient applications but you don't
have to vary too much about this in the
beginning so what it's enabled someplace
that we have a strong support for for
HTTP servers and clients okay but let's
first look into the the application so
this is how our store looks like we're
four products here you can buy thats
four books
we also tell you what the current best
seller of the New York Times's so
obviously there's come from two
different sources so the best seller
comes from an HTTP API which is exposed
by the New Times and that other stuffs
comes from persistence or from a service
within our service infrastructure so
what happens if for example the these
times API does not work while we expect
our application to gracefully degrade to
just show the product catalog so we
would like to pick up various from
different services and if one of that
phase well that does not need to fail
our complete application so that's what
we are going to build so if we do some
vet programming usually I need routing
so that's map some URL to code and we've
seen this done by annotations and the
two previous arm applications here and
play it's done by a configuration file
much like it is in ruby on rails for
example so we here see that be HTTP verb
we get and the path together are matched
to some code or some method okay so
let's look into that coat so that's
women and controller because this
language might be new to some of you
i'll try to explain it a bit so the
first line tells us object books
controller that just means these books
controllers a singleton so object tells
your intent to instantiate it and keep
just one instance so books controller
extends controller so that's inheritance
and it means just it's a controller in
the play sense and now therefore method
def books is a method definition and
these action as i'm from the Play
Framework tells it that we would like to
make this call non-blocking in a
synchronous so ever HTTP request comes
this method will be called it will
return a future very fast and then
eventually this future will be resolved
with the answer and then the play will
pick up the ante and respond to the
client so let's look into the
implementation what we do here is pick
up two other futures that's the best
seller future and the books future so we
are doing to a synchronous things
fetch you both futures and then move
some nice syntax that's cause of for
convention we pick up the values from in
fact futures once they are they are
resolved that's these bestseller and
books and then within the g8 block we
put both of them into a view so what's
the view you see this view HTML books
that's actually just a function so if
you think about what use do they take
something and spit out HTML well that's
a function so every view and scholars in
play is just a function of course you
don't have to write that function menu a
little bit but you have some templating
language and there's a compiler plug-in
that or the build system plugin that
builds some code out out of your
template so let's look into the the best
seller future stuff so that's doing an
HTTP call to this API and it can be done
with the vs client here so we do bs30 or
error give it in ul and say ok you'll
get what we get back down again it's a
future and eventually it will contain
value that value will nap and while we
that Jason and maybe positive to some
some domain object here so that's an S
in Crohn's non-blocking call that's fine
so far but still it could fail so how do
you recover from failure while you just
tell it to recover and you say well and
if any exception comes we will turn an
empty list in this case so we won't have
any best seller but that's okay we Jen
does just display them so we now have
recovery from failure but we don't have
all these circuit breaker and timeout
patterns here and of course you could
pull in hysterics again and rapid but um
that would be like like introducing yet
another technology because this is based
on a cadet it's more naturally to use
acha circuit breaker that's how it's
done you define your breaker and here
you see very explicitly various timeouts
and the max failures for example so we
are telling it to to switch to the half
to the to the open state after five
failures and then after reset time out
of one minute it will try to switch to
half open and then back to two
closed okay how to use it while that's
just take the call as it was before and
wrap it with this with circuit breaker
indication that's what we see in the
method down there unfortunately this is
not not collecting metrics as the
historic stuff does so if you want
information about like like counting
failures and report these status of your
circuit breakers you would have to do it
manually here and packaging I'm just
noticing it because it's a different
build system than you what we're used to
in the Java world arm but SBT that's a
build system behind play provides
plug-ins for building debian package RPM
packages or just a distribution zip
through some some start scripts to start
application get you done ok so let's do
play round up so it has a very concise
syntax for doing all these a synchronous
stuff and for recovery and you have a
natural way of introducing a curse
circuit breaker here it has easy
packaging but we haven't seen any
support for metrics here and also we
haven't seen any support for service
discovery so you would pull another
stuff the question saria
so the question is of the circuit
breakers supported in the Java version
of play I haven't used flame of Java
recently but usually they try to make
both the API also available for java so
i would think they have ok another
question
question 5 database back-end you're
going to do all this effort to separate
them on smaller services the backend
database you guys do equal up or it's a
two
cables that youth service what address
yeah so the question is if we go to this
effort and separating everything in
micro service wats about databases and
be like do your learning between tables
from different services and so and the
author's the answers even further we
expect each service to have his own
persistence so at least a theological
layer we expect to be no to have no
coupling between the different databases
so each service chooses not only the
database but its database technology on
its own and if you then later in
production still use like the same
database installation but you would at
least have different schemas for example
okay it's time for for yeah finding an
aunt so we conclusion okay the main
takeaway I think from from our look into
the frame works is that micro services
aren't really micro except you look at
to the the business domain that they
actually tackle right because actually
microservices still are separate systems
which have like the whole vertical layer
like the UI logic eventually persistent
whatever so microservices in our point
of view are only micro regarding the
business scope yeah so actually to build
a micro service you meet even more than
you need to build a monolithic system
and that's because microservice means to
take a deep dive into distributed
systems so all the problems we know from
distributed systems now suddenly appear
for even the smallest application we can
build that means we have to prepare our
not are not only our knowledge but also
our frameworks for this and we've kept
feeling that the the web frameworks
we've chosen here don't have all that
support yet there's some some
interesting stuff interesting stuff but
basically you have to pick your own
things and yeah at them to do the stack
you already have fears there's a lot of
manual work to be done if you if you
really want to take on micro services
and distributed systems in this way
and none of the systems none of the
frameworks actually supports everything
that is that is the main conclusion
actually that yeah not only there is
there is no silver bullet but you really
have to have to look into if you build a
micro sister microservice then you
really have to look into what are my
business use cases what technology do I
really need to to support the the
different use cases and how can i
connect the systems with each other like
loose coupling not depending on the
database just depending on data formats
and exchanging them via via network
holds for example okay although any
questions look yes
you mentioned using asian-pacific all
the question is we mentioned the Acer
and currents call between the systems
and whether we use an asynchronous call
to place the order no we don't because
this is not the system interacting with
each other but you will receive the the
shopping cart view that we showed and
this is an HTML form and when you press
the order button this is actually the
post request that goes to the artist
service so you receive the HTML from the
card service and the post will actually
go to the order service the this is this
is a UI interaction not between the
systems themselves so this is a
synchronous call from the browser to the
artist system well there there is a way
to do to help this also but that's a
different different topic well we are
running out of time here so if they're
further questions I'd like you to just
come to us so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>