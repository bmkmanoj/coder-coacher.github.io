<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Let’s Get Physical: I/O Programming with Java on the Raspberry Pi with Pi4J | Coder Coacher - Coaching Coders</title><meta content="Let’s Get Physical: I/O Programming with Java on the Raspberry Pi with Pi4J - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Let’s Get Physical: I/O Programming with Java on the Raspberry Pi with Pi4J</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/grItDpy3TRM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">what you see today is real we're going
to compiled code delivered or oak and
SSH it directly over to the Raspberry Pi
in real time run that code and pray to
God that it all works so as in most
presentations you see here here's my
disclaimer use it your own risk and your
mileage may vary it's an open-source
project if you go off and build the you
know a killer race of robots it's really
not my fault if you use PI for J to do
that and then the last disclaimer
anything that I tell you today is my own
personal opinions it's not that of the
company I work for AMX Oracle or any
other company so today we are going to
do a brief overview of Raspberry Pi most
of you probably already know what that
is so I won't spend too much time there
just kind of an overview of what the PI
4j projects all about we're going to do
some getting started examples so just
some basic building block examples that
will help us build up to putting it all
together demo which you see here in
front of me on the podium this is an
access control system so we're going to
learn the little bits along the way that
helped us build up this complete system
in the end we'll talk about the
components libraries that PI 4j has to
offer its expansion capability beyond
the PI hardware itself again putting it
all together in this final demo and then
a little bit of Road mapping just so you
guys know where we're headed and then QA
who in the group actually owns a
Raspberry Pi at home wow that's
fantastic who has run Java software on
their Raspberry Pi excellent so I may be
preaching to the choir a little bit but
the Raspberry Pi I got engaged with the
project with the PI's as soon as the
kind of marketing information was out
about it before it was ever available I
was one of the early people that signed
up to get it because I saw this device
as a very empowering device for
automation I work in the automation
industry for about 15 years now and
never before has such a powerful little
device that gives us the ability for DIY
automate automation based projects so
very exciting and the low cost and
how really make that accessible the low
blow cost makes that accessible to
everybody
whereas in commercial world if you want
to buy an embedded prototype device
you're going to spend several hundreds
of dollars and thousands of dollars just
to get even if they'll let you buy it so
it's a pretty powerful little device and
I think it's going to open a whole new
world of opportunity did this device and
devices like it I think this is just the
first in many that we're going to see
this is just a reference slide if you
guys haven't run java on your Raspberry
Pi I have a blog site that you can
access that has the instructions for how
to install the java both seven and eight
on your Raspberry Pi I personally prefer
the Oracle hot the the hotspot JVM for
the for the arm because it runs so much
faster than the open JDK I crossed out
soft float because here recently
Oracle produced a Java seven hard float
distribution for the Raspberry Pi so now
that the now that the soft floats out of
our way we can just focus on hard
floating the advantages in speed and
performance we get out of that ok so pi
for J PI for J is an open source project
that I'd started mmm I don't even know
how long ago probably well over a year
ago but it's pretty soon after the
Raspberry Pi came became available to us
I started this project because I wanted
Java programmers to have a an API and an
implementation with a lot that would
allow them to access the low-level
interfaces of the Raspberry Pi the
low-level input/output interfaces in
particular the 26 pin header which we'll
look at here in a minute where I think
all the magic can can happen when terms
of automation I wanted an
object-oriented API there were other
Java libraries prior to PI 4j and they
did a fantastic job but they were styled
more like the Arduino type of api's they
were or see like in a nature where you
had this library of functions that you
communicated with and you could execute
those functions and pass in all the
different parameters you wanted to
execute against the PI I wanted
something that's more object-oriented so
in like the PI forge a world you
instantiate or provision a pen which
gives you a GPIO pin object and then you
can work with that object probably more
importantly
really wanted an event-based API when
when I produce this project at the very
beginning there was no capability at
that time to provide events back up into
the Java layer to do that you have to
dig way down and do that processing in
native code so I wanted Java programmers
not have to concern themselves with the
low-level Java the low-level J&amp;amp;I and
native C programming I wanted them to be
able to have a library that they could
register add listeners for GPIO events
and then receive those events and work
with them prior to an event based API
you had to pull for state so if you
wanted to know if a button was push you
had to be in some tight running constant
polling state the Raspberry Pi of course
is an embedded system so the process the
capability somewhat limited so you know
running constant polling would work for
a fine simple demo but if you're really
building something that is starting to
push the limits of it you've got a
little web server or something on there
you really don't wanna be wasting cycles
just doing you know state loop
monitoring so we we produced an event
based API
at this moment in time the PI for a
project is limited raspberry pi platform
but we'll talk a little more about that
in the roadmap and then again just
providing the J&amp;amp;I and native code for
you guys so you didn't have to turn you
have to work get into that unfortunately
I did and had to learn a lot but it was
good it's good so we primarily the PI
for J project is perfect trying to
provide access to the GPIO the 26 pin
header so if when you see this diagram
it's the 26 pin header on the Raspberry
Pi which is what this ribbon cable is
plugged into that's where your GPIO pins
your UART which gives you serial
communication capability SPI and I
squared C those are really lower level
communication buses if you're
communicating between other chips you
would typically use SPI or R squared C
and then the Raspberry Pi does have a
single pulse width modulation pin so the
PI 4j project was focuses on that those
levels of communication and provides all
of that to you as a Java programmer
so we're going to start jumping into
demos and you know just want to give you
guys a brief overview of what the
project's about and what we're at what
we attempted to accomplish but now
really the focus of this meeting for me
is to get you guys hands in code and
working with not only not only pi for J
but you know working on the Raspberry Pi
create your own embedded projects so our
in our first example this is essentially
the hello world of the of an embedded
project we're going to create a simple
button and an LED to illuminate when we
press the button we want the LED to
light up when we release the button will
deactivate the LED this is what the
wiring diagram will looks like for this
project and just a side note all of the
slides and I'm going to on my blog site
I'm going to go into more detailed
in-depth blog articles to provide these
to you guys you can always follow it
after afterwards and get and get access
to this information but this is the
wiring diagram so we've got our simple
button connected to GPIO 6 down here and
we've got our LED connected up to GPO 7
are you guys familiar with GPIO and and
the Raspberry Pi puts out 3.3 volts on
the GPIO pins so to power our LED we
need to reduce the power a little bit
otherwise we burn out
all right simple red 2 volt at 1.5 2
volt LED so we have a 2200 wente ohm
resistor just to reduce the power to it
I should probably talk just for a second
about pull-up and pulldown resistance
for those of you are not familiar with
GPIO so gpo is digital on and off right
computing world bit binary on/off the
GPIO senses you can you can make a GPIO
pin an input or an output pin as an
input pin you're sending it either a
high state or a low state high state is
represented by positive voltage and in
the case of the Raspberry Pi it's
positive 3.3 volts low state is
represented by 0 voltage however if you
don't apply a bias to that pin it can
float which means it can float anywhere
between zero and positive voltage which
gives you erratic GPO input
so you really need to provide pull-up or
pulldown resistance depending on the
circuit you're designing and really all
that's doing is giving it a bias so in
the case of our switch here it's our
switches is configured as an input GPIO
pin and we're through software you don't
you can do this in a hardware circuit
but through software we're able to
configure the GPIO pin to be a to
provide pull-up resistance so by default
this pin is going to have a positive
bias voltage to it so it's going to be
in the high state so at rest with no and
you know no circuit it's it's at a
positive voltage when we press the
button to complete the circuit we're
sending the ground lead to it so now
that it stabilizes that and reduces it
to Z you know reduces it to zero voltage
because we've grounded the circuit so
that when we push the button
our GPIO pin State is going to go low
and that's important for our later
conversation when we get to components
but I just wanted to understand that
there is a depending on your circuit
design you can either Pat you know you
can either be sending it ground to put
it into a low state or you can give it a
bias of a low state and send it positive
voltage from the from the 3.3 volts this
pin here and then it would go high as
you press the button okay this is just a
simple logic diagram in terms of what
we're trying to accomplish here so in
our software we're going to provision
our GPIO pins and it kind of breaks it
out into what's the word users program
responsibility and then what PI for J is
what's its responsibility is so we write
we provision GPIO pins which is
effectively using kind of a factory
pattern to get yourself a pin instance
and at the same time configuring certain
information about that pin we register
the GPIO pin event listener so we can
know about updates so for the in the
case of our button we're going to
register a GPIO pin event listener and
then we're going to leave the main
program at rest and we're going to then
on callbacks on receipt of the listener
of the pin event handler we're going to
take some action against the led so
we're going to change the GPIO state
that the LEDs connected to to turn it on
and off
this is a kind of a snippet of what the
pseudocode looks like can you guys see
that okay so we create a GPO controller
which all these interfaces are PI 4j
interfaces we create from our GPO factor
we get a controller now that we have
this controller we can provision
different pins we're provisioning a
digital input pin and a digital output
output pin one for the button one for
the LED then we register R for the
button we register a GPIO pin listener
get get the state back and then take
action on the led pin pretty simple
stuff and a prime candidate for a
lambdas as we move forward in Java aid
so I know you didn't come here to see
pictures and stuff so let's let's dig
into code so we are going to this is
what basically what you just looked at
in terms of the code is a little bit
more you know the boilerplate around it
we're going to switch the little bit
smaller so you guys can see the code
better so you can see this is a little
more fluff because I'm printing out
information to the console but basically
the input and output pan the LED I'm
setting some shutdown options which
means when the program completes what
state do I want to leave the GPIO in and
then our button listener so we're going
to have a pin listener just so I can
echo the output state of the LED so you
can see that on screen so we're going to
compile this program and send it to our
Raspberry Pi
and then while it's doing that we should
see it come up here in a second okay
stop the previous program should be
loading the new code ends and starting
the new program okay so here's our first
GPIO example again extremely basic we
push the button we listen for that event
in our java code and then we control the
state of the LED pin so I'm going to do
that here our momentary button is this
exit button switch to when I press this
then it completes the circuit and then
the LED is going to be right here
on the small circuit board so when I
press the button you see the button has
gone to the low state and then the LED
has turned on and if I release the
button the opposite pretty basic right
and of course as many times as I press
that hold you know we get state updates
whoops little turn a little too
aggressive there I'm excited about this
okay so I wanted to start with simple
examples like that to show you how
really it easy it is to control things
sure it's an LED which is not all that
impressive but that could be something
else that you're controlling for example
I did my Christmas lights last year you
know I had a Java program that would
read that would go out and figure out
sunrise and sunset times based on my
location and then turn on and off you
know electrical circuit for a hundred
ten volts to turn off you know my
lighting so you can imagine you do other
things with this but this is the basis
of where you start okay we're going to
do we're going to continue to iterate on
that particular example and then show
you different variations of it so in
this case we're using something called
triggers so the PI for J project also
provides triggers which basically mean
less code for you if you just need to
simply effect the pen state of a
different GPIO pin on the on the state
change of your of the but like that in
our case the button pin we want to
affect the state of the LED pin you can
use a trigger for that there are several
pre-programmed triggers that are
available to you or you could build your
own so in this case we're going to
change the goal just slightly we're
going to toggle the state
so by pressing the button we're going to
change the state and leave the state
sticky and then another press would turn
it off
same exact circuit design no change in
circuit as you can see here the
responsibilities have moved less from
the user program more into what PI 4j is
doing for you so we simply register we
wouldn't provision our pins as we would
have before and we register a trigger
and then we're done
and here's what the code for that looks
like so a little bit you know more
compact here you know in this case we're
registering we're adding a trigger a
GPIO toggle state trigger and we're
saying when the pin goes low we want you
to toggle the state of the LED pin so
this is the button pin adding trigger
when when the pen state goes low on the
pin the button pin we're going to affect
the LED pin so we have that here and
here in the comments you can see there's
a number of other there are several
others beyond this but there's a few
different examples of we could do blinks
sync state inverse sync pulses there's
different things you can do with
triggers but essentially it's just less
code there's a little bit more here in
my example just because I'm printing out
information to the console but we'll go
ahead and compile and run this program
wait for it to start
okay so now our GPO program has started
using triggers so now pressing this
button and releasing
I also registered a callback trigger
which I failed to show you so that's
where the button call back fired text is
coming from but we received the the
trigger did the work so we didn't have
any code that's turning the LED pen on
and off in this example the the trigger
is doing that for us so we press the
button and it changes the state of the
LED pretty basic stuff but I wanted to
show you that you guys are that as an
example that we're building on the same
principles but there's variations in
ways you can do it if you don't unless
you have some complex goal you can use
these triggers to do simple goals yes
sir it's to reduce the code you have to
write if you need to accomplish simple
things without creating your own
listener and writing your own state
logic that controls the state of the
other pen it's just a convenience
mechanism but essentially it's doing the
same thing under the covers with java
code so it's not taking it down to a
lower level admit the native layer
okay that was still a time okay next
we're going to do rs-232 control if it
is any one program serial before few of
you guys rs-232 if you want to
communicate beyond the PI and you want
to do something beyond just simple ons
and offs there's a lot of periphery
devices out there in the world that have
serial control for example I was working
with my security system over the past
month and there's this little serial
module I can buy for it and I've
connected that to it and then
communicated from a PI via serial to my
alarm system so my PI is not my alarm
system the alarm system is a dedicated
environment unto itself but now that I
can talk to it serially there's more
there's more interesting and unique
things I can do with it through my java
programming via the PI communicating
serial to the alarm system in this case
I brought a an LED display system and
we're going to try to do a hello world
to to communicate with rs-232 so that
the the Jeep the Raspberry Pi has a UART
built-in so we can do serial
communication but you really need a
level shifter to communicate with a real
rs-232 device the reason for that is
because rs-232 has a higher voltage than
what the PI does a real rs-232 I think
is somewhere between five and twenty two
or twenty volts or something like that
so obviously we if we some even if we
received a communication back and we
were driving voltage higher than 3.3
volts you could damage your PI so the
level shifter you can buy these on eBay
or at a fruit or sparkfun anywhere you
know hobbyist electronics you do need a
level shifter to communicate our rs-232
so we simply connect power ground
transmit and receive to our level
shifter and then we have a serial cable
coming out of our out of our PI over to
our display device so program logic
we're going to basically the same thing
we're going to provision a serial port
open the serial port register a listener
so we can see echo feedback and we're
going to send our hello world message
and here's what that looks like in code
so we have a serial factory we create
ourselves an instance we open the
particular comport that we're interested
in passing the baud rate and then we
register set ourselves a listener and
then once we're done with that we go
ahead and send the the the device a few
commands if you notice I have a sleep
command in here that's just because this
device is fairly slow and if I if I send
them back-to-back it would overrun its
own buffer or wouldn't be able to
process it fast enough I tried so a
little bit of a sleep type just to give
it a brief moment to up keep up okay so
we'll run that demo now
soken here's what the code looks like
cereal factory open serial port add
listener and print out our hello world
oops wrong way
you guys have questions oh that's
IntelliJ I recently switched I'm kind of
liking it there's a nice clean maven
integration with it someone from eclipse
okay so not a lot of feedback on this on
the console here but you can see that
the LED message board has updated and
it's got a hello world and we received
the ideal ones or the responses back
from the device so every time we sent it
to command that was its acknowledgment
so we could in our program we could
verify that the successful command was
sent by monitoring the response there
yes I'll show you the code for that
right there adlet we saw our serial
object we've added a listener serial
data listener and then there's the event
for it yeah
now with serial you have to I don't to
get too far off topic but with serial
depending on the amount of data that's
coming in where that event breaks up the
data you may have to in your code
recognize that you may not receive
everything in the packet that you're
expecting in one event because if it's a
series of data that's fairly lengthy to
pay on when we receive the data in it
could be chunked so you may have to
buffer up the data in your own event
wherever your event logic is and parse
the data as it comes in and make sure
you've got the correct package that
makes sense it's actually one of the
things I'd like to add is some kind of
ability to specify their specific bytes
or kind of a packet identifier to kind
of only deliver events when you receive
a some kind of packet identifier but not
there yet okay
so next we're gonna talk about the
component API so we've been talking
about GPIO LED pen momentary switch pen
that's all great we were able to
accomplish everything we wanted to do
but what we're working on now is a
component based API so I really want to
think of that button as a component I
want to think of it as a button I don't
want to necessarily think of it as a
GPIO pin in my throughout my program
where all my business logic is so
component API is an abstraction layer
around the kind of physical devices so
the one example I included here was a
relay device if I've got a relay I have
to if I'm going to interact with that
relay with the straight-up GPIO code I
have to understand the circuit I have to
know whether I've got to drive that pin
high or drive it that pin low to cause
the the the relay to latch so throughout
my program I have to understand the
implementation the circuit designed to
be to successfully use that so as a Java
programmer I really don't want to
concern myself with the hardware I want
to stick to my world of software so we
have a component API that allows you to
to to achieve some of that abstraction
so if you use a relay component you're
able to instantiate that relay component
sure you still have to set up the logic
of what the GPIO pin is but then
throughout the rest of your program you
can just treat it like a relay you can
tell the relay to pulse you can listen
for relay changes and you don't have to
concern yourselves whether that's a
higher low GPIO Penn State or even
further what if that's a relay that's
not connected to a GPIO what if it's on
an I squared C bus you know GPIO
expander chip or what if it's on a
different board that you control the
rs-232 your program would really not
doesn't need to care about the logic of
how the communication layer works to
drive that relay you just care about the
relay so it's just an abstraction layer
so you can concern yourself with the
business logic of your code around the
components and not necessarily have to
proliferate the communication layer
throughout your code we have the
following components that are in the
code at the moment I think there's a
couple of additional components that we
have beyond this I think there's a
gyroscope that just got added and a
servo
so we're continually expanding the
component API and when we add a piece of
V API we also try to add an
implementation so you'll find a lot of
these are backed by different
implementation coaches well a lot of
them GPIO implementation so for example
the relay there's a GPO re Lake object
that you can instantiate so it's driven
by GPO but it really delivers you the
relay interface so exact same circuit
design nothing nothing's changed we're
going to go back to our you know button
LED example so our our workflow is we're
going to provision our LED we're going
to provision our momentary switch and
we're going to register except I'm sorry
this time instead of just the pin we're
actually
provisioning a component so we get back
a component interface and then we can
register events off that component
interface and then deal with the when we
receive those components with those
component event handlers we can take
whatever action we'd like so here's kind
of an example for that this is very
similar to the first example can you
guys see that okay okay so we provision
our GPIO controller and this time we
have a momentary switch that we're
instantiating so we instantiate a new
GPM omen tarry switch component and then
we still pass it a GPIO pin because it
still has to be backed by some
electrical communications so we we send
it in the pin that we want to be to
participate as part of that component or
drive that components logic the same
thing for the LED and then we add
ourselves a switch listener not a pen
listener okay so we'll take a look at
this
so the code here is pretty much the same
a little more boilerplate stuff but the
meat of the code here is in the
eventlistener run this code and I'm sure
it's no shock to you the outcomes going
to be the same it's just I push the
button the light comes on but it's just
walking you through these different
concepts to help you show you what the
library is capable of doing and then why
you might want to use some of these
abstractions so our component example
started so if I press the button I
should get a momentary switch pressed
and released pressed released in the
light of course follows the state does
that kind of make sense do you guys
understand is there any questions on the
component stuff okay pi for J expansion
so we certainly recognize that there's a
lot of additional capability I mean the
PI provides us a lot but there's
projects that you may want to work on
that need more capacity than what the PI
has to offer maybe you need 20 GPIO pins
well the PI is not going to provide you
that on board in addition the PI only
has a single pulse width modulation pen
and it's somewhat limited so if you need
that kind of capability you really have
to look at some external periphery
devices as well as analog so the PI
doesn't provide any form of analog pins
so there's no way to do that unless you
use an external chip so that the PI 4j
library does support a number of
different expansion capabilities where
you can use things like the PI face I
love you guys have seen that up there
the other example at the bottom is a ole
MX AVR or i/o
board where it's serial controlled
relays and inputs so when you need to go
beyond the puppet of the PI hardware
itself to have additional periphery for
input and output we're trying to add
more and more support for this i/o
extension library
okay I didn't we don't have a specific
example of that go and keep it kind of
simple and moving forward but so now we
want to put it all together so now we've
seen the different GPOs and cereal and
things that we can do let's bring that
all together to something more like a
real-world example so in this case and
the board you see in front of me we've
got an rfid access keypad so I want to
be able to enter a room if I've got an
RFID tag with me that you know that
provides me access to that room secured
access to that room or maybe I just have
a keypad number I can type in to access
the room inside the room you might need
an exit switch to get out if it's a if
it's a fixed solenoids magnetic door you
need an exit switch to get out perhaps I
need a doorbell there's visitors that
might come up that need some form of a
way to notify me that somebody's waiting
to get in
I also want to track the state of the
door I mean it's somebody Jimmy the door
and force their way in that's a kind of
security state that I want to monitor so
I want to understand the state of the
door in case there's a state where it
opens and it's not an approved access
additionally I have a keypad tamper so
somebody's tried to take the keypad off
the wall there's a tamper switch in
there that will notify me that there's a
security event that's happened in this
demo we're going to use an
electromechanical lock there's a
magnetic solenoid here that we're going
to unlock our door with in commercial
settings that there are solenoids Riven
much larger sophisticated locks or
there's magnetic locks that can keep a
door sealed but for this simple example
we'll show you the the solenoid here I
want to be notified of security events I
mean if someone does force their way in
or tamper with the keypad I want to know
about it I want to sound some alarm in
the room I want to notify personnel
security personnel via a you know the
alerts email SMS things like that and I
want to access I want to access in
security log so I want to know when the
system was accessed over time and I want
to know if there was a security event I
want to track all of that stuff
and finally it'd be nice to have some
remote access maybe I've got an app on
my phone that gives me access so we're
not
dig down into the guts of this but
here's the circuit design of what this
particular example is it's really not
that difficult but so if you follow all
the traces you can see where we things
are connected at a high level we are we
just have our exit switch that's a GPIO
the tamper switch is a GPIO we have our
rs-232 communicating over to our message
board we're going to use that in this
example we've got an external reach set
of relays there's two relays that we're
going to control via GPIO to actuate the
solenoid and to when we use our
overwrite switch we use a relay to
actuate a signal back to the keypad to
allow us to enter the room and finally
our solenoids connected as well the you
can't connect things like relays and
solenoids directly to the PI that would
cause problems probably burn up your
system also most of those kind of
devices like the in this case the relays
are driven by five volts the solenoids
driven by 12 volts so you have to have
some external means of using your GPIO
with transistors or like boards like
this one that I purchased that have that
capability where you can drive it with
very low level input but you can't drive
it you can't drive those kind of
components directly from the PI there's
not enough power and not enough voltage
so I didn't bother putting the the code
here in the slide just because there's
way too much of it but we'll we'll take
a peek at it here
okay
so we provision our momentary switch for
our doorbell for our override switch our
tamper switch we provision a door sensor
so we have a sensor component that we
provision the door sensor so we can know
when the state of the door changes and
for that we have a magnetic sensor
attached with a keypad unlock sensor so
this keypad when it approves an access
token or an access code it will it will
send us a pulse on one of the GPIO pins
to let us know that it can't it's okay
to unlock it's a it's asking permission
to unlock the keypad opener relay this
is a request that we're sending back to
the keypad through it through a pulse a
GPIO pulse to tell it that we would it's
basically the exit switch telling it I
want to open a security LED we just
illuminate we flash an LED if there's a
security violation and there's some
messages that we send to the sign and
finally we'll scroll down to some of the
event listeners in the code so we can
see here I'm also actually hosting a
jetty webserver so I can access pages I
can show you guys the remote access
capability so that's really I should
have mentioned that earlier but one of
the things that stands out about
something like the Raspberry Pi I could
do everything that we've seen today and
in fact everything you've seen on this
board up here directly through an
Arduino so why would I use a PI I think
the PI really stands out in providing
you this higher level programming
capability but then also access external
access it this thing can be connected to
the Internet it's got the ability to
have a Wi-Fi USB Wi-Fi adapter plugged
in so it can connect directly to your
network I'm hardwired here so I've got
hardwired into a network so that's a lot
more difficult to do and in our doing
you window kind of project I mean
there's use cases for each and there's
places you should use more of a
real-time up you know system like the
Arduino but where you want connectivity
I think that a platform like the PI
really really stands out and the fact
that I can run standard you know web
servers FTP servers media servers and
things that I want to do like that
directly on the PI so I'm
have we have a little WebSocket server
that we're running with jetty we're
using the embedded version of jetty here
and the rest of this is pretty much just
the different logic so all of the
listeners and then adding the logic to
the program so I'll probably bore you if
I go through all of this so let me
switch over to let me run this code
okay still start the web server just
started up systems ready we're good to
go so we've got our Raspberry Pi here
our relays that control the solenoid and
then feedback back to the keypad or exit
switch the door which is currently
locked the magnetic sensors - no the
doors door state so we're going to
request an unlock so I've got a little
RFID tag here I place it there we go
place it close to it it opens and
unlocks the door I'm able to open it I'm
able to know the state it was a little
slow there for saying that's not a
real-time operating system so again
we're able to track all of these things
I can know when the door gets shut I can
use the interior exit button to exit the
system from like the inside or or if
somebody had use the doorbell I can open
the door for them and approve it and if
you notice also the LED message board it
gets updated whenever I'm changing
states here just for feedback I can type
in a keypad code to request access and
it again opens approves us access so
those are all the happy conditions
that's all the happy state so if I were
to attempt to break into the system by
forcing my way through the door it
should detect that there's a security
violation it's telling us over here that
there's a problem you can see my Dropbox
is getting updated with security log
information so it's a very unhappy
system at the moment and I implemented
some reset logic directly into the
switch so if I press the switch it'll
reset the security state so that's kind
of an all all-in-one demo and let me
show you some of the other the things
that we're doing my phone keeps going
off because I've got several are you
guys familiar with if/then that I've got
several recipes connected so basically
the PI is sending out emails to a to an
if/then then that web server it's
listening for emails from my account and
as you can see I'm sending it to
pushover
familiar with pushover it's an app for
the phone that you can push
notifications to I'm sending I'm
creating tweets so if if all worked
correctly I should have some tweets here
come on there we go so you can see here
a security violation has been detected
door breach and in the second one when
we reset the system so so we let Twitter
now that someone broke into our house if
you're familiar with boxcar boxcar is a
similar service to push to push over you
can see that I've got notifications here
waiting in boxcar and those boxcar and
push over notifications are also being
delivered to my phone as well as SMS I'm
updating Evernote with my log
information
I'm also updating Dropbox with my log
information I'm a little excessive and
paranoid here but I just wanted to show
you guys what all the connectivity
options you get especially when you know
all we're doing from this system is
sending out a simple email but with
services like if then then that you can
get creative where you want these
notifications to go and how you want
them to interact so there's boxcar SMS
and the other ones are from my lighting
at home but uh but you can kind of see
that example so let's let's just check
our logs and make sure we've got a an
access log make this a little smaller so
you guys can see it new they won't let
me resize it okay so if we scroll to the
bottom here you can see that I don't
know what time zone that's reporting
from but we basically have our latest
security notifications are here at the
bottom and I can use the access log I
can see where access has been granted
and denied over time you see a lot of
examples you're going to been testing
all week trying to make sure everything
would work for you guys today but so
those are my access and security logs
may be able to see it a little bit
better here from from Dropbox since I'm
doing the same thing with Dropbox so
here's all the access granted
and
come on Dropbox doesn't wanting to
respond so we'll ignore him are you
probably just a little slow but anyway
this is there's a security log there on
Dropbox as well so that's great I mean
that's that's a really powerful
capability to send these notifications
out and proliferate it throughout your
life throughout the different services
and things that you use but the other
thing I mentioned is external input I
want to have an app or webpage that can
let me have access to the to the PI so
let me show you guys that back to the
beginning
so this is just a little opera mobile
web client so you can kind of see what
it would look like on a mobile device
and if all goes well I'll pull it up
here on my phone too so I've got the
same the same UI here on my iPhone this
is just a web hosted pages so when I
click the Open button
I get an approval and of course I get
the door to unlock so this is this is
just a simple jquery mobile app using
WebSockets to communicate back to the
Raspberry Pi and if I use it from the
web page you see on the screen it
basically does the same thing so really
a basic example but I really wanted to
kind of you know show you the pack a
police imple coding I mean I put the the
web sockets and web capability together
in one day or less than a day after work
so it's it's immensely powerful for such
a small and cheap device and there's an
innumerable amount of projects that you
could go out and create with something
like this so I hope that you guys have
learned something through this so let me
go ahead move on to the roadmap and the
wall we'll do some Q&amp;amp;A so we haven't
reached 100 status yet that doesn't mean
that's not solid enough to use for the
basic GPIO but there's some things that
we want to clean up before we claim 1.0
so we're trying to target that for the
end of the year but we may slip into
first quarter there is a 1.0 snapshot
that's available now and you can
certainly use that in your projects or
there's a earlier 0:05 version release
that you can use beyond that we want to
continue to add additional component
interfaces and device interfaces we want
to abstract ourselves away from the from
this platform I mentioned this is the
first one to come but there's a lot of
other interesting cheap and expensive
devices that are coming out some with
more capabilities that we'd like to be
able to work with in the future so we
need to create ourselves a clean
platform abstraction layer so we can
work on other platforms like the Beagle
board and other systems like that our
testing is not as good as I'd like it to
be because we're we have to run
everything directly on the PI until we
put that platform extraction layer in we
when we put that platform extraction
layer and we'd like to build a better
testing harness for it a little bit of
refactoring and cleanup to do additional
communication channels we'd like to
support and then finally we've been at
you know we've been asked a number of
times to provide a web service or a
service or daemon that you could run
that provides GPIO and access externally
so it's kind of the high-level roadmap
so do you guys have any any questions
I'm sorry the current the current test
system I'm ashamed to admit is very low
is the person sitting between the chair
in the keyboard so there that's actually
a few J unit test cases but it's not
what is not proliferated throughout the
entire code base so that's something
where we have to work on yes sir
yes the question was there's a well
sorry
so that we would stomach noted that
Sophia or
so soft pwm so the question was the the
PI only supports a single hardware pwm
pin pulse with modulation so there is
software capability where you can
emulate PWM we the library has direct
wrappers for wiring pipe are you
familiar with wiring PI project the CG
project for the native so we wrap a lot
of their stuff and we wrap their soft
pwm call is that the one you're talking
about you used or I don't know there's a
way to improve that because I mean we're
at the moment where we're controlling it
and they're they're executing that
through the under their native code
right so unless they have improvements
for that we certainly wouldn't want to
try to emulate soft PW in a java layers
not fast enough
yeah absolutely there are in fact I
don't remember the chip name but there's
a if you come out and look in the
development branch of the github
repository and we go and flip to that
oops if you if you check out the the
development branch that you should see
in the expansion area there should be a
a chip that has PWM expansion so there's
a you can connect a different chip and
it communicates that on with I squared C
or SPI we communicate to that chip and
it has a number of pins that can do real
better PWM capability so you'd have to
use an external chip to do that but we
do have support for at least one of them
well be one of the chips I mean there's
lots of different chip manufacturers out
there that's what I meant so yeah you
can you can still program it through
Java through the PI 4j interfaces if you
find a chip that you like that we don't
have let us know maybe you know if it's
something we can get ahold of we can add
that support or you're welcome to add
that support and you know fork the code
and then do a pull request we can bring
it in but you have to get better PWM
support you're probably looking at
connecting an external chip to bring you
that capability soft PWM I wouldn't rely
on for anything mission-critical
yes sir
do you mean in terms of providing a
library well when we started out in this
space there certainly were a couple of
other Java interfaces I don't think
they've been carried forward I haven't
checked their repositories lately but
they kind of seem to have established a
certain amount of functionality that
they were happy with and then and then
they just stabilized there and have it
moved forward our vision was a little
bit more grandiose I guess in the
component layer and and things like that
I mean if all I wanted to focus on or
what we wanted to focus on was just the
GPIO just the cereal we could be done
right but that's we want to bring you
know the embedded capabilities and
programming to the Java programmers in a
much easier way to consume so we don't
feel that we're done you know I haven't
actually charted it you can go out on
google downloads or if you look at the
PI 4j website you'll see where the
downloads link is and you can see you
can look historically and see the
different versions that have been
released we release in a thing - it may
be a zip of the jars or something like
that but we also release in a Debian
installation package so you can just do
you double you get that dub file and
install it directly on your on your PI
yes sir you mentioned several times that
for a lot of control you have to use
transistors or whatnot yeah are there
like any recommended kids or pre-civil
kids
or stuff that you I just wanted to get
one to just get started and play with I
think the pie face is a good place to
get started if you want to come back up
after a show I've got one of my bag here
I can show you it plugs directly on top
of the 26 pin where this where there's
ribbon cables plugged in so you don't
have to concern yourselves you know
concern yourself with wiring and
crossing and shorting pins it plugs
directly on top and it gives you two
relays and I think it's got four buttons
and a series of LEDs or input outputs
then it's got screw terminals where you
could connect an external sensor like a
button or a-- or a magnetic sensor or
something like that so that's those are
the other to answer your question
there's a number of different types of
kits that you can buy but the pie-face
is a good one because it's very simple
to get started with and there's no
wiring per se to have it connected and
it's a good one it also protects a lot
of those external modules also give you
additional protection so if you were to
drive five volts to a GPIO pin on here
you'd probably burn up the GPIO pin
those devices are more protected so
they're they're safer for hobbyists and
people experimenting learning and
believe me I've burned up one or two
PI's I burned up one in this project so
you know I'm not a hardware expert but
I'm learning and learning sometimes cost
a little bit of money when you burn up
your PI's I think I sent back voltage
across the five volt pen see is you
knows I'm not actually powering the
Raspberry Pi with a USB probably can't
tell because there's so many things
connected but typically you plug in a
micro USB connector here to power the PI
I'm back powering it through it's five
pin port from this module here but if
you're not careful you'll burn up your
PI yes sir
I haven't seen contribution from a
company like that at this time it's
individual contributors and then there's
a number of commits there's a small
number of committers on the project that
are that are working on it but we have
received a lot of contribution
externally for this especially when
we're talking about the the add-on chips
like I want to support this particular
vendors I want to support microchips
version of this ADC analog to digital
converter then yeah a lot of those have
been contributed but I haven't seen
contribution from a formalized company
any other questions well I really want
to thank you guys for coming I hope that
this was helpful I know some of them
have been a little slow just in terms of
you know simple examples but that's kind
of where I'm focusing on my blog and
focusing on to get people interested the
Raspberry Pi itself obviously was put
out by the by the cameras group in the
UK by the Raspberry Pi foundation as an
educational platform so I and I'm
embracing that philosophy as well and
want to keep it simple for people to get
started but I wanted to get started with
Java on the Raspberry Pi so that's that
my particular bent is is towards the
Java side and I wanted to make a library
that was easy for people to get on board
and control it Java has it does have a
following on the Raspberry Pi but it's
not as strong as the Python group and
things like that if you look on the
forums you can see the number of posts
for different languages so we need to
everyone we need to ramp up that number
and get good job as a more predominant
platform on the system and I think the
Oracles new releases will really help
that
yeah they're their latest JVMs now they
have hard float support with JVM 7 they
also have the JVM or you know the early
release of 8 they've had that one for a
little bit longer but now that they've
got a version 7 release you know people
but I don't want to call themselves
early adopters or more capable can use
that and not have to install an old
version of a Debian or something on the
system it's offload well thank you guys
you keep here interested come check it
out</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>