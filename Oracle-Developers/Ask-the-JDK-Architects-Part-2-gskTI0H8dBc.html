<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ask the JDK Architects, Part 2 | Coder Coacher - Coaching Coders</title><meta content="Ask the JDK Architects, Part 2 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ask the JDK Architects, Part 2</b></h2><h5 class="post__date">2015-06-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gskTI0H8dBc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and welcome or welcome back this
is the ass the architects as the jdk
architects Q&amp;amp;A session how many of you
were here for part one oh all right you
don't get to ask any questions just
kidding preference will be given to
people who weren't here for part one
although they at least going billing by
Twitter there were lots of questions
from part one that we still haven't
answered and no doubt will not have time
to answer tonight okay so that's slide
number one here's slide number two you
can ask questions live by walking up to
the microphone which extends some way
into the audience and I will walk
towards you when when when appropriate
or you can ask questions via twitter
twitter to tweet with that hashtag and
i'll see it on my phone others will see
it and and we'll sort sort of choose at
random sometimes looking for clusters of
related questions as we go so with
someone like that we'll ask a live first
question or shall I choose an old one
from Twitter from the hour before yes
sir what Doug dunk don't say anything we
will meet in the middle yeah so I was
wondering uh there's a bunch of talk
about potentially adding graphite
generics to Java in the future which I
imagine was something that a lot of
people heckled you about already so
sorry about that I'm curious as to
actually what's the thought process
behind behind us like the pros and cons
of doing it this late in the game is if
this were the British Parliament the
answer would be re for the learner
gentleman to the question I gave some
moments ago Brian would you like to do a
quick summary of your long answer for
every snow yeah so I like the way you
phrase the question because you didn't
presuppose that reified generics are a
good idea but you observe the people are
still talking about that and
you recognize that there are pros and
cons to it and and and and that's
exactly right there there are many
things that are imperfect about erasure
there are also some things that are
pretty darn convenient about erasure and
there are some unfortunate things that
we would like to correct but it's not
clear that the benefits outweigh the
costs and so this is one of those things
where in a perfect world if we could
wave a magic wand and get all the
benefits without all the costs we would
of course do it looking at what the
costs are are our current inclination is
to focus on other areas where we have
higher leverage because I think if we
went and did it tomorrow it would take a
lot of effort it would cost us a lot it
would distract us from doing other
things and ninety-nine percent of the
java community would say well it doesn't
look any different and so we would
rather focus on efforts on things where
people say wow look at this thing that i
couldn't do yesterday and so it i think
it falls down the priority list because
it is not as compelling to as many
developers as some of the other things
that we could work on in our limited
time resource and complexity budget from
a compiler point of view i want to say
that there's this hidden trade-off which
the users don't see until it goes very
badly wrong between how much you share
code and how much you split it and
customize it and therefore increase the
amount of code in your system if you
share code you have very compact
footprint if you if you split it then
you could potentially optimize it
differently in different contexts but
eventually you blow out your instruction
cache and then things go very wrong from
there and it's a recurring theme at
least in my experience in working with
computer systems that are practical how
you turn the knob between sharing and
customizing splitting if you do reified
generics you turn the knob decisively
towards customizing splitting and let me
just point out that there are systems
where this is the knob is turned that
way C++ templates do you like the the
code sizes that come out of very complex
to C++ template
question so yeah you then need heroic
optimization just to cram everything
back together and put the genie back in
the bottle c.net also has more reified
generics than we do and they not
surprisingly have the corresponding
problem of too many byte codes instead
of too few so it there's that there's a
reason that there's a reason we have the
reef rum a vm point of view that we have
the non reified generics it lets us have
simpler more shareable code follow-up
question is if you were to have whole
program optimization would you revisit
it well jigsaw is giving us for the
first time ever a framework for whole
program optimization so we'll have to
check back on that Java is a very
dynamic language which is a feature that
most people in this room enjoy and so
having hope program optimization is to
some extent incompatible with with it a
dynamic language yeah I tend to doubt
that we would want to go in a direction
that would make whole program
optimization almost mandatory to get
good performance whole program
optimization is fine as an option but I
think a lot of existing application
models programming styles would break if
that suddenly became mandatory there
will always be a need percent for some
amount of dynamic behavior so a language
feature that that that bloats your code
and then you know the such that it can
only be squashed down with whole program
optimization just sintra seems like the
wrong thing all right um let me combine
the on on the theme of language features
let me combine two to Twitter questions
into one any plans to support these are
actually questions from before but it
was getting near the end of the hour and
this and this could be quite long any
plans to support tail recursion co
routines other alternate execution model
were language level async operations hmm
I smell a planned those are all very
good things tail recursion co routines
reactive frameworks event-driven
execution lightweight or non-existent
threads one of the so there was a there
was an excellent question in the last
session which was what would you remove
if you could from from the Java
ecosystem and now it comes to mind I
would I would remove threads as they
exist now having having something always
have a thread on it means you have this
multi megabyte sort of jabba the hutt
tail following you around help and and
it's inconvenient you want to be able to
fork and join computations want to be
able to split and merge much more
efficiently than it takes to grow
another job of the hut and then make him
go away so yeah I think that the fork
joint framework gets us closer to where
we want to be in that it virtualizes the
threads and has these little more
reactive things that are running small
for keable tasks the JVM is holding back
some magic that it could be sharing
which is the ability for the runtime and
the compiler to reify the stack and and
reformat it on the fly this is inside
the vm we call this D optimization and
on stack replacement the two major state
changes so you actually have on your
stack an interpreter running along and
then it realizes that it feels kind of
slow today and it wants to speed up so
it gets some compiled code and then it
replaces the interpreted frame with with
an optimized frame that's a very good
trick that trick is not too different
from a co routine running along doing
task a and then realizing it wants to
transition to task B and just replace
itself with a tail call or perhaps with
you know just a thread replacement in
the in that case of let me say a fiber
or a micro thread replacement these are
things that the vm can partly do and
there's some prototypes out there to
surface that up
do we have plans to do this no we have
we have the the useful and healthy step
before plans which is healthy community
discussion so there was a great
presentation on her routines at the jvm
language summit earlier this year which
you can find online the talks about that
should we do something with this yes is
what about tail call in that in
particular guy Steele has been patiently
voting for tail call ever since bill joy
said we put it in one dot 2i says the
rumor right we we know how to do tail
call and that's that's just a matter of
getting the right number of votes to
bubble it up to a high enough priority
level so what when John says you know do
we have plans do this I think the answer
is we don't not have plans to do this it
it always seems like there's something
more important higher priority that we
will end up wanting to you first and and
that seems to happen a lot but it's not
that we don't think these are worthy
features that's it's just that they are
competing with many other features for
limited limited resources live question
anyone somebody else unless there is no
somebody else I'll here's somebody else
marketing troublemaker
watch out I'm going to be nice I promise
so the jigsaw works been split into four
jets and the first one I believe is
being completed dish what's what's the
next one out of the four okay so jigsaws
been split into four Jeff's for those of
you don't know quick quickie bit of
process information so in OpenJDK we
have this this process meant to be
lightweight for making proposals to
enhance the jdk they're they're meant to
be you know smaller in scope than a JSR
if they evolve api or language changes
then eventually they feeding the into
jay s ours but they're a smaller grant
granularity of thing with a much lighter
weight process anyway so they're called
Japs jdk and has enhancement proposals
we use these to structure all of the
major work that went into eight and
we're doing the same thing with nine so
jigsaw being a fairly large effort we
envision for jets so two already exists
their numbers are 200 and 201 201 is
actually the one that's finished so to
200 defines the modular structure of the
of the platform and the JDK itself so
it's kind of a in a way it's in a way
it's a placeholder it won't actually it
will be the last one it was the first
one submitted n will be the last one
done because we have to have everything
done in order to consider that finished
okay 201 was the Jeb is it still the
Jeff for restructuring the source code
so the internal source code structure of
the JDK has evolved over actually more
than 20 years it predates when it was
even called Java and as an evolved
slowly over time had a number of Miss
features and you know in particular
while there were no modules right there
were repositories we're kind of the
closest thing we have the JDK source
code is is actually a a set of mercurial
repositories you you pull them down in a
forest and they relate to each other and
that's how you do build
so the first big step in in getting
jigsaw in 29 was to restructure the
source code so this was basically move
everything around so that you can now go
into one of those repositories and
you'll find a directory except for
hotspot which itself isn't modularized
using jigsaw but if it in Jade the their
JDK or Jack's Peter other other repos
that contain mostly Java code plus some
native stuff you can go in and find that
the sources now in modular form you can
find them you can find the base module
and all the stuff that's in it you can
find the Java dot XML module and the XML
parsers and transformers and so on and
so forth all all 50-odd modules that we
have and that's now reflected in the
structure of the source code and the
build system understands that structure
so that it will actually do an
incremental build by running running
over the topological sort of the module
dependences and can be very efficient so
the the result of doing a build with the
modular source code is almost exactly
the same bit for bit as the build before
that and that was our goal was not to
change the shape of the bill product but
to change their shape of the show up the
source code and get people used to that
of course you know people are still
complaining I walk down the hallways and
people are remember there I used to be
able to typing a JD case or share
classes and I can I put a module name in
there but you know a progress requires
change sometimes and if you use an ID
that can help you too so thatthat step
201 that's done that's been done for
some some number of weeks 202 which i
haven't draft form and hope to submit
shortly after i'm done with this
developer conference distraction will
we'll change the structure of the built
product so we're today you you're used
to a Jerry or JDK build having a certain
shape with certain files in it after
Jeff 202 is done it will have a
different shape with a bunch of other
basis a few files will be the same but a
lot of files will be different although
all those all those command line
commands in bin yeah those will still be
there the stuff under lip is going to be
completely different RTR is going to be
gone tools dr. r is going to be gone
lots of things in inside will change and
again the this will be dramatic we know
we know stuff is going to break we've
been talking about this publicly for
years now you know warning people yeah
stuff is going to break if you you know
if you have if you maintain an IDE and
it's going to go look for tools jar be
warned that's going to change will give
you a nice API in 92 find the same stuff
but tools dr. are won't even exist we're
not just moving it we're getting rid of
it putting that somewhere else in a much
more efficient format so that's that's
Jeff well it doesn't have a number yet
it's not submitted that's that's the
third job the fourth JEP will introduce
the actual module system so that's the
big final piece so that's that's
something for which we will very shortly
be spinning up a JSR to get the module
system design done and specified that
will come in last may seem odd that it
comes in last but as we as we worked
through all the dependences that
actually turned out to be an order that
makes sense so until we have a model
system you might ask well you've got
these modules how do you how do you keep
them that way since there's no module
system enforcing the boundaries well and
the answer is we do it at Build time so
even after just changing the source code
the builds still check say the bill
doesn't check took towards the end it
understands what the model graph is
supposed to look like this is a quick
static analysis of everything that was
just built and the build will fail if
you crossed a model boundary in a way
that you weren't supposed to that will
remain true until we actually have the
module system so it's possible for
dynamic dependencies to leak through but
we think that will that will catch all
the static cases
and here was that a defective in the fan
sir we're not a bit long sorry the the
demo was was was or was of our prototype
so yeah that well that that actually
contains the beginnings of the model
system itself as well so yeah that's the
prototype which is running far ahead of
what you see in the actual JDK nine
source code because you know it it's
better to prototype stuff in a very
experimental way and then you know get
it stabilized make it make it make sure
it is what you want and then fold it
into to the actual KDK because that's
kind of a one-way street especially for
changes this large oh no the intent is
is is for jigsaw to be in in Java 9 yep
okay so we can still Twitter oh no which
opens up consult the room jigsaw enable
whole program optimization since that
was mentioned a moment ago what extent
does jigsaw enable whole program
optimization what you can do whole
program optimization today you know
there are tools that will take a class
path full of jar files and and do and do
a bunch of analysis jigsaw helps in a
couple of ways one is it is we're
introducing the note the notion of an
optional link time step to the Java
development model so that gives you a
natural point you know on which to hang
a big optimization step that can go look
at everything the other way it helps is
by having modules with strong boundaries
you do whole program optimization on
everything on a classpath you have to
make a lot of conservative assumptions
about what is actually going to be used
whereas if you know that that a certain
body of code can only refer to code in
these three modules then the scope of
your optimization is much more limited
and you can do more effective
optimizations because it's limited in
that way add anything John or
the thing that that I mentioned earlier
about Java that's really Pleasant is one
of the things is that it's dynamically
linked and it means you can build up
your program over time and plug-in new
pieces and you have a robust symbolic
linkage it and that's that's a different
feel than with a language that is
statically compiled and linked like C++
where you're in line sort of all are
collapsed into into code at compile time
there are tools as as Mark said which
can take an entire jar and given a few
entry points throw out everything else
that's not needed and do the C++ style
thing and shrink it down to a small
module that is in order to do that you
need a clear boundary around the code
that you're going to shrink that's
that's basically what we will be in the
business of with with jigsaw in a new
way and I think it's worth pointing out
that optimization means different things
to different people right so you know
John talked about space optimization of
pairing away code that isn't used by
your application and that's one form of
optimization that's really interesting
to people there's also you know time
optimizations and similarly a link time
you can do class hierarchy analysis
which the vm currently does at runtime
but you can do some that you know you
can also do it ahead of competant I'm
and explicitly in line through calls
that are known to be monomorphic and
things like that and so the full range
of optimizations both space and speed
that you might conceivably make at
runtime become candidates for doing at
link time with different combinations of
link flags yeah um maybe way to say to
think about dynamic link you know
dynamically linkage in jigsaw yes that
there is definitely a tension there and
you can think of jigsaw as a structured
way to impose some limits on dynamic
linker
that there still is being a dynamic
linkage once you've got the model system
but with limits we get other advantages
such that giving up on some of the power
of dynamic language linkage is actually
worthwhile so as usual it's it's all
about the trade-offs that follow
news for us so I
collection others probably have to do
with I get download classf algo that had
never been started calling in to the
time but they have to think that's been
usual use case promotion
so that that may be an unusual use a's
for most applications but there are
important categories of applications
there aren't that many instances of them
that do need to load stuff dynamically
well or well and what we're trying to do
is we would we would like say an
application server to be able to be
linked you know using jigsaw using some
optimizations but it will still need the
ability obviously to load web
applications dynamically and have the
modules in those web applications relate
to modules that were linked into the
underlying image and we think we know
how to we know how to make that work so
there there's definitely still a need
for dynamism and there will be a way to
do that you know if you still wanted to
use the classpath and class taught for
name and pull on reflection and no
modules you can you can do that too I
expect that one category of improvement
that will see with with jigsaw level
link time optimizations would be
something that would basically cash code
that would have been developed later on
and get you to get you to your startup's
your startup States earlier than if you
had to run the jit at the same time you
were starting your program so that
wouldn't necessarily remove any
functionality but it would move fancy
stuff like reflection out to the fringes
and concentrate on just getting your
your initial initialization steps
running as quickly as possible and
another example of that is for example
the way lambdas are implemented in Java
8 the at the first time that you
evaluate a given lambda expression and
given visit you know point in the in the
code it's going to spin some spin spin
spin some bytecode and loaded class and
it does that lazily which is great
because you know you get the full
benefit benefit of dynamism but it does
have
uptime hit and so if you're looking to
optimize for fast startup which is one
of the many dimensions along which you
might want to optimize one of the things
that a linker could do is is addling
time instead of at runtime run those the
you know those invoked an attic
bootstraps and cash cash the results are
you thinking of all legs transform this
is very similar yeah this is very
similar to what the latest Java ME vm
does which is it runs it does think
things that would be dynamic code
generation at runtime it does statically
at built at build time and and you know
the in any any kind of on the thought on
the fly class generation that might be
involved in future language features to
come you know could would be amenable to
this treatment as well okay I mean if
you take a couple of questions from
Twitter and merge them let's see
do your do you regret introducing null
references any plan to help with null
pointer exceptions optional was a move
in that direction but is there more on
the drawing board like language support
I do not regret the French Revolution
because I wasn't there he finally made
up this thing it wasn't involved James
are no he's not so I'll take the
optional part of that question so we
introduced java.util optional in in job
aid we introduced it because we needed a
way to describe a return value that
might be present might not be present
and we we tried to walk a very delicate
tension but between you know meeting the
library needs that we had and not going
all the way towards language support for
optionality and this is an uneasy
tension and no matter what we did there
was always somebody very politely
suggesting that we should go one more
step in whatever direction they you know
that they wanted and one of the things
stopping us from doing taking that all
the way is that we knew that down the
road we would be doing value types and
an optional is really something that
ought to be a value type you would like
to be able to get all the benefits of
the type system enforcing that you don't
dereference what is morally no pointer
without paying the performance cost of
it we knew we couldn't do that in Java 8
we knew that in the future we would be
able to do that and so we deferred
taking those additional steps until we
had better tools in the toolbox
hopefully to be able to do it in a way
that balances both safety and
performance I'll take a whack at the non
optional part of that question as it
were the mandatory garden exactly do you
regret introducing no references so I
wasn't there at the time but if I if I
had to hazard a guess my guess is
no thought was given to not having no
references you know it just it just
wasn't wasn't part of the the language
programming language research milieu to
have languages that didn't have null
references except for some of those
weird of functional things which of
course now they're not so weird are they
but in 1994 1995 they they were and you
can consider the original members of the
java team you know they were coming from
a c c++ background yeah a pointer can be
no it would be very it would be very
interesting question to ask James maybe
I'll ask him when I see him later this
week did you even consider it but my
guess is he would his answer would be
huh what so you know that that's just a
trying to trying to peer into the past
and so the future for once it is it the
truth I don't know you'd have to ask
games oh yes sir let's this
you mentioned early sorry you mentioned
earlier about dynamic coach any
generation at runtime so there's some
stuff done in austria by your oracle
apps teams are you planning to actually
merge that hot swap stuff that they're
doing about them swapping types and type
hierarchies into some of the coming JVM
i think you're talking about the hot
swap patch on em lvm the ml vm patch q
yes are we planning on that is
unfortunately one of those things it's
sort of in the middle of the priority
range that at so there are more people
that would use enhanced hot swap than
would use tail call and it's an easier
it's an easier cost to integrate the
patch we may improve hot swap patch that
we have it is let's see how would I put
this we have we can receive extremely
good contributions which still have not
yet been folded into the product because
of the limited amount of cycles
available in our you know in our core vm
staff and so at any point we look at
what absolutely needs to get done what
like first we have to do this power pc
port that that sa p is donating okay
we're going to put several engineer
months on that to to integrate it and
great now we have a new platform that's
a big deal which engineer are we going
to put aside to brood over this hot swap
patch or this tail call patch or core
team patch whatever that is that is a
hard question to answer if if the number
of people that want the patch is either
small or they don't know they want it
and so they're not they're not voting
clearly so at that point we technical
people can say here's this thing would
be nice to put this in let's get it in
but if there's something more strategic
that's that's some that's paying the
bills then we
but our engineers on that that's a
that's a kind of a sad lame answer I I
confess but that's kind of how the
reality works right yeah I can give some
more specifics on that functionality
itself and I think one of the things
we're trying to do or one thing we're
looking at it splitting it up so
currently that hot swap patch is solving
a few different problems so it's I think
primarily what people are asking for is
the ability to add and remove methods
but the patch also supports things like
adding and removing fields which happens
to be extremely much more complex and on
top of that there is a possibility to
add to change the type hierarchy and
that's where I think we're all sort of
yeah we're it nightmarish territory so
you know we're sort of trying to attack
the patch in that order so getting to
the method part of it first but the
whole area of we re factoring classes we
changing classes on the fly in the JVM
is an area where in general trying to
just get into better shape if I put it
that way so as much as you know with
works today we want to get it to a place
where we can make changes to it more
easily and less part of that the weave
in the method and field potentially part
of the hot spot Patrick do you think you
think they all get how expensive intake
is yeah I don't know I mean did this
this whole area for sure is one of the
absolutely most most complex of the JVM
because you're really taking the
innermost parts of the the type system
we have all the classes and how they
hang together and on top of that it's
all visible to the outside through
various api's like jb MTA JVM TI and
things like that so yeah this is complex
really complex area how many people in
this room are blocked on enhanced
hot-swap one yeah
oh yeah yanno in one of the key use
cases I think we see is if you have a
very big web application stack let's
call it fusion apps in oracle speak and
it takes hours to start up or whatever
then clearly you don't want to take down
your jvm just to add that single method
so clear this value in this we're seeing
the value but much like John pointed out
there's there's a trade-off obviously
between that and all the other
functionality we're looking at another
question correct me if I'm wrong but an
rmi when you're working with it the most
of the control seems to be with the JVM
I mean you don't seem to be able to
control how many threads I mean it
depends on how many call you are making
in parallel but underlying I mean if
you're using a more other remoting
framework you might be able to control
what's the level of parallelism in terms
of in the in the receiving side or in
the network channel you're getting and
that doesn't seem to be an option or or
or or also if you do rmi as soon as you
start doing rmi you get distributed GC
is and all that but in most of the
scenario they see people using rmin
examples essentially today people
actually treat them as separate vm and
don't really access the remote p.m.
subject as a single the distributed
portion of it doesn't seem to be used
much but there are no ways to skip it
and the only way to skip it is to use a
different protocol which is you know you
can use web services rest or something
but then it's not as efficient as I mind
processing the things you know the
sterilization and also
time is faster but you can control it if
the black box you send a call and arm is
hard to use yep um sorry I'm not so r RM
I let's see what our ARMA rmi is built
on all right okay sorry let me try to
answer your question questions are my is
built on top of bryan and my favorite
platform feature serialization ization
so as such it you know it's all it's
already got a bag of brittleness
attached to its side I think our mi at
this point in the platform's life it is
what it is specific requests to enhance
it in in minor ways or even better
patches and suggested patches to enhance
it minor ways are certainly something we
would consider but you know the people
writing sophisticated distributed
applications that you the percentage of
them that we see or hear about using our
mi is very small I mean but most most
people have moved on to you know some
some for a form of you know rest web
services Jason whatever and and that
seems to work well for them if you were
here for the first hour you you heard
her but Brian and I rant about
serialization are my makes make some of
the same fundamental mistakes it tries
to offer this this Pleasant fantasy that
oh well you have an object over on that
machine over there you just invoke a
method on it and it makes that work to a
fair extent but you know what that's
that's a really brutal fantasy as
sapolsky would say it's a it's a leaky
abstraction you know you find out very
quickly that no that's not a normal
method invocation you know you're you're
you're you're winding up in TCP and
sending packets over the network and the
network might not be reliable and all
sorts of bad things can happen now if
you're never controlled environment with
a reliable network you can actually be
made to work as long as you're cognizant
of the fact that those method in
vacations are much more expensive than
the ones inside your vm
but I I think in general though that the
rest type model which just recognizes
the look it's different when you're
going remote the local is is a good
thing you know independent of any any
particular protocol
yeah I I understand so don't use
libraries that use rmi I mean is there's
you can think of are mi as being core
but without the benefit of
cross-platform interop so given the
things that were said in the earlier
session about how eager we are to keep
Corbett in the platform you can draw
your own conclusions jmx can use our my
as a transport it can also use other
things as transports so you don't have
to use our my in order to use jmx and
you might be if you accepted some some
default configuration or some
configuration yeah outside of your
control you know it's even you can think
of this as you know rmi like
serialization was one of the mistakes of
the past it seemed like a good idea at
the time and in that in 1995 distributed
objects were all the rage and by several
years later we realized why that might
have been an overeager vision of the
future the code still there there are
libraries that depend on it their
applications that depend on it that's
why we haven't removed it yet that
doesn't mean that we think it's
necessarily a good use of the resources
we have to keep propping up what is
basically an ill-considered execution
model we'd rather focus our resources on
thing you know things that we can do a
better job at and that are going to have
more leverage for customers and and and
just in case you were wondering there
there is a way to use our mi over the
corba transport protocol yes yes there
is you could actually mix them together
if you so desire ejb depends on it it
does okay a question from somebody who
hasn't asked a question yet yeah you
asked a question having you know let me
know okay sorry it's been a long week
already it's only Tuesday is there any
future to Java advanced imaging
no sorry I didn't even realize there was
a present for Java advanced imaging I
think that that is now lost in the mists
of time after the after the acquisition
I'm not even sure where the code is
anymore it was available for a while but
I'm sorry actually I actually wrote a
couple of apps with it back in the day
then but then I decided to do we could
do a better job at Lightroom that I
could any other questions in the room
somebody new I'm not trying to pick on
you but that's all right we'll do reruns
you guys love serialization so much now
that you have so many years of
experience how would you do it better
we've considered this we have on someone
so the tension with serialization is
that so in the happy case you'd like to
be able to have serialization and
deserialization be explicit so the
creation of serialize of deserialized
instances should proceed through what is
a real constructor and the schema you
know that the mapping from the from the
class to its serialized form should be
more explicit it should have explicit
support for versioning etc and these are
all mistakes of the same kind which is
the attempt to make it transparent and
magic and from a you know just sprinkle
this magic serialization dust over your
class perspective it works beautifully
for the simple classes and then things
start to fall apart from there the
problem with a more disciplined approach
like you know more explicit approach
like the one I outlined is that there
are certain
graphs that simply can't be deserialized
that way for example except cyclic data
structures and so there are trade-offs
between what can be represented with
with a simpler civilization model and
the better integration of civilization
into an object-oriented system and none
of the none of the intermediate points
that we consider it seemed all that
attractive it's a very difficult problem
well if that that's that's essentially
what reread resolved us right in the
existing you know in the existing
mechanism um it's if you look at
serialization you see that there are
bags nailed on the side of bags nailed
on the side of bags right the you know
you have in in in the in the initial
version you just had implements
serializable and then you had read
object and write object and later read
resolved right replace were added serial
version uid was added serial persistent
fields were added externalize abul that
would've externalize got it wrong the
first time yeah sit so that there are a
lot of different overlapping cases that
were you know that don't fit cleanly
into the basic model and and I think
that's true for a lot of other models I
would certainly prefer a more explicit
model and one that was where
civilization was more integrated into
the object model rather than attempted
to scrape the you know scrape the
representation but I understand why they
made the choices that they made at the
time and it might be the case that if
they hadn't done that we might not be
here right because javas ability to make
remoting simple was probably a big
contributor to why Java was so
successful in the you know in the late
90s so it may have served a valuable
purpose but now work for kind of stuck
with was a definite
come on so from the from the vm level a
class is something if it's to be secure
ought to have only a few entry points
that are well understood and
serialization adds these extra in entry
points that are implicit in the source
code and in the byte code and are very
hard to analyze and to understand and
the proof of that is there multiple
security problems that stem from this
over time so what what Brian is saying
and what you suggested is that well
couldn't we have a explicit interface
like a factory method or a constructor
or something that is used to make
instance of the instances of these that
are when you deserialize them and of
course that's that's kind of a
no-brainer you want to have explicit
construction of them even when they're
even when the objects are deserialized
the missing piece that's sort of not not
so obvious is that you also need
explicit entry points for taking objects
apart you need in Scala there's this
very well understood option called apply
which is when you take a bunch of
arguments and you give it to a function
and you get a result there's a not so
understood function that is the reverse
of that called unapplied which takes the
result and takes it apart back into its
component parts and that's quite you
could call that a nun factory or you
know a nun constructor or an extractor
that is the concept which maybe wasn't
widely known at the time that
serialization was designed and like know
the concept of non null types wasn't
widely known you know in when see sort
of was rated to become Java so at this
point if we were to redesign
serialization we have we have new
conceptual tools let's say that are more
common in the community for building the
right building ap is that can not only
construct objects like factories but
take them apart for for shipping across
a wire so i think i think if i think if
we were to do serialization the using
today's technology we would we would do
a better job not because we're so much
smarter than those
guys that didn't know what they were
doing but because we have better tools
better conceptual tools okay question
from Twitter can we get properties like
project lombok or groovy properties
literals maybe question that never goes
away what one of many questions one of
many lessons that never goes away yeah
the real question is you know what would
you give up for that right it and a lot
of these things are things that arguably
we should have done 20 years ago but
given that we didn't do them 20 years
ago they are incremental utility to do
them today is greatly reduced and if you
look at the project coin as a project
coin was done what was part of Java 7 it
was a community driven effort where we
accepted proposals from the community
for language changes and there were
several competing proposals for
properties made at the time and the most
bitter arguments on the project coin
mailing list were those between the
proponents of various different
properties proposals each calling the
other an idiot for not understanding
what true properties were and this was a
cautionary tale because everybody what
many many people are in favor of
properties but when you ask them what
they mean by properties you get many
different answers and if we were to pick
one of those the other end minus one of
those groups would hate us even more for
having like almost done the right thing
and then blown it at the last second and
you know so it seems like there's no
winning move with it it would have been
great if this had been part of the
language in the early days at this point
I think reifying a library design
pattern in the language and trying to
retrofit it that way is probably a
mistake I think it's one of those things
that we just need to look at as
something perhaps we could have done a
long time ago but the time for it is
past and i think the effort is better
spent on other features will do that in
another life
that's actually the linkage to the
previous question that Eric mentioned
about why exactly what's in your other
language and look at the it's a serious
question well what would you not want in
Java in favor of properties you can
simulate almost everything in a property
using one or two or three methods so you
met java objects classes methods you
could do you can simulate properties of
the fairly low syntactic and runtime
overhead would you what part of that
would you give up in order to get this
nice crisp property notation maybe
there's an he'd give up serialization of
course and we know that reflection
messes a whole bunch of other things up
right so why do we continue to use
properties system that's based on
reflection so for for Colin property
appears to be a I'm sorry to pick on you
but you just poke yeah named value that
you use reflection to get from an object
and for that we are supplying guy
sitting next to you bear handles which
are a type safe way to do that and
without adding much or anything
hopefully not much to the language i do
i will say that that it was it was the
first thing i personally when I when I
visited the Java organization for the
first time I said why you has no
properties like i sat in front of the
faces of the people in charge I said you
know if you just change the vm this way
you could put in setter methods common
lisp stipes type setter methods that's
my version of what properties is right
and you know what it's it's simpler to
have fewer language constructs as long
as those language constructs can
simulate all the missing things without
too much overhead although I still would
like setter methods
so we mentioned jmx just a little bit I
do you guys recommend it is this sort of
these things that is worth the
complexity and comfort context imagine a
standalone server application that you
want to just query for some state and
send it commands occasionally is that
the right technology for that purpose
today could be a so jantjie MX has its
issues but but it but it works you know
we continue to use it for exposing
information and certain kinds of control
features for a running java process if
it works for you in that kind of context
than sure you might want to steer clear
of the rmi transport but but otherwise
you know I I don't think that's that
that's something that we would put in
the same category as a sake or by I
expect jmx will be around for quite a
while it is is it more complex than it
needs to be well yeah yeah but I don't
think it's so so burdened with
complexity that it's something that you
should avoid necessarily know I'm going
to say that it's actually one of those
api's that would you know somebody got
mostly right from the start given how
well it works in many cases we are
making as John pointed out minor
improvements to it I'm you know I don't
know when these will show up but there's
a both on the transport side of things
but also the declaration side of things
we're trying to make things slightly
easier at least so yeah I mean it
obviously depends how long is a piece of
string ultimately but uh seems to be
working well we know that you know the
answer that right by my grandfather has
entered that it's twice the distance
from one end of the middle
remember Matt okay any other questions a
lot of questions they are basically
about yesterday's solutions being
today's problems so what are the
strategies I mean language feature can't
go away apparently with the core by
library can't go away so can you design
a platform for the vacation of 40 at the
feature in a way that could be removed
20 years from now ok so we touched on
this a bit in the first hour we are
trying to to morph Java into a platform
where things dude occasionally disappear
in a controlled fashion with plenty of
warning so there are things which were
deprecated in the early days that
shouldn't have been deprecated they
should have been painted with a brush
saying that this is not the best choice
we actually we want to revive
deprecation give it some teeth and
actually tell people look does it this
method this class this package is here
now in the next major release it will be
on and gradually remove things that are
just not interesting anymore that I am
but aren't actively being used by a
significant number of developers and end
users so the the module system that
we're working on within Broderick jigsaw
will certainly help with this because we
there will be tight boundaries around
some of these features we can deprecated
an entire module and say look the core
biz here in nine guess what in 10 it
won't be that's not a promise is just an
example or a fantasy i but but no i
think in any platform to survive for a
long time it needs to be able to
jettison things that were possibly very
valuable 20 years ago and just aren't
valuable now and are just a maintenance
burden for those of us who maintain the
platform and also frankly a cognitive
dissonance burden for for developers i
mean there may be a few developers who
look at
the corba api anymore but you know the
fact that it's there is frankly just a
distraction if you're new to the
platform you don't quite know what
Corbett is 0 this court of thing and now
wait a minute that's really complex all
but I need to do something remote it
looks like it might help me and you
could spend a week and you start looking
up stuff on stack overflow and reading
books like oh that's great that's a very
long string two poles we just you know
take it out we could say probably a
significant amount of developer pain
there there aren't many anybody who
really hasn't asked a question sir thank
you on a totally different topic about
really things from the past we have
arrays in Java and they are indexed with
integer and in the earliest class and
the asset class we saw in recent version
of the JDK protections to against
overflowing of those arrays I mean at
some point when you double the side of
the arranger rights class for instance
the fact that you could need integer max
value was never checked and now is there
is checked so don't you think that at
some point we could hit some kind of
limits not so far in the future and that
will lead to another question where we
need to move this index that is an
integer to our longer index in arrays I
guess it won't be that easy to put in
their language but you know I hear big
data's all the rage these days and 32
bits or all 31 bits is not very big yeah
so Java Java was created when a hundred
megabytes was a really big development
machine that was the first time I
compiled hotspot it was on a whooping
beefy 128 Meg machine and so you would
never ever need 64-bit anything for that
right so we've we've we've moved up the
scale and now our two gigabyte arrays
are looking kind of
small Giga element the the change from
32-bit to larger indexes involves deep
changes throughout the typed schema of
everything that has a composite
everything that is a composite there's
very few composites in the AP Isis in
our api's now where somebody with
foresight put in a 64-bit index maybe
what are two places but so it's going to
be a messy change the the place where
we're experimenting with this right now
is in something I mentioned in the last
hour or raise to 0 which is a sub part
of the Panama project Panama is about
foreign function interface native data
interconnection and big arrays and those
those those three things synergize
nicely the big arrays themselves will
our involvement part we're prototyping
and interfaces which abstractly say
here's a bunch of elements II index by a
64-bit pointer so there's it's a bunch
of interfaces that we're working with
and the the the optimization problem is
to get interfaces that are easy to work
with and that express efficient
operations that can be compiled down to
native code without without overheads
and that's some that's a very active
piece of develop advanced development
that we're doing in project Panama so
yeah we see this coming you I think the
last year or the year before I gave a
talk at JVM language summit on arrays 20
and it talks about the design the
degrees of design freedom for arrays or
razor-like properties everybody has an
idea of what the an array is but the if
you combine all of those ideas of who
that people have for what an array is
you get something that can't be created
because it's it's got too many different
of you know impossibly aspects that are
impossible to reconcile so the the thing
we're doing with a project panama and
arrays 20 is building a menu of array
type constructors
that will allow you to build well I need
a matrix of doubles I need a vector of
complexes I need an array of mixed data
records flattened I need an array which
points on to userspace aunty native heap
all of those are valid uses and we think
we can express them in a reasonably
small number of interfaces and still
optimize them to good code so that's
that's our approach will that ever allow
us to have java.util.list with 64-bit
indexes I don't know the answer to that
I think we have to develop some of our
current ideas about value types and
specialization and dynamic clasp
spinning in order to give us the tools
to create that kind of a hybrid system
we in the java community we highly value
continuity and compatibility so we're
never going to just say okay all your
code that works with 32-bit indexes that
that's all broken now so we have to we
have to work towards a a mixed model
we're in debt and index is something of
a probably a parameterised type
so in the mean there there are many
reasons why you can harp on the signed
nature of Java primitives but in the
context of arrays ok that gets you one
more doubling that buys you another year
and a half of Moore's law before you hit
the wall so whether or not insar signed
or unsigned makes a really small
difference in terms of when we're going
to have to tackle this problem but it's
certainly before we all retire either
way so we might as well tackle it yeah
sorry if I do oh you had plans India so
we're we're we're at the bottom of the
hour some of us have another session to
get to thank you all very much for your
questions and have a good rest of the
week</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>