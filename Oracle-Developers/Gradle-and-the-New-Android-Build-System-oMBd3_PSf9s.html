<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Gradle and the New Android Build System | Coder Coacher - Coaching Coders</title><meta content="Gradle and the New Android Build System - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Gradle and the New Android Build System</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oMBd3_PSf9s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to this talk about the new
android build system my name is Hans
doctor i'm the founder of cradle and CEO
of great aware and so this talk is about
not just about how you use Gradle for
building Android applications it's also
about why cradle has been chosen as the
platform to build Android applications
from the Google Android team and and
what are the generic features and why I
build systems important also for Android
and stuff like that so let's start with
a why I build systems important why are
so many people here in this talk I guess
it's not just because of me so so so one
major focus of cradle is a has been in
the past really heavy lifting for large
enterprise builds so for example linked
in they have a single Gradle build 3,600
sub-module build for 800 developers
right so and we have we have quite a few
engagements like that and users of
Gradle like that and it's a very
different problem to what most android
android teams are facing but it's a it's
a serious problem so in that so so we
see many projects that are shipping
software for living and aren't on the
brink of dying because the automation is
not working they have 200 people in
Northern America 100 people in India the
build is taking 15 hours when should
they do a commit before they can get any
feedback right then they start doing
things okay let's have this six-month
freezing period that we need to
basically figure out to release after
everyone has just thrown their stuff in
version control without without early
integration and and and then many of
those code bases those are all legacy
code bases so so people are getting
completely risk-averse because they're
hardly capable of getting a new
distribution build where all the tests
of are succeeding so instead of doing
some ambitious with factory
to pay back the technical depth they are
going down the opposite route no changes
no ambitious changes and that brings
them in a heart and have a situation so
so for some and I can tell out of my own
experience for some large projects that
the build system and the automation
infrastructure is not working is for
them it's getting mission-critical they
under there are they are almost losing
the capability of shipping their
software to the clients like and then
and this is a vicious circle then the
quality suffers from that and then the
clients are saying well the last upgrade
was not very successful we don't want to
upgrade to the new version but please i
want to a feature a B and C of the new
version right and then they have 15
branches you know complete complete
nightmares I could talk a lot about that
on the other hand because it's such a
challenging domain to do to do builds
and automation on the large-scale level
on the other hand companies are doing a
really good job having a strong
competitive advantage like LinkedIn or
like Google who invested into that area
area while ago massively together to get
a really good continuous delivery
pipeline going so so that is one area
where Gradle is used massively right and
anti advantages and the necessity are
obvious there's no questions they need
that or they lose take a capability to
ship software so so in that respect
cradle is a well-established technology
there you know six books out there with
our own cradle conference two days three
tracks the summer we had 1 million
downloads over the last year many
corporations are using cradle for their
software specs in large software stacks
and so just to give you that background
which is which has nothing to do with
Android so now you could be wondering
well oh this is no longer the heavy
lifting large team this is kind of more
an Android team let's say 10 people why
should they both are about bills well
why should any kind of smaller team
bother about build systems you might we
ourself might ask us this question
cradle is a small project we
overall we are 15 people right and but
for us investing into our automation is
absolutely crucial for our success let
let me give you a couple of of scenarios
of what we're doing so for example we
are shipping every six weeks a new
release of Gradle and that involves
quite a bit of stuff we have to make
sure that there are no performance with
crashing so we have a really massive
performance regressions you to test
against all the different versions of
cradle to see where our memory
consumption and performance is
developing of course we need to test
against all the different platforms
right where Windows 7 Windows XP linux
against the different Java versions not
just from Oracle but also from IBM you
can see it's kind of an interesting
testing picture we have to deal with and
then we have our documentation every
snippet in our documentation is life
tested so when you see it when you see
in a greater user guide some code this
was tested and the output was extracted
and injected into the user guide to make
sure that this is not stay a code right
when we when we release all the website
is updated with all with all the
download wiring and things like that
that way we are pretty relaxed when
we're doing release right did emails I
send out to all the different stuff that
needs to be done hey a tweet there an
announcement here and and and that saves
us first of all if the release would be
more painful people would say oh let's
do it tomorrow right and if it were if
it were less automated it would be much
more error-prone right so the
documentation would be full of bucks
would have to hire possibly a copy
editor to check to go through every user
guide after each and every release will
say oh let's then do it only three
months it's getting too expensive right
so for us to do agile development to get
our features out fast even for us as a
small team it is essential to have a
high degree of automation and that's the
same a for I would say for any project
that is a that is shipping software that
is relevant right that is not just some
toy project right and also for every
Android project so although
it is not as mission-critical as for the
larger stacks where they don't have any
choice the benefits in investing into it
automation are enormous right and then
what we often see is that that you have
in some so in most of the organization's
a android is now normal part of the
software stack right the same is true
for iOS cetera but what we are still
seeing is that they're kind of isolated
right so you have the Android team which
is doing their own stuff and then you
have the rest of the software stack that
is having a much more elaborate and
integrated build an automation pipeline
and that is problematic because usually
the android stuff depends on some of the
backend services right and that's where
it's getting interesting maybe the guy
that is right in the backend services
wants to do once you have an easy way to
do some integration test whether the new
version of the backend services still
runs with the Android application and
things like that so you want to you want
to deeply integrate your Android
software stack into the rest of the
organization in particular if you have
runtime dependencies and that's and
that's one thing that that greater will
enable very well okay so what is this
Android build system about we're talking
about well the base of that build system
is Gradle what we think is the mode most
advanced build system out there and not
just for Java so Gradle has a good
scholar support good JavaScript support
a good groovy support very soon very
good c c++ support so it's a it's a it's
a build system that embraces the reality
that the software stacks nowadays are he
drew a genius right there no longer
legacy are we still have to C++ code
lying around they are they are
heterogeneous and that won't change so
and then there's the end broad cradle
plug-in which is the Android build
system and the IDE integration which is
really nice piece of energy
nearing developed by the Google Android
team itself so it's not the cradle folks
that are doing a great land droid plugin
it's through google folks but we have a
really good cooperation going with them
and it a nice thing about the Android
build system this is not just a good
build system for Android it picks up or
it it is really innovative and I will
talk much more about that soon in the in
the features it has developed and I'm
sure many platforms will get inspired
from some of the patterns that are used
in this android-based build system right
so this is really a state-of-the-art
build system that is that is it is
leading leading the build systems
compared to other platforms okay so one
important part of that build system is
that it's declarative so what does it
mean let's let's go back so
theoretically a this empty script here
is a valid cradle script right you can
use greater for anything you can now say
a this is a java project or you could
say well this is not of any type any
type of project you know just and then
just tell cradle I need a task for this
I need a task for that okay but if
you're having an Android project the
minim the minimal the minimal Android
script you need to build that let's
forget about this section here is this
you just tell Gradle hey cradle I have
an android project that is the SDK
version I need and this is to build
tools versions I need that's all right
and then the idea is that this android
plug-in makes a couple of assumptions
for example it makes the assumption that
your Android source code lives under
source main and the asset's live on our
source main assets and a code on a
source my java and that the test lives
on a source instrument test right so
those are the assumptions you can of
course tell creator to look at different
places but if you don't if you do if you
stick to the
sumption this is how easy or build
script look like right just this is an
Android project and if we are now I can
also go to the command line we can now
ask cradle hey what can I do with this
Android project and you see a simple
life cycle so you can assemble you can
build your apk we will talk later about
what it means assemble debug assemble
re-release assemble test well let's talk
already about it assembled test you
don't need to create a separate test
project as with other build systems
right this is the whole older all the
testing and Android user is
automatically dead with you within the
same project right you can you can deal
with dependencies if you have external
dependencies you can install your apk
you can uninstall it from a device and
you can run the instrumented tests and
you can run lint right ok so the
interesting thing is an Android project
is much more complex than a java project
so it's a more challenging domain for
build system if you look if you look at
those tasks here you think oh why is
that the case right this looks pretty
pretty easy but if you look at all the
stuff that is happening to build an
Android application this is now much
more complex you know in Android you
need to do all the all the dexing the
render script handling the aidl handling
the resource processing the assets
processing you have you have proguard
you have a simple line it's it's much
more complex to build even a simple
Android project than a java project and
one quality of this new build system a
normal Android developer doesn't care so
we try to hide the complexity as much as
possible it's not like an N script where
you have it all in your face all that
stuff right we try to hide that a normal
developer only cares about the relevant
lifecycle stuff install built uninstall
test boom is not thinking about oh I
could possibly do this render script
stop there
the good thing with that is it is all
happening automatically if you need it
you just need to put your render script
code into some a dedicated directory and
will be taken into consideration right
but you don't but it's usually those are
steps you don't execute in isolation
right there they're usually
automatically done as you build your apk
so we try to hide that complexity okay
so now one thing you can see here there
isn't this stays an install debug and
install test task but no install release
task we can't the release test is not
offered because we haven't specified the
signing so that's what we're doing now
so we define a signing config and we use
the debug keystore also for our release
APK which is something we usually
wouldn't do right and then we tell hey
for the real for the released version
designing config should be the debug
config right and if we now look at the
tasks that are offered we see there's
none install release task so you see
compared to end where everything is
happening on the low level right here
you have a declarative language that
where you don't need to tell the build
system about the how right you don't
need to say this is how your decks this
is how you compile you just say what you
have I have an Android application I
have some sign in config and the rest is
all happening the how is figured out by
the Android build system by cradle okay
so now the interesting thing in the
Android domain is it's more complex than
a Java domain they are now typical areas
where developers want to have some
flexibility so let's start with the
first concept that is typical in the
Android world it's called the bill type
you want to be different ap case for
debugging for releasing or for staging
for example
right so obviously for the debugging you
don't want that program is running that
record it's shrunk right you want you
want that a debug flex I said to true
for release you want that programming is
true but that the debug flex are set to
false right and let's say if you have a
build system that says oh one project
can only publish one artifact like some
build systems like that are around you
have a problem you can't you can't build
multiple artifacts per project then you
have to create multiple projects one for
the debug version one for the release
version or you have to deal with maven
profiles and what not right but it's a
we want to make it really easy to
capture that scenario right so who views
doing scala development i had a look at
scala many huh so my friend big war is
big scarlet Poquette he wants to have
Scylla on Android so the problem is you
need to ship scala with the android
application right if you want to do that
and so it's really important that you
get that you shrink to code so um on the
other hand shrinking Nicole for the
whole thing the Scala library and the
Android application is a very
time-consuming process so what he wants
to do for example he says okay I have to
debug the debug version which builds
really fast no shrinking of the code
right but it's very big but but on the
development a time you don't care about
that but then for the QA folks I want to
have a staging version because I want
that day test the stuff as close as
possible to production so they I said
proguard into true but the debugger
debuggable flex are also set to true
because if there is some problem going
on I want to have an easy way of two-bit
debugging it right and for release of
course regarding is true and debugging
is false so those are typical scenarios
where where we make it really easy to
work with that so let's have a let's
have a look at an example oops
so
so here we have a an android project
which makes use of the concept of build
types if you remember in this project
before you saw a command like assemble
debug and assemble release right the
cradle android plug-in by default is
adding a bill type release and then
build type d bar you can now easily add
your own bill types or configure the
ones that have been contributed by the
android plug-in itself so you could say
the debug the debug build type already
exists but you you modify the package
name and some of the built config code
right and then you say hey cradle I want
to have an additional build type staging
right and you want to set debuggable
true Jane the I debug build true zipper
line true proguard true and yeah and
then you specify the ProGuard file and
assigning config and to build config so
again this is a high-level declarative
statement if we're now going to this guy
here and say hey cradle show me the task
you see there's now an installed staging
tasks available for you right and there
isn't assemble staging task which just
builds the APK you did you don't need to
care about that right that happens out
of the box this to build the staging APK
would require easily 15 task right with
all the render script and the texting
and things like that but for you it's
just a couple of lines of code and even
better lets the staging application
might need some special resources right
how do i how do i get to my project
explorer yeah sorry
I mean I mean I mean large more thank
you oh so you see here the idea is that
the major chunk of the Android code is
in Maine but you might have certain
variations for the release and the
staging version right make sense so and
you can now create a staging directory
where you put in special code and
special resources just for the staging
APK the same is true for release and you
don't need to configure anything there
is a convention in place if you add a
bill type staging all the resources in
code you add to a sort staging directory
are automatically picked up with by
convention but on a bed net in a dynamic
way you declare something right and the
mini framework is created to deal with
that you can also have special external
dependencies you could say hey for my
staging compile version I need comments
I all right and for the release version
I need something else for whatever
reason so you have external dependencies
handling per bill type so that's one
really nice thing they the Android a
build system is enabling and I see this
all over the place where people with
their current build system try to work
around that right they have a they have
an apk for the CI they have an apk for
the developer it's right to solve it
with maybe profiles who's using maven
for building the Android applications ah
so okay so that's one concept one
declarative element they added to make
it really simple to solve the typical
use case in the Android world the next
concept edit is called a built flavor so
the bill type has nothing to do with
what you are shipping to your clients
it's one android application you are
shipping right it's just just you need
different versions on the way mostly for
the debugging behavior but is another
topic the other two
scenario in the Android world that you
have an Android application with tiny
variations free and paid right it's
still do the major chunk of the code is
the same but there are tiny variations
between the free and the paid version so
that's that's another thing the android
plug-in makes very simple let's have a
look at that so now we start here so
there is not a concept of a product
flavor right and you say hey I have a
free flavor and I have a paid flavor
right enter and the same game is what we
playing for the bill types if you know
add a source paid directories this will
be automatically part of the paid APK
right the same would be true for free
except that I don't have no I have I
have sources for the free one I could
not also have separate external
dependency maybe the free version is
using a non-commercial library and the
paid version is using a commercial
library which is better performing right
it's also easy to solve that here and so
and now the interesting thing is now i
have for our flavors and i have build
types right so and that that leads us to
the next concept sorry i didn't i didn't
say this is x-ray to this presentation
but so we now have a cartesian product
right we have the trousers are are the
build types and the Flies are the
product flavor and we have now something
that we call a build variant there is
now free debug ATK if we release APK app
a debug APK in a paid release APK right
and let's look at the salt
the source code of that at a task you
know can do with this guy here and you
see install free debug install free
staging install free tests install panty
box so you can now do oh all what you
want to do with a particular subset of
those ATK's I mean you can't you can
easily tell cradle hey cradle build
everything right and then if you know
open the bill directory you see a here
are the apks that I built flavored is
the name of the project free debug
flavored pre-release unsigned flavored
restaging unaligned I'm and so on and so
on all the different variations that all
or they make automatically built for you
but you can also easily say hey cradle
just just meet me only the AP case for
debugging right so 231 and the paid one
but just for debugging right this is
that the purpose behind that we want to
make it very easy to you to only do it
exactly that what you need to have fast
feedback cycles and stuff like that
right so on see on CI you might say hey
built me everything and test everything
the development level you say it just
between the debug version are not
interested in the release versions with
all their time consuming programming
stuff and whatnot right so of course you
can also say build me only this
particular one only the paid debug so
it's up to you right but this Cartesian
product is fully modeled in the crater
built so free and paid debug and release
any other variations you might be
interested in can you think of any know
this yep an int'l is getting active
right so a I am vs. x86 so so how do you
need it with that right you
oh sorry maybe the next release know
there's already a solution for that so
it's called you can introduce multiple
product flavors you can say or so when
you go back to the picture you can add
sunglasses easily for that guy so let's
take the example of the processor right
you can all say I have a free and paid
dimension but i also have an x86 and an
AI M dimension right and then you have
now the tuples of three that describe
your built very end right and let's look
at an example of how you can do that
flavors here we go so I mean it's a
small build script right just every
flavor I have a paid flavor Evan am
flavor and x86 flavor and tier you have
declared two flavor groups ABI and
version 2 free flavor belongs to the
version crew to paid flavor as well and
the a RM flavor belongs to the avi group
and the x86 flavor as well if we're now
going to build script we see that this
is now reflected right and you have a
assemble am free debark assembler m4
release etc etc but you can still say
build me all the debug versions right so
the same the same hierarchy we have seen
before and and then let's again enjoy
this build script because so much of the
complexity here is completely hidden
this is looks like nothing right but if
you do greater tasks or you have more
than 300 tasks now imagine how your
Enfield would look like for this guy
thousands of lines of code all right and
then imagine someone looking at a 10
script and are wondering Oh what flavors
are we building here right it's just the
task in itself so in terms of usability
in terms of maintainability we reach
here a dimension where things with n
would become very hard with maven what
would you have you would have easily a
30-40 sub-module build you need it you
need a sub module for each test you know
you need to the instrument paid test
enter in you know only their own sub
project and every flavor needs the unsub
project Wow I know so so there's a lot
of complexity you would add that is not
really necessary as we can see here
right because things are properly
modeled and that is thick that is the
key that is the key beauty of the
android plug-in and i would also say of
the cradle platform because it allows it
allows it to be used like that that you
can properly model your domain and you
can provide a rich model to the users
why is that so important I mean I talked
a little bit about that already so the
key for me is we want to offer a rich
model with the android plug-in to model
the android domain so that the android
developers that right an android build
script don't need to think in terms of
the build system what is the creative
tasks what is the greater sub-project
you know how do i create a sub-project
for my for my instrumented tests who
cares you know they should be able to
describe the the problem they are having
from their domain perspective and that's
the language we are providing and then
how this is mapped to the build system
that's the job of the cradle android
plug-in and this is so the usability of
that and the maintainability is so much
better the learning curve etc but there
is more to that there's more to that so
um let's say you want to provide a
little drop-down box for your QA folks
1 2 u.i they want they don't want to use
an IDE that one don't want to use the
command line you want to little bright
little swing applications where they can
double-click and the particular flavor
is built ah how would you do that if you
had model depth with end there is no way
you can ask the end build hey what are
your flavors and doesn't know what the
flavor is and only knows what the task
is a target is right so having a rich
model makes it makes the whole thing
variable and extendable you can now ask
cradle because it's modeled hey what are
your product flavors and to what flavor
group do they belong and then you can
put it it's a couple of lines of code
because it's modeled it's accessible to
you and it's therefore easily extendable
right and and then if you compared to a
maven solution let's take another
example you want to say before you
commit your code hey please build all
the debug types of my AP case and test
them would be very easy to do that in
cradle with maven you don't have the
abstraction of that the tests are
something special they are just another
sub project so you now have you 40 50
subprojects how can you just execute a
subset of them to say only build to
debug versions and then run only to test
for them there's no way the abstractions
are not there so this is not just the
usability and maintainability thing this
is also this is rich models also
extremely important on how you can use
your stuff how you can extend it how you
can integrate it with other to lean in
the Android studio there is a do you
have a nice drop down box on what flavor
you you are working on because greater
makes very simple to query that but
another example let's say you say okay
we have a couple of Android projects in
our company and we want to write a
company-specific android plug-in for
crating where we say where we want to
have a special check that we we want to
go through all the external dependencies
of our free versions to see that none of
them has a commercial license and it
would be really easy to do you could
write a plug-in
gradle give me the product flavors
container iterate over all the product
flavors and and then give me
dependencies for them because the
abstractions are there so this makes as
soon as you get ambitious and you want
to customize stuff and that's the stuff
we talked about at the beginning right
pushing your automation much further
than just building the APK having such a
rich model is priceless okay and as our
another nice thing of the whole Android
a of the whole new Android build system
is that there is a plug-in ecosystem in
the making the android plug-in by itself
is a greater plug-in but it's more than
a normal plug-in it may it's basically a
plug-in that it that extends cradle to
become an Android build platform which
can then be extended by other plugins I
want to show you one example any of you
knows money more money more is a
provider for Android virtual devices in
the cloud right so so if you if you
don't apply this money more plug in
right and you have your normal Android
applications application if you if you
if you create a hair cradle run the
instrumented tests what greater will do
it will look on your local machine is
there's any if there's any virtual
device or any real device it's running
or I attached to and then it runs it
deploys the test apk and runs the tests
now just by applying the money more
plug-in just by this one line and then
buy some of that specification what is
now happening the tests are no longer
run locally but they deployed to the
money more cloud on the devices you have
specified they are run in parallel so
you can you can you can configure it in
a way that they are run in parallel on
the same device and then the test
reports are sent back you wouldn't even
have an idea that that that this has
happened it's completely transparent and
it's extremely easy to use because the
android plug-in is really extendable
right thanks to cradle I might say and
thanks to the good work
Google Android team did that now money
more plug-in can easily hook into and
can rewire how the tests executed no
longer locally but in the cloud and
testing is often a massive performance
problem in the Android world I don't
know who views running into that so and
that's how easy you can solve that with
that commercial provider you could also
do something similar if to say I want to
use my private built form for that
purpose right and you have to write your
own money more plug-in but it's all
doable right but you still have the same
test reports that are generated and
things like that you can completely hook
into a rich platform okay so one there
are many reasons why kind of Android and
Gradle found each other one are some of
the other nice base services cradle is
providing be it android or any other
platform and i would like to give you
one example of what you can do with
Gradle overlap two or three should say
so one thing almost every greater
project is using is the greater rapper
so what does this create a rapper about
so here we have for a chance for a
change I should say oops why can't I
stop Skye we have a java project it's
the same game we have a java project
core java star not we stick to certain
conventions right and we define the
dependencies it's a much simpler life
cycle and android nonetheless but you
could do the same with an android
project you can declare what we call a
rapper task and then execute the rapid
house this is something and not a normal
developer is doing but you as to build
master right and if you execute this
rapper task the following is happening
this rabbit asked has output but the
output doesn't live in the bill directly
but it lives in the root directory of
your project it generates a creator w
script to create a w bed script and
create a rapper directory with a very
tiny crater ray Pajar and the greater
wrap up properties file so let's look at
this properties file so
so what you're now doing after those
fights are generated you commit them to
version control right the next time any
of you developers are checking out this
project they don't need to have cradle
installed they just use creator w/o the
idea integration is doing that
automatically as if they were using
cradle and then the Creator rapper
distribution is automatically downloaded
as specified here to the developers
desktop and everything works if you
upgrade to new cradle version you just
change the distribution URL committed to
version control and developers
automatically get the update so you have
zero administration for the build system
on the client side another thing that is
a nice side effect is your builds are
now also much better reproducible if i
go back to version control one year ago
here here I go and my build system at
the build system version i was using is
is nailed down it's in version control
and I can and I know exactly what build
system I version I have to use and it's
automatically used right to build the
software had a last year we we have we
have one cradle user they are built they
are building medical devices and
shipping them to the hospitals when they
get an audit and the auditors come and
they can't show that they are able to
still reproduce to software the archives
that are used on those medical devices
they have to call them back so for them
reproducible builds is important right
end and i think android is also getting
more and more into more mission-critical
domains right so for some folks that's
also very nice side effect that you have
offers for others it's the major thing
that you have a reproducible builds okay
so that's a really convenient feature
and of course usually you would use a
distribution URL that is that is in your
in your domain to save us some bandwidth
ok the next thing i want to show our
init scripts it starts very simple so
let's say you have multiple bills
right and here we have one build it's
called testing with Gradle and and i
want to show how you can inject to be
unchanged behavior of a build from the
outside right let's start with a very
simple example i just cut out the
information where to retrieve the
dependencies from right just cut it out
from this project and then i create what
we call init script can live wherever
you want where we put in this
information let's not bother about the
oil project sections we say hey
repositories should be maven central
right so now let's go to this project
testing with Gradle and let's let's run
the tests if you would stop here the
bill would fail because greater would
say hey I have no idea where to get the
external dependencies from but we can
inject this init script and the build
works the tests are run and everything
is good now now to show you the power of
that let's do something much more
ambitious I want to inject the following
behavior into this build I want to get
in real time warning if any of my tests
are taking longer than 20 milliseconds
that's more interesting I guess so so to
do that created in general provides you
a very deep API so you can you can get
you can get into the very internals of
cradle to get information out to change
the behavior etc etc so to achieve that
we we first get the cradle object right
this init script runs in a cradle
environment so there are certain objects
that are that are available and the
cradle object represents the built the
init script is injected to all right and
then we tell this Gradle object hey
after all the build scripts are
evaluated in this case it's only a
single project build so it's only one
build script give me the cradle object
again and then iterate over all the
projects again here we only have one
project
give me the test task for that project
and for each test task I want to inject
the following behavior after a test is
run greater should give me the results
of the test then i can calculate the
time it took to execute them and if its
larger than 20 milliseconds i can issue
a warning so a couple of lines of code
let's see you see in real time you know
get the warning I mean a lot of stuff is
happening under the hood to test the
executed in a different virtual machine
and but you don't need to bother right
so um so this is just to show you how
how deep you can get into cradle to to
influence the behavior now let's do one
thing a final thing every cradle
distribution has an inner door d
directory which is empty by default and
we I can now go to my local creator
distribution and add an init script to
this in a dirty directory I can have
multiple init scripts in there obviously
I take the same init script that we were
using before that we injected explicitly
on the command line and now I can run
the built without injecting the init
script and now for every bill that is
run on that machine this init script is
applied you could now argue I don't want
that my developers you know screw up
with the local creator distribution
that's right but do you remember the
rapa you can now build you can now
assemble a creator distribution with
init scripts in the energy directory and
let the wrapper point to this
distribution then all of you developers
get a pre-configured create a built
environment where you can say hey this
is the repositories that are used what
whatever rules you're interested in
right so and so one of our goals is no
build wiki's right we have seen so many
crazy build wiki's for what developers
had to do to deal with the build system
completely insane right ridiculous they
have other stuff to do so that's one of
the goals of Gradle to make it really
easy for them right and and with with
with this pre-configured built a moment
that's really cool the inner script
injection also has its place so for
example sometimes people say oh cradle
is so flexible all the freedom to
developers have but this is the free
them for the build master to tailor the
rules of your organization so that the
developers don't need to to mess with
the build script so one thing you might
want to enforce is that all dependencies
all external dependencies should be
retrieved from your company repository
right so but you you only want to
enforce that on CI for the code that is
committed on the local bills developer
should be allowed to do whatever
experiments they want to do let's go to
this jboss snapshot repository or
whatnot you know there should be able to
do experiments but if they then commit
that code right you want to have an init
script that says that lets this bill
fail with an error message hey you're
using a repository for external
dependency that is not authorized again
with the abstractions it's a couple of
lines of code to do that you can say
headrail greater give me the
repositories container you go to the
repositories that are declared in that
build and you let the build fail if
there's anything in there you don't like
no no you can go to the dependencies
with your rules you can do whatever you
know you can go what the french academy
of language could say everyone gets
fired that is not using French words for
task names or you know so so there's
very powerful stuff in there to to to
keep the quality high and to make the
life of your developers easier and
they're usually happy to be informed
that the repository was accidentally
committed to version control right it's
not so much a friend of the handcuff
model I mean you can do it with Gradle
it's my rather a friend of you know
providing good options to be developer
then they then there any I don't want to
mess with the build but of course
different domains have also different
different requirements yeah you can you
can ever another thing you can have a
project specific rated properties file
which specifies the Java home that
you'll be used by the Gradle build
system itself which specifies a JVM arcs
of that project again no build wiki
where you have to tell your people set
to end ops to this value set may even up
to that value and it's
in control and it's project specific so
um so in that respect the whole the
whole declarative approach of Android is
is I think really leading the way that
can also be used in many other domains
we just came from a client with the old
massive software stack j java ee right
but they had a variant problem they had
they were doing software for for banks
and a payment management software and
they had their main software stack and
then they had certain variants for
websphere six zeros websphere seven
weblogic and so on and so on that
exactly the same problem as in the
android work right and they want to have
an easy solution because they built is
so complex that that would that hides
this complexity and makes it easy for
the developers to work with that another
key strategy of the android plug-in is
um deep IDE integration so yeah the Ides
were kind of forced in the past to be to
add a lot of functionality that actually
would be the job of the build system in
our opinion right so um so compiling the
code running the tests et cetera et
cetera you know during the decks thing
in the Android world so the Android
folks basically had to maintain to build
system Eclipse EDT and the end phase
build system and one major goal of the
new build system is that the IDE becomes
much thinner and for every build action
which is out to the build system for
compiling for dexing is that around it
has many advantages it's it so your IDE
feedback it's much closer to the
canonical bill to the sea i built and
when you have when your idea is doing
the stuff by themselves its performance
optimized because a lot of effort goes
into the performance at least that's the
end goal I can't claim right now that
the performance is perfect but that's
the end goal and we will get there you
have more automation so look look in the
Android world the testing is not just
simple unit
testing you have pretty complex test
fixture set up right and so sometimes
people had to go to the build wiki and
say if you want to execute the test from
the IDE you have to execute a particular
end tasks on a command line to set up
the test fixture and then you can run
your tasks from the IDE because the IDE
test Runner was not coupled with the
build system with the build system
direct deeply integrated with the idea
this is no longer necessary you know the
IDE will still eventually be able to do
provide the same nice visualization of
the test execution but the test
execution will be delegated to the build
system so all the test fixture setup is
autumn automated and things like that
you get the idea which and that is one
rule if it's hard to get feedback for
the developer day in ninety-eight
percent of the cases they say okay let's
get the feedback tomorrow so if you make
it hard they will get less feedback the
box will be discovered later and it
would be much more expensive unless the
application right from the built from
the IDE and build system offers point of
view okay so tool integration in the
first class grade of citizen so when I
des integrates with Grail or CI servers
we automatically deal with the
provisioning of the Creator distribution
we deal with backwards and forwards
compatibility issues we provide tailored
models for the IDE this is a kind of
cool feature in your built or cradle
script you can you can programmatically
change how a created project is mapped
for example to eclipse so let's say you
have a 3600 sub-module build if you
would import that into eclipse how long
would the Refresh take more than eight
hours I would assume so that doesn't fly
but the first case of Gradle would be
hey all all projects should be project
in Eclipse right and then you can say
all on cradle you know and then you can
get and so what greater does initially
it it has an internal Eclipse model it
models in Eclipse project
structure and populates it and then you
can say before you pass that model to
eclipse give me that model and you can
modify it and then it's passed on to
eclipse right so you have programmatic
control on how your creative projects
are mapped to eclipse or to IntelliJ or
to NetBeans by the way which has
excellent greater support the other nice
thing with with the Ides because there
are no those those nice models in Gradle
you could it would be a piece of cake to
write a drop-down menu with all the
different lists of test types you want
to execute just the IDE plugin with just
us a greater give me give me give me the
task for executing the test so you can
you can provide a much richer
visualization in the IDE because cradle
has a rich model in itself so the
project where this is implemented this
is Android studio it is still early
preview right so so a lot of the stuff
I'm talking about it's not done yet it's
it's usable right but the vision of this
you know very deep integration and you
you run the tests from the IDE and you
have this nice visualization that you
used to when running the test for me I
de this is still work in progress but we
work in full steam on that so we're
talking about months here to make this
better and better yeah so so yeah the
Android team switched from eclipse ADT
tooling or i should say they did not
fully switch they still provide eclipse
edited tooling but the major effort for
the new build system is now happening in
Android studio which is based on
IntelliJ I said and and there will be
Android studio which is again maintained
by the Android team but the same android
support you can also get into the normal
IntelliJ version if you're not just
doing Android development but
development for different platforms a
very interesting topic is deep sea I
integration so what what we are working
on with Jenkins is that you can when you
take greater this is an Android project
you can you will have a task to say hey
cradle
set up Jenkins and then a Jenkins jobs
are automatically set up right this is
not available yet but we're working on
that again customizable models you will
be able like you're able for Eclipse to
to influence Grail and how it sets up
the Jenkins shops and we will have
abstractions so that other see I servers
can only can also open into that so this
is this is work in progress okay so if
you want if you want to learn more about
the android build system you can go to
tools android tech talks new build
system it's pretty good documentation
it's been tempered by the by the Google
Android team you want to learn more
about great we'll go to greater load or
is it created conference in london on
october 26 you want to enjoy the weather
there and you can subscribe to a news
about cradle one of those URLs yeah
cradle where the company provides cradle
and cradle Android trainings we have a
creative training coming up beginning of
november just to apply at our booth you
get a discount um if you're interested
in that and create aware as a company
provide services all around cradle and
continuous delivery so so if any if you
have any questions if you need any help
for your Gradle build feel free to
contact us but but even if it's just not
just about greater but also if you're
wondering how should i set up my
continuous delivery pipeline which can
be quite challenging what our best
practice is in that domain we have a lot
of experience there we are involved in
some of the era dia largest software
stacks on the planet and so but also a
medium-sized office tech so we have with
yeah we have pretty unique experience in
that domain so feel free to contact us
and we are we're happy to help you any
questions we have five more minutes the
same was a one second before you are
sorry
hmm yep yep so the question was a his
company is using maven and they use
create they use maven to deploy
artifacts to a repository with the palm
and stuff like that so we are fully pom
compatible so you can produce come pumps
with greater you can consume pumps with
greater so you could do exactly the same
we also support a different metadata
format as an alternative which is the ID
XML format which is a little bit more
flexible so but if one of your teams
would switch to cradle the other teams
wouldn't would not notice it because
they would get the same artifacts and
the same palms but that's an interesting
point the pond map model is kind of
getting pushed to its limits when other
platforms try to user so now in the
Android world we now have not just group
artifact version we also have built type
and then how you say well how how can
you say in pom land oh please I'm know
in the debug context and when you're
using Android libraries for example give
me give me the debug version of that
library you see so there are some
challenges that will be hard to solve
with the palm but Gradle you can
customize the poem it's auto produced
it's perfectly compatible with that but
we're trying to push that to innovate in
that area let's not start talking about
C++ yeah yes but yes yes so it was an
int'l support it was sponsored by a
client but it was very rudimentary so
now in the over the last two releases we
working full steam on that and so it's
already much better at a couple of
performance improvement we still want to
do before we before we challenge the
large C++ software stacks to have a look
at that but that's just a question of
one or two months so it's definitely
worth a look and if you can come to our
booth and then we could send you a
presentation on a new CC + / staff or
what we're trying to do there a lot of
stuff is similar to Android you know you
have two variants in order different
platforms cross
from spilled and stuff like that just
even one one step more complex than them
with Android yes please can the android
plug-in be used for other brain works as
a project so for other non-android
projects yes yes so at the moment this
is an Android specific concept and
they're kind of leading away and we will
extract more and more of that and
putting it into a generic concept but
what you could do because it's not
rocket science to do so you could get
inspired and easily implement it for
your use case with Gradle it's not too
hard but we want to make it we want to
make this really a deep concept in
Gradle eventually runs out of variance
in particular when it comes to
dependency management but at least you
could look at the code right is open
source grade list by the way a petty
version to open source like Anton maven
and get inspired it's not that hard it
was another question a question yet
um oh no no no we're not thinking in
years haha things are happening fast so
I think quite a bit of this stuff is
pushed into the core by the c++ effort
and then it depends so I would be
interested in your requirements that i
could give you a more educated answer
yeah awesome i try to get people to the
booth no no it's seriously though yeah
okay any more questions yeah oh one more
so from from an end point of view no
because we can you reuse any anti us on
the planet so the wealth of n is still
in the task you know deploying to
websphere 40 from 1932 yes no in Gradle
it's it's nicer than from home than with
the build.xml you can import until two
ends and there's a first class citizen
in the greater world so with aunt their
only advantage to space so switching
from an to cradle it sounds may be
arrogant it's a no-brainer really
everything is faster better to maintain
and whatnot from maven maven still has a
bigger plug-in ecosystem the greater
plug-in ecosystem is decent they are
handled blast greater plugins out there
but there are certain tasks let's say I
don't know some exotic language where
there might be a maven plugin another
crater plugin no n/m doesn't end targets
and tasks yes maven plugins no because
they wouldn't reverse-engineer the maven
model to inject it you know it did we we
want to go down that route so you can
but but we are not quite there yet you
can convert your maven builds to cradle
we have some conversion script for that
but but the customary plugins are not
taking into consideration but again I
think I think it's usually not a big
deal so I've word migrated many maven
project to cradle and was there was
hardly any any significant pain involved
with that because the major platforms
are supported in cradle GWT or
exp or whatnot and at the end of the day
if not directly and greater you have an
aunt asked that mostly does it and then
it's really easy to wrap a greater
plug-in around that okay yeah thank you
very much obviously at all boo</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>