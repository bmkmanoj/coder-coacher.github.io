<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>From the Spring Framework to Java EE 7 | Coder Coacher - Coaching Coders</title><meta content="From the Spring Framework to Java EE 7 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>From the Spring Framework to Java EE 7</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QF-TVJa_DQw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this presentation is about migrating
from Spring Framework to Java EE 7 and
I'll start by introducing myself a
little bit my name is Eva I work as a
software architect at company called
Cybercom in Sweden were in the
consultant industry and I've been
working as a consultant for almost 15
years and I worked in the Java since
version monado and done everything from
Java ME to Android development and web
and and price but mostly I've been in
the web and enterprise domain and also
been using lots of other frameworks such
as spring which were going to talk about
today so how many of you guys were at
the last presentation whether you
precise it percent of spring for you
know today how many are all read likes
spring farms Kimbra brave and Java EE
here not so many ok should be careful
though well luckily I've read this
presentation
so saying that I'm not going to say that
one of the frameworks are better than
the other and I'm not going to mock
anybody in either direction I won't even
say that one of them rocks or the only
one sucks but everyone knows that Java
EE rocks and yeah you can fill in the
blanks yourself but what we will talk
about here today is a short feature
comparison of some selected features
that are present in both Spring
Framework and in Java EE and I'm going
to do that by migrating an application
that is fully spring over to a fully
Java EE application so we're going to do
it in code so what I'm going to do first
before we dive into the demo is to give
a little bit of background a little bit
of history and
go through some of the features of
spring and Java EE then I'm going to do
a comparison of them and I'm going to do
that by showing you the D code and doing
the migration step-by-step and going
from a spring application to a Java EE
application and I'm gonna highlight
differences and similarities and maybe
focus more on the similarities than the
differences and at the end I'll wrap up
with some lessons learned and a little
summary section so a little history
about these frameworks Java EE was
launched as literally as in 1998 and was
then called Java professional Edition
and but but it didn't really get
momentum before the launch this j2ee
at one at 0 and 99 but the platform
didn't get that kind of penetration
they're born and it didn't gain
popularity as much in the world and AJ
be for example got a very bad reputation
and it probably hasn't recovered from it
yet and the developer community and me
included were screaming for something
light or something easier something that
didn't need this huge container still
employee and this vendor specific
deployments of scriptures and you know
why should I have to write like for
classes or five classes and and a couple
of XML files just to deploy an EJB so
when rod rantin and in 2002 launched
Spring Framework in his book we were
kind of running for it of everybody here
and and even though in between before
the first milestone of Spring Framework
in 2004 job j2ee
104 came but it didn't really give us
anything more so it's kind of a dead
platform more or less when spring came
and
we started using that and the releases
of the two frameworks kind of followed
each other along the way
Java 5 was better but still not very
good and spring was always a step ahead
until this summer when Java EE 7 came
now suddenly we have Java EE 7 would you
have some features that spring doesn't
have yet a spring forest do I think it's
later this year but the zubur 2
presentation earlier probably not better
than me and spring for will support all
the features of Java 7 it will also
support Java 8 language features and but
it's not here yet so right now Java EE 7
is ahead of spring so if you look at the
characteristics of Spring Framework we
can say it's flexible you can run it
everywhere I mean have a dip in a
standalone application a web application
a mobile application everywhere so it's
a pretty flexible framework it's
lightweight and by lightweight I mean
it's not like waste in a sense of size
because spring is huge but it's
lightweight that it doesn't need to run
in a container it kind of has to contain
on with it a lot at all times and it's
very modular you can pick and choose
exactly the kind of functionality that
you need and it's extensible you can use
all java ee technologies with spring
I mean it's they're not really exclusive
in any way if we look at Java EE Java 7
has been thoroughly presented at this
conference and I'll just say a couple of
words about it the three focus areas of
Java 7 was developer productivity html5
and meeting and price demand and the
developer productivity part base that
it's more cohesive its integrated better
your CDI all over the platform across
the specifications and
it feels much easier to use and more
mature platform and we got html5
supports for for example WebSockets and
JSON processing and and JSF ones of
support session five features for the
enterprise we finally got the simplified
JMS api and batch who would thought of
that
running batch in a Java EE container I
mean it's pretty cool actually so I've
compiled a few of the features here this
is not complete that wouldn't have fit
in in this slide so it's just picked a
few of them and as I said earlier they
don't exclude each other you might very
well use jax-rs for spring or JSF for
spring and there are lots of more
persistence mechanism as in spring than
those to mention it here there are you
can use JPA or other or on frameworks
actually I can't like spring data but in
this demo I'm going to use JDBC
templates which is a more common newest
technology and in this demo I will focus
on the areas I have put it in the red
frame here and use a the the spring
specific stuff in the spring version of
the application and I migrated over to
the Java a specific of course I could
have years to Java EE technologies in
the spring application but then this
demo would have been pretty short so
I've chosen very carefully to to go with
pure spring to your pure Java EE and
WebSocket support will be in spring
floor so that completes the theory of
this session so let's look at the demo
I like cooking I like food so I thought
I'll make a real world application it's
a web UI and a REST API for an online
cookbook where I can store my recipes in
my cookbooks so let's have a look at the
simple UI it's it's not very advanced I
can list my recipes I can view them I
can edit them I can manage my users on
my cookbooks so it's not very advanced
UI I'm a service our developer and I'm
not very good at you alright but this is
very a very simple application it has
the credit capabilities and it also has
a pretty decent JSON API work and I can
for example see this was for one of them
and the same for the cookbooks sorry
and users so it's very simple and it
supports all it should be methods like
you created and edited or deleted the
data model of this demo application is
very simple I have my users the copic
users you can have several cookbooks and
a cookbooks contains of recipes it's not
that complicated
my demo application architecture is a
nice layered architecture it's pretty
common for this kind of solutions my
recipes are stored in a relational
database I have a persistence layer and
have managers which we will and
persisting my data and a service layer
that provides services that my REST API
and web you are at canoes and everything
runs in some kind of context so it's
pretty common way of building these kind
of applications if we're looking at this
specific version I'm using spring JDBC
as the persistence mechanism I'm all
written using plain old Java objects as
my services or spring beans and here's
the spring embassy for both the REST API
and the verb you are and everything is
running in the spring in Russian control
container so let's have a look at the
code
you say my pom-pom father it has a war
project it's alright even larger just a
second
it's better great so it's it's a simple
world project and we have a lot of
dependencies and that's pretty useful
for a spring project I'm not sure I'm
using all of this but it's probably
copied from some old project I used a
couple of years ago or something
but it's pretty usual project it's not
best practice in any way but it's the
kind of project you usually come across
when you see this stuff if you look at
the web.xml file we see that we have the
spring configuration and we're using the
spring MSE dispatcher to both the UI and
the API or look at the context receiver
that we use annotation configuration and
we have some transactions bundles just
text them in the UI and I have some been
defined and my dispatcher serve look for
the spring MVC is also have some
components cannon and Asian driven and a
couple of beams defines so it's nothing
not nothing special it's pretty normal
spring application so - so it's a web
application it's clearly based on Spring
Framework and its mix of XML and
annotations
yes no I'll show that later so what I'm
going to do now is step by step on I'll
get to that I would define the the rest
API and differ them first we're going to
add two Java EE and then since this is
Java is seven application I won't need
to add and be in sex multiple I could
have done it but I'm not going to do it
I usually say that the leader code is
your best code since it doesn't contain
any books but code that you haven't
written yet this even better if we can
avoid it and we don't take it with us
and then a layer four layer go through
and add the Java EE configuration were
needed and I'll add the Java annotations
remove the spring annotations and and
replace where I have spring specific
implementation with Java EE specific
employer implementation and then I'll
remove spring completely afterwards so
we start with the layer four layer work
through let's just start with adding
Java Eve and since I know that running
demos up here can be pretty scary but
very fingers and stuff prepared this
with updating formal version control so
what I wanted to do is just see her in
the dependency section that I'm going to
add Java EE so what I just did now was
to add Java EE as independent say I'm
keeping the spring the premises since I
want my creation to compile so the only
thing I do is to add Java EE and that
would make me able to use the Java EE
technologies and I can replace for
example at or wired and XML annotations
with our inject now since spring 3 you
can use our inject in spring as well
and spring will we'll treat it justice
or word but then again the demo would be
a bit short so so let's start with the
persistent layer and see what we can do
there first let's look at the energies
they are just simple Java objects I have
commented here that the recipes are
mapped by the cookbook and I have a
owner for the owner of the cookbook and
managing this in my data access objects
I feel look at one of the data SS of yet
it's an ad repository annotation which
is a specialization of spring component
and it extends an abstract JDBC de data
access object where the data source is
injected and it gives a spring JDBC
template to create the queries it's not
worried advanced and but it's a pretty
common way of doing this when you use
spring JDBC so if we add some JPI code
along with I'll show the similarities
and differences with it
so what we did here is that our entity
objects are no JPA entities I've added
the addint energy annotation to tell JP
this is in NJ and I've added annotations
for the relationships rather than
managing it in the data access objects
I also added the JPA closest error which
has a persistent context and it extends
an abstract API data access object which
is a general fide version and using the
criteria language so if we compare the
final method we see that here use a
select star from cookbook and in the
JPEG version we're saying select from
energy which is cookbook so it's pretty
much the same is just another way of
writing it and it's and the relationship
with the the recipes and owner is
handled by JP a and the annotations
rather than I have to do it
programmatically like you're I set the
owner
so what I did here was that replaced the
a quest or annotation and the JDBC
templates implementations of the data
access objects with my JPA classes I
fixed the under the objects and use
annotations for relationships and also
added a persistence XML file
it's just pretty simple I'm just
pointing out which states are someone
yes
so to recap this is the spring version
and this is JPA version it is pretty
attitude to make the conversion and it's
Meryl test taste what you like I kind of
prefer the JPEG which is clearer and
easier so let's move on to the service
layer
see her that my service classes in the
spring application are martes
transactional which is the spring
transactional attribute and should not
be confused with the job java
transactional and I've annotated it as a
service which is a specialization of
spring component and I'm all wiring in
the data access objects here and my
methods in the the beam experiment just
called the data access objects so it's
not nothing weird going on here so if
I'm converted this to the Java EE
counterpart
you see here I've chosen tears and EJB
and this is all I have to do - great
need to be I have a local state like
stateless session bean and well a kid
have used just a POJO here as well and
used the a transactional attribute but I
mean ejbs are so easy to use and for
this service I want to use a JB's and
I'm so happy that finally we can say
that well I like to work with a JB's
because you never could do that before
so I like this new and I'm using add
inject for the dead exes opiates rather
than the auto bird
so to recap I just replaced the
annotations on class level from service
and a transactional - at locals and at
stateless a kid obviously a
transactional here as well but then I
had to changed from the spring
transactional to the Java transactional
but EDA bees are called so stick with
that and the implantation is pretty
similar
so moving on to the rest API
another one so the recipe I are using
spring embassy to to map the resources
and it's easy I'm using the controller
annotation in spring embassy to say that
this is my control gloss and I'm using
the request mapping annotation to say
that I'm mapping to the recipes sub
resource which is this one
if you remember from the web.xml I'm
saying that API is handled by this
disposition of servlet so here I'm using
request mapping to define my rest
interface I'm saying that the finder
method takes a ID in the path variable
and that is the ID here let me see
nothing's gone away there it is and I'm
saying this is listening to an HTTP GET
method I'm just going to produce jason
and it's going to take the rest of the
recipe object and put it in a response
body so there are some special
annotations to to make this work and the
same way for for example creation I'm
saying that I'm mapping the it should be
post with the serious bug it should be
consumes but it consumes application
JSON and it takes recipe as the body of
the HP request and then it creates a
recipe and adds the location to the
great resource in the application error
so if I rewrite this to using plain
jax-rs
hundun here now is done Ted this class
rather than using yet controller and
request mapping I'm not saying that I'm
using the earth path which is a jax-rs
to say that the recipe says we're on
listening I'm injecting the EJB M and
I'm using the EJB a TGB injection if I
had used and pojo as my service I would
have just used our injector and also
injecting the euro info from the context
or show where our yourself later here
rather than having one annotation with
parameters like in spring I have
separate annotations for the HTTP method
the path and the JSON output and it's a
little bit difference that I can just
return a response object and have a bit
builder I put in the recipe that I've
selected from the database and it would
create the Jason for me looking at the
creation method is actually post and it
consumes application JSON and it has
taken a recipe object from the just body
and here I'm using the injected you Ryan
for to create the location in the header
and I have convenience methods to return
HTTP 201 which is created
well you also can notice here is that I
haven't done any changes to the web.xml
I could have done that but there's also
a feature in last wish that you can use
the programmatic approach and I say that
I'm using the /ip I established lost
Brewer my API years and also saying that
ammonia is the Jackson way of freezing
to Jason and my resource closest
so what what I've done here is I've
taken the add controller annotation from
spring MVC and replace it with that path
and taking the variations of request
mapping and response body request body
and path variable and a different spring
annotations and translating over to the
jax-rs counterpart now spring supports
jax-rs as well but then again the demo
would have been short so and this is a
way that it can be different than it has
to be different and somebody has chosen
that it should be different yes a
question okay the question was in what
scenario would I suggest to migrate from
spring to jail Jovie and that's a good
question analyze the rate later and when
we saw much after the demo I'm not
touching input into that right now so
yeah so the spring MVC version of the
jacks are the rests resource looks like
this and the jax-rs counterpart it's
like this so it's not that different is
just another way of using the
annotations to get what you want
so moving on to the web UI
what you can see here is that I'm using
plain jsps and I'm using the the spring
message tag lib to get the translations
from a translation file and these are
defined in my application context and
I'm also getting my users from the model
in the spring embassy which I'm showing
here so when I handle the different
request mappings from for the the UI
which is a different mapping than than
the API part I add what is needed by the
UI to the model of view object in the
spring MVC framework and in analyst for
me anok nice access from the J's base
so if we put some jelly version here
what happened here is that rewrote the
controller to using the Java EE
annotations at named so I would be able
to use access the methods in the
expression language in the JSF pages and
I'm also injecting the EJB and the rest
this code to support the UI if you look
at the exceptional files here I'm
accessing my translations from my bundle
which is defined in the face config file
and it's the same set of translations as
I used for the spring version of the
application difference here is that I
actually have code completion and also
have completions for methods on the
controller and of course here I can add
all kinds of cool and fancy component
libraries such as primefaces and etc but
here I'm using just standard JSF
so what I did here was to replace the
jsps with XHTML and this is kind of a
more rewrite than for example the
service layer but it's pretty sit
transferable for a if you know both JSP
and XHTML and you can more or less just
copy it over and the I'm not sure that
the HTML I'm producing is the same I've
chanted controllers from using the F
controller of the spring MVC framework
and yet requests mapping to map to the
pages using F named so I can use it in
the Joseph pages the controller has
changed for something looking like this
to this and I changed from using the
translations defined in the application
context which is accessible via the
spring message tag Lib tiers and it
defined in my faces config file and
recognizes it with expression language
so now we're gone through all the layers
and I'm ready to remove all spring
configuration from my application so
what I'm going to do them is to remove
all the configuration files and clear up
the dependencies in the pom file
what happened here is that the own
depends the left is the Java ear
dependency that's pretty neat and also
in my web and folder all the spraining
xml configuration files disappeared and
the only files left is my WebEx model
which is no point mocked in my face a
servlet and I have a face a
configuration which is my translations
and this just my template file which is
the immoralist the header and footer
area sides
so if I restart GlassFish
and also remove the JSP file so the only
thing left here is the joseph port I'm
using the same statutes as I did for the
juice the version
so look at the Russian now looks exactly
the same only they're amusing the jsf
portion is exactly the same
functionality as I did with the spring
version and Jason API is exactly the
same
so what I did here was to go from an
application using spring young receive
for the REST API spring embassy for the
UI having pojos in the service layer and
spring JDBC that's the persistent
mechanism and I change it to using Java
EE technologies that is jax-rs for the
rest api JSF for the UI eg base for the
service layer which could have been
pulled over one hundred and JPA for the
persistence mechanism and all wired
together with CDI way so what I did to
come here was that added Java EE as a
dependency I could have added beans XML
file and if you want to run in in the
Java EE 6 6 container you need to add it
but in Java EE 7 you don't need it
anymore and layer for layer I added the
specific configuration for Java EE which
is I modified the web.xml file I had to
persist in external file added I faced
config.xml and I replaced the spring
annotations with the Java EE
counterparts and then I switched from
using the XML and all word in spring to
the CDI version in Java EE and then
finally I removed spring the premises
and spring configuration now what I did
was to go for something looking likely
this is something looking like this and
I don't know which one you like better
but I kind of prefer this moment and if
you're if size matters
I went from something that was seven
point nine megabytes in size to four
nine case it's significant smaller
unknown
don't know if it matters but somebody
thinks that since container is there and
maybe I should use it
yeah this is this is a Java EE version
the size of the war file produced and
this is the war file produced my spring
and spring virus all the libraries
the question is what about security and
that spring security has great support
for it and what is support in Java EE
and yes there is support in Java you can
use container manage security to secure
your web resources and in the eg base
you can use blank Java security so so
yeah I'm gonna you can define your own
role so you can do think code or
configuration and however you like it
including security I have done it in on
client projects but this is a pet
project I created so if we moving on we
can take your questions as to at the end
as well
what about testing so Spring Framework
has good support for testing and there
are no direct support in testing in Java
EE but maybe it's not needed I don't
know because there are tools like alien
that you can use which are excellent
there are other tools so the tooling is
there and so testing is no reason why
you shouldn't migrate what I haven't
covered here is I haven't covered
security I haven't covered the
simplified JMS API or the web sockets or
a JSON processing or the batch API that
would have to be for a later location so
why should you migrate and here comes
your question
spring is a proprietary framework Java
EE is a standard and if you're running
in a Java EE container
there's no reason why you shouldn't use
it so like you like yeah I mean you have
everything available there all the
services the commander provides and is
still wrap it in your own container and
deploy it on the same machine it doesn't
make sense to me actually so the other
side of question is once you did not
migrate and I would say you shouldn't
migrate if your vigor into a platform
that is prior to Java EE 6 so any other
container you're running in that is
prior to Java 6 probably a stick with
spring and of course you should always
listen to your developers if your
developers are spring experts and are
you have a community at work that you're
using spring and you're heavily used
spring in your project you should stick
with it because it's at the end is
always that the developers are going to
write your code anyway so if you switch
to a framework that they are not happy
with you're going to get problems anyway
and if you're using heavily AOP or other
spring technologies that are not covered
by Java 7
then you should stick with spring so
what the lessons learned migration
doesn't have to be very hard but it
depends very much on how your
application is structured and migrating
from a newer version of spring is easier
than migrating from an old one because
there are more similar and as I said not
all applications can be migrated you
have to take it case by case and the
more you use the advanced features of
spring the more difficult it is to
migrate
so to wrap up a little bit I say it
they're both both excellent
technologists the great frameworks and
what you choose is more or less a matter
of taste and but if you're running in a
Java EE 6 or 7 container you should
definitely go with the Java EE because
Java 7 really rocks so that was all of
us
preparing for today so I say thank you
for listening and I hope you enjoy it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>