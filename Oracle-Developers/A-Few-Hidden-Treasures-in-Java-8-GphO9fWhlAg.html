<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Few Hidden Treasures in Java 8 | Coder Coacher - Coaching Coders</title><meta content="A Few Hidden Treasures in Java 8 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Few Hidden Treasures in Java 8</b></h2><h5 class="post__date">2016-09-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GphO9fWhlAg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright let's get started welcome to the
session on a few hidden treasures in
Java 8 my name is Venkat Subramanyam I
want to talk about things that are
pretty powerful available in Java 8
things that may not be something we run
into right off the bat we talk about
lambdas often we talk about streams
pretty quickly but some of these things
we're going to talk about today are
things I've found to be extremely
valuable and very useful in working with
Java itself so I want to touch upon a
few interesting things and in some of
the cases you may explore things that
you probably have not seen in other
cases you may be exploring something a
little deeper than what you may have
seen as well oh it could be a good
refresher also best time to ask
questions or make comments is when you
have it so if you do have a question or
a comment draw my attention I would be
delighted to listen to you so let's get
started well one of the really cool
things about Java 8 is Java it gives us
the ability to do a functional style of
programming which means we can use
lambda expressions we can use streams
and we can build applications with a
combination of these capabilities
higher-order functions and building
function pipeline employing lays
evaluation all those good stuff but
going a little beyond that there are
quite a number of interesting things we
can do some of them related to lambda
expressions some of them related to
streams but other things maybe a little
bit off to support some of these
operations as well so let's talk about
one thing and I'm going to start with a
little example to begin with to see what
this is going to provide for us so let's
start with a little example here let's
say we have a list of names to begin
with so I want to say names over here
and let's say this is going to be a
raised dart as list and let's say this
is going to be a few people here let's
say there's Tom there's Jerry and then
of course let's say there is Jane so a
couple of names so let's say the problem
given to us is is very simple and the
problem is they tell us to you know
print the names so I'm going to say
print the names and we're going to say
in uppercase and then we will say comma
separated
a problem I'm sure every one of us has
you know seen from time to time so what
would we do we could say for a string
name and then we could say for example
names and then we could do something
along the lines of output name dot
something like to uppercase that would
be a good starting point so we could run
that well yeah that's great but wait a
minute we really want them to be comma
separated in uppercase okay that can be
arranged so we can put a little comma
and we can run it well but we want us to
be really comma separated obviously that
means it should be that way so we could
do that as well but then once we do that
we realize while it worked really well
there's a stupid comma in the end
anybody who has seen this problem before
yeah how did he feel that night terrible
isn't it you sat there and said this
cannot be happening to me right because
how do you get rid of the comma from the
very end I know you came up with some
really creative ideas you said I'll
create the stupid string and I will
strip out that comma oh darn it string
is immutable and then you reached out to
string builder that only took you down
the path you didn't want to go and you
struggle for a while and you said this
has got to be simple all right and then
eventually you find out there is a very
simple solution how do you not think of
it so all you have to do to solve this
particular problem is you don't have to
work that hard you have to simply say
for I int I equal to 0 and then I less
than and the name start is it length or
is it size or is it count well it's a
length of it's an array but there's a
list so it's got to be a size and then
is it less than or less than or equal to
I think it should be less than okay and
then I plus plus and then you had to
simply say output in this case and then
you would say print again this would be
names but this time it should be get off
I because you got to get the value out
of it and then of course you have to say
after this you have to say output and
then you are going to put a little comma
but you're going to only put this if I
use it I mean are you kidding me
right so you finish all this and
when you finish this you would never
ever tell anybody what you do for a
living right and in anybody who works
from home a few of us right if you're
doing this if a kid walks in you
immediately close the laptop right
because if they see this they look at
you and say that's what you do for a
living right and they never want us to
be doing code like this so this is
incredibly complex and gets dragged in
and by the time we are done with it
you're like gosh why did this take so
much effort and we think that something
is wrong with us well the problem here
is a pure abstraction this is an
imperative style of coding and
imperative style just sucks you in the
more you do it wants more more from you
and it just keeps on going so let's
break the cycle and see how we can do
this in more of a decorative start so
rather than that mess let's start with
output what I would have relief already
and then we will say name start stream
and then we will say perform a map
operation and in this case we'll say
string to uppercase and we are
converting this to an uppercase already
well that's great so far but what do you
want to do next then we're going to do a
collect but in this case once we collect
the data but to work so we're going to
go ahead and include right here would
say static and one of the classes you're
going to be running into collectors is
something it's it's a good idea to spend
maybe an hour or two on a on a nice
Friday night it's a great time to spend
some time on a jdk libraries right and
just go over the methods available in
the collectors a utility class it's a
good thing to look at what they provide
and one of the things they provide is a
function called joining and so you can
simply say I want to collect them all
together but by joining these things
well the join function is available in
multiple different languages and Java
provides one but I'll tell you this for
sure the day that I first learnt about
something like joining I cried that
night right I mean this is the way life
should be in programming not being
dragged into the ceremony and things we
have to do so you can see how simple
that is compared to all the thing we had
to do and and one of the things to
consider is how do you get rid of the
ceremony how do you get rid of the
dancing around that you have to do with
all these languages and abstraction but
to get straight to something a little
declarative so if you look at the
collect method the collect method takes
a little object that you provide an
interface that can decorate and provide
certain conversions if you will there
are quite a wealthy of number of things
you provide to the collect method
joining is just one of them that you see
here in this example so the beauty of
this is you can join variety of things
from a stream and it doesn't put that
into the end or the beginning it only
concatenates the middle elements but
this could be like a class pad you want
to concatenate for example if you want
to build a class path of things or a
directory hierarchy or whatever that you
want to build you can use it for a
variety of purposes not just to calm I
could be anything you want to build with
so this becomes very very compelling so
one of the things to think about when it
comes to the functional style of
programming is you want to produce a
result which is an accumulation or a
collection of transformation of multiple
data this often is called a reduce
operation so one of the things we need
to do as we begin to program in
functional style is to take the problem
and see how we could translate it into a
reduce operation in the end so we can
formulate it so in this case the collect
is just reducing it but using join as a
flavor in in that reduction that we saw
just now so that is one thing the
joining function but we will look at a
few more functions we can use along with
collect in just a little bit well one of
the other things I want to talk about is
static interface methods and I remember
very well looking at the very first
static method and I told myself gosh I
hate it and I worked with it for an hour
and I found myself saying oh I love it
I don't think I've ever gone from ahead
to love in such a short amount of time
ever in my life so this is something you
get to really
begin to appreciate quite a bit so let's
think about this for a minute let's go
back to good old Java Java seven and
before so I have a method I want to use
on different collections well where
would I find those methods well of
course in the collections utility well I
wanted write a few things based on an
array where would I go for it of course
in the arrays utility
well when Java eight was being created
in the first few months of Java they
kept that tradition we call that legacy
isn't it so they kind of said this is
what we did before we're gonna do it now
thank God somebody got since finally and
they said wait a minute we're going to
just create a parallel hierarchy and
this is going to just explode in front
of us can you imagine having 100
interfaces and 100 classes to go with
interfaces now and and every time you
want to use one of them in the interface
you're going to write a class name with
the letter ending s after it and it kind
of begins to be located the bird and it
becomes heavy after a while and they
said how could we remove this burden and
then they said wait a minute
if this method is so closely working
with this interface why not just put the
darn thing in the interface and and so
at the first start
it looks really strange that an
interface would have a have a method
right well a static method but once you
begin to use it it becomes a easy reach
where you're going to go get it it
becomes a lot a little bit more
intuitive well we'll come to life a
little bit later but let me start with a
little example to show you how this
actually works so in this case what I'm
going to do is I'm going to create an
interface umm so in the interface so
just as a quick side note I'm a huge fan
of test-driven development and I'm one
of those few guys who really cares about
a very high code coverage and I don't
want to ever spend my time looking at a
code coverage and saying it's okay for
this to be read that's a waste of time
for me I don't have the patience to
examine what is right and what is not
wrong
give me a good coverage and we are done
have to look at it well I had a class
which only had static methods and the
stupid code coverage tells me that the
constructor is not covered and I was
like sitting there scratching my head
and all of us and I said wait I can
convert the class to a interface because
if it after all only has static methods
why do I care about a class I was happy
the coverage report was happy so you
know kind of we can figure out some of
these things also moving forward so in
this case I'm going to write an
interface called that you tell that's
what I've written right here and what am
I going to do within this I'm going to
write the method this method is going to
be a method called let's say Y nth
number of up you know let's call it as
course so my method number of course
says return a runtime dot get runtime
and then dot in this case dart available
processors so so that's what I'm going
to write over here for this particular
method so I just wrote I could call it
directly but I wanted to show you a
static method so in this case I can
simply output util dot number of course
and I can simply call it directly that's
a lie by the way I don't have eight
course but anyways you can see that it
actually is a static method that we are
actually calling on this so interfaces
can have static methods if you're not
really comfortable with it just kind of
keep going and eventually you know you
will be ok with it
if you're still troubled by it I have a
solution for it get over it
so the point really is it just kind of
works really well and you can work with
it over time well we saw what an
interface what an interface can have a
static method but this gets a little bit
more interesting with default methods
there's really nothing has really
nothing to do directly with lambdas are
streams but it's a Java eight feature I
begin to really appreciate over time so
what is a default method well most of us
can agree we are smarter today than we
were yesterday and I can definitely
agree that I'm a little bit more smarter
today than I was 20 years ago well the
folks who wrote Java would like to think
the same well they created these
interfaces 20
years ago and what happens to an
interface well the minute you create an
interface and publish it you cannot
change it anymore even the thought of
changing it is an invitation to death
threats right people get very angry at
you because you're going to change the
interface now the code won't compile
anymore they got to go back and fix it
so they were kind of stuck with these
interfaces so they were desperately
looking for a way to modify interfaces
well on one hand they couldn't change
the interface on the other hand you
really need to be able to change it so
default methods nicely give an escaped
class default methods are
implementations of the methods that he
can put into interfaces so interfaces
now can have method implementations as
long as you can mark them as default
well I was mentioning the Seneca in a
conference there was a lady in the
middle of the room and she was
absolutely phenomenal she didn't speak
at all all she did when I started
talking about default method says she
took her hands and she did this to me
like this a few times and then kind of
smiled at me I said ah the diamond lady
I called her well she wanted to point
out the diamond problem well if you have
heard of diamond diamond problem it's
not really fun so the diamond problem is
you have a class that inherits from the
base class this goes back to the days of
C++ well you have a class that inherits
from two base classes so you got this
thing right now well these two base
classes now inherit from their own base
classes so it kind of becomes that right
now but obviously if the two classes are
exactly the same you want to bring them
together this is called the diamond
problem and because you're bringing them
together but why are you bringing them
together well because it's common stayed
in there so you got to bring them
together otherwise you've got to
duplicate it state it's a mess to deal
with
well C++ programmers use what are called
virtual base classes and it doesn't work
really well because you have to mark
these classes as virtual base classes at
the beginning and it's a mess
so Java looked at the C++ programmers
and said you guys really have trouble
with multiple inheritance don't you and
they all said oh it's terrible and Java
said don't worry we fixed it no multiple
inheritance for you right so that is
called run away from real problem kind
of pattern so it didn't solve the
problem it said don't do it right well
that worked really well but the problem
in this case is what do you deal with
how do you deal with the diamond problem
that was the lady's question when she
did this what about the diamond problem
well here comes the charming reason the
reason you are interested in the diamond
problem in the first place is that you
have a common state in the top well
guess what interfaces cannot have state
and when you don't have a state you
never have to worry about it by the way
state and dealing with the state or
messing with the state is a problem
everywhere in programming and in
politics so state is always a problem
right so the fact that interfaces don't
have a state you never have to merge
them together so you don't have the
diamond problem at all so that's great
news one good news but how does this
really help us well to understand this
let's take a little example and play
with it so what I want to do in this
example is I want to start with a little
interface to begin with so my interface
is called the fly interface and the fly
interface contains one method I'm going
to say in this case let's say call this
as void and we'll call it as take off
and that's my first method so I also
have a few other methods I've got to
have another method here called a turn a
third method called cruise and finally a
method called Lent and I want to know if
everything is going well so I'll just
put ok here to know it is ok
but what I'm going to do now is I'm
going to go back to this code and I'm
going to say for each of these methods
output and I'm going to say take off and
in this case of course I'm going to say
turn and here I'm going to say cruise
and then finally I'm going to say land
over here and these are the methods on
the fly interface I'm going to call it
that way well obviously the minute I do
this you know what's going to happen
Java says are you out of your mind you
cannot have implementation
within classes so why not well obviously
because you know interfaces in Java
cannot have implementations at least
until Java 7 so what is an interface in
Java so here is my definition of an
interface and interface is something
that says a lot about what it'll do but
it never does anything kind of like my
boss right so as a result the interface
is kind of there doing nothing well but
in this case of course we are saying hey
interface not only do you have methods
but I want you to implement some in Opa
details in it and Java sees you can't do
it well what you can do now is you can
take these methods and notice it didn't
work it complained about it but what I'm
going to do is simply say default on it
and execute it and Java is so happy now
because you mark each of them as default
methods so that is the question what
does this mean really to us well the
very first thing is the interfaces
cannot have state but interfaces can
have method implementation so this is a
pattern I want you to think about
because I really like this pattern now
obviously if an interface cannot have
state but it can have methods in it gosh
how much can you really do in these
methods without really having state
because if you're never going to have a
state duh why don't you make it a static
method why would you not want to have it
as a static why would you have it as a
default so that's a little puzzling well
this is a very beautiful pattern so what
you do here is if you want the state you
can do a get state obviously call it get
state but you can call it whatever you
want to call it get property and then
you can have a non default method let's
say get State for example that will be
implemented by a derived class so the
beauty is it's kind of like your factory
method pattern isn't it so you provide a
common implementation in the interface
but anything that is specific to the
class gets overridden in the class so
this is a beautiful pattern to follow
and so when you start using default
methods with interfaces eventually you
will start doing this it'll drive you in
that direction and you begin to
appreciate
beautifully you can put common stuff in
the interface but he can start putting
state specific details in the classes
that implement that interface flows
really well as you can see okay that's
great so far so we can have default
methods in the interfaces but I want to
then go to how we deal with interfaces
so interfaces cannot have state they can
have implementation of the methods so
because they cannot have state a lot of
times people ask hey if if you can put
implementation in an interface or does
it mean abstract base classes are the
same as interfaces how do you go about
it
well the golden rule that interfaces are
better than abstract classes is still
true secondly you can put fields in
abstract base classes
you cannot put fields in interfaces you
can only extend from one abstract base
class you can X implement any number of
interfaces so interfaces still are
superior compared to abstract base
classes but having said that I want to
talk about four rules of default methods
so what are these four rules of default
methods to understand the four rules
let's go through each one of them the
first rule is you get what is in the in
the base interface so if there's a
default method in the base interface you
get it and it is available to you so to
prove this point let's go write a few
things here so I'm going to create
another interface called fast fly which
implements in this case the interface
called fly and I don't have anything
right now in here then I'm going to
create a class and the class is going to
be called seaplane and the seaplane
implements in this case the fast fly and
you probably noticed this should be
extends of course so this is going to be
fast fly and again I don't have anything
in the sea plane right now so don't
worry about it at the moment so what I'm
going to do here is to call the use
method on the samples a new sample dot
use let's go to the use method so public
avoid use and within the use method I'm
going to say seaplane
in seaplane is equal to new seaplane and
seaplane dot a fly sorry turn or take
off and I'm going to call the takeoff
method in the seaplane so that's all I'm
doing
did I remove not remove the gate state
okay there we go I told you state is
always a problem okay so let's go ahead
and run this so right there you can see
the take-off appearing really nicely
this proves the point number one isn't
it if there's a default method in your
base somewhere you get it for free you
don't have to do anything
so seaplane Dart turn and then see plain
dark a cruise and then finally of course
you're going to say seaplane dot what
was the last one land so so that's
basically all the format that you get
for free by using the inheritance
hierarchy that's rule number one
rule number two says you may override a
default method so you can override it
you're at freedom to do it so notice
what I'll do here I'll go to the fast
fly interface and I would say in this
case over here let's go ahead and write
a pod on me I'm going to say default and
I'm going to say default what void they
at take off and I'm going to output here
we'll say fast fly take off so when I
run the code notice it ended up calling
the fast flight take off because that's
your nearest implementation and then if
you don't have one
it goes to the one in the base so that
seems to make sense also really well all
this is great so far but then comes a
third feature or a third rule that is
pretty important and useful as well and
that is if a method is there in the
class hierarchy then so if I know how to
type hierarchy then it takes a
precedence so that is a rule we have to
be very careful about so what does that
mean it says eat good that's your class
of a method that's your class's base
class have a method that's your classes
based classes base class grandfather
class all
way up to object in the class hierarchy
does the method exist
oh yes it exists way up there well use
that it doesn't matter you have a nearby
default method so it doesn't matter how
many default methods are close to you
from the derived you always go walk up
the hierarchy of classes if you don't
find them from your class all the way to
object then you go to the interface so
quick quiz be what - string method you
think will be used definitely not a
default method right because if you
don't have one it's going to pick it up
from the base all the way to the object
right that's a way to think about it
well that's the rule so to understand
this rule let's go extend this example
so class vehicle and I'm going to say in
in this case public void land and I'm
going to simply say output and this is
going to be a vehicle land so great so
far now what am I going to do I'm going
to say extends so extends a vehicle and
implements fly so when I run this notice
the rule number three as you would see
it got the rule of value from let me try
to move this around there we go so it
got the object from the method from the
vehicle because see plane doesn't have
it but vehicle as it I'm sorry I don't
care that one of my interfaces have it I
pick it up from the from the from the
class so far so good
well now comes the fourth rule the
fourth rule is if there is no method on
any of the classes in the hierarchy but
two of your interfaces that you
implement uh has the default method
obviously in this case we are talking
about the method with the same name in
the same signature so the question is
you don't have Rule three to kick in at
this point but two of your interfaces
have the interface so in other words
there is a collision Java solves this in
the most elegant manner
it says it's your problem so essentially
it says you got into this mess go deal
with it so you have to fix it so to
solve this use Rule three right so
that's basically the answer so if you
get into this ambiguity you got to go
fix it and you use Rule three to solve
rule number four so to understand this
let's take a little example here so what
I'm going to do now is I'm going to
introduce a new interface so the
interface I'm going to introduce right
here is called let's call it a whatever
what do I call it a Cruz interface well
let's call it a sail interface how about
that and the sail interface has a method
called cruise and this is going to
simply say output sail : : Cruise and
let's make this as a default method so
far so good isn't it no problem but I'm
going to introduce the ambiguity by
saying implements fast fly and bring in
the sail into the mix now what happened
notice it says seaplane inherits from
unrelated default cruise and then from
fly and sail so you have a conflict at
hand so what do you do to resolve this
conflict well you know that if this
method exists in the class hierarchy it
doesn't go to the method in the
interface so very easy to solve it so
what we're going to do now is to go back
here and say well public void cruise and
here I'm going to simply say seaplane :
: Cruise and you can see that it's
picking up the seaplane cruise but wait
a minute though I really wanted to use
one or the other or the boat so how do
we do it well actually pretty darn
simple you say fast fly Dart super dot
and then you say cruise and that's how
you can call the base method hey wait a
minute why didn't I say fast flight
crews and I had to say fast flight art
super dart cruise because it needs to
know whether you're calling a static
method or a default method if you don't
put the word super it looks
for a static method if you put the word
super it looks for a default method
whether the other one exists or not
doesn't matter so that shows you how we
can work with default methods and how we
can implement it so interfaces have
default methods now well you're going to
be looking at existing interfaces a lot
of existing interfaces now have default
methods which is a bit of a challenge
for us as programmers you may have
worked with this interface for a decade
but all of a sudden your interfaces are
no longer the same right once upon a
time they could wake you up at 3:00 in
the morning and you can recite the
methods with signature and go back to
sleep now you don't know that there are
a few methods you've got to relearn it
which is absolutely wonderful people in
this room otherwise you wouldn't be here
but there are other people who are you
know semi-retired as Java programmers
they find it extremely angry right
so but that's the beauty is it's evolved
quite a bit it's a nice makeover of the
language so that is the default method
happy so far so that's basically how
they default methods work but we're
going to see these things begin to shine
out as we go along and do stuff moving
forward so for that I want to start with
a little example of working with
collections of objects so we're going to
get back into the territory of
functional style of programming and see
some of the beautiful things we can do
here but for that I want to work with a
little example that we can play with so
to do this let's take a little example
here of will call it as create person so
this create person function you see here
is going to create a bunch of people I
want you to quickly notice scan through
this there are a few people with the
same name like Sarah Sarah and Jack and
Jack there are a few people with the
same gender a few male and a few female
there are also few people with exactly
the same age as well two or three people
with age 20 and a few people with the
age well 32 so there is a bit of overlap
of things here intentionally created but
what I want to do really here is to sort
these people so what am I going to do to
sort these people so here's my first
attempt I'm going to say a collection
start sort and then I'm going to say
people and where in the world is this
people
I'm going to simply say list person
people equals create people and I'm
going to then sort it now question for
you this one called right here it's a
good method it's a bad method it's an
evil method what do you think I like you
all it's an evil method now why is it
evil it's evil for two reasons it is
intrusive it wants the person class to
implement a comparator interface right
the comparable interface
well that's intrusive second what does
it do it does crime punishable under law
you give it the data structure
collection and it changed it how bear
right you can say look what you did to
the collection I put this all together
damn you you changed it right well of
course the question is if it is so evil
why did they do it I know one reason why
they did it they were young and they
needed the money right so imagine the
time when Java was introduced Joe was
introduced when the major competition
was C++ and do you remember what C++ is
C++ was C++ is a jungle there is no more
reality there is no ethics does it run
fast
hey is it correct who cares does it run
fast so as a result they had to compete
with that kind of performance now we
know those are not our pressures the
world is different place than it used to
be 20 years ago I call this the politics
of programming languages so when I
sympathize greatly with language
designers because they have to not only
work with the word language constraints
but the other ecosystems and other
environments and the pressures as well
become really influential well that's
great so far but given this we don't
want to go into this evil path what can
we do well thankfully we can do this in
a lot better way than we would otherwise
do well to understand this I'm going to
create a public static void print sorted
I'm just going to make my life a little
easier here and I'm going to say people
but I'm going to then pass to it a
second parameter it's called a compare
tour on the person will call it
comparator so let's go
head and bring that in here well the
comparator is already there that's good
so we brought in the comparator into the
into the mix so now that we have that in
here what do I want to do well I'm going
to say in this case a people dot stream
and in this case I'm going to simply say
dart sword head and then we will simply
say the comparator
I'll pass to it and then for each and we
will say system dot out and we will do
print illan so you can see in this case
we're going to sort it and then we're
going to print it we didn't quite tell
it how to do the sorting but whatever
the sorting is given based on the
comparator I'll do the sorting and print
it well this makes for a very powerful
combination of things so notice what I
can do here now I can simply say print
sorted and then I can pass the people
here but I can simply say compare ring
and what am I going to compare a width
so I'm going to say comparing and this
is going to be a person and then we will
say get name is what I want to pass to
it well the very first question is what
in the world is this comparing come from
well that is the beauty if you go back
here you can say import static Java dot
util dot comparator dart comparing and
then you can bring that comparing
function in here so once you bring these
methods in this in this particular case
you can see that it took our collection
but it sorted the collection based on
the name so you got Bob at the top the
jacks after there Jill and Paulo all the
way down to Sarah after that so we
compared by using the comparing pardon
me I need to show you the code in the
bottom and we're just calling the
comparing to use the comparison so you
can see how the code is so beautifully
fluent so what is comparing actually do
comparing this a static method that
actually takes a function as a parameter
and then it returns a comparator as a
result well you can clearly see from
this example that prints sorted second
parameter is the comparator so clearly
comparing is
turning a comparator but what is
comparator take as a parameter it takes
a function as a parameter because it's a
function functions the functional
interface we can pass a lambda
expression or in this case we pass the
method reference to it well that's great
so far we sorted based on the name
awesome but let's go a little bit
further I don't want to sort it based on
the name I want to sort it based on the
age so to do this what I'm going to do
here is called prints sorted pass people
to it comparing and look at the power of
this person get age so now I'm comparing
based on the age value rather than
comparing them based on the on the let
me get this down here so based on the
age versus based on the name well this
worked really well the kid Oh jack is at
the top the yellow jack is in the bottom
and everybody else in the middle but
unfortunately I got word that at least
one person is very upset currently and
that is of course Bob Bob says not fair
I am twenty Sarah is twenty how come
that in this case where's Bob Bob is
below Sarah right so Bob is pretty darn
upset there are two ways to fix it one
way to fix it as we can tell Bob Bob
want to grow up right so that will fix
it most likely on the other hand you
could say fair enough we really have to
honor the lexical scoping like a lexical
ordering so yes if the age is the same
we got order by the name that's only
fair right so what do we do well looks
like it's actually pretty easy to do so
what I'm going to do now is I'm going to
say comparing and then I'm going to say
then comparing and then of course you
say person get name and you do the
comparison it almost sounds like fiction
isn't it when you're writing this right
it's like he's a true are you kidding me
it's like no it is true you can see
there's a proof in the pudding the code
actually works and Bob is smiling as you
can see so we can actually compare based
on the age and then
period so you can see here's a quick
quiz where that what kind of method is
comparing it's a static method from the
comparator then comes the question what
can a method is then comparing yes sir
yes I'll come back to that in one minute
I can only handle one thread right now
so so what is the then comparing what
kind of method that is default method
and to back back to your question which
I kind of buffered away is reversed so
you can call the reversed on it and
switch the ordering as well that would
be just a further call and that just
flows through and combines it forward so
I'm going to just do the reverse right
here so you can say do reversed and you
can do the reverse operation and then of
course you can combine you know move
these and back and forth and you can do
whatever operations you want to perform
so depending on that you can decide
where to put that so so very powerful
set of combinations of things you can
put into this to make this happen as you
can see so we can see already the static
method to the default method shine here
in this example already so it becomes so
natural you may not even stop to think
that these are static methods and
default methods which is the point
really right it should become really
second nature for us to use and they
should just kind of go in the background
and we should be really happy using it
so that's basically what we saw here but
there's a little bit more you can do as
well so for example in this case you
have a list of people on your hand but
what I really want to do is taking these
people I want to group these people
based on their age so if they're ages
there are two people with the same age
put them together well how do I really
group them for age so what you can do is
you can say output for example and then
you can say people dot stream and then
you can call a collect method well there
comes the collect one more time and you
can call the collect but this time
though I'm going to go ahead and bring
in a static and then we are going to say
a stream a dart compare tour sorry of
collections and remember we saw this
earlier with the joining method
so collections is going to have a sorry
a collectors rather so collectors is
going to have a few interesting methods
that you can actually use and one of
them here is the grouping by method you
can use so you say grouping by and then
you specify what you want to group on
just a function this is what I really
like about it is that it is extremely
intuitive because the code begins to
read in a way it makes sense so you can
see that Paul and Paul both are Paula
and Paul pardon me are thirty two years
old so they are grouped together Jack
and the other Jack are grouped together
as you can see and the list goes on and
and follows out of the monitor so you
can see how two is one jack thirty two
is to Paul Paul and Paula well that's
great but I don't care about their names
I don't care about their well I'm sorry
I don't care about their age I don't
care about their gender
I just want their name well if I only
want their name what should I do
well I want to group them and once I
group them I want to perform a mapping
operation where I take a person and
extract the name out of it well okay you
want a group but by mapping so that
becomes extremely intuitive so you say
mapping and then you specify well person
get name and then you want to put it
into a list so to list over here and
then you can extract just the names
itself so you can see the power this
gives you in terms of how you can start
transforming your collection by grouping
things together so if I want to group
people in this room based on who is
wearing a blue colored shirt versus who
is wearing a grey colored shirt I can
just do that in one call I don't have to
sit and write 20 30 lines of code to do
it where I keep putting stuff into the
collection yes sir well the question is
what if you want the count well this is
actually going to result in a list
eventually and then you can iterate
through the list further and then get
the count out of it either using a
stream following it because at this
point you have done a terminal operation
the train has come
halt you can start the next stream at
that point if you have to there are
other mappings you can do in between as
well but that's going to be a little bit
more a work to do yeah so so that is
basically an audition for you is if you
really want only the count based on the
age values I might actually go through
something like a reduced function or
potentially a filter a map rather so I
have to think about it a little bit more
so but but I would look at a few of
these other combinations and decide
which one which one makes sense so there
are three or four answers available your
account would be on the terminal so it's
going to tell you the whole streams
count in the end oh counting yes on the
collect you are saying yeah okay try
that as well yeah so that's great so far
well we have a way to work with these
collections but then I want to talk
about something that's really powerful
which is predicates and functions well
of course there is predicate of course
there is a function but what is really
beautiful is what you can do with them
I'll just show you with predicates here
I will skip the function you can do
something very similar to it with a
function as well so Java util function
dot predicate and let's start with this
for a minute so we got a predicate on
our hand to work with so what I want to
do to begin with this wickham a little
clearer when we start with the example
so let's go with the function here and
I'm going to call this as print and we
will take this one as int let's say
number and predicate I'll say integer
and then we'll say a predicate and then
we'll call it as and then we'll call it
as a message string will say message
well what I want to do here is output
and I will output the number plus so I
will then output the message given to us
and then a plus and then we will put the
predicate dot test on the number so a
little simple example there's nothing
really great of this at this point so
all I'm doing is I'm just printing the
number the the message and then the
predicate evaluation of that so let's
start with this a predicate integer
then I'm going to say in this case is
even and then this is going to say given
a number will say e e mod 2 is equal to
0 so I can say print and we will say
here 5 comma is even so is even question
well it clearly is going to tell us Phi
use even is false so that was easy let's
do this one more time we will say here
is 10 and 10 is oops
that didn't mean that so 10 is even so
you can see that 10 is even and you can
see that's true well that's awesome so
far let's do this one more time so what
I want to do now is create one more and
I would say is greater than let's say 6
and I'm going to say given E is greater
than 6 well ok so far so what do I do
here let's actually say greater than 4
so well to use this I can say print a 5
and then e is greater than 4 and then we
can say 'is greater than 4 question we
can do the same thing with a 10 as well
very easily so here we can say here's
our 10 well when you run as you can see
that's working really well also but what
I really want to do is to check for both
so here is something nasty isn't it we
could first say well I'll write
pseudo-code here we could first say is
even or you know is it even and then we
could say is even and then we could pass
a 5 to it then we could say is is it
greater than 4
and then we could call is greater than 4
and pass 5 to it and then we can work
with both of those we could say is it
even and then we could evaluate it but
when it comes to calling the print we
are stuck because print says give me a
predicate not a result so that kind of
which is in a binding so what can we do
to get around it well it turns out it's
extremely simple so 5 comma and then I'm
going to say in here is greater than 4
and then I end is even and then I'm
going to say e is greater than 4 and
even and then of course you can see in
this case we are employing operation
which is a combination of the two not
only can you do that you can also say an
our operation as well if you really
wanted to so this gives you a very nice
power of combining predicates so you can
take multiple predicates and form a
chain of predicates when two predicates
combine what do they do they give you
another predicate kind of like humans
right so they just kind of multiply and
produce but these pretty because the
predicates are more predictable than
humans generally so so basically in this
case you can take two predicates and
combine them using an end or R and that
gives you another predicate similarly
you can do this with functions you can
say and then and combine the functions
together as well and it will apply the
first function take the output of the
first function and feed as an input of
the second function of course in this
case the output of one should be there
compatible to the input type of the
other and then you can combine through
really nicely so we can do that pretty
nicely I've used this quite a bit
actually to build a very series of
processing and filters where our data
comes in but the users would give me
these criteria but I would pack them
into a series of criteria together and
then feed it as one criteria to use or a
series of transformations in the case of
functions you can implement decorator
pattern very nicely with these kinds of
techniques if you will and the one other
thing I want to mention really quickly
is that map has gone through some really
interesting change as well so and I
laugh because it's a change but we got
to be very careful because mutation and
functional style don't quite go you know
well each other I've run into some
difficulties with it so map let's say
string the comma integer and in this
case actually let's say integer comma
double how about that so we'll say
integer integer a comma double and then
we call it as square root equals new
hash map and I'm going to just create
this for a second so now in this case
what I want to do
is just for our purpose I would write a
method called compute and this compute
method takes an integer number and what
it does is it outputs in this case and
it'll output let's say a called and then
it returns math dot square root of that
number well great so far we got a little
method to do the work for us but what am
I going to do well I could do something
like this I could say Squire rude dot
you know is it what contains and then
you could ask if it contains too and
then you could say if it contains well
that's great but if it does not contain
then square root dart pert do comma
compute too and then you could do
something like this right so so you
could write code like this definitely
but this is a little bit too verbose to
be doing in the code so if you notice in
this case we can write code like this is
it contains or what is it called so this
is going to be a square root yeah a
contains key thank you
so contains key well that's a ceremony
right you're not expressing what your
intention is you're going through the
lower level there you go well rather
than doing this of course once you do
this you can output in this case square
root dot get and then you can get the
value for 4 and display let's see how we
can change this so rather than doing it
this way all I'm going to do right now
is simply say well square root a dot
compute if absent and then you're going
to say 4 comma and then this is going to
be sample square root so you're asking
it to perform an operation if that
particular thing does not exist and this
is of course a compute so you can see
how we can pass that function very
easily so just like you were compute if
absent you also have a compute if
present and there are a few other
combination of functions so if you're
using map just pause for a few minutes
go to the map in the Java 8 JDK and look
at various methods they have so they
have methods to only you know compute a
value
if it is absent computer if it's present
take a value and merge with an another
value the merge is a bit confusing but
what they do is they get the current
value take the new value that you want
to produce perform operation on it and
then set the value back into it so some
really powerful methods are available
there that you can use but use it with
caution so you got to be very careful I
ran into trouble with this when I
started using this with the recursion
and it failed in rather unpredictable
ways so as long as you are careful how
you're using it this should be really
fun to work with so so that is another
thing to think about in terms of what
map is so another good exercise for you
if you guys do Brownback's sessions at
work one of the things I would encourage
you to do is on a Wednesday afternoon
you know lunch time you tell people hey
we're going to take one Java interface
or one Java class every week and just go
through what's new in it in functional
style of programming then for crying out
loud things like a random class has
streams to produce so you can call I and
PS are doubles and it gives you a stream
of random numbers
similarly file provides you lines which
gives you a stream of data for content
of the file so the classes which are
very old suddenly have new things in
them which is pretty interesting to say
hey we could do all these do things
differently now the other thing of
course is to pass in your IDE and put
the dot but take a minute to see what
new functions are available that's
another thing to do as well but a
brownback session is a great way to
really look at it the last thing I want
to talk about here today is about
parallel streams I have an entire talk
on parallel streams that I normally give
so I'm going to just touch on this here
for just a little bit of information
that we can look at well you can take
streams and you can paralyze the streams
and it runs those functions in
concurrent threads if you will so this
can be very powerful way to engage in
getting better performance or
responsiveness in cases where it makes
sense sometimes people ask well if you
can paralyze the stream so easily why
would you not paralyze it all the time
and the short answer is I have a car why
am I not draw
the car all the time well because car is
not the fun most fun thing to do to take
from one room to the other in the house
for example hard to go to the next
remain neighbor's house so a bicycle is
great in a lot of situations where I
want to go to the neighborhood park so
we got to ask ourselves is your data
size really large maybe parallel will
help is your computation taking longer
time maybe parallel will help thee is
the solution fit for parallelization
parallelization may help but there's a
lot of situations when it doesn't fit
any of these answers it may not be the
right answer for you well let's quickly
take a look at an example here I want to
say in here a little thing called let's
call it as double it so I'll call it
double it and it takes a number and I'm
going to simply return the number times
two but before I do this I'm going to
out port thread dart current thread so
we can see what thread it's calling it
on and then I will also print the number
here so number plus and then I will put
a little colon and print it just what
our fun sake so now let's say in this
case list of integer and then I'm going
to say numbers is equal to arrays dot as
lists and let's say a few numbers so I
have a bunch of numbers on my hand and
what do I want to do with these numbers
all I'm going to do here is simply say
numbers start stream and then I'm going
to perform a dot map and I'll call
sample double it and then I would say
dart reduce and in this case we'll start
with the zero integer sum operation to
perform the sum of these numbers and
when I'm done with it I'm going to just
go ahead and print that value so you can
see in this case all I'm doing is
performing this operation and printing
it when I run it of course you can see
in this example that it is actually
producing all that in the main thread no
surprise in this example after all
because you're running all of them in
the main thread and so it's running it's
sequentially one after the other and
produce the result you can also see that
it ran one then two then three so it
preserves the order in that case as well
but what I can do
though yes I can simply come down to
this code and say just a parallel stream
so I'm just changing the stream to a
parallel stream it does require proper
typing though so a parallel stream
that's the hardest part of this so once
you type the name parallel stream now
you put it on multiple threads all of a
sudden so if I were to go back and run
this code right now you can see that the
result is still the same as it was
before so that did not change how well
were you notice that in this case the
threads it running it's running in a
fork/join pool thread and you can see
the order is different as well it's
absolutely non-deterministic because
depending on what time you are running
it fires up so what does it really do a
by default it uses the same number of
threads as the number of cores in the
system it already lied to you the number
of cores in my system so this works
really well so that's why you see eight
of them running at a given time so it's
a whole new ballgame why did they choose
the number of threads to be the number
of course the shortest answer is that is
the safest bet so if you are a
computation intensive process you should
never feed it more threads than number
of course otherwise it will trash the
system if it's a io intensive you can
feed it a lot more but the short answer
is they don't have a clue what you're
doing well a lot of times I don't have a
clue what I'm doing so how could I
expect them to have a clue about what I
am doing right it's a very unfair
request to make so they said let me take
a really you know safe bet I'll just
give you the number of threads equal to
number of course but it can change it
really well one way to change it is at
the JVM level you can use a flag at the
JVM level if you will to convey what you
really want and how do you do this well
I'm going to show you here on the
command line how to do that in just a
second but before that I'll show you the
flag itself that you could actually use
in here so I wrote myself a little
compile too so let's go ahead and take a
look at the compile to here if you will
so the compile to shows you
the flag I'll bring this up here in a
second so when you run this what you're
going to provide is this particular flag
so you can specify add the jvm level the
Java dot util dot concurrent dot for
join pool dart common dart parallelism I
love this property because finally
something is longer than my name okay so
you can see that in this case you can
say Java util concurrent for join pool
calm and parallelism and you can say I
want a hundred threads so now you're
saying I know what I'm doing giving more
threads and it's going to give you more
threads so to prove this point if you
will I want to show you how this works
really quickly here so notice in this
case I'm going to kind of repeat this
just a for fun sake and I put this into
three so thirty of them right so I go
back to the command prompt if you will
and I'm going to run the compile this is
going to use the default so I got thirty
it tells me got eight cores so do me I
do it do me a favor 30 divided by eight
two point five so three times is a fair
am i doing math right so it should be
three births right three batches so
since eight then the second date then
the third eight so that should work
isn't it so run it and it should do that
in the three births you know what
actually it's a good idea to slow this
down a little bit just to see it so
let's say thread darts sleep and let's
say about you know let's say one second
so we can actually see it of course this
requires a little bit more thing so we
can say try and then of course this is
catch exception and then e.x Java is so
cool isn't it we can do these kinds of
wonderful things okay so now that we
have that taken care we can run this
batch one batch to batch three done
right okay almost my math is off by one
okay so right there you can see that it
did in four batches just to show you
again well it sends you eight of them
the second eight the third eight and
whatever is left okay that's great but
what if I were to run a compile to and
remember the compile to was using
hundred threats at the system level and
you can see that one burst done and
that's example of what it can do so it
gives you that many threats you say wait
a minute I don't want to do this at the
jvm level how do
do this within my own process well you
create your own for join pool for
yourself we all know how to create
executor service per pool you create a
for join pool and anything you do submit
inside and whatever runs within that
call well that's going to be in your own
pool thread and you're going to have
your own world of poop just a word of
caution if you are using a you know j2ee
containers I won't name them
specifically if you're using any of them
I will tell you how to use this feature
with all of them I can summarize in two
words good luck okay so given that let's
quickly summarize what we talked about I
talked about a few features in Java 8
that are usually not at the surface but
come to light as we start using it I
looked at the strings join I really like
it quite a bit we talked about static
methods and why to use them we talked
about the default methods and the
reasons to have them and we saw examples
of them when we started using sort and
grouping collect is one of the beautiful
things with collectors worth spending an
afternoon looking at collectors and
different methods in it we saw how we
can start chaining predicates and
functions we saw a few convenience
functions in map which are functional
style we just touched a little bit on
parallelism and and saw some of the nice
Eden treasures in Java 8 I really hope
you found this useful thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>