<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ask Tom Office Hours SmartDB | March 20, 2018 | Coder Coacher - Coaching Coders</title><meta content="Ask Tom Office Hours SmartDB | March 20, 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ask Tom Office Hours SmartDB | March 20, 2018</b></h2><h5 class="post__date">2018-03-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_L9trVzhEew" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I think we should get started welcome
everyone to this smart DB session with
Brin and tone who basically we've been
presenting and talking about Oracle
database forever and I'll hand over to
tone start with to talk about
opportunities for smart DB yes okay yeah
I thought I'd prepare a small slide deck
for this second session just to for two
things I I want to I want to bring a
little bit of a of the smart DB message
every time we do an office hour so I'm
gonna bring a little bit of mess of the
message that I haven't touched upon last
time but also to ensure that if we have
any new participants or people who
watched recording and are new to this
matter we always start with a real short
explanation of what we mean by smart DB
so it's going to be five minutes and the
plan then is to go into the questions
that we had received of last week's
session in the Deaf gym area and and for
this week now so for those who are not
yet aware of this smart to be is about
how you use or fail to use the database
and there's basically two very big
opposite ways of using the database you
can use it as just a persistence layer
where you just use it to store rows and
tables or you can use it as a processing
engine I mentioned a full-fledged
processing engineer and by that I mean
or we mean that it's all about where do
you put the business logic now I
explained in detail what we mean by
business logic last week so I'm not
going to do that again this week but the
applications that we targets roughly
consists out of three tiers you have the
table store the table store at the
bottom stored in the database at the top
we have the interfaces both human or
software interfaces and in the middle we
have the business logic which deals with
all the use cases that you need to build
for your application and which have lots
of programmable logic that issue sequel
statements towards the database and we
see two mutually distinct approaches of
building these
of applications one on the left is where
you use the database is just a
persistence layer meaning that the
business logic and all the sequel that
is being issued towards the database
lives outside of the database in a
language that's not BL sequel hence the
no PL sequel approach name that we put
on the left there and on the right we
use the database as a processing engine
meaning that we are going to use PL
sequel and also set based sequel
statements to implement the business
logic for our application and here we
are using the database as a full-fledged
processing engine now last week I
explained that if you use it the way we
depict here on the right side you might
actually a get much better performance
but be and this is counterintuitive
be much more scalable the database will
be your bottleneck far later then it
will be on the left and this is totally
counterintuitive we talked about that
last week there's a video on YouTube
that you can look at and in case you
haven't seen that yet and on the right
we call that the smart DB approach now
over the past 25 years we've seen
roughly at a very high level these 3
software architectures in the 90s we did
everything with client-server where we
had fat clients sitting on our desktops
that ran the user interface that ran the
application the user interface part of
the application and we used a lot of the
smart DB approaches in those in those
years then in the new millennium we've
seen the dawn of Java Enterprise Edition
and the ubiquitous model view control
approach where all the data logic the
business logic is being implemented in a
middle tier in an application server
that also has a web server that services
a browser very thin thin client thin in
the sense that there's no logic logic
anymore in the client side and the
database was did you adjust the
persistence layer now in the last few
years we've seen the dawn of this whole
javascript phenomenon to build the UI in
the first place but also javascript on
on servers at times and we see this
approach called Maul of you view model
being used over in this new architecture
so these are three high-level
architectures and the point that I want
to make is has to do with the title of
this short slide deck the opportunity
for smart to be to become popular again
if you look at the architecture in the
90s where everything was in the middle
we used frameworks that we used view
frameworks control frameworks mobile
business frameworks and we had basically
a I think you could call it a full stack
developer that was in charge of
everything because these frameworks they
are so they sit so tied to each other
and they integrate so tightly that it's
it's it's it's an all-or-nothing deal in
the middle tier in those days so we have
developers taking care of all these
aspects of your application now what
we've seen in the past few years is that
functionally wise the whole creating the
user interface and also the control bit
of the application so how does the
application behave in terms of the page
network of this application has moved
that that that business logic that
application logic bit of your
application has moved from the middle
tier to the browser the browser is
essentially again a new fat client
because deaths those functionalities
were on the client in the client server
error in the 90s also now so what what
this had and has enabled is and I
depicted that with these two little
persons here that I animated is that you
can now also have two separate roles one
developer can be much more focused on
creating the user interface of your
application whereas the other developer
can be much more focused on implementing
the back-end services of your
application that are required to make
the user interface work
yeah so this this whole new architecture
that we see as a very popular one
nowadays is an abling these two separate
roles a user and user interface
front-end developer and an ANA well I
mentioned here Java back-end developer
but it could be a JavaScript back-end
developer if you use nodejs or any-any
anything else probably the point being
is that these are clearly now d marked
with they have they are separated with
each other via this rest protocol now so
from the user interface you just call
out to rest endpoints to deliver data
that needs to be processed or you call
out to rest endpoints to get data that
you want to do something within your
user interface now and the the the
reason why I call this the new emerging
world creates an opportunity for smart
DB to revive again is because what you
can now also envision is that instead of
having a Java JavaScript back-end
developer here you now just have a
database developer that creates these
back-end services for whatever is
required on on the front-end in the user
interface part now so that's that's
that's the point that I wanted to make
as a starter as a warm-up for this this
month smart DB office hours so currently
we see this rest
that's very hip and Jason being the the
data format used to to implement the
payload of these rest messages so we
would have a web server maybe with RDS
or maybe something else that that opens
up the endpoints towards the browser but
basically just acts as a proxy so every
endpoint there's nothing else but just
stored call the corresponding stored
procedure preferably a package to store
procedure in the database and these
database api's in in our most ideal
smart DB world would at the moment just
do Jason in Jason out so they
would accept adjacent message they
dissect it and they start working on it
and depending on whatever needs to be
done with it do it and then process
adjacent message to be output again and
sent back to the user interface where we
can then modify the user interface
accordingly so that's the smart DB
high-level architecture as I envision it
nowadays Brynn anything to comment on
this and no I don't think so I think you
said that very clearly and lonely
diluted if I say more okay Chris
anything from your side here no I think
that was a great sum up thanks time okay
any questions on this short slide deck
maybe now in the chat from from the
people in who are joining us yeah so if
you've got any questions and please put
them in the chat window and we do have
some questions that we've had in advance
as well so okay so Dennis this all
emerges as some problematic in
development process I think you need to
expand on what exactly you're asking
there Dennis I'm not sure what he's
getting at I don't interview brain or
tone you've got that you're the guy who
submitted a number of questions along
these lines to the typing interface
you're flying interface yes/no Dennis
have you submitted questions using the
website yes yeah well in that case I
have the list in front of me and you're
said said a yes and I we plan to address
them so you needn't type any more at the
moment let's just come to them we could
come to them straight away I think okay
because after all and it would be nice
to let people online type stuff but
we've got a backlog and last session I
was we were all acutely aware that we
were preaching without really having
much bandwidth for interaction so we're
trying to turn the tables this time so
I'll come to your question presently
Dennis but here are a couple of
questions and
and before I answer them I'm going to
switch to my slide and just reinforce
eyes one point um which I hope I can do
now the question is first of all where
is it gone can everybody see that slide
christened tone can you see this slide
not yet not yet
okay I have shared but I haven't shared
right there's two steps do you want to
share it and then you want to share
again right now can you see this yes yes
yes yeah this is where tone left us
really he said that there's a whole
world out there where JavaScript
developers are implementing the mod V
sorry the view and the controller part
of the whole UI basically vui everything
about it and all they're interested in
or what they are interested in it's a
noble thing is issuing calls and getting
responses we usually call it rest to
save breath but you could say this is
just a way of doing remote procedure
call over HTTP and here are the
endpoints and as far as these guys are
concerned that's the end of their
interest they negotiate with the people
who are implementing these endpoints so
that everyone agrees on the same
protocol and then each can work to their
own skills in their own part of the
picture so moving on then just to
emphasize this my main point and I say
it rather differently from tone but
really we're just using different words
for the same thing is that these end
points after the ORD s has done some
semantics free protocol translation from
RPC over HTTP to ordinary oracle net
these endpoints are the procedures that
don't talked about namely the JSON in
JSON out sub programs each in its own
singleton package I talked about that
last time what what are the circles and
the Diamonds and what's the gray box and
the light gray box that's the essence to
the whole thing the gray box is an empty
schema owned by a user
has from the get-go zero privileges
let's not be distracted by the
inevitable public starting point is zero
privileges and then that user is granted
exactly and only execute privileges on
each of the intended sub programs here
so these diamonds represent the
existence of an execute grant on
something in a different schema and that
in my view is the essence of the smart
DB paradigm or the hard shell paradigm
there's tons more and of course as
always the interest is in the detail but
the higher level position is exactly
that and as long as you do this bit
right then that's the main part of the
discussion nailed down and then
everything from here on in is all about
code classification which is important
greatly important but it's a separable
point from the basic establishment that
the world inside the database is exposed
to the world outside of it only through
a countable set of very specifically
designed sub programs okay now against
that background then here are two
questions both came from reading my one
of the people putting these questions
had read my paper end to end which
pleased me and the first question is
about the point that one of us probably
me made last week that by putting your
sub programs each in a singleton package
in other words a package that has
nothing but that one sub program you are
achieving a special benefit over using a
top-level function or procedure in that
the execute privilege which you need and
which confers the ability to read the
source code to package specs top level
functions and top level function
procedures does not confer
benefit to the body and I made a big
thing that the people on the outside of
the database shouldn't be able to
discover anything about the insides of
the database beyond what you intend in
other words the API specifications and
by all means whatever comments you care
to put in the pack expect to describe
the purpose of the various formal
parameters and the question was why are
you making a fuss about that that sounds
to me like security by obscurity and
they referenced the fact that that Apple
has said that design of such sorry I'll
read out what he says by design the
security of our products doesn't depend
on the secret secrecy of our source code
why am i making a fuss about things in a
different way and really it has to do
with the difference between some kind of
stuff that's installed in your own hands
on your own smartphone and stuff that's
installed Co installed in the
environment of who knows what precious
data about people's financial positions
their medical histories their all sorts
of sensitive personally identifiable
information that we hear so much fuss
about it's a different game and it's
just axiomatic I would say that the
world is full of bad guys we hear about
it constantly and they are seeking ways
to hack in and any information that a
bad guy can get about anything that's in
essential for the purpose of the system
they're trying to hack in is just
imprint sickly potentially beneficial to
them and it's really a waste of breath
to try and examine the detailed
mechanisms everyone in the security
space simply rehearses that point in
time and again so I just take it as
axiomatic that anything we don't have to
reveal and that we so trivially can
securely avoid revealing we most certain
should and that goes for all the source
code and it also goes for that other
part of what I was talking about the
error logging system anything to do with
what goes wrong must be recorded within
this hard shell and the only thing you
can give out is that terribly sorry
something unexpected happened and here's
the incident number so I hope that's a
sufficient answer to that question do
you have anything to add to that one
tone no other than you you explicitly
mentioned singleton stored procedures
each in their own package yes
single packages I guess I'm a bit more
flexible in that in the sense that I'm
happy I'm happy to see a package that
has a set of procedures that services
one particular area of the front end or
so right or consolidated in a single
package yes well let me return to that
point then I'll explain why I'm so hot
about that and my have to go quite a bit
forward to get the right slide there my
enthusiasm about that here it is is
entirely to do with their feature in
Oracle database which is new in 12-1 and
that's code based access control so I
hope this diagram isn't too
spaghetti-like but these guys here are
the next level in from these guys here
the guys in the dark gray box are they
JSON in JSON out who act as a shim for
the conventionally parametrized PL
sequel equivalents with ordinary PL
sequel data types and I showed you that
that maybe some subsystems are
interested in exercising that
conventionally parameterize PL sequel
right now each one of these PL sequel
sub programs is of course a member of
the set which defines the interface
they're not there by accident they're
there because each one has been worked
out to be the implementation of a
specific business function and different
business functions required to do
different things some are selecting
and when they're selecting each of them
whose purpose is only selecting will be
selecting in general from different
subsets of tables of what's available in
the whole mess similarly those who do
changes will be changing in tables and
different of them obviously will be
changing in different subsets in the
limit the subset is one that it's often
a few of tables within the whole mess
now there are two ways of enabling such
procedures such sub programs to do what
they want one is to give them privileges
beyond what they need but nevertheless
which set of privileges encompasses what
they need and argued that now it doesn't
matter really if they've got more
privileges than they need of course you
can argue that very convincingly on a
specific case-by-case basis with this
fair amount of analysis but the other
stance is the one I take no I'm not
going there I'm not having that
discussion there's a well-established
axiom out there the principle of least
privilege is just you know taken as a
law that anything you do should be done
using exactly and only the privileges
that you need you can't do it with fewer
privileges than you need but if you have
superfluous privileges clearly without
examining any of the mechanisms it's a
potential enlargement of the attack
service so that's simple and the
practical way to give each one of these
exactly and only the privileges that it
uses is to use the fact that new in 12-1
you can grant effectively are missing
out some words here you can grant
privileges directly to a PL sequel sub
program actually not to the sub program
but to the PL sequel unit that contains
it ergo if you have two or several sub
programs in the same unit you've lost
the granularity that you want in a
future
maybe we can lower that granularity so
that tone can have the organization
benefit that he wanted but in my skin
tones world is here where these guys
have their several ones grouped together
for various organization reasons that
suit you and these are again shims and
their purpose as shims is to be exactly
and only the spot to which you grant and
by the way sorry yeah maybe I'm not sure
if you can quickly find it in the docs
yeah maybe just quickly show the syntax
on how to do that you know I could find
it but I think if I can find it I'll
speak it out then when I'm talking but
we're gonna get escalated into
complexity basically there's a level of
indirection involved you don't grab the
privilege to the sub program why should
say to the unit rather you grant it to a
role so you first have to have the role
there and you grant the dog to the unit
and the syntax for granting the role
would be grant ah to you in very crude
terms where r is the role and U is the
unit obviously there's a little bit more
syntax around to disambiguate what you
mean but I wouldn't fuss about that I
would just rather say that your
intention of granting a role to a PL
simple unit can be met by using the
right syntax and thus in taxes in the
book and then in turn you grant the
privileges you want to the role and
here's a way to see all this lot had you
insisted on it well put it a different
way if you're stuck in 11 - and you're
inspired by this philosophy how would
you achieve it you could achieve it by
having every single one of these in its
own individual schema establishing it as
a definers rights guy and granting the
of that schema exactly and only the
privileges that you need that would work
splendidly
it would just be quite tedious for
maintenance so in this new regime every
single code unit in the whole universe
and everything is in Volkers rights and
that means that by the time some this
guy this guy who has only execute and
nothing else comes to invoke these if
there were nothing else each of these
would fail in the sequel attempts to do
because execute on a unit doesn't give
you the ability to do secret from it and
it's exactly then at the last minute
that we give with the precise
granularity that we want the privileges
to execute what shouldn't be done I
sorry the privileges to fulfill the
tasks that should be done see what I
mean
sorry I know you see what I mean I mean
I understand brain that you're currently
working on a white paper that details
this very persona yes rather more
carefully stated I'm currently working
on getting ready to start currently
working on it but yes yes exactly
so and I'm just gonna say without any
shame or embarrassment here that whole
discussion that I just had which I'm
going to in assert is only a
manifestation of everything you hear
everyone in the security space say all
the time is uniquely possible by
exploiting by taking to use the features
that you find exclusively within the
world behind the hard shell within okay
so Brynn there's been a couple of
questions kind of yeah well you've been
talking one is probably just a
clarification they're saying single
singleton packages so that's just a very
granular access control list or ACL
method essentially it's fine-grained yes
if you like to put it that way
the term singleton is just meant to be a
ordinary English word that expresses
exactly what I'm saying a singleton
package is a package whose spec exposes
absolutely nothing at all but one sub
program yep and OH type declarations no
to sub-programs no exceptions no nothing
just those things cool right so then the
next
later question is so why use packages
for this why not just use and standalone
procedures and functions well I already
stated that again briefly but if I just
repeat the same thing again we'll run
out of time the execute privileges sorry
execute privilege lets the person who
has it read the source code of objects
in namespace one spec level objects
freeze standings sub programs
free-standing sorry lists I'd say that
another way functions top-level
functions top-level procedures and
packages and for that matter type specs
package specs and five specs but
noticeably not bodies they're not in
namespace one so exactly to hide the
people in the middle tier or outside of
the database to hide the source code of
your whole project from everyone outside
of the database you must separate the
code in other words the implementation
the definition from the Declaration and
fail sequels type sorry bill zinc was
packaged spec that bitch body mechanism
gives that I hope that's clear yeah and
there's a second reason which is also I
think applicable to one of the questions
that was being asked last week is how
how to support mocking objects in this
whole smart database paradigm well if
you have packages mocking objects in
terms of we have already agreed upon the
specifications so we can create the
package spec but somebody else is still
working on the implementation in the
meantime you would like to mock this
object to have it already return data or
accept data in some manner so that you
can do your work because you're out
there in the day in the user interface
trying to access this API it that can
then be very easily done because because
that person crank create his or her own
private her own version of the package
body in in their own private database
environment
without without having already an
implementation available in the source
control system that you have and that
you might be able to check out you just
mock the package body in your own
development environment which is much
easier or much more natural to do if you
have all these procedures as singleton
packages are implemented brilliant I
forgot to do my implementation so in my
animation another closely related
question I'll stated it and leave this
one two-tone is in the scheme of things
where I've got various schemas for
whereas there is purposes where do I
think that triggers should go my answer
to that would be that's a detailed
question the main question is these you
know singleton guys here would execute
and everything else hidden in a suitable
fashion but it's an interesting question
so I'll hand that one over to turn yeah
okay well first trigger easy do I have
triggers yes triggers in in in in the
Oracle database developers community is
a very controversial topic I think I
think it has been established through
all the work that's been done in the 90s
where triggers have been used in lots of
different ways that triggers that have
what's called
side effects are generally considered
harmful and and by side effects I mean
for instance you insert a customer and
you have a trigger on the customer table
that immediately propagates a sub
transaction of something else towards a
bunch of other tables because whenever
you insert the customer you want to have
something done and why why not do that
in a trigger so that would be a trigger
with a side effect because inserting the
customer has as a side effect this these
other DML statements that get fired by
the trigger this I think the general
consensus out there right now is that
that's that's not the way you should use
triggers it's much better to have an
insert customer API somewhere in your
layered architecture of POC coast or
code and as part of that insert customer
business logic you do all the additional
stuff right there
instead of pull it out there and and
took it away basically hide it away in a
trigger on the customer table now so
supposing you you're not doing those
kinds of things in triggers then I think
there's a couple of things left for
which you might still use triggers a
very obvious one that's often heard is
auditing if you're if you have some very
special auditing requirements those and
by very special I mean the type of
auditing that you could not
pre-configure with the audit
functionality inside the database
because we have an audit statement in
the database and we can have the
database automatically audit a whole lot
of stuff in various ways
if you audit you want to audit it
yourself in a trigger be my guest
but then that's always going or you're
always doing transactions towards audit
tables and and sort of that's the end
station you probably don't have triggers
again on those all the tables which
might get you in this cascading hell of
triggers firing which is the case in the
first way that I talked about triggers
and if you have a customer trigger that
that propagates some DML statements
towards other application tables those
application tables might also have
triggers and then they fire and it
becomes uncontrollable so other thing
might might well be a use case now where
where would you put the auto trigger in
that case I think I'm not personally I
don't have a really big opinion about it
but I would put them in the code in the
code schema any any any any thoughts
that you have on this ring yes yes and I
think I should emphasize the subtext of
everything you were saying I'm just
bring out a point that was implicit and
make it crystal clear
um just imagine a no plc scheme where
there are some very rigorous and
right-minded data modelers I know that
doesn't often happen but let's imagine
it so they really really care about the
data model but for some reason in the
larger picture of the organization all
the sequels are still coming in from the
outside world and there are various
rules about if this happens then that
should happen as well you know and one
way to get it all right
in other words to end up so that the
database at rest always holds exactly
and only the data that conforms not only
to the kind of constraint style rules
but the rules about what should happen
in order when things are done there in a
way to get that correctness in the
database is to trust outside of the
database code which by the way in order
to function at all has to just have the
ability to go on any table at any time
and therefore anyone the outside world
can go on any table in any time and do
things in a weird way so under those
circumstances you do find that that the
recourse to the trigger the problems
that you mentioned not withstanding is
expedient because you can then within
the world of the database where at least
you have some authority make sure that
certain rules are maintained or at least
give it AB far better shot but all this
is kind of it's like a solution to a
problem that shouldn't exist point is
that you can't achieve what you want to
achieve in the context of the data model
unless you control everything and the it
comes back to the basic concept of an
API you know the functional definition
of what's to be done and its
implementation and when the
implementation is spread and Trust
diverse tiers yeah you're out of
luck basically when it comes to any
control ok ok but now it's not because
we're using smart to be resized where
where should not a trigger go that is
the point
now we're using well now you just state
all your
in a very different way don't you let's
say you never thought of auditing and
you've got your functional API
absolutely splendid and now someone's
comes along and says you know what we
should have some auditing well then you
have this discussion about what auditing
means what he ordered any award him the
time of day or during the color of the
socks the guy is wearing and all that
kind of stuff
you know and when you've got a
functional understanding of the
rewarding requirements and only then you
work out what to do and it might well be
the case that some sort of uniform
intervention in the relatively close to
the API guys in ordinary PL sequel code
can gather the information that's needed
and in a uniform fashion write it away
that there's every reason to hope that
kind of thing would be possible it would
be just inconceivable unless he were use
in smart DB paradigm so you know in one
answer to the question that still be no
triggers in another answer where they
really really really are triggers that
you rights because out-of-the-box
auditing is not sufficient and you're
convinced that all this locked is as
right and proper as it can be that
you're not cascading on and on and on
well I would imagine that you would
depending on the volume of such I mean
the number of such it might make an
auditing schema why not
actually right now there is a problem
here it's a very practical problem and
it would be solved at a stroke if only
someone in Oregon god of their backsides
and implemented a way to grant the
ability to create a tape you know grant
create table in schemas got to Blake
grant you know if we had things like
that we'd be in a different world but we
haven't and the problem is that when
ascii when a trigger is not in the
schema that the table it should fire on
is in and getting in in place is tricky
in various ways getting into fire in
various ways and you end up in a
elevated privilege regime that you don't
want
and the minute anyone has got a single
any privilege it's just intrinsically
bad news as well and sometimes I think
you have to let that rule and that would
mean that the triggers sorry to say this
just have to be in the same scheme as
the tables they're on because
consideration Trump's others yeah yeah
yeah and when I was talking about use
cases of triggers I still I had a number
three in my mind so the ad diem the
number three use case for triggers would
be to validate constraints that you
cannot declare yet in the database and
but but these would be triggers that
never do DML because those traitors they
just they didn't validate a transaction
that's just occurred in terms of some
data integrity rule that you have inside
your database design and since these
triggers only reads in my sense of
side-effects they don't have side
effects so they they only check the
transaction arrays an application error
in case it's true so those kinds of
triggers in my will definitely be part
of the table schema and not of the code
schema now implementing data integrity
rules fight triggers is a very complex
matter it should not be taken lightly
and there yeah let's just leave it at
that that's a whole different you can
say say it you're too embarrassed I'll
say it what tone means is you should all
if you haven't yet go out there on that
community and vote up tones proposal for
sequel assertions the basic subtext is
that if these things which are solutions
to a very common problem and for which
the whole theoretical side is well
understood if they were done by Oracle
for this whole discussion may I think
just buried yeah if we have seen so much
then a whole lot large use case of using
triggers in then in the database it just
goes away let's go to other questions
otherwise would get stuck I'll I'll give
a brief answer and hand this one over to
you as well turn the question is
basically
do you allow the PLC Co hard shell API
to include views that's the question and
I'm going to answer it very mechanically
and then hand over to tone for the real
answer the answer is obviously no
because by definition a PL sequel API is
a set of PL sequel sub programs
interview is not a PL sequel sub program
end of discussion
right but really I guess the question is
how do you arrange that clients who want
to do sequel can get that sequel done
presumably you know exercising some
freedom on how they compose it doing row
by row sequel if they think that's good
over the Hughton yeah so I think I have
seen views being used in pretty good
smart TV projects what 10 15 years ago
we're thinkin we'd have to say smart DB
primed smart DB you know ok soften and
but but that was in the days when we
were still using model frameworks in the
Java middle tier and because some of
these model framer today they just
really like to do sequel preferably
against Raw tables and not fuse at all
so in those days I would allow views but
but in in in the new in the in the
current time that we're in with with the
JavaScript way of building these
front-end applications and the rest way
of communicating with back-end services
I don't see the need anymore to allow
views in the sense that that I would
have allowed them 10 15 years ago it it
it also so so and another question in
the same area that I often get is do I
allow stored procedures that return a
ref cursor that's that's that's a very
common question in the same in the same
in the same area here
again I would say no because if you
return a ref cursor via a stored
procedure you then lay the burden of
fetching rows outside the database and
to me doing a fetch is like doing just a
sequel statement outside the database
and I I would never want to want to have
that I would just want to return exactly
the rows and preferably nowadays as
adjacent message that are required for
whatever page is out there that needs to
display a couple of rows fetching rows
it's not the only responsibility that
you then immediately put in the
different realm so not in the database
realm but on the application server
realm or even in the client realm with
you depending on the architecture that
you're using you're also putting the
burden of closing that cursor outside
the database yeah and and the the the
the risk of leaking cursors or where
where clients forget to close these
cursors is very real and very high and
and and it's often the reason why DBAs
get often asked to increase the open
cursors all the way up to ten thousand
or even higher because then we can make
the weekend and then we can bounce the
database and we're good for another five
work days so in if you are currently in
this new paradigm in this new JavaScript
architecture paradigm with preferably of
just just a rest server in the middle I
I would not want to use views anymore as
a database API no good right let's um
that's all the questions I believe that
were outstanding from the first session
let's move on to some of the ones that
have come in from the second session
sprint so just going back to some of the
things you were talking about earlier we
had a question coming about the
singleton packages and so on and saying
is it correct to say this more granular
access was mainly intended for into
invoker writes and goes on for definer
writes which is the primary choice when
it comes
ensuring security this is rest less
relevant yes the question is worded in
such a way that it includes some
assertions and those assertions are
groundless in the world I'm talking
about so it's a slightly tricky word
game here before we had code laced
access of control before you could grant
privileges to code units through the
intermedia of a role then definers
rights was exactly the way that you
achieved the effect of privileges equal
unit to do the task it needed to while
the user who had the execute privilege
on that unit had no privileges to do the
sequel operations themselves okay that
was the only mechanism and in that
regime as I explained you could always
get ultimate fine granularity by having
every single definers rights sub program
that implemented the API in its own
schema and granting the owner of that
schema the privileges needed okay in
that regime if you were being careful
and using that whole multi-schema
approach everything in that world would
be in bocas rights except the api and
the api would be the finest rights in
the way I mentioned okay now what code
based access control does is liberating
from the tedium of so many many
different schemas one for every single
sub program and rather it lets you have
them all in your API schema and grant
the privileges that you need to each
unit within that schema using the code
base access control mechanism with the
right set okay so the fact that we now
have code based access control turns
that whole discussion on its head and in
the scheme I described there is
literally no there's almost not a single
in the finest rights unit presence okay
so the world changes so you have to
think differently where do
use a defiance rights unit this is very
practical
low-level detail but I found it useful
to have common declarations like for
example the biggest fire char - you can
have X like Steven Feuerstein is always
talking about have a package with some
types in it also types and subtypes who
were the various you know table row
shapes and so on that I needed to
communicate between these layers and
that package that defined those types
obviously it was only a spec did no
sequel and the definers rights first is
in focus rights discussion is relevant
not at all a compilation time it's only
relevant for the sequel that comes out
of something so when no sequel comes out
you may as well have it define this
right so I hope that made that point
clear I think that's good thanks Bryn um
I don't think there was any other
questions come in specifically ok there
so let's move on then because we may
manage only one last thing in this space
there were a number of questions that
came in from it was that guy said said
something for things of the name look
but they're all embroidering on the same
theme so I'll try to paraphrase it's
really how do you do the development
process when the or aim is to be smart
DB how did in version control how did
you continuous integration how do you
have check-in/check-out how do you
manage with the fact that the databases
is harder things sort of just
instantiate and wipe out and instantiate
and wipe out and how do you manage the
fact it's got data in it on and on and
on and they were all really those things
and tone and I talked a lot about this
yesterday and I'll just turn over to
tone unless I could say but something to
tone I seem to have been talking more
than I thought I would you want me to
start oh no no no no so yeah I I get
these questions of offline frequently
let's say once a month and my first my
first answer is well suppose you're not
doing smart DB
so you're developing everything in
JavaScript or Java you use you're using
IDs that support you building that code
and you're using git or subversion or
what have you to to to check in all your
source and to branch and to merge and
all kinds of things in that regime you
also have very likely create table
scripts right yeah they say yeah right
we have create table scripts and they
version control create table scripts and
a version control create index scripts
and maybe they version control create
sequence scripts those are typically the
three types of objects that you see in
no PL sequel kinds of objects projects
and when they move from a release one
two or at least two they might have
instead of a create table scripts a
couple of alter table scripts or drop
index and recreate index scripts in
different ways so so you're already
doing version control of files that
basically constitute sources that should
be run or that should end up being run
in the database what's the difference by
just adding more script types in the in
that in that whole process that you
already have so now you're gonna
introduce create package create package
body scripts you're going to introduce
maybe create view scripts create all
kinds of other types of scripts and you
version them first and control them in
the same way as you do those few scripts
that you already now have the liquid
base is a framework that I often hear
being used to to run scripts in the
database in those kinds of objects well
you you can use liquid base and
configure the running of all these kinds
of stored procedure scripts that that
that have all the all the business logic
of your of your smart DB application in
it so so so there's a part of me that
says I don't really see the problem but
but there is another part of me that
says maybe I don't yet fully understand
the problem but at the moment I'm at the
position that I don't really understand
really see the problem as I think you're
already doing this only you're doing
this a very little bit and it becomes
full-fledged if you go smart to be I'll
have a go at this too
and but in a rather different way and I
talked to a fair number of customers
especially I talked I've got to get this
word in somehow I talked to a lot of
customers who were interested in
adopting EBR they have said it addition
basically a definition it's wonderful
stuff you should know about you should
use it right when I'm talking to them
and I have to ask them what have they
got and then we got any of this and so
on and then how do you go about things
how do you do your development how does
it work and I often asked this question
to people at conferences to I seize
every opportunity I can and there's two
kinds of answer that come along one is
very straightforward coherence and we
have the basis for a meaningful
discussion and in that regime and
whether they state it explicitly or
whether it simply emerges these people
recognize that any deployed database
whether it's a production database or
any of the gazillion that you have in
the flow to get to the production
database any one of those is just an
instantiation of a definition which has
its own important existence and the
definition exists in a source control
system and the source control system
provides you a scheme to instantiate not
only the latest definition but any
definition along the way including
earlier ones that were good and
including provisional ones that are at
the moment in progress and the people
who work in this way are all focused on
the idea that anyone can in a prototype
environment check out not check out just
copy out anything they want from the
source control system instantiate any
version make all kinds of changes in it
come to all kinds of conclusions which
changes they do by changing some or lots
of the scripts that define it then the
question is if they think they're too
changes are good can they get him back
into the source control system and the
answer is of course no not unless they
sought permission in the first place and
if they did sleep permission in the
first place and if they're going to get
them back in only through no end of
gates like a peer review of the code
this is what we do in Oracle
excruciatingly Li careful peer review of
the code a discussion of things maybe a
meeting lasting an afternoon where
people discuss it FES tones bina such
meetings and then of course when you
check it in it's checked in in some kind
of provisional space which occasions no
end of mechanical testing and who knows
what I don't think I'm talking out of
turn if I say that sales force with whom
I've worked closely in connection with
it used to be BR do this kind of thing
did they do it as a matter of course
then there are other people and dare I
say it they're the people who have taken
sequel developers ease-of-use deluxe
where you're just looking here connected
to a database you're looking at her the
source code of a principio sequel
procedure you type a few changes in it
you press save and it's back there in
the database and the database
particularly when it's populated by many
people connecting to it all doing this
the database kind of becomes your source
of truth and then you get this business
of diffing don't you know you take this
sum definition of DBMS better that
metadata the production you do some
corresponding thing of this thing you've
got organically in your shop you work
out the differences you compute scripts
who are going to impose the differences
that people do this don't they have you
heard of people doing that tone yeah
you're laughing but you laughing like
making it up no it happens well when
you're in a priori or least when you've
drifted into that second school then
everything is problematic right no
matter what it is when you're in the
first school of thought the questions
that these people are asking don't seem
to arise you know as tone said well
everything is just various forms of
artifact that done with certainty I'm
not sharing and every everything
is just some kind of artifact in your
source control system typically text but
not necessarily and there's no no
difference in philosophy what you're
doing smartly be or not and don't forget
that the system contains artifacts that
are relevant outside of the database as
well there's one important aspect that I
forgot to touch upon so so if if you're
in it there are say traditional way of
building applications in the nopd sequel
way of building applications everybody
has his or her own local application
server right so and and it's in the
application server where the highest
frequency of code changes happen because
that's where you build your business
logic now if you go smart EB I do think
and I'm absolutely convinced every
developer should have his or owns
database sandbox because if you if you
don't have today to own database and box
into which you can first so you first
check out whatever release or branch
that you want to work on and you get all
the source codes although all the DDL
script files on your local machine and
you then have tooling like liquid base
or whatever to to install those scripts
into your local sandbox database and
then you start working on it yeah and
only when you then have completed your
working you you recheck in your scripts
but but it requires to have your own
local sandbox like in the no peel sequel
world everybody has his/her own local
JVM sandbox
and often in in in the others in the
other scheme of doing things with with
all the logic outside of the database
people might have been sharing it's
single development database because
that's that's an environment where
hardly ever any changes took place and
although all the tables got created once
and then everybody can use them and
start building the business logic so in
the in the in the smart DB paradigm you
really would need to organize every
developer to have to have their own
database sandbox I think that's an
important thing that that I forgot to
mention when I was talking right I'm
going to grab the screen and then the
last couple of minutes I'm going to show
a little demo and hope I can communicate
the psychological force of it in in
limited time so meeting share screen do
I want to share yes I want to share
right what I've got here is a directory
with you know names to do with different
database versions and if I look at 12.1
you'll see I've got my cloned DB
database I think all the data files that
represent obviously the PDB that's at
that version
oh nothing there why is that well the
reason is because this is one among many
unplugged gold masters this is a bean is
meant to represent a PDB who is
populated it could be populated with
everything so that it is a proper
representation of your work-in-progress
project as it is at an in-house label 42
right and the task of the day is to
instantiate this I get the scripts that
you're interested in that a part of it
and work in it how do you do that a
trivial sequel script that you can run
directly from sequel plus or at a tiny
little bit of extra effort where is it
gone wire up to your favorite editor
okay so here we are if I was to won't
even bother to connect and show that it
fails that's uninteresting I'm just in
my editor I'm doing stuff on changing
scripts I think thumb I've messed up I
want to be in
Stanzi ate my whole database I'll go up
here I go up here give me a new thing
from gold master 42 whatever it might be
here it is it's coming I'm dropping
whatever I had before if there was
nothing there before it doesn't mind and
now it's just you know seriously using
those straightforward sequel statements
who clone you a pdb off an unplugged
gold master day it's done how long did
that take less than 10 seconds and my
whole point here is that I'm in my
editor I'm typing this file I realize
I've screwed up I want to run my whole
battery of the scripts again from
scratch bang I don't lose focus I got
here I say you know do the same thing
this will drop and Riaan Stan she ate
blah blah blah blah I'm still thinking
about that is it done yet
wait a minute blah blah oh it seems to
be done right that's what we're talking
about that's what it takes to get a
every single developer their own private
sandbox don't forget that to use that
feature you don't need the license
because there's a one PDB in your
database and don't forget either that
with a teensy once the on-premises stuff
is available so will XE be available XE
gives everyone who is using it as part
of their professional job the ability to
have a full on all options database for
every any purpose they want except you
can't have much data in it obviously no
good for production but having not much
data is perfectly fine for a large large
set of development tasks so I think the
era of our core the only thing cuz I
can't make every developer have their
own sandbox is over and the point is
that exactly and only when you're in
this smart DB paradigm a whole corpus of
engineers need exactly an only an Oracle
database and something like sequel plus
for running scripts and their own
favorite editor in order to be
productive it's not like they need all
the other components that je viens and
who knows what so
you know you get your cake and eat it
this simple PDB cloning thing gives the
Oracle database Engineer Oracle database
development engineer it's working in the
smart paradigm scheme exactly what he
needs to have a perfectly private
sandbox one among n of them cloned off
one among n interesting gold masters in
a heartbeat sorry if that sounds like
too much marketing but I feel quite
passionately about this because I am
sick of hearing can't work sensibly
because I can't get a sandbox okay okay
thanks for that Brin I think dennis is
identifying with a what you're talking
about and he's saying he liked it you'd
love to have a look at your scripts that
you've got so there's some way you can
share those or them you mean the PDB
cloning script I believe so yes well
seriously I'm not going to share that
because it's cluttered with everything
to do with my macbook where this is
where that where the others it's it's
all in all over the place in examples
you know Tim holds blogs Frank power all
these people they've all talked about
how you drop and create and so on yes I
know of a very good talk by kana
McDonald's I think four or five years
ago who had a scheme of managing local
sand boxes for developers also and even
without using the PDB CDB architecture
this may be a topic that we that I think
this is a topic that we should spend a
small slide deck on maybe next time or
some some future run to to discuss
various options in this area yes in that
live presentation environment I'd be
happy to show my code it's just you know
I'd have to write an essay ten pages
long to explain what my math book is
like okay so I think that's great I
think yes this would definitely be a
good topic to follow up on in future
sessions um so we're just over the hour
now so I want to thank everyone for
joining us I hope you will found this
useful please let us know what you
thought on the feedback page and we look
forward to seeing in future sessions
thanks Brent thanks thanks and let the
questions come in and we'll see you then
thank you bye</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>