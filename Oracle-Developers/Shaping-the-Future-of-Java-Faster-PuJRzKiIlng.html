<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Shaping the Future of Java, Faster | Coder Coacher - Coaching Coders</title><meta content="Shaping the Future of Java, Faster - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Shaping the Future of Java, Faster</b></h2><h5 class="post__date">2018-04-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PuJRzKiIlng" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so let's start good afternoon
everybody
I'm going to be making this presentation
on shaping the future with Java and in
this talk I'm going to explain a little
bit about the history of Java about the
Java ecosystem and some of the more
recent releases of Java and some of the
important features that were implemented
for those releases and also a little bit
of a peek into what features are in the
pipeline for for future releases
I hope the break was refreshing for you
all how many of you have programmed in
Java or or code in Java actively right
now okay that's that's pretty much 90%
how many have programmed in the last
five years other than Java
okay quite a lot so you have polyglots
all of you so my name is muladhara I had
the you know Java platform group in
Bangalore I work for Oracle and before I
proceed I need to tell you that you
can't you know make any business
decisions based on what I'm going to
tell you about the future of Java so you
need to look at the Associated
documentation for the release before you
make such decisions at any time if you
have a question please raise your hand
and and you can interrupt me so Java is
a pretty large ecosystem as you can make
out from some of the numbers here right
it's it's of course the number one
programming language there is a survey
that happens every year and we've been
maintaining the the number one position
for you know quite some time the number
of you know active Java developers runs
into the millions and of course the
number of you know instances of the Java
VM runs into the billions right and the
cloud itself accounts for you know 20
billion plus you know Java instances
so it is the pretty huge what should I
say user base and also a community and
it is expected because Java as you know
is over 20 years old
it started in you know 95 96 timeframe
and it has grown very popular and big
over over this period of time so how
does it happen you know how how does one
decide what should go into the next
release you know so you know there is a
lot of collaboration there is there is
quite a big community which provides you
know continuous feedback there is
opportunity for you know contributors to
also contribute you know ideas
contribute implementations and so on as
will be see seeing little later in the
presentation so we have a Java magazine
which is a you know quite a large
subscription base we have a community of
Java user groups typically you know
there is a jug they are called jugs and
there you know in most of the important
cities there is a jug that is quite
active and Java champions many of the
speakers that you heard you know today
they are they are you know Java
champions and so that's an independent
what should we say activity by the jugs
and and other Java champions so it is
not regulated by Oracle and of course
the the biggest contributions are coming
to you know what people contribute to
the open JDK as you know Sun
Microsystems open source this in
2006-2007 timeframe and you know so open
JDK is is is completely in the open now
and I'll be discussing some more about
you know how much more open it is now so
what are the you know key themes or
you know directions in which Java is
evolving right it is of course based on
the the computing you know environments
that are available today and keep Java
relevant to those environments right so
it is of course open it was open quite
some time back but it's not now going to
get even more open as I'll be discussing
it is continuously evolving you know as
a language system you know it keeps
introducing newer ideas all language
systems borrow from each other right so
some you know particular paradigms or
some particular even you know syntax and
styles of programming you know keep
getting borrowed across language systems
so Java is no exception
Java when it started came from C++ as
you know the syntax is almost very very
close to C++ right so there is a lot of
give-and-take between languages as they
evolve in Java continues to evolve as
more and you know more new applications
and new frameworks evolve so so Java
needs to adopt some of those ideas so
that those newer applications can be
implemented very efficiently in Java of
course it has to be nimble that means
the change should should should happen
you know rapidly enough that the
developer community sees that as a as a
evolving language and things that they
can apply you know the changes and the
new features that are coming into Java
they can exploit it you know quickly in
the new age applications that they are
building and of course scalability is a
big area we have to make it as scalable
as possible whether it is you know
multiple cores whether it is you know
different types of memories and of
course the cloud with different types of
containers and so on it is the number
one runtime in the cloud ok so if you
see AWS and Google App Engine it is the
number of Java is the number one runtime
right that means applications run
on the Java platform and it is the
number three on Azure did I hear a
question no and II the Java Runtime is
the foundation of the cloud is pass and
SAS you know a lot of these applications
are built built on the Java Runtime does
anybody know what is the Java Runtime
what do we mean by the word runtime
anybody wants to take a guess yes
so the VM is is is a critical you know
component of the J of the Java runtime
right it is the it is the engine on
which Java applications run so when you
compile a Java program it generates
bytecode and then bytecode is what you
execute on JVM so a virtual machine
basically emulates the the java
bytecodes correct so in addition to the
you know to the interpreter and compiler
you know engine JVM the other important
part of the runtime is the API you know
the entire set of the core foundation
libraries that Java comes with all that
is part of the runtime okay it's
available to you and the Java
specification covers the language as
well as the API right unlike other
languages like C and C++
they focus only on the language all the
other you know libraries like you know
they are not part of the language
standard right they become standard by
by virtue of it being used it's it's not
really a published standard as such with
Java the specification of the API is of
the libraries they are also standardized
okay the other big commitment that Java
made very very early on in its you know
journey was to maintain backwards
compatibility okay so it is you know
makes a huge demand on such a platform
some people might have the impression
Java is not changing fast enough but
Java has made a commitment to its
millions of
of you know users that you know if they
write the Java application it's it's
guaranteed to run you know in future
versions and we we take great care to
ensure that we don't break anything so
that's a you know that's something that
that makes us what should we say very
very cautious about implementing new
things there obviously it's very
difficult to roll it back you know we
can't just introduce something and pull
it back in the next version so we would
only install it after there is enough
you know confidence that yes it is a
necessary feature and it is you know
already you know tried and tested in you
know part of the other you know language
systems perhaps or even in the research
community and and you know there is a
thumbs up on on implemented at in Java
so that's the time it gets into Java so
it's somewhat behind but that is
intended okay that's the way it is
designed to be so what are the
investments we are making in you know in
the open JDK platform so security has
you know of course number one priority
it has been so since since the beginning
as you know the JVM runs in some kind of
a sandbox environment and there are
various policies and ways in which you
can determine you know what the
application that runs on the JVM can
access you know whether it can access
the file system whether it can access
the network and and so on and so forth
so right from the beginning it has been
a priority and continues to be so
because in today's you know cloud
environment it is even more important
that we have the same kind of a sandbox
environment in your containers a
container is kind of a shell around
around your your application and the
runtime you know that keeps it from
impacting any other containers that are
running on the same machine there's a
lot of isolation and it's a void by
itself so you know so obviously it needs
to
take care of you know security quite
well of course Java developers is also a
focus we just need to keep adding
features and enhancing the Java platform
so that it improves that productivity
right how quickly you can build so one
of the big themes of of the Java
language is to let the system or the
underlying system do all the heavy
lifting right and you know the
application programmer is supposed to
focus more on on the application logic
so which is the one thing that comes to
your mind when it comes to what is
handled by the Java system as opposed to
an earlier programming system like C or
C++ garbage collection that's right so
you don't no longer keep track of you
know what memory you're allocating and
when you gotta free it right and whether
you're freeing it correctly or not you
can't free the same memory block twice
that would be disaster if you don't free
it that's also disaster because you'll
very soon
run out of memory why is garbage
collection even more important today or
why is it so critical for enterprise
applications
because maximum memory is consumed yeah
I mean enterprise applications of course
their memory footprint is large they
handle lots of you know concurrent
transactions so obviously there are
there are many users that are there are
connecting and it will consume more
memory but what else avoiding deadlocks
yeah I mean that say a system yeah so if
you're you know locking synchronization
is is incorrect or less than efficient
it's going to show in in less throughput
or you know in it'll have higher latency
but what is the other most important
reason for it yeah I see a hand yeah
yeah that is true it is similar to the
answer this gentleman here in the front
gave so yes it is an enterprise
application it's like a server side and
obviously it gets a lot of traffic and
so it consumes a lot of memory then an
application that's running on a desktop
would write but the other most important
thing is
yeah so yeah so one you know one way
could be if you're consuming more memory
than required then you're being unfair
to somebody else who is running on that
box but where I was trying to get at was
these are all 24 by 7 applications
they're always running they're always on
ok just imagine that you're leaking some
amount of memory every second how long
does it take for you to just you know
hit the wall and run out of memory with
a server-side application it's going to
happen in a few hours or a few days or a
few weeks because of the nature of
enterprise applications they are always
on they never stop until there is a
fatal crash of something right so
garbage collection and its accuracy and
it's what should we say it's operation
it's cycles that it keeps doing to
continually free memory so that the
demands for allocation new memory never
fail ok so it's it's a it's a very
important you know aspect of the system
and it's one of the things that keeps
your enterprise applications running
people you know applications are run for
months without having to be you know
restarted right there are a few more
features that are going to show up in
you know some of the future releases one
is increasing density which is called
valhalla so many of these projects are
you know described under open JDK so if
you go to open JDK door java.net you can
see what are called jep's
jdk enhancement proposals and they are
all identified by a chip number and you
if you go to that website and just gives
jep's slash you know whatever the number
is you'll find the description of that
project so you can find you know what is
Valhalla yeah you had a question yeah
Oh
if GC is so important why is it a low
priority thread is a question any close
yeah one is if you have memory you know
there is no need to run the GC because
you can always allocate from whatever is
available right but the question is
still valid why won't you be running it
all the time why do you you know why is
it a low priority yeah I mean so one way
of triggering a garbage collection is to
wait until you have run out of memory
right you try to do an allocation there
is no more memory available now you
start doing a GC which will free the
memory and then you will be able to
satisfy the Alec that's one way of doing
it but today garbage collectors don't
wait until that that almost endpoint
they employ heuristics right and they
say you know how much am i allocated
what is the rate at which I am
allocating newer objects and you know so
they have some kind of a high
watermarking and they can trigger a GC
yeah you know once it is 80% consumed
the available memory and things like
that so you know so there are different
types of GC algorithms and they can
employ these heuristics however you know
the real reason for why GC is a low
priority is GC consumes resources right
when the GC runs there are stop the
world G sees right where when the GC
runs the application threads have to be
stopped and so GC is sucking away time
from your users right it's going to
reduce the response time it is going to
lessen your transactions per second and
and so on and so forth so it read it has
an impact on the through port and little
latency of the of the
vacations and that is the main reason
that you don't want to overrun the GC
right if you keep just DC running all
the time and it is doing a lot of these
you know GC activity it's going to drop
your your application throughput so
that's that's the main reason okay
improving startup time so there is a or
T I don't know how many of you were in
this the talk earlier in the before
lunch by Christian challenger he spoke
about the JIT compiler and he also
mentioned about the ahead of time
compiler so the AO t is one project AB
CD s is application class data sharing
we will go into some of that that coming
slides
improving predictability you know so GC
is a area of active research people are
continually trying to improve the GC in
terms of you know speed of execution how
long the GC takes and how effective it
is in mopping up memory right so it's
it's a area of research and there's
always you know some at least one or two
new GC algorithms that people are
working on so zgc and Shenandoah are two
such you know projects in open JDK that
are currently running and the last one
is about monitoring and profiling right
so when something goes wrong with the
JVM when it crashes or even if it is not
crashed you know it is running but now
the responses has come down so if you
want to know what exactly is happening
you need to obviously monitor it to
detect that something is going wrong and
then you need to be able to profile and
see some of the statistics even in a
running JVM and so that's where you know
the Java Mission Control and Java flight
recorder these two tools are invaluable
in trying to find out what's causing the
observed behavior in the JVM instance ok
so we said it is becoming more open so
you know what exactly do we mean by more
open and it's moving faster if you know
the history of Java you know the major
releases
used to happen once in two or three
years approximately okay
so Java five Java six it was called 1.5
1.6 and so on this naming you know
nominal Eicher keeps changing from time
to time so then Java 6 7 8 9 10 we are
right now the latest releases 10 but all
the releases before Java 9 right we saw
between 9 and 8 there would have been
like almost a three year you know period
of time and then similar between 8 &amp;amp; 7
and so on so major release has happened
you know once in 2 to 3 years and there
were lots of minor releases which
essentially fixed a lot of the problems
or bug fixes plus some minor
enhancements and things like that which
did not change the spec right every Java
major release has got an Associated Java
specification and so things that you
know did not break that spec but you
know it needed to have some small
enhancements and fixes all that went as
minor updates and of course we had
critical patches which are called the
CPUs which are essentially all your
security vulnerabilities so they get
fixed and that happens on a quarterly
you know calendar so every three months
we have a CPU update that fixes at least
all the security vulnerabilities so
that's been you know the the thing until
9:00 Java 10 which released in March you
know just last month is the first six
monthly release and so that's what is
the thing about making Java faster so
one of the disadvantages of having a two
to three year you know release time
between major versions was all the you
know features that were planned for that
major release are available at just one
shot right when that major release is
made but if you if you take Java 9 for
example it had over a hundred features
ok or 100 japes
and of those maybe about five or six
the really big ones right for example
jigsaw the Java module system was a sort
of a key feature release for Java 9 and
unless that key features you know are
already implemented and then tested and
found to be you know good enough to go
the release will not be made right they
will hold back release until those key
features are in there so those are
called feature based releases but now we
are moving into a time-based release so
so the disadvantage with feature based
releases is that there were lots of
smaller features you know that God
implemented let's say in the first few
months of that 2 to 3 year time window
they never reach the hands of your
customers or your users right that wait
until you know it made it along with the
all the other features in the major
release so there is a lot of skew in you
know in there are small features there
are medium features there are big
features but everything got bundled into
one major release so we are trying to
correct that with this 6 monthly release
or or faster cadence and we are going to
go on a time-based you know release plan
so whatever features are available and
ready to go at that time they make it
you know so it's like a train leaving
the station if you're there on time you
make it otherwise it's it's you know the
next opportunity is just expands away
anyway even if you missed a release so
we feel that's you know a lot more
efficient and also we live in a giant
world today and you know a lot of
changes is happening quite fast so even
from that point of view making release
every 2 to 3 years seemed you know not
right so what does a new release model
look like ok so if you see JDK 6 7 &amp;amp; 8
you know they have the timelines when
that's going to become end-of-life JDK 7
you know it sometime in 2020 22 JDK it
goes up to you know 25 26 in between
that right so those are the
six seven eight or the old release
cadence in the new you're gonna have
nine ten eleven you see there of course
there are after eleven there is up to
seventeen there are another five or six
releases in between they all happen
every six months
but once in three years we have what is
called a long-term release that's LTS
stands for long-term release so there
are other you know popular operating
systems that also go using this model
and you know these two focus on two
different types of adopters right so one
our people who are you know either
individual developers or startups or
small teams that want to keep up with
the latest so even if you throw a new
version every six months they are
willing to you know consume that use it
for you know developing their
applications and libraries and whatever
right but if you take large corporations
like you know a health care you know
provider or a bank or you know and so on
they want more stability right you can't
keep telling them every six months okay
go deploy this new thing because they
are subject to you know a lot of
certifications stuff and their to do a
lot of testing all those three
certifications based on the new stack
they are using and and and that takes a
lot of time so usually you know they
tend to have much bigger you know eight
years ten years they continue to use the
the old stack so they do not upgrade as
frequently so the LTS the long term you
know support version is geared for
enterprise customers whereas the six
monthly releases are geared towards you
know individual developers and and
fast-moving you know platforms okay so
what it means is after ten becomes
available there is no further support
for nine okay
so if if you are using Java nine and ten
became available now you need to move to
ten because all the you know updates the
security updates patches etc will no
longer be applied to nine that'sthat's
kind of end-of-life it's over okay
you know so this is one of the choices
that you know Java users will have to
make going forward you know which one
you want to use you want to use the six
monthly release or you want to use the
LTS okay yeah eight is not LTS eight is
kind of a special because it's like the
the transition between the the old
cadence and the new cadence so eight has
got kind of a much longer life cycle and
it's available until you know for the
next five six years or more but the ones
after eight nine and ten they are all
six monthly Cadence's with limited
support after the eleven which is going
to come out in September this year is
going to be a long term version long
term support okay so the releases are
made in March and September six months
apart so the one that happened in March
was 10 the one that's going to happen in
September will be 11 and 11 will be
maintained for you know I you know five
at least five years you'll have keep
getting public updates yeah
well by support so the question was what
exactly do I mean by you know support is
available versus not available and you
know and we say support we mean like
customer support there are people who
sign up for you know a support contract
and usually enterprises do have support
contracts with almost all the vendors of
the software that they you know those
applications that they use because in
production when something runs into a
problem you want experts to fix it you
know very very quickly and so that's the
reason for the for the support so such
people you know customers who have
signed a support contract will of course
get based on the severity of the problem
there are sls and you know depending on
the problem they'll get a fix within you
know a few days within a few weeks and
so on sometimes you know if the if the
problem is so critical that the
production you know thing is completely
stopped then there can be a separate
what is called a vp are separate release
that's made for for that customer but
these are for paying customers if you
use OpenJDK which is in the open you
know then then you you know there there
is no question if you run into a problem
what do i do you got to do it on your
own you got to figure it out or wait for
the next release okay
did I answered your question okay
well that's because of the you know the
versioning thing which has gone to go on
a little change it was year dot month
the 24.9 is YY dot M whereas the 23:29
these are all simply just running serial
numbers
so after Java 8 the next release is 9
the next release is 1011 so it just
keeps on increasing
we wanted a YY dot M kind of a scheme
but you know that was for a some of our
presentations had that but we are now
going with the just a simple number yeah
no when I say support for Java 9 C we in
Java 9 is announced after that it will
get two updates remember I was mentioned
about the quarterly updates so those are
the security patches and so that'll be
available in the first quarter after
initial release and then the second
quarter after initial at least but
beyond that it will not be patched
anymore so after six months and of life
happens for those for those releases no
Java 9 it are all those people who are
you know oh don't mind moving you know
fast enough there are lots of people who
are willing to keep pace just because we
have you know enterprise customers we
don't want to ignore that part of the
user community yeah and you know it's
not like Java is unique in almost
everything you know operating systems
Ubuntu for example and you know all
kinds of Linux is they all follow
something similar right so you have a
version that comes out very very quick
so if you want the latest features and
you want to improve on performance and
all that and get the you know biggest
bang for there for those improvements
move on to the latest platform as
quickly as possible but you know the
stable versions will will
you know the ones that are for longer
type usual will appear a little later
yeah
yep yeah
so the question was do I have to wait
for a long-term support release and you
know if I'm interested in in exploring
some of the features that are available
in nine see once the feature is
introduced it's going to continue right
so what's available in nine will be
available in ten eleven so on and so
forth so even if you are interested in
eleven you know you can there's nothing
that stops you from using you know
features of Java 9 and you know
refactoring part of your application
well but I see there is there is there
see there's this Dell there is you know
testing there is production and lots of
things you know our baked and cooked for
a while before it lands up into
production so you can start early
after all it's it's how many months are
we talking of is you know six months to
the yeah SEC member will be the first
long-term release that we are going to
make in this this new cadence okay
jigsaw was the you know the real major
revamp that happened in Java nine and
essentially Java platform itself you
know all the libraries under the Java
platform also got you know modularized
so it's a module system and there is
syntax associated with you know what a
module uses you know what it requires
for it to function what it exports to
other users of that module and so on so
so this is how the Java you know library
itself all the packages in the Java
platform get reorganized as different
modules now there's a big advantage to
using a module system because it allows
us to now reduce the footprint okay
earlier it was monolithic if you
remember our T dot
does anybody know Artie doors are so all
the you know I don't know twenty
thousand-plus classes in the the Java
you know library API everything resides
there right and even if you were to use
only like you know I don't know let's
say thousand of them you would still
have to use you know that say market or
job but with a module system and an
Associated tool called J link okay
allows you to you know strip down GRE to
only those essential modules that it is
actually making use of so a full-blown
GRE might be add-on 150 MB but if you
put it through a J link and let's say
you're you know you have a simple
application you know the the GRE for
that if you use jailing it can be you
know as small as maybe 10 MB right so it
makes a big difference specially in the
cloud where you want to pack you know as
many instances as possible in a box and
obviously consuming lesser footprint is
going to give you big advantage in that
environment so a lot of good advantages
of the module system yes yes what do you
see here is really the dependency graph
okay so if you take the the top right
corner Java or AC dot EE
that module depends on you know all the
arrows that are coming out of that right
and so on so this is exactly the
dependency graph so if I'm not using
Java SE dot e for example it's not a
Java EE example application then I don't
really need to use all of that Java dot
korban Java or transaction and Java or
XML all that is not required and let's
say I'm just using you know Java or AC
so only whatever it uses is needs to be
in the package in the in the JRE yes it
will be in the bin folder so if you
download the JDK you'll find it along
with Java C and you know J console and
all the other thing
this is literally the the laundry list
of all the features that got implemented
in Java 9 so this is what it looks like
if you wait for a major release okay it
is some 100-plus I don't expect you to
read this you can you know you can go to
the website and figure out what this is
there's no need to even take the
photograph but so now you get the you
know the impact of let us say if you
have some of those things which are
really really small were available in
the first month itself they all waited
for three years until the jigsaw was
ready right so that's the disadvantage
of major releases yeah this just to
drive home that point
what are these containers so in the
world of containers we want to
definitely be very very very much more
secure hey there is a lot of sprawl
because you know pay as you you know go
and you know scalability you know can
lead to a promiscuity of resource usage
so you'll keep you know spinning up new
threads spinning up new instances using
more memory and so on and so forth but
you know there's a sprawl lots of
instances there is a lot of mix of
different applications
all this is the environment of you know
a box running applications in containers
heterogeneous machines right data center
consists of heterogeneous machines JVM
basically came into the world because of
that right right once and run anywhere
so there are a whole bunch of platforms
on which you know Java will run you
don't have to modify your your code for
that or rebuild it so these are you know
all very critical even in the cloud
world where we are finding the same you
know heterogeneity in hardware platforms
we have constraints on you know security
on application
not having an impact on you know other
applications there should be fully
isolation and things like that and if
you see Java you know it kind of Maps
very well to to what Java is already
designed for okay
so it's managed runtime hardware and OS
agnostic of course only for the
platforms that we support so Oracle you
know open JDK releases for Windows Linux
Mac OS Solaris Park okay so on these
platforms you know it will if you run an
application you can run on all these
platforms of course multiple you know
versions of those operating systems are
supported I think at any point of time
the latest plus the last last two
releases of that OS so the matrix is
quite big of you know the heterogeneous
type of platforms that Java supports and
compatibility is a key design goal we we
never make changes that will break your
applications and so in a fast changing
world that's very very important what
should we say thing to rely on as an
application developer you don't want the
rug to be pulled under your feet every
now and then yeah you want to guarantee
that what you wrote six months back is
you know will run without any problem
and of course there is a rich ecosystem
of libraries and support for almost
anything that you would want while
building an application the other you
know major announcement that was made
you know in the last open world JavaOne
conference that all the commercial
features so you know so there are two
major releases of Java one is called the
open JDK then there is called the Oracle
JDK right open JDK is is open source it
is you know distributed under GPL v2
with class path exception but Oracle JDK
is not open source so it's it's under a
different license it's called the
ciello binary core license so Oracle JDK
had certain features that were not found
in the open JDK but that's only
temporary because with you know very
soon we are going to have Oracle JDK an
open JDK matching as far as features are
concerned so the only differentiating
factor between these two
you know JD case will be their support
support life times yeah
also Oracle will work with other open
JDK contributors to you know to make the
infrastructure complete so you know
automated build system automated testing
system automated you know verification
or compliance testing all this needs to
be available to the open JDK community
so that they can also participate in you
know coding new changes you know
building testing and then finally
integrating it well they have said it
will happen very very soon and so these
are some of the things that
differentiates it right now so you can
see Java Mission Control
JMC and its counterpart Java flight
recorder which runs inside the JVM
Mission Control is like the client
visualization library so application
class data sharing java usage tracker
and so on are are so-called commercial
features and to unlock them you have to
use a special command-line option
that'll allow you to use them so it's
available but then according to you know
the license terms you need to enable it
so that you can use those features and
of course if you are using those
features you need to have the
appropriate license to use them so
coming back to the timeline which was
your question we hope that it happens by
11:00 but don't quote me on this it
could happen by you know around that or
a little little later so sooner than
later is going to happen
no it won't be a big bang it you know it
all depends on you know how quickly
these things are are done and remember
they are not all of the same size in
terms of effort so they could land you
know in different releases in Java no no
these are already yes for the Java spec
okay
today the the spec is not different for
Oracle JDK versus some of these tools
are outside of the spec yeah for example
a garbage collector you know it doesn't
tell you which garbage in get the spec
doesn't tell you this is the way garbage
collection needs to be done it just says
you need to have a garbage collector
whose job is this right you could you
could implement any number of new your
garbage collectors so things like that
okay how much time do I have
okay let's quickly go to Java 10 so
there are several places in which you
can download the the the JDK there is of
course open JDK door Java or net there
is java.com there is there is of course
the what is called the Oracle technology
Network OTN so you can download it from
there too so this is a snapshot of of
the ODN page so JDK 10 was you know made
available March just last month in just
a few weeks ago actually and this is the
page that I you know makes that
announcement and if you go down to you
know the features now you see a much
smaller list because Java 9 you saw
their whole the whole slide was full of
full of features here you have much
smaller set you see those numbers to the
left of the features are are the Jap
numbers okay so each you know feature is
captured under what is called a JDK
enhancement proposal and there is a
webpage corresponding to that and if you
want more details you can always visit
that page
openjdk da java.net / jep's / the number
okay so you can see now what are the
features that got added in Java 10 it's
just this small set okay so let me throw
some light on some of those features JEP
286 is called local variable type
inference
LVT I and this is just a I would say a
shortcut or a or a developer
productivity kind of feature where it
lets you get away by typing less okay so
if you see the the two statements at the
bottom of the slide this is how you
would do it without can you all read it
if no what can I do well it's in the
slide so I can't so let me read it out
for you are sorry I think I skipped yeah
so this one is a traditional declaration
you say ArrayList of string list equal
to new ArrayList of string so you can
see the duplication here you know on the
left you are saying you know this is the
type declaration of the variable called
list and then you are creating the new
object of that type you're repeating it
so it's like double the typing and same
thing here in the next line so how would
you do it with LVT I you would say
Wireless equal to new ArrayList of
string so it infers from this this is
the local value variable type inference
saying the type of this variable list
that you are declaring is this okay so
it's just a a a way of shortening the
the boilerplate code or the amount of
this thing you need to type there is
still strong typing okay it is still
maintaining all the essential features
of the java language it is not becoming
any weakly typed or anything it is just
that it is saving you some typing
yeah yes so you're right
I think gentleman here says he observed
this in some of the scripting languages
so scripting languages typically in fact
forget about this they don't even
declare a type okay you can use a
variable as a string and the very next
line you can use it as an integer and a
third line you can use it as a float or
whatever right so it is very very
minimal or minimalistic when it comes to
declaring so this is called dynamic
typing and a lot of your scripting these
things they do that but usually what you
write in a scripting language is is you
know a few tens of lines or a few
hundreds of lines you don't write fifty
thousand lines of code in in a scripting
language like Perl for example because
you know if you made a mistake in the
type it will manifest as a problem at
runtime and you'll spend sleepless
nights in trying to debug that and and
finding the root cause of the problem
right so strong typing is good for
building you know big applications that
run into tens of thousands of lines of
code this is invaluable you cannot have
like a dynamic typing system and then
you know do your debugging quickly okay
so what do you pay for what do you save
at the time of coding you will pay for
you know many many more
you know multiples of that effort in
debugging so it is worth its weight in
gold
so this wire yes you're right some of it
you know loosely typed or dynamically
typed languages and scripting languages
they do use this kind of feature so we
are borrowing the syntax but not not
necessarily the intent it is still
strongly typed okay the VAR where you
know keyword says that the list we need
to infer its type based on what follows
okay application class data sharing so
this is about
loading you know shared libraries you
know what I'm referring to
what's a DLL in Windows and what's a dot
I saw in the UNIX world okay so that's
what this is
they send essentially so you can have
one copy you know loaded in memory in
physical memory and that same copy can
be mapped to you know multiple processes
in their own virtual address spaces so
what do we save here we save memory
right so if you have like you know
twenty instances of Java running on a
machine but you have only one copy of
the of the library so that's what this
is class data sharing this was available
anyway for system classes that's been
extended now due to application classes
I think this is even more relevant when
you are talking of you know cloud
infrastructure where you would have you
know multiple instances running on the
same box then there is a JEP three one
nine that talks about root certificates
so when you install a Java it already
comes with the whole bunch of root
certificates that you do not have to
install so if you are building a web
application it already has you know root
certificates of I don't know what those
names are but things like Verisign
thought thought a and all these you
might have heard of and so they are
already in that so you don't have to
take extra effort to create the trust
store and and populate it with these
certificates they had already built in
so out of the box it can you know work
and HTTP will work okay there is also
you know zgc
which is kind of a low latency garbage
collector as I told you garbage
collector is a area of intense research
so we have one more in the pipeline
pause time should not exceed 10
milliseconds you heard of in the morning
you heard of this serverless and you
know the function is always fin win and
all this stuff it makes enormous you
know
impact you know the startup time needs
to be you know if you have is a function
that it executes for a few tens of
milliseconds and goes away you cannot
have a JVM starting up and taking two
minutes for starting up okay so it needs
to be also nimble very light-footed and
come and go as quickly as possible so
lots of you know changes are happening
in the background to sort of you know
achieve that goal okay there are also
early access binaries which means you
know I think somebody here asked a
question should I start doing Java 9
even knowing that I want to do 11 the
thing is even today you know 11 early
access will be available so you don't
even have to wait until the actual
release you know for you to start
building your application that is let's
say design to run on 11 so that's how
all our partners actually work right
within like a few weeks or a month of
the announcement of the availability of
a new release of Java
you know big you know Apache releases so
many other you know packages that depend
on that but very quickly how does it
happen because they start early and they
use this so they are continually revving
their application and refactoring them
to use the new API and so on so that you
know almost very quickly they can they
can release their dependent applications
what is in Java 11 there's very small
set of features you know there is a
dynamic class file constants is another
low overhead garbage collector called
epsilon and there is something called
remove II and Korba because EE and core
ba is kind of going away it's not very
popular he's not you know heavily used
so those things are going away from Java
platform also some of the modules like
the XML processing and so on we're more
related to Java EE and they are also
available in the Java EE package
so it's kind of a duplicate and you know
there was XY fully mauled in keeping up
with it and keeping it in sync there was
also something called the standards
override mechanism has anybody heard it
or used it standards override mechanisms
so there was a way for you to update the
JDK when I said JDK I mean the the JDK
where you install it it'll come with all
this bin Lib and these folders and there
is something called ext so there are
some standards with Java doesn't control
you know namely you know XML for example
security is another example so these are
governed by other standards bodies and
when a Java release is made you know it
can of course a deal to the latest
version that was published at that point
in time but let's say a newer version of
the XML or this thing was made available
it was not immediately available in the
Java platform so you could override what
was you know installed with the later
version of those libraries like XML
processing and and crypto security and
stuff okay so so that override mechanism
is gone now okay he's no longer
supported and which means anyway II
anyway was we considered that to be a
duplicate effort and that that's been
removed and there is a a substitute
thing called a upgradable modules which
allows you for updating a model even
after installation and local variable
syntax what I told you about LV ti4
local variables extended to two lambdas
if you know Java eight had two critical
you know major update feature called
lambdas and streams so lambda is here a
functional programming you know syntax
to to describe snippets of code in line
and it's available in so many other
languages it's been made available since
Java 8 so the local variable you know
type inference is extended to those
lambda you know snippets of code so
these are the things available in are
slated to be available 11 there are few
other things that we are working on
optimizing data so if you know
everything in Java is an object it's an
object-oriented language and of course
there are primitives which are non
object and you have to keep you know if
you have a primitive and you want to
pass it as an object in your box it
unbox it and so on if you are having an
array of elements an array of objects
every object there carries the overhead
of the object header and and so on and
so forth so unlike an array in C or C++
an array of int for example will have
only integer and you know it occupies
much less space whereas if you have an
array of integer object in Java each
element is going to have the overhead of
the Java object header and so on and so
forth so it kind of makes it much bigger
also while accessing it you do a double
indirection so you access it with the
reference to the array we extract the
element which is a reference to another
and so you've got a double indirection
okay so for some of these reasons you
know C++ things are much faster and
we're trying to address that by by
optimizing you know data layouts and
these are only for what are called you
know data objects these are like final
classes you cannot you know extend them
or subclass them what else and then that
is the project Valhalla value types so
there is effort going on to see how we
can you know introduce newer syntax that
allows you to have you know more
optimized data layouts so these are some
of the things in the in the pipeline
improved Java native interpreting this
is what goes by the name of J&amp;amp;I Java
native interface and it is used for you
know cross language
in vocations okay so you know Java
platform itself depends on you know lots
of libraries which are which are native
or written in a different language for
example the Java graphics relies on
OpenGL OpenGL is implemented in C++ so
how does Java make a call to opengl
library of functions so this it has to
use what is called a j'ni but the j'ni
as it exists today is pretty cumbersome
the way you have to create it you have
to declare an interface you are to
create you know header files and then
you know you have to write some proxy
you know coding in C or C++ before he
can make this marriage happen okay it's
it's it's pretty cumbersome and there is
an attempt now to make it much more
simpler and that's using the support of
what is called a Lib FFI a foreign
function interface okay it's nothing new
foreign function interface was defined
in Lisp in 1960s so all of the concepts
have been kind of evolving over 40 50
years and keeps getting packaged and
repackaged yeah yeah so some of these
are running as projects under open JDK
if you go to open JDK java.net projects
you will see a whole lot of projects
that are defined out there and that is
work going on okay because it's a
community process remember it's not just
Oracle employees of the Java platform
group that are working on this there are
other companies there are other
individuals there are other you know
jugs and so on contributors who are
working on that so you know they'll be
working on it at what point of time does
it get targeted to a release or get
integrated and merged it at least
depends on its state of readiness so
when it gets ready
yeah well deprecated you'll know every
time a Java release is made there will
be some items that marked as deprecated
and the intent is that it can go away it
is going away for sure but is it going
away in the very next release not not
sure it could go away in the next
release it could go in a release you
know following that but it is an
indication for developers to say hey
this is going away please refactor so
you will see even in the logs there will
be alerts if you are using those API
saying using duplicated API so then we
don't say when it is going away we say
it is going away so better start working
towards it who's who's talking can you
raise your hand are there okay yes
deprecated means that it's going away
okay how are you doing on time you don't
know it started a little late so yeah
maybe I should take a few few questions
yeah somebody else from here from the
back I saw some yeah ah you started a
big debate you'll see I don't know
terabytes suffer of flaming war zombie
on the on the internet about this Java
is it a pure object-oriented language
it's not because of because the fact
that you know I don't think there is a
very easy answer to this you should be
talking to language designers is why
they use this particular word where do
they call it this why do they have funny
brace and this kind of structure I don't
know primitives are obviously much
faster they fit into registers they fit
into the smallest memory word size of
the machine and so dealing with that is
is obviously much faster so if you want
great speed you want to operate on those
if you want the other
you know useful aspects of
object-oriented programming the ability
to subclass and you know do all these
runtime typing and you know that kind of
then you use classes okay but that
doesn't mean primitives do not have a
role to play even today you know there
are critical pieces that are that are
written in C there are written in
assembly and so on just in the interest
of making the the platform faster so
even Java has got some things that are
written in in in assembly and and maybe
C and so on yeah it's an interesting
thing his question is about jvm
languages do you know it's a JVM
language exactly Scala is an example so
there are tons and tons there I think
tons of languages so Scala Ruby Python
closure go I think Gatlin that there are
tons of them I think there is a web page
that gives you you know yeah just this
last question so what's the JVM language
the compiler for the JVM language you
know compiles the source code of that
language generates output as bytecode a
bytecode can run on the JVM that's why
it's called a JVM language what is the
advantage to those languages they get
the advantage of that language being
available on all the platforms on with
JVM runs without having to do anything
and if you use a foreign function
interface you can you can latch on or
you can make use of all the API is
libraries that are available with the
with the java language you can you know
extend that without having to make those
libraries again for the new language
okay
I think I've run out of time now if you
guys want to discuss further with me you
can send me email I work out of passage
technology park mercury building ok
thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>