<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Delivering Developer Tools at Scale with Swagger and the Open Source Community | Coder Coacher - Coaching Coders</title><meta content="Delivering Developer Tools at Scale with Swagger and the Open Source Community - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Delivering Developer Tools at Scale with Swagger and the Open Source Community</b></h2><h5 class="post__date">2018-02-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CMRbY6lAKRY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">that's today my name is Joe levy and i'm
mateus Rickon and we are here to talk
about delivering developer tools at
scale thanks for joining us say I think
we have a very interesting topic and
hopefully you guys think the same as
well so Matias and I are from the Oracle
cloud infrastructure team and so what
that means is our organization's goal is
to deliver infrastructure as a service
offerings for Oracle enterprises and for
startups and so we provide a whole bunch
of different infrastructure as a service
offerings compute block storage virtual
networking identity database DNS file
storage there was a talk earlier this
morning called kerbin to kubernetes on
Oracle cloud which went into a lot of
detail on some of the benefits of this
platform and why it's better than some
competitors but one of the main reasons
is we provide a better price to
performance ratio because we provide
bare metal machines on the cloud so you
can really get really good performance
not have to worry about noisy neighbors
so get that really good reliability in
the cloud makes it very easy to shift
lift and shift enterprise applications
to the cloud and get the same
performance at the same or lower price
in the cloud how many people in the room
are familiar with Oracle cloud
infrastructure ok a couple hands so to
give you guys a quick demo just to set
the context
and of course now our screens are set up
slightly differently when we practice
this yeah so anyway this is the Oracle
cloud infrastructure browser experience
and so in here for example one of the
things you can do is go in and create
instances where is that button to create
faces
I think you might have to select a
compartment first that's probably yet
all right so in here you can go in and
just like in other infrastructures of
service clouds create instances although
one of the things that we offer that
other clouds don't really is the ability
to choose shapes that are bare metal so
let me see if I can get that to appear
there's the bear mental oh yes a
bare-metal so these are very very high
i/o high CPU instances you can use in
the cloud that really provide great
performance for the price but this is
just one that way to access our cloud
and what Matthias and I work on is
actually the another way to access the
cloud the programmatic way so Matthias
and I are responsible for all the
developer tools functionality being able
to automate management and operations on
our cloud through SDKs CLI etc for our
cloud so we have some current slide
so and really what that means is
supporting a lot of developers or
picture I think okay there it is
supporting a lot of developers in a lot
of different places because as you know
the developer landscape is very
fragmented Java developers want to use a
Java SDK Ruby developers want to use
Ruby SDK Python what developers want
ease the Python SDK people are used to
bash when he's a command-line tool this
is a chart from 2015 that just shows how
fragmented the developer landscape is
and and you know a lot of things have
actually changed in the three years
since then can anyone think of a
language that is pretty popular now that
isn't in this pie graph go I heard go
yes that's exactly the one I was
thinking of closure Scala there's a
whole bunch of additional languages now
that weren't even on the map three years
ago
sorry I thought I heard someone else say
something anyway a lot of languages
right and so what that means there's a
lot of places to support customers if
you look above just languages and look
into tools that are used to talk to the
cloud it's actually even bigger right
because sure there's a base level
languages and then there's a plethora of
tools built on top right if you want to
do orchestration there's terraform
there's chef there's puppet there's
ansible you know and and there's many
tools in each area of the management
landscape continuous integration
configuration management deployment
orchestration monitoring etc right so
there's really a lot of places to
support and the job Mattias and I do is
make sure we support all the
functionality of our cloud all the
different services in all of the
different developer tools that customers
require require for their to give them
as easy and on-ramp to our cloud as
little friction as possible so we call
it fill all the boxes right so we have a
list of services here compute block
storage virtual networking etc we have a
list of developer tools we support and
we've done a good job so far of kind of
filling in those boxes making sure we
support all the functionality of our
cloud of all of our cloud services and
all the developer tools who want to
support and actually it's really hard to
keep the slide up to date which is part
of the point part of the problem we'll
tell you about there's a number of other
services that have released since we put
the slide together recently
DNS service file storage service there's
an email service coming very soon for
example as part of Oracle cloud
infrastructure and the developer tools
section also isn't up to date we have a
go SDK that's coming out very soon for
example so there's lots and lots of
places to support this functionality
allow allowing customers to automate our
cloud so if you look at our team size
it's around six people right now the
boxes we showed there was you know eight
dev tools nine services so if you
calculate all the boxes there it's
around 72 so sure you know maybe that's
something our team can accomplish you
know writing the code manually figuring
out how each function each function of
our cloud works and coding that up
debugging any errors etc but as I
mentioned you know there's there's more
there's more rows and more columns so
what this is showing is more rows more
developer tooling languages now of
course we're not actually going to build
a Fortran and a logo SDK for our cloud
does anyone remember logo the turtle
that went in circles and squares around
the screen right we're not going to
build a logo SDK for a cloud but we are
going to build other SDKs the go SDK is
what I mentioned and there'll be other
developer tools outside of SDKs that
we'll build as well ansible plugin chef
plugins we actually have a chef plugin
already puppet plug-ins for example so
that increases the amount of spaces
amount of places we have to support the
same functionality so now this this
thing that was a constant dev tools is
actually a growing set over time right
and dev tools some nine services it's
growing our team size isn't necessarily
growing right we aren't just
spontaneously
doing meiosis or mitosis to grow new
developers so
but we still need a scale to meet the
demand so maybe our smiley face is
getting a little more stressed out and
then there's more columns
you know Oracle cloud infrastructures
can add more and more services over time
we're not actually going to add puppies
as a service or haircuts as a service
but we are going to add lots of other
services for example I mentioned DNS and
file storage service came out recently
before and we need to again support
these all the functionality of these
services in all the developer tools all
the languages all the tools that
customers want to use to talk to our
club which becomes you know a very large
set of things now our equation is
getting a little tougher you know it's
more areas to cover our smiley face is
getting more stressed out there's
actually been more to this because it's
not about supporting a service one time
right you sure we do the initial support
for a service but that service continues
to be worked on and adds new features so
you know the vcn service for example
these are all the different resources
that have you know create read update
delete and other actions on them and
there's more and more coming over time
this list actually grew by about 30%
just for the visa virtual cloud network
team service since we last did the talk
so each of these big boxes is actually
an ever-growing set of smaller boxes
which are kind of illustrating with the
purple lines here so the equations
getting bigger more and more to support
smiley faces probably struggling to
maintain that smile another thing is the
pace of innovation you know as our as
our organization hires more and more
people the rate of delivery of new
services new features is increasing
right and an area with zero developers
on it is naturally going to get more
developers added to it than an already
established team like ours so you can
see here this graph Mattias put together
which so is you know the rate of growth
of our team versus the rate of growth of
our cloud and and the people working in
it and so you can see a year and a half
and ago versus now 300 people in the
order and a half and ago 1200 now so
it's actually had 4x growth right and
our team has really not kept up with
that 6 to 7 you know not much growth
there
but we still have to keep up we still
have to support all these services this
increasing pace of innovation and all
these different developer tools so our
equation grows lastly there's the
different scopes of release we're not
just talking about releasing tools
publicly we also want internal versions
of the tools internal preview versions
of the tools when a thing is not ready
to be shown publicly but we want people
to be able to test it internally of our
services and of our SDKs and other tools
public previews for when something's not
ready for you know supported production
use publicly but we want people to be
able to play with it so there's multiple
scopes and another thing is we actually
support the tooling for a whole bunch of
internal only services so that that a
table I showed you know there's actually
a whole bunch of services using the
tools we develop that aren't ever going
to be public just services calling other
services that are you know internal only
services for example that support our
cloud but are not public for our
customers to use they use our tooling so
it really is a ton of services to
consume to support in in different kind
of scopes so you know our equation is
pretty big now there's growing set of
developer tools growing set of services
many features per service and more over
time a pace of and a grit innovation
that is increasing and multiple
developer scopes you know at least for
right and guess what the team size is
still six to seven devs so you know our
smiley face now is he's he's tired he's
dead this is too much for him to do
manually okay so how do we this is the
problem our team face is supporting lots
of services in lots of different tools
very quickly you know we don't want to
release the service and not have the
ability to automate against it from the
variety of tools that our developer
customers use so how do we solve that
problem how do we scale to meet the
demand and it turns out the way we do
that is kind of a three-fold approach we
use swagger we open source then we have
API consistency efforts so the first
thing I want to talk about is swagger
who here when they saw the talk
description thought swagger just meant
bravado or confidence
now you guys all knew it was a specific
technology okay props to you guys
so what swagger is in case you don't
know and just were shy about raising
your hand is a way of declaratively
expressing your services api's
application programming interfaces in a
way where it can sense its declarative
it can go in a file right and so you can
control that file with source control
put it through you know your usual
pipeline stages code review it etc like
you would do normal imperative code but
it's not normal imperative code it's
actually very readable declarative
syntax to say this is what my AP eyes
look like and it kind of acts as a
source of truth for that API to be
consumed by other tooling which we'll
talk about swagger is since the newest
version is renamed to open API it's open
source on github and so you're kind of
consuming a very well tested product by
using this and it's useful for a whole
bunch of things like when you can
declare the state of your interfaces
declaratively in a code file in addition
to being able to source control it and
you know code review it and put it
through a CI CD pipeline you also get
one source of truth for all of the
things that need to reference those
api's right so you can generate service
scaffolding the part of your service
that takes in you know that generates
the different operations it supports and
takes in parameters you can generate
REST API documentation for your
customers so they know what the api's
look like without having to read a and
understand a swagger file you can
generate clients which is what our team
does in order to scale to meet this
problem so we generate our Java SDK Ruby
Python SDK or go SDK CLI terraform
provider the way we scale one of the big
parts of it is because we take the
source of truth the swagger spec that
declares the interfaces of our services
and we generate that through into
different developer tools
so in terms of what an operation and the
swagger spec looks like here's one
example so I showed you in the console
the the web browser experience for
Oracle cloud infrastructure the way to
create an Oracle machine in the cloud
right this is what that ends up looking
like in a swagger spec it's very close
to our real definition of this operation
so you can see at the top there slash
instances is the path to the operation
post which is the HTTP method used when
you call this over HTTP and then it
declares the parameters you pass launch
instance details in the body declares
the responses that come back in this
case we're showing the 200 you know
success response and what will come back
then an e-tag an instance model and the
thing on the right here is as you can
see we're kind of referencing models so
the launch instance details body isn't
directly in line in that operation we
just kind of have it another thing that
that swagger Yamma lets you do is kind
of reference things so we have the
launch instance details model that you
would pass in this operation in a
different area in the spec and you can
see there it models all the different
properties you can pass the availability
domain all of our cloud regions have
multiple availability domains for
scalability and availability fault
tolerance purposes display name the
image you want to use for that instance
any metadata you want to send through an
eye pixie script etc and it declares
which parameters are required as well
and if you add descriptions you can put
the descriptions on each of those fields
and then the rest API Docs the Java SDK
Docs et cetera can pick up those
descriptions automatically so in in
terms of what the sun's like ends up
looking like
this is what our REST API looks like I
have to navigate on this screen there
you go so this is the launch instance
operation and you can see again it's the
post on slash instances there oops and
if I can scroll down here you can see it
takes a launch instance details as the
body right you can click on that and
there are those same fields right and so
all of this is generated which really
cuts down on the time to write
documentation because it's it's the same
documentation in our SDKs for these
parameters and in our REST API Doc's and
then other tooling right other things
so in our Java SDK for example
this is the class that was generated for
for that a model from the swagger spec
launch instance request and so again you
can see down here if I click into launch
instance details you know all those same
fields that were kind of declared in the
swagger spec all right here as well
right and the types of them things like
that so let's see if I can go back to my
presentation
I won't click into the Python SDK Ruby
SDK links but this PowerPoint should be
available you guys after if you want to
browse through the CLI as well as
generated you can see that's the
operation that gets generated for create
launch instance in this case so now I'm
going to pass it over to the Tia's to
actually show you a demo of us taking a
swagger spec doing some work in it and
then generating an sdk from it Thank You
Jill so I've prepared a few pieces of
code here I think this might actually be
a little bit too big so I overcorrected
this is the sample that that we're going
to use it's written in Ruby we just sort
of randomly picked that and the first
thing it does in in this line it loads a
configuration file that specifies what
region you want to use what user what
fingerprint all of those things and then
in line ten it creates an identity
client which allows you to create users
groups policies all kinds of things
related to identity and then I'm calling
this print number users method which is
defined above here in lines three to
seven and all I'm doing there is using
that identity client to list the users
that we have and really what I'm
interested in for this demo is just the
number of users that are being returned
so I'm printing out a number of users
and then it's going to be the length of
that list being returned from the OCI
identity service now I'm returning to
line fourteen here and this creates a
new user
it's called Oracle code user and then
some unique number and it calls the
service and gets a user ID back and then
I'm calling the number of users again
and then
down here I'm deleting the user and
printing the number of users again so
what would we expect this output anyone
something like maybe 10 11 10 or
something right we're creating a new
user we're incrementing the count we're
deleting it so it should go down again
let's see what it actually does so
it's running our demo oops I must have
I just have done something wrong
I think we've got network problem there
a long time mmm let's see how do we fix
that this is why I think Chris's talk
was so brave oops the the earlier talk
he actually did everything live see
the browser's working right because I
was able to use the browser before snow
maybe bear with us
should I just talk through what the demo
would do well you're working yeah why
don't you take us into the the the other
evil surprise the one that we had
actually planned see if connecting to
VPS oh well well
Matthias briefly rain/storms us what the
demo would be showing if we can get it
working is that this API that is listing
users and creating a user than listing
users and basically outputting the count
of users before and after there we go
I don't even have to tell you so that
does not look what we actually expected
right it's 25 25 25 we created an
additional user where did it go so this
was this was the the the flaw on the
demo that we actually planned for not
the the problem with network
connectivity so to skip the debugging
what actually happened here if we look
at our source it did return a list but
the list was too long so if we do a
little bit of debugging and we look at
our operation for example it does return
the next page and so the way the cloud
service worked here is that it just
happened to return 25 users and it said
there's a next page and we didn't check
it so since we're just interested in the
number and we don't really want to page
through maybe there's a different
approach that we can take maybe instead
of doing the paging we can actually
request from our friends with the
identity team that we could set the page
size maybe if we just get a thousand
users all at once then we could do this
demo this way so let's simulate this
this this talk basically we talked we
talked to our fellow team they agree ok
we're gonna make a spec change and
because I'm not as brave as Chris in the
earlier talk I'm just gonna uncomment
this and make the demo a little bit
easier for me let's actually take a
quick look at this identity client this
is what's automatically generated so
this is the
the method or the function that's being
called to list users here's the path it
puts together query parameters
compartment ID and page pages the thing
that we're not using right that should
that would have given us the the the
next page some headers and then this is
making the rest call and we get some
data back so now that I've actually
changed the code of the spec are our
co-workers from the identity identity
team they tell us okay we made this
change now you can set the page size so
now we have to regenerate this identity
client or I mean we could make manual
changes but then we've got all of these
n times M times whatever boxes to fill
and that that gets old very quickly so
instead we use swagger and we regenerate
and we've got this hooked up behind
maven which is a little bit of a
discrepancy between Ruby and and Java
but since swagger is written in Java
this actually makes sense
so we've regenerated the the source code
and let's actually see what the client
looks like now so now you notice there's
this additional limit thing that we can
set here so it takes compartment ID page
and limit now let's go into our example
and here we type in limit for example a
thousand and let's try that again
so let's run our script again
84 85 84 so this is what we expected
basically whenever we realize that maybe
there's there would be a nice feature
that we could add to one of the services
we have this negotiation with a service
team they give us a new spec and then we
rerun the code gen we don't have to
write this stuff ourselves with that I'm
gonna pass it back to Joe thanks
Matthias so that was a great example of
kind of taking a taking a swagger spec
that was missing a feature a feature a
user might want such as being able to
specify the page size which we call the
limit parameter in this API the service
goes implements that limit parameter
service side they update their swagger
spec to say we now take this new
parameter we hit go in our generator and
suddenly all of our different developer
tools support that new parameter and so
swagger is really useful for that
because instead of the developers on the
team spending all this time having to
understand new features that are coming
from services write the code manually in
every single language debug manually
written code for errors we just take the
source of truth provided by a service
team on what their interfaces are and we
generate that through so it really saves
us a lot of time and effort and allows
us to with a small team support a lot of
services very quickly and a lot of
different developer tools SDKs CLI etc
but like everything in life nothing is
perfect and so there's some things we
ran into ran into a swagger that weren't
as good so one one thing is you know
when you're using a code generator if
there's something that you want to fix
you can't just modify the generated code
to change how it works because the next
time you're out the generator that will
just get overwritten right so if we
wanted to add modifications we'd have to
build a layer on top we'd have to modify
the code generator itself to produce
generated code that maps to those you
know custom modifications if a certain
operation needed to be exposed in a more
simple way for example another thing we
noticed is while swagger is open source
and is really great we when we took
swagger code gen for some of the
languages we wanted to support it
actually would have
cause breaking changes when we add a new
parameters so for example positional
parameters in the job SDK the way
Slugger was exposing them was I think
like an alphabetical order so if we had
a parameter a and a parameter C in the
signature definition and then in the
future a parameter named B was added to
that operation suddenly what the user
was passing for C previously is no
getting passed in for B right which is
not the users intent so we had to we
changed our templates for that we use
with swagger code gen to use builders
the Builder pattern where every
parameter is specified by key the
specific name of the field and then the
value as opposed to just a position so
that was you know one change we made on
top of swagger to make it more robust
and reliable and and not breaking as we
add more and more features to our
services another thing which Matthias
actually mentioned if you remember he
said well it's a little weird here I'm
working on a ruby SDK but I just ran
maven most Ruby developers probably
don't use maven day-to-day but swagger
is written in Java you know it can be
used through maven it can also be used
to the CLI but if you wanted to run the
test for swagger that's of course using
a Java specific test framework so what
it means is someone if you want to get
someone to write your Ruby SDK they now
need to be familiar with Ruby and with
Java right they need to be able to
understand meta programming Java Java
tooling like maven and you know the Java
test suite tools j-unit etc so it means
there's a little more required of a
developer than just knowing the tooling
and the language of the SDK itself that
you're building the other thing is we
share the code generator among a number
of languages and so it's possible then
when we make a change you could actually
destabilize something in the generation
of a different language a different SDK
so we need to be very careful and make
sure we have robust testing to make sure
it isn't changing something for the
worse in another SDK when we make an
update to the code jump
so another thing we do that has proven
very usable is open sourcing so most of
our developer tools and oracle vitae
infrastructure are open source on github
the Java and Python SDKs for example the
terraform provider chef and I plug in
the CLI the go SDK very soon when it's
release will be as well and the reason
we do this there's a lot of reasons but
one is just one way to scale more easily
is to get the to get the community
involved in actually finding issues
identifying them making fixes right so
in addition to that we also get to use
github as a platform for answering
questions github also has ways to make
it users can watch your repository to
subscribe to an atom feed to know when
there's a new release of code so when we
release a new version of the SDK anyone
who wants that new version can just be
notified automatically through email or
through RSS feeds and things like that
the other big part is creating advocates
for your products so someone who uses
your product and has a good experience
sure they may tell their colleagues and
Friends you should take a look someone
who is actually a part contributor to
the product is a lot more likely to
advocate for it because it's it's partly
their creation as well it's not just
something they use it's something they
help build and so by putting things on
github we're both getting contributions
from the community and creating stronger
advocates for our products it also is a
great way to identify hires so the
Oracle cloud infrastructure team as you
saw it grew from 300 to 1200 in about a
year and a half and that means a lot of
hiring so one way to really test out is
someone a good fit for a team if they've
been making contributions to it on
github they're probably a good fit
other things I didn't mention archived
releases so every release in the past is
just stored there in case the user wants
to get an old release and metrics so
github will actually give you download
fork metrics as well as actually page
view metrics on every part of your
repository including every source code
page so just to show you briefly you
know clicking on the terraform provider
that talked I mentioned earlier Cubert
kubernetes kubernetes on Oracle cloud
infrastructure used terraform who's
familiar with terraform in the audience
a little bit so terraform is a
declarative tool for saying this is how
I want my cloud infrastructure to look
and then you hit a button to make it so
and you don't have to worry about all
the imperative steps to get there you
just worried about make sure it matches
the send state so our Tara phone
provider is on github you know as are
many of our other developer tools and
you can see that it has you know a lot
of Watchers and stars and forks and a
healthy amount of issues and pull
requests and and close pull requests as
well 207 closed right so we really have
a vibrant developer community able to
contribute add to and advocate for our
products thanks to github so going back
to powerpoints
but of course there's some Gaughan's
some cons with open sourcing as well so
one of them is actually when I I
mentioned earlier which is
if I'd swagger one we've been working on
right now
we just released kind of the the SDK is
to see lies the end things we generate
and so what that means is some pull
requests we get while there's a lot of
the SDK that
and make changes
and so basically what we do there is
kind of treat that polar quest as a very
specific this is the problem I have and
this is what would fix it right and so
then we go and we make the same change
to our code generator internally such
that when it generates code it generates
the same kind of thing they've written
then we merge in their change then we on
our next release push our updated code
and so publicly their contribution stays
there in the commit history and the idea
the spirit of what they've added stays
there as well well there might be a
little bit of a diff what our generator
produced there and what they actually
proposed in the polar quests they're
still contributor to the SDK or other
developer tool some other things we want
to do is we want to keep things private
while they're meant to be private so we
have services other developer tools
other features of existing services
coming where we don't quite want them to
be known about publicly yet for example
competitor reasons so we actually keep
the source of truth for all our
developer tools internally and then we
push them out to github when we do our
public releases and so we have a
whitelist file so that we don't push
everything out we don't want to push out
so some of that is maybe tests that use
sensitive keys or you know I IDs of
resources that we don't know up publicly
and just files we don't want to show up
publicly the reason we don't use a gate
ignore for that is we do actually want
them stored in our repository internally
we just don't want them stored on github
so it's it's not quite the same as a git
ignore which would exclude it from all
source control tracking and also so what
do we do then if we're hosting
internally and we push out publicly what
if someone makes a change publicly and a
change internally right how do we merge
these source of truth those truths
together and so it's definitely possible
to do and we do it but it requires a
little more finesse than just you know
what a public github repo would require
since we want to keep some things
private so we have to merge
and merge back changes since they can be
made in both github and internally the
third thing we do which helps a lot is
API consistency a great way to cut out a
lot of time you would spend on
implementing things is to make sure that
the services are consistent in terms of
following rest guidance in terms of
being consistent across services so for
example in Matias demo he showed
pagination right there was the page
query parameter there was the limit
query parameter to specify the page size
there was that OPC next page token as
the way you get the token to pass in the
page parameter of your next request when
you're doing multiple paginate calls if
all of our services were using
differently named parameters for those
or just sometimes it was in the headers
and sometimes it was in the body and
sometimes it was you know who knows you
pass the data in the query versus the
body versus the headers it means instead
of us having to write one paginate err
that can just make it very easy one
paginate err per language per SDK or CLI
etc for developer tool 2 that can
paginate all of our list api s and our
services we would have to be writing
many different paginate errs and in
doing so that's all manual code were
writing and so it could be error-prone
it just takes manual work to write write
another thing for example asynchronous
operations if all of our services model
asynchronous tasks the same way and then
we can build a way or a waiter that will
wait on a resource reading reaching a
certain state we can build that once per
developer tool across all of our
services instead of having to build lots
of different waiting functionality
depending on how the service changes to
implement exposing asynchronous
functionality asynchronous state
some other things so similarly to that
if you know our services are exposing
filter functionality again if it's
exposed the same way for all of our
services then we only have to implement
serializing how to filter how the user
specifies the filter one way to the
actual request to make the HTTP and with
all this actually there's also the fact
that it's very useful to users that they
just have to understand less if concepts
are consistent across all the services
there's less surprises to them things
are more simple which as we learned this
morning is very important
and swagger actually helps us with this
so it's important in itself and swagger
helps us get there because since we're
defining the source of truth in a
swagger spec in a file that can be
checked in it means we can code review
the swagger spec to make sure it matches
these semantics it means we can use an
automated review tool that understands
that format to run certain checks to
make sure they're exposing pagination in
the way we usually do and just following
other guidance we have
giving it back to Matthias thank you so
that leaves basically one problem area
and that was the multiple scopes where
we have internal internal preview
preview and public and really this is
probably the thing that we struggled
with the most at least recently one of
the earlier approaches was using
different branches in our source control
so we had a release branch we had a
preview branch and an internal branch
and then we told developers on the
service teams if you want to make
something internal only branch of
release make your change merge it into
internal if you have something that
eventually should go public then branch
off release put it into your feature
branch work on it then merge it into
preview so that we can release a preview
SDK and then at some point once it's
team stable merge it into release but
that didn't always happen really there
were some features for example that were
just so small maybe or so easy they were
just made into release immediately and
then a little bit later once a team
comes to us and says hey can you
generate the compute preview SDK or
something like that they see that there
are some things in the preview SDK which
is generated from the preview branch
that's missing because in some ways
maybe the preview branch is ahead when
it comes to these feet the secret new
features but it's actually behind on
other features that are already released
publicly and that's because the Bret the
branches were in kept in sync so that
was really a problem
another thing sometimes features were
merged into release and we didn't really
have time to write good documentation or
examples or to test it so as SDK team we
weren't quite ready to include that in
our SDK our release SDK but because we
automatically generate most of the code
we didn't really have much of a choice
anymore
if it was in the release branch well it
kind of had to go out so what we came up
to to solve that were these custom Flags
that we added to the specs so if we
found something that we didn't want
released then
these the spec writers on the service
teams can you please include this
preview only flag or this internal only
flag and that allowed us to later filter
it out but it also created churn because
basically whenever we wanted something
excluded we didn't own the specs we had
to get the service team involved they
made the change we regenerate it and
then later once a preview feature was
actually stable they had to remove it
again so they actually had to make two
changes and also it didn't help at all
by with simplifying the branches we
still had these three branches that were
always out of soon could seemed so I'm
gonna skip some intermediate things that
that we tried that helped a little bit
and show you what we're doing now we are
including conditional blocks in r-spec
which means our spec is actually not
necessarily a valid yamo file it's a
file that gets pre-processed it's really
similar to the C or C++ preprocessor and
then it generates valid swagger so we
have if def if not def else and end if
and then a number of of files of white
lists that enable different kinds of
features for example at the bottom the
the left file that you see that could be
the release white list it just has
feature 1 in it so whatever is marked up
with feature 1 would be included and
release but the blue and the orange
snippets they would be filtered out for
release for preview for example we could
add feature 1 2 3 which means now that
blue blocks get included in preview they
were filtered out before and an internal
we add feature 4 or 5 6 so it also has
the the orange area and one of the nice
things about this approach about having
these conditional blocks is that we can
we can write files that don't
necessarily have to be swagger swagger
valid for example what we couldn't do
before was have two different versions
stuff documentation what this example
does is in in release it just says
description create a puppy for the
preview one it actually says create a
puppy the puppy
might already be potty-trained thanks
for the examples by the way Joe I like
this this is this is something that that
we can do now and we can also easily
have any number of white lists if we
need to have some different release
channel we just create another white
list for it and we can have some kind of
different way of filtering which also
means that we are decoupled we don't
have to ask the service teams for
changes anymore so we we can decide at
the last minute let's filter this out
because we're not quite ready with it
yet and also because we can now say this
is included this is not included we can
actually go back to one wrench which
probably solves the biggest problem
we've had just because the the branch
has always got out of sync I do have to
admit that there are some downsides with
this and we'll see how how bad they get
there's sort of more complexity on the
one hand the files are invalid Swaggart
anymore so anything that expects swagger
now needs to have this preprocessor in
front of it and there are a lot of tools
there are some tax checkers there's
tools to generate our clients all kinds
of things visualization tools so all of
those need to be hooked up now another
thing is sort of conceptual complexity
when you read this now you have to say
well if is this enabled is it not so
that might be something that that we'll
have to keep in mind because otherwise
these files would just continue to grow
so at some point we need to clean them
up but at least the way it looks like
right now this approach is addressing
the two biggest things which were how do
we keep the branches in sync we'll just
have one branch and two how do we filter
out things without having to
inconvenience the service teams and
that's actually the end of our talk and
I think we've got a little bit of time
for questions yeah I think that's that's
pretty much the N one thing I want to
mention is the best way to scale a team
to meet this kind of demand really is to
hire more right and so if this area is
interesting to you building products for
developers metaprogramming
interests in a lot of different
programming languages
please come talk to me and Mateus after
please send me an email we are hiring
and we'd love to add more people to the
team thank you any questions we can take
yes
all souls
so the question was how do you keep the
SDK in sync with the swagger spec since
developers may go and modify the SDK is
that the question so I think the first
part of that is not all of the SDK is
generated right so parts that they might
may add to like adding paginate errs
awaiting functionality or new forms of
authentication right that those parts of
the SDK aren't generated so they don't
get overwritten when we generate again
outside of that I mean if they were
gonna go and add a feature like support
for a new parameter really the service
has to support that for that to work
right and and that means if they were
adding it and it was already supported
by the service really the service should
have been adding it to the swagger spec
since it is something that they support
right so I'd say that the write process
for that wouldn't be for a person to go
and add it to the SDK which takes effort
it would which takes you know some
amount of effort it would be for the the
service team to add it to the spec which
takes less effort and then means we get
that change that that person made
instead of just in the SDK that they
manually wrote code for we get it in all
of our developer tools at once because
we can just head generate and if it is
something that's more focused on the
client and and the customer makes a
change to the generated code there then
we would take this sort of as a as a
very detailed feature request modify the
templates from which they're generated
so machlin the specific request the the
user made rework it so that it goes into
the code generator and then we can
automatically generate all the files
again and that's something that we've
done in the past as well just added that
a little we wouldn't necessarily decline
it what we do is kind of after we had
made the Associated code generator
change that would produce the same kind
of thing they'd written we would accept
their pull request and then we would
merge in our newly generated code which
might make some slight changes you know
versus what they had made
but essentially keeps them in the commit
history and to them seems like oh I made
this contribution I was trying to make
and that's why he manages an AI code
because he is much friendlier to people
also because I don't code as well as
Matias that's the other part of it any
other questions
all right well thank you guys for coming
hopefully the talk was useful to you and
we'll hang around for a bit if you have
any other questions Thanks thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>