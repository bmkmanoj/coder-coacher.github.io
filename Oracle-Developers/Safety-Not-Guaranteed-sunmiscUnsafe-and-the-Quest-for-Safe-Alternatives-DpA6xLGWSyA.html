<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Safety Not Guaranteed: sun.misc.Unsafe and the Quest for Safe Alternatives | Coder Coacher - Coaching Coders</title><meta content="Safety Not Guaranteed: sun.misc.Unsafe and the Quest for Safe Alternatives - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Safety Not Guaranteed: sun.misc.Unsafe and the Quest for Safe Alternatives</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DpA6xLGWSyA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so thank you for attending this
talk it's actually more attended than I
expected would given the subject so this
is obviously people are interested so
the talk is titled safety not guaranteed
some miss gun safe and the quest for
safe alternatives as my twitter handle
you can tweet me if you want and hassle
me about this and others so i encourage
you to ask questions as I go along if
you want to ask something but if we deep
dive we'll take it offline and there
also some my esteemed colleagues in the
audience as well if I don't know the
answer I might actually ask them to help
me out okay so i got this title because
i saw this little gem on the internet
now you can't read that but this was an
advert put in a a bi-monthly journal and
it was a somebody to go back in time
with me this is not a joke p.o.box free
to to oak view CA 930 222 you will get
paid after we get back must bring your
own weapon safety not guaranteed I had
only done this once before I love the
last two sentences of that but it's sort
of related to me we're working on them
say you know we're not going back in
time but we might be going into the
future and you can bring your own
weapons if you want to but I think bring
some cunning and some deviousness and
some understanding about hotspot bits
out assembler code and you can start
your journey so I have partially done
this before as you will see but there's
links to this if you want to find out
where it actually comes from is actually
fantastic paper okay so let's get
started so unsafe vs Java culture I
think it's actually before I start how
many people have used unsafe okay
it's pretty good I've used it to how
many people used it for fun just for
poking around and working out how what a
spotters that's good too yes this very
very interesting way of working out how
things behave by poking around I think
Java developers rely on safety I think
it's part of the core culture of Java
and if you go to John roses blog who's
sitting down there here at a very good
blog on Panama but at the end as an
appendix there's this whole list of
stuff about what's java's culture and
that's written in the context of going
native has a different culture to javas
culture going native it can be a bit
scary bit unsafe I think on the safes or
straddle a bit of this it's an
understatement that this is important I
think you're not supposed to worry about
seg V when pulling in a library from
maven central or memory corruption or
something like that this this safety and
this culture enables a whole ecosystem
are likely this is what makes java
successful so when you start to use
unsafe you have to be very careful about
what you do I think because this sort of
it sort of rubs up against java's
culture so for those who don't know miss
an internal class within the JDK issues
inside and unfortunately outside of a
jdk often for good reasons not necess on
not so good reasons but we never
intended it for outside use but we never
really tried to enforce it we sort of
stuffed it in a in a package that didn't
look really official it's not public but
we didn't really enforce the boundaries
so people started using it as well as
lots of other stuff that we didn't
intend to be public but it's used by
many popular libraries and applications
how many people say use extreme for
example use extreme objet assess mock
libraries anything that uses a mop
library probably uses of Genesis stuff
like that they are very popular
libraries out there which will build
this tower of usage Finkle and guava for
example we'll use it under the covers in
some case
so functionality wise you can peek and
Pope memory pick and poke at memory off
heap you can define instantiate and
check initialization in classes you can
park and pot Fred you can as memory
fences and there's a bunch of a minor
stuff there might be more in the future
we might remove stuff from here in the
future but it's inherently stuff that we
need to do in a jdk to get the job done
but but up above you don't see this all
you see is a nice safe Java culture
world it's a very sharp tool even in
vance developers can get things wrong or
assumptions can change and perhaps some
developers don't care about this and
then many other pitfalls especially
around security and serialization every
time we do a new feature in Java we ask
you so what about security what about
serialization and it takes CPU cycles
for us like this we have to think about
these things carefully so question you
can see this code is this code safe this
is from a patchy Cassandra project so
it's it looks like what's it doing here
is its setting up some offsets up above
working out minimum length and then it's
looping over some minimum words times
the number of bytes in a long and it's
doing unsafe get long one off at one in
one buffer and unsafe to get along
another at different offsets and it's
going to do a comparison what it what it
wants to do is take two byte arrays view
them as Long's and compare them as
Long's rather than bytes for efficiency
so is this safe who thinks it's safe
well man I walked into that one didn't I
bucks do you think that the developer
who's calling whatever this method
contains this codon do you think that
the actual method is implemented
sauvetage safe as a whole no
up to seven bites can be outside the
boundary why is that ok so there's
carried down below which caters for that
that case so anything suspicious about
these offsets it's a constant okay this
the answer is it is now but it was not
before february2014 this would cause a
crash on solaris sparc and it's been
there for at least two years now but you
could ask who's been running cassandra
on solaris sparc we've been using this
perhaps not many perhaps true but it's
been fixed in one 1325 you can see the
bug in the code diff like that now do i
say why okay but reason why is because
spark has a different chip architecture
to vex 86 and it doesn't support
alignment on any sports alignments on on
particular boundaries like 32-bit 64-bit
it doesn't support alignment on the bike
boundary for loading along on a bite
boundary and if use B's offsets can be
any offsets here they can start it off
set off set 12 free not 0 for the start
and so forth like that so this causes
issues on spark what about this one in a
similar vein this is from github a
project called slice exactly the same
problem address + index get long index
that indexes can be naught 1 2 is might
not be a modular and might not be a unit
of 4 or 8 or something like that so that
is unsafe to does not count for
alignment a native byte order there's a
pull request rotated on october2013 but
the developer says i think we should
just say slice only supports
little-endian machines he doesn't care
but actually I am I ran into the
developer at java.lang to have a lengthy
em summit and was a little bit
embarrassed but because he goes oh you
wrote that and he goes oh no I'm so
sorry he said no it's great so but he's
in a sense what they want to do is just
make it run on x86 platforms but what
they should be doing is making it not
work on nonet xe6 platforms that don't
support the right alignment issues
that's so he's not on the band he
doesn't really care just if you try and
run this library it will build barf and
throw an exception before you start
using it properly or something like that
but I found that interest is sort of
proved my point later on here's another
one I was talking about this with david
holmes on the bart today to make sure i
know what i'm talking about somewhat so
here's a class in the jdk atomic long
and so we have a set method so we have a
field called value which is volatile and
we have a set method which updates that
value using volatile semantics then we
have a comparing set but underneath
users unsafe to do the compare-and-swap
Long Valley is that is that code safe no
you know the answer button but there's
volatile there do we need to synchronize
it okay does volatile it is a tama cop
atomic I think volatile on longs is spec
to the atomic not when you do what yes
right so you're doing an operation
directly on the field and you're doing
an operation using unsafe and the two
don't talk to each other properly that's
my understanding of the issue at a high
level so we had to so this was safe on
all mainline openjdk platforms but not
on platforms not supporting compare and
set of 64-bit values so I think PowerPC
32-bit was at the environment so this
issue very i think is fixed at to check
so the thing here is plez can shift over
time so what we thought was unsafe even
for us can shift over time when new
platforms and new architectures arrive
and in fact there's some gnarly issues
even underneath the unsafe hotspot code
which is actually had to be fixed to I
think related to this
so the situation is we would like to
stop outside use of them safe if we can
because i think it undermines for safety
guarantee is offered by java project
jigsaw will enforce this but I say we
say this in slides with input this and
slides there will be a get out of jail
flag that you can use so we're not going
to pull unsafe from under the rug from
you immediately because I think that
would be an affair because we can't
replace all the functionality we want to
place over the period of Java 9 java 10
or the future whenever will be ready
with certain features so why is unsafe
in the jdk it's really for like low
level of the n based features which are
often intrinsic and je na is a pain in
the backside project panama to a rescue
in the future i think some good work
going on there and it's kind of it's a
bit vague to save is kind of for stuff
not directly expressible in byte codes
so it's kind of call it with glue
between the j and the vm is for stuff
you want to do in between like this and
i think maybe there's going to be more
of this going on in as we sort of push
more java semantics from hotspot up to
the VN like lambda forms and stuff like
this this is probably going to increase
this little glue hoonjae and the vm
there's some future things I sort of
picked out as examples you might be
interested in looking at how people
might add stuff to unsafe in the future
so there's been a lot of really good
work on improving lambda forms vladimir
ivanov has has been doing some excellent
work improving au 40 and he's got we got
some experiments for improving even land
reforms in the futures he's
experimenting with user level profiling
to improve how lambda forms get get
compiled and in lined and stuff like
that so you can see he's added some
methods to unsafe for that so you can
see how they if you really interest in
this type of thing you can see how
unsafe is that dumping ground for kind
of unsafe stuff or not so unsafe stop
depending what we put here's another one
we had we had a chat on our internal
chat lists about unsafe chopped array
imagine if you wanted to shrink and
arrayed it if you ever created an array
and you want to return it out
and but the array is never the size you
want and you always have to you have to
chop it down a little bit and he have to
do that by copy so it just creates a
memory chair and sofa like we should
have a chopper rate perhaps in there and
that's kind of unsafe you don't want to
be chopping your array while you're
iterating over it and stuff like that
good thus knows what might happen so
let's nix / I'd like to have time to
actually add that as an experiment so
we'll see so developer distinctions so
there's this nine million Java
developers is that is that marketing
number is it real I don't actually know
let's say marketing is an order of
magnitude greater than the actual number
just just to say thats caso SI is 1
million java developers so that it is
10,000 9i was a nine hundred and ninety
thousand java developers don't use have
never probably heard of and have no need
to use and say i think it's probably
more than that i think I think developer
conferences are not necessarily
representative of the average Java
developers out there in the world so
this one percent of Java developers use
and say there's probably smaller but I
suspect higher in this in this audience
for sure but this is one percent often
right widely used libraries like I
saying of Genesis extreme guava
Cassandra stuff like this but so much of
that is also used transitively by the
developers don't use unsafe mostly
without knowing it so this one percent
mix so we categorize the different
developers who use unsafe here so
there's developers you think they need
to use it but probably don't really need
to it's cool there's lots and lots of
blogs showing how you can use on safe to
do cool stuff but you shouldn't really I
suspect advanced developers with a
genuine need but don't care about
cross-platform safety now that's not
really fair to say that on the slice
stuff they do care about people who
might use it in ways but it they
shouldn't use it so they'll stop them
early but that I tried to use that as an
example here but I think I'd be mean to
categorize them in that and then their
advanced developers have
genuine need and want to align with the
Java culture so that's a good example of
the Apache Cassandra they fixed it so we
want our methods to be unsafe even if
we're using it underneath the covers and
then there's the developers working on
the JDK itself openjdk developers myself
other people people who submit patches
outside of Oracle they OpenJDK community
you work on it so I'm going to poke the
bear so this is the bear is a grumpy
developer because I'm taking unsafe away
and we poke him and he wakes up and he's
grumpy so that's our strategy here we
say unsafe is going away in sides and
that and it gets people's attention wake
up get noticed and you say oh no I am
particularly grumpy about this so I'm
going to say we shouldn't focus on
developers who think they need to use it
but probably don't in crazy stuff
advanced developers are generally don't
care about I don't think we should focus
on these I think we should focus on the
bottom to the developers who want to
line with the Java culture and
developers working in the JDK itself so
what about these advanced unsafe
developers I think they're often pushing
the boundaries of whether and how the
JVM is used you know a high frequency
trading is an example for really pushing
things are running up to the amazing
things on the JVM really pushing this
this platform to the edge in a sense
they're often vocal and innovative and
they develop really popular libraries
how many how many people have used
disruptor you know about it it's not a
hugely popular one but in in the
environment where you want to use it you
know it does the job extremely well and
they're good for the java community as
well they're pushing it in ways where we
see you know and there i think they're
they're really useful to have on board
and on site so when we say we're moving
on say we don't want them to go away so
we want to provide alternatives to help
them do their job so i sent out an
unsafe survey a while ago just to get an
idea of what people are doing with it in
what ways so i don't have the full
survey just have some snapshots here so
one question i asked is do you have an
optional dependency on unsafe to ensure
code is portable
across multiple platforms so yes is
thirty percent no is seventy percent
that's not good is it if you look at
guava and stuff like that bae an extreme
de haber they have a fallback if unsafe
isn't there that's the way you want to
use unsafe safely and be conforming with
job as culture that's how you should cut
it up if there's an awful lot of people
using em say who are don't have a
portable solution yes well what was that
yeah I think there's an unsafe piece of
glass is just about to fall from the
ceiling okay get ready to catch him
it's over your head too though thank you
okay sorry question oh yeah so the
question is not just a comment is that
oftentimes the mechanisms that are
supposed to automatically tell whether
they should fall back to that safe route
as opposed to use on same are actually
less safe than the unsafe go ah
interesting very often these grow haha
they don't write it correctly yes yeah
it is also because certain but you don't
test on all platforms and sometimes you
don't detect it properly yes yeah I
should also say that other platforms
also provide unsafe for interoperability
and so this is sort of an ad hoc I think
I bm's platform provides it is that
right John yeah so so what's this
because if there was a safe unsafe
standard some way imaginable I'll turn
ative for your use cases at least would
you be prepared to replace them safe
with that alternative and if so under
what conditions so that was add your
stuff so if there was there would be yes
for an almost ninety percent and no for
the others well we can't do much about
the nose there hardcore guys I don't
know what they're doing but just let's
ask this question in the audience so do
if you're using unsafe today do you have
an optional dependency on it some do and
the end and the others who has no
optional dependency on it okay medium
it's not it's not correlating with this
and what about this one if there was a
stand a safe standard would you switch
your code to use it for those okay rad
correlates I would too but not for the
JDK because it would be have a circular
dependency anyway
so the use cases when when you can pick
a poker memory you can do almost
anything you want in certain cases you
can do crazy things and there's some
really good reasons why you want to do
this as a library called Java object
layout written by Lexi ship laughs and I
think that uses on safe to poke around
look out memories laid out and that's a
really nice tool to use to see how how
things work and that would be a use case
but i'd like to see still supported
somehow perhaps we should substitute
those tools into the jdk themselves I
think the use cases come down to two
things performance and working around
restrictions limitations so performance
wise like blake brian guts as comment on
performance if you just write your code
well most of the time you don't need to
worry about it but there are good
reasons why you might want to write
perform and contort it using unsafe and
i can imagine the contortions that
people do with it so we can characterize
these use cases it's a very broad thing
but we can sort of we can sort of slice
it up into different use case in
different sets and then we can tackle
each bit independently and some sooner
than others so we slowly over time we
evolved ap is for safe alternatives to
unsafe under the covers step-by-step so
here's more of the survey here asking
for particular use cases so we see a one
one of them may ask was atomic access to
fields and array elements such as
compare and swap about forty four
percent how many use use unsafe for that
okay what about off heap memory
operations okay as yep d serialization
hacks okay yep it's not correlating
again fencing operations which rent
which were introduced in eight so maybe
it was not oh there's one guy there
doing fencing well an access to private
fields that's kind of related to
serialization in some sense so as you
can see there's
but any use cases they're not on there
that you use unsafe for yes yes i would
say that is the serialization hacks but
that is a very common use of use of
unsafe array access with bounced without
bounced checks yes this guy over here is
using unsafe for everything and as other
so I think that covers the main usages
at least then yes oh yeah I wanted to
remove that I'll talk about that bit
later so we there's really free general
cases here I can think of one is off
heap one is enhanced atomic access and
fences and we have D serialization and
serialization I bet one of the bet wisin
JDK I think we can split up the offi
into further cases reduced GC efficient
memory layout very large collections and
communicate across JVM boundaries I'm
sort of setting this up later on because
it fits very nicely later on with what i
want to show here so there's a use case
to feature mapping here so there's this
doesn't express all that's going on but
enhanced atomic access we have a jet
called 193 enhanced volatiles we working
on so all of the cases of port ordered
and lazy puts and stuff that this
compare and set all those people not
using atomic field reference sub data
and stuff like this foot and that we
have a jet for that I'll talk about in a
bit we have a jet for serialization 20
we need to reiterate and revisit that
reducing GC we have something called
value types you may have heard Brian
talked about four on the community
keynote yes
maybe maybe there's a slight necessity
to refocus the afternoon because what
your first two as a DC organization is
actually being used for and safe for
that is typically more on kind of
lightweight reflection that doesn't have
to go through the initialization process
from JPM classes so you know it can be a
lot of things that use like sample
objects or abscess pencil can be a lot
of things so maybe there's room for a
shall we say smaller domain than 007 so
you want to split serialization up into
two or more use cases is that what you
say yeah yeah i think there's various
serialization to those a lot wider than
just focusing on say replacing unsafe
and extreme with a safe alternative
perhaps i think there's as wider use
cases there for sure yep reducing GC
value types brand talked about that but
he talked about it the second time not
the first time because it got yanked off
stage now is interesting there's the Red
Hat Shenandoah low pause you see I don't
really know much about that but builds a
presentation java want today on that but
also say there's lots of incremental
improvements going on in g1 to try and
improve this to efficient memory layout
value types raised to the zero project
palomar and stuff like this so it is
tackling these use cases and very large
collections the same thing and
communicate on that there are you can
see a roadmap going on for the next you
know for eight years which can slowly
tackle all these problems that people
are using unsafe for so strategy put
features an unsafe use them in the jdk
identify the features but really belong
in a java program model pull them out
add support for them and theoretically
garbage collector stuff we don't need
anymore i think we need a
carrot-and-stick for this we have an
idea I can't can't talk about it just
yet but removing functionality can hurt
would you you'd be pretty fed up i guess
if we removed unsafe without replacement
yes how many people were really angry
not just grumpy but terribly hungry yeah
we need to make it easier for library
and framework developers to migrate
gradually say from release end with
unsafe to release n plus one without and
try and provide two together so
hopefully we can mention a bit about
that sometime soon in the future so one
area i showed in that table was a jet
193 enhanced volatiles check my time ok
so the idea here is to provide safe
perform an enhanced atomic access to
field and array elements but without the
dynamic overhead that's currently there
with atomic update array classes how
many people have used these atomic star
up data classes and then do you still
use them would you use unsafe for both
of them depending on the performance
characteristics you switched over yeah
what we did to and while Doug Doug Lee
did at least he didn't use his own
classes he created and Doug legs
performance yes so and it depends on
Java one JEP 188 the Java memory model
update so they're connected there's
going to be a refresh of that to make it
I hope what comes out of that is
something that that's actually more
human readable more understandable 22
more ordinary developers like myself
because I read that and I'm scratching
my head and the fact Alexei ship lives
done a great job of explaining this in
in a set of slides which is really
really good so I hope that can be
improved so the if you look at the
memory model at the moment doesn't
specify what their Kaz's or anything
like that so it's day egli worded in in
a documentation of the atomic classes
and stuff about so we need to we need
two more clearly specify what that means
so I had some I set myself some success
metrics for what might this might be at
least at the first stage for a prototype
and I thought the API should be at least
as good as what unsafe offers today the
performance results should be close to
unsafe and faster than the atomic start
classes otherwise no we'll use it and
you should be good enough to replace on
safe uses in Java util concurrent so
that means not just performance in micro
benchmark cases but
almonds in cases where it's used in say
before join library and stuff like this
so you got to make sure it when you're
calling these methods that everything in
lines is expected and so forth like that
so here's the strawman proposal on the
jab so the idea would be we would come
up with some syntax volatile prefix and
here's an example of usage I have a
violet Island count and I want to
atomically increment it and so the idea
would be you would do count dog volatile
incrementing get but count doesn't have
a field bullet alders that looks kind of
strange so this there would be an
interface associated with this with an
increment and get but we're not saying
how its implemented so it's a bit of
magic going underneath the covers java
sea would have to know how to translate
that into something we call under the
covers do you how many people like that
you're okay with the magic there no yes
be interesting to see because we are
searching for solutions i'm not
particularly happy with it cuz i think
is a little bit too magical myself but
yes yeah we have a we have yes i looked
at the keywords we could use and none of
them really fit as except is if i go to
count go to incrementing them we could
revive that yeah I dear yes so is there
anything else yeah so it's sort of this
volatile prefix introduces a scope if
you like and its scope to interfaces and
it requires language changes but you can
still ask question what should be under
the covers what should be the
implementation of this what should drive
it java sea translate that too and would
it bat on its own be sufficient and is
there a weighted essentially I'm asking
is there a way to do this about language
changes because language changes are
even simple ones can be a lot of work I
think I think Joe you'd say that with
project coin even the simple most
innocuous language changes can
big hard work so but we can still build
the lower layers and then decide how to
expose this out later on so it's not
we're not stopping this from happening
so there's two alternative proposals
I've looked at so far one's called
method handles and we heard of EFT
handles how many people heard of bar
handles okay whew we're good so a method
handle is a reference to an underlying
method to constructor or field it
doesn't have to be only method and you
can use it to support volatile access to
a field you can actually if you look at
the getter and a cart meant the exact
names now there's getter and setter
associated methods to get a method
handful to update a read and write of
field and it inline surprisingly well I
have if you want to sort of see some
deconstructing of method handles and
have the basics in line there's a
there's a document we we added to the
OpenJDK wiki called deconstructing
method handles which goes into it to see
how it works how the implications work
and that I used this to understand how I
might implement VAR handles but might I
like method handler because they're
cunning and this is my black adequate
I've come up with a plan so cutting you
could stick a tail on it and call it a
weasel I think that is and the
underlying things about how method
handles work and how they all link up in
that is is rather cunning and that's the
basis of how invoke dynamic is built on
top as well so it's a it's very
interesting stuff
so with some tweaks you can support
other kinds of access through method
handles it's very easy to change the
code to call unsaved compare and set and
stuff like this under the covers in the
method handle code it's not too tricky
and I think that's a it's actually quite
well written and generalized so that
it's very easy to do that but there's
there's kind of an issue API wise this
is coding for joint pool today using
unsafe so we want to update something in
the fork join a work queue array since
you've got a rare for joint tasks and we
want to pull one out and start doing
something with it so we have to do the
shift and base of our index to work out
what the offset is in our array so we
want to get a full Joint Task out of odd
array at the index be so we shift it by
the the amount of each element and we
and the base for the array header and we
call get object volatile on it so we get
it out and then if it's not know we want
to we want to compare and swap with null
and then we update some counter and
we're using the the lazy set to make
sure it doesn't get reordered with other
other loads and stores I expect other
people who've used unsafe this looks
quite familiar so this is what it fear
might look like with method handles
first we have to either add afros fro
Abba laptop because the invoke exact on
the method handle froze throwable
otherwise we do try catch gymnastics we
don't need to shift and base anymore we
just need the area lymph MSM be because
we know the array is a power of two so
we can we can we can mask it by the
length minus one and then we call a
method handle we've obtained and is in a
static final field we call invoke exact
on it so we have to name things by the
name of the field to know what's going
on with our actual operation here so we
call it get under school get all the
time it's the same for compare and set
we need a cast cast of the boolean
here on the compare and set invoke exact
we had a cast of a null for a full join
cast for joint ask if you look at the
deconstructing method handles it you can
see why that's the case why that casts
these casts are required so that's how
many people like that would you use that
as a replacement for unsafe Pudden you
do use that already as a replacement do
you like it interesting right but you
wouldn't if you didn't have to do that
ok ok so my my opinion this is the API
is not as good as unsafe in in this
respect it doesn't reach that goal to
meet performance results these micro
benchmarks and I think in the way in
lines and everything are actually are
actually pretty good I think you can get
close to unsafe and probably almost the
same as if when we fix hotspot with
certain micro optimizations and how
indexes are things are strength produced
in terms of index bounced checks and
null pointer checks hanging around that
shouldn't be there in certain cases we
can probably generate almost the same
assembler code as calling unsafe itself
which is quite promising so of our
handle instead so this is an abstraction
of safe access to a memory location it
could actually be on or off heat if you
wanted it to be so we're leveraging
method handle invoke intrinsics and some
misc unsafe under the covers so you can
think of this as method handles for data
I talked about the current prototype in
the current current prototype solution
we're still looking at other solutions
but this is a current one which is
working we're using to investigate the
performance characteristics and what
goes on under the covers and how we can
optimize there's video and slides that
BJP MLS which goes into more detail
about this so the idea is we have one
abstract class and there's many access
modes one per method fenced atomic has
many access kinds one per instance
like static instance field array of heap
and many value kinds princess like
object ref or even in the future we
could have composite values for value
types they like a complex value type of
something like that and yes it gets
interesting when you want to cows on a
composite value that's a greater than
128 bits or some pressure we need STM or
something about there's lots of things
we need to investigate around that area
in the future for atomic operations on
composite values so here is the code for
bar handles I have a patch on line you
can say the VAR handles colored is in
Valhalla let me just show that the
Valhalla code base here is the actual
VAR handle class you can see it and it
has a bunch of methods on there which
leverage the current you leverage with
polymorphic switching mechanism and
method handles so you don't you see them
as a object array uggs varargs here i
tweaked poly sick too not always have to
return objects so it's a bit friendlier
and especially it becomes friendlier for
for the comparing sets but notice these
aren't statically typed in that sense
and yes so I have a patch let me just
show the location in so there's patches
online so here's a VAR handles document
you can read also find out more detail
it's in my OpenJDK area I don't have
network access oh well you can look
around nevas patches for the code
snippet i'm showing here i've updated
java.util concurrent classes for joy in
another of a concurrent class yes
good question so this is the magic of
polymorphic signature methods they are
our odds but Java Sea is told to
actually the signature of this is
whatever you pass in and Java Sea will
encode it as as the signature of a
method so avoids voids boxing if you
look at the deconstructing method
handles it goes into how it shows the
bytecode and shows how that works so
that's the clever trick that's going on
to avoid the boxing devious trick
actually I think or coming actually I
think so this is the bar handles on we
don't have to name the bar handle by the
by the operation we're doing we just
have to name it by the thing we're
operating on like the array here so we
don't need the again we don't need the
shift and base we still have to cast to
encode to tell Java see what's going on
what's the return type there we see
compare and set doesn't have the cash we
still have a cast of Nolan for joint
task but that's but I think that's
better than method handles this much
there's no throwable either in that
sense I so cleaner usage they still must
be static final fields for things to in
line and stuff like that but that that
is getting us further along as a
prototype I think the API is at least as
good as unsafe I'm kind of biased by I
think that's case and the performance is
good too so the question is is this capi
we should expose out and we're still
exploring we're still looking for other
cases but a problem with polymorphic
signatures and this is we have to bake
another thing in the spec saying this is
this is another polymorphic signature
thing like like a method handle and
questions is there a more generic way we
can do that the question is can we do
that for nine it would be nice to try
and get this thing's in earlier rather
than later so we're still searching
around for for opportunities so if you
come up with any ideas let me know I'll
be really interested so low hanging
fruit
so this gets on to life someone sorry I
don't know your name to a gentleman over
there at the back bear was saying he
wants to use monitor enter monitor exit
and try monitor enter so I looked on
them grep code and I saw that I was only
one pun there's actually one use but
it's only for java 6 is jboss modules
and it uses it to work around some I
think some class loading issue but
nothing else uses it but the danger is
if I talk about it people find the thing
to use it for some I'm going to be as a
danger here no one is using you accept
this gentleman over there in the back
but I would right right I would I want
to remove them I think we should remove
code that's not used because it just
makes it harder to refactor other stuff
I fair fair around but not there's one
actually but I live there is one use
case and we're actually using it
ourselves in a jdk test which was
recently added but as a better hat to
work out how to remove it so there are
reasons why you might want to use it as
it on john told me it's kind of like
breaking the glass in an emergency it
comes useful in that in that sense once
and once in a while you kind of find
this is useful but i don't think it's
enough used to justify them being there
there's a lexical bites compare byte
array comparator we could add something
to raise or byte buffer or something
like that so we cover the guava case
exam dication of a question is do we
just a bite but then people want can I
have the char can I have the long habit
in so you might have to add a whole
bunch of things just to be consistent of
all the types we have but it's not
difficult to do this is not difficult to
write but I think it will cover a nice
set of use cases if you have any point
type use cases we'd be very interested
in hearing them to cover cover some of
these types of case can anyone think of
any now but you'd like to see no so
that's it and I've got more covered okay
what the time is there
so in conclusion some misc unsafe is
going away may be accessible from the
jdk jigsaw is going to enforce
boundaries around modules for the first
time the but there will be a
get-out-of-jail card flag for you to use
which i think is important so safe
support features a plan that will
replace common and safe usage and i
think it's important to express this is
in line with Javas culture that i'd say
that is exceptionally important thing to
preserve going for exerts hasil is what
has made java's success exercise now and
a success in the future so i conclude
with legal safety for people who are
going to take my future projections
seriously be careful okay I'm did that a
bit faster we go but we have a fair bit
of time for questions if you want to
just ask questions comments feedback and
so forth okay
she already subsidizes with your
relation to a circle I'm a very good
Morgan country and it makes me a little
shaky buceta because we really need to
accentuate any object and support
promise and we are not involved what
heroes over them I know how it's used by
many libraries like that you made
specific languages and live reason
basically want to separate the type from
from implementation drama cloth houses
so you want basically construction of an
object without calling its constructor
yes should be allowed my opinion yeah
there's two different audiences what
you're saying for this so you've got the
audience of the tooling where safety is
not so much important and the audience
of production where safety is more
important in that case hmm not sure I
want to differentiate the two in that
sense and we should provide one solution
that works across both I think it very
hard to detect that a production library
is not pretending to be a tool and
getting it getting and getting under the
covers again we do have some ideas about
how to expose out AB larval type of
object which you can sort of set stuff
on the men say pupate and you're ready I
think there's a connection here between
final fields as well because often the
things stomp on final fields and we need
a way to control that without part the
problem is final fields aren't really
final we actually want to change that
but we can't move forward then as a
connection with the serialization here
and stomp and mate and in a larval state
we can actually set final fields until
we play there we go and then all fields
are final afterwards so we there's
actually interesting connections to
other features we might try and attack
on with this but it's a it's not an easy
problem to solve and we're still looking
at this it's still early stages to look
at how to solve these use cases but we
are looking but I'm not sure we can
cover everyone's use case mocking I'm a
I don't like mocking myself
sorry could I remember rich hickeys
quote those mock objects are mocking you
in there so I always remember that I
that doesn't mean that other people
shouldn't mock their objects ok any
other opinions questions yes which
versions of are you talking about
versions of Java on Oracle's jdk or
openjdk or cross cross different vendors
j decays as well yes this is so the
question is how do i how do I use unsafe
in n say java 8 and how do i use the
equivalent of unsafe in java 9 now that
the something has been removed from
unsafe so the answer I didn't really
talk about where Z see if i can find
thee i have the slide some my carrot and
stick if i can find it there we go so we
have a solution I just can't talk about
it yet and it'll be even so it's all
there if you work it out but we're just
through just we just not ready to talk
about it but it's at least under video
stuff like that talk to me offline and
that it's something working and
hopefully it will provide this solution
ok any other comments questions
the jigsaw in the minds of our system is
going to do checks at compile time it's
going to Deesa news today that Kate
you're not alone ancestors packages so
obviously so if you're at a library
using unsafe it's going to complain and
say do that so that's easy but then
everybody else that's using that library
suppose you invoke the magical override
switch do they now have to also invoke
the magical or right switch for the
right yes basically it propagates
transday if you've got a library 10 deep
inner in a grotesque maven dependency
hierarchy yeah and you run your
application has bad in there you're
going to have to put that flag on that
it would be nice to have a tool in maven
to tell you in your application that
warning you need to set this flag and
theoretically we could actually work
with a maven community to actually make
that happen when the java or Gradle and
so far i think or even java sea we could
add something to Java Sea might be worth
thinking about but yes it's going to
cause some pain yes any other questions
comments so the question is does this
flag allow you to focus for checks on
particular packages or particular
classes or not i think mr. Alan Alan
knows far more details wethersby saying
yes in a sense cuz Islands mr. jigsaw
here so he knows he's in dep yes there
will be control of it in fact we have to
use these types of stuff 45 white box
testing and stuff like that is that
right so there are genuine means for
white box testing of stuff which isn't a
separate I you don't want to put it on
the boob classpath or or something like
this where you want to get in a monkey
around move stuff for for genuine
reasons like that so that's why that
flags bear as well any thoughts final
thoughts no okay so i just say in safety
we trust us going forward
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>