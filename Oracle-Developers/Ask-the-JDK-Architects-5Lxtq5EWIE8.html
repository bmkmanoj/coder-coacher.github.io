<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ask the JDK Architects | Coder Coacher - Coaching Coders</title><meta content="Ask the JDK Architects - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ask the JDK Architects</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5Lxtq5EWIE8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">first let's do introductions I mark
Reinhold I work on Java ryan gets my
convince Ted John rose okay so though so
Michael and John are sort of more vm
guys Brian of course is mr. lambda I I'm
a generalist and they're actually all
general general it's two to one degree
or another so this this is my only slide
this is our only slide here we are it's
an opportunity for you to ask your
questions we don't necessarily promise
to answer them depends on the question
but we'll try our best Sam you have exam
all right that's always our goal on pots
are making life for my creators recently
yeah I'm wondering you is that Robert we
really need them why do we have them
what do I lose if I just
so so for those of you in the back room
Sam's question is he has been seeing
lots of articles lately about people
having pain with stack maps when they
when they generate byte codes why do we
have them what happens if I just turn
off verification and can maybe we get
rid of it's not a fair summary I'll take
that one of although we don't have
anything to report like movement in that
area in jdk a right it's not been art
our attention but the historically the
reason that's gone in is to remove in
theory at least a pass of a verification
make the verifier faster so that you you
you know the difference in the if you
look at the vm spec it says it's the
difference between the type checking and
the type inferencing verifier with type
checking the stack max give the types
and and let them be checked in a pass
whereas with type inferencing the vm
itself the verifier has to build up the
types and then sort of check them as it
builds them up there's I don't know I I
don't know even though if I could report
a performance benefit for for doing it
this way but it either we did measures
you know marginal performance benefits
when we put the sin in six yeah and I
think if we if we used it if we
exploited it a little bit more maybe we
get more more load time performance but
it's still of course faster to load
without verification how many people in
this room load without verification to
get faster loading in product in
production yeah how many people care
about
how many people care about how fast
their stuff loads in production ok so
it's an order of magnitude more people
that are willing to still verify even
though they care about speed of
verifications and that's it generally
the sense you know exact people go to us
right I this thing called X verify it's
a relatively new option but you can you
can look it up on the helpline he asked
how many people know about this option X
verifying none so I think generally our
philosophy is run like crazy be really
fast but don't give up security and type
correctness and if there is some way to
give up security type correctness make
it not the default and give it give it
to you guys as a as an option and you
know a few a very few of you care enough
to find the option and turn turn off the
extra type checking feature and it's in
theory all of the bike codes that you
feed your vm are already verifiable so
you don't need to Rivera Phi them again
but there are advantages to checking
things that you assume and that's what
we do by default if you're feeling shy
you can tweet to my twitter handle and i
won't reveal your name but we'll see
your questions i also i also recommend
the the object web azum toolkit which is
which we use inside of our tea jar as a
wonderful way to ignore the details when
you want to and it will generate stack
maps for you most of the filter
generating at runtime where so now what
by taking that out of the out of the
bear fire and sticking it in the ASM
code like yeah come on that's pretty
much it yeah right but anyway please if
there's the next question we will
continue to dive into verifier oh look
at the hands going my colleagues use
encoding method that is metros de terre
from string two bites of ice cream so
this is that lady echoes can be this
before but there are several methods in
the summit API for example the area
rectified reader swing invites use fring
taking bites it has five artifact we
Herzog and the don't take encoding
parameter in the favorite actor Paul is
basically as fast because if you have
the wrong
the coding against corrupt data and most
developers don't know about this
understanding coatings so my question is
could you please
I did this yesterday there was the eye
of all I mean the one thing that is also
something missing is the capability to
pass white buf herbs or this kind of
things because right now we have to take
the back butters copy them to buy a
raise in then do the conversion or well
we're just going to use various channels
that was the whole idea sorry got go use
go using our families use the charset
and then create the encoders and
decoders way but for example it's a more
cumbersome way of food things like it
would be reusable to add a new strain
Wi-Fi popper oh oh oh I see question
that would be easy said such horrible is
that it's awkward to operate to
transcode between byte buffers and
strings that was one of them another one
was it was general complaint about some
of them the old file file IO api's like
file reader and filewriter don't take
care set specifications so one can
inadvertently wind up dropping things
one can in and vertically wind up
depending upon whatever the the runtimes
and you that the default character
encoding is and it might be different at
some other point and that causes bugs so
you should just be required to specify
that you really want iso 8859 23 rather
than whatever you're running with right
now okay so you can blame me for file
reader and filewriter those were amongst
the first classes I ever added to the
platform that can one not one I no
argument they could be easier to use
they could be they could be there could
still corners that we could we could
smooth out yeah it's a perfectly
reasonable idea to have additional
constructor
that would take a care set you also I
doesn't feel like the sort of thing
that's so radioactive and on fire that
it's the that it's worth pestering
people with warnings it's not like it's
not like yeah that's not how it happens
to way down the line as it's bugging a
distance and what is what you end up
doing if you end up doing what I ASCII
files on your tests and stuff yeah then
somewhere you have three libraries away
so when someone uses that against a Mac
Roman file friend like that for someone
to put a smiley face in it yes they get
Brett and at that point like you
actually have to fix like several layers
of api's it does happen every company
okay fair point but we'll take a look at
it all I'll listen to the recording here
in Thailand are Fe and you know I don't
think it can happen in eight we're
trying to be done with a how many people
would be hurt if we or object if we made
utf-8 be a sort of overwhelming default
for for single byte character encodings
whoever's objecting was drowned out by
the applause who puts to be to be fair
who would object okay there's another RV
I'm going to find the default character
set in in Java 9 is utf-8 hmm you want
something else asked for that's a
Shannara fee it's not a Hanuma Betty
will start working but Stephen were you
wanting to add something but this
based event
yeah that might be useful documentation
he wants to party going up what actually
have the whole body like you to fight
what you have is a global variable right
yeah or should a random in a very small
space okay look a question from Twitter
can we have tail calls please John can
we have already answered his hands have
been above the table oh I am he's
tweeting to me it's under an alias good
this i paid someone this is the this is
an important recurring request and we
are actually making it's one of those
requests which no giant corporate mont
you know monolith gorilla sized
customers saying you must give us tail
calls right now it's not like a security
bug not to have tail call it's just like
a recurrent bad cold not to have tail
calls so but we have been making
progress on this guy steel in his
keynote at the JDM language summit how
many of you were there they talked a few
of you talked about this that and and
and and went over again some of the the
modern rationales for doing it if you
look on the wiki openjdk java.net you'll
find in the hot spot or ml vm area
you'll find new content on how to do
tail calls and how we how we hope to do
it so we are actually thinking about
this and making progress on it i think
as of two years ago we the IBM guys and
I talked during a 292 meeting about this
and we figured out how to how to do this
in a way that respects the security
security mechanisms of the JVM and
that's like one of the hardest thing
yeah that's that's kind of the hardest
last piece except for sort of now we got
to put it on the plan and get everybody
sort of lined up that
new tail call so at this point is sort
of the last thing is to just say that
we're going to do tail call tale called
automatically done for you in the vm so
the question is it am i talking about
what i call hardtail calls or soft tail
calls soft tail calls are as as
appropriate the vm puts them in for you
and that's a that might be reasonable
but the thing that that people need when
they really need it is hard tail calls
which have guarantees that you can do a
loop without blowing the stack and have
I looked at scala's I've looked at some
workarounds I don't remember the details
of scholars something that declares the
Softail cause is interpreted a phone and
it will break if they can't do it like i
I'm just wondering like what will be the
mechanism that you'll oh you look at I
have like a five or six year old blog
entry proposing how to encode tail calls
and Eve and work with the semantics
minus the security part at that point it
wasn't figured out look at it basically
it involves a byte code change involves
putting a prefix on the on call
instruction saying this needs to be a
tail call and that's separate from the
question of would it be and how would it
be surfaced in the Java language right
so this is a you know strictly a vm
question at the ephah at the lowest
level and then there is a separate
question to be asked about how any given
language would surface the ability to
demand a hardtail call said the language
architect who has to field all the
public comments on every semicolons with
the language change
people show who this care about the jdk
man feels like a good opportunity to
find out like what people would like to
see ya like for example my yeah I think
I feel like the thing that I'm still
missing that was one of them so that's
good and the other one is sort of local
type inference I mean is that something
you guys think about the okay so the
question is a set of Sam as it is asking
are we thinking about improving local
Thai print for inference for nine so um
so let me make sure I understand what
exactly you mean by that because
different people mean different things
so are you simply talking about being
able to say def x equals blah VAR x
equals blah have the compiler and for
the type and not make you specify the
manifest I've their logo right for low
for local variables okay so number other
languages have C sharp has this Scala
has this this this is not technically
difficult this is not technically
difficult all right so this is whether
or not to add this as a language feature
is really purely a philosophical
decision so historically our bias has
been towards more type inference at the
U site without applying type inference
at the Declaration site so for example
with the diamond feature we did in Java
7 you you still you say you know a list
of string l equals new arraylist diamond
right so at the U site we're allowing
the you know the user to say you know to
not have to type those again but on the
left hand side of the Declaration site
we still prefer to ask the user to
specify the type because the natural
consequence of inferring all those
declarations as you end up in a program
you can't tell the type of anything
without asking the IDE what's the type
of this and so there's a lot of
information capture value that typing on
the left hand side has that isn't
necessarily present on the right hand
side so our bias has been towards um
full type declarations at the
declaration site but then not making the
user redundantly specify it at the use
site its target typing its target typing
on hence you know the improvements and
type inference that came in Java 8 so I
mean not only the lambda specific stuff
but there have been improvements to a
static method type inference where you
don't have to say list dot bracket type
empty you can just say list you know
blissed-out empty and and and so that's
been our focus but it's mostly
philosophical question
continue to require people to import
pheromones are very least repackaged
version of ASM so they don't
because it so the question the question
is we're using a as him ASM internally
in jdk 8 is there any intent to expose
that for use by application code yeah so
presumably the goal of exposing it for
use by application code would be so that
people could rely on a specific azum api
being available do you really want to
run the Azam's ASR book because that's
basically what we would have to do to
truly expose it in a support in a public
way and that seems like both more
overhead than the asthma guys want to
take on and also I think slow you know
slows down the improvement of the you
know the evolution of the ads of a p.i
so
method handle
what is the preferred way the tools
standard interaction hi Rene style
sister or something for generating less
than perfect way the access
so lately let me try to repeat the
question the I think the question is if
you're using method handles to do some
reflective type a computation what is
the preferred way to access fields from
front method to handle code he wants to
have a non nominal non nominal access to
Fields well you don't name the fuel II
have a capability that somehow gets to
the field value and he wants to know
whether it's still good to use Java
java.lang.reflect.method.invoke method
handle for a field i would say for
fields method handles are lighter weight
because the fields the access checking
is done when you create the method
handle instead of when you access the
field although you can you can get
around that by doing set accessible true
on the on the old-fashioned reflective
thing and so then at that point it might
be it might be a wash because they both
boil down to something really simple you
know an unsafe access at offset 12 with
a cast it also depends if you're jenna
if you're generating bytecode directly
or you're going through the java source
language so if you're generating your
own by code you can put the fields in
the console you can put method handles
to field accessors in the constant pool
and they'll be verified at class load
time whereas if you do it reflectively
deals in that case can your method
handles access private fields or do you
have to turn off verification so if you
have method handles in Brian's point is
very good you can have method handles in
in the constant pool which which has
some advantages compactness 41 and
static checking for a check ability for
another but it is the case that there's
a good sorry there's a strong parallel
between whatever bytecode behavior you
could put in your class file with an
explicit get field or invoke static or
you know one of those bytecode behaviors
whatever you can do that way you can do
with the method handle and vice versa
but neither one is really a superset of
the other with respect to access control
and therefore the constants in your
constant pool can't refer to somebody
else's private methods or fields so if
you're doing a framework you probably
unless you're you're tuning your
framework to have each class define its
own access or hooks if you're doing that
then it's great I would I would I would
use the new api's and bake it into the
bike code if each class has a chance to
be generated with his own access you
know persister hooks or whatever if
you're doing it at arm's length
reflectively then I've been probably
either one either option is fine
although the method handles you know
they they you don't have to turn off the
accessibility hack okay a quick question
from Twitter as Java continues to evolve
are you considering breaking backwards
compatibility between versions yes
absolutely
so when one simple example is in in java
and java jdk a we have done a bunch of
work to prepare for having a truly
modular platform in java nine so we
actually have an internal model of how
the jdk will be sliced up into modules
we've done a lot of work to to make that
happen by eliminating bogus dependences
between implementations and and other
public API you know there were there was
no reason for Java util jar really to
depend on a WT there were a few things
that we judge a few these really bad
ugly dependences that we just couldn't
eliminate and and so our proposal and
this is actually in the java SE eight
early draft review specification our
proposal is that this list of i forget
it's nine or twelve methods we have
deprecated them in java 8 and then drop
a 9 they will be gone just gone not
deprecated and still sitting around but
gone related to that is if you're where
if you're aware if the work we're doing
in project you exhaust when we go to the
modular platform in nine we are going to
hide internal a p.i classes behind a
very difficult to overcome boundary if
you have code that's using you know some
misc dot cash or you know com.com son
internal organ xml about parser dot
internal your code is your code is not
going to work unsafe as well now i
destroy hello air let me finish the
story there there's a lot of code that
uses unsafe there's a lot of code that
uses you know some other things that it
really were just utility classes that
arguably should have been part of part
of a standard API many releases ago so
we've already done an initial corpus
survey one of my colleagues actually
sucked down all of maven central and you
know
did an outstanding to see well what
internal stuff our libraries in maven
central using and their libraries in
maven central to do reach deep in
difficult sup the xml parser and guess
what they're going to break and i have
no sympathy for the main themes of those
libraries I feel sorry for the people
who use those libraries and didn't know
about that anyway so stuff like that's
going to break but where there are
things that are more like utility
classes you know base64 encoder oh why
didn't we put that in the platform in
one that one and in that particular case
we actually made it a supportive API in
SCA that's already there and it's usable
on it and it will continue to be there
unsafe I think it's actually that the
time has come to promote unsafe into the
java.lang package clean it up make it
well specified so that all vm
implementers understand what it is since
in practical terms all vm implementers
implement it anyway and whenever you
know whenever we want to make a big
change to it we consult with you know
our friends at IBM so that they can do
the same kind of change and you know
it's just time to put it in job on a
line with appropriate security
protections around it obviously yes so
there are some examples of some things
that will break and I think I do think
going forward in general when there is a
good reason to break stuff we will do
that we will try our best to provide a
migration path when that's appropriate
but sometimes it won't be like if you're
reaching deep into the guts of the XML
parser don't do that and and just just
to follow up on what Mark said the the
key word is good reason yes right so you
know a lot of people when they say are
you considering making incompatible
changes probably have in mind things
like let's get rid of checked exceptions
the you know because we don't like them
because we think they're silly what's
there which they are but that doesn't
necessarily rise to the level of the
reason right so you know the bar for
making changes that is going to break
people's code is really high we really
try very hard not to do this the amount
of analysis that went into let's see if
we can do this in a way that doesn't
result in incompatible changes was quite
substantial and ultimately you know we
came to the decision no we're going to
have to break some things we have these
good reasons it's going
be stretched out over a long period of
time we're going to have to notify
people so it's you know don't interpret
this as are we throwing compatibility to
the win that's no that is not to take
away here right existing code that uses
standard language features and api's you
know must continue to work on future
releases a is due warning involving at
least one feature release ahead of time
that something is going to disappear
yeah you know code that uses API that
was never part of any standard you know
we've been telling developers for 15
years don't use them so you know the
chickens are going to come home to roost
roost at night right and i'll just add
very quickly that if we look at the data
can or very specifically at the JVM one
of the reasons we would like to
deprecate and remove stuff there is my
favorite example would be the nine or so
garbage collector combinations we have
right now it's just not you know
possible to maintain that many garbage
you know there's room for more than one
that i think we can agree on but nine
combinations is pushing it so at some
point it's just if you extrapolate and
we just add functionality constantly
then clearly we we won't be making
progress a few years from now so that's
another example of
not now and really follow
I
devel other girl was it
turn on it
enforcement I was worrying about your
thoughts
so so so the question is I started using
jetbrains I'm using their nullable and
not malleable annotations and I call it
in love with them and then there's also
a way that I can get those to be
enforced at runtime that when it went
running tests and so forth are there any
thoughts to making that part of the
platform yeah so our story here um is
largely based on a new feature that's
being added in Java 8 which is a part of
the jsr 308 annotations on type so i'm
not sure if you rode with it but the it
has it has two parts the the part that's
visible in you know in the language
surface is being able to put annotations
on types so you can say not just list of
string but list of at non null string
before you couldn't put an annotation
there so there we've expanded the set of
places where you can put annotations
basically any naming of a type in a
generic type parameter or 80 throws
clause or catch clause etc you can put
annotations it hasn't quite gone as far
i know some people are thinking what
about expressions no we're not doing
annotations on expressions that's
something else the primary purpose of
being able to do the annotations on
types is so that tooling can implement
what we call extra linguistic type
systems so for example no ability
checking can be thought of as a type
system it's not a type system that is
part of the Java language or enforced by
the Java compiler but an analysis tool
can do all the same sort of analysis and
you know and detect failures you detect
water amount of typing failures and
similarly you can do taint analysis you
can you know and how you can do range
analysis all sorts of interesting things
with extra linguistic type systems the
people who have that have been
responsible for JR 308 this is a JSR
that was led from outside of oracle the
spec lead was a professor at the
university of washington has a companion
project which is outside the jdk but
open source called checkers where he's
implemented type systems for a dozen
interesting things including null
ability no ability checking is actually
very complicated there was an effort in
jsr 305 to put together some standard
non null annotations this started six
seven years ago
and basically this beckley there gave up
because the complexity was overwhelming
our plan though for using these type
systems is because the machineries in
the language but the type checking is
outside the language the you know the
ecosystem becomes sort of an
experimental laboratory for people to
figure out which type systems work for
them and then we can you know look at
the innovation that's happened in the
wild with development of various you
know extra linguistic type systems and
decide which of those make the most
sense to now pull into the compiler and
allow you to allow you to enforce it
directly from within compilation so
there's kind of some enabling technology
and eight for that and then a pipeline
to let these things be experimented on
outside of outside of the language and
then pull into pieces that work
so the question is why not just make the
annotations now and worry about the
implementation later the problem is not
the annotations we can put any
annotation we want the problem is if we
put an annotation in the JDK we have to
specify it has to have semantics about
what it means you can't do that until
you figured out what type system you're
implementing so unfortunately that's not
something that can be done early okay so
a note I'm reminded by I think it's
somebody in the room on Twitter I should
have had two slides the other one is the
Oracle legal disclaimer saying that you
can't take any of this no just just
imagine another slide here with five
round if there's one thing you cannot
take any of this as a product commitment
is our commitment to strip any feature
in any particular brilliant future
product yada yada yada other but there's
no it's not too late part there's one
saying the preceding is not to be the
preceding and receding and the following
right yeah we're allowed to use two
forms the preceding the following just
assume it covers the whole thing sorry
no I don't was somebody in the room
would do well that statement does not
fit in a tweet okay somebody new
actually not ready stop using the stock
using mouth I go stop using knowledge
and use option you know that do you have
the stack system that tells you if
somebody can be now so cannot be now you
suddenly candles can it can be hard if
your weekend without the 31 is a big
planet as a function of P if he can
never be now it's a week so you are
beating the deposition you don't need
any fancy notation just abusing power
now this is the biggest miss fame ok ok
so the observation we want me to
summarize for the recording the object
observations is it hang on is-is-is
nullahs bad use the new optional class
or wherever you can waiting one
developers a very very strong personal
opinion switch on the costly
a switch on class literals what would
such a switch to sweet show you don't
junkies be one then it's as we chose
that don't like we have switched on
straight now why don't we stop there oh
oh the so the switch stay oh the switch
statement on class literals rather than
then then just strings where's the water
right was it that could be one or two
questions it could do you want to simply
due to exact equality on the type or do
you want to do subclass inclusion which
is basically a pattern match right Davey
if you say if you say case list we will
never match anything if you're being
strict because nothing is of type II is
from of ESA if object case of be the
class maybe a taco sweetness and then in
that block of the the casebook I know
that these are key probably i would like
to the me to 12 you are exquisite cast
eco because Abby beverage be cool okay I
think we get the use case and I'm not
going to try to repeat it Jared he wants
to upsell strings in switch to pattern
matching right yeah yeah okay I'm
question from from Twitter mca's
suffered since apples stop supporting
Java for example file chooser can't see
network shares will Oracle support mac
and future will last i checked oracle
supports mac today and is committed to
supporting it into the future if there's
a bug in file chooser not seeing network
shares then we should fix it so please
file a bug if you haven't done so
already yes sir
patience is truth there only three for a
handful baked into the young so the
question is are is it true that there
are only a handful of annotations that
are part of the java SE eight spec yes I
believe yeah this is a handful like a
deprecated and yeah there's not very
many deprecated suppressed warnings
overall functional interface uncle
enterprises a new one is view kazoo is
that a problem yeah yeah okay all right
somebody who hasn't asked a question
Stephen always has good questions
my company you are too
fast they did
they go fast but
though you got three things
Aaron contrast and ladies
receiving or
ok so the TLDR the question is packed
objects value types enhanced Jay and I
all seem to be addressing some similar
problems compare and contrast what
future do you see so I'll start I
suspect on will have something to say as
well so there are really sort of two
clusters of benefits you know in the
technologies that you named so one
cluster is about better memory
efficiency and locality so if you can
have objects that don't have headers and
don't have identity then you can put
them in registers you can put them on
the stack they don't have to live on the
heat you don't have to pay the cash miss
penalty when you dereference from an
integer to get its in value etc so that
so sort of one cluster of benefits of
these approaches is simply better
efficiency don't waste memory on object
headers don't have as many in directions
don't spend as much time pointer chasing
don't use the heap use the stack use
registers instead the other cluster is
Native interop and so better jni is is
one aspect of that and packed objects
also includes having a much stronger
control over the layout of the fields in
your object so that you can have an
object that you can overlay directly on
say a packet and have you know have
everything just show up from you know
from from at least from my perspective I
think these are like two completely
different features packed objects plays
in both of those spaces but I see them
as having different benefits and
appealing to different constituencies
and really being almost completely
orthogonal so you know the the the
better jni which has been discussed as
you know a possible jsr Charlie nutter
has been talking about this he gave a
presentation of JB I'm language summit
on that is something that could be done
entirely separately from value types or
from packed objects you know that so
there are a number of approaches to get
to one of or both
those goals you mentioned Fortran also
and that's that's it that has some
interesting interactions around the
around the edges with this these areas
of concern and their their interactions
that can't be gotten rid of one of the
interactions is type complex that in in
Brian's summary that fits into the
packed objects bucket but it really
doesn't go it's like there's a there's a
third or bucket or another half bucket
which has to do with dealing with
classic types that ought to be a ought
to have been primitives in Java but
never were so like 128 or 256 bit vector
type of some sort or type complex
everybody knows type complex and
everybody knows you can't do complex in
Java at least a complex of two doubles
you can try everybody's probably written
a class that did it and then sort of
gave it up because the performance
characteristics were uncorrelated avah
to grow new primitive types or garbage
collectors that are so fast that you
don't even notice them which we haven't
got yet or you have to work out some
scheme whereby the JVM allows certain
type so this gets into value types
certain types to be routinely scale
Erised up up into registers so you could
have a class complex but marked in a
certain way that you almost never see it
on the heap you almost always see it in
registers and that's that's sort of
that's not exactly packing but it does
fit with what Brian was describing about
getting things out of the heat so it
shouldn't be confused with a packed
object proposals it's really more like
scale Erised objects objects and
registers and we believe we believe that
we can make a serious oh there's a
serious Jeff out there which you've
probably read if you're interested in
this on value objects and and we believe
we can make a serious serious progress
on this in the next release or to which
the goal would be sort of a test case
would be yes can we do type complex if
we do type complex you can begin coding
with Fortran and then of course we need
some sort of a flattened
multi-dimensional array thing in order
a place to put them efficiently that's
that's the Rays 20 Jeff which is
forthcoming and there was a JVM language
summit talk on that last year so that
these these pieces are important they
break away in two parts one thing that
has been mentioned yet is reification
that's another maybe a fourth bucket of
stuff and tuples yeah and tuples tuples
are sort of a kind of scalar I zabal
thingy like complex the native interop
stuff is is very interesting also at
this year's JVM language summit last
year I talked about arrays to dot 0 and
value types this year Charlie Nutter
talked about the wonderful thing that is
jnr which is a java native runtime that
lets you interpretive lee i say
interpretive leah with emphasis get to
see AP is that that framework needs some
refreshing and adjusting in order to
make it compile able but it can be done
some of us have seen this sort of thing
done before I actually have a published
paper on it from the 90s pre Java so you
can you can take this sort of native
access to C++ pull it into a dynamic
language like Java interpret it and
compile it and be able to introspect on
it it's it's it's a soluble problem and
the jnr project has gone a long way
towards to show show plausible ways to
do it in Java we expect to see another
JEP on this and probably a OpenJDK
project this is very important stuff
that native interrupt working title
project Panama like that that's kind of
cute I don't I don't know what one
forced to name it but that's that's what
i think of it is right now and it has
the advantage of being a place name so
it's not a trademark issue okay a
different topic
Oh
after a while they try to optimize this
thing and they fail every time the
question is more generic
work or strategies along how to select
the garbage collector
okay sorry I think that the summary is
tuning is selecting and tuning all these
garbage collectors is really hard can
you please make my life easier right
yeah and I think so basically I think
this is this is not only the garbage
section i'm gonna say it's for jb m and
job in general what we obviously want to
make sure is that the vast majority of
work clothes there you should not have
to have any specific option set and yeah
you know there will always be a case
where if you want to get the last few
percent of performance out of the JVM
you will have to do something but again
I think this the philosophy in general
is make sure that the vast majority of
use cases would just work out of the box
it will be good enough i'm going to say
we're not there yet we have so again i
was not kidding when I said nine
different combinations I think it
actually is nine different combinations
we have I think four different kind of
frameworks major different garbage
collectors if they're going to say if i
can say that and the one we we're trying
now to get to the point where we have
one framework and this is the garbage
first orgy one framework that we will
implement our future garbage collectors
in so it's not just like one framework
or you know many we have not just one of
many different types of garbage
collectors internally we have many
different frameworks as well and that's
a big problem for maintenance and so on
so this will be the framework we use
going forward and then on top of that we
will implement different policy policies
if you saw well for the different use
cases you have realistically we will
never really know when you start up your
application if you're after
put or + x and Layton sees or and so on
so some amount of help you'll probably
have to do you know feed into some
knowledge feeding that into the vm but
again hopefully for the vast majority of
workloads it will work well enough
flirting and then the flip side of all
of this is for the cases where we can't
help you automatically I think it's
important that we make sure that it's
easy to understand what is going on
inside of the jbm so that is something
we you know we are continuously working
on it I think it will become even more
important going forward where because I
felt it feels like the world is becoming
more and more dynamic with clouds and
many JVM processes on the same machine
and all of that and I think it's it's
becoming more and more important to get
information out of the JVM I think it's
part of the maturation of Java that we
are running larger and more complex and
more diverse workloads and this means
that we have to up our game not only
with making small benchmarks run fast or
even large systems run fast we need
visibility into them and tooling and
this is this is actually something we've
been investing strongly and for the last
couple of years and will continue to I
modulo anything that the lawyers might
say well you know predictions about the
future this is important to us who know
somebody who hasn't asked a question yet
back there in the blue
so is there any plenty to add features
like the boss
full glasses
make sure
my field is their plan that keyword
glass is out for single men
question is are there any plans to
enhance the language to allow you to
express directly the notion that a class
should be a singleton or it should be
completely immutable so if there were
one or two of these patterns that were
so widely used that might be attempting
thing to do these things tend to be a
slippery slope right you do one or two
of them and that now you have 6,000
people healing up at your door saying
but this is my favorite pattern you
should add it to the language so it's
not clear that evolving the language is
necessarily the best thing to do there
that said what John was talking about
about about value types might might open
the door to some some of the things that
you're looking for because this would
elevate the importance and the
enforcement of immutability you know in
the programming model and might get you
some of the benefits that you're looking
for and so it's more likely that we
would evolve the language to support
interesting new ways of creating
aggregates that have you know have
different properties like immutability
as opposed to simply adding keywords for
a mutable class or you know
automatically generating certain certain
patterns I I think you'll be waiting a
very long time for like singleton patent
patterns support in the language you can
look at my blog from two marches ago on
value types and the VM and it talks
about design patterns that might
synergize with the vm for immutable
objects and the goal is to do what we
said earlier of be able to pull
routinely pull objects into registers
without special analysis ok do you have
a question still yeah go ahead
currently we use it for Tabitha compila
tappi budgeting tools doctor and we can
manage our way together to the jar and
what does reckon underway okay so the
question is where we're currently using
the compiler API that's found in the
tools a jar file in the lib directory of
a jdk what is the recommended way to get
to that API and and what will be the
recommended way after Java nine or as of
Java nine well the recommended way today
is to use the the jsr 199 i think it is
api to get yourself a a reference to a
compiler and the complete api behind it
tools jar will go away in 9 RTR will go
away in 9 so if you have code that's
going and growling around looking for
those jar files today would be a good
excellent time to start looking for
alternate waves ways to solve your
problem but the compiler there there is
part of the compiler api is not
specified in jsr 199 it's under comes on
tools java sea or something that that's
not part of the SE standard but we
consider that a committed specification
it is supported we actually do intend
that people use it and we intend to
evolve it in a conservative way going
forward so that that API will be
available in you know some module or
another when when we get to know no no
you should know
yeah they're so that so if you look at
the jsr 19 99 spec that defines the
drawbacks tools package and that has
api's in it forward get me a compiler
well yeah you if depending on what you
want to do you may or may not need to
use the combat son but whatever API if
you do that's okay because it's because
it's supportive it'll be somewhere but
it will be somewhere but it won't be in
tools dodge are all right ok whose plate
please don't raise your hand if you
haven't asked a question yet you've been
waiting for a while x value types that
so the quite a quite question was in my
keynote i mentioned that all this boxing
and pointer chasing makes it hard to do
big data well that was a very short hand
high-level way of saying we need
something like value types to eliminate
boxes and pointer jacek which helps big
data and and a bunch of other stuff yes
sir
where do we want to take Java 9 10 11
and Beyond architectural II what are the
broad strokes I think you know at the
highest level we want to continue to
evolve dry like you guys don't notice at
the highest level we want to continue to
evolve the platform the language the VM
and the libraries so that is it is a a
productive and fun thing for developers
to use so that it can continue to be the
basis of heavy duty you know production
systems that have lots of latency and
performance requirements and continues
to be to be dominant that that's that's
the highest level how will we get there
we will we will continue you know doing
what we've been doing much more of
recently which is continuing to learn
from other platforms you know some of
which are platforms built on top of the
JVM itself continuing to look at at the
history of research and computer science
and recognizing that yes there are good
idea ideas lambda that were that are
older than me and maybe it's time maybe
it's time to adopt them but you know but
we will always do so in a careful and
considered way so that we we maintain
you know Gosling's feel of java that's
that that's ultimately important where
you know we're not going to mutate Java
into Scala will we study Scala we
already have and adopt good ideas from
absolutely you know but we we want we
want Java to to maintain its its general
a sense of style because that you know
that is something that millions of
developers have have have found to be a
useful one so how's that guys did I do
okay yeah
you want to add anything any of you
Gilbert okay sorry what api's do we want
we already have lambdas we don't need
more I mean we've got the language
feature go make as many lambdas as you
want you're right a little bit you're
you're you're good I you know that there
there there are lots of ideas I mean
we've got some you can look at the list
of open Getty openjdk Jeff's the JDK
enhancement proposals you know for some
of the stuff that we're starting to
think about you know they're plenty of
other other ideas you know outside the
community so yeah I don't have any
particular you know pet api's I'm just
dying to see evolve there there's
certainly some dusty ones that are in
need of a refresh their sure certainly
some dusty ones that will wind up in
modules that I think most developers
will will never use korba
so yeah are there any plans to improve
the logging API yes are there any plans
to approve the logging so the logging
API is is a particularly sad story I I
was I was not involved in it at the time
but i but i know of history behind it
some of the history behind it i can't
tell you it involves corporate politics
so we have been well aware that many
people in the java community hate and
loathe the jdk is logging API we have
been well aware of its flaws for a long
time i I think that now that we've seen
you know there's any large for Jay and
simple logging framework for java and
this facade and that facade and I think
it's actually a good question to ask
maybe even four for java nine ok it is
is it time to open that conversation
again you know there's a lot of one
water under the bridge now can we get
enough people from the wider community
involved to look hard at java.util
logging you look at these other things
that a lot of people use and come up
with some enhancements to java.util
logging that would make it acceptable
for everybody because it's just stupid
that they're there 23 different 2942
whatever different logging frameworks
out in the world times the number of
versions thank you saying so no I that
that's actually a converse thing you
know if you want to examine an example
of an API that I think I think needs to
be evolved that's definitely near the
top of the list and so yeah I'm trying
to trying to encourage people to get
that conversation to open in the nine
time frame
what works being done to change
JPM's or lambda
what work is being done in the JVM to
support lambda and mega morphic methods
oh boy on right so some of the work to
support lambda was done in jdk 7 it's
called invoke dynamic and now that we
have multiple users of invoke dynamic
including project lambda there are
specific optimizations that in fact if
you if you look at our review channels
there's there's code changes out for
review right now in process for
improving the in this case the
bootstrapping performance of lambdas
this is something Brian and I have been
talking about for probably at least
three years and and the the kinds of
things we want to do is adjust the
inlining heuristics of the of the JIT so
that it tends to pull in the right
collection of collar and colleague
material the the the body of the lambda
and then also whatever Combinator is
executing the lambda in some particular
control flow pattern so you know that if
if you write for each in the new way
with the lambda body and a four and a
Combinator loop superstructure we want
to be able to routinely in line that do
the existing inlining heuristics which
can be traced back to Java you know one
dot to do those existing inlining
heuristics perfectly optimized these
lambdas no not yet this this will this
will be partly driven as it always is by
what customers do with their lambdas and
how what sort of code shakes we start to
see in the jet that are new so if
inlining is in lining is is maybe that
the mother of all optimizations for jets
once you make your good enlightened
decisions then everything becomes
visible within one horizon all your code
and you can then cook it cook it down to
what the user was was wanting to get if
you fail in lining that you have these
out of line calls and mega morphic call
sites and so forth one optimization that
that that lambdas make more pressing
that we do not do yet
we are planning to figure out is what I
call loop customization which is when
you have one loop with a programmable
center that's that's mega morphic so you
might see this in old code with an
interface called its mega morphic inside
a loop that you were use over and over
again you want to be able to somehow
have that mega morphic call site sort of
grab the whole loop pull it inside out
and clone a copy of the loop for each
receiver type and then hoist the
dispatch outside the loop that's that's
the loop customization problem it didn't
use to be as pressing because we had
external iteration where people
customize their loops by hand by writing
their own for statements we're telling
them not to do that anymore so now the
vm has to support it that's probably the
single most important thing that's sort
of not working yet that we that we plan
to do is that is this this customization
of looping okay course other control
flow constructs thank you John so thanks
everyone for your questions and comments
we're out of time feel free to continue
to send us feedback by the usual channel
channels and thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>