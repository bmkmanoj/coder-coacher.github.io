<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Graph All the Things: Graph Database Use Cases That Aren’t Social | Coder Coacher - Coaching Coders</title><meta content="Graph All the Things: Graph Database Use Cases That Aren’t Social - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Graph All the Things: Graph Database Use Cases That Aren’t Social</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TFimzwbOY7Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right cool so we're gonna start this
this is the evening slot so we're gonna
start with a little bit of evening
gymnastics I thought so hands up if this
if you have including this one ever been
to Java one before
come on including this one who's been to
shuffle on before right every hand
should be right it's cool who in here
has heard of no SQL hands up cool who
here has heard of SQL alright we're
learning who here has used and knowest a
so-called no askew L database ends up
keep your hands raised if you've also
used a graph database cool keep your
hands raised if used if you use near / J
yay awesome fantastic cool so my name is
MLA forum and I'm the CEO of a company
called neo technology where the
commercial sponsor of an open-source
project called neo4j neo4j just right
here on my shirt which is an open source
graph database implementation it's also
a product also ironically called neo4j
which is the most popular graph database
out there today I'm gonna talk for the
remaining 58 or so minutes about graph
database use cases that are not social
alright so graph database this is in
this kind of interesting spot now where
it's actually starting to become fairly
known amongst developers but a lot of
people peg it to be exclusively for
social which is it's one of those
dangerous types of truths right in that
it actually it's true it is very very
useful for social data but it's not
exclusively useful for social data so
I'm going to be outlining a couple of
thoughts along those lines in for the
remainder of this talk please keep this
as interactive as possible it's a fairly
small group sit just raise your hand if
you have any questions and do tweet
about this as well please the the
conference network seems to be working
better this year than previous years
that's good maybe not perfect yet all I
ask is that you use the neo4j
the neo4j hashtag hashtag neo4j because
we monitor those tweets religiously have
a super simple agenda today one two
three the first one is we're gonna set
some context and talk about where we are
from a graph database perspective and
then I'm gonna take a step back and just
establish 101 there's probably 40 45
percent here who haven't used the graph
database and talk about what graphs are
actually foundationally and then we're
going to get into the into the use cases
specifically the use cases that aren't
social so a word of warning though we
are at I guess Oracle OpenWorld these
days or something like that so it's a
lawyer sponsored conference right so I'm
gonna get my liabilities upfront I can't
offer anything in this talk except for
the truth I've given variants of this
talk a while for a while now and there
are some victims
for example this gentleman an Indian
gentleman who watched I'm not sure if
you guys can see this from the back but
he he watched the photographs from his
Diwali fireworks and he says he's seeing
graphs everywhere as he's looking at the
stars in the sky and he seeing graphs
hands up how many are seeing graphs in
that in that photo we came not a single
one let's see I'm gonna show this again
after this talk and we'll see how we're
doing
another victim I saw this talk or a
similar one and went home and then
looked at his curtains and it's like
graphs are everywhere so context we're
gonna be talking about graph databases
but before that let's keep this
interactive I want to ask you a question
so what is the one thing that all five
of these companies one two three four
five six all six of these company
companies have in common can I get some
suggestions make a ton of money good one
consumer focused good one
third third time's a charm what's that
contact management I don't understand
that but maybe that's true maybe that's
true massive number of users all good
ones so I'm going to argue that actually
the key thing and I'm sure all those are
true as well but the one that I have top
of my mind is that actually the secret
sauce the secret sauce for every one of
these companies why they ended up
winning their market is one key thing is
the fact that they took a look at their
data and they did not just treat it as
silos but they said that hey there's
connections in our data and if we start
leveraging those connections that can
unlock a lot of value and I'm gonna give
you a bunch of examples about this and
I'm gonna argue that this is a trend
these are all consumer web companies but
this is a trend that started out in
consumer web but it's now spreading
completely horizontally across other
verticals we call this trend sort of
tongue-in-cheek graphs or eating the
world graphs are eating in the world
vertical after vertical are being
consumed by graphs and I'm going to be
walking you through how our thinking
around that so the first example out of
the previous slide is that of web search
right so if you if used if you scroll
back a few years 15 or so years back to
the end of the 90s there were 50 search
engines out there 50 search engines
everyone knew that search was dead there
was no there was no innovation left in
search and they all did this absolutely
amazing thing I remember even back back
in those days 15 years ago I thought
about that it was like holy this is
this is awesome technology because what
they're doing is basically let's crawl
the entire web every single document on
the web let's download that into our
data center let's index that and look
into that so when you're searching for
water you know we're gonna look inside
of each and every one of these documents
sure indexed I'm sure B plus trees and
all those good things but conceptually
or do one look inside of each and every
one of these documents and see the
documents that have water in them serve
the result back right and oh by the way
we're not going to just do this once no
no we're gonna do this every day from
now until perpetuity like I just thought
that that technology was was amazingly
in it's amazing in its and
they all did the same thing but then
along comes a small startup which does
exactly the same thing as the other guys
but they also they do that they also do
basically they say that hey you know
what let's not look at these as single
documents but let's look inside of the
HTML and see that hey there's an a H ref
in here let's extract that would say
that's a link which of course those of
us who know HTML know that know that
that's a link right and then extract
that into connect the data set and then
rank the search results don't just
return all the documents that have water
in them but let's rank the search
results along the connected data sets
let's use one link as a vote yeah use
that algorithm that they called
creativity PageRank which actually was
not named after the pages that they
crawl but after one of the inventors
Larry Page right and of course this
startup was Google we've all heard about
PageRank and that's the key innovation
that's the reason that this company is
probably the most formative and and
defining company of the at least the
previous decade and all of these other
companies are gone right one single
innovation the fact that they looked at
their data and said that connections and
data are really really valuable
next example in recruiting monster.com
very big very famous still around today
and they do online job search job ads
basically they help people find a job in
how well basically this standard way
which is let's look at job job profiles
and let's match them to CVS and if we
have a good match here let's you know
return that as a certain good search
result right and then along comes
another company called LinkedIn and they
say that no actually the way that human
beings have always found jobs or
occupations is through their connections
through the social graph through their
network of people that they know and
they built the product that enticed
people to volunteer the connections that
existed already in the physical real
world they digitalized them and they
built an infrastructure that allowed in
the process fees and then completely
dominate that market same same
difference here in in this space versus
in Google to AltaVista another example
more subtle is that end of 90
early two-thousands a lot of people
tried to do online payments and one
company pulled it off
one company only and the company was
called PayPal and I spent some amount of
time thinking about connections in data
but I actually didn't realize this
myself that the key reason that these
guys were successful is that they
managed to build an infrastructure that
allowed them to handle connections and
data really well because the key risk of
doing online payments is fraud and it
turns out that when you're looking for
fraud if you have only a view of
isolated transactions the city Bank for
example example where this all one
transaction one transmitter one receiver
or if you have the entire payment
network the payment graph you can detect
a lot more fraud and have much more
precise algorithms if you see the entire
connected data set three examples and
they were all consumer web what we're
seeing inside of the graph database base
and this has changed just in the past
couple of years is that this this trend
started out in the consumer web but it's
now spreading across all the verticals
when we started out a few years ago
actually started out quite a long time
ago but when we started racing venture
capital when you started getting
investors in the company that's when you
need to start articulating the market
for your product right we said basically
look we we have a hypothesis we don't
know yet it's very early in the era of
graph databases so we don't know yet
where the ultimately the market is going
to end up but we have a hypothesis and
that hypothesis is that we have three
verticals where bias V so software
companies right and then financial
services and telecom and we have for use
cases network and data center management
master data management social and then
geo and I'm going to be double clicking
on all of these later and in this four
by three matrix we believe is going to
be the early adopter market and
specifically only four neo4j I'm talking
mostly here about craft databases in
general but all of my examples are from
the FHA cuz that's that's the one graph
database that I that I know the best
specifically for neo4j we now have a
scorecard right who who are where did
our customers end up coming and you can
see that this entire four by three
matrix is
is now filled out and this is a sample
data set of the customers that are using
neo4j in production today super proud of
this you see big company's HP Cisco etc
as well as small hype ones like snap
interactive and 53 etc but we're even
more proud what what is what happened
outside of this four by three matrix
because in parallel to the adoption that
we've seen inside of the of the early
adopter market there's been an explosion
of graph database usage outside of a
multitude of other verticals and this is
the trend that we call graphs are eating
the world because what we are observing
is that once one company in a specific
vertical starts using a graph database
or at least starts exploring connections
in their data and start leveraging them
they all of a sudden have a more fine
and precise view of the world and
they're able to build much more powerful
products so all things being equal which
they never are but all things being
equal that product will then be a better
product than the product that only uses
data in silos and the Google tulta Vista
example comes to mind and so after a
while this company will then either
start completely dominating their market
or they're going to force other
competitors to adopt graph databases as
well graphs are eating the world so
we're not the only one seeing this that
this were all internal metrics so our
own customers that I that I see
day-to-day but there are some external
data points as well that point to this
so there's a site called DB engines calm
evening gymnastics again DB engines calm
who who has heard of it avenges calm
hands up only a few people so basically
it's a site that tracks a number of
different signals they track 150
database projects along the axis of how
many people have added them as a scale
on LinkedIn
how many tweens tweets mentioned that
specific database project Google
Pagerank for them Stack Overflow
questions etc they have seven or eight
different things that they that they
measure and then the computer score and
what's interesting is that they not only
compute a single discreet
or project which actually is interesting
in and of itself but they also group
them by category and it turns out that
graph databases have been the
fastest-growing category in not in no
sequel not in big data but in databases
for most of 2013 and all of 2014 so far
which is kind of interesting graphs
let's not kid ourselves is the least
known of all of the so-called no sequel
databases by far but it's been the
fastest growing for quite some time now
so that's all fine and dandy but if you
have popularity this is only popularity
and now analysts are starting to cover
the space and this is one example
Forrester I'm sure you've heard of them
they now estimate that inside of the
enterprise more than 25 percent will be
using graph databases in production by
2017 so a lot of evidence of sort of the
traction in in graph database I'm not
going to spend more time about this
although please ask me about this
afterwards because I'll be talking for
hours and hours about it but let's take
a step back what are we talking about
here what is the graph anyway all right
I'm actually going to take you way back
to the to the 1700s today to the 18th
century and graphs actually started out
in a small town back then called
konigsberg kenigsberg which is
Kaliningrad today in Russia and
channing's Berger Kaliningrad is is a
city on both sides of a river called
prego which is the river you you see
here the blue in in this picture and it
consists of basically it's on both sides
of this river but then it has two big
islands and those big islands are
connected to the to the mainland and to
the to the other Island through seven
bridges seven bridges and there's a very
famous seven bridges of königsberg
example which gave birth to two graphs
and basically those seven bridges if we
remove will have a more cleaned up map
you can here see the one two three four
five seven bridges between these
different islands and through the
islands to the to the mainland
one guy a gentleman coal boiler EU l er
oiler who for some reason wanted to
answer the question sir one way is there
well at least one way that I can walk
through kenigsberg and pass all of these
bridges once but only once every single
bridge once but you can't go back and
forth and once only once
is there one path that you can do this
right it turns out that it's not
actually that easy to figure out the
answer to that question you can sort of
intuitively do it if you start racing
you're gonna see that I'm gonna get into
a dead-end right by I can go I can
reverse back over a bridge but
intuitively yeah that's one thing but
how can you do two mathematical rigor
right and so what he ended up doing was
that he said that well he thought about
it for a while and came to a couple of
conclusions one of them was that it
really doesn't matter how you're gonna
walk inside of every one of these land
masses you can just actually treat them
as a sort of Indian device' below Tomic
unit what really matters is how you walk
across the bridges and in what sequence
you do that
so we've reformulated the problem using
a new type of a vocabulary where he said
in modern terminology is that we have
four nodes and between those nodes we
have four edges or four relationships
and how can I walk through this graph
visiting multiple nodes I mean the same
node multiple times but the
relationships only wants to abstractions
nodes and relationships and that was the
birth of graph theory which is has ended
up becoming one of the most important
sub disciplines of mathematics I'm sure
many of you have amazingly fun memories
of your college mathematics classes in
the ingre theory so the way this has
evolved on the database side is that in
databases today there's a model that is
called property graphs which builds on
the original abstractions has formulated
by Euler where he said that there are
nodes and relationships but in the
property graph model we also had key
value pairs that you attach to both the
nodes and to the relationships right so
think of the think of the nodes ask
basically a Java dot util dot map if you
will right
and the same thing with the
relationships but the relationships have
a type that ends up being important it's
important if I know you or if I if I'm
in love with you or if I if I own this
car or if I Drive this car so the type
of the relationship is important and you
can also add labels on top of the nodes
you can say that this node is a person
node or this node is a car node that's
an example right so those are the key
abstractions in in the graph database so
if we take an example right let's say
that
how would you query a graph database
right so let's say that I'm going to New
York and I want to find a restaurant in
New York I happen to like sushi I go on
to Facebook and I search for using their
new graph search product or new it was
launched last year where I can type in
sushi restaurants and it's gonna sort of
Boldin the things that are nodes or
entities and sushi restaurants in New
York
but not just any sushi restaurant in New
York but I want the the restaurants that
my friends like so a very simple type of
recommendation it would look something
like this
right so basically we have me and I have
two friends in this fictitious example
in real life I'm very popular I have
many many friends especially with the
ladies they all love me but and so I
have two friends in this fictitious
example and they like a bunch of
different things but we've now extracted
the ones that are located in New York
and that serves sushi right so me my
friends a subset of my friends who like
things that are in New York and that
serve sushi right so how would you
express that actually that was that was
a natural language right how would you
express that in the graph query language
well there's one graph Korean language
called cypher and I believe there's a
talk about cypher actually when is it
Stefan tomorrow tomorrow at 8:00 there's
a talk specifically it talks about the
internal of cypher so the way that you
would express this in in in this graph
query language is maybe counterintuitive
at first so what I've observed is that
when people first see cypher this
sometimes get a little bit confused so
let me walk you through how ciphered
thinks and how cipher works so basically
turns out that a really important
operation in a graph database is pattern
matching it's not the only one but it's
a probably the most important operation
that you can do on a graph right so
let's say that we want to match a very
simple pattern basically what you do is
that you describe a pattern a loves B
and then you throw that to the graph
database and it's gonna look inside its
entire big graph and give you instances
of a loves B right so conceptually very
straightforward but the question is if
you have a query language which sort of
by its nature is textual so
two-dimensional or maybe one dimensional
actually how do you describe a
multi-dimensional structure right and
the answer is obvious I think in
hindsight you use wait for it ASCII art
hands up how many in this room remember
ask your so so we're bringing it back
we're bringing it back to the main
stream at finally askew art right when I
was in in in in high school a very
popular thing was to pass around small
calculators TI 82 calculators with ASCII
art pictures of let's call it beautiful
ladies and we're bringing that back but
now we're using it for good and we're
using it to query graphs right so you
can see here that we in ASCII art if you
want to describe an ode in ASCII art one
way of doing that is to wrap it in
parentheses you can see that a here sort
of is is is a node and then we want to
describe a pattern where we from A to B
you can see that we've drawn an arrow
here using - and then greater n then I
guess less than and then we have another
node called B and then we can add this
sort of we wrap this in what we call a
match clause which instructs the graph
database to match this pattern and then
we say that law we want to bind this to
somewhere in the graph so we want to
just not find any ace that loves bees
but we want to find an a node which has
a property called
atom right and the result of this is B
and we want to return B so these are all
the the people or the things that that
atom loves in this particular example so
going back then to the sushi race
grunt example we would start out with me
which is a friend of someone friend who
likes a restaurant and that specific
restaurant is located in New York and
the restaurant serves sushi and then we
bind those nodes down there into
specific nodes in the graph where me has
a name mo and New York top location has
location New York etc and we return this
this is a stolen example it's stolen
from a blog post by a gentleman called
max de Marci who is one of my colleagues
at neo and when Facebook launched graph
search about I guess a year and a half
now they launched it midweek and that
weekend he hacked up basically Facebook
Graph search using neo4j over a weekend
not of course as scalable as Facebook
etc but it's pretty cool that you can do
that in a weekend using ciphers some
natural language forcing etc I
definitely urge you guys to to check out
his blog it's it includes a bunch of
cool things including this one so what
happens then from a runtime perspective
right so we've described this pattern
and then on this huge graph neo4j is
going to take that little pattern it's
going to find instances of it and return
that back to the end user right so okay
that's cool that's a neat little
language but how does it work in the
real world so this is an example from
from the real world where actually a
customer of ours had the following
problem they were modeling at age or
hierarchies they were modeling starting
with the CEO all of the CEOs direct
reports and the people reported them and
then this huge hierarchy that is a
company today the company organization
at least in theory it's a hierarchy but
we all know in reality it's a graph and
the question they wanted to answer was
that given a specific individual like I
know the SVP sales you know take that
person find all the people that they
manage up to depth 3 so directly and
indirectly and how many people report to
them was a pretty simple question you
might think right and their SQL code
looked like this
and this is actually a lie this is
actually a simplification because in
reality with the real example that they
were doing was up to depth 8 and when
you get to depth 8 then that is kind of
expensive and it it got so so awkward
for them to write that they ended up
they were never successful writing it so
they ended up writing a program that
generated the code actually and that in
that way they managed to construct the
SQL that handle up to 8 levels down but
then of course once they ran it or just
to slow
yeah so the question is why why was that
such a cumbersome example no actually
the real reason why it was so cumbersome
is that it has variable path length
queries which are really really awkward
to express in in SQL there are some
syntactic sugar around it connected by
an oracle sometimes works with some with
with a number of constraints on it but
not one that works generically and well
in cipher however this query looks like
this right so pretty pretty simple as an
example okay so that's cool but what
about performance then right so we've
talked about expressiveness from a let's
call a compile time perspective right
which is really important as a developer
but what about runtime performance right
and so one example of this is when we
were contacted a while back by a big
social network that you've heard about
and they said you know we've looked at
old no sequel and we use a lot of it but
like graphs
come on graph databases or just expose
exactly abstractions that we want to
work with however like the only thing we
really care about is performance so can
you show us some benchmarks and of
course benchmarks is the root of all
evil or something like that it's what
what what is the saying it's a lies damn
lies statistics and then benchmarks
right so we being the honest geeks that
we are we said hey you know we can prove
anything with benchmarks so instead how
about you show us give us a scenario and
we'll show you show us your numbers and
show show you our numbers and basically
the scenario that they gave us was this
one right so there's a small social
graph with a thousand people we have 50
friends on average per person and we
grabbed two people on random and we
check if there's a path between them
right not even how the path works but if
there's a path between them and then we
returned that result we've implemented
that in MySQL actually a MySQL
consulting shop implemented that in in
MySQL with a thousand people I think you
can see the schema in front of you you
have a person table and then you have a
friend's table right and person table
has an ID in name for example and the
friends table has AI
an ID right ID 192 and if person 3 is
friends with with with person 7 you're
gonna have one row saying 37 right and
then the row saying 9 13 etc and you're
gonna end up doing a lot of self joins
in the second table if you have 50
friends on average just gonna end up
being with a thousand people in the
thousand rows in the first table that's
25,000 rows in the second table and it's
a 2 milliseconds sorry it's a 2,000
millisecond operation in MySQL this
comes back to the runtime cost of a
bunch of joints self joints in the same
in in the same table india for j this is
a two millisecond operation which we
feel super happy about of course but
it's also kind of obvious right this is
this is what we're supposed to be to be
good at right this is graph data this is
where we supposed to excel so we up the
ante a little bit and this is running on
two laptops ago my laptop two laptops it
goes with a 300 megabyte eath we added 1
million people so 25 million connections
in total grab 2 people at random to set
check to see if they're connected and
it's still a 2 millisecond operation
right so pretty dramatic example of of
the type of performance benefits that
you can get not guaranteed to always get
come on the the basics of no SQL is that
you choose a database that maps well to
the data set at hand that's the that's
what Noah's girl is all about right and
and the era of the one-size-fits-all
databases is over but if you have that
kind of data set and that type of
workload you can get these kids and
kinds of examples question
yeah so the question is am I going to
talk about the internals and what is it
that makes it so so efficient no but
there's a talk tomorrow at 8:00 which
will go into some of this at least and
you can hit me up afterwards and/or
Stefan can you can you wave Stefan who
works in the cypher team and he'll be
able to tell you a little bit more so
this is still slide where I haven't
shown you any running code of this you
shouldn't trust it right we have real
customers that you can see because I
guess the slides are cutting off but
real customers experiencing this in real
time this is one example of that this is
eBay which uses for their same-day
delivery service right and they have
some nice quotes about it they used to
have a situation they were all on MySQL
and they do basically when you click on
eBay they do same-day deliveries
sometimes within the hour of when you
buy something on eBay in selected cities
which is freakishly cool right this is
basically their response to the Amazon
drones which are also very cool but this
one works today and it's all based on
near perge they used to be on MySQL and
they had a situation where some of their
slowest queries were slower than some of
their fastest deliveries so there are
queries that took like 45 minutes and
some of their deliveries took 30 minutes
right the physical delivery of the goods
that's when you know you're not in a
good situation they switched out to
neo4j and have a response time in the
milliseconds all right so that's the
foreplay so what about use cases then
social non social graph use cases right
so let me give you a snapshot examples
of the type of breadth that we see today
breadth that we see today
the first one is network impact analysis
and I'm actually going to challenge the
the demo gods and show you this live
without the mirrored screen so this is
gonna be interesting so when you install
neo4j the first thing that you see when
you fire up neo4j is that you're gonna
see or the so-called neo4j browser which
is the web use
our interface for neo4j which is a super
simple very clean minimalistic UI it's
basically a rebel hands up if you know
what a rebel is most some people a
redeveloped loop right so there's a bar
at the top where you're gonna end up
typing in cipher queries every cipher
query is going to give you a little
window if you will a little little frame
with a search result that you can look
at that you can interoperate on etc to
include some nifty little guides and the
sample data sets and things like that
right so for example I can do a super
simple query I can see what I'm typing
right now so let's see if I type
something coherent I did but there's no
response so basically what I did now is
say I probably the most simple cipher
Creator would just match any node and
then return it and we can see here that
we don't have anything in in the
database yet but I'm gonna show you a
network management example if I can
click alright so here we have some
cipher code using syntax that I haven't
showed you yet this is a create
statement which basically works the same
way you you throw in a create there and
then you draw a graph using this ASCII
art syntax right so here we're creating
a bunch of nodes with a label resource
we create the CRM system we create the
database virtual machine a server server
one server two et cetera and then we
were not happy with just creating the
isolated notes but we also create the
relationships between them specifically
only one type of relationship called
depends on so we want to match the
dependencies in this sort of very very
trivial very tiny data center all right
so we we say that the CRM depends on the
database virtual machine etc etc etc so
if we run this and we do the same query
as before we're gonna see hopefully most
of you can see this I may be able to
yeah that doesn't make it better okay
so what we see here is that we have CRM
application which depends on the
database virtual machine which depends
on the which has a dependency also on
the on the public website or the other
way around the public website has also
dependence on the database VM which runs
on server 2 which depends on the sand I
don't know if this is if you guys can
see this but hopefully conceptually you
get this so imagine that you're a big
telco or in that in that you've run a
web server operation web service
operation then you would have a data
center looking like this but not with
seven nodes or whatever we have here
seven nodes but with the 700,000 nodes
or something like this right so we
described this and now we can start
running some very simple queries right
so this query here creates it I'm just
randomly clicking around here this query
here checks the impact what happens if
server one goes down right so we take
server one and we check all the
downstream dependents are the upstream
dependencies of server one what happens
is several one goes down if we want to
check all the direct dependencies we
wouldn't we just have this asterisk like
this right we without an asterisk I'm
just going to show you exactly that only
the web server VM is is depending on
that one right but if you want to check
check all the transitive things then
it's as simple as adding a star like
this right and we're gonna see that the
on the web server VM of course the
public web site it depends right so very
simple conceptually simple query but
very difficult to express in sequel and
very easy inside for at least if you can
see the screen when you type so there
are a couple of other ones but I think
the the coolest one is is this one which
finds the most dependent upon component
without geeking out too much there's a
concept in graph theory called
centrality and centrality basically
describes how important and notice right
so you can imagine that if you're doing
if you're a telco and you want to map
influencers in your graph who should I
we should I real
try to upsell my new whatever phone or
something like that in order to get that
to spread through the social graph then
these are the five people that you
should hit first that's a centrality
algorithm right and there's a bunch of
different types of centrality degree
centrality between the centrality
eigenvector centrality they all have
fancy schmancy names this is one is
called I think this is gonna end up
being it between the centrality
algorithm but basically it it tells us
that if we only have budget to replicate
or implement fault tolerance for one of
the devices in our network which one
should we we should we do that with
right and in this example it comes back
with us a huge surprise that's
absolutely no one who's run a data
center it's the sand because basically
everything else depends on the sand so
this is an example of network impact
analysis this were all trivial example
but imagine this with 700,000 notes
right and yesterday we had a situation
where maybe an average data center had a
thousand of physical machines or
something like that right and maybe they
were connected squared with that so like
let's say a million connections between
them which is big but not impossible to
manage today and for some definition of
yesterday and today right today an
average may be a hundred thousand
physical machines and not only that
every one of these physical machines
runs ten virtual machines so that's a
million already there and imagine this
you know Time Square Metcalfe's law the
number the explosion of connections
between all of them makes it really
really difficult to keep track of so
this is a very popular example yeah of
graph databases today check the impact
of something happening in on the network
another example this actually comes a
little bit back to the roots this is
route finding or route finding depending
on where you're from but basically if I
want to get to point A to point B and
this example I think is the London Tube
map how do I do that most efficiently
right so imagine that every city in the
u.s. is a node and all the roads
connecting them are relationships and I
want to find out how to go from point A
to point B
how do I do that right so there's a
without without revealing too much all
of that one-third let's at least
one-third of all the flight paths in in
the world actually will be calculating
using the over J in the in the near
future
let's say so imagine that you're doing
price optimization for flights right
that thing that we're all battling
whether we're trying to get from point A
to point B right that describes all of
the nodes in that in that world is all
of the airports and the relationships
are going like all the flight routes
from point A to point B and then when
you want to optimize how to get from San
Francisco to Copenhagen right there's a
multitude of ways you can get from point
A to point B and you need the graph
algorithm to figure out that figure that
out recommendations it turns out that
ever since we started moving from
physical to online retail there's been
an increasing demand on recommendations
and Amazon probably started this at
least in the mainstream and forever in
the physical world retail outlets have
stored physical records or not physical
records but purchase records of the
transactions the e-commerce transactions
that are happening right but it turns
out that when you look at that data as a
very isolated set of elements it's very
difficult to do anything with it but if
you see that let's take this purchase
information and say that there's an
individual called ml because that's that
the individual is in that purchase
record and he has bought a camera and
his bought milk in his bought an Xbox or
something like that and then there's an
individual called Adam right that he's
bought the same things but there's one
fourth item that Adam has bought that ml
hasn't bought right and then there's a
very trivial graph algorithm called open
triangle recommendation or collaborative
filtering where you can implement that
it's one or two lines of cipher which is
going to identify this fourth thing that
Adam had bought that ml hadn't and then
recommend that to him this is trivial to
do in a graph database but it's one two
three four five something like that
joins in relational database and in
reality of what you want to do is much
more sophisticated than that
because one of the items that ml bought
was a book it was the two towers by JRR
tolkien but you don't want to do
recommendations based on that specific
book but in reality that book is part of
a category called fantasy books which is
part of a category called you know
sci-fi books or something like that
right and you want to do recommendations
based on that abstraction not on that
specific element and that alone leads to
an explosion of joins in this particular
example so Walmart is now public
publicly using neo4j
to power their online recommendations
not not their in-store recommendations
but all their online recommendations are
powered by by a neo4j
Logistics we were contacted by one of
the biggest package couriers on the
planet a while ago and when they said
that they basically handle all of the
package routing or Parcel rafting so not
TCP IP packets but actually those
physical package for a major country in
Europe and they said that oh we're
running into trouble because we see that
two years from now we're not going to be
able to handle the peak volume and peak
volume in this business it's a very
seasonal business so peak volume is of
course Christmas time so basically they
saw that okay so we manage all of the
parcel routing for this major country
and they're not going to get their
Christmas gifts in in a couple of years
and as they try to debug why they try to
figure out you know is it the physical
infrastructure problem and the problem
wasn't that the physical infrastructure
in that country is it's very good
there's a lot of very big highways in
that in that country let's say but the
problem was that there's software that
backed all of the logistics and all of
the the getting from point A to point B
intelligence could not use lateral
connections they could only describe a
connection into a hierarchy so if you're
sending something from let's use a local
example from San Francisco to Menlo Park
I don't know how many of you are local
to the Bay Area but that's that's 30
miles or something like that then you
had to send it to a core distribution
center for it first you might have to
send it to Chicago or something
like that even though there's a physical
way of getting from San Francisco to
Menlo Park it's just one highway away
right and so they ended up replacing
their entire relational database
back-end and swapping in the ER for J
and been up and running now for a year I
believe it's been riding a hundred
thousand parcels per minute at peak load
which is pretty significant it's very
cool just from from implementation
perspective it's a very cool example
because physically you have a chute
where these packages drop down and
they're gonna scan the barcode on top at
the top of that chute and then at the
end as gravity has pulled that package
down a few milliseconds later you're
gonna have to make a choice either left
into that truck or right into that truck
and so you have a couple of milliseconds
and they're gonna throw that query to a
cluster of neo4j instances that in
within a couple of milliseconds
calculates the optimal route and then
you know decides you the left or right
into whichever track one example access
control actually the most the earliest
example of graph databases that I know
of that this is the origin of why we
ended up building neo4j in the first
place so access control very typically
involves users connected to some kind of
content and if it only were that easy we
could use just a relational database
saying ml has a right access to this
particular file but users are organized
in groups groups sometimes belong to
multiple groups you're not not no longer
just a member of a specific part of the
organization and this particular file is
not just an isolated file but it belongs
to a folder and that folder belongs to a
folder you can see how that builds up a
big network let's just connect these two
different trees to one another using
access control lists this example inside
of finance is called entitlement and we
have a few of the biggest investment
bankers using graph databases for this
today so basically the problem is that's
the on board a new trader the unit used
to take them two weeks before that
trader was up and running and because
that it just took that long to resolve
all of the different assets that they
had access to and now it's it's the
millisecond operation
to to parse that entire thing so that's
access control fraud detection it's
another example where it has previously
been using mainly correlation analysis
which is looks something like this right
so you have a situation where you have
you're mapping two different things
right for example total dollar amount
and transaction count or something like
that all right and you see that normally
in the mainstream we have a band here
where within this range things are okay
things are normal this is how it's
supposed to be right and then we look at
outliers
hey whoa someone is outside of this
normal range and then we're going to be
investigate that one and this has been
very popular and still used today very
much so maybe the foundation of fraud
detection inside at least certain
industries but fraud fraudsters are
becoming much more sophisticated and
what this misses if you stay inside of
this band of normality but you do for
example a fraud ring so you have every
single individual has behaved within
normality but together they form a fraud
ring this is impossible to detect using
simple correlational analysis taking you
connected data view will allow you to do
that I could go on and on and I will if
you hit me up afterwards and asked me
about more use cases but basically this
summary is this graph all the things
every vertical every years case graph
them no not quite but pretty close so
most of you know Gartner the number one
analyst firm on the planet today
probably and they did something unusual
a while back where they said that hey
let's take a look at the consumer web
and let's try to analyze that and
they're mostly focused on the enterprise
but they said that you can actually
understand all of the dynamics of the
consume of the consumer web so we're
talking about the apples and the googles
and the Facebook's of the world by
looking at it through the lens of there
are five key resources that all of these
big giants are battling over and they
wrote in a really cool paper called the
four Giants and the five graphs of the
consumer web right and they said that
these five key acids or the social graph
the interest graph the intent graph the
mobile graph and the payment graph and
if you if you can conquer these and you
can own these that is a huge amount of
value in the consumer web so we we
looked at that and we thought it was
very cool of course being being graph
guys and we said hey let's take this and
start mapping other verticals so we
started doing that and I'm going to end
with with a little bit of a flavor of
that and then we're gonna move on to Q&amp;amp;A
but basically we've started to explore
different verticals and find the five
graphs of that vertical and in telco is
one of the first that we mapped we've
taught we've found these five graphs
that seem to be common amongst all that
have the telco customers and and and and
community users that we see the network
graph is the graph that we talked about
before with the resources being cell
phone towers switches routers firewalls
etc we have the social graphs which is
good for influence analysis which I
alluded to a little bit before the cold
graph is actually inferred social graph
based on the CDR the the cold data
records the master graph ends up
actually being very very popular inside
of telco so the so-called master data is
all the data that are that is
non-transactional in in in an enterprise
so all the customers all the they
organization with the employees and the
the supply chain all those things ends
up being a lot of graphic data and then
the help desk graph actually ends up
also being very very popular all of the
support cases that people file and how
they relate to one another and two
issues and two tickets that support to
them and to the various specific
products but also the parts of those
products that the support cases adhere
to five graphs of Finance I'm not going
to go through these in detail if you if
you're in a specific vertical you want
to go no more please
come up in at and ask me afterwards and
if you're in a vertical that I'm not
showing here the final vertical is the
five graphs of health care and you have
some ideas around what you believe are
the key
Graff in your vertical please hit me up
afterwards because we're super
interested in mapping these things out
so to conclude if you think that this
sounds interesting that graph databases
aren't just good for social I'll get to
it in a minute then there's a book out
there called a creatively graph
databases it's an O'Reilly book it's
it's it's pretty good it's a it's a
fantastic introduction it's available
for free as a PDF on graph databases com
so that's a great next step if you want
to learn more about this and even better
next step for those of you who are local
it's gonna be super easy if not it's
it's a good thing to travel for there's
an upcoming conference called Graff
connect which is the biggest conference
related to graph databases and graph
database applications it's a one day
conference it's at the SF jazz center
here in San Francisco and there's gonna
be a lot of interesting speakers from
ConocoPhillips talking about oil mining
and how that relates to graph databases
to eBay to many of the examples that I
had only time to talk about for a minute
here they're gonna go into really core
detail there's a huge discount for
JavaOne attendees at least for the for
the next weeks week or two so just use
that one called java one and on that
note I want to wrap it up and the my
final urging is if you thought this was
interesting there's the book of course
there's the conference but let's not
forget that neo4j is open source and
it's available free of charge for any of
you who think this sounded interesting
please go to new FDA comm and download
it and add some data and start a graph
thanks thank you very much
can turn me on yeah so we have time for
a few questions
so got a question yeah so the question
was can I talk about how to use master
dating graph yeah in the generic case
absolutely so it turns out that in
master data there's a lot of hierarchies
and a lot of graphs right so one type of
master data organizational MDM right has
an organ or org tree as the foundation
or tree of course is a big graph one of
our earliest fortune 500 customers was
Cisco they're now public as being a
neo4j user in their MDM division and
they used us basically for sales
compensation calculations so imagine
that your Cisco so you have 4 gazillion
sales reps right and they're organized
not just in like an organizational heart
but they also map to a territory and
they map to different users right and
when you translate and you want to do
sales force compensation that's a lot of
connected data that you need to traverse
so those are some examples of master
data any other questions go for it
so the question is can I talk a little
bit about how well do 4 j s quails how
well in the offiers scales would love to
so basically the scale out model of
neo4j
is master-slave replication so think
mysql right so you have a single master
at all times and then all of that data
is being replicated to all of the slaves
it is a little bit dissimilar from from
MySQL in that the master can get
reelected so it's not fixed to be a
specific master and you can actually
write to the slaves
unlike in my scale or you don't right
through the slaves in my scale that's
gonna really really mess you up so
that's the foundation for the for the
scale out so it's its replicated scale
out which gives you a number of
advantages it gives you read scalability
in particular it gives you fault
tolerance what it won't give you is
right scalability right you're still
gonna be bottleneck by you to the right
throughput of the single master and it's
not gonna give you sharding and sharding
is actually not a goal in and of itself
but it means to an end and the real end
when it comes to shorting is to achieve
right right throughput the right scale
ability so that's sort of the drawback
with a with a neo4j scale of model as it
is today it won't give you right
throughput but it will give you read
scalability on the right throughput
actually the the stuff we're working on
right now in your 52 2 &amp;amp; 2 3 will
increase right throughput by at least
one order of magnitude cool final
question
yeah that's a great question so let's
say that you have a use case which is
very document heavy and you could look
at that use case and say that hey this
is all graphs right because actually the
graph model is the mathematical superset
of the document model if you draw
documents to its logical extent the long
auric of documents and the long arc of
graphs there's no need for documents
there's not a single use case the
document databases can do that graphs
cannot do at the long arc of it like at
its full power we're not there yet today
so today it's going to come down to very
specific sorry this is like a huge
consulting answer but it's also a true
answer which is it's going to depend on
your use case like our ambition is that
over time we should be able to handle
all the richness of everything that the
document database can do but today we're
not there yet
so if you have a situation where you
have super deep documents with a lot of
content I would be down maybe you can
put it in there for Jay maybe you can't
I would at least look into that and do
real performance performance of the my
performance benchmarks on it but over
time that's definitely our ambition to
be able to handle anything that a
document database can handle and those
of you I'm sure many of you have used
document databases because they're by
far the most popular of the of the knows
SQL databases right and there's a bunch
of times when like inside of the
documents you end up encoding basically
foreign keys you have like you encode
like an a key element that refers to a
document over here right and then except
it's not a real foreign key there's no
support for that in the model right so
then if this thing gets deleted you
point to what to null
basically right so there's no there's no
abstraction to really support that in
the model so logically those models are
a graph right and that's what the graph
model is is therefore today we're we're
much better at the relationship fast
traversing than we are at at handling
let's say a completely disconnect at a
document space right just a data set
with just documents without any
connections that's not our Forte over
time it's definitely our ambition that
we will
be and next year if you ask me the same
question the answer is gonna be a little
bit better and then a little bit better
and a little bit a bit better but today
I would say it's very much depends on
your data set and with that very
consulting oriented answer I'm gonna
wrap up thank you very much for paying
attention and if you have any more
questions please come up and ask me
afterwards</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>