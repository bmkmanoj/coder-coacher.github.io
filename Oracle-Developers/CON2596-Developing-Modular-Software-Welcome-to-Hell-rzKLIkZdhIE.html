<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON2596 - Developing Modular Software: Welcome to Hell! | Coder Coacher - Coaching Coders</title><meta content="CON2596 - Developing Modular Software: Welcome to Hell! - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON2596 - Developing Modular Software: Welcome to Hell!</b></h2><h5 class="post__date">2015-12-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rzKLIkZdhIE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to hell just kidding so just let
me present myself my name is Europe I'm
the CTO and founder of joy frog if
you're not familiar with Jeff frog then
we are a startup company we have
branches in Israel in California in
Santa Clara and in France so we're quite
an international team and we are
building products that revolve around
binaries right so we have yeah we are
kind of obsessed with frogs you can tell
by the name of the company so we have
ulti factory which some of you may be
may be familiar with it's a repository
for hosting all kind of artifacts we
have been tray which is a distribution
platform for for artifacts basically for
binaries so you can take out facts
thanks from ulta factory push them to
bring trade and they're available on a
CDN and your users can consume them
securely and so that's a web platform
and we have Mission Control which is
relatively a new product that connects
those products allows you to control the
flow of artifacts but also allows you to
make configuration changes in multiple
odd factory instances so naturally we
deal a lot with binaries and with
packaging systems so this is a
screenshot from the factory create a new
repository page and you get a wizard and
you need to pick the type of artifacts
you want to select and you can see how
many types of artifacts we we walk with
we are familiar with those packaging
systems not only as users but mainly as
the ones that have to provide the
protocol support the indexes so we all
kind of have an intimate knowledge of
how those things work because we need to
make them work with the clients of
docker off of maven of Bower
and so on so this is why we have this
session because we
I want to share with you some of the
pitfalls we are seeing with binary
systems and with packaging systems and
show you the main problems that are
standing out there are plenty but I will
pick some some a few examples that stand
out stand out above the others so we
have sixty minutes seven stories so
these are the examples
lots of memes let's go and so first
thing you might want to do if you look
up look up this the subject you will go
to Wikipedia you will find this article
about package management systems don't
worry we're not going to read all that
off but you may wonder ok this guy is
talking about packaging systems and this
session is is called modules what's the
difference so there is a slight
difference it's mainly conceptual right
so when we speak about modules typically
we speak about developer oriented
modules so api's and dependencies and
and things like that when we speak about
packages usually it comes it has some
notion of something that you install on
your system but that's mostly a semantic
difference and we really don't care and
we're going to talk about those subjects
interchangeably so modules modules a few
examples so this is just a brief
introduction just to get the terms right
so I'm going to show you some some
examples and take the most prominent
ones out of them so systems mostly stuff
that you install on your system
development modules so you know all of
these may vary the SBT framework modules
so many folks that are extensible which
makes them module
well again take the big ones and
applications it can be basically
anything that's pluggable it can be your
browser your watch your phone anything
that can accept something that
extends it as a plugin so there are a
lot of module systems what what we are
going to do with them and what we will
do is I will tell you seven dragon
stories about things and problems we see
these with these packaging module
systems and some of them are trivial but
you may overlook them just because you
are used for things to walk in a certain
way and you never questioned why it
works like that and some of them are
less trivial so Story number one it's
the story of indexes and it's a story of
indexes that are kept in a place which
is not suitable for them to be kept
ourselves from the wrong place so the
story begins it begins with once upon a
time the computers were slow anything
you could have recalculate and offload
from a computer was something that you
wanted to do and search is serving
searches especially for magnitude of
users was not something that was easy to
do that has changed so today computers
have much power how much power we can
serve searches without an issue and
nobody even questions the fact that if
you google something up you don't need
on your client any special library you
don't need to catch anything you don't
need to facilitate something on your
clients you just call a REST API and we
know how to scale horizontally and
Google returns the results right but
then in maven there is this maven
indexer that you have to download I will
show you in a second so and maven at
least some maven tools they expect you
to download an index to the file system
and maven is not alone here I will show
in a moment so there is this
contribution from sono type it's called
the maven index l or the nexus index or
whatever the name currently is and it's
calculating an index for your whole
maven repository
and you have to download it so normally
it's a very big download normally it's
around hundreds of megabytes you can
download chunks of it when you do
increment or incremental updates but at
the beginning you have to download a
very big file it takes a lot of time
another thing is the update rate so it's
not up to date as much as you would hope
it would be because it needs to be
calculated and then it's cached and
served by too many users so it's not
real time if you publish something to a
maven repository this calculation for
the whole repository so it's a full
repository indexing it takes time it's
expensive and the owner of the server
doesn't want to do it every time and of
course it requires a special client
library to read so it's not just a REST
API you don't go with Carol and you get
your searches you need to embed the
client library to use it so it's it's
it's not the best the best part right so
there is this contribution in open
source but we can say no thanks guys and
like I mentioned before maven is not
alone in this space so take these
examples so new frameworks new or amaq
starting started to get this right so if
you look at new get if you look at will
be gems python doc variant things like
that days of rest indexes actually OB
gems and pi PI Tech combined approach
they also offer a legacy index so they
do have an index that index is the full
repository but most tools today they
stopped using it because it's it's too
expensive debian and RPM are quite old
and they and very very popular we can
tell us as jeff fog yet they need
calculation to happen on the full
repository which for a vendor that
creates a repository manager it it's
quite a challenge so you have to
calculate the indexes on the side to
switch them at some point it's it's not
it's not very easy nathan is is new well
but yeah new or Amex they got it so the
lesson here is that indexes need to be
served from the server side not cached
on the client and just use a rest query
API everyone's doing it today there is
no reason to write something that using
something else okay story number two we
move on and that's the story of
Impostors or a story of security and
mainly and let's take an example so who
knows this guy okay not very I mean it's
not very popular nowadays his name is
heinrich heine is a german poet he was
born in diesel DAF a long time ago he
died of course and died alone in Paris
or something said like that and what
strange if you go to any GPG public
server so that's one example of those
servers and you do a search for him he
shows up a lot right so watch the screen
so this is just a snippet of the results
there are plenty more anyone knows why
heinrich heine is so famous in the PG PG
PG world what not quite okay so first no
he doesn't he's not a coder
he was born and died before computers
were invented and yeah he's quite
popular and the reason is that the GPG
program itself if you just default for
with dentists I think they gave him some
tribute because these from Dusseldorf
and the GPT library were all this client
was developed in this and off so this is
what you get okay so that's the default
everyone is heinrich heine the strange
thing is that
those servers they don't even check who
you are so you just create your public
identity you get your public and private
key pair you get a fingerprint for your
for your identity and from there you're
free to go and upload this online and
many folks are using it so this is a
snapshot for maven central but it's not
the only one that is using it and for
open-source guys especially the security
where open-source guys this is a must
right so to take the identity of a
developer and put the detached signature
near the files is almost if you don't do
that
just don't put your open source online
but something is totally broken here
right because the web of trust if I
would if I know the guy who developed it
and he would email me from a certain
email let's say that the the server-side
validate your email then there is some
sort of way about a web of trust between
us I know him and I know he told me what
his public key is and I can take his
public in I can validate the artifact we
this public key but without knowing him
just by blindly taking some signature
from a server there is no web of trust
okay so I cannot trust him yeah and no
we probably didn't write it let's
continue so the other side of this toy
is that this guy the name of the guy and
the identity might be buried somewhere
in Palm fire or some other document but
largely speaking he's totally I'm not
identified so there is nothing in the in
the repository itself that tells me that
this guy is who it claims to be we also
don't credit him so the right thing to
do is basically authenticate using some
public identity everyone today has some
public identity whether it's your
Google+ Twitter github account bitbucket
account so those are trusted identities
and you also want to credit the
developer
actually both goals can be achieved in
in one go if you take the nougat gallery
for example look at the screenshot here
so you can see that every library is
identified with the developed with the
developer that created it that has links
to his private eye to his public
identity so that's one thing to do it
that's a shameless plug for Jeff Fogg so
this is a plug and it's shameless
so in bin tray which is the Jeff Fogg
distribution platform so every developer
has the identity so this is an example
of vagrant vagrant is downloaded form
bin try cellphone bin tray so you can
see what this guy is if you go to his
profile you will see his public
identities is authorized github or out
and Twitter and so on even his public
key if we uploaded it so we have trust
there are other services like Kiba saya
that are taking this further and
creating a much larger social trust but
this is the bare minimum just trusting
or an email of a guy or not trusting
anything at all or not validating
anything at all is much worse yeah so
this is it
story number three that's the story of
dependencies so normally if you're you
don't have to be on Windows it's a nice
to batch windows but you don't really
have to be on Windows if you're
installing some kind of software you
don't have a version in mind you just
download something and you install it
and that's it right you never question
what version of a specific app you're
getting from the app store you're
getting the latest and that's a typical
case well getting the latest is a good
thing when when you're on time basically
cannot accept more than one instance oh
it's not very common even if it can
accept so yeah this is an example you
install some meme reader
but it becomes a problem when you need
to depend on something so for a long
time when you install something in you
install the latest it may be good enough
but if you need to depend on it it
doesn't work very well and look at the
aptitude library on Debian and you can
see that it has a transitive dependency
on a PT on the apt library which is
supposed to be installed in the system
and it doesn't have any version ok so
that creates an issue and the reason the
issue exists is because many systems
they do not know how to take many
versions in parallel so for example
we'll be right if you want to install
multiple versions of OB you really have
to install a separate product called the
RVM the OB version manager because an
installation of OB has a very strong
assumption that you will only have one
installation of gems in a certain
location and one installation of the OB
version the runtime will be another
example is go so who's using go he'll ok
very few it's still Java one but go it
has a strong assumption that whatever
you build it's the Google way of
building you build it form source and
then what you do is you create a root in
your source tree and if you need a third
party library you just get it from
github or you check it out you check the
sources and then you compile everything
but in go if you want to have several
versions of the same library you need to
switch your check out to this version so
in a way you have a way to support
multiple versions because you have the
gate index and you can always check out
a different tag but it doesn't work in
practice so because if you have multiple
versions looking at this one go path
that you have on your system and you
need to use multiple versions you need
to be very careful and make and make
sure you remember to check out the right
version
every time you switch a project because
if you own the wrong tag nobody will
tell you that there are 4 mocks to deal
with it but it's not part of the go out
of the box so it's a it's again a system
that doesn't accept multiple versions on
a system level if we cannot run if we
have a name spacing issue so we can we
cannot use multiple versions then we
have to use some tools out to all kind
of facts like the RVM and same for OB
there is something the GBM or we use
home before the magnet takes away this
pain on a platform like java so we
usually run so Java in in the on time we
can install with maven and great in and
so on we can install multiple versions
but in the run time we cannot have
multiple versions right we cannot be we
cannot run a program there is a one
class path that that allows us to
specify the dependencies if we have the
same class in different locations it's
going to to clash and then we tend to
all kind of ugly solutions such as
incorporating the code operating in uber
job just to avoid those transitive
dependencies clashes so let's see an
example ok we'll use maven because maven
is always fun to look at and we have a
project we have reliably a that depends
on e that depends on D and library a
also depends on B that depends on C that
depends on D but a different version of
of D so here we have the version 1 and
here we have the newer version version 2
and the question is which version of D
is going to be use so let's do a quick
poll okay so who thinks it's a d1 the
older version not many ok who thinks the
newest version v2 will be use option B
okay some people are not voting to
apparently see Wow
okay D it will just spit out an arrow
okay so okay so so my guess when making
this deck was that most of you are going
to say the newel version so let's say
that let's pretend that you did so no
you're wrong it's actually version we
want the older version anyone wants to
take a shot and guess why
exactly if you meant to say the shortest
parts as well so yeah good yeah
maven always takes the most direct
dependency so that's the it's completely
up to the conflict resolver to figure
out what to do there is no way you could
have guessed but and you may think it's
it's the wrong way to do it certainly
not what you would expect I mean in
greater I think it's the newest version
but so another issue with the multiple
versions is uninstalling that's also
something that sometimes you overlook it
but when you really need to uninstall
something it can become a real pain so
this time I'm going to use Gradle and
this is how Gradle is managing caches it
has a cache for for every version of
Gradle of the Gradle resolver and this
cache is actually very smart it's using
file system singing symlinks and
checksum based storage to avoid growing
your your cache too big so it's very
space conservative you can say so even
though it's very smart there is really
no way to clean up things and it does
happen from time to time that you get
some co-option in your cache especially
if you don't use a repository manager
and you know tell them downloading
something and find out that you yo cache
is filled with four four pages that
the hotel server ever returned to 202 I
don't know how many have you experienced
if it's a very bad experience when it
happens other cases that you may have
installed a newer version and you have
some by mistake and you have some range
dependency and you don't want this new
version to come in when you need to
clean the cache most often you will go
you will totally delete the cache and
start all over because there is no way
to clean the cache
Oh clean individual installation and the
last one here is that if you're using if
you're designing a module system you
should design for X election and you
should design for cash management that
is usable right Story number four it's
the story of version ranges so basically
depending on something which is dynamic
so in in a ideal world everything is
backward compatible I actually have
heard a few theories talking about
reaching a point where software
development is fully backward-compatible
and they truly believe that this is
something that is feasible in the future
to to reach in practice this is far from
being too so things work and when you
get a new version that is incomplete
incompatible it just doesn't work I'm
going to use some example of something
like that fairly modern wanna guess what
it is just by the name of the title
image
okay so it's Dachau so this is an
example of a doctor all you may not
think of a doctor file as being a
dependency or packaging system
effectively it is it creates a space
where you install things and you would
have expect some metadata to exist about
what you have installed and what you've
baked into the image it's it's Wild West
at the end of the day you just do
whatever you want with bear show just by
installing something remotely with the
apt so apt is a good example you just
download latest version of something but
the worst thing is this form Ubuntu
which effectively means that you're
doing a doctor or the latest Ubuntu
version from the doctor server meaning
that every time you will learn this bit
this build of the image again you will
get different potentially a different
image so this is really bad it's like a
new meaning for failure well and I know
it's not well but the fins of a whale or
not are not long enough for face bottom
so we had to use a seal so basically you
want explicit versions and you want to
you want to depend on explicit versions
another story the story of vodka and
beer you don't mix those so otherwise
you look like that and what do I mean so
himself so I'm talking about
configuration and metadata and
configuration we configuration basically
is best is anything that controls your
build so the location of your repository
all kind of environment variables for
files and so on usually we stick them in
version control or we use some
environment that is fully dynamic and
based on where you're building this
stuff whereas when we speak about
metadata like pom files even though they
originate in sauce and they probably
exists somewhere in version
the final version is usually a binary
artifact that is totally immutable and
you stick it in a binary positive him
from Dario we solve it so let's tell a
story here there was some happy user and
he had in his project declaration that
in maven world it's going to be in the
settings XML or something like that you
basically define your internal
repository or internal server your
source of artifacts and then you start
building your project and you declare a
dependency on B once a and B one
internally in the poem it has a
repository reference it has this
repository tag which is something that
exists in maven that allows you to
reference another repository form a pom
file and by doing that you get your
metadata first you get a bed repository
into your configuration you have a
source that is not trusted by you but
was injected to you and and you mix the
review you it contributes to the
metadata so it contributes to the
configuration so your metadata
contributes to the configuration and you
have a bed repository and you're not
that happy anymore me I call it
sometimes the core site scripting of
dependency management you have some
source you believe that you work with
sauce but some inputs that you're
getting so it's like in a browser you
get some input from a user that injects
another sauce into your client code and
it makes your client to go to another
server so this is exactly the same maven
is not the only farm objects doing good
NPM ok and Pam is doing exactly the same
so same user is building an NPM project
now so we're going to start you know in
a very clean way we're going to clean
the cache then we're going to configure
a local registry so this user is good is
using goat factory
we're going to install a library which
is common that is called in term version
one three and this is what we will see
on the command line can somebody tell me
what's wrong with it exactly the third
line this github fetch so you're happy
everything comes from the trusted source
and all of the sudden an injection comes
in and you go somewhere on the web it
doesn't have to be get up it can be any
cell phone in it's cute and the reason
is this oops it doesn't show up very
well on the on the screen but this line
now this line that says this line is
declaring it's an exception right
everyone is using the semantic
versioning letting this NPM client go
against your canonical repository but
all of the sudden you have this dodger
dependency that inject some dependency
on an archive this is real stuff and to
to fix that it's very annoying as the
maker of a binary repository you have
actually no choice but rewriting this
file because this file you have to
remember it served to the client and the
client is doing the connection outside
so most users our enterprise customers
will just fail the firewall will not
commit that but they again they don't
want to fail they want to allow the
build and they want to let through some
sources that they trust
so either we write that or either the
client is approaching the developer and
asks him to fix that or to create
another dependency of this job dojo to
go archive as a real dependency it's a
big pain and you're not happy so please
please please don't mix configuration
metadata this is largely where you
control as a user because if you're
making libraries you and you're using
frameworks that allow you to make this
mistake and you're contributing to open
source or something similar you have
control over that this is a developer
that a mistake that is in the framework
but at the end of the day the developer
is that the one that persists it okay so
another story and that's the story of
the matrix so this is a short one
basically it says that if you have
multiple systems and and you try to
combine dependencies for multiple
systems normally it's a big headache
let's look at an example if you want to
install fog plugin for Grails
that works with elasticsearch then there
is this question it's a real-world
example I mean if you install the wrong
version it will just not work you have
to take into account the version of the
plug-in the version of elasticsearch
that it's going to work against and of
course the version of Grails because the
the event handling of the indexing
ingress effect how the plug-in is
written so you have to take all those
factors into account so it's a it's a
complicated matrix and ideally the would
there should be some way to express
those dependencies in the in the
framework itself Java just doesn't have
that I think that there is something in
jigsaw and I saw that there are a couple
of jigsaw sessions going on in this Java
one and finally it's it's getting it's
unbelievable this project was lingering
for for so long but it's finally getting
in into Java in production so there may
be some solutions to that let's look at
something very old like rpm and they do
it right so there is metadata here that
allows you to express those dependencies
and actually when you install an RPM if
it obsolete something else you need to
uninstall it first so rpm is quite smart
about the
between packages and what cannot be
installed together and so on
and there is also namespace dependencies
but that's something else so basically
it's not enough to have version
dependency sometimes you have to have
more metadata to support decisions that
cannot be made based on version alone
okay we reached our last story actually
so story number seven and that's a story
about trumped-up limitations so this is
when you're making something and you're
you present it as if it's going to it as
it has to be that way sometimes those
decisions have very hard percussions on
on on the module system and I'm going to
use doctor who is using doc you so this
is a docket ugh I don't know if you can
read but what's important is that once
you've tagged an image and you if you're
tagging an image that stays in your
local repository rather than the public
doc you have the the host of the of well
the repositories becomes part of the
name of the image so then if you look at
the examples below example below
we actually have an image that is called
Jeff org which is the namespace in
doctor if you don't say anything there
is an implicit namespace called library
which is owned by doctor itself but most
organizations when they develop images
they namespace them using this namespace
and then there is the name of the image
doctor calls this repository but I'm not
going to mix the terms I'm going to
speak about repository as a repository
manager and call this image even though
it's not accurate and then there is the
diversion the tag but then again when
you when you push an image when you
create a tag it's it contains also the
host name it becomes an integral part of
your image
name so it's a double sign first it
mixes configuration and metadata because
it persists the the location of the
image which needs to be configurable on
your system and doctor itself they have
they have like LT factories they also
offer you a local repository and they
allow you to change this host yet every
time you want to move the image you have
to name it differently according to the
host name but mostly it creates a a big
issue when you when you want to do
things like promotion so for promotion
you basically need two repositories at
least right so you have to have a
repository for artifacts that are not
promoted and then artifact battle
promoted and you cannot do it and the
way you override this is you start
referring to all kind of trickery so
either you create see names for your
repositories and you you have to
configure some boxing and and mapping
between between requests that are coming
the data being routed to the right
repository in your repository manager
and appending the the path name of a
certain repository to the original
request that lacks it and to do that you
use either a hostname a cname any you
just have multiple Sinnott o the another
ugly trick is to use the port so you put
nginx in front of your repository and if
you see a certain port then you realize
the URL to go against a certain
repository in your repository manager
those are really ugly hacks and it's an
informed decision made by Daka so it
doesn't show up for some reason but yeah
they thought that it's unlikely that
anyone will need more than one
repository in any server and if you do
you need to spin up multiple servers or
to some port trickery and the lesson
here is that if
just leave your name space open don't be
and be HTTP friendly if you open an HTTP
repository just play by the HTTP rules
don't try to reinvent things and of
course don't mix metadata in
configuration it always ends up badly
and this is a an example of something I
mean you have no control and no way to
pass the repository name even just give
some way to pass it as a header
parameter or something similar currently
there is no way to do it in Tokyo and
it's it's very much so there are more
soils I just touched on the prominent
ones the ones that stand out basically
the reason for speaking about that is
that module systems are here to stay and
there are not just here to stay the hill
to expand and basically it doesn't make
any sense for anyone today to write any
system that is not extensible and if you
look at this slide everyone likes to
show this a iot slide nowadays and you
can see that by the end of 2020 we're
going to have 50 billion devices
connected so we need IP version 6 but
this this area is just going to go and
go and all those devices eventually
today they are just small sensors but
they're going to get smarter and smarter
and they're going to get updates and
they're going to be very modular because
this is the way to go there is no way to
do things otherwise so it's really
important when somebody builds a module
system or designs it or or inspect one
to have those lessons in mind and I
guess I'm early that's it for me thanks
guys
and we have plenty of time for questions
if you have any questions yeah
so the question is about using maven and
using client-side plugins to enforce
dependency rules so yeah anything that
makes your dependency more explicit and
and more Egypt is usually a good thing
make some users may not like it but at
the end of the day when you have we want
reproducibility then anything that makes
your dependency set more rigid is good
any other questions so the question is
if we have some research preferred
package management system so the thing
is we don't make those packages we are
we are serving them so for us it's I can
tell you that NPM for example except for
this injection of dependencies and org
sources is it works very well yeah
otherwise everything that is less than
about even you get is weed especially
with nougat 3 is is a nice is a nice
dependency management system so yeah
Gradle is not a dependency management
per se I mean it's using maven artifacts
at the end of the day or IV artifacts
the resolver is implemented much better
than in maven but at the end of the day
I think they have some proposal to add
metadata for example such as
compatibility like the metrics problem
compatibility between different versions
and obsoletes and and conflicts and
things like that if they managed to pull
it through that's that's great but at
the moment it's just a better
implementation of a maven resolver and
divert reserve
any other questions thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>