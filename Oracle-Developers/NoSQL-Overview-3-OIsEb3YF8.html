<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>NoSQL Overview | Coder Coacher - Coaching Coders</title><meta content="NoSQL Overview - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>NoSQL Overview</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3-OIsEb3YF8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Tobias and I'm gonna talk
about a talk about the sort of diverse
landscape of databases that we have
today I work for a company called neo
technology speak louder I would be great
if I I didn't have to if this was just
loud enough so I work for a company
called neo technology it's not better
good that I'll keep working there what
we do is we build a database and sort of
falls into this category of no sequel
databases because it is it doesn't use
sequel I guess it's one of those
categories that they are defined by what
they not R which is always a very good
way of defining things this is an auth
cat and so given this confusion about
what the hell are these things I i
created created this presentation to in
2010 and it's evolved a few times since
this since then and but I think still
the thing that originally made me think
that I should create this I think it's
it might still be valid and it was this
comic so we've got two people talking
here one guy says hi so how do i query
the database it's not a database it's a
key value store okay you're a bit
confused we got this diverse diverge
space of things that our databases or
are they not databases what are they
okay so so it's it's not a database how
do i query it you bribed a distributed
MapReduce function in Erlang what should
you just tell me to go myself
believe I did Bob believe I did and this
sort of captures the the entire
Confucian around these databases that
that are their databases are they not
databases what are they so I think maybe
this talk is still relevant I when I
created it in 2010 I was hoping that by
by 2012 it wouldn't be relevant anymore
but it was still quite appreciated last
year so I thought I'll give it a go from
again this year and actually this
happened a few things since since last
year this whole space of databases is is
sort of a an area where all things
become new again over and over and over
again so what was old yesterday is new
today and then it's old again tomorrow
and that's certainly been in the case
for for databases I mean in the early
2000s it was really easy to be a
software developer it was nice and
convenient there was only one type of
database sure you had a choice you had
to choose between Oracle or IBM's sequel
database but it was all sequel and then
in 2007 I think was when the no sequel
movement took off we got the whole
plethora of different types of databases
and now just recently there is a new new
sequel which is the same old sequel
database again using sequel ah but
they're different somehow so today I'm
going to try to talk about these
different categories of databases and
try to make some sense of them I'm not
going to go too deeply into each of them
i'm just gonna just give you a light
overview of them as we got key value
stores with or without distributed map
rete MapReduce functions in Erlang we
got document databases new sequel I
graph databases column oriented
databases and if you
other things that aren't databases but
somehow for some reasons often get
lumped into the hole no sequel space
could maybe because they also don't use
sequel so in general are two main
categories of databases and this was
identified by martin fowler a great
thinker so it's always great when martin
fowler does something cuz that means
roof he defined it people trust them I
don't need to to define it I can just
refer to Martin found her and said way
that great authority of defining things
that guy said it so you defined
databases in two main categories
aggregate oriented that store aggregates
of data and these databases fall into
that category these are often called
document databases as well we got
MongoDB react red is so on and what they
do is they the store aggregate so they
store some kind of root element and then
with that root element they store
associated element that sort of hang off
of this route so it's it's aggregates
data stored aggregates hang off of these
and the ice are stored together and then
the second category and he defined and
I'm really happy that this is stands on
its own as its own category defined by
Martin Fowler is graph databases and
graph databases don't store things I
created it's rather anything can relate
to anything so you have entities and any
these are their own things and they can
relate to other entities in any any kind
of way as I said is this a distinction
defined by martin fowler so why if we if
we try to understand why no sequel
happened in two thousand
six two thousand seven ish there are a
few underlying trends and the first
trend that I want to highlight is that
data today still more so and then in
2007 is less uniform than what it was in
the 80s 90s or early 2000s in the 80s
when the relational databases completely
blew all other kinds of databases out of
the market most data that we stored was
very uniform it was things like
employment records where every employee
looked the same every employee had a
name every employee had a salary um
that's not the case anymore just look at
something like a social where some
people are more popular than others you
have Britney Spears with millions of
followers on Twitter and you have me who
only have 300 something followers on
Twitter it's a huge difference so data
is less uniform now it's all so it
doesn't really have the same shape or
size anymore you can have if we take the
employees and it's not as an example you
today it's it's actually a change in an
R and R in our environment or in our way
of being as humans people don't have
just one job anymore I I do a lot of
side work I I I work as a developer at
neo technology but I also teach a bit
that pays some so I got multiple I've
got multiple jobs and different incomes
and different salaries for each and one
pays monthly one piece by the hour
invoice weekly and all these different
different things so even my even
something as simple as my my employment
record and my salary is more complex
than what it would have been in the 80s
so modeling this in a relation
database this diverse set of data led to
something that we know as the relational
mismatch if you get sparse data is one
way of looking at where we not
everything has the same entries the
Dorado you got if you look at the top
table here you've got if you were to
represent it represent sparse data as
one relational table in a relational
database you would have something like
this where you would have many columns
and only a few of them will be populated
most of it would be knows and that's not
very nice so to to model sparse there in
relational databases often what you see
is in something like the bottom where
you have a an entity table and an
attribute table where the entity table
contains the things that you know that
everyone have which might just be a name
and then everything else is in the
attribute table where you store the
entity ID the key and the value so sort
of dynamically store the the sparse
information for each entity and this is
a nightmare to query one thing that I've
another model that I've seen recently we
sort of become a favorite of mine
because it's it's so so awful but but
but clever is to have a one table that
just stores the raw data this is the
kind of like the entity table but it
stores all the data often serialized in
just a blob so all this bars information
stored there and then it has searched
tables which is for each attribute that
you're interested in you have a
specialized search table which is the ID
of the entity and the data table and the
value of that particular attribute also
a bit of a twist your brain to have to
to query it
so the change of data from uniform to
non-uniform was one of the driving
factors for that push no sequel to
happen that sort of made people think
that hey relational databases while
they're good aren't the best fit for all
types of data the second trend is the
Big Data trend we've got an exponential
growth since but what maybe forever but
since since the few recent years at
least in the amount of data that we
store human seems to be hamsters we
store all data every year we store as
much data as we stored throughout
history the entire recorded history or
almost like that i think it's might be
every 14 to 16 month we store as much
data as we've stored throughout history
but still it's it's an exponential
growth it doesn't matter what the time
is but it's some fixed interval its
exponential so we got more and more data
being stored and that was also a reason
for trying to figure out well how have
now that we have all this data now we
store all this data we need to have some
way of making sense of it we need the
ability to process large amounts of data
and just shoving it all into sequel or
shoving it all into a relational
database didn't quite cut it in many
cases the third trend is the data is
becoming more and more connected the
social trend is a great example of this
we are all connected through multiple
social networks online and if we take
this back back back to like the 60s or
something data used to be all just flat
files on on disk then we started before
we have databases and then we started
having well maybe we can have nested
records maybe we can have
we started with with the web in the 90s
and we had hyperlinks so links going in
one direction data became connected we
had blogs with a pingbacks that's a link
that goes in two directions so when I
don't know if you guys remember this but
in the in the heyday of the blog's when
you had a link in your blog your blog
onion an engine would actually send the
link send a request to that web page and
if that was also a blog that blog would
recognize a you're linking to me fine
I'll link back to you we had even more
connected we had dual connections of
data and of course their social and
there's RDF the whole Semantic Web kind
of area of thinking where everything is
is really connected am I had the
internet of things to mention one of the
bus words that was a highly mentioned
during the keynote on Sunday if you guys
were there I think everyone mentioned
Internet of Things and now I've said it
twice I don't know what it is but it
seems funky and that's when every single
device is connected to to one another in
one way or another so everything is
becoming more and more connected so
those are the three trends that sort of
drove no sequel to appear in two
thousand and seven ish but as I said
nothing new is really new everything old
is new again all of these databases that
you that exist now there are these new
no sequel databases pretty much
variations and things that have existed
before if you look at graph databases
for example with no sequel as with no
graph databases with an ear for J as an
example we had back in before relational
databases we had navigational data
or network oriented databases if you
guys remember the network model I
remember studying it in university as
some sort of architectural interesting
curiosity that my professor said was was
completely dead and now I work building
a database is kind of like that craft
database most influential was probably
the code asil database in that category
and then we had and these databases were
bigger than relational databases in the
in its early days it was not until the
relational databases introduced sequel
that they started gaining on on the
dominance that the navigational data
bases had that's kind of interesting i
think this this is an interesting
curiosity relational database is one
because of sequel a query language a
language and CODIS ill i don't know if
you know what that stands for but that's
a conference on on programming languages
so these were experts in programming
languages the guys that define cobol
that got together and talked about hey
we should have a standard for databases
for a navigational databases and they
didn't think of coming up with a
language for it these are guys that were
experts in languages and didn't build a
language had those they lost but they
sort of had it probably it was because
they sort of had a language tied to it
they had cobol but we all know and love
so they maybe they didn't see the need
the same was true for many of these
databases they sort of they were tied to
one particular programming environment
where a sequel was an agnostic language
it didn't care about what you wrote your
program in you communicated with the
database
in sequel which was its own language and
that was used only for communicating
with the database if you look at the
other ones we have the multi-value
databases of the past which sort of
correspond to the column databases of
today with Cassandra being a modern
example and pick being an example of the
past which was highly tied to basic you
had mumps and em I don't remember which
one is a language in which one is a
database it's one or the other and I'd
no one really cares there are sort of
like the key value databases of today
with couch bays are cash place is pretty
much the only only pure key value
database is still alive yeah and then
you had actually copybook in cobo is
sort of like the document databases of
today not quite but as some similarities
and that seems to be a one of the most
popular no sequel categories with
examples such as Mongo red as react then
of course in the 90s we had the whole
the whole field of object oriented
databases those don't really have a new
a new variety to them because it was
still it's still recent enough that they
haven't been old enough to become new
again I guess same thing for XML
databases which happened in the late 90s
was one that was popular so let's talk
about these different categories of
databases starting with the key value
stores so few examples are these is one
of the most well-known ones were biggest
in plenty that had the biggest influence
on on sort of defining the space was
Amazon's simple DB with their dynamo
paper so dynamo is an internal database
that no one
amazon gets to use I don't know if they
use it themself anymore but they wrote
the paper about it and then they sort of
took some of those ideas and created
simple vb from it and many other
databases have copied those ideas from
that paper but we sort of memcached sort
of try to get into this base as well we
used to be a cache and then it's a we
can be a database too and then of course
last year at around this time at oracle
openworld they oracle announced their
Oracle no sequel which really to me
looks like Berkeley DB in a new package
and then we have read is and many other
examples some of them alive some of them
dead so the way that this works that
makes this thing beautiful is that it
scales large volumes of data in a sort
of linear fashion by distributing data
over multiple machines and does this
with something that's known as a
something hash function it's some what's
the term consistent ash yes a consistent
hash function it sort of tells you that
no matter how many i won't go into the
details but i can add machines this and
i will know given i can given my key
compute a hash that tells me where where
my data will reside so if i have a an
apple that i want to put in for example
and I have these buckets of ABCD if
Angie Apple comes after a so it falls
between a and B in this so we will fall
into the B pocket um for example if
that's what the what the hash function
looks like and then I would replicate
this to provide redundancy in case one
of these fails I know where to look
for for an alternative and so I get a
failover in case one machine goes down I
know where to look for for another copy
of the data I'm looking for and I know
where to find it by as a client because
I know the hash function then if I put a
fish in that would go in F and follow
after after if ya know why is that built
in that way sample use case of the
database like like this the stores just
keys and values would be something like
storing files large files you can
imagine generating an ID for file and
given that ID know where to find it in a
large distributed array of machines is
kind of handy when you have large binary
data because usually when you have large
binary data it's it's okay for you to
treat it as an opaque thing and that's
the thing with a key value database it
doesn't know anything about the content
of the value it's just an opaque blob to
it so for something like pictures it's
great storage I don't know if you guys
use the Amazon Web Services but you can
think of of s3 as a as a key value store
of sorts next on document databases with
the notice notes has a great example not
really use that much anymore mongodb is
certainly used these days it's one of
the biggest players in the nose equal
space react red is in CouchDB are also
examples of document databases and they
store data as is documents and the
document is just some sort of object has
a key but multiple values are nested in
this industry meant
the main difference between a key value
store in a document databases is in a
document database is that the document
database know something about what's in
the value so you can build indexes for
looking up this document by by first
name or last name you can write more
sophisticated queries than you can with
a the key value store which of course
might cost you of depending on how these
things are how the distribution works
might cost you an additional network
round trip but you it's you're probably
willing to accept that for the querying
capabilities that you gain but still
since this is an aggregate oriented
database they store things together as
one value and I agree at this I said
that case you can have nested documents
within documents and those will be
stored together and some in some
database you can make queries based on
on these nested documents that are
usually a bit a bit more expensive but
efficient enough what you I won't go
into deeper detail than that but one of
the beautiful things is that you don't
have to have uniform documents so if you
have you can have one document that i
want one document representing a person
that has a clock and another one who
doesn't and you can have different kinds
of different kinds of fields for for
each in each document and the database
is fine with this so it handles this non
uniform data in a very good way of
course it wouldn't handle relationships
very well relationships between
documents are
like hyperlinks on the internet there
there's no guarantee that the page
you're reaching is actually exists which
for some applications is great for
others you might want that guarantee but
it will cost you an extra round trip
it's sort of if you have a reference
it's the clients responsibility to know
what to make of that its clients
responsibility to know that 99 c see
here is actually the ID of another
document and have to go and look up that
as a separate query so you can't do
something like I join in a document
database typically I think this is a
cute example of what I would if I were
to write a blogging system document
document databases but I would go for
it's a perfect fit for that where you
would have something like a post
representing the blog post the document
therapist on the blog post has a title
has a text as as its main attributes
might also have a list of tags and then
it can have a list of comments which are
nested documents to that to that post
and the great thing about this is that
it's a single round trip for me to get
the page that I need to render so it's a
super it's a super nice fit to the
application that I'm building and that's
sort of is the key to that I'll make at
the end of this presentation that when
picking a database for for your
application you should look at the needs
of your application and think of okay
what what is it that what is it that I
actually need to do and what type of
database suits suits those needs the
best now boring slide so new sequel ah
this I've added for this presentation is
its new its its its new give has new in
the name but this is sort of something
that happened
I don't know if it's a counter-reaction
to know sequel or if it's it's just a
name that's a counter-reaction but it's
a cute phenomenon it's it tries to sort
of learn both from the relational
databases but also from the no sequel
databases so you can think of it as a a
relational databases that puts automatic
sharding and scaling to multiple
machines out of focus so what these are
a typically relational databases with a
sequel interface but to try to adopt the
scaling benefits that the no sequel
movements introduced and they so what I
do is they try to do automatic and
transparent sharding of your data so
that your data is distributed over
multiple machines but you can still
query using one single interface and of
course I being distributed they have to
think about things such as fault
tolerance and high availability as well
which databases have thought of before
but it gets trickier in a distributed
setting than in a replicated setting
some examples of this is google spanner
for example i think that's a great
example of one of these new sequel
databases they can do it's globally
distributed throughout the entire world
they've got databases in multiple data
centers I was at a presentation about
Google spanner this Friday it was super
interesting I but there are even though
they query through sequel are some
things that they don't do very well or
don't do at all like they don't do
multiple level joins for example you can
join on some things on a single single
join but not all things and many things
that you join on that you can is
actually going to be slow because it has
to go somewhere else
in the world to fetch that data we also
have databases such as vault DB and
Tokyo DB toca DB is is really cool I
think I've looked a lot of their the
papers that they published and and some
of the source code that's another cool
thing a lot of these databases of open
source I can just go and read everything
cluster eggs and rethink DD are other
examples of new sequel databases and
having looked through these they sort of
fall into two categories one being the
category Google spanner falls into it's
a ground-up database that sort of is
like a sequel databases it has some
other benefits that it sort of stole
from no sequel or Royce inspired by no
sequel but it has a sequel or sequel
like interface and then there's the
other category that Tokyo DV falls into
of being a storage engine for my sequel
there are many companies that position
themselves as being storage engine for
for my sequel and that's kind of cute
that my sequel has sort of gotten this
whole new area of usage next category
graph databases and this is this is my
favorite neo technology we build a graph
database called near forge a new for j
is a graph database graph database
stores data as nodes and relationship
between nodes we capture the information
like as nodes neo4j is a graph database
so we got the concept of a graph
database as sword as anode and the
product near forge a stored as anode and
the fact that Nia Jay is a graph
database is stored as a relationship
between the two there are other examples
of of graph databases
objectivity you know that object
oriented database they built a a graph
like front end on top over there the
core of their database or it sort of
took away the top object layer replaced
with a graph layer and call it the
imprint graph I don't know how well
they're doing now I think they're
starting to to do quite well in the
beginning when they started it was the
main thing that they had going for them
was a lot of marketing dollars their
product wasn't that great but they're
getting a lot better we got an old
player that sort of no one has ever
heard about but they're still going and
they're still making money off of a Lego
graph and that's friends I don't know I
when I first heard of a Lego graph and
from France I thought wow this Franz
make make a database as well because
would I knew them from west from their
implementation of common lisp which are
used in University soup and that might
be why why this is such a niche product
because it integrates with their common
lisp and and not a lot of people are
list developers there are also many more
hypergraph DB titan infrared dex dex is
really cute i'll out i'm really
interested in index they have the
absolute opposite situation to infinite
graph they have no clue about how to do
marketing they are have a former
research projects it's sort of from a
university in spain the thought hey this
database that we've been researching
maybe we can sell it and they started a
company and they have no idea what
they're doing but maybe they learn they
might learn it's not too late for them
and i have this cute example of of how
to model things in a graph database of
course being a graph database vendor i
have to spend some time at this because
not because I want to sell it to you
although I would be happy to but because
I love it so I this is another thing I
love Doctor Who it's a great TV series
you should all watch it it that I will
try to sell to you it's about the doctor
and the doctor is from the planet
Gallifrey and he stole a TARDIS from
there and I uses to travel to time we
can model this in a graph database we
have the doctor he's from Gallifrey he
stole the TARDIS he travels with
companions so these are companions of
the doctor there's Rose Tyler and my
memory sucks why don't I put put names
here Amy Pond and Rory pond yes the
ponds they're married as we can store
that information as a grab so we you can
see how we're getting these kind of
overlays of different types of
relationships in the same graph
restoring different types of information
through how these entities interrelates
so the doctor has a few enemies as well
ready you've gotten along the way but we
can also mix in different types of
domains so before we started off with
the fictional domain but we can also
have the sort of physical representation
this domain the actual actors that have
played in this area so we have many
actors throughout history as play the
doctor we also have episodes and these
different different characters and
different enemies appear in different
episodes so we have the bad wolf episode
for example which stars both the Daleks
and Rose Tyler and of course the doctor
the oxygen every episode it would have
been too cluttered to put that in as
well and then of course we in a good man
goes to war
have the doctor we can store which
incarnation of the doctor appeared in
that one it also stores the also
contained the Cybermen it's a great
episode another example same example i
thought i had a query here oh yeah a
great use case for graph databases if
you ever I this is taken from some known
website that sell books and other things
this I've never been too happy with the
recommendations on this website I don't
think they're very good they're either
trail to sell me something I'm not
interested in at all or something I
already have but graph databases I
highlight this example because graph
databases are really good for writing
recommendations engines and I think that
they should buy one so how do you write
queries for a graph database you write
queries by defining patterns and the way
that we and then matching those patterns
over the graph and the way that we do
this in the average a is by drawing
these patterns in ascii arts so you have
you want to find lovers some a that
loves some be you would draw that as in
ascii right as a loves be and then you
would find somewhere to start so you
would find who so finding who a loves
you would find the person a that you're
looking for and then matching the the
nodes that a loves probably representing
people i could be animals as well so if
a is my dog my dog loves me and I return
return the the lover or the loved should
be so that's graph databases if you are
more interested I'm happy to talk more
but let's continue with this
presentation you can ask me afterwards
about graph databases I'm happy
talk about them column-oriented
databases it's the next category this is
a really great column column store
stores columns really well right in all
seriousness though a column oriented
database is sort of superficially looks
like a a relational database but instead
of being row oriented as a relational
databases is it's sort of
column-oriented so you find things by
finding what you're saying which
entities have this be taken more
concrete example which persons have the
name John so you would look in the name
column and find the the entries that
have the entities that have than they
have the value John and you can think of
this as the I think a database called
the atomic has a very good good approach
to this that or that explains it really
well how how it could work because
that's the way how it works in their
model I'm not saying that this is the
way it works in all column database but
the atomic has a very simple model you
can think of it as everything all
entries being replicated in all the
columns in the store for each column in
every column store and then they're
sorted by the value for that particular
column so when you find something in
that by that column value you'll find
all the entities that smashing you find
them in their entirety in that
particular column store and then you
have multiple columns stores when you
have
uh multiple columns that you're
interested in and if you have data that
has to two or more interesting columns
in them you would store them replicated
in multiple columns stores in this
database that's the way it works in
diatomic I'm not sure that every column
database replicates data in that way I
know the first sample Cassandra which is
probably the biggest column database for
general purpose use because big table
inside of Google is also a column
database but it is not available for you
or me to use Cassandra I know that in
their design documents they recommend
picking one one primary column for each
entity but they do support having
multiple columns for an entity and so a
but I don't know if they replicate or
not if you have multiple and I've always
outside of so the one of I've always
struggled to find good examples of when
you would use a a column database I know
that it's great for log processing but
it's sort of tricky to get a good
example of that in just a single slide
and then what they use as their main
sample application cassandra is is a
Twitter clone so I'll just say that well
yeah possibly that they're that design
looks quite quite sensible so yeah if
you were building twitter with the focus
being on the the tweets a column store
would absolutely make sense if however
you're more interested in in the who
follows who aspects the graph database
would of course be a lot better but
another trend with with column oriented
databases is that there
are they found use case as underlying
storage of higher higher abstraction
models for example are really is Titan
as a graph database built on top of
Cassandra right non databases caches
sort of play into the space they for a
while there in the early no sequel
database a lot of caches try to position
themselves as ASCII value databases yeah
in a way they are but they don't store
things durably that's the whole thing
about being a cache it's ephemeral
storage but they're really useful
together with with any database for for
improving read scalability in particular
where you have something some kind of
transformation in your domain so where
you where the data format that you as
you want to present it to your user is
something that you would actually
compute from what you have stored in
your database if that computation is
expensive you might want to store the
computed value in a cache another tool
that's heavily used with databases of
all sorts are message queues and if
caches are used for improving Reed
performance message queues are used for
improving right performance it of course
means that you have some latency in your
eyes or some at what what's called
eventual consistency so what you would
do with a message queue is that instead
of writing straight to the database you
would write to a message queue and then
you would have something that takes
these things in the message queue in
batch and right into the database you
aggregate your rights by putting them in
a queue I got a slide that what I'm
talking about and it's great for
improving right scalability but it means
that when you
if when you if you write something and
then go back to read it immediately it
might still be in the queue so you it
might not be available for you to read
from the database some people solve this
by putting it by writing to the cash as
well but then I sort of think that if
you if you start using queues and
clashes with your database you're sort
of your sort of building your own system
on top of of the database you're sort of
building your own storage system in your
application and it's it I would highly
recommend to anyone to try to avoid that
only when you have to try building
straight up with the database with your
application using simple and and and
good modeling techniques and and only
when that that really really doesn't
work should you look for poor
alternatives such as as Cassius or
message queues message queues are great
though for the things that they're their
name sort of implies that they're good
for sending messages between services
many of these measures cues such as
Amazon's SQS rabbit NQ or CRM Q are
actually durable and highly available so
you have guaranteed delivery of messages
which is really good if you have if what
if the system you're building is a
distributed system you can rely on the
message queue to guarantee that the
communication that you send between
servers actually gets where it's
supposed to be but for communicating
with the database on yeah it's used for
that people use it for it some people
have great success some people have a
major clusterfuck to maintain but I
thought I'd mention it in the slide
because it or in the slides because I'm
not here to tell you what to do i'm here
to give you an overview that's the title
of the talk speaking of the word talk
let's talk about the elephant in the
room hadoop
I I get confused every time someone says
that they store their data in Hadoop
because that does not make sense Hadoop
is not a database or a data storage
anything it's a data processing
framework and is great for processing
data but data is typically stored in
some other database then you and then
you use Hadoop to pull the data out of
your database or maybe hdf which is
something that comes along typically
with a Hadoop insulation and it's
distributed file system so you Hadoop
sucks the data out of your storage
processes it and then either generates
reports for you or or stores the result
of the this process back into the
database or into another database but
it's it's not a it's not a storage
solution that is a processing solution
and it integrates with oh it's lots of
different database oracle oracle oracle
what's the name of there it's so
confusing that they have the same name
for their databases they have for their
company because they have other products
as well but the oracle database the
oracle relational database has
integrations with a loop cassandra has
great integration near for j has some
integration I've we have customers who
do really funky and amazing things with
Hadoop in neo4j I've never done anything
with it but but I'd sure love to so it
sort of takes all this data processes it
the processes at using MapReduce not in
our line but in Java so it's a lot
better at least I can say that at this
conference and then gives you some sort
of result and this is typically done I
wouldn't some would say it's offline but
it's certainly at the back of the house
it's not something you do on a user
request through your website something
you do
as a continuous process process running
in the background mm-hmm I'm done
talking about the loop um right so I
said that everything old is new again
but the thing with with things being new
is that they're new and and building a
database is hard so when when you go to
pick a a database any database you
should know this the building databases
is really hard and every database I've
seen has some sort of quark to it it
might be bugs it might be things that
don't perform as well as you would love
it too but and or it might be just the
weirdness in the interface that you that
you have to struggle with and given the
fact that no sequel databases are so
young as they are so we started in 2007
it didn't really take off until 2009 was
big boom they're still quite young 2090
now that's just for years and building
databases is hard so a lot of the and no
sequel vendors haven't really got all of
their things figured out yet they still
work great for most parts but whenever
you you think that a no sequel database
might be a good alternative you should
make sure that you test it sure these
vendors do do a lot of testing on their
own some more than others most focus on
performance but the series ones will
focus on correctness as well at scale
but unless you have tested your
application with real with the database
in a real scenario you could you you
shouldn't put it in production because
you should be where
we're that it could be could be failures
and this is actually true for all
databases I talked to one of our
customers that said that he would have
loved to not have signed an NDA with
Oracle cuz he would have had so many
stories to tell me about all of the
support requests that they've done with
Oracle and how how much they had to to
to interact with them to get their
product to to actually work with with
Oracle so this is true for all databases
test test test and test your application
with with real workloads but as I said
series series database vendors take data
seriously the worst thing that can
happen to any database vendor is losing
data so we're everyone is really serious
about about about making sure to not do
that and so if you were to encounter
that with any database vendor I'm sure
they would jump on the solution on I'm
trying to fix it for you you would find
this in your testing of course we
wouldn't harm you and make sure to fix
it before you can tell anyone about it
because that's how embarrassing it is
and as I said serious database vendors
do a lot of their own testing I've spent
the past year at at my company working
on making sure that we have really solid
testing we found a few things while
doing that not as many things as I
thought which I'm happy about but a few
things that my boss didn't think that we
would find so yeah finally a polygon
persistence that's when you combine
multiple databases there are a few
applications that I've seen the do this
in real role as I said we have customers
that use both oracle and neo4j I've seen
that
quite a few times because we sort of
manage to stumble into to this sweet
spot of where we solve a problem that
people have with relational databases
really well and that is deep joins I if
you don't have a deep joint problem
that's great continue using a relational
databases or but if you do a graph
database is really good at solving that
but what we've seen is people having
large relational database installations
but having a few queries where their
joints are killing them and then what
what a few them and have done is
actually bought our product and use it
for accelerating only those queries so
they store that data replicate that data
into neo4j still use there are DBMS for
as their system of record but use neeraj
a as a query accelerator it adds a bit
of the of overhead for their application
because they have to manage to databases
but it's something you can do and of
course I myself in the most recent
application I built used near 4j for
storing all the metadata how things are
connecting than s3 for storing the
actual blobs and what there were large
log files I wouldn't want to store them
in the graph because they don't make
sense it doesn't make sense for that Nia
Jay is not very good at this point for
storing large opaque values but s3 is
great for that as I used a hybrid
approach my conclusion may might not be
have been obvious but it is that it's
all about modeling when you pick a
database for your next application the
model of the of your application is the
important part models are about
simplifying the world enough to to
reason about it and that's and the
simplify is the key word here you don't
want to store the world as it is you
want to store a model out it
simplification that makes it easy for
you to reason about it and what you want
to do is
have a a model that's geared towards
solving the kind of of answers that you
want out out of it for your application
so you should model for for the
questions that you're interested in
asking and so it really is it a two
level or three level maybe thing where
you first start off with what are the
things that I'm interested in knowing
about the world and how do i model the
world to to to answer those questions
best and then given that which database
model is the best suited for storing the
model that I'm that I've envisioned and
if you have complex problems use the
right tool for for free job use multiple
databases that is what what if your
problem is such that you one particular
type of database which store would be
ideal for four parts of your application
model and another database would be
ideal for another part of the model if
that's the model you have why not use
multiple you put each block in the right
hole oh these are conclusion slides
about these databases I don't have time
to go through those but if graph
databases were interesting to you the
new technology is running a conference
next Friday next Thursday Friday here in
San Francisco if you want to attend that
there's a discount code java one that
you can use to get your passes for just
ninety nine dollars other than that i'm
out of time and i'm happy to take
questions i don't know how long we have
the room if I can stand here and take
questions I'm happy to but otherwise you
can catch me in the hall do I have the
room for another
yes example yeah yeah i agree hybrid
databases are would be very interesting
and i would love to see that in the
future but you're right it hasn't really
happened and I don't know why yeah yeah
I think there's sort of this notion
among among these vendors that their
model is the best and any problem is
isomorphic to their model yeah yeah but
I agree there there are things that I've
been thinking about for the most recent
think I think I've been thinking about
is wood for our product would be to
combine it with a column database for
storing large amounts of units uniform
data along with some some node and I
would love to work on that but it's
going to take time yes yeah of course
everything is
i well you so you might have if if
you're building them so if you're
building a single one person blog yeah
you're not going to have that many posts
but if you're building a blogging
platform like blogger or WordPress you
would have but WordPress uses my sequels
at that example the use relation little
bit yeah that's that's true it's
absolutely true and if WordPress is
always wrong because it's written in PHP
but I I think it as I said in my
conclusion it's all about modeling if
it's easier for you to model using a
particular database and that database is
available why wouldn't you use it it is
just as you as you're saying why would I
not use a relational database I can say
why would I not use the database that's
most fitted for for the problem I
solving sure sure and you can do that in
in most types of databases so so having
some sort of idea of how you might want
to expand is a good thing but yeah sure
right there's that it's not true in
practice and any database is going to
lock you in in one way or another that's
cyber true and the while this true that
having a star standardized query
language gives you a feeling of nothing
then it it doesn't really mean that
you're not logged in you had a question
yeah thank you so yeah yeah um it's this
is a great thing to talk about I can
talk about that for maybe 20 minutes
what I think the failure of document of
object databases is that they tied their
tied the model too tightly to your
representation model in your application
yeah but it having it so tightly modeled
with your application means that you are
you have less of a you have lower
flexibility of evolving your model
because essentially you've tied you tied
the storage to your classes so
refactoring your classes is is going to
be much harder than
don't use our ends yeah I know a lot of
people use our ends I think they're
completely wrong you should never use an
RM yeah yeah yeah it's sad I know sequel
is a powerful query language just use it
if you're if you're using a relational
database why would you hide it behind a
no are mapper yes right yes yes so why
wouldn't you use a database that doesn't
have the same impedance mismatch instead
then that's that's my take on it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>