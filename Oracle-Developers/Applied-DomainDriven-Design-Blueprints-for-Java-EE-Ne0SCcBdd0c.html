<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Applied Domain-Driven Design Blueprints for Java EE | Coder Coacher - Coaching Coders</title><meta content="Applied Domain-Driven Design Blueprints for Java EE - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Applied Domain-Driven Design Blueprints for Java EE</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ne0SCcBdd0c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right excellent let's go ahead and
get started hopefully you the folks that
wanted to get to this URL can still do
that do that and we're all done with
this I'm going to go ahead and close
this up and begin the session so the
title of this session is as you can see
applied domain driven design blueprints
for Java EE it's a bit of a mouthful and
I'll explain to you what I'm trying to
accomplish in this talk and I guess what
my motivations for doing this is my name
is Reza Rahman I'm a Java EE GlassFish
evangelist at Oracle Corporation as you
can see I have my email address and my
twitter handle up there part of the
reason I'm here is for you for is to
help you out so please don't hesitate to
ask me any questions that you want
certainly on this talk or any other talk
of mine that you may have okay so that's
you're more than welcome for that at any
point in time so here's how I've broken
down my plan for your time investment in
the next hour or so I'll actually be
talking about the project that's driving
the stock is called cargo tracker I'll
explain to you what this project is is
about and I guess hence what this talk
is about and I'll also try to gauge to
what degree I need to cover domain
driven design my hope is always that I
don't have to cover domain driven design
too much but what I found in the past
doing this talk is that unfortunately is
not reality and I often do need to spend
a bit of time talking about domain
driven design and explaining what it is
and then finally the brunt of this talk
actually is going to be spent looking at
code I am but not too much code
hopefully manageable amount of code
basically showing you how you should
implement Java EE systems that that
conform to the domain driven design
paradigms okay all right so without
further ado let's get started
I'm an old school j2ee guy I've been
using basically Java ie since it was
Java EE I'm one of the first people that
deployed a servlet to what was called
IBM Domino go now called IBM Wes here
for me you know the technology part
wasn't that hard to gonna severe
learning JT was was literally simple
what was hard for me is actually putting
all the pieces together and figuring out
how well how do you take all these
moving pieces and put together an
application and put together an
application in a well structured manner
for those of you who are in in the earth
crazy days of the early 90s you know you
you know exactly what I mean you know
there wasn't a whole lot of guidance to
go to tell you okay how should you go
about designing systems so really you
are on your own to figure out you know
what type of architecture
do you use and how do you ensure that
you know your project is scalable and
maintainable so for me one of the most
invaluable pieces and I guess my fondest
memory of j2ee to be quite honest it is
actually the Java pet store how many
people have heard of the Java pets for
awesome I love it love it love let felt
fellow you can all sympathize with you
hopefully right so basically I looked at
the Java pet store and I looked at his
job ie blueprints and I said well I
really like this you know this basically
gives me the template that I need to use
in my own projects and it gives me some
rationale as to what design patterns I
should use and why I should use them
right so this was this system to me was
awesome
the JT blueprints in my opinion has had
a very profound impact on our industry
because of the because of the initial
efforts behind the JT blueprints we now
have generally tend to have much more
maintainable systems even if you are not
necessarily using an j2ee so whether you
you whether you know it or not some of
these terminologies that are still
floating around today things like Dao
data access object dto remote proxies
session facades all of these things if
you don't know these are actually all
coined and termed in this j2e blueprints
and pet store application that's where
that's where these guys come from and I
guess somewhat to my to my delight when
I and I used to be a consultant before I
joined Oracle I was a consultant for
about eight years to my delight you know
when I went to and
often I would find that he gets guess
what I mean even if these guys don't
realize it they're really using those
patterns which is which is kind of cool
but in reality you know in hindsight we
I also know that the j2ee blueprints had
their own problems as well so a lot of
the j2ee blueprints and design patterns
in reality were were designed to
overcome shortcomings of j2ee as a
technology okay so that was a if you go
back and read about the motivations of
each of these design patterns they're
principally tried to not to keeping me
away from a pitfall of the technology
and most importantly the biggest
drawback all of the pet store and the JT
blueprints generally were not the
blueprints per se but actually EJB to
entity beans the biggest problem with
easy b22 entity means at that point in
time is that they only allowed you to
model data okay just like a row in the
database there was no mechanism by which
you could actually model a risk domain
what do I mean by that I essentially
model a a domain object that has both
state and behavior so as a result what
tends to happen when you're using the
classic j2ee blueprints is that you tend
to write a code that looks more like
procedural scripts C code in reality
more than on the heart of
object-oriented development so a long
came domain driven design and honestly
domain driven design is not a new thing
it's it's been I think a few months ago
to mean driven design celebrated its
10-year anniversary so it's been around
for a good bit of time and domain driven
design was sort of a breath of fresh air
because it emphasizes is essentially a
return back to the core principles or
the core value propositions of
object-oriented domain and in an
analysis okay and we'll talk a bit about
why that's important and and why that
matters as you also saw you also may
know domain driven driven design at
least in the design community is
relatively well respected right so if
you look at most of the
reference architecture or sample
applications today whether it's a you
know dotnet Ruby on Rails or spring they
all have I either confirmed to
domain-driven design or have serious
elements of domain driven design in them
right which is which is kind of a nice
thing so I was on the other hand not not
a ruby guy you know not really a spring
guy not not a drop-dead guy I'm an
old-school j2ee Java a guy right so the
gap that I that I saw is that really
there wasn't very much work done to
align domain driven design and Java EE
and yet in my opinion anyway domain
driven design in Java EE are actually
very well matched
they're they're very good fit together
as I as I kind of hope to explain to you
with code examples as to why I believe
so
so this was the motivation for map for
this project called cargo tracker and
I'll talk a bit a bit more about what
this project is in in just a few seconds
so I actually conceived this project
before I joined Oracle it's been
something in in that's in the works for
me in my mind to fill this gap that I
just mentioned for a while and in Oracle
fortunately I got somewhat lukewarm
support to do this project okay so
basically this is the project that you
see today is largely my work and a few
other folks good folks at at Oracle
primarily if this is a labor of love
right so we kind of do this in our you
know in a in in in our spare time
whatever that spare time may exist in
the hope set you know we want to fill
this important gap and hopefully deliver
something useful to you all all right so
moving into the completely unreadable
slide okay that I have I promise you I
want I won't torture you this too too
much if I can help it so a raise of
hands please how many people have heard
of domain driven design brilliant how
many people you think have a good enough
grasp of domain driven design such that
doing a review would be a way
Stroeve your time okay you're in the
minority okay so you are going to be
tortured alright okay so let me let me
explain to you what the deal here is
domain driven design is is very very old
as I as you know I've been practicing it
myself for about five years to me
personally picking up domain driven
design in the beginning was extremely
daunting why was this daunting it was
daunting prime primarily because of the
way with all due respect the early work
that was done in domain driven design
the way it was approached a lot of the
literature and a lot of the thinking is
very very highly abstracted in to some
degree for me while reading this it was
very hard to imagine that these are
folks that actually write your software
in the real world that their work was so
I guess cerebro there is hard to get my
head around for quite a while quite
honestly it took me about a good year or
two before I really understood what
exactly these these guys are trying to
tell me in the text and translate that
to real-world real-world scenarios and
real-world code and understand what the
underlying value propositions are so the
reason I'm going to spend about the next
15 minutes or so talking about domain
driven design is to help you get over
that hump okay so I don't want you to
spend two years reading Eric Evans's
book trying to figure out how what the
heck easiest is this guy saying okay so
I want to give you a real-world
pragmatic practitioners view of domain
driven design so the way I've chosen to
do this is I've actually chosen two of
the most iconic graphics in domain
driven design when you read that read
the domain driven design architecture
you will come across these two graphics
if you understand these two graphics or
at least get a basic gist around it and
get your head around it you will
basically understand I believe 80 to 90%
of what is actually important about
domain driven design all right so let's
go to let's go ahead and give this a
shot for those of you in the back I
really I I if you have a cell phone if
you have a smartphone try and pull up
that present
and look at the graphic it's gonna it's
gonna just make your life a lot easier
otherwise I'll just talk through what
the graphic is is and hopefully you'll
get enough out of that
okay so first and foremost let's talk
about well what exactly is domain driven
design what the heck is this thing so in
all reality domain driven design is
actually a very one very simple concept
it is a concept that your software
there's the code that you write should
very closely model the real world
problem that you're trying to solve okay
so why would you bother doing this
there's two important reasons why you
want to do this first and foremost when
you model software in such a way imagine
you know using the same type of
terminology with your business business
analysts to your system administrators
all the way down to your DBS using the
same words and same same same verbs and
same nouns okay so when you do that
you're essentially setting yourself so
far for a far more maintainable and
agile system the principle reason for
this is because the translation cost
basically goes away okay so in general
if you do not have this thing in mind
what do you mind what you wind up with
is a code that is friendly to the
machine and not very friendly to the
human and very very distant from the
actual real-world problem that you're
trying to solve so imagine if you know
if you're if you're some poor soul that
was you know thrown into such a project
and asked to deliver some functionality
you would not only have to understand
the business but you'd also under have
to understand well how exactly is this
business problem solved in this in this
bit of software that looks nothing like
your business right so that's a reason
number one and to apply to maintain to
do domain driven design and what's
called a by the way this concept is
called ubiquitous language we don't need
to really remember the name but remember
the remember the concept so the basic
concept is you know you you design your
software such that it looks like the
real world problem that you're trying to
solve and in the end you get agility and
maintainability okay especially
important in enterprises where you may
have a large team or some turnover and
the like
alright so
that is believe it or not all you nearly
need to know about the definition of of
domain-driven design the next things you
need to know is what are the important
design patterns or design constructs in
domain-driven design and that is what is
reflected in this graphic here so let's
take each of these elements in turn and
try to explain exactly what it is that
they are the heart of this diagram here
is actually this portion here okay
inferring so imagine and imagine imagine
a boundary line here this is a sub
that's really important to know or not
understand and all those the most
important thing is an entity all right
so can anyone guess what an entity is
it's a relatively natural name it's easy
to figure out what what an entity might
mean yes sir row in the database sure or
in in all right in in a bit more
abstract highfalutin way of thinking is
essentially concepts or nouns in your
system right in your them in your domain
model things in your domain model is an
entity what is it that makes an entity
an entity well it's a very simple thing
it's so it has to be a thing a noun and
it also has to have a uni it has to be
uniquely identifiable as you said a a
row in a table that has a primary key
okay so that is what makes an entity and
entity the other important distinction
is that in domain-driven design an
entity will both have state and behavior
okay so go back to your roll back your
mind into your CS one or two or CS 101
class okay an object is supposed to have
state and behavior and hence it will
model things in real life and things in
real life generally have both state and
behavior yes sir
right so that would be an anemic domain
model right so that's the kind of thing
we don't want right so we want a a rich
domain model that has both state and
behavior right so entities will have
will will store their their current
state as well as you know the actions
that you can perform on those on those
entities and we'll see examples of this
right it doesn't have to be the power
whole point of this there was a in and
second part of this presentation is
actually to show you how this works in
real world and why why all this all
makes sense or might make sense
hopefully a close cousin of entities or
value objects can anyone guess what the
difference between an entity and a value
object is yes sir
somebody else they do not have a
identity yeah they are not uniquely
identifiable okay so similar to entities
value objects are things in your domain
model concepts in your domain model the
only difference is that a value object
is not uniquely identifiable the only
way you can identify a unique object is
you essentially have to associate a
value object to an entity okay examples
of this things like address okay phone
number you know X I this these type of
things they don't really make sense to
create their own little table in the
relational table to be very simplistic
but in an inner object world it makes
sense to have contained relationships
okay so this thing is it contains these
other things all right so this is this
is what a value object is value object
will also have both state and behavior
okay closely related to these two guys
and more related to the mechanics of
maintaining the life cycle of entities
is a thing called a repository anyone
you want to guess what that is very
simplistically speaking yes so you're
you're you're mostly correct so
basically a repository is this a is a
facade over your underlying persistence
tier okay and that may be a data
relational database in may
don't be a relational database it may be
some external other system whatever it
may be some way or whereby you can save
things from memory to persistent state
well why the heck you do you need to do
that or the reason you need to do this
is because you know if systems are up
and running but they're not gonna stay
up and running all the time right so
they're eventually there you're going
there they're going to go through a
reboot cycle and hence you need to
almost always you know save the state of
an entity or a value object from memory
to persist on a disk right and the whole
purpose of a repository really is
basically to abstract out that actor
that mechanical act of saving in the
persistence tier from the actual domain
model concern so from a de minimis
perspective you're just saving the state
of an entity retrieving the state of an
entity updating the state of any entity
removing an entity and how that actual
those operations take place is not a
domain concern all right another closely
related closely related concept to a
entity and a value object is a factory
all right so let's think about this
black actually before I talk about you
know let me let me change my mind
sorry okay reset the other the next
concept that I need to explain to you
before I go try to explain a factory is
an aggregate all right so let me try and
explain an aggregate real quick it's not
initially it's C it seems like a
daunting concept it seems like an
unnatural concept to understand but in
reality is actually a natural fit so let
me let me try to make it easy for you so
whatever your system may be today
imagine in your mind a giant whiteboard
in the sky where you're going to put in
every single table that you have and you
know you're going to map out all the
relationship relationships between
tables right so it's gonna look like
stars right a whole bunch of stars in in
the open sky and the connectors will
look somewhat like you know maybe your
astrological astrological map alright
and what you'll find is then when you
create these astrological maps of
entities and value objects
interconnected with each other with
relationships what you will find is that
you'll find class
stirs of entities and value objects some
value objects and entities will be more
related to each other than then another
okay so typically these clusters will
look like here's an entity it says it
has a close relationship with yet
another entity and then this sort of
this spoke a pattern or value objects
attached to attach to each of these
entities and then there's some other
entities out here that are similarly
closely related and each of these
clusters may have very thin through a
thin relationships with them so each of
these clusters of entities is really an
aggregate okay so it's a grouping of
entities and value objects in your
domain model all right
generally speaking domain driven design
dogma is that an aggregate should only
have one aggregate root okay and that's
going to be an entity and the entity
that aggregate root entity will control
access to the rest of the rest of the
members of the of that aggregate okay by
and large this is true okay in the real
world I have seen exceptions but it's an
important concept to understand it's
it's something to strive for rather than
necessarily take as a rule okay it's
something to keep in mind in your design
thinking all right so now let's go to
factories imagine yourself now your
instantiate a new part of your your
model so you're inserted inside
instantiating a thing and this thing it
can be related to other thing closely
related things and that are either have
their own identity or not the problem is
in some cases instantiating this new
thing is a simple as simple as creating
a new operator and creating a new object
however sometimes it's not as hard as
that not as easy as that because of this
aggregate situation okay so what will
happen is when you're when you're
creating entities you'll create clusters
of entities together generally then
perhaps the entire aggregate all in one
go so imagine a whole bunch of new
statements and some crazy rules
enforcing how these things should be
related and the like okay so if you did
this over many many blocks of code and
copied pasted this over clearly your
violating some dry principle don't
repeat yourself
okay so factories are basically ways of
encapsulating this aggregate aggregate
creation script okay inside of a inside
of a factory method usually this factory
method will either implement the
singleton design pattern or the Builder
design pattern or both okay all right
beyond this I'm going to throw you
another mind bender okay as if the the
aggregate wasn't a mind mind-bending
enough okay is a thing called services
alright so what do you think of when you
think of service most people every
average developer yes sir
okay you're not an average developer
okay Web Services yeah this is this is
not services in that sense okay so this
is called a domain service all right and
I mean that in in the most flattering
way by three all right you're above
average of lover uh-huh alright so uh so
a domain service so when you when you
think about your domain you can think
about your business back to your debate
business domain you have things in your
domain okay but other than things which
are nouns you most likely also have some
verbs all right and the verbs are
important enough to be peers of these
things rather than their subordinate
okay so if there if there is subordinate
there would be behaviors of these things
rather than a peer of those things so
let me can you somebody give me an
example of what is a verb that's
important in your system important now
so to to be the peer of the things in
your system system if you can't I'll
give you an example I have a canned
example that I that I can use place
order not quite know it that will
probably say not quite know authenticate
yes
yeah authenticated a good is a good
example but I want to a slightly better
one Mohammed you want to try
okay not quite okay let me help you one
last chance yes sir
transfer very a good example so you are
dealing with a banking system right so
in banks you know you have things right
account account holder balance and these
type of things
however transfer is a non-trivial
operation because the transfer may be
from one account to the other or it may
be between between banks all right and
it's actually a very critical operation
to get right in a banking system if you
get transfers wrong you're basically you
might as well be out of business
okay so a transfer object is actually a
domain service okay it it belong is it
is a peer of entities and value objects
and it will act upon entities and value
objects to do a specific action a one or
more closely related related actions
that is what a domain services alright
it's it's a peer of it's a part of your
your domain model domain services
generally speaking will tend to be
stateless okay keep that in mind all of
these things that I'm kind of gluing you
in are going to be more important when
we talk about well how does this
actually map to encode and in particular
how does it map to Java EE okay as a
technology okay
beyond all of these things to make all
of this work okay so this is your
conceptual domain model but it actually
doesn't it doesn't do anything on its
own in order to for it to be doing
something useful you will either you
will usually attach it to a UI or
interface of some kind okay and it then
that brings the thing alive right it
makes makes a useful interactions
possible with this - with this domain
model the other thing you will you will
have to deal with is something called
layered architectures and we will talk
about why that is important in a second
okay so before I move on I just want to
briefly ask do you have any questions
No well okay I'm gonna actually skip
over this part don't worry you didn't
really lose that much okay you can you
can take a look at the graphic later on
or it's yes sir something like transfer
will be it will not have an idea it will
generally be a service it will be
completely stateless so hence it won't
identity doesn't wouldn't make sense for
it it would be a verb rather than a
thing a thing would usually have an idea
I have an identity a pair of an entity
means it's conceptually they at the same
level as as so think about this so there
are two different types of verbs in
domain-driven design one type of verb is
a behavior of an entity right and that
is because it's it's not really
significant enough it's it's more
naturally attached to a state change in
in the entity whereas a domain service
is usually a much higher level construct
that's important enough to represent at
a in your domain model at a higher level
number one and usually it will also act
upon multiple entities or value objects
okay yes sir absolutely yeah actually
that that would be the that would be
what you would opt for but again you
know you have to have the domain service
possibility in your mind so that you
know if something is a natural fit for
that you know you would use it for that
instant right to actions that occur
within the two actions yes
so generally and a domain action will be
part of an aggregate you are you are
correct about that then you may have
more than one domain service within an
aggregate as well but yeah generally
speaking you should try to fit in a
domain service within an aggregate does
that answer your question yeah okay yes
sir
CQRS you're talking about a query it
would be actually a concern for the
repository okay so what you're doing
there is essentially querying your
persistence source to retrieve a certain
subset of entities err or a certain
subset of your certain certain part of
your domain okay so that would be a
repository you had put in finders in
your repositories and implement those
finders okay any other questions moving
on
no generally the finders will generally
be repository methods yeah because they
will be closely related to the retrieval
of a of an entity or a value object or
rather an aggregate very good question
so this is an important distinction
between the like Dao pattern that you
may use to and repositories in the Dao
pattern that's part of the j2ee
blueprints generally you will have a Dao
per entity okay in this world though
what you should strive for is actually
to have a repository per aggregate okay
so you're gonna retrieve your entire try
to retrieve your entire aggregate at at
the same time so basically you will have
the aggregate route and aggregate route
will be the name of the repository I'll
show you examples of this and you'll see
what honey okay okay any other questions
and yes sir
creation of the entity is made of
creation of an aggregate will will can
either be a factory if you're creating
it brand new or if you're doing a
retrieval it may be part of a part of
the repository so two possibilities so
it would be a factory usually yeah
unless it's as simple as creating a new
operator and calling some setters and
getters okay in that case you don't
actually need a factory it's so it's
just unnecessary overhead okay any on
the clock yes Mohammed
so we'll cover that case let's talk
about that in a second we'll actually
cover this cover this case right now
yep all right so next concept that you
should understand in domain-driven
design and this is somewhat of a
controversial concept and I actually
don't think it's controversial okay but
let's discuss it for a second so let's
assume for a second that you have so
layers layers has become somewhat of a
dirty word
thanks to principally Duty the Ruby on
Rails community and of late you know the
Grails community and things like the
node.js community and the like okay so
whenever you mention layers they think
you're you know some evil person that
you know should be damned to the seventh
layer of hell and whatnot okay but let's
think about this from the from the
perspective of the average Java
developer imagine a world where you are
not going you're not allowed to use any
layers whatsoever what will you you
should you wind up with how does that
code look like well in six months to a
year or two a couple of years a couple
of giant classes exactly so the good
symptoms of such as such a system is
usually you open up a component in its
thousands of lines long and that same
same component is what I lovingly call
the uber component okay so it does
everything right there is a some some
domain model that perhaps a nicely
create even a nicely created domain
model and yet you have these giant
components that do basically everything
from UI rendering to database logic to
web services and every and everything
else not a very very fun situation to be
walking into okay as a as a maintenance
developer so that well that's it there
are some systems for which layers are
overkill what type of systems are these
well prototypes
very small one-person projects in my
opinion anything that falls within let's
say ten to fifty thousand lines of code
may be okay that's that's an okay
situation to say yeah well I'm not gonna
have layers it's overkill but beyond
this okay when you're talking about
hundreds of thousands of lines of code
millions of lines of code which you may
surprise you you actually should do a
line count on your own systems and
you'll find out that your whether you
realize it or not you're probably in the
million order okay most Java developers
are that is not a sustainable situation
to say I'm not gonna use any layering
and I'm just gonna stick with just using
you know this this one monolithic uber
component okay so this is so this is the
reason for layering
what does layering accomplish well it's
actually a very simple concept what
you're what you're essentially doing is
they're you're taking this imaginary
uber component and isolating that uber
component into smaller components
grouped by your related functionality
the types of things that they do alright
so that is what layering is it's an ah
it's a identification and isolation of
concerns that makes your code a little
bit more manageable and a bit more
readable so when you're reading a
particular layer you're just concerned
with this is I know exactly what the
type of work that I'm doing and this is
what this layer contains and nothing
more okay fortunately for us most
enterprise systems actually fall pretty
cleanly within a well we'll understood
recipe a layers recipe and what is this
recipe we'll here's a recipe I think
this one you can probably read from the
back I hope ok so at the very top of
this layered cake is the interface layer
ok so anything that talks to and enter
an external or an external entity in the
simplest case it will be a web UI or
graphic graphically or you know or
desktop UI and the like so that is your
simplistic case of an interface however
it may not miss merely be just hat ok it
can be a web service ok it can be a
scheduled batch execution it can be a
rest interface it can be a WebSocket
interface these are all interfaces the
critical distinction is
you are talking to something outside of
your system that you receive input and
output from okay so that is what your
interface clear is below the interface
layer is what is going to be the
application layer and what is this
this is actually another different kind
of service the application layer
consists of application services okay
and what do these what are these things
these are basically modeling the
high-level use cases of your application
so if you look at an application layer
component it will tell you this is what
this system does at a high level this
will be you know what your business
analyst can read and understand exactly
what is going on what are the services
in this application provides and also
generally speaking if you're using BDD
by the way behavior driven development
these are the services that you'll be
writing your tests against ok because
this is this is the this is the system
behavior ok beyond the below the
application layer is your domain layer
so all other things we talked about
domains or other entities value objects
factories repositories all of these
things belong in the domain ok
infrastructure is a cross-cutting
concern all right in in in domain driven
design and this is actually very
important when we talk about mapping
this concepts to Java EE because what
happens here is that you basically
attach infrastructure code at whatever
layer that you want ok so if you want
your interface to do something you make
access of infrastructure API to do that
thing ok similarly if you want as some
services in an application layer let's
say monitoring or transactions you apply
some infrastructure to make that happen
if you want to implement a repository in
your domain model you have to attach
some infrastructure ok namely you know
database access code to make the make
make the repository actually do
something all right so this is
infrastructure is a cross-cutting
concern yes sir
no no no that's yeah so this is a common
mistake so your application layer is
going to define your high-level behavior
right whether a domain whereas a domain
service actually will will be actual
business logic so there's actually no
business logic in the application layer
the application layer simply is actually
a coordinator right so it takes it
coordinates actions on on your domain
model it it itself is very very thin
it never includes any any business logic
whatsoever so that is that is very very
much the opposite of the j2e blueprints
and there's j2e blueprints the
application layer will generally be a
session facade and it will contain
business logic or it will be a business
delegate in fillet it will contain
business and business logic in this case
no that's not going to be the case no it
may be that you actually do access
domain services directly from the from
the interface that's going to be the
next and next point that we're going to
talk about okay
so by and large you are going to access
this layer cake in a highly hierarchical
fashion okay so you're gonna aim your
default mode of thinking should be that
the interface will talk to the
application layer and the application
layer will will talk to the domain layer
however that may not always be necessary
okay so there may be cases where you
don't actually need an application layer
and you can if you wish directly talk to
the part of the domain layer okay or
access a domain service directly from an
interface that is perfectly valid okay
there is nothing there's absolutely
nothing wrong with doing that as long as
you are reasonably reasonably
conscientious about using layers okay so
if you need a coordination layer if you
need complex coordinations then by under
a bind then then by all means you should
introduce an application application
service if it's a very simple thing that
you're doing like in Muhammad's case
just doing a finder and showing some
data data in their UI will you don't
really need an application service for
that you know you can just directly
access the repository from the UI if you
so wish okay we're all good with this
moving into the more code intensive part
just parts of the talk no no it's fine
sure
binaries are set up to allow that don't
know this is the Java space
so the answer to your question is in
standard Java not yet okay so we have
packaging but that's simply a way of
essentially bundling code the work that
what you're describing is actually an OS
GI service okay
that's what that's what you know is GI
bundle does it says these are your
specific access internal and external
access reference points
hopefully we may have that in Java 9
right but the answer short answer is not
in standard Java right now if you want
to do something like that you know you
should be thinking about OSGi for now
all right moving ahead how are we doing
on time ok mapping DDD to Java EE ok so
this is to me this is the this is the
most interesting part of the talk
frankly speaking so once you understand
domain-driven design the other very nice
thing you'll realize is that the
concepts in domain driven design and
concepts in in Java e mesh very well
together to some degree this is a happy
accident this was not intended to happen
however the reason this happens is
because in Java EE we tend to modularize
things so he has specific API is that do
specific things and what actually as a
happy as a happy coincidence of that
fact what happens is usually you have a
one-to-one mapping between a DDD concept
and how it's implemented in Java EE
okay so I've represented some of these
nothings Java EE is a large API set as
you know so if I try to graph all of
this out you know this would be a rather
large graph so I'll just give you a
flavor of what these mappings look like
when when you're trying to map concepts
in domain driven design to concepts in
Java EE and API is in Java EE so the
interface part is fairly simple
okay so generally you you implement in
web interfaces in Java EE using JSF okay
so JSF belongs in the presentation
everything that there is a JSF component
by and large will belong in in the
presentation tier okay similar thing for
jax-rs services okay so if you're create
you have a jax-rs resource that is
really part of your interface layer okay
similar thing for WebSocket interfaces
you know these also belong in your
interface there Jade Java batch the
something that was added in in Java EE 7
also WebSocket was added in Java EE 7 as
well these are all things that belong in
the interface okay so this is a distinct
concern and in this layer you're really
dealing with input and output concerns
no domain concerns per se okay just
handling input and output doing some
simple validation doing some simple
conversion perhaps alright so this is
the kind of code you should expect to
see in the interface layer using these
api's yes sir so base web services are
also a part of the APIs and so jax-ws
would be generally speaking in the in
the interface layer the application for
the application services layer easier B
is actually very very ideal okay
because application services in in
domain driven design tend to be
stateless and you know basically you
have a out-of-the-box canned annotation
in Java EE called stateless okay so by
and large your application services you
will be a stateless session bean why is
this the reason for this it goes back to
thinking about well well what is a
domain service a domain service is a
coordinator its principal role is to
coordinate your domain layer
transactions or rather doing domain
layer interactions for a given use case
so this use case is actually a unit of
work okay so this is the unit of work is
ideal if not if not absolutely perfect
location to attach things like
transactions okay sacred declarative
security declarations or role-based
security declarations any asynchronous
processing that you may want easier
stateless session means generally will
come with pooling capabilities which
will be very important for the
application services to make scalable
application services okay so what for
those of you who don't and know what I
mean basically what this means is for a
stateless session me in a stateless
session mean as an upper bound pooling
limit okay so in in gloucestershire for
example that limit is 15 concurrent
connections for a given for a given
stateless session bean method okay so
what that mean
when you have let's say you have a
hundred requests coming in the EJB
container will actually pull on the 85
requests that it cannot handle
concurrently and only process 15 in
concurrently the other nice thing with
ej bees certainly any lost fish and
containers like WebLogic stateless
session means are also monitored which
is very very a nice semantic fit okay
because then then you can go ahead and
open up your login console open up your
JMX console and lo and behold you are
able to see okay at a high level what is
happening what is what what is the
behaviors that my application is is
performing you know what's the average
response time what's the failure rate
was the success rate and the like okay
so it's a very good a very good fit for
the EJB programming model entities JPA
are entities in in know in driven design
are a very good fit for JPA entities
okay almost a 99.9% of cases if you're
using a relational database you're JP
entity is your entity will be a JP
entity okay there's even a an a a happy
match of names even there okay similarly
value objects will generally be JP a
embeddable okay so again pretty
no-brainer JP m embeddable czar
basically entities - identity okay which
is exactly what a what a value object is
weak entities
sure yeah and also in the interaction a
majority of Java EE is concerned with in
with providing you infrastructure okay
so think about that what I said
infrastructure is a cross-cutting
concern so what do you do is when you
want services you essentially add
annotations for the most part okay you
either write api's or you write
annotations when you're using
annotations what you're really doing is
you're you're declaratively supplying
infrastructure into a component in a
very very differently way okay so
basically what's happening you're
maintaining your clean domain model and
just adding the services that you need
via metadata
without interrupting your business logic
without interrupting your domain model
whatsoever a similar thing for API so
you know the JPA entitymanager api this
is not an annotation based mechanism
this is actually writing code but
nonetheless this is infrastructure
infrastructure code if you're when
you're writing GSF components whether
you're writing a model or a view those
are all really parts of your
infrastructure concern whatever tier
that that that they may belong in so
interesting so there's a whole bunch of
infrastructure api's in java ee JPA a
JMS you can even consider jax-rs clients
and and JAXA jws clients part of your
infrastructure as well because what
you're really doing there it's an API to
talk to an external system to provide a
service okay typically this will
actually be in your dao layer okay or
some other layer whichever layer it may
be alright
so introducing the application alright
so here's the application it's a car
boat record or java.net it's basically a
an open source project I'll show you the
the website for this real quick so
here's the website you know there's a
basically much of what I covered about
overview getting started but more
importantly you can go and download the
resources ok so sorry download the
source code behind this application I
have the instructions for the source
code is basically written in maven okay
it's a simple maven Java e7 application
you can open it up in NetBeans you can
open it up in in in Eclipse okay right
now the code is written to Java EE 7 and
GlassFish 4 you can in theory port it to
any other application server any other
Java of an application server let's say
maybe somewhere down the line web logic
or certainly wildfly or what have you as
a matter fact here's a little pitch
always looking for contributors ok so if
you wanna if you want to contribute to
the project that those would be good
contributions ok and we also have a set
of other contributions that you can help
us out with as well okay so go ahead and
hopefully after this session you'll go
ahead and go to the website download the
source code and play around and see what
what all of this stuff is all about ok
let me do a very brief walkthrough of
the code so we will go ahead and start
this IDE up start the application up yes
sir it's domain object first most
certainly yeah they did the database in
fact is in my cases generated
dynamically using schema generation ok
because this is not a production
application really so that's what I'm
doing there and I hope everything goes
well yeah I didn't try this in the
morning I didn't have time so hopefully
it's all gonna work keeping my fingers
crossed yes sir I you considered a bad
bad practice ok let's talk about there
in a second
okay well this is starting so one thing
you should know and I should give credit
to this application is actually not I
didn't write this from scratch okay so
the original application actually comes
from Eric Evans his work okay and Eric
Evans is the guy that wrote the
basically the domain driven design book
he actually has a project that he worked
on to provide a real-life example of
domain driven design basically what I
did was I ported over that code that
code was rather old it was written in an
old version of spring and hibernate i
ported it over to GlassFish 4 and Java
EE 7 added added some additional
functionality and modernized it ok so I
hadn't made it hopefully look a little
bit better and actually I'm working on
the look and feel right now so excuse my
appearance ok so what is this
application basically this application
is a cargo tracking okay tracking cargo
going and going across the globe there's
three distinct interfaces to this there
is a landing page so imagine this is
like your USPS tracking tracking
interface okay so you register your
packet with USPS or in this case log
your cargo with the with the cargo
provider and now you want to find out
okay where is my cargo it's so you can
say abc123 and hit the tracking
interface and it will tell you what
happened to your cargo what are water
all the events so in this case it was
received in Hongkong loaded in onto some
voyage in Hong Kong and on offloaded and
in New York and we estimate this to be
arriving in Helsinki and some other in
some at some date okay so there's the
tracking interface there is also a
administrative interface okay so I won't
show you a lot of this I'll just show
you very quickly what this is all about
basically this is your your dashboard
this shows you what are what are all the
cargo information that is available here
you can book new cargo it's relatively
self-explanatory I won't go over this
too much because I do want to show you a
little bit of the code but basically
take a look at this yourself it's a
relatively self-explanatory what to do
there's also a mobile friendly interface
so I have a mobile web interface here
and this is the guy where once you
register your cargo
you're the guy at the port that's
handling the cargo okay so your linter
and things like okay this is when this
cargo event happened this is a tracking
ID this is a location code where this
event occurred and there's there's
various types of events that you can
that are modeled here so you're loading
cargo onto a ship receiving cargo and a
port and the like okay so the way to
figure this out is actually to read the
readme file okay so when you download
the source code you want to figure out
what this application is doing generally
speaking just to play around with it
start with the readme okay and it'll
tell you generally a workflow of what
this what this application is okay so as
you can see it's a relatively
non-trivial application actually let me
go ahead and do a booking real quick I
agree because I have to do this to map
to show you some of the code so let's
say it's going to hong kong and it's
going there on november 19th
hitting cargo that's now it's the cargo
registered okay I'm going to try to
route this cargo so just like an airline
reservation system you'll be given some
examples of how this cargo is supposed
to look like
you'll get your last sign into route and
now you're assigned this particular
route okay now you can register events
against that okay don't worry about it
if you don't follow it quite verbatim
you know hopefully you'll get it when
you read the readme file okay
so how does this application actually
look like believe it or not this
application is already about 1200 about
12,000 lines of code okay so we're at
the at the boundary of where you know it
becomes sort of nonsensical to not to
say we don't want layers anymore so
believe it or not because of the of
layered architecture so this is where
we're layered architecture really shines
okay even though this is a 12,000 line
application you can generally by and
large take a look at the packaging okay
and the packaging really reflects the
layers of that are present in this
application and you can generally guess
where to start right or where you where
you may you may start looking at
functionality if you want to find out at
a high level what this application does
you will look at the application layer
you see that there is a domain domain
package and within this domain package I
actually have several models and these
models actually represent this aggregate
thing that I talked about okay so that
that's an aggregate each a cargo is an
aggregate location and is an aggregate
voyageurs is an aggregate and we'll dig
in beginning to that in in just a second
you'll also see that I have a domain
service okay in my case the domain
service is routing so remember I entered
I I registered the cargo and then I was
looking for what the possible matches
are the guide that actually does that
matching algorithm and that's an
important part of this system and hence
that is actually a domain service okay
in this case he's actually a distinct
domain service he doesn't belong in in
any aggregate per se okay he's kind of
on his own on his own box there's also
various bits of infrastructure I'm using
Java EE infrastructure so that I'm using
CDI I'm using JMS as my infrastructure
I'm using some JPA as my infrastructure
okay and then you'll also notice that
have several different types of
interfaces so have a booking interface
that's the interface that you saw where
I was doing the booking of the cargo and
the like okay there is a handling
interface so I'll explain that and let
me explain that very briefly so what
that is is actually a rest-based
interface
number one the rest beta is based
interfaces use used by my mobile web dy
okay the mobile web UI is just actually
plain JavaScript so you could basically
load it and it'll it'll work potentially
all the way off line okay but when you
actually are registering events back to
the server you you actually invoke a
rest service that's in part of my
handling repository okay similarly I
also have a filesystem base repository
filesystem based interface that is a bad
job okay so just like you can in a
mobile interface you can enter event one
by one
you can also batch load events so you
can pass in a CSV file in the CSV file
will basically contain all of the events
to be processed all right I want to dig
really quick into the application layer
so here is my application interface it's
called default booking service default
booking service is really the high-level
functions
that this that my booking service has if
I click on this guy you will see the
booking service consists of booking new
cargo requesting possible routes for
cargo you've seen both of these
operations I've showed you I showed you
them assigned route to a cargo you've
also seen this right so I took a bunch
of cargo routing possibilities and
assigned one to my registered cargo and
you can also change the destination
which I didn't show you which is which
is another UI which is another portion
of the UI so this is your essentially
your behaviors for the for the booking
interface you have four different
behaviors taking a look at the
implementation of one of these so let's
take a look at the implementation of for
example request possible sorry
assign route to a new cargo what you
will see is that unlike sort of the
business delegate and session facade
paradigm I actually have absolutely no
business logic here whatsoever okay no
business logic all this is doing is it's
it's a coordinating between the domain
parts of the domain object namely it's
coordinating between the cargo domain
object in the cargo repository okay so
basically I'm doing a fine by tracking
ID assigning route to the cargo that's
the actual behavior okay and it is
actually a behavior of the cargo domain
object okay so the cargo domain object
is known not only just a data holder but
also something that models behavior okay
and basically what's happening here is
you're your co-locating the the state
and the code that acts upon the state
okay far more readable and maintainable
in little longer okay and we finally
have a repository dot store the
repository is nothing but a JPA
interface JPA implementation I will take
I'll let you take a look at that
on your own and as I mentioned this
service itself is actually a well
surprise surprise it's a stateless
session bean okay so as I mentioned it's
a good fit for this because of what's
happening here is that all of my
behaviors are essentially by default
transactional secure you know all of the
other good stuff that and that an EJB
provides looking a bit into the domain
model let's
look at the most important domain model
in rather doing aggregate in my in my
model okay that's the cargo interface so
the aggregate route for the cargo
intercourse the carbohydrate is actually
an entity called cargo okay and the rest
of these guys are sort of its hub and
spoke model it's part of a part of its
larger aggregate similarly if you looked
at the voyage voyage aggregate it's a
separate you know sort of constellation
that has its own related entities and
value objects right looking a brief look
at the few minutes that I have left I
will show you the cargo real quick again
the cargo is an entity and hence it is
modeled as a JPI entity so there is the
at entity annotation okay it has both
state okay so this is all state alright
and inside of the state I have embedded
objects okay so these are basically your
value objects so things like for example
a routing specification okay that is
actually a value object okay it is a
thing that doesn't have an identity or
of its own in in JPA it has a direct
modeling of with the embedded embeddable
object so that's all the state I'll take
a look at let you take a look at that
but there's also behavior as I mentioned
and if you look at for example things
like specifying new route right there's
a bunch of business logic going on here
so for example if I look at the delivery
object it is doing things like
calculating the last event calculating
whether this this entity is misdirected
calculating the routing status and whole
bunch of other business logic going on
so essentially logic that is acting upon
your data okay so to change the change
the ITT state alright I think that is
all I'm going to talk about in terms of
the code I hope you'll take a look at it
and I've given you enough so that you
can begin navigating this yourself and
hopefully ask me any questions that you
might have before you going this is the
most important slide of this of this
presentation okay
and then after that if they don't kick
us out we can do some a little bit of
additional Q&amp;amp;A if you want to stick
around first and foremost a project
itself I do not recommend starting with
Erica Vance's book okay do not do it
okay so here's here's what you should do
instead you should go and download this
ref card d-zone ref card okay it's three
pages it will explain to you basically
what I try to explain to you in the
first part of the presentation there's a
small little iBook it's like it's like
cliff notes for domain-driven design
okay it's a it's from info cube calm
it's a free ebook you can go download
that again and give that a read after
the ref card and then finally I want you
to give credits to Eric Evans as
original project it's over there for you
to take a look at if you want to learn
more about Java EE 7 okay the best list
we'll start doing that is the official
Java a7 tutorial and I also like to make
a little plugin to plug into my guitar
sort of team blog
the aquarium blog it's a daily blog we
try to blog about in everything and
anything in the Java EE ecosystem since
I am a Java EE evangelist at Oracle
Corporation so definitely appreciate you
following the aquarium alright thank you
very much please free to feel free to
leave and if you have any questions I'll
take some questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>