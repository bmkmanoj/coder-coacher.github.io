<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda-izing JavaFX | Coder Coacher - Coaching Coders</title><meta content="Lambda-izing JavaFX - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda-izing JavaFX</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wbaflWdy9IY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone I'm Steve north / client
architect working on javafx development
manager too I've been in doing gooeys
for quite a long time and been doing
different languages quite a long time so
I have a history with eclipse quite a
long history with eclipse i have a
history with small talk which is a
language that had lambdas and to start
with and i worked at IBM for quite a
while until I decided I'd had enough
there and came to work at Oracle so it's
been a about last three or four years at
Oracle and drawing myself with this guy
with me today is Philippe Heydrich yeah
um actually share some of that history
except that I'm not arced at I'm just a
minion get work done and I was a minion
under steve back and IBM when he was
developing swt and Eclipse working two
kids and graphics and then when he moved
it took around for a couple years then I
decided that stew code in Auto for a
Brazilian and ended up here in santa
clara and working as a minion for steve
once again so I javafx I quit and try to
get away like and I fallen I he follows
me around getting away so it's like a
stuck on the bottom of my shoe anyway
thanks well you gotta have the scraper
by the way I'm you see that this talk
has land in the title which means you
know it's the last day of the conference
is this the second last lot so this is a
pretty terrible slot and this is a
pretty good turnout considering Adam it
has lambda right so if India holidays
are about early zero discussing what
talks is to be made for a jobber one and
I said well maybe just throw la mattina
tighter that should get deep in the room
yeah and that's why I'm here pretty much
so I you're either the straight one of
us is the straight man there is no a
straight events time Steve out king no
well oh that come up the wrong
yeah that said that is actually work
that we did that we change our inner
class to use lambdas and we had a
technical reason for that and we learn
through this experience only has some
results what is learning and we'd like
to share so it's something that you're
probably going to do with your code base
and you know with just this kind of an
experience report thing so this is the
useless lawyer slide there are any
useless lawyers here what about the
night is all de l'homme de kothlis what
about the day anyone so in here are
there any members of the knights of the
lambda calculus here etrg does exist it
does exist I'm a member of the knights
of the lambda calculus I've been I'm a
card holding member and have been so for
a while the secret sign is this by the
way so do you see someone doing this
you're not supposed to reveal that it's
the secret side it's not I have a lambda
pin I should have brought it look it up
look it up it exists ok so let's talk
about lambda a bit here so this is from
from wiki petty PD at lambda is an
anonymous function it's just an unnamed
function but the interesting part is it
has a whole bunch of mathematical
history of mathematical science behind
it Alonzo Church is the inventor of the
lambda calculus in 1936 and he worked
with Turing there's if you look it up
it's quite interesting there's a church
Turing hypothesis and that's based on
that's based on the lambda work and it's
about computability so lambdas are old
and when I say old they're really old
they started off in Lisp in 1958 so the
first programming languages were Lisp
and Fortran I think for tram was first
like a member which one was first but
that's a long time so land is a concept
that's based on mathematics and it's so
that's interesting stuff so here's a
kind of history of programming languages
lists list pad them for
the start in 1958 so all computation is
done with lambdas in enlist small talk
had them 1980 this is where I i did some
lisbon you everybody had some listen
lisbon university but i worked quite a
bit with small talk in the in the 80s
and they had things that are called
blocks and you know so and they were
part of small talk from from day one
1980 javascript as we know has lambdas
as a fundamental concept the function is
a lexical lambda the thing about
javascript is it was a language created
in 10 days supposedly i'm not sure how
much of a myth that is but that's the
claim c sharp has them so let's see at
the c sharp 30 c sharp always had
delegates i think there was some lawsuit
between son oh hang on i'm not a lawyer
but they had delegates and they added
lambis in 2007 Objective C has a
non-standard extension that Apple added
Apple guess is driving that so they
added that 2009 and C++ got any act as
well adding lambdas for C++ 11 2011 and
here we are java 2014 lambdas are in the
JDK and i'm extremely happy about them
because i really missed them since 1980
since or well I wasn't you know since my
small talk days let's imagine small talk
guy and you're doing lambdas because
years ago block and that's the alarm de
there so move to Java the designer
glasses that look terrible yeah it was
horrid it's okay for you know we were
doing small talk we moved to Java
because our company moves to Java saw
the white writing on the wall and small
talk and we were all these programmers
that just you know you're doing Java now
some people quit their jobs but not me
ask Philippe said in small talk a lambda
was an open square bracket bracket in a
closed square bracket and that was it
and no restrictions on visibility but
let's keep going so the question we have
here is what took Java so long I mean
the the languages on it's not that like
lambdas were new they've been
established part of a computing language
since nineteen fifty eight
so what took them so long so um we are
not answering that you know we're not
answering that those questions but there
are some conspiracy theories those are
some nice anagrams I found I'm sure
there's some more the bald my I wonder
if it's Sigourney Weaver or you know but
I think this is my favorite one I think
so the question is are lambdas full
lexical closures like we know that
they're lexical closures but are they
full lexical closures as defined by say
lisp or some of the other programming
languages so a electrical closure
requires that variables live on beyond
the lifetime of the method so if you
return a lambda and it's referencing a
variable that variables not on the stack
it's around for use when the lambda
execute that's what they're lex full
lexical closures they trap there in
closing environment and make a shallow
copy now I put shallow copy in quotes
because it's not exactly you know what
they do is they bind the environment in
in the with the lambda and each lambda
references that environment but you know
we'll get into a little bit of details
on that so variables are trapped within
the variables trapped within the lambda
environment are mutable so this is a
full lexical closure and in Java
variables reference outside of the
lambda must be effectively final so
they're not mutable so Java lambdas
aren't full lexical closures in the
sense that lisp or small talk or some of
the other languages have are right so
let's look at some JavaScript on the
left and some Java on the right this is
a generator function it's a stupid
little example it takes an array and you
call next on it or you call the function
that's returned and it gives you the one
at a time so you can see that there is a
local variable index that's local to the
new gen function and it's referenced
inside the function that is returned
from the new gen function and what if i
can say function a few more times in
that sentence
but the idea is that the actual internal
function ish is there's not a copy of
that around but the local variable index
that's used there's a copy of that
shallow copy if you will for each value
that is returned from the call of the
new gen so it's easier to understand
what I'm saying by looking at the Java
inter-class code on the right because
it's pretty clear that each time a new
instance of jan is returned it has that
index field in it so if you look at the
jet that JavaScript on the left is
essentially doing the same thing under
the covers so if you so this all
compiles now if you want to do a similar
sort of thing with Java you end up back
to the days of final variables and
arrays of size one how many people have
done this array of size one hack in
order to see a variable outside of from
the outside of an inner class one person
okay everybody that everybody has done
the array of size zero hack okay or or
you just learned a new hack today to get
around this problem all right that's
going to make the whole talk Worf
already there you go so it's worth on
the last day it's worth coming they may
be anyway look I you know I add this
pithy statement why can't the compiler
do this for me and this was I mean I'm
not a language designer and I'm sure
there's some good reasons why you can't
do that but just to give you context if
that thing was not an interior just like
integer int index you would not be able
to change that value from inside of the
ideal ammeter yes I me that's the trick
make an array that's a point the real
value yeah then you can make this
concern yeah so so if i can type in an
array of size zero why when the compiler
generates all kinds of boxing unboxing
does all kinds of magic for me why
couldn't it create array of size zero
not even from the day of inner classes
somebody will get me that the answer to
that and then i'll stop asking the
question okay so i was mad about that
so the question is our land is the same
as inner classes and they're not right
so they don't have local state fields
like we saw in those previous examples
they have different scoping and
visibility rules they just do by
definition and they have a different
implementation from inner classes and
that's really good because I mean
they're not implemented as a name
mangled class in a jar file which is
great for reducing the size of your jar
file but if you have a different
implementation of something you're going
to get a different runtime behavior or
you might get a different runtime
behavior so we used a IDEs to do the
lambda fication for us by lamb chops
play along so here's the tooling that we
use we used all three IDEs because at
the time they all had different bugs in
them so we you know we use them and
check the output at first it wasn't easy
to find the lambda fire they all use
different names so you looked around for
it you look for hot keys and stuff I
mean you know great but we kind of start
early in the process and you got all the
bugs to do with this way yeah and I
guess the last thing is javafx is a
pretty good test case for lambda fires
because it's got all kinds of hairy
generics and code patterns in it and
classes and classes within classes and
the video and he's responsible for most
of them no ok so good things the lambda
fires are easy to use and it's easy to
find and fix the problems that they
might create so they work most of the
time but they all have different bugs
and they still have bugs to this day and
it's much better than doing it by hand
because we added mean I could ask him to
do it he'd still be there typing now so
so the bad thing I guess is it would
have been nice to have had a command
line so that once we've got weed out
figured out which ones to use in which
methods to skip and this kind of thing a
command line might have been good and of
course there's the bugs and the lambda
fires which a lot of them have been
fixed because we did start the process
early so here's the IntelliJ lambda fire
it's called analyzed so analyze inspect
code then choose what you want to do
when I searched on lamb and I got lambda
fire and these are the actions I wanted
IntelliJ to take and also named the
action lambda phi so that i could
reference it later in this in this other
dialogue and tell it that the thing i
want to run is lambda phi so as I say I
mean you can find the lambda fires but
it you have to search within the
dialogues and whatnot so that's IntelliJ
skver junne Eclipse and netbeans have
the same thing same idea similar you I
similar behavior similar bugs Eclipse
it's called a cleanup and you you the
use lambda where possible you check that
one off and that means it's inspect and
transform and convert to lambda remember
references so we use the lambda fires we
reported bugs to all three ides as we
found them and you know and that's and
they were fixed a lot of them were fixed
during the course of our of the lambda
fication so you know report those bugs
there the IDE vendors are fairly
responsive it also helps when you might
know a few so now we get to what we
actually did lambda lies down on
broadway i just talked my required at
your notes a mofo you grew up in
American to 70s or 80s in North America
in the 70s or 80s 1974 yeah which is
about the age of F if you don't
understand it's a line neither do i
so we had some restrictions around how
we were going to do the lambda fication
process we could have done a stop the
world lambda phi start again process but
we didn't want to do that because
there's a distributed development team
and we have a concept of code ownership
where component owners are responsible
for reviewing changes and ensuring that
the code that goes into their component
is of higher high quality and the
component owners themselves were not
doing a lambda fication it was a you
know so the code was lambda fight and
then presented to the component owners
and for their approval etc we did lambda
conversion only there are options to
convert for loops and other stuff
iterators into streams and we would have
done that conversion as well but the iOS
and Android ports they could just about
survive the lambda fication by using a
retro retro lambda yes there's a there's
a open source project that takes lambdas
in terms it turns them into inter
classes called retro lamba so if we went
and used lambdas they could still
survive but as soon as we go to the
stream library there's no open source
stream library so that would mean they
were be completely broken so right now
we have lambdas all in javafx but we
don't have a lot of use of stream there
is some use of stream but it's inside of
low level platform specific code like
the windows port which iOS and Android
are just not going to be running ok so I
told you we did the one at a time we use
the best lambda fire we fixed the
trivial we fixed trivial errors or
sometimes we wrote an entire files what
we didn't want we didn't want bugs
introduced by the lambda fication we
want to be very careful is what did I
find was the best ide for lamb defying
none of them at the same time and all of
them they all had different bugs
a kind of a question is not come on all
right so it's not a fair question what
am I going to say I mean I used to be
involved with the clips I'm not going to
write it's polluting arrived politically
it's I used to be involved with the
clips i'm working at Oracle I the kind
of question to ask over beers actually
yeah okay so right so we did one
component of the time ran the tests make
sure they passed and so you know edit
wait so and that the component owners
knew that this change was coming and we
communicated through the mailing list
and and you know so slowly but surely we
lamb defied the code base and very
carefully checking as we went so we
never want it to be the case that we
couldn't find the change that may have
caused the problem if there was a
problem and of course we found some
problems so there were compile errors
that the IDE is introduced and those
ones are really easy to fix because you
get little red squiggles and you know
you just fix them or you revert the file
so that's easy then there were semantic
errors that you'd have to find at
runtime so the lambda fires would
produce code that compiled but did
something different and that both the
first to the compilers and semantic
errors are bugs in the lambda phi lambda
fires in the first case it's obvious
compile errors you shouldn't have that
in the second case the lambda fires have
to understand that the code that they're
producing is not equivalent right and
the last kind of error is which is this
is it it's kind of a tricky between
semantic err it's also a runtime error
and it's also found when you run the
unit tests and it's because that the
implementation of lambdas is different
from the implementation of inner classes
and that difference came through in you
know
in a particular rare case etc so I'm
going to just go through the ones we
found we are going to go look at a bunch
of you some example yeah yeah you're
going to see so the last you know the
take lambdas are great this was a smooth
process everything went really well we
had a lot of fun doing it so naturally
did I have the t-shirt runtime matters
they're far more painful to find
sometimes you get lucky in the genuine
it just gets it for you I think the
worst one took up two months later
there's a bug and which thread trace
back to lombriz is studying this
relation with your classes well we have
exams will keep going to get but the
takeaway is that it's you know well
let's keep going well get well I'm not
gonna give you if i give you the
takeaway now on the last day you're just
going to walk out you got to wait till
the end before you get the takeaway so
like lamb to the slaughter off we went
here's some interesting problems so
there will be three classes of problems
right so the first class is the compile
error so the first obvious one that the
and remember these were introduced by
the lambda fires so X is a field and
there's the inner class and when you
convert to lambda you get the can't have
a forward reference error so this is the
compile you get little red squiggles and
so those you know the expression on the
left when lambda fide gets you compile
error so that so the the bottom line is
the the IDE should recognize that this
is a problem and not either not lambda
phi or do something else what is one
fixative they're all objects no this is
not oh yeah this is yeah this one is
fixed by all the I this is the most
obvious one is fixed by all the idea IDs
now so the fix that you could use to
work around this problem if you were
doing it by hand and saw the strange
compile error was referenced was
this the this compiler works now
remember that intex that is a field okay
and so I mean here's another question
why can't the compiler do this for me
are there ball I guess there's you know
if I was a language designer I can
answer that question are there multiple
x's that in here that it could be
ambiguous and thanks thanks i don't know
let's review it let's restart the
computer in 10 minutes of you don't you
want to show an ID so i want to do that
no okay okay so i mean you why do you
want to show it in the ID go ahead okay
so um you know the compiler could do
that this for me i don't know i always
thought just talking about x and the
context of the object would be the field
but anyways so that's a handy hack that
you can not hack work around or if
you're ever land of flying by hand so
there's also variable a variable
shadowing error so that the lambda fires
were produced the thing on the right and
you can see that the Zed's would
conflict and in this case zed is a local
variable not a field so and you know
this gets caught by squiggly little
things in the ides write lambda does not
allow you to shadow and local variable
yeah and it's compiler ever so the fix
is to rename it and the ides rename them
now but shadowing of local variables is
not allowed in a lambda but shadowing of
fields is allowed in a lambda and i
didn't show you the code for the
shattering of the field but you know
believe me try it with your code so
there's probably a reason for that too
you know you can have the arguments
whether you like shadowing or don't like
shadowing I mean shadowing is good if
you have code generators that generate
code and the names might conflict
shadowing is bad because well it hides
variables and you can have code that
compiles and does stuff
that it shouldn't so you can have that
argument but we're kind of in a case
here where some shadowing is happening
is allowed and some shadowing is not so
here's another compile error that a
lambda fire introduced in here there's a
ton of different do privilege methods so
it's an overload due privilege is
overloaded with a bunch of different
arguments and a lambda fire produced the
code on the right which is the simplest
possible thing and what it should have
produced is add it should add the the
cast to tell you you know which
particular do privilege method the
return 12 lambda is referring to right
that goes back that with Rome does you
don't need to tell the type of the
variable except when you overload the
method then you had put in the area
doesn't know what Matt's a call so Java
is not dynamic at jama how to put this
correctly at compile time java knows
exactly which methods are going to run
in the normal stuff and this cast
privilege integer tells it which do
privileged i should run and you've seen
this before if you've ever overloaded a
method and you've had to cast and you
call it with null and you have to cast
null into the correct kind of null i
always loved that your hell java exactly
which method it needs to run and again
the lambda fires don't make this mistake
now they fixed so here's a case where a
lambda fire caused a cement so we've now
moved from the compilers to the semantic
error so these are the errors that we
find at runtime and this was a lambda
fire produced this error so the code on
the left the pre lambda code is expected
to fail with a cast class exception it
is not expected to throw the explode and
this was tested for in a unit test the
code on the right when it runs
we'll throw the explode error rather
than failing on the cast class exception
so we were we had code that tested for
the cast classics cast class cast and
Mark couldn't say it either this morning
yeah I mean it disciplines that game
because in the EV translation just
doesn't give it a time yes throw up to
the type yeah it's a bug in the lambda
fire but in this case you don't get a
little squiggly error that tells you
about it you find out about it at
runtime right and the lambda fires now
at least some of them correctly put in
the class the class cast in order to
tell it which to switch what happened so
when this runs now it will not run the
explode it will fail with the class task
exception as it is supposed to fix the
cast fire them another interesting thing
is the meaning of this so this inside a
lambda is the is not the lambda it's the
class where the lambda is defined and so
if you have crazy code like those stuff
on the right that egg that uses double
equals and object like identity things
can accidentally compile and just give
you the wrong the result because you
because this is not what this used to be
right in the inner class days in the
right is always a result of false yeah
yeah it never happens because it's never
identical it's not what the object
itself itself is never so normally you
won't get this problem because when you
start referring to this in a way that's
wrong you'll get a compiler right but
this is because double equals happen to
be used and double equals is understood
by every object in the universe yes
so I mean in this case don't lambda phi
it right okay so I've already yeah so I
guess the lambda fires didn't get this
one wrong try to explain this the last
one is really interesting and this is
the remember I said there were three
failures that could happen this is the
third kind of failure where the
implementation of lambda was different
from the implementation of the inner
class and somehow this code was relying
on it though the code on the left it's a
little bit I mean there's more than two
lines or something it's not that much
code but essentially it's waiting for a
countdown latch inside of a static
initializing block now that's a terrible
thing to do anyway waiting inside a
static initializer it's I believe it's a
Java anti-pattern so I mean it's it's
terrible code but the lambda fire at
least one of them which will remain
nameless took that code nameless like a
lambda function took that code and
produced the stuff on the right which
compiles and is semantically correct but
hung at runtime and the question is what
is quite surprising the question is why
right this is everybody got a full fill
of that delicious code can anyone tell
why it's gonna hang oh yeah he's
actually not that easy to see you're not
going to get it we actually park a
bargain JDK and they just haven't
explained us how to use the language you
have been used for 10 years and really
okay look no that's Java gives and gifts
yo yo it ain't even like dough yeah
buddy to have the defense of us it Kevin
Kevin the best of what should remain
animus would like an inner function like
a lambda so anyway let's go to the
answer which was a lot of fun so this
one was caused by the implementation of
lambda so the body of a lambda is
compiled into a private method in the
class and there's a call
factory or some implementation where the
lab is called that that's not really
important so if you can see I put next
to the method there are the guts of the
of the what was executed the name of the
the method that was generated and what
that means is it caused a circular
reference and initialization an
unexpected circular reference without
the lambda there was a new runnable that
was being created and the method the
code was running over in the new
runnable and it was not referring back
to the class itself once the lambda was
defined then there was no more runnable
object that was off somewhere else and
the code was in the ball it was in the
class itself so that caused the circular
reference during initialization ok you
can have this problem without the llama
de or any of these inner classes
absolutely so basically it is that you
are in the process of initializing your
class and then you have someone level of
interaction you call some object that
eventually calls you back a static
matter of this very same class that's
that that's the recursion you came back
for that class and don't try to call him
at in the class that is still in the
process of being initialized and when
you have an inner class oh that's a
different object is a different class
that gets initializing the side and you
can actually let that interchange finish
and call it math on that yeah but they
de l'homme de what it did it brought
those byte codes inside of the same
class so that it close the circle yeah
so I mean it was pretty subtle this
pretty it's pretty subtle but I mean we
did hit it right where are we and
there's also a jdk bug that's already
affects this I actually have no idea why
this bug happens but it's it's fixed
already the result returned three
so now conclusions and we can all get on
our way silence of the Lamb does so we
reduced her we've reduced our jar size
by eight percent so we went to you no 9
mag instead of nine point seven which is
pretty good I mean if you can run 82 and
get all that space back you probably
want to do that you've got failure
attention right here tests but pays off
yeah so you know we reduced our code
size by you have two percent something
like that now that code size I got it
that's everything including comments and
it's just the raw sighs I got it from my
thinking IntelliJ plugin I did I cause I
should have taken lines of code where it
was just executable code and there's a
bunch of other which would be a higher
reduction in code but this includes
comments and everything right so two
percent of your code is just boilerplate
wasted stuff that's obscuring you know
the guts of execution it's it's pretty
good so because there's another reason
as well right for probably one of the
reasons why we did his work at today's
at the time we need was in embedded when
you start the application when it start
fast right and the first thing you got
to do is load your classes if you have
thousands and thousands of in your
classes those are bored a class loader
is doing and you gotta load those class
and verify those classes with the auto
loan they don't do that work and we had
thousands yeah so that's something that
so you reduce the static memory get your
start up together faster in the desktop
don't feel it because your heart is just
so powerful that kind of work doesn't
really matter much but in a pie or in a
bag a bagel bagel board it's your fault
Steve and embedded you can have that
problem it's just internet slang so yeah
so you know there
beagle oh my god it's the BeagleBoard
not the bagel board so take aways that's
what happen to work Steve you followed
any earth better give me a pie and a
Buick a mini bag I tried to get away
anyways so lambdas in their classes are
not the same thing nobody claimed they
were right they are almost
interchangeable right almost the
conversion is ninety-nine percent
automatic so I've shown you some of the
errors that happened especially after we
reported the bugs to the IDE vendors and
they fixed a lot of these errors went
away a lot of the definitely the compile
errors went away and so the conversion
is fast and it's automatic there is no
single lambda either that's the king of
all lambda I zehrs in the world and
notice that there are very few subtle
edge cases and very very few so you
shouldn't to take away from this talk
which I threatened you with at the
beginning of the talk and made you wait
all the way through instead of getting
away but the takeaway is that lambda
fication is worth it and you know
because I've shown you a few things that
went wrong they are the very few things
so I you know I recommend that you
lambda phi your code because of the the
reduction in size and the sum of the
startup improvements that you might get
but also a bigger reason is just for
readability because all that boilerplate
junk that is in there in an inner class
is just distracting you from the actual
code that is executing and doing
something interesting so you know
increased code readability and you've
reduced complexity by just making things
easier to see and understand and that
and here's another lawyer slide and
that's it so
uh does anyone have any questions well
my wife might that's correct the code
base that was lambda i's da sorry the
code base that was lambda i's was javafx
so you thought yeah we the source code
that was lamb oh so we got them in here
on the last day of the conference okay
how many people thought the talk was
going to be something else ok give me a
min i'll go right the other talk you
also mark us well no our thought was our
thought was that this would be a
software engineer appropriately vetted
back door the thought before meeting
starts hey a software and a software
engineering problem that any people with
a large any large project is going to
have exactly the same problem right so
cut the word convert was in there it
would have been case study would have
been good too yeah
well it took I think it took about two
weeks or week and a half or something
and and really it didn't have to take
that long because we could have done to
stop the world do it and that would have
been you know a day or two but we wanted
to we want to run the unit tests after
each change and also we wanted the we
had we have the model of component
ownership we didn't want to just throw a
bunch of code and just force it on on on
people we could have had the component
owners themselves lambda phi their own
code and that would have been the same
sort of thing but i guess they're busy
off fixing bugs and whatnot so but so
yeah don't expect we kind of took it
very slowly any more questions so that
was not the takeaway I wanted so the
Ides if they get it wrong you that
you'll get a compile error most of them
have fixed up the bugs I've shown you
but we did do that right weary beautiful
we refute we got engine yet to go over
every change we always review the code
anyway right just because you know so
they're all oh yeah so the runtime
errors a lot of those are gone because
the IDE vendors have fixed those
problems and the last two that one is
one of them has gone because the JDK is
fixed this bug and the last one is
extremely subtle and you have to have
that it's extremely subtle you have to
have the anti pattern in place and it's
it's it you know it's it will be smooth
for you but anytime you change your code
you've got to run all the tests right so
and and you could shouldn't expect to
take a code base and make a massive
change to it
and not have some strange fallout from
it a config file or I don't know what
right it wasn't the latter it was an it
wasn't to test the ides it was too yeah
his name added yeah the embedded really
or the embedded team requested to work
but also we wanted to be able to read
our code again like I've been doing
since I was reading able to read my code
in small talk I was able to read you
know it was 7 in 17 years I could read
you know 17 years I could fall in love
have a child that child could grow up
and you know right it could go to school
I could teach it about lambdas anyways
ah other questions
we it was a wash like we did nothing got
faster nothing got slower it was a you
know that was a start-up got a little
bit on startup I think the embedded I
don't know if I forgot that on your
desktop yeah performance-wise doesn't
really matter no Indian embedded we
didn't had a change to the task of
didn't have the hardware when we need it
but I was expected the time wasted in
class of loading to be reduced again
it's not like there's not gonna be
anything huge but yeah but but on really
slow devices like a raspberry pi PI has
a great device by the way but it has a
particularly slow processor but it's
like what is it 25 bucks for raspberry
pi it's an awesome device so you you
know we get some speed up there possibly
but if we stream of Phi then we will no
longer compile and run on iOS and
Android which is a Nicholas learning and
Johan Voss now they are talking about
moving to the JDK to jdk 8 libraries and
if they move to jdk 8 libraries we will
go back and stream if I or would
consider doing it it depends really I
haven't really run the benchmarks myself
and I should actually I'm guessing that
if you were doing micro benchmarks this
is a guess if you're doing Marco micro
benchmarks with a for loop and in sand
summing them up and that you know if you
look at the the jitters do an excellent
job on that you know is going to be a
small lump of assembler I'm expecting
that that code would probably run faster
than a stream version but it's such a
it's a micro benchmark I haven't run it
and you know streams are awesome too for
us that's a some salty for others a
little hard question because you re
running different platforms so if you go
to a top platform where you be able to
have a jitter did a nice dream is going
to really going to hurt you you're gonna
have just so many method calls yeah
yeah but I mean you know and again that
kind of thing is a micro benchmark and
it's you know what it's I guess it's
useful for vm vendor or vm vendors etc
but in an application right there was
something else you I can't remember how
well many ways well I'll think of it and
talk to you after okay any last
questions well next year we'll give the
talk that you were expecting that's
what's that going in java fanciful
ominous no don't start okay so here we
go going once going twice sold</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>