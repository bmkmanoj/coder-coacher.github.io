<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Making RESTful Web Services the Easy Way with Node.js | Coder Coacher - Coaching Coders</title><meta content="Making RESTful Web Services the Easy Way with Node.js - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Making RESTful Web Services the Easy Way with Node.js</b></h2><h5 class="post__date">2017-08-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LclQD7I21qY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name is Dan McGann I'm an Oracle
developer advocate I focus on the
JavaScript and html5 communities I have
some contact info here you don't need to
scribble it all down now I'll have cards
and will make these slides available
after the talk here is a look at what
we'll be doing we're going to start with
a very rough intro to API then we'll
talk about manual API creation and then
we'll talk about how we can make it
easier with sales and ords I will admit
I spend the majority of the time of the
talk doing things the manual way the
hard way and the reason for that is I
want you to see that so you understand
some of the magic that's happening when
we get to some of the other frameworks
so imagine you walk into work tomorrow
your boss says hey could you create us a
REST API on our HR data using this new
hip thing nodejs and you say sure boss
and you scuttle off and begin
researching what is this rest thing that
he's talking about so of course this is
representational state transfer it's
really just the architectural style of
the web originally defined by Roy
fielding a while ago and he gets really
upset when people don't do everything
exactly the way he says it should be
done but the truth is most rest systems
don't comply 100% to the spec but we do
take a few things seriously for example
uniform interface when you're working
with an API for employees and then
another one for departments the idea is
that the way in which you go about it
should be consistent stateless we don't
save any state in the server if there is
any state being say that's going to be
in the client-side cashable that makes
sense
clients are these are just good ideas so
most folks will stick to these but not a
hundred percent so the client the
browser in a lot of cases but it could
be any any app really is going to
communicate an intent and it's going to
do that via URL the URIs and these
should be based on nouns not verbs so
for a collection of employees it'll look
like this and if this was an RPC style
API this might have said in the past
something like get all employees
something like that but now it's just
nouns now
verbs and the verbs come from the HTTP
methods and so we have the standard sort
of crud methods that you're going to use
in HTTP there are more methods in HTTP
but again most folks don't bother and
you can see the mapping here so when you
do a post against the employees
collection you're expecting to insert or
create a new employee so once you have a
good understanding of what rest is you
might then turn to no js' so some other
folks already talked about node I'm not
going to spend too much time here but
it's essentially the server-side runtime
for JavaScript based on Google Chrome's
v8 engine known to be highly performant
it's based on this event-driven
non-blocking i/o model and I made this
neat little graphic a couple days ago to
help explain what that means so we
basically have that main thread or often
you know people this is where your
JavaScript runs and so the way that you
do something asynchronous and note is
you use some API call that's essentially
going to be written in C basically all
of this that you're seeing here comes
from a library that no just depends on
called libuv and libuv is what gives no
Jess it's cross-platform evented
architecture works a little bit
different on Windows than it does say on
Linux and Mac and so on now some of the
API calls you make such as a timer like
set timeout if you want to wait a brief
period of time and then do some action
that's going to be a timer others like
Network call-outs TCP gets and such
these are all evented which makes them
highly efficient they don't have to use
the thread pool that's used for normal
background processing or asynchronous
processing a node but maybe you make an
API call
like you know select star from employees
right it's a database call that does
need to use one of the one of the
threads in the thread pool by default
node starts with four threads in that
pool
you can adjust libuv they use up to 128
but keep in mind more
is not necessarily better you have to
pay attention to the number of cores you
have in your CPU and eventually get into
time sharing these other things that we
don't have time to get into but it is
important to know the thread pool does
have a queue in profit so if you're you
know making requests for some resource
in the thread pool and it's not
available they'll just get queued up in
service as soon as I can whether you
come through the evented architecture
the thread pool eventually your callback
function gets added to this event slash
callback queue and it'll get it to turn
to do some processing on the event loop
as soon as possible
cool so once you have a better
understanding of node.js and you're
ready to give it a shot you'll have to
decide what exactly we want to do with
node nodes very flexible we saw earlier
just how many packages are in NPM the
node package manager it's there's a lot
so you have your choice here you can do
a lot of code yourself and this is I
think pretty common in the node world
folks want to design exactly the system
they need to build to spec and so they
start you know heavy configurations can
be a lot of codes can be very flexible
you're going to end up with an API that
has all the functionality you need and
nothing that you don't know bloat
nothing wasting CPU cycles on the other
hand you have convention and has anyone
done any rails development I mean a lot
of folks here do Java so j2ee these are
convention heavy the advantage with
those types of environments is you can
write a lot less code but sometimes you
get less flexibility as a result until
you really learn the tool that you're
using and then of course most tools
allow you to get around some of those
limitations but they are a bit higher
lend lend themselves to higher
productivity in the long term once
you've kind of decided that you're going
to have to make a determination as to
what features you want to support and
don't let this shock you most the time
folks start rather basic and then add
features over time as needed so we're
only going to look at the first two
bullets here today just pagination with
sorting and filtering and also
authentication but you can you can get
into a lot with api's and this really
isn't a complete list
so what are the basic ingredients well
we have here the three tiers obviously
is going to be a client some of you that
want to communicate with your API we're
going to have a middle tier that's going
to be done the node jet and we're going
to a database I use Oracle so the first
thing we need to do is get some kind of
a web server and the web server is going
to be you know basic just taking
requests coming in and sending responses
going out you have a lot of choices for
web servers and node we'll take a look
at those here momentarily then you're
going to need some kind of routing logic
and the routing logic is going to look
at just a little bit of that request
coming in it's going to identify the
intent we talked about the intent before
it's going to look at the URL structure
as well as the HTTP verb and figure out
what it needs to do it's going to route
the incoming request into some kind of
controller logic the controller logic is
going to do a bit more it might be
applying some kind of business logic it
might be pulling data out of the request
in order to do that and it may be
sending that data along to some kind of
database driver which is the last part
the database driver or ORM or whatever
it is you're using that communicates for
the database will then apply perhaps
some more business logic and eventually
update persisted state how should this
be done it's completely up to you so
let's take a look at doing this the
manual way first thing you need to
decide is what web server you want to
use by far the most common web server in
the node.js world is Express and the
reason for that is that it's this really
nice level a lot of people call it
really low level but the truth is the
core module with in node that gives you
this ability the ability to create web
servers and work with the network
interface is the HTTP module it's just a
core module that's included with node
nobody wants to work at that level so
they made one level higher which was
called connect connect was sort of this
nicer place to work you were more
productive and then Express actually
came on top of connect the latest
versions of Express completely
undependable
but it's it's it's high enough to where
you can be really productive but low
enough to where it doesn't get in your
way when you need to do anything you
might need to do
there's Resta fie you might want to take
a look at this if you're creating an API
only basically expressed as a general
purpose web server has functionality
safe for rendering views so they'll have
you know some view logic in there you
may not use it but it's there rest if I
just rips all that out there purely
focused on API creation and if you're
into systems that have dtrace they have
dtrace support built-in they also have
built-in support for throttling and a
few other things
there's cracking jest this is from the
folks at PayPal the folks at PayPal in
Walmart they were really really used in
OGS they have a lot of hard-earned
knowledge and so they're sharing that
with the community community via these
two modules here so Kraken is a layer
over express adding structure and
convention and then happy from Walmart
as an alternative to Express with a lot
more going on including modules one for
validation called joy you have Coors
crosswords and resource sharing we'll
see an example that here a little bit
sessions caching logging etc so we're
going to stick with Express but you when
you choose to create your own API mi1
won't want to explore those when you do
that what about communication with the
database well there is a node database
driver for Oracle database it's pretty
low-level it's built on top of oti so or
commencing client you have to get that
installed but the advantage of that is
even though the driver is only 2 3 years
old now it's it's somewhat advanced in
pretty performance because it's a
thinner layer on top of an existing
proven set of libraries disadvantage
working at this layer is that it
requires more code often times and
sometimes specific knowledge about the
database you're working with the node.js
drivers API is going to be very
different than those maybe you're used
to seeing with Mongo or something along
those lines are ends on the other hand
higher level definitely can be more
productive and they'll attempt to
abstract away the database so for folks
that are more into say mid tier
development than database development
they really like working with ORM
because they don't
about the database but there can be some
downsides to that as we'll see I'm going
to stick with the database driver and
these are the various classes that you
end up using when you use the driver so
the core module is the Oracle database
driver you bring that in and use this to
essentially do two things create pools
or create one-off connections creating a
one-off connection is fine for you know
tasks that run periodically but if
you're creating a webserver an API you
do not want to create one-off
connections from the base class you
instead want to create a pool and
subsequently grab connections from that
pool there's an object called result set
and a lob class as well these are
optional you don't need to use them but
essentially the results set if you're
working with tables with very large sets
of data it's going to provide that read
consistent view of the data as you're
streaming it back out to the client and
the lob does the same thing only for
large objects he lobs B lobs things
about huh all right cool so we know what
web server we're using we know we're
using the database driver but how are we
going to put this project together when
you're starting off and you're doing it
the manual way this is one of those
issues that just kind of freezes you who
dead in your tracks you don't know how
to even step forward so I propose this
it's a very basic directory structure
you'll see it's very similar to some of
the what's created by some of the other
tools including sales as well as loop
back and also rails and probably even
j2ee although I never really did any
Java development so the way this works
is you start with your package JSON and
this is something like a manifest file
it's going to contain the name of your
project brief description of it Pratt's
Persian information but more importantly
it's going to include a manifest of your
projects dependencies and there are two
types of dependencies both for
development as well as when you're
running in production the index Jas is
you can think of that like your main
file and this is my goal is to keep this
file pretty much as small as possible
just to get the project started
I create a generic services directory
and I just stick anything in there that
I want to be reused by other modules
throughout the app the node modules
directory is not one that you need to
worry about NPM the node package manager
will maintain that one for you the
controller's directory obviously just
kind of hold controllers you pretty much
create one file for each controller
employees departments and so on
and I create a DB api's directory most
the time you're going to see a models
directory I personally don't use lrms so
I create DB api's instead but there's
typically a one-to-one mapping between
your controllers and your database api's
although there doesn't have to be you
can reuse database ap as in multiple
controllers and finally we're going to
have a configuration directory when you
get into higher-level frameworks that
favor convince your configuration over
configuration over over code there'll be
a lot more in this than I have in my
example but that's fine for now just
stick as much config as and as you can
in the beginning all right so this is
Oracle code right I hope you guys
haven't seen too much code already
because we're going to get into it now
all right so everything starts with that
package.json and this is what one of
those look like notice our dependencies
right here we only have four Express
being the webserver and I'm also
bringing in a couple others so body
parser is middleware for Express that
knows how to parse incoming bodies so if
you're working with JSON XML that kind
of stuff it can do that for you there's
Morgan Morgan does logging if you've
ever seen an Apache log file
Morgan can basically replicate that for
us which is nice and then of course we
have the database driver notice there's
a main here and it's pointing to index j
s so that's what we'll look at next
alright so in the top of this file and
not on our main we're bringing in two
modules that are in the services
directory one for the database and one
for the web server and I said modules so
I want to go over to one of these we'll
do the web server
I actually know we'll do database just
to show you what a module is and nodejs
so a module is just a file and in this
file we're declaring functions like this
function here this is open connections
and then I'm calling module dot exports
open connections so anything that I put
on module exports is basically going to
be made public to anyone else that then
imports this or includes this requires
this into their files you can come back
to that in a bit but let's continue here
so I mentioned before nodejs when it
starts up libuv puts four processes and
it's or rather four threads and it's
dreadful for for me I like to run a
connection pool often with about ten
connections so I tend to bump this up
some just to be on the safe side I then
log a little bit of information out to
tell me you know how the boot process is
going and the next thing I do I start
using that database module and I'm
invoking the open connections method
what that does it goes into the
configuration file in connections Jas so
this is our config file and that's the
only file in our configuration directory
super basic right module exports it's
exporting an object with a single key
the key is HR which in turn is an object
with three properties and it's grabbing
values from process env process is just
a global and node and it gives you
access to the actual process the running
the currently running process that nodes
using
and one of the properties on it is env
and a and B is just like in a node or
I'm sorry in Linux when you type env and
you see all your environment variables
basically when your node process starts
it brings them all in and exposes them
here on env so I can access environment
variables that way so I'm basically
going into that file and I'm iterating
over each of the keys right now we only
have a single connection per se just to
HR but you might have others to other
users and for each one I'm invoking from
the driver to create pool method and
passing in various pool related
properties one of which is the pool
alias which then the pool get cached in
a little pool cache and then later I can
pull them out via the alias so going
back to our main that's what it's
happening with open connections it's
just starting connection pools once
those are done we then go to the web
server and we call start on that
so this is our web server module HTTP is
that core module that is included with
nodejs for doing HTTP web servers what I
mentioned we're going to use Express and
in this demo here I kind of use a little
bit of both it's because I need some
underlying functionality I mentioned
Morgan for logging body parser but I
also have this other file router
now remember routing is one of the
pieces you need after the web server
right it's going to route incoming
requests to the appropriate controller
logic and our router is really
bare-bones so again I'm bringing in
Express Express has this class on it
called router so I create a new instance
of the router class and then I'm
bringing in our controller for employees
and I'm simply saying router dot route
and I'm passing it a path and this is
slash employees slash colon ID this is
essentially making a variable and the
URL and the question mark at the end
here is making that optional so then I'm
saying alright if the incoming request
is a get request at HTTP verb then I
want you to route that to the employees
controller
more specifically the get method in the
employees controller and I tend to keep
these method names the same they don't
have to be this might be employees dot
create employees dot insert whatever
whatever it is you want to do or that be
get or find so I expose this router
which is then here and what I'm doing
when I start up this web server I get a
port either from an environment variable
or a default and then I invoke Express
to get an app and I loop the app and do
HTTP server again just for some
functionality I needed now the next
thing I'm doing here is I'm calling app
dot use and I'm passing in a call to
Morgan the logging software so what app
dot use is is we're basically attaching
middleware into the app that as incoming
requests come in they go through all
this middleware so middleware is just a
function
nothing really complex it has a certain
signature which you'll see here in a
moment so Morgan is essentially
returning a function the next one body
parser I want basically to have JSON
data already parsed by the time it gets
to my logic so I use body parser for
that and one of the things you can
specify with body parser is a Reviver
function because json doesn't support
some data types for example dates so you
have to revive appropriately if you want
to work with dates so down here a little
bit you'll see my reviver revive dates
it looks to see if the particular values
of string if so does it match this
regular expression and if so then we
parse it to a date and JavaScript so the
next thing I'm looping in here is Coors
cross-origin resource sharing and the
reason I do this is because I'm often
running my applications from a different
domain or port than I am doing my api's
and if those two don't match you know
browser securities these days is kind of
tight it's going to prevent it so Coors
is actually really simple to enable and
you're seeing an example here right in
use I'm passing a function reference so
that's a function definition down here
and this is the signature that your
middleware and node or rather in Express
expect so you have requests and this is
the incoming HTTP request we have a
response this is what you're going to
use to generate the response you then
send to the request of the end user and
there's next and you invoke next when
you want the request to go to the next
handler and the chain so generally with
these kinds of api's once you want to
get to your logic you don't invoke next
you're going to handle it completely and
that requests question
Chane so going back up to the top we're
saying app dot use Morgan so when the
request first comes in Morgan is going
to get the first shot at that request
internally Morgan must invoke next for
that Bend to go to the body parsing
middleware the body parsing middleware
must invoke next for that then to go to
the cores middleware the cores
middleware but you'll see it does right
here must invoke that next handler so
that the next thing can handle it does
that make sense and remember I brought
in and we've already seen the logic for
the router here is where I'm bringing in
that router so I'm bringing in the
router and I'm not just calling you
directly but rather I'm attaching router
this is called mounting a mounting
router at slash API so all of my urls
are going to start with slash api if I
wanted to I could do versioning here I
can do all kinds of things but we're
keeping it simple in this example and
finally the last thing you want to mount
in is your error handler and the error
handler is the only one that deviates
from that standard signature because it
starts with the actual error and this is
a good way for you to prevent certain
error messages like at the database
layer from bubbling out all the way to
the client you want to return a generic
error to them and maybe do some internal
logging you want to see what really went
wrong that kind of thing so my error
handler just returns this I actually log
it out in the console so we can see it
but I returned to them something more
generic I won't get into all this
basically I'll summarize so in node if
you want to kill your web server you're
going to send like a SIGINT or something
like that you want to shut down but if
it's open HTTP connections it doesn't
necessarily work so I'm tracking all
open HTTP connections so that I can
sever them and boot down appropriately
later so that's our webserver going back
now to the end XJS we're still like
starting our application so we've opened
our database pools we've started our web
server and that's really it if we
succeed in that our our API is up and
run
the rest of this like we have some event
handlers here for SIGINT
sig term as well as an uncaught
exception which can happen in in
JavaScript all of these just call this
shutdown method down here and this just
does the reverse of the startup right so
we're calling web server dot stop no
more incoming HTTP connections once
that's done we can then go to the
database and shut down the pools and
once that's done we exit the node
process so the next thing I want to take
a look at is our employees controller
logic we've seen the router the router
is going to route an incoming request on
slash API slash employees to this
controller and depending on the HTTP
method one of these functions will get
invoked so here we have get and get just
follows that same pattern it's actually
pretty simple only once we get to this
level we almost never invoke next and
lesson error occurs so what are we doing
well if a get request comes in what we
want to do is look at the request and
identify more specifically the intent
and so data comes in and requests
generally for up to four ways and the
URL you have the path right so we saw I
was defining a variable or a parameter
in the path before on the other side of
the URL you have a question mark and
then a query string on the right hand
side that's another common way to pass
in data usually with a get request data
can also come in via the body of the
request and finally there's HTTP headers
those are the four most common ways that
is going to come in so what we do we
take what we need in this case we go to
the params and we look for that ID
property and we just parse that into an
energy and adder and assign it to
context and then employees dot find this
call employees here is in database API
so now we're getting into the database
call which is the last thing we need to
look at
so this is what it looks like for me
I've just identified a connection named
HR so I'm going to use that pool I have
a basic find query here where I'm
selecting the columns I want to query I
can do joins I can really do anything
that I want at this point is I'm using a
driver
note that I am using double quotes for
aliases to enforce case sensitivity this
is your way when you're generating or
creating your API when you think about
that JSON you're sending out if you want
it to be uppercase lowercase the way to
enforce that really easily on your
queries is just with double quotes you
can use camel case whatever you like I
find one query is really simple I take
the find query and I attach a where
clause and just match by employee ID so
going back to our controller the get
handler and the controller is calling
employee dot find which is defined here
passes that context and then this knows
okay if there's an ID coming in the
query I'm going to use is to find one
query otherwise I use the find query and
then I use database now this is not the
driver I'm bringing in this database
module and the reason is that the driver
when working with connection pools is a
little bit tedious in that it expects
you to get a pool from or get a
connection from the pool use it and then
finally release it and while that may
not seem like a big deal it can add up
you know it's a little bit of overhead
that if you can centralize that in one
place for the majority of your calls all
you're going to do is a single execute
no transactions or anything necessary so
why spend the time so that's what this
does this is just a simple execute
method that makes things a little bit
easier
enables auto commit and sets your out
format by default the driver is going to
return to you data in an array of arrays
with no headings or anything that's very
lightweight it's it's lean and fast but
most folks prefer the object so they
don't have to inflate it on their side
and then it go to the pool it gets the
pool by name gets a connection from that
pool and then calls executes with the
statement you passed in it does all the
error handling
and finally closes that connection when
it's done and returns the result so
that's it for that one and that's pretty
much it so it's just using the simple
execute method to execute the query it
takes the result then and returns that
via this resolve this is going to return
that to the controller so the controller
it's going to get its response after it
calls find it essentially gets the rows
here and then again it needs to
determine or you know depend on how you
want to build your API is it may need to
determine if the user wanted a single
object or an array a collection or
single resource so if they wanted a
single resource then we'll just take the
object and send it out as an object
otherwise they get the array of rows
instead so the post logic I won't walk
through it all the post logic just does
your inserts but things get a bit more
complex because what we're doing is not
just going to the request parameters but
we're using those other methods and ways
to get it data coming in from a request
so here we have request stop body now
remember we're using that body parsing
middleware right so by the time the
request gets to us body parser has
already parsed it turned it into an
object we have actual dates instead of
strings and we can then work with it
from here and we just call the database
method employees dot create so a nice
separation of concerns it is a bit you
could call this verbose but we have a
lot of control here and there's nothing
getting in our way anything we want to
do we can pretty much do let's see if it
starts
so we'll open this directory and I'll
call node period which tells it to go
and find the main it locates the main we
see the console logs coming out starting
the application it's started our
connection pools in the webserver so now
we have a webserver listening on port
3000 I use a tool called Pau for most of
my testing api's a lot of folks use
postman which is open source and free
some folks prefer curl one of the
reasons I love Pau is that it actually
can generate jQuery code for you or curl
it does a lot of those for you but Paul
is great it makes this kind of thing
really easily so what I'm going to do is
I'm going to issue a get request on
localhost port 3000 slash API slash
employees and when we fire that off we
get our 200 success and I can collapse
this and we see that we got a hundred
items back we can open it up and here's
our first element it has 11 properties
we have ID we have name first name last
name email and so on what about a single
employee well I'm just going to issue
remember that's an our path and our
router that's just a variable so I'll
just add a slash 101
issue that again this time we get a
single employee so that's working just
fine and we get the object not the array
you can actually see the raw response
and just see that this is in fact an
object as opposed to the array that came
back and this response
in the interest of time I will skip
these others but yes you can create
update and delete employees as well so
you go to your boss start up the API you
show it to them and and they're happy
but then you realize you forgot to
secure it and now you've opened up your
company's information to the to the
world and so they say can you secure it
you say sure no problem
so in this next part there actually is a
little setup and I'm just creating a
users table when it comes to how you do
authentication and authorization that's
how completely up to you because we're
at this lower layer but you know any
module on NPM you can use and so I'm
just doing a quick demo here that uses a
local users table in the database of
course we're going to have a password
field and we need to make sure that
we're hashing salting passwords to store
here so we'll create that
and what I needed to do to add basically
I just copied the files and and started
to build on top of the previous example
so the solution here what I did I added
a new service and I called this security
and actually let me show you the the
manifest.json for the package.json first
because I've added two different modules
so one is bcrypt
and bcrypt does hashing it does all
kinds of encryption but I'm just using
it for hashing and I included something
else called JSON web token this is
abbreviated oftentimes to jot but the
idea is that in the past often times the
way sessions worked you establish the
session with the user you put the
session identifier and some kind of a
cookie and then the cookies transferred
back and forth that worked well for
browsers but it failed with you know
other mobile clients that weren't using
cookies and so JSON web tokens is a sort
of more modern way to do that and it can
remember that one of the goals with
api's is to be stateless and cookies
they are a kind of a form of state JSON
web tokens gets around out the way that
they work you're essentially taking a
let's say a JSON object
that includes some specific data such as
maybe the user name maybe their
authorization are they an admin are they
not and you're encrypting that using a
secret key that you're going to store on
your side and then you send that
encrypted key or encrypted JSON object
down to the client and the expectation
from that point forward is that any
requests as long as the routes are
authenticated if they want to use them
they have to send that jot and so you
then unencrypted it and you see who they
are you know what their prayers are and
all that kind of stuff makes sense so
those are the two new modules and you'll
see them being used in the security
module again just a generic module to do
some security related functionality for
us the purses hash password so here you
see I'm using decrypt to generate a salt
and once I have the salt
then use the salt to hash the password
and then send that password on out
there's a validate password here B crypt
had a built in compare so I just mapped
that right through to validate password
and I can call that elsewhere there's a
get session token so this is when the
user a request is coming in and we need
to inspect the jot this will this will
do I'm sorry this will generate the jot
so here you can see the job sign and
then it sends that out and finally
authenticate authenticate is Express
middleware so remember we've seen
middleware we know that the signature
that middleware uses this particular
function takes in request response and
next it actually returns a function
that's how we do this that's then used
to verify specific route handlers as
you'll see in a moment so let me show
you the route now what's going on in the
router so we have this existing route
for employees and what I've done is I've
put a call to our middleware security
authenticate before this handler which
we saw before this is the normal
controller and so what that function
does is it make sure that the user is at
least authenticated and if they are then
we invoke that next method so they can
get to the controller otherwise we just
send a response you're not authorized
and we designed them access to the route
this one is a little bit different and
then I'm passing in some kind of
authorization name very flexible you can
do it however you want but in other
words for DML I want them to at least be
an admin but if they want read access
they at least need to be authenticated
that's the idea here and the way that
this works I added two new routes one
for users and one for sessions when a
user account is created we're going to
do an insert into the users table we're
going to hash that password and we're
going to return the job then and then
you know a job can last as long as you
want it to if it expires in 24 hours the
user needs a means of real and
you're getting a new session so if they
do a post on sessions passing leading
them and passwords will return a jot
directly
so I'll shut down the previously running
instance
we'll start up this one
and to test this
I'll show you now we do a refresh on our
previous route localhost 3000 API
employees and what are we getting back
401 unauthorized we can go to any of
these routes and that's just what you're
going to get so what we do is create a
new employee I'm passing in damn again
you can see that and the raw request
here in a second but notice the password
do not know how that's going to work ah
okay so here I have number one
so here's where we create the user and
I'm just sending in an email and a
password and the password here is abc123
I'll refresh that so our users created
and if we now look at that users table
you can see that password has been
properly hashed bcrypt makes that really
really easy and no so now what we can do
we look at the response notice is sent
back this token here I grab this and I
can return to one of the URLs that was
previously not working and I just had a
header for authorization paste in that
value and now when we refresh it's
working
so that logic is unencrypted a jot going
through it and it passed authorization
who five minutes all right let's see if
we can speed this up a little awesome
your boss says but I can't pay gen8 the
data this is actually how it works when
you choose the manual approach you go
through the sequence one after the next
adding functionality as it's requested
and that's how you end up with an API
that does exactly what you want and
nothing that you don't what I'm not
going to do is show you how to add
pagination basically we add a few more
parameters to the routes such as limit
and offset and sort and that then gets
mapped eventually down to the database
layer so we can manipulate the query and
then applied that query correctly I'll
of course make all this code available
so if you want to step through that
particular one you can do so on your own
so the manual api's are a lot of code
but super flexible let's take a look at
how this works with sales so there's the
different terminology that goes around
some people say MVC framework when
they're talking about sales
other people say API framework when
they're talking about loopback the
distinction is just because sales tries
to be a bit more generic and then
loopback just tries to focus on on api's
but they're both really really great and
actually very similar there's definitely
some overlap but I'm going to show you
sales here's how you install it you just
do an NPM install sales make it global
then you can generate a new project with
sales new project
so I'll come back out to demos and we're
just going to open this and I'll say
sales new my project now it gives you an
explanation but basically this takes a
little bit longer than it should because
of the fact that NPM changed a few
things and they're going to try to fix
that soon but as a stand just takes a
little bit longer than it should and
once that's up and running we see the
end to my project and we can then call
sales lifts to start the app and we can
add database support for Oracle via this
command here so that's installed
we'll CD into my project and then I'll
do skipping a little bit we're going to
say sales generate API employees so it
created a new API and if I go into my
project what do you see
pretty much everything that was there
before that I created manually sales
kind of starts off with that the most
important directories being config and
API if you look in API you see
directories for controllers models
policies for security and so on and side
of controllers I just created this when
I said sales generate new and then new
API controllers are employee so it's
empty right now and the weird thing
about this to start a sales app you you
invoke sales lyft and it's going to
prompt me it's asking me if I want to
migrate via safe alter or drop I'm going
to stick with the safe option one
basically when you get them to these ORM
frameworks they want to create all your
database stuff for you they want to
abstract that away so now our sales
server is running we knew
and one of the nice things is that I can
issue a get request and we get nothing
back I can then do a post it succeeds I
can go back I can query it and we're
actually seeing our value the question
is where in the world is this going note
that I have not yet installed the
support for Oracle basically the way
this is working is it's called
blueprints and it's one of my favorite
features about sales it's all about
rapid prototyping of api's and so the
idea is that you can essentially just do
your sales generate API whatever you
want to call your model and controller
it'll generate the URL and then you can
just straightaway start using it it's
essentially writing to disk the values
that come in and you can do crud
operations without a bit abuse back-end
and then fill that in later I don't have
time to show you anything else in that
the manual creation took too long so
just be careful when you're using these
are M s they're nice especially if
you're not too comfortable working with
databases but some work in strange ways
for example some I found enforce case
sensitivity and if you're not careful
what that means is when folks go to use
it after the fact they have to be very
careful so instead of just select column
from table you have to say select double
quote column from double quote table and
that can get to be really tedious some
do not use buying variables and this is
really bad in Oracle if you're
especially in an OLTP environment you're
getting a lot of requests if you're not
using bind variables you're essentially
forcing more people to do more hard
parses than it should be definitely not
a good idea and then some don't even
support transactions so choose wisely
another tool you can look at is ords
Oracle rest data services one of my
favorite features about ords is that it
allows you to auto rest enable tables
you can basically go into a schema right
click enable enable rest for the schema
and this is in sequel developer then go
into your table right click and say
enable rest for that table and you get
crud out of the box but really robust
crud a lot of great functionality in
there including
ability to page n8 filter both sales I
should say and Ord and loopback I'll
provide the ability to paginate filter
sort all that kind of stuff right out of
box they all have different syntaxes so
you have to see which one you like the
best but they're all pretty good alright
so in summary there is no perfect
solution for creating REST API swith
node the manual approach definitely
gives you the most control but it can be
a pain RMS are great abstractions more
productivity but make sure they're using
the database correctly API frameworks
bundle it all together to give you an
all-in-one solution but that only makes
sense if you agree with all the
convention that they're offering you
thank you all very much enjoy the happy
hour</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>