<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scala in Action | Coder Coacher - Coaching Coders</title><meta content="Scala in Action - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scala in Action</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xCmHKzYXoko" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everybody I'm so glad you
made it to that very early session
I'm haiku I'm looking for typesafe we
are the creators of the Scala
programming language and the akka
toolkit and runtime for scalable systems
the Play web Pembroke and some other
components related to Scala I have been
a Java developer for many many years and
a couple of years back I think in 2008 I
came to know skal and ever since then
I'm enthusiastic about that language and
today I'd like to show you Scala Scott
action and hopefully spread a little bit
of that enthusiasm word of caution I'm
going to show a live code real code so
if you don't like that it's your last
chance to get out of here of course I
hope you will stay before we get started
let me ask you a question or two who of
you has already used a little bit of
skull-like hello world
okay and that's one word who is using it
at work or in production three four five
six okay I think that's a perfect fit
because this is intended as an
introductory level talk I have a couple
slides but most of it will be live
coding
okay so what is Scala big surprise
it's jvm language so there's a Scala
compiler which takes the source code and
creates bytecode and the JVM has no
notion whether this was Java for a movie
or Scala okay it's really a very mature
language it has been there for about ten
years the first experimental release was
in 2003 the roots go back into the last
millennium into the late 90s when Marta
Dorsky the creative Scala added
interesting stuff to Java so he was the
original author of the Java C compiler
which is still used today so he are the
generics dropped in generics which were
added two down five were based on his
work and he had some more ideas which
didn't make it into Java so he decided
to move on and create Scala the first
production already released was in 2006
Scala - written in scala eating our own
dog food and we have seen a couple of
releases since then today we are at
scale to 10 to 11 will be shipped in a
couple of months and meanwhile we have a
very strong focus on backwards
compatibility that wasn't always the
case when it was an experiment
experiment language of course not
and since Scala - 9 we have a pretty
good backwards compatibility
compatibility story but we are still
scholars still very innovative so
there's always a couple of interesting
features which are on the radar and
sometimes make it into the language
to describe Scala this term unifier
might be the best because skull language
brings together a lot of different
paradigms from different worlds like for
example Scala is an object-oriented
language like Java so we have classes
and all that stuff but on the other hand
skull supports functional programming
you know guys but functional programming
is who's using who knows some functional
programming languages which ones
yeah list scheme mal wow these are hot
cool ones well just great so yeah there
are a couple out there and the main
thing is that in those languages you
have function as first-class citizens
and we'll take a close look later
interestingly generate will also have
well not me first classes about these
lambdas one hour one other interesting
aspect is that skull is statically type
like Java you can write a program and
assign an int value to string variable
so in most cases this is at least what I
think is good but at the same time Scala
code is really lightweight so it almost
feels like the code is written in a
dynamically language and this is because
we have some features like type
inference so the compiler is in those
cases able to figure out the type on the
right hand side of an assignment or the
return type of method so you don't have
to repeat that on the left-hand side of
an assignment you Kinnaman semicolons
and there are some other nice features
which make the language really look very
lightweight
this is maybe the most important skull
is really fully interoperable with Java
so you can use any of your favorite Java
libraries spring hive and a local day
you can use the code you have written in
Java you can even have mixed projects
can add source Scala class maybe for
testing to your Java project and then go
on and on so there's a easy or smooth
integration path you don't have to do
this bigbang change if you want to go
for Scala you can add it to existing
Java projects all right so no more
slides I'll show you a couple of things
about Scala veal ah live coding if you
have questions please raise your hand
and we can answer that immediately so
the more you ask think the more fun we
have I'm using Eclipse for for that
purpose there are decent plug-ins for
IES like IntelliJ Emacs VI whatever you
prefer so
so the question was how does the
IntelliJ plug-in compare to the Eclipse
plug-in meanwhile both are pretty mature
and good the Eclipse plug-in does the
very essentials better so the compiler
is perfect because it's the real Scala
compiler in IntelliJ they more or less
have to rebuild their type checker but
on the other hand until j has awesome
features I mean all these refactorings
and implement method and whatsoever I
mean from that perspective IntelliJ
gives you a better experience so you
have to go back and forth and see what's
better for you so I'll be using eclipse
today because we have a thing which is
called work sheet but there was another
question sorry oh how would I write a
NetBeans as a Scala IDE I'm not sure
because I'm not using it but a couple of
years ago it was pretty good though it
was only developed so the plugin was
only developed by a single person it was
really good but I have no experience in
the last two years for that okay so
here's a cool feature it's called a work
sheet it's like a repla read eval print
loop in an IDE so you can enter
expressions it's safe they will not only
be compiled but evaluated here on the
right-hand side you see an artificial
variable name for the value of that
expression here you can see the type and
result okay so that's pretty handy you
can go for experiment rhythmic develop
in that way so the first thing I'd like
to show you is how concise you can how
concise object already code you can
write in a scholar so this is not
scholar this is Java and therefore it's
called Java time it's just a bean with
hours and minutes these are parameters
of the constructor and also fields we'd
only feel so this is an immutable object
so say this as minutes field is
initialized based on hours in
then we have getters for all three okay
there's a minus method which takes
another time and returns the difference
in minutes and then we have equals and
hashcode and be sure you know these guys
they're pretty important if you want to
store objects in let's say a met or
settle or whatever okay so well it's
just time with our minutes and yet 70
lines of code so let's see what we can
do with Scala so I create a new Scala
class called time and interestingly this
is already a valid Scala class it's
pretty useless but I could already
create time instants okay and what you
can see here is the result of the two
string method so make sure you know that
so obviously every scholar class is a
Java class and yes it has to be like
that because it's on the JM so at the
end of the day we inherit from java.lang
object let's add a little bit more
meaning to that class we need hours and
minutes and in Scala we have class
parameters let me show you what I mean
we can add hours and minutes to the
class definition so the result of that
is that I can no longer create a time
like this because the compiler takes
this class definition
maybe I move that down here and you can
see time okay because it takes this
class definition and creates a so-called
primary constructor which means now we
only have a constructor which has tool
which needs two arguments four hours of
minutes
it's 8:40 now so we should be able to
create class sorry an instance like this
so we are not yet there because we need
to expose hours and minutes as
properties or read-only fields or
methods or whatever
and we can access those let me assign
this time to a meaningful variable name
in Scala read-only variables are defined
with a valid keyword like the private in
Java so we can try to access ours but
that don't want work the compiler won't
let us do that in order to make these
parameters fields we just add the value
but here and after that it just works as
you can see here so what's happening now
is that the compiler creates not only a
constructor like this with with two
parameters
but also to private final fields and
construct a code to initialize those
fields all that we have to do on our own
in Java and it's pretty convenient to do
it like that so this is like a read-only
scala bean so what's missing is a real
field which is not promoted from a
parameter and that's this as minutes and
we can sign hours times 60 plus minutes
- all right and as you can see here I'm
using type inference I don't have to
specify the type of as minutes the
compiler is able to figure it out you
probably can read it but if you hover
your mouse you will see or I will tell
you that the compiler knows that this is
an end ok so you could give the type if
you want to and you could try to give a
wrong type and then the compiler will
complain so it's data clearly typed
even though you there is type inference
yes please
yes those are not IDE features this is
built into language all right so we have
our as minutes field now the next thing
if I remember correctly was the minus
method we need a minus method so in
scala we have to use the DEF keyword for
the methods call it - take another time
call it that and well I'll give you the
fully-fledged signature now we return an
int but again we could have used type
and friends we can use curly braces and
we have to return the value this dot as
minutes - that dot as minutes this is
how it is implemented here in Java time
right let me see yeah so it's just more
or less the same code except for the
fact that there's no return keyword and
that's because in Scala everything
almost everything is an expression which
means has a result or has a value a code
block is an expression it has a value
and this is a code block okay so the
value of that code walk is the return
value of the definition of the method
there's no return keyword and as this is
a one-liner we can even get rid of that
we only need the curly braces if there
are more than one lines okay let's give
that a try
we have time let's add the second one
time - it's 846 now so well no sorry
time to dot - time one and here we go
it's not called time one that's my fault
okay
so you can see it's six LGB you can omit
the dots in the parenthesis in method
invocations so you we can rewrite this
line we don't have to it's a matter of
style in this case or taste we can
rewrite this line in so-called infix
operator notation so the minus method is
now used as an operator in between the
target of the invocation in the argument
okay why do we need that feature
certainly not because of that we need it
because in Scala every operator so there
are no operators but every operator is
just a method with with a funny name
okay so let's define our own operator so
to say let's define the minus operator
method again taking a time and returning
an INT and just delegate to that other -
method okay and now we can just do this
and now it hopefully becomes obvious why
we need that in fix of Rio tation
because that would really look super
ugly and nobody would want to write it
like that so that's the purpose of why
we have it and we can use it for normal
methods but we don't have to all right
so we already have no not all the
features of Java time we have most of
the features of Java time we have even
added our own symbolic method our own
operator so to say we don't have the
equals and hashcode and now here is a
very cool thing we can add a single case
sorry - okay question please
could you please repeat the question
so um in the implements or item this
here like that here okay this - this
this - here is the - method which is
defined on int o here
okay does it make sense now those int
values are just added right it's it's up
to you how to define it that would be a
very interesting implementation but
anyway so the if you look again so this
- method or operator it's the same in
Scala II these operators are not global
they are just methods which already
final classes so the class here is int
the class here is time these are
different
- implementations or definitions yes
sorry oh yeah that's a very good point
so this is a class you're right in Scala
is a simple language there are only
classes everything is an object but this
is not integer the Scala compiler takes
this and compiled it to the primitive to
the lower case int okay so for us it's
easier it's objects classes objects all
the way but not down down its primitives
okay
it's pretty convenient so ok back to ok
sorry last question
it's not the mines is not a class it's
only AM is a method yes it's always the
same if you are in a completely
object-oriented language you have up
tech dot method so the dot dereference
yeah yeah so - there's no global -
there's no global star bang hash
operator it's always a method which is
defined on a class so you can only
invoke it on a class the assignment
operator is the only exception right so
we have seen the assignment operator
that's for defining or initial defining
method implementations or initializing
that I'll use that's all very nice
question
no that works very nice because the
integration is based on by khun the
skull compiler takes this int and
composite to an int with a lowercase I
so that's fine and if I get a lowercase
in from the in primitive from Java
that's perfectly fine can you get the
class here then you get to java.lang
integer that's not a problem we're using
the java.lang string so we can use all
these L so if your Java if he I gives
you a boxed integer you will use the Box
integer it will not automatically unbox
that then it will just use what you
decide your API to return no no not at
all okay so we still have to do this
equals and hashcode so there's a neat
keyword called case but you can prefix a
class and call it a case class so this
gives you a couple of features and one
of the most important is that now you
have very nice implementations of to
string equals and hashcode so this is
the result of the two string as you can
see here
well it's no longer this weird address
pointer it's the name of the class and
the two string implementations of each
parameter it's a pretty good default huh
so we even get an e-code and a hash code
now you can you can take a look we can
do time 1 equals time 2 and this will be
false now if we change that it will be
true as you can see here that's cool
isn't it by the way that's not the Java
equals equals operator there are no
operators in Scala this is a method and
it's implemented in a way that it just
delegates to the equals method so this
is the way how to compare two objects
for equality
okay you could also call the equals
method like this or not using infix
operator notation anyway yeah so no more
errors by using that operator so case
class gives us good implementations for
two string equals and hashcode based on
all the parameters of the class that's
what you want to have in most cases of
course you can override that if it
doesn't fit by the way if you add the
case you can get rid of the valve
because a case class is meant as a value
object so it will promote those
parameters to fields automatically so
all the parameters become visible fields
and you can even get rid of a new
keyword because you have a factory
method that's not really important and a
couple of other nice things so whenever
you want to create like an entity data
transfer optic value object the case
keyword might be a good choice when we
don't use the case keyword oh I mean I
mean in this case if it's a case class I
wouldn't use it I mean you can't use it
but you only have to use the new keyword
if it's not a case class and there are
good reasons for classes to not be a
case class if you have like a service
object where you usually just have one
spring configured service bean or
certain type service objects are usually
not compare to each other not storing
Maps hash sets arrays so there's no need
to have all this hash code equals and so
on as well
and for those who would have to each new
so this is just here like a neat trick
because the compiler does a couple of
things and it creates this factory
method I want to dive any deeper but
that means you can't create a time like
this so we're almost done I just want to
show you one more thing so you can
override the two string method if you
want to I mean this is already pretty
good right the two string here 8:40 what
we can do better if we want to print 0 8
: 5 6 for the time right
like like here then um we need to use a
nice string format and it's got we have
something called string interpolation so
we can use strings and prefix them with
an F or with an S and then we can insert
variables like for example hours :
minutes and we are almost done if you
look at it here now it's 843 awesomer
and we can even use format strings so
that would work with s and with F you
even can use formats now I don't know
exactly if I get it right I think that's
the format you have to use that's normal
Java text format by the way that's
nothing Scala specific we this support
is from the Java libraries ok now you
get 0 8 40 so what's pretty awesome here
is this string formatting which makes
the string concatenation or string
building more digestible and easier yeah
now so for for you or for the developers
there's only classes it looks like but
it's not sorry it's not boxed because
the compiler takes these special so
there's in the type hierarchy the
top-level
class is called any and underneath we
have any well in any ref any ref means
java.lang object and eval means int long
float double boolean and or two more the
compiler takes these capital int and
capital double and so on and translates
them to the primitive data types of the
JVM
if you call what if you go yeah no
there's no boxing at all it there's no
boxing at all I mean I could show you
the bytecode but that's probably maybe
if you do that later but it's really if
you look at the bytecode there's just
int with a small I okay
there's no boxing at all you're welcome
okay so basically that's it we have
created a case class time which
represents hours a minute and so on
in some ten twelve thirteen lines of
code and got a lot more than we got from
Java oh I forgot one thing
we can even add defaults that's pretty
neat so you can assign a default value
to any parameter not only yeah so and if
we have that we can create times like
this time five this will be time 500 now
tell me if we want to omit the R because
we haven't default here and just provide
some minutes that say 30 how can we do
that what do you think comma yeah but
that would be super ugly if we had like
five parameters then we would end up
with oh my god was that no no
def it would have been a possible choice
but we need something better name yeah
cool thanks
so some dotnet freaks here we Internet
they are in in in in c-sharp they
already had that for quite a while so
yeah we can use the parameter names to
give a very foreign argument we can
always do that we can we can do time
here if you want so you can reorder on
call side note I'm sorry hours okay this
sometimes if you have a larger parameter
list with the same type like intended
use you really know okay this fourth int
was it for this so for that so giving
the
argument names makes your code more
readable in those cases even though it's
a little more verbose it increases
readability okay cool so we have that
class ten lines twelve ends of code more
features so I think that's a pretty nice
demo of the power of the concise of the
Scala yep ah very good question so are
there any access modifiers and Scala yes
there are if if you don't use any
keyword so there's no public keyword it
is public if you want to make it private
just add private or the yeah the default
public yeah so the access modifiers are
almost the same like in Java you can add
qualifiers so it's more powerful but
that's just the details so yeah it's
almost the same yes
it's completely transparent you don't
know so you could do here well daytime
equals new Java time 10 30 40 whatever
and now it's here okay and then J time
get ours it's just it just works and we
are using a couple of of standard class
like java.lang string there's no string
implementation in Scala that does make
sense the strings very good
implementation with a lot of DM
integration we do have our own
collections which are by default
immutable and have all these nice
features I'll show you a couple in a in
a few minutes but in many cases we just
use existing Java stuff sorry
yep
that's a very good point what happens if
you are using Scala code from Java and
the javis sorry the Scala code is using
features which are not available in Java
well that doesn't work properly so if
you want to design a an API in Scala
which can be consumed from Java you've
got to be a little bit careful to only
expose those features which are
digestible from Java underneath this API
you can use all the power of Scala all
the additional features but at the API
level you've got to take care of you
must be careful okay so that's concise
oo let me show you a little bit about
functional programming okay two
questions no there's no missing method
implementation group because it's
completely statically typed
yeah more lines in a method I mean yeah
I can do that so it shouldn't be too
hard so you can println fool and then
you can return eggs
I don't know so now one would be
returned to all is the last line the
last expression is the value or return
value of a method or a block okay so
that's o let's talk about functional
programming in Scala by example of
collections and we'll probably soon have
Java 8 which is awesome because there
will be a lot of similar features in
Java 8 regarding the collections and
functional collections stream API and
stuff so going to move that up again and
get rid of that ok
yeah that's a good point I mean you
could use that like you can use any
scholar feature no problem but I'm sure
as soon as you see the scholar
collections you even don't want to use
the Java 8 collections yeah it's a nice
try I should I should I should be
careful here no honestly I think it's a
huge step forward I really like Java
becoming functional that way but of
course it's a little different story
scale collections have been designed
from the very beginning to be functional
tall collections now so this stream API
is the best they can get ok I mean
that's a little advanced maybe we talk
about that later in detail but you can
do the same lazy evaluation of
collections in Scala if you want to so
you can make any collection stream and
then it will be lazy evaluated and we
explicitly have parallel collections in
Scala you can turn any collection to a
parallel collection if you want to do
that and then you have still most of the
methods available and they will be
executing parallel so if you want to see
more details let's talk about it offline
or at the Scala SRE typesafe party later
so let's start with simple collections
now ok last question that I would like
to start with that for running off time
yes indeed
okay what we have while loops
I have haven't shown you that so we have
we also have mutable variables so you
only have seen valves which are
immutable so we do have these constructs
and you can use them if you want to if
is always an expression always returns a
value so there's no if in the sense like
you know it if you have well x equals if
through one LS - so your X so this will
return a value it's like the ternary
operator in Java
okay but your question was probably
targeted taught something else maybe I
didn't fully get it
Oh a while loop doesn't have a return
value on that sends its unit void yeah
yeah so there are these things which
don't really return something which
return void so to say that exists in
Scala - it's a not evil or anything it's
just not that idiomatic
if you do this functional approach you
usually want to have an expression which
returns a value okay there are some
benefits but that's not always our it's
not necessary and while loops are are
fine so I have a demo later I maybe can
show the code very quickly at the very
end where a while loop is used all right
let's dive into collections so in in in
Scala in order to create a collection
you just name it and add some values to
it like the list one two three so again
type inference so this numbers value or
variable is a list of one two three the
compiler can figure out that it has
possibly that list event you don't have
to specify it here and this list has the
normal or expected
members like size three what else
other cool methods like head which takes
the very first element of the list and
tail which takes the last element if you
need more flexibility let's add some
more elements here you can take the
first let's say three or drop the first
two so these are pretty powerful methods
and again I'm using in fix operator
notation so if you prefer you can write
that you only should use in fix operator
notation if the method names use those
symbolic operators like + and banging -
n't whatsoever okay but that's not yet
functional that's just normal methods
like expected let's assume we want to
take this numbers collection this list
and just add one to each element and we
don't want to use a loop what could we
do any Java eight guys here so we go the
functional way and we call a so-called
high order function which takes a lambda
which takes a function and this function
then says add one to an element okay
let's just give a try
that's how to do it so we get a new list
two three four five and this map method
which is defined on lists and on every
collection type is like a transformer it
transforms the original list into a new
one by applying this method here sorry
this function here to every element so
what we get is a very declarative way of
expressing what we want to do add one to
each element instead of describing or
implementing how to do it this could be
implemented using recursion or iteration
it's hidden by the implementation of map
method we don't have to really care
so the question was we are using a valve
for numbers and doesn't that mean if the
list is immutable well there are two
different things the valve means that
this variable is immutable so like a
private variable in Java so you can not
assign a new object to this valve so you
can't do numbers equals empty lists or
list with only one element so the
completely will let you do that but this
would be another object so that's the
meaning of valve you can reassign a new
object to this variable numbers itself
so sorry the list itself is an immutable
object so if you append prepend drop
take whatever you will get a new
instance a new list but this does not
involve copying in most cases it can be
even more efficient than working with
the original data structure and mutating
it in place it depends on our what
exactly you're doing and how your data
structure is implemented there are
detailed performance characteristics and
yeah so for example a list gives you
very good performance
if you want to prepend an element that's
the way it is implement it as a linked
list it's a nothing special in Scala you
have the same enlist we have the same in
Java linked list so it's very efficient
if you pre pass something if you up him
something it's horrible
so you get to know what you do is on if
you don't know that are you you can use
the vector that's the Scala vector by
the way that's a really awesome data
structure it's not the Java vector so
that gives you extremely good performs
characteristics for almost every
operation
you
sorry could you please speak up yes of
course it's like in Java there's no big
difference in that perspective or in
that regard it's jvm language it just
behaves pretty similar if you just look
at the object-oriented aspects of Scala
really behaves pretty similar to Java
oh sorry speak up I can no I didn't say
that I said that the int here but this
special class it's in any real class
it's a value class that there's no
boxing and unboxing this will be using
the intimate of data type of the JVM the
same is true for long and double float
and boolean yeah but all other things
are normal java.lang objects okay
can you please pick up I'm sorry but
this I see yeah
so he wanted me to speed up so let's do
that we have this map implementation or
map method which takes a function and
that's the idea of functional
programming high order functions like
map iota methods which take functions or
virtual functions so if you look at the
collection you will find numerous
higher-order functions like map there's
another one which is called filter and
that lets you filter a collection based
on a function which says yes or no to a
particular element so in this case we
could do n like number goes to let's
only let those numbers pass which are
even ok so we do modulo 2 equals 0 and
then we should get back a new vector I'd
go back to list because this is terrible
looking at the output here it gives
always the fully qualified name so now
you get a list to four instead of one
two three four so this is not a
transformer it just reduces the number
of elements now the interesting thing is
you can combine those you can do numbers
map and goes to n plus one and then
because this type wise is just a list
again you can call filter and you do
this here so in one line of code you can
express a pretty advanced computation in
a highly abstract way without looking at
the details of the implementation okay
so I think this is a big advantage of
this functional style you can really
focus on the what
instead of
good point is iterating twice in this
case yes we could turn that into a
stream and then we get that lazy
behavior of course it's not yet
completely evaluated right only if you
consume a stream completely you get all
the numbers you could at the very end
turning it into a list again if you want
to so then it would be evaluated so this
would only iterate it once the way the
Java eight collection stream API would
work um but it's not necessary to do
that you could also use a for expression
I want to show you that anyway so if you
have these multiple steps map there's
another method which is very important
it's called flat map if you if your
function returns a collection and you
want to have a limit every element of
the collection in the resulting
collection called flat map so if you
want to do these steps you can do for N
in numbers only if let's me copy and
paste this guy here and then you do this
sorry
then you do n goes to n plus 1 ok I
forgot a key word it's called yield
sorry so this will return a new
collection and the point here is that
this will only tried it once
yeah I agree I agree it's not completely
the same thing just from the conceptual
level okay so let's move one step
forward and what I would like to show
you now is that you can integrate Java
and Scala very nicely so who've know who
you know is the game of life Conway's
Game of Life a couple so it's a very
nice simulation based on a few very
simple rules you can similarly let
simulate life I will show you that in a
couple of seconds so I will first move
there and run it for you I have a
repository which backs this whole
project so and this is a build tool I'm
using here it will now run this game of
life so you get a JavaFX UI it's
terrible I can't I don't have any design
skills but it should do the job so you
can define your cells on a grid these
green cells are alive while the others
are dead you can define an initial
generation before you start the
simulation and you can define various
forms so the reason I'm picking these
forms is that they behave in a special
way let me run that so as you can see
here we have a constant arrangement and
we have those two blinkers that's pretty
interesting and I didn't do the glider
correctly I forgot how to do that
glider I think that's a glider hole so
that should change its form every four
steps and just glide over the grid okay
very cool so that's very very nice and
there are only two simple rules so
moving from one generation to the next
and a live cell remains a life if it has
two or three neighbors else it dies
loneliness or overpopulation and a debt
cell can become a lot if it has exactly
three neighbors so that's not like for
the humans we always have two parents
they need three but that's it these are
the rules and based on these simple
rules you can simulate a life in a very
easy way now let me show you how you can
implement that in Scala
I'll move here because I don't have so
much time left there's already a couple
of things prepared
there's the cell implementation a cell
is a simple case class it has x and y
coordinates and a method which just
returns the neighbors okay don't look at
the implementation just the signature so
cell just says X Y and which neighbors
it has so the interesting part here is
the generation the generation is a class
which has a live cells so it knows which
are green on the grid right and it has a
method next so this is also again in the
functional way on generation you call
next to get a new generation instead of
changing the generation in place okay so
this is obvious obviously wrong and
there are test cases by the way so they
should be red if I run it here these
test cases say okay if you start with a
vertical bar it should get a horizontal
bar which you have just seen in the UI
alright so in order to implement that we
need to look at those who are staying
alive plus those who are born now this
should be two sets an empty set
and empty set again this would help and
we would do it this way so in order to
determine those which are staying alive
we must look at the alive cells
we must filter them okay
with a method which says yes you can
stay light if you have two or three
neighbors okay so in order to implement
that well we got to come up with a
function which does not return true for
any cell that doesn't make sense get a
use a function which tells us yes or no
depending whether this cell has two or
three neighbors so we have to find out
the neighbors of a cell okay and we
already know the neighbors of a cell but
we don't know whether they are alive or
not right okay so we could define a
method death can stay alive it takes a
cell and it looks at the alive neighbors
of that cell we got to define this alive
neighbors too so else it won't compile
let's say this is an empty set to make
it compile and and then we have to ask
whether the size of this collection
equals two or three okay and that can be
shortcutted by doing set two three
contains the size of the alive neighbors
okay all right so the last step here to
finish that is we got to know the alive
neighbors for a cell well we know the
neighbors it's a field or a method here
on the cell how do we get the alive
neighbors well we know the alive cells
the overall alive cells these guys here
two sets cells and alive cells the
intersection mathematically wise into
the intersection and the scholar
collection is so rich for most cases
there will most probably already be an
implementation or a method which does
the job let's take a look intersection
oh cool there's intersect method so
let's use that and here go that would be
the implementation so instead of calling
cell goes to true we would do can stay
alive so in this case we just use a
method like a function that's a another
nice feature of Scala so we are using
this can't stay alive method which is
listening to a function and well that
way we can implement that I'm running
out of time so I won't show you how to
do the born but it would follow a very
similar approach so the final solution
would just be this here a couple of
lines more code but that's all you have
to do really does these nice little
one-liners which are very expressive you
can just read the code and hopefully
almost you're a fan what's going on and
these are really all the rules you have
to know for the game of life okay in
order to concatenate two sorry in order
to to create the union of a set this is
the operator which is defined for it the
plus operator on a set adds one element
to a set and the plus plus adds two
cents so finally let's let me very
quickly show you the implementation of
the UI so you believe me that you can do
all that integration between Scala and
Java that's that's it so as you can see
here we are importing a lot of Java FX
stuff and it's just used here from Scala
the code written in Java would most
probably look almost the same way
because we have to fold the Java at X
approach here which means building all
these UI elements and doing all that
event handling listening stuff so
there's no big difference here all right
so I think I'm almost running out of
time so therefore I'd like to shortcut
that I'd like to wrap it up say thanks
to you you can look at the code if you
want to it's on github it's my user ID H
C burger skull in action
and I think we have left for one time
left for one or two more questions
yeah
so what's the best kind of application
there the power of Scala or yeah it's a
typical use case for Scala I'd say that
it's as it is a general-purpose language
you can use it everywhere so I only
program in Scala
but Scala and it's immutable nature make
it a perfect candidate for every
concurrent system whenever you do
something concurrency it's still hard
but it's ways easier than in Java where
you have to use a lot of synchronized
volatile and locks and stuff so Scala is
a better fit for that but if you look at
the first example I showed you this
concise oh why would you want to use a
programming language which is so verbose
and add so much noise if you can't have
something like Scala so I think it it
has a lot of advantages in almost any
scenario you didn't have any questions
so far
oh yeah the question was whether one can
hot load code so first yes you can do
the same things like in Java so using J
rebel or stuff and there's a compiler
and an interpreter so you can really in
a running system load let's say a script
or just a piece of Scala code evaluated
and use it and that's even more yeah so
you get a very nice tooling for that no
there's not a problem using Java on a
different rhythm like IBM no shouldn't
be a problem no problem so far because
it's just a library from that
perspective shouldn't matter at all you
need Java five at least and that that's
the only yeah Oh debugging yeah that's a
good point you need good tooling for
that so in Eclipse and IntelliJ you have
it
so the object-oriented stuff is easy
debuggable because the bytecode looks
like source code like you would expect
it from Java if you use functional stuff
like map and these lambdas it gets
little hairy but I don't know how the
Java folks do that by the way so we have
but they're still work-in-progress
debugger support is there it's not yet
super but it's okay
well that's a very nice question because
that's how I started into scholar so
Scala and I was di I wasn't no expert
some years ago
so yes it's not a problem at all it's
not so there's no I mean yeah like like
any Java do you have the same issues
like from a Java perspective if your
libraries don't like or I'll not OSGi
friendly then you will have but yes so
that's possible yeah I wrote a Scala
library is called Scala modules if
you're interested it's it's almost dead
but it's nice ah you if you want to know
how to write a scholar DSL
domain-specific language um you can take
a look it's a pretty decent I think so
thanks a lot for your attention
enjoy this conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>