<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>BDD and Beyond: Automating Acceptance Criteria with Style | Coder Coacher - Coaching Coders</title><meta content="BDD and Beyond: Automating Acceptance Criteria with Style - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>BDD and Beyond: Automating Acceptance Criteria with Style</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-D5l3vstPws" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's get started a brief introduction I
am John smart do a lot of work in the
technical agile space so behavior driven
development test driven development
continuous delivery that sort of thing
but today I don't want to talk about
what I do I want to give you some
hands-on experience with what behavior
driven development looks like in the
real world who who does BDD in in
practice in their daily work a couple
who use cucumber or G behave or a few
more who have just come to see what it's
actually like cool you can move up
closer this is a quite a small intimate
crowd we couldn't get nice and cozy what
are we going to look at today we're
going to just go over the basics of what
BDD is if you want the full story the
talk at 11:00 11:30 I think it is doing
another talk later on this morning which
is more about the theory more about the
principles today it's hands-on so we're
going to be working through a few
scenarios using J behaved acidities
webdriver spring few other tools Spock
and few other tools like that and we're
going to be seeing what it means to
produce living documentation and I'll
talk about that a little bit more in
detail when we get there we'll be
looking at doing BVD with web interfaces
but also with non web interfaces so West
web services and so forth and so this is
all going to be very hands-on we'll just
have a small number of slides and once
we get through the first half dozen or
so slides it'll get interesting so quick
overview of BDD
in a nutshell behavior driven
development is an approach not a toolset
that's really important because in this
session we'll be looking a lot of tools
but BDD is not the tools you can't just
use a be needy stop to
during baby there won't work it's not
effective BBD is a collaboration
technique it's about using discussion
conversation around concrete examples to
identify value and to build up a shared
understanding of what you're actually
trying to deliver how you can deliver
value to the business so that's really
important
figuring out how you can actually build
valuable features so you don't waste
time on building really cool stuff than
no one uses hate it when that happens so
an important part of that is being able
to verify what you've built that what
you build actually does what it's
supposed to do is so that's where our
automated acceptance criteria come into
play when you get large applications you
can't in theory test everything manually
but it becomes a bit of a pain and not
very reliable so automated tests become
really important so that's where the
tooling comes into it that's where the
BDD tools their communication tools for
automating your acceptance criteria in a
way that you can talk to the business
about what you've done and then when you
take it a notch down into the what you'd
call the API or the coding level baby
they applied there as well so this is
more of what traditionally would be
called TDD we'll see how debility
principles also work there as well and
that goes into the code quality aspects
of it you can't even touch continuous
delivery if you're not doing a decent
effort in the test automation space it
just won't hold water and that's both of
the acceptance tests and at the unit
test level unit or integration tests I
don't make a big we'll see I don't make
a huge difference between units and
integration tests I have a bit of a
different approach when it comes to
distinguishing what tests are out we'll
see that in action and then we'll look
at leaving documentation which is a very
important concept which is the way you
give feedback to the business about what
you've actually done in very concrete
terms so just very briefly traditional
development only gave variations on
these little spectrum but in a
traditional development process
you get a BA or business owner who
basically says okay this is what I want
done BA writes up some specification so
it might be a big word document might be
user stories still vo comes up with some
specifications translating what the
business wants into specifications
that's important developer then
translates the business specs into code
tester translates the business specs
into test cases
see there's a bit of a disconnect
already and then once you get to the
actual delivered product that may or may
not correspond to what the business
actually wanted because there are lots
of points in the circuit where you can
get misunderstanding miscommunication
forgotten details hidden assumptions and
so forth so that's what agile in general
tries to avoid but if you're just doing
user stories of either mini waterfall
style doesn't really help that much just
limits the time you can spend building
the wrong thing which is good but still
you can do better
BDD uses a collaborate a collaboration
approach where you get together to
discuss what you're trying to build you
use worked examples use real concrete
ideas real concrete examples to work
through what a feature should do why it
should do it what the business value is
what the business case what the point
what's a point and then come up with
counter examples assumptions make sure
you everybody is very clear about what
needs to be built and how to build it
and how it's going to deliver value and
that common understand it's not doing
specifications right upfront if this is
as you do stories but as you do that you
get a common understanding of what
you're supposed to be building and that
gets transformed into automated
acceptance test they may or may not be
automated actually this gets translated
into a form a relatively formal form of
examples formalized examples and
oftentimes they are automated and these
automated tests guide the developers in
the writing the code they divide they
guide the testers when they're testing
what's been built they document what's
being built they
help with the reporting of progress
we'll see this in action but it is that
whole automated generation of
documentation is really powerful but if
you automate the wrong thing it's not
that useful so the collaboration is more
important good to get the collaboration
first that said today we're going to
just be looking at automation
collaboration stuff I'll talk about that
later on in the next session but today I
want to focus just on the tools I just
want to get the give the context we're
going to be doing a little demo app so
it's an airline frequent flyer
application and before we have a look at
the scenarios I just want to give you a
bit of context so the just because
there's no point writing scenarios if
you don't know what value they're trying
to deliver what business goals are
trying to meet so if you don't have that
context it's a lot harder to really
understand whether what you're doing is
useful so we're going to get a bit of
that context basically we've got a
frequent flyer application usual story
you earn points so you can get cheap
tickets that's the business goal you
want to get well the real business goal
is you want to get more people buying
frequent slot buying airline tickets
with flying high Airlines which is the
name of the airline and to do that we
need to provide a number of capabilities
so our capability is the ability for the
business to do something a may or may
not be resolved we're so capabilities
you got to let people earn points when
they fly earn points maybe when they
spend with partners or on credit cards
they've got to be able to see what point
how many points they've earned and so
forth now when you're building an
application using a BDD approach you
take your capabilities typically and
you'll try and figure out what software
features can deliver those capabilities
so every software feature Maps back to a
business goal that's important as well
so if we got for instance viewing earned
points some of the features that we want
to deliver so we're not talking about
stories we're talking about features
bits of functionality that you can
actually use so it might be viewing the
current
balance viewing how many points you need
to get to unused next status level
calculating how many points you need to
go to a given destination things like
that they're features that we want to be
able to deliver to make users want to
get it buy into this program and
increase revenue for free for flying
high so that's just a very short
overview of what the application does
now we get to the interesting stuff
so those notes are just for me so I
don't forget anything
so yes let's have a look at the
applicator the application basically is
a small angularjs front-end which talks
to a couple of web services and behind
the scene there's a MongoDB database
that's it pretty simple stuff the each
service can be deployed independently so
it's a micro service architecture I
don't want to attempt the demo gods and
actually do a full deployment but this
project is actually set up so that there
goes through a Jenkins build pipeline
and pushes out to different staging and
production environments the other point
of saying that is that BDD is not in
isolation it's a really important part
of a whole delivery pipeline if I have
time I'll show you the what the pipeline
looks like when we get some working
features so let's have a look at the
application so I'm assuming everybody is
vaguely familiar with Java yeah so let's
have a look at our application I don't
think I can increase the size of this
side but you don't really need to know
about that so basically we've got a
little application with two web service
modules we've got an Accounts web
service and a flight web service and
we've got some acceptance tests and
we've also got a little angular j/s
application with stuff few screens now
let's have a look at the application so
this is the application it's all its
glory it doesn't actually do a lot
though does it so basically we can say
where we can fly to and if we go into
the your account you can see we can't
see anything really it's sort of
unfinished
looks like we need to add some features
so but I will show you before we get
into the features I'll show you the
living documentation anyone see that
like in
there's not a lot to show to be honest
this is the except the these are the
acceptance tests to run the acceptance
tests I'm going to run them using a
Gradle build so nothing fancy here this
is this module is just pure acceptance
it's no application code this relies on
the application running somewhere else
so it's going to load up the application
screens and start to run a few
acceptance tests so there's nothing
there it is still testing a fair bit of
stuff so I'd normally be doing it on a
virtual on a vagrant box so the screen
the browser windows don't pop up I find
that quite annoying but this is just to
show that these actually testing
something so we've just tested run all
the tests and I'm going to open the so
here we have the test results so we've
got 29 scenarios and 12 of them passed
17 of them are pending pending means
work in progress or we've just said we
need to do it and have it done it yet
and what sort of test we have we have
things like well we need to be able to
calculate points in different ways need
to calculate how many points we need for
a particular destination display the
available destination on the home page
well that works at least burning points
by frequent flyer status so we've got
different acceptance criteria these are
really detailed acceptance criteria now
that's really that's really cool you can
tell see that's least of the tests you
run but could you show that to your
product owner and say here this is cool
this is what their application does and
not really not so much you got 11 tests
here Matt you got 200 it's going to
start to get a bit confusing so we need
a little bit of an aggregate an
aggregate view so one way we could do it
is do
by stories that's a bit better so here
we've got a list of the stories or
features so depending on the tool use
some of the tools use stories and
features interchangeably technically a
story is not a feature but we won't
dwell on the details here we have a few
story it's only got nine of them because
you've got multiple acceptance criteria
first story so it's kind of getting
better you could probably show that to a
product owner embedded within the
project maybe for a sprint but again for
a whole project you might be started
it's getting a little bit a little bit
dense if you're going to show that if
you had a six-month project with
hundreds and hundreds of user stories
it's going to get a bit dense so you
really want to think in terms of maybe
capabilities so here we have aggregating
by capabilities the ability to manage
airports we're sort of on top of that we
apparently we know how to spend frequent
flyer points but the earning points and
the frequent flyer partners bits not
done at all that's another way we can
look at it but for more complete point
of view what you'd really want us to
think in terms of requirements where you
have you're basically starting at the
top level so here I've got some
capabilities we've got some stories some
acceptance tests and from here it's
actually the capability view but they're
from inside the capability in say
airports ok that's cool what stories are
associated with airports oh you can list
the airport's whoopee-doo
maybe we need to make the airport
capability a little bit more complete so
this sort of report gives you that
aggregate view that sort of high-level
view and the ability to drill down to
see where you projects at so that's
quite important as well but reporting is
all very good it would be nice to
actually deliver some features at some
point so let's have a look at some
features so what can we deliver how
about we have a look at
the acceptance criteria so I can read
this you probably can't but I will find
you an acceptance criteria that we can
read viewing points summary that'll do
so who is familiar with this format this
is a format called this is similar to a
format called gherkin technically it's
not good and because it's J behave but I
won't go into the details it's a format
that's very widely used in a lot of BDD
tools tell you express their acceptance
criteria so our acceptance criteria is
that for a particular story we need to
be able to view the point balanced and
we've got the context here the story is
in order to know how many points I've
earned as a traveller I want to see my
total points that gives us our the
context a story that's what you'd have
on this story card and you'd have
several scenarios here so given Sara as
a frequent flyer member with 800 points
once you use a can't beat us you should
see a balance of 800 points that's
pretty obvious stuff but for the moment
it won't work because there's nothing
being displayed let's have a look at the
details of these while we're here just
to show it's not magic every line here
is mapped to some Java code so we've got
given Sarah is a frequent flyer member
with 800 points let's make that actually
do something it doesn't need to throw an
exception to no whites whereas yes it
will maybe it will anyway so got big to
do here and I may of I may have a very
good idea of how to code this in the
comments but normally obviously you'd be
writing it from scratch but I won't bore
you with that now the interesting thing
here is we've got Sarah is a frequent
flyer so we've got variables in this
string dollar frequent flyer is a
frequent flyer member with dollar points
that's boring let's rewrite this let's
make this a bit cooler so what I'm going
to do is so I'm gonna say frequent flyer
flyer
now a frequent flyer is actually an enum
this is a technique called knowing in
what I call knowing entities Sarah is
someone that we all know and love sarah
has a frequent flyer number
she has an address an email account all
the RET all the details probably got a
feature stuck up on the wall somewhere
in the team room so no one person it's a
technique called persona so when we talk
about Sarah
everybody knows who Sarah is it's not
just a random name that's been invented
and the way we do that is we've got this
here it's really simple but we've got
Nina Sarah who has a frequent flyer
number of one two three four five six
typically you'd have a lot more data in
that enum that would describe everything
you need to know about Sarah in the
context of your tests so that's where
Sarah comes from so J behave and
cucumber tools like this let you pass
the nums directly into the code so go we
can pass CC now so we don't need that
they don't let's get rid of it to do and
now assigning points to a frequent flyer
obviously we could do that in a number
of ways in acceptance criteria in BDD
style you typically do things from an
outside-in point of view so you call the
application using an external interface
of some kind but that does not mean you
have to go through the web UI every time
in fact it's a pretty bad idea to go
through the web UI every time because it
flows down the test and makes them
unreliable and it's harder to write so
just so happens I've got all this REST
API so I'm using spring spring for
spring boot I know there are few other
talks on that at the conference which
makes it really easy to write rest api
is on top of databases of different
sorts and that's what i'm doing here so
a bit of rest client
so I'm going to effective I'm going to
update the points for the fire for this
particular flyer get update up to these
points so what does that actually do
yeah we do need an exception and the
rest client just for curiosity so one
thing that spring does quite nicely is
it gives you there are a few API to do
these so plenty of ways of calling rest
web services from Java so I won't spend
too much time on that but they vary
quite a cool one in spring called a rest
template and the rest templates you can
do things like basically we're building
up a URL passing in a parameter it
converts it in this case to a we're
getting the URL so we're actually
getting Lee because it's a proper peytie
our REST API we're getting the link to
the to the frequent-flyer member then
we're getting the frequent-flyer member
so get for object use on that URL
setting the status and then putting it
so we're updating it using a fairly
classic REST API technique the idea of
doing this is to keep it all external so
you don't but I mean you could directly
call the MongoDB database whatever
you're using in the backend if you
wanted to it's very much up to you how
you do these sort of fixed your code but
I quite like to do it externally so
that's our first step oh yeah we still
got a pending so let's get rid of
appending so that's our first step that
should be working so we can now
we go back to our story here she views
her account details let's have a look at
that one sir
when she views her account details so
here we have Sarah who opens an account
page now this is a webdriver test but
you'll notice I'm not doing any direct
webdriver stuff here that'd be really
ugly one of the keys to writing
acceptance criteria acceptance tests
that are maintainable is to keep your
layers keep your layers of abstraction
well defined the developers usually get
that pretty well as long as you point it
out these are not test scripts this is a
text API so it's got to be well
architecture just like your application
code or you'll get into trouble down the
track so the way we're doing it here
we've got a layer so this first layer
we've got a steps library which is a UI
layer for the My Account functionality
screen and the first thing we'll do is
to open the accounts page and this has
actually got some ajaxy stuff going on
so he do an explicit we wait for some
stuff but typically all you need to do
is do an open and the my accounts page
where does that come from that's down
here so again we've got three layers of
abstraction here the first layer is in
the given when then steps where we're
basically describing the flow through
the application what the business
objectives are of each step so given
that sara is on the accounts page okay
so we go and open the accounts page and
then the actual details of opening it
that's in this class which is called a
page object which encapsulate any
webdriver logic and we'll have a look at
that just to see what it looks like
so I've commented out some stuff here
because we don't know yet and it would
hamper the test but this is a fairly
typical page object they're not
particularly complicated things where
you want to keep them simple or gets
hard to maintain like anything
so this is where you're doing things
like looking up the departure object
selecting by visible text so we're
selecting of departure city destination
city and so forth these are all CSS
selectors because I like using CSS
selectors with web driver who is
familiar with web driver so you know
with webdriver you can use CSS or XPath
or the text in links or different ways
of identifying things on a web page and
then manipulating them oh it's been too
much time on that but just to give you
an idea of where we're trying to get to
then so she reads our account details so
she's on the account details page then
she should see a balance of however many
points so Sarah should say about account
balance of how it whatever so here
should see so if the short sorts in
assert of some kind so here I'm saying
assert that my account balance get
points balance is equal to the expected
value now the principle here 90% of the
time your page objects their role is
just to do things on the webpage or
return information back from the webpage
not to make any judgments about the
quality of the data on the webpage so I
like to avoid having any asserts inside
my page objects the page objects their
job and say hey there's a this number
field has a hub value of a hundred
that's in the layer above where you can
see a hundred is that what to expect or
not so here we've got the an assert
assert that so I'm using feste assert
here you could use hamcrest you could
use anything you want assert that the
balance is equal to the expected points
again this is pretty basic stuff yeah I
would think there's nothing particularly
fancy about about that that's you do
that in unit testing so again most of
the techniques we're using here there's
nothing really
particularly sophisticated about it's
just the way you organize things so is
that going to work good question I've
activated the test well it's runners and
see so run the test again sorry first of
all let's just make sure which test was
it that we were trying to demonstrate so
it was viewpoints balance which is in
the pending state so we can see here
that's the current point balance in the
pending state let's run it again and see
if we're actually getting anything
displayed in the on the screen we could
test it manually as well but that'll be
kinda boring
I could also write a test harness to run
this particular test but you would
probably take longer than running the
tests so I won't bother I don't think
we're getting any points maybe I've
forgotten to actually implement the code
so we have a failure error count of one
so what's going on here now we don't
know long have a pending test whoever
failing to so in TDD terms this would be
the first point you've demonstrated that
the application does not do what you
want to make sense all we've done is
written the acceptance test we haven't
actually written any code yet and so
could not reach a sono unrecognized
field status okay that's a real error
that'll teach me to make last-minute
changes so what's happening here is I'll
walk you through a bit I won't bore you
with the details of actually showing the
implementation we're not getting the
details we expect from the account so
the accounts look like this any assume
that here we go
that's the accounts API so we got four
first name last name airport status
status code I this morning I added a few
features to demonstrate spot that we'll
be looking at later on some of those
features happen to include some new
fields in here that are may or may not
have included in the code that manages
the JSON mapping so drop me two dates
actually make that work or should you
want me to go to another test it's up to
you I can do it either I'll have to make
a work at some point make it work okay
so we're going to have a look at this is
quite small bear with me a minute okay
that lower the resolution the screen so
you can actually see what's going on in
the project column
what's written in mitosis in that
maybe I won't
said any better a little bit 720 that'd
be really claustrophobic okay let's go
with that so that would be the accounts
web service so I wonder what happens
when we run the except that unit tests
are the integration tests for the
accounts they're looking up accounts
so who works use a spring anyone using
spring for spring for has a lot of nice
features in you can write basically
annotation driven self executing jars
and deploy micro services very very
easily that's what this does and this is
actually a unit test for an integration
test go away and this integration test
is not surprisingly failing it's failing
because it's running it from inside
IntelliJ and it's not getting the class
pass right that's a different issue
let's run the tests from the IDE now
from the command line see what happens
there so what I want to do is see if we
have actually reproduced this problem in
the integration tests the integration
tests are in separate modules normally
this goes through a pipeline so here
we're basically running the acceptance
test without having run the integration
tests so I'm going to see if the
integration tests pick up that error and
if they do we'll have isolated the error
and if they don't then we've got a
missing integration test so let's see
that's in the it'll be in the account
service shall we here so if we do a
Gradle thing at the cradle
think it's great on integration test for
this one
we're running all that unit tests first
then rounding the integration tests and
when it looks like we're missing an
integration test
to explain actually what's going on I'll
show you the code so we've got a
frequent flyer member code here this is
what the code looks like so that's our
application we've got these fields one
one's an ID so that's generated
automatically by a MongoDB or both
spring spring layer to be more precise
then we have a the fields that are
causing problems of the status and the
status points so let's have a look at
the error again
unrecognised field status
and status is
effectively we have status here which is
in this case a string why would it not
be converting that to an enum
I'm a little bit surprised that it's not
picking up they were here to be honest
but I'm sure there's a very good reason
for the update operation
so that would not be the update there is
actually a test for the update but that
would not be the update let's ignore the
you know let's not ignore it that's the
conversion I think it's the conversion
from the string to the ena which is
causing a problem which is annoying
because we use it in the unit tests
further on to demonstrate Spock so I'm
going to have to I think I have to write
a converter for the scene um which it's
kind of annoying because that will take
more time than I want to spend on it so
what I'll do for now is I'm going to
back those features out for now and I'll
put them back in sure will that work
pepper ignores really
anyone remember the spring rest
annotation to ignore Jason fields
it's something to do with ignore Jason
ignore properties I think that might be
the one
and that will take that yep
see if that works
I should write an integration test for
that
but I don't want to spend too much time
on that detox it's another material I
want to go through okay so let's run
that and see if we're
so that's how you start up a spring web
service in spring 4 so now have a
running web service let's make sure
we're still getting yep demo status so
your is the right annotation let's run
the acceptance tests again see what
happens
so I still not displaying points but
let's see if we're getting the error
I think we're hopefully it will get the
JSON data back
and then we'll have a look at the
angularjs side of it and see how you'd
actually implement that feature going
from the UI down the service layers
which is normally when you do BVD you
always do an outside-in approach so you
start typically you feel the feature to
implement on a screen you'll start with
the screen start mocking out the changes
in the screen and then figure out what
you need to do to implement those
features on the screen so that's more
interesting should see an account
balance of 100 and we're not getting
anything so that's what we typically
expect so thank you for whoever said the
J's the ignore imitation that did the
trick
so now back to our normal program this
is the My Account screen so Lisa who is
has some familiarity with angularjs
who does not it doesn't really matter
I'll explain it as we go and it's not
important for what we're talking about
here basically the way this works is
that at some point we're displaying the
status point balance field and we're
going getting an account status points
that's where the data is coming from
we're also getting the data incidentally
the account or first-name an account
last name the way that works is
angularjs has this idea of scope and you
put variables in scope in your
JavaScript and then that gets displayed
that gets rendered in the HTML in a
nutshell that's what angularjs does so
where that happens is in here oh I seem
to ignore I seem to be little negligent
here I may have accidentally commented
out all the interesting code so what
happens here without boring it with the
angularjs details what this does is
we're going to call an account basically
we're calling the rest service against
this guy we're looking up the accounts
object what are we looking it up by ID
so we happen to presumably normally
you'd have a log in our feature where
you'd actually go and authenticate the
user but we haven't done that here here
we're just hard coding it to Sarah for
now so we've got we're looking up the
account with an ID of one two three four
five six and then we're going to go and
put that account in the details and I'll
do the other stuff as well because I do
want to get I see we've only got 15
minutes left and I want to show you the
unit testing stuff as well so and
further on where we have some other
stuff which I will show you in due
course so now our angularjs application
is actually showing the data correctly
so now it's going to the web service and
fetching the data so now when we run
this again hopefully we should get a
passing test
now when you're running these web tests
typically you'll have a choice between
running them in a on a virtual machine
with something like phantom Jas maybe or
running them in on a virtual display at
half who's used phantom Jas yeah I've
used phantom GFI you get limited varying
mileage depending on your application
sometimes it renders in surprising ways
and on the other hand Firefox will run
out of memory from time to time so
horses for courses let's see if that
worked so now we have a passing test and
we can see the result here in the
reports we can actually see the 800
points as expected so now we basically
got that feature implemented now I've
been sort of glossing over some details
in particular how you actually code the
backend stuff let them look at what I'll
walk you through some examples of what
BDD coding would look like at the
low-level speed IDs for the acceptance
criteria but it also worked for the
lower-level
in this application so you earn points
basically more points you get the
further you can find so fast so here
I've got what I uncovered was a little
calculator where you can figure out how
many points you need to fly from a
certain certain city to another city now
the points also give you levels so gold
silver platinum and world sapphire
whatever that sort of thing so to test
that I'm going to show you what that
would look like the coding level how you
would go about calculating how many well
what status level you've got for a given
amount of points so you'd have
effectively you'd have a J behave
scenario for that as well
as you drill down into the code
at some point you're gonna say okay we
need to model this at the Java level and
the tool I will typically use for things
like that is in Java code is Spock
anyone familiar with Spock yeah Spock is
awesome if you're not using Spock go and
use it it's very very cool so here is a
you saw there you the spring unit test I
wanted to show you put in both of them
just to have show you the difference
this is a spring integration so yeah
first point you can do be be doing a
unit that's a bdd test sort of all I'm
doing is saying what the behavior should
be as opposed to saying testament test
method a test method B I'm talking in
terms of it should do this it should do
that should display the current
application version or so that's a
perfectly legitimate BDD style test you
don't this trick with BDD as you're
talking about describing behavior in
terms of examples it's not using a
particular tool so you can do it with
j-unit on the other hand if you do it
with Spock it becomes awesome this is a
Spock test
so could anyone hazard a guess at what
that might do
yeah exactly that's exactly what it does
I mean it's pretty cheap without knowing
Spock it's pretty easy to understand
what what's going on if I run that I'm
gonna have eight different tests because
I've got this unroll annotation with a
little bit of text here so I've got this
hash expected status level and hash
points earned I don't have to have that
tech text but if I do have that text
probably can't zoom that but you might
be able to see here we've got the eight
Tests expect bronze for 299 and expect
silver for 300 and so forth so that's a
very behavioral style test you'll notice
I haven't really talked about methods
here I'm just basically when I come up
with that I'd be starting with this
table first thing I do is say okay I've
got this table here at the top here's
the data I need to need to figure out
then I'm going to say okay well status
what's the status level for a particular
amount of points and I want that to
equal the expected status level and
they're not going implement it so the
implementation just for the fun of it
okay so basically here all I'm doing is
I've got the status which is an enum
with an attribute so I've got the
minimum number of points for each status
and here I'm just using the Java rate
streams so first I'm sorting it by
descending minimum points then I'm
filtering it to retrieve only the
statuses that whose points are greater
than the minimum points and then I find
the first one and if I can't find a
matching one then I'll find bronze and
that but that's done after I did the
specification obviously
so let's have a there anything else
that's interesting here you don't have
to do
Spock test in that format you can do
really simple ones and here's a really
simple one where I'm just testing a
builder so I've got a frequent flyer
member with a frequent flyer number
named Joe Bloggs and I'm just checking
that actually does the building
correctly again I'll be writing that
first I like to write that first just so
that I can figure out what sort of
builder I like to I like using builders
for this sort of stuff because I find it
makes the code a lot easier to read and
if we have a look at another example in
the
so this is a more slightly more
complicated example again I'm using
builders but here I'm also using another
feature of Spock which is quite cool
it's the mocking and stubbing which is
very easy to do and support very
painless here basically we've got this
repository which is a rest spring rest
repository I don't want to actually test
the rest for closet area here because I
know that works that's the rest
repository for if you're interested so
that's all if you haven't played around
with spring fall that's the code you
need to do to write a non-trivial hate
EOS rest api against a yeah that's
against that's against Mongo that one's
working against Mongo so that's pretty
pretty minimalist code to get some
pretty decent for it so that's what
generated those nice well nice if you
like those standard each reports like
that for the routes it would be
I think
well there's the airport anyway not sure
where the roots are living but that gets
all generated from this sort of code
very very lightweight and but I don't
want to actually test the rest API for
the assist of the unit test so I'm going
to mock that out I'm going to say okay
the route repository when I call find by
departure code and destination code
seemly Melbourne then I should get this
route back and here again I'm using a
builder to make the code a bit more
readable okay I don't know you guys but
I'm capable of mixing up the order of
parameters if there are two parameters
in a constructor so I like builders for
that avoids really silly mistakes and
that's all you need to do to mock out
that service in spock this is this shift
operator then i go and use a point
calculator which uses a repository
calculate the points and then see if
it's actually the required points now I
might do the same thing for another test
I check that it works in both directions
and so forth so just that's the sort of
BDD style unit testing low-level testing
some would call it TDD done well and I
would not I wouldn't disagree with that
that's basically good coding practice at
a low level I find it really useful to
use this very descriptive approach both
at the high level and the low level so
I've shown you how how we do more or
less how we build a feature going from
the j-bay scenario down through the UI
building building out the acceptance
criteria and getting our working
criteria acceptance criteria now I've
showed you the at the actual coding
level this sort of unit testing style
BDD and we've also had a look at the
living documentation that comes out and
living documentation is really powerful
because that can actually help with your
project reporting and your the feedback
to bas and product owners so that's a
really really powerful part side of BDD
at the acceptance level but this is all
focusing on tooling and once again
BVDs starts with collaboration if you
don't get the collaboration right it's
very hard to get the tooling the tooling
won't help if your collaboration isn't
up to scratch you'll be automating the
wrong things but if you get the
collaboration right then the automation
can be really powerful
so what we're the tools were used here
were Jay behave spark and through
Citadis cucumber JVM is another popular
alternative to Jay behave at this level
the syntax is slightly different but
it's a very similar approach and we also
use spring integration tests we have
four minutes so I think if we can
questions I find it really useful as a
tool jib gems really cool the only
problems are reporting Spock is good it
all depends on your audience if you've
got a technical audience you'll get away
with it if you've got a BA audience
product owners testers who aren't
technical maybe you can't read the code
it's harder to do because you don't get
that sort of living documentation so
what yeah
yeah now there's no reason can't do both
the trick with your acceptance criteria
is you don't need a gazillion acceptance
criteria at the reporting level you need
enough to demonstrate that the
application does what it's supposed to
do for your product owners your tests in
and so forth it's more the testers that
drive the quantity of tests they want in
the acceptance criteria Oh so oftentimes
what you can do is have high level
acceptance criteria you may not have
every possible combination but when you
get into the details you might use
something like Spock or in JavaScript
there protractors another option if
you're using angularjs it's another
option for sort of low-level BDD style
but more technical tests which aren't
really aimed at communication 21 other
than developers but for communicating to
developers to heck lot better than just
a unit so I is it possible to have a
complex domain language for you might
say you're talking about dsls
I see where you're coming from yes
so the problem the question is how do
you express complex
accept complex conditions or criteria in
the gherkin format it can be non-trivial
okay if it's basically if it's too hard
you want to wonder if you're automating
it in the right way maybe and you want
to think it taken to notch higher and
think in terms of examples and then have
maybe a comment column in the gherkin
table where you're saying this is a
business rule I'm applying well this is
the logic I'm applying because you can't
express everything just as given when
then or as a table of examples so you've
got to know when the tool fits well and
when it's a if it's too hard to fit then
maybe you want to express some other
Express the acceptance criteria in some
other way you don't have to do gherkin
to do BDD after wtd with Excel Excel
spreadsheets was a long time ago but
Nextel spreadsheet produced by a
insurance company that they use for
manual testing so we automate it against
that it had about 6,000 cases of carry
examples of car insurance combinations
and so we just fed that into an
insurance our calculator and got the got
the results so it doesn't have to be
gherkin we use a tool which is most
appropriate
I find gherkin works well in a lot of
cases but if you come across a case
where it doesn't use something else yes
where we've got time for one more
question I think I will yes I've got to
tidy it up because it's a it's a little
bit messy and it's got all my
credentials for the continuous delivery
side about the yes I will put it on
github thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>