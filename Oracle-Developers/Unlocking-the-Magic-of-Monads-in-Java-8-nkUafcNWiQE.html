<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Unlocking the Magic of Monads in Java 8 | Coder Coacher - Coaching Coders</title><meta content="Unlocking the Magic of Monads in Java 8 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Unlocking the Magic of Monads in Java 8</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nkUafcNWiQE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Alex life and today we'll be
talking about monads and jo8 and maybe a
functional program just a bit so yeah I
think we're ready to start right now
yeah this is my first time at John one
so really hard to see so many people
coming to listen to me
so direct questions how many of you came
to actually learn something versus how
many were just attracted by the monads
in the title and want to ask three key
questions
that's awesome then we'll probably have
have some fun so let's start with a
little introduction so I'm coming from
Estonia and I worked for zero turn
around this is a company that does
development a product for developers
making development in Java a better
endeavor so you can later find us at the
expo hall and talk to us about frogs and
stuff I also write an author a travel
apps which is a Content kind of division
as a return around but it different not
product manipulated so we just publish
nice blog posts about all things Java
and sometimes reports and I'm also
studying at the University of Tartu
I'm a PhD student looking into dynamic
system updates and code evolution so it
gets busy so if you're wondering how I
can combine all those things then the
winters in Estonia very long very dark
and incredibly cold so that's me
so today we're gonna talk about monads
and this is a slide with the most the
most text from this whole presentation
so it gets better but what I want to do
I want all of you to maybe learn and a
new singer to about like Mona's in
general
or listen to my opinion how one can
explain moments to two people and we
will try a problem first approach and
giving the secretary session is kind of
introductory we will ignore all almost
all fancy details like ad hoc
polymorphism or like what's the
difference between that and parameterize
spoonerism and how does it involve that
gets into the topic so all the really
interesting stuff will we can discuss
later but here we'll start with simple
things and try to get into a general
understanding about monads so lots of
people when obviously first thing that
you come to that comes to mind when it
heard here like something about Moniz is
a great functional programming right and
then some people think that Java maybe
not the best language and most adequate
language to employ functional
programming techniques something kind of
exhilarating
like this product here but well with the
recent release of Joe it obviously you
know that Java got lambdas which is a
first like big step into getting into a
functional programming language land so
now you can assign functions to
variables and treat them as first-class
citizens so that makes functional
programming in Java much better there
are still some technical limitations and
how Java can compared to other languages
handle recursion or something but that's
also kinda advanced will not go there
how many of you have done or seen
something enjoy it
how many of your customs to lambdas and
things okay so will really quickly just
recap a couple of things just to know
the syntax in that to know that
everybody is on the same page so first
of all you have enjoy wait we have
functional interfaces
a functional interface is a single
action method thingy so we have an
interface that declares one method just
one right you can by the way have other
methods that have default
implementations but one abstract method
so here's an example from a Joe it it's
a function interface function from T to
R and a single metal they apply right
now object that implements this
interface can be treated as lambdas and
they have a special syntax to describe
them and to assign two things so first
of all this is a method handle syntax so
you can use double cone to reference a
method so in the given example we take
the value of method from the integer
class and assigned it into a variable
pretty simple pretty straightforward we
will see that it's kind of useful later
and obviously syntax to declare a lambda
so we have this function from string to
an integer F and it will be a function
from string and the body of the function
comes in to in a curly braces later and
also note that lambda kind of captures
the context so we can use the final
variables or virals that are not
declared declared final but actually are
not any changeable later we can also use
them in the body of the lambda so that's
all we should know about
how to use lambdas enjoy it and we'll
try to build a road into understanding
monads using that stuff which is cool is
Monas are kind of hard to grasp and
there are like thousand tutorials on the
web and thousand blog post explaining
how I'm on it is and how we should treat
that
why is it so hard to explain at the
first place and when you actually
understand the concept it kind of seems
really obvious so that's how all those
blog posts click creates it somebody is
like oh I just understood how Mona's
work let me write a blog post about that
because obviously nobody explained it as
easy as I could do that's how this
session was devised as well so yeah so
but the thing is
omona describes a different concept so
first it's an algebraic type that comes
from the type theory and you have like
hierarchies of monoliths functors
applicatives and whatnot and the
monolith is somewhere in there and it's
really useful and interesting concept
and then there is a useful part from the
most how you actually as a programmer
would want to employ the concept and
implement that and maybe do something
useful with it in your project so
essentially understanding Mona's you
have to draw a line between those two
parts it's like when you want to do the
bridge right you kind of should know
basics of the physics but you don't need
to know like quantum mechanics to just
deal the bridge at some point of time
when you want to build a Golden Gate you
should know more but if you just have a
local River that you want to cross with
some bridge you just need some basic
understanding and keep going right so
we'll start with a problem that will
describe shortly and we'll try to devise
a solution and I will try to give as
little theory about the algebraic
concept of monad as possible so we'll
focus on the practical stuff how to
write monadic code and how to use that
in projects and obviously projects using
Java so here's the problem I'm pretty
sure that how many of you deal in the
web app development or something like
that something that is related to
JavaScript so this example the code here
is a piece of JavaScript jQuery
call so we take a button element and we
try to fade it in and the function that
prints hello world to the console is a
callback so this will be executed when
the action completes right so we want to
supply a way of a synchronous execution
of some code and we do that with a
callback so the problem here is that
once you reach a certain level of the
side of your code and the certain level
of callbacks they start to get annoying
right so you have a function that as a
callback takes another function and that
has also callbacks and they have error
message error handling and you have
multiple levels of callbacks and you end
up with a gigantic function that is not
manageable anymore
right so we would like to in this
session to devise an ad hoc like kind of
simple solution how to maybe make it
better and at the same time we'll try to
use the concept of monad and to kind of
bring those two together so what we have
here is a synchronous code that will run
someone sometime in the future and
obviously first thing would you do with
an unknown concept in Java you devise a
type right you could devise a class to
represent this thing so luckily we have
a future class in Java and basically it
represents the result of a synchronous
computation and it has an interface
that's really simple so you can either
check if it's done or blocking Li get
the result and your current thread will
block until the computation is finished
which is good but the question is can we
do better we can do and we will do in
this session and to use that we will
obviously employ monads so sure there
are
this is a definition of a bonnet in
Haskell so how many of you are familiar
with the syntax so yeah we won't go into
details but here is just a definition
you are not supposed to understand what
it says just note that it's kind of
short and really concise right so
hopefully we will manage to recreate
something like that in Java in the
remaining 15 minutes so but this
definition is not enough we want to
first understand the concept right and
go from if we want to go through the
theoretical part into sorry into the
actual code then we reach this famous
line here so this is a definition of a
monad maybe not the best one but it's
pretty accurate so a monit is it just a
moderate of in the category of endo
functors with product times replaced the
composition and it's not really easy to
understand so if you if you understand
this and you know how to use this then
probably this session wouldn't give you
any any additional the knowledge just an
opinion how to express smallness to
somebody who's not familiar with them
but the thing is this is kind of complex
and the life shows us that actually it
shouldn't be that context so everybody
should be able to understand the news
monads or deny the code and yeah so this
is it so now who has any idea what
immunity is and who has any intuition
about Monat or a metaphor for monitors
who have heard any metaphors about
monads whatever so not many of you
so this pictures here represent the
things that people usually correspond
moniz to so Amanat is it like
or a month is like a number of elephants
chained together trunk to tail or a
burrito and those are really good things
and it's really important then when you
have a complex concept to have a matter
of that but it still doesn't help us do
anything useful so we will combine those
three things and we devise a common
common things that that are important to
us to understand how to devise the type
of a monad in Java because we need some
class to actually provide an
implementation so the intuition is that
a Monat is something that will wrap
things right you can put something in
the box or inside of your burrito it
doesn't work with elephants that well
but the second thing a beloved Manas is
that it will be used to chain functions
about and on those things that would
before wrapped so that is that is all
that mana does it just wraps things and
changed functions kind of simple and
kinda represents the short haskell
definition of hamona
type lass so Amanat is a type and those
three things right so when when I say
type a word class so actually Moana is
kind of type class which is a type that
can't create classes for you so if you
supply additional things it will define
a class kind of like when you
parameterize a list with some generic
arguments it will also kind of list
generic and non-generic non parameterize
list is a tie price as well and you
parameterize that with something and you
get the actual class like a list of
array list of integers or something like
that but differentiation differentiating
between the type classes and classes and
types is also more like a theoretical
exercise and the road to type theory and
really deep pressures to every
functional
programming efficient other things so
will not go there
we'll just take those two intuitions
what am on that should do and we'll
device a plane Java interface so the
wrapping the wrapping functionality of a
monad is usually referred by the name
either return or peer and the contract
for that would be really easy so you
will take an instance of thumb of evallo
you will take some valor and you apply
this pure function to that function
called pure and you will get an instance
of a monad actually an instance of an
instance of a monad but what you what we
want to say here is that that would be
just a constructor where a factor method
right you will get values from somewhere
and you will wrap them in our own
implementation of a given monad so how
would you translate this in English
description into Java just pretty simple
we don't have the implementation so
Vista will go with an interface right so
we declare an interface of a monad and
we now have a first abstract method that
we want to provide later so called pure
it takes a value of type V and it
returns you a mona that will wrap the
value of v quite simple right and will
almost have there because we had only
two functional requirements for a monad
so now we have to go into chaining thing
so the chain chaining of the function
will be called bind word this Haskell e
operator but we'll call it bind and the
contract for that is that it will take
one moment that wrapped something's a
thing about a of a low a and it will
take a function from this type a into
Monat wrapping something B and it will
return this monad be
this should be still clear right
who's with me yet good so if we take
this bind in this definition into and
try to insert into the interface that we
have already so we'll have a second
method in that interface so we have the
pure that was previously available and
now I have bind and the bind will
operate on the monad because that's an
instance method so the first parameter
that it should take like a moment of
type of wrapping something will be this
and it will take a function from the
valley that this mona traps into a
moment R and it will return the Monett
of our so now we kind of declared all
our requirements in the interface right
so it's kind of no simple enough and we
can start trying to devise code that
will solve the problem remember the
chaining callbacks leading into an
unmanageable code and we will try to
solve that problem employing this
interface to figure out like where
Mona's can help us in in the real world
so we will devise a class promise that
will also represent the result of a
synchronous computation and it will be
kind of like future and in fact it will
extend future at some point but it will
support chaining functions using the
bind method right so first we'll declare
something that you can do with the
promise so how many of you know how how
future works so if there is a field to
hold the result and when you get the
result it gets set into the future field
and then you can when you when you
called gap it will return you the value
of that so we'll need a functionality to
set the result into our new promise
object so we'll we'll be able to invoke
this promise with an exception that will
correspond to the case when the
functional the assing computation threw
an exception we can invoke this promise
and basically set the Valor into it into
the field for later consumption using
the invoke and we will be able to redeem
to declare an on redeem actions which
isn't essentially like a callback which
is a callback we can supply a promise
with a callback that will be executed
when the value is set so we have the
same trauma space now so we can
introduce an Earthling computation into
our class so the exact implementation of
those are not really important to
understand but the setting is that we
can represent as in computation and we
can finish that computation and we can
supply callbacks that pretty much
defines the problem that it is now we
want to add the Monat interface methods
here to make a code more elegant so
first first thing was pure and it's kind
of really simple so we get a value of
the type that we want to wrap and we
create a new promise object and what we
do we just invoke this promise with this
fellow basically making this value V
available for consumption through the
promise right so we just we don't do any
computation we don't do anything we just
supply the result promised to to the
thread that wait and we just put the
value in so whenever somebody will try
to access the result of this computation
it's readily available in there that's
it and the second so purists
implementation is kind of super
straightforward and then it comes bind
and bind is a little bit complicated
and we'll spend some time on this so
beware so first we create well we have a
promise which is this and we will use
that and first of all we create the
result object which is also promised and
then we register a callback to the to
the promise that is available so when
the this computation will finish the
computation that this instance
represents the callback will get called
called
and we can apply the function that was
given as a parameter to the result of
that computation and that computation
will give us a new promise of Type R and
when that promise will redeem it will
set the result into the result from it
that was given before and now half of
your confuse but the thing is so we we
do straight for things so we have an
instance of a promise and we have a
function so we just straightforwardly
try to obtain the value the function is
from type V into something so we first
need to apply a value of V which also
only can go from the instance of this
promise so we use that and unredeemed
obtain this value of V then we apply
this function to we getting the result
of promise R but we kind of just return
that because we are in a callback so we
create a new promise as a placeholder
and kind of substitute the result into
that the the code here kind of follows
really the types that are given in the
signature and it looks like that so who
understands what is happening is this
code approximately
so if if you understand that we have a
promise that will deliver us a value of
e and then at some point of time in the
future
we will apply the function and swap some
promises and return the promise of the
correct result of the correct type that
we want then your understanding is
pretty much on point and now we'll gonna
cheat so the next thing that we still
will do which is was not in the contract
of the mana interface right so Monat was
only to wrap things and chain functions
and we just did that and now we want to
do something that is not any contract of
mana and want to get the valley out of
the torus right so with just pure and
bind functions we can create a promise
and it will have some valor and we can
chain functions but we'll still be all
the results are promise right so we'll
still have this result of I think
computation and we can chain more
functions into that and do something
useful but we will always have only
promise types and we never can actually
reach to the valley that's why we
introduced this get method which really
schematically introduced here but what
it does essentially it waits until the
promise is redeemed and returns the
result that was stored in the field of
that promise so this result is actually
filled in the promise class I'll give a
link to the code later if you want to
try to play around and see how it goes
but yeah so this is super
straightforward as well we just want to
discharge all the promises and kind of
break them and obtain the internal
valleys still good so now I have an
example really simple so imagine we have
a way to submit an essence computation
to obtain the initial promise
because that's why we wanted promised
essentially so we'll get a promise P
that just returns us a string which we
could do with a pure function as well
but here we actually submit somewhere to
create an as in computation and then we
create a promise result which is created
we bind the function from string into
integer into promise of an integer into
this function right so P bind takes a
function from string and it returns a
promise of an integer and how come we
obtain that promise is really
straightforward we just create an
integer object from the string using the
hash code the actual and finish is not
important the idea is that we get the
type of the integer and then we wrap
that in a into a promise because we
super really wanted that promise that
much to satisfy our type signatures so
and that actually works and that can
show how to how to use a bind function
and peel function from the Java
interface here is a check point so to
this point of time we talked a bit about
like introduction and then we devised a
promise class that represents and I
think if result of as in computation and
it will be able to handle some Valis and
it will be able to chain functions to
operate on the values that are inside of
a promise right so that's it we have a
code that is supposedly works you you've
seen just the pieces of that but if you
change everything together put it in a
class it kind of compiles which means
that most probably it works
in some languages but the thing is like
really what just happened so we started
with the concept of omona that is
described by an intuition and that the
intuition is valid because all those
blog posts about like chaining elephants
they do not lie to you and we derived
some code that doesn't have any
connection to do that to the actual
definition of what Amanat is so like
anybody could write that code right like
you don't have to create a promise
object or promise class you don't have
to know anything about monads that is
just a pure Java code that any of us
could write some of us could write
better so the thing is here is the line
between the Monat in green as in concept
as a big concept and what we create it
actually is an instance of the monad so
we provide an image then provided an
implementation of a moral interface and
it satisfies that interface so that
means that you can use that promise as a
monad but it doesn't describe the whole
concept right we could provide a
different implementation of that
interface and it also will be a monad
and it will do something else and it
will represent actually something else
so for example if we want kind of like a
list which will be our box and we will
want to chain function to transform that
list name two different lists that will
also be Mona
implement that using the interface that
you created but it doesn't mean that
either of those things will be like a
monitor as a type class or as an
algebraic type right so there is a clear
distinction between the code that we
just wrote that kind of is a monad and
and the actual concept of monitor which
is really important to understand
but the thing is why do we need the
moment in general right so we just wrote
code and supposedly it works and
supposedly we can bind functions and
avoid like callbacks because we can just
say okay now transforms this result and
transforms this result and transform and
the end we go like okay
give me the Valor and it that works but
we still want to understand the general
general concept and how to get any
benefit from that so what we can derive
from that when we have something common
or when we have some definitions that is
really as general as we provide it like
just the interface to wrap things we can
device than generic functions that will
operate in the same way it kind of
produced results for you on any monad
right so for example what do we do so we
can have a function of sequence which
can take several minutes let's say
several instances of a promise moment
and combine them into into into one
promise that will give us a list of
those result individual results and that
function in theory can operate on a
mullet that is satisfying the interface
or we can zip links together and the one
catch here is that implementing that in
Java under the permit rights for
Murphy's when we actually have to supply
the generics argument to every function
is really not that easy but in theory we
we can have functions that will work on
all of them and the old functions will
sit and be reused right so some are
languages obviously have it easier than
others so to devise the generic function
here like like a sequence or something
we will need to obtain the
individual values from the Mart right so
we introduce that get masses as a like
hackish work around about just to get
the valise and actually use the program
somehow but essentially that is also
important to provide a generic
functionality that works for all the
models so some languages kind of
declares the explicit get because you
can just reuse the valley without
declaring that we are not so lucky in
Monat in Java so we will actually go
forward and declare the gap functions
here as well so this is kind of
unorthodox I would say I have never seen
anybody declaring a moment interface
with a method to actually obtain the
value from the model and you will not
find that in a in a type class theory in
a theoretical work of that but it's
really useful so and if it's useful we
should use that in our code to make it
to make it simpler right so we'll
declare out the gap luckily we'll
already have the implementation of the
gate in the promise so we're all good to
go so we have a promise in in a moment
Amanat called promise there is another
catch so obviously not any
implementation of that interface would
deserve our attention right we can write
like complex crazy things ER and we'll
be like oh so I satisfied that type
signatures of that interface then
definitely I mean Mona and all those
great functions that should work in all
models will work for me right that is
not true here comes the loss of a monad
so in a in a Haskell notation to
describe like this very concise right as
usual things in Haskell will come to the
Java analog definitions in a second just
for those who doesn't know how to read
Haskell this says that Amanat cannot
harm
human or a low Bates what was that or
through inaction allow a human to be
come to harm and this red line means
something else but in fact that is not
what happens
so those three lows are left identity
which should just say that our pure and
bind combination work as expected so we
the operator the equivalents operator
here will be defined like in a in a in a
moment but essentially we want to be
able to wraps the Valor in the mana that
we have and bind some function and have
a result which is equivalent if we just
would apply the function to the pallet
if we would get something else then the
whole concept kind of breaks down and it
doesn't satisfy any logical terms so if
the left identities the checks that the
bind behaves correctly the right
identity checks that pure behaves
correctly so if we have a monad and we
just pass a function from the Bala into
MMO knots itself which is pure then we
actually get the Valor the mana itself
obviously in Java that would be like a
different object but that's why we have
this equivalence operator here and the
third rule which had like it the kind of
longish haskell string as a definition
is actually associativity so what that
says that if we in a sequence bind two
functions together then the result of
that would be indistinguishable or
equivalent to the actually applying
there and binding two functions together
the first and then supplying it into a
monad so on the left this is kind of a
longer definition so identities very
easy were they easy yet they were so
this is a bit more complex so on the
Left we have a monolith m and two
functions F and G and we
one so it will reduce us a Monat of
different type and we bind G and on the
right we first create a function that
will apply the F and bind the G to the
result kind of we go from the right hand
side and then we bind this result
function into M so essentially what we
what what what that means is that if we
apply F and then G to the value stored
in the Monat it shouldn't matter if we
do F and G or if we create a function
that does that and bind so this is
important so you actually can chain
things properly so now the thing is we
have the laws but we have to interpret
them somehow and they feature this
equality equivalence operator which is
complex and not defined yet so some
languages as usual have it easy so e if
you if your language of choice features
like referential transparency in partial
application then you can just say ok it
looks the same and it should be
equivalent and you can just use the
normal equality but four platforms that
are more like JVM where the referential
transparency is not available and
actually if you apply a function to the
same valid why's it doesn't mean that
you get the same result that you can
compare it just by comparing with a
usual double equal sign operator and we
have the equals and hashcode and you
know that if you implement those
incorrectly then you'll get wrong
results so for equality in Java and as
this equivalence let's let's just
distract ourselves and we'll say that
the side effects of those things are
kind of similar we don't want one
operation like binding F and then G
complete normally and binding the
complex functions that we devised blow
up the universe so side effects should
be kind of the same and
the thing is if we try to get the valley
from the Mona that will result all by
the sides then we'll see the same values
so we don't care if the model itself is
kind of equal or the comparison is
implemented correctly we just want to
observe and let touch values that are
the same which essentially defines the
contract for any for most of the
sensible programs right you want it to
behave the way that you understand it
behaves not sometimes you want it to be
also probably correct but usually that's
not that that a big issue so the same
values side effects are kind of similar
let's try on the left height entity so
you remember you remember hopefully you
remember the definition of the left
identity law who does that
so that was and that described in the
short here so if we take the and wrap
the value of Val in the pure and bind
the function f and then get everything
that gate is missing then it's kind of
the same as if we just apply the valley
and obtain the Mona just by calling that
function okay and surprisingly this
works on this simple example so now we
have the code that compiles and you have
tests that path so it must be correct
right so and indeed it is correct and
it's kind of simple so if you devise an
instance of a monad do have a question
yeah yeah the gate is missing there very
observant so no thank you
so yeah so when you device an instance
of a monad and you're like oh I have a
problem I know else oh well I'll solve
it using monads and now we have more
problems that initially in your device
in the movement engine you should at
least check for the loss that it kind of
represent the actual and it complies
with this informal definition of a monad
the right identity is kind of the same
it just does the way in different order
so we obtained the promise of this valid
by calling pure and the bind pure again
and we want to see the same Ballas so
this is where as this equality check
that it kind of fuzzy as we defined
comes in place so if we if we check the
actual promises as we would do like but
just looking at code because the objects
that are returned have promises and we
like oh I want those to be equal then it
won't happen but the Vala is that they
wrap are actually the same so as that's
what's important so it works so you
should always try to device the laws and
check if your implementation satisfies
those and if it does then you're like
okay now I can use all those generic
functions that smart people wrote for me
for the jama'at and you're like good to
go about smart people so if you are
really excited about like how to solve
this callback problem and use the code
of this promise somewhere then don't
smart people in the JDK team devised
exactly not exactly the same but the the
class that actually does this thing and
represent the result of a synchronous
computation that supports chaining
functions and supports dispatching the
new functions into in the async mode so
that's completely future and that is an
example of component in Java 8 and the
code is super readable and
the bind that we called bind is called
Dan apply which makes sense a lot
it describes exactly what happens when
the first computation finishes then you
apply the next function so this is then
apply and then apply a sync is a
definition of a bind for the computable
completable future so don't use the
whatever handcrafted promise that we
looked before go for computable future
and it's a nice example of the code that
you want to look at if you want to
understand how magnetic code should
behave another an example of a monad in
Java 8 I think is represented by this
picture quite well pudding who thinks
that they know what class I'm talking
about okay maybe that's my East yeah
yeah that shredder is cat so it
describes a mental experiment where the
cat is simultaneously dead in life in a
box until you look into that so and
obviously I'm talking about optional
when when the optional class gives you
an ability to avoid or with the constant
null checks in your application so
basically you can wrap the value get the
Valor and you can create an instance of
an optional class which can help either
valor or null and you can operate on
that without actually checking for now
itself because in a monadic fashion you
will just supply functions to transform
that value and it will make use of null
on non null itself so the optional pure
is really simple right so if let's
revise it once again the pure was that
we want to take the value and wrap it
and return the monad and this is really
simple so if we have an actual valor
if we call off nullable and provider
valor it will check for the null and
return either an instance that
represents an active optional or the
actual optional holding this valid this
is super straightforward right and then
the bind for the optional is a flat map
how do you know that this represents the
bind and not something else so there is
interesting question so I have a flat
map in the optional class and I have an
actual map and why do I do whether they
say that flat map is a bind not that
usual map yeah because the bind type
signature said that it takes a function
from the valley into monad so the flat
map takes a function from T into an
optional of the result Vala and the map
takes just the function from valley into
valley it also returns an optional in
the end but it doesn't satisfy the bind
interface contract so this is the second
example of Mona's enjoy it and I will I
will recommend paying some attention to
that if you if you have projects that
will move to Joe Wade or start projects
and Joe it make a heavy use of optional
it's quite good it eliminates quite a
lot of boilerplate and you will be fancy
will be using monadic solutions in your
projects projects to solve real problems
so now we have just a little bit of time
so and I want to start concluding things
so why what I wanted to say during this
whole presentation is that always it's
always useful to understand what are you
doing
and it's actually like understand what
he doing is is essential not to
embarrass yourself were not not not not
not to break a prog project so the most
important thing from this session that I
wanted want you to remember is that the
Monat as a type class as an algebraic
concept is really interesting useful but
if we just want to use a magnetic
classes in our projects which we most
definitely want to do instead of what we
also want to know the type theory but we
mostly focused on the projects so
separating those two concepts and
understand me the part of it to build
that small bridge of the rivers that you
has to cross that you have to cross is
important and it is much easier to
understand than diving into this type
theory so the last checkpoint what we
did during this presentation we started
with a problem of having too many
callbacks for the assing computation and
we used the intuition about Mona to
devise a monadic solution we provided
the interface with that that featured
two methods initially three and just to
be easily more easily useful so we have
a pure that wraps the value will have
bind that allows you to transform the
valley in the monad and we kind of
actually have get to observe the valley
back which is really cool note that you
don't have to use that yet so for
example just a random shot at the moment
so if I have a server that serves my
requests and at some point of time I
want to go a sink and just operate on
those like completely futures or
something at some point of time I can
just supply a function that will give
this Vala and write it into the request
entry
fons so and then the disregard the
resulting promise whatsoever so I don't
have to actually exit the monadic code
but sometimes it's just easier to do so
you should pick your flavor of the
solution so after that that we devised
the code we looked at the laws that any
well behaved more mana should satisfy
and those were identities that means
that functions will work correctly and
associative 'ti and we looked at the
computable future and optional as an
example so for mo not in Java 8 which
means that actually monadic code is you
can write monadic code using Java 8 so
Java is a super functional language
right so that's it we have I think like
eight minutes for questions before we go
into that and health of you go out I
just want to ask send feedback will
you'll definitely receive some forums so
as I mentioned before I'm studying at
the University and I'm really hoping
that this experience will help me to
pass one public speaking assignment a
little bit less today during those cold
winters so if you want to talk find me
and we have time for questions
please
so the question is the initial contract
of the monnet offered has two methods
just pure and bind right those should be
enough to satisfy them Damona and create
Amanat why do we need a get method and
what would be an example of a monad that
does not benefit from from the gap
method that's a good question so I
wouldn't say that I can provide an
example of that so having access to more
things make it it makes it more flexible
definitely so you can totally write your
monadic code without that gap method
it just depends on what you want to do
so if you don't want to leave the
monadic code whatsoever and you don't
want to use the functionality of those
generic methods that should work for
anymore that where you actually have to
grab the valet out of the mona somehow
and that's why we device that get then
you're good to go without that optional
could be without get if you are ready to
to be fully engaged into that
optionality so once you go optional you
wouldn't be able to actually obtain the
Valor so the implementation of the bind
method will sit in the in the let's say
optional so implementation of the
flatmap there sits in optional so it can
access the field directly so you don't
need to to declare the gap in the
interface to to get that so if you are
willing to to do this like kind of
stacking them monadic code till the end
of the processing get is not necessary
please so the question is the Haskell
has a syntactic sugar for using Mona's
using do syntax which basically you
don't specify the bindings the bind
method altogether like if you want to
chain several things you just say ok now
I'm going into the bind mode and here
are the functions that I want
sequentially to bind it into this monad
and would it be possible to implement
something that in Java that's a good
question so I would say with the short
answer is no the long answer it depends
so obviously if we saw out changing the
language constructs you wouldn't be able
to introduce a syntactic sugar into Java
right so if you work on the like
application level you wouldn't like just
throw in library that does that for you
so if you want to change the how JVM
operates and how Java like language
specification dictates what is possible
or just you want to hack your open JDK
version that accepts some second
syntactic sugar for that then I would
say you probably can do that unless that
was a really tricky question
so if if if the intended solution is to
create to have a method that can bind
several functions one into each other
then yeah it might be possible I'm not
sure if that will work with words
because you want your functions to be
parameterized that means if you go
through different types like a function
that creates a like for example a
promise of integer and then the promise
of string and promise of something else
then either you will lose generics and
just go with pure like promise of object
then it might work with with with very
herbs otherwise you'll have like a bunch
of methods for all kinds of combinations
so yeah it's kind of possible but I
don't think that is that useful
any more questions
okay then thanks a lot</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>