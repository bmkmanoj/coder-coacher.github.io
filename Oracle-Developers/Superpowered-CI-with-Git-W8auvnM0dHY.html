<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Superpowered CI with Git | Coder Coacher - Coaching Coders</title><meta content="Superpowered CI with Git - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Superpowered CI with Git</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/W8auvnM0dHY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so officially good morning my name is
sarah i'm on the dev tools team at
atlassian we make a whole bunch of
different collaboration and software
development tools like JIRA and
confluence and stash and bamboo and
HipChat and clover and bitbucket and
sorcery and fish eye and crucible and
that probably is about it in what okay I
thought I missed one you won't hear a
ton about the products today I try to
keep my talks like fairly tool agnostic
I probably will in fact I promise I will
toss some screenshots of bamboo at you
but what I'm really here to focus on
today is doing CI and using it and
sharing with you some of the things that
our teams have learned over the years a
past couple of years about working with
those two technologies in combination it
is really exciting to see probably close
to a hundred people coming in to learn
about CI and get I think that's awesome
I was a test engineer in my former life
so any time that people show an interest
in code quality and continuous
integration I get kind of a warm fuzzy
feeling so i'll start off today by
talking about why i think it is
particularly advantageous in a team
setting and then i'll go through and as
part of that i'll go through the
branching model that our atlassian teams
use which is actually really effective
with CI at least i think so or we think
so because we keep using it and then
i'll get in to see I specific stuff
starting with some tips around how to
get your CI server and your repository
to talk to each other in sort of an
optimal manner and then we'll go into
some feature branching stuff and then
last i'm going to introduce some get
hooks which i think are really effective
in kind of shoring up your CI system and
i'm giving your your code lines a little
bit of extra protection from human error
and just stupidity all right so why get
in the first place I mean we all know
the benefits of making software as a
team you get different backgrounds
different experiences different ways of
thinking from different people and when
you bring all those things to bear on
whatever problem you're trying to solve
you generally end
with better software right it's it tends
to be more maintainable in the long run
it tends to be of higher quality it
oftentimes will serve the user better
because you just have all these
different perspectives coming in to you
know coming in on the problem but we
also know that developing on a team can
be really really messy I mean you're
trying to understand what pieces
everyone is working on you're trying to
make sure that those pieces don't
conflict with each other you're trying
to find bugs before your customers do
you're trying to keep all your
stakeholders connected with the project
up to date on what the heck is going on
and then on top of that you're trying to
future-proof your code so that six
months down the road you don't find that
you've coded yourself into a rabbit hole
and then you're like oh crap I got to
start over so it's messy but it turns
out that get I think is particularly
advantageous to working in a team
setting and a primary reason there's a
few but the reason that I'm going to
focus on is that get makes it really
easy to divide up pieces of your project
and do kind of a divide and conquer
thing so you can isolate different
pieces of in progress work on
development branches usually referred to
as feature branches and so in that way
you don't get developers who are sort of
stepping all over each other and causing
conflicts or or creating bottlenecks or
blockages or hope perhaps blocking a
release even so developers generally
work do the in-progress work down on a
feature branch and and then keep working
there until it's implemented and the
code has been proven safe to merge
upstream to the shared branches and
proven safe is kind of where CI comes in
actually it's exactly where CI comes in
now clearly svn and other traditional
version control systems do offer the
ability to branch every VCS does that
but let's sidestep for a moment and talk
about branchings evil twin which is
called the merge so traditional VCS is
like svn it's simply not that great at
tracking different versions of a file
that live on different branches and I
don't I won't get into a ton of
technical particulars on this but
the upshot is that when it comes time to
merge svn for example has to stop and
ask you for directions a lot so we've
probably all had this experience of
sitting there you know you're you're at
your your terminal or you've got your
SVN client up in front of you you click
merge and it goes along and then you're
just about to stand up for a coffee cup
of coffee and you get this pop-up that
says I don't know what to do do you want
this line in the final version of the
file or that line this chunk that chunk
and then you're like okay yeah that one
that one mine yours clobber yeah okay so
the fact that so much human interaction
is required at merge time tends to drive
teams to institute code freezes so that
whoever is performing the merge doesn't
get derailed by new code changes coming
in on one of the branches that they're
working with and code freezes are very
expensive it's pretty unproductive time
so then in an effort to minimize code
phrases teams often discourage branching
entirely by putting sort of heavy-handed
administrative controls around who can
create branches again the idea is to
create as few branches as possible so
then stemming from that it's this whole
like chain reaction thing here right so
stemming from heavy-handed
administrative controls around branching
you end up putting all of it just piling
all of your change onto trunk or main or
whatever your primary code line is every
commit goes there and that tends to make
that code line quite unstable it's
difficult to find a point where all of
the tests are clean and everything is
impeding doom you've got everything on
there that you want to release and
nothing that you don't want to release
and all the tests are clean so it's hard
to find a release point or or a point
where you can safely make like a stable
version branch it's even hard to make
sense of why tests are failing if you've
got 20 different test failures or even
just one different one test failure and
you've got 20 different commits from 20
different people that had come into that
build it takes it's a pain in the butt
to sort through it all but that is not
the case with git git is actually really
good at tracking different versions of a
file that lives on different branches
and
get always knows what the common
ancestor of those two versions of the
file looks like so it can use this sort
of like a triangulation technique it's
basically like a built-in GPS that helps
get navigate merges on its own with very
little interaction required from humans
so thanks to that merging and get and
and in material for that matter it's a
very trivial operation from the
developers perspective which means that
you are free to exploit the full power
of branch and merge workflows which are
indeed very powerful and you can exploit
them in a way that like practically
speaking you just wouldn't with svn so
every team at atlassian is now using git
and we are really bullish on feature
branches it's so bullish in fact that we
have taken to creating a feature branch
for every single issue that we work on
doesn't matter if it's a bug fix a user
story a technical task if there's if
it's tracked in JIRA and there's going
to be code committed for it committed
for it and if there's going to be code
committed it better be tracked in JIRA
and it gets its own branch so just in
the JIRA codebase alone speaking of we
have 775 active branches now granted
JIRA is a 12 13 year old product and
it's composed of many many repositories
with probably close to 100 developers
working on it but still that's a big
number so I put it up there to just
demonstrate that we are really serious
about this branching thing we love it
and this all might sound like a ton of
overhead but it's actually not with the
right tooling and and the right branch
and even more important than the tooling
with the right branch and merge workflow
you can go pretty nuts and not feel any
pain from it and all of this this
branching and merging is actually
helping us deliver faster than ever
before because by isolating all that in
progress work down on feature branches
were able to keep our master code lines
and our stable version branches in a
state where they're clean we can release
from them we can cut new development
branches from them very safely and
ultimately we can ship stuff out to our
customers faster
so here's the workflow that we use this
is this is not a dumbed-down it is what
i call the simplest workflow but it's
not a dumbed down version of the
workflow the branching workflow that we
use this is the real deal you may choose
to make branches at like more like the
epic level where it's like a collection
of user stories or a collection of
issues like I said we do we go the issue
route but either way the the workflow
looks about the same we do really
believe in the branch / issue model
though we've had a ton of success with
it and our tools do all manner of
magical things around that which you
know you can chat me up later about I
want to call out the naming convention
that we use let's see if my laser works
hey laser so this bit here dev dash 30
or dev 45 and gosh that looks an awful
lot like a JIRA issue key and that's
exactly what it is so it doesn't matter
if you're using JIRA or some other issue
tracker it's it's pretty it's a pretty
nice thing to include that unique key in
your branch name because that makes it
crystal clear what's being worked on
there's no confusion among developers
and if you've got you know a product
owner or some other stakeholder or some
someone outside your team who's looking
at your repository they can see oh
there's a feature branch for dev 30
awesome I know that that is actively
being worked on there is code being
committed to that and then later on when
it gets merged into master or whatever
upstream branch its destined for that
same external stakeholder can be like
ahhh i know that dev 45 is done it's
gone through a pull request it's met the
definition of done it's been tested
killer i'm ready to release that puppy
right so that's the naming convention so
feature branches as you can see here are
generally made from master sometimes we
make a branch off of a stable version
branch but usually it's least for new
development it's always made off of
master and then when all the tests are
clean as indicated by these little
colored dots with the nice little
circular arrows around them indicating
that that's where CI is run when all the
tests are clean then the branch is
merged back
up and the network can be released so
the point that I really wanted to make
here and the reason that I bothered to
show this is that get makes it really
easy to keep unproven code off of master
and CI makes it really easy to prove out
that code while it's still isolated down
on a future branch so with that in mind
let's get down to the CI stuff and I'm
going to start with your repository
which is kind of where it all begins so
one of the things that you often hear
about get is that you should avoid
putting large files into your repository
so this could be things like pre-built
binaries image libraries any kind of
like pre-built artifact and because once
you add a file to your repository it is
always going to be there in the repo
history so even if it's even if you
later delete it and it's not that that
big file isn't in sort of the current
snapshot of your repo it's still there
in the history and that matters because
when you clone a repository into your
local workstation get clones the entire
repo history by default so that huge
heavy file comes along with it so it's
good practice in general to keep them
out of there but it's really important I
think if you are doing CI and the reason
for that is that the first thing that
your CI system is going to do at the top
of the build or one of the first things
anyway is to in fact clone a repository
into the current working build directory
so if your repo is bloated with all
these huge artifacts it's going to take
up disk space on your CI server boo and
it's going to make your you know that
that cloning operation is going to make
it take longer which then just like
bloats out your whole build duration
also boo but what if your bill depends
on binaries from other project or some
kind of large artifact I mean this is a
really common situation and it probably
always will be so the trick is just
handling it effectively and what we
found is that an external swords storage
system like Nexus or archive ax or
artifactory or even just well I don't
know you got a spare Tower sitting
under your desktop you could set that up
as a temporary file service and some
place besides your repository to to
store artifacts if you do a lot of
artifacts that you need to pull into
your build like a full-on archiving
system like artifactory or Nexus might
be the best choice for you and then you
can just pull those into your build at
the top just the same way that you would
pull in third party dependencies via
maven or Gradle so you might be thinking
oh well actually what I'll do is I'll
just instead of putting making it part
of my build I'll just sync my artifacts
to the build server nightly and then I
only have to pull them across disk at
build time instead of pulling them
across an EPS network super fast and
that's true it is much faster to
transfer across disk than it is to
transfer across a network but I
recommend doing this nonetheless because
in between your nightly sinks you're
going to end up building against stale
versions of your artifacts especially so
this is in a special wait I recommend
this against this especially strongly if
your artifacts change frequently because
you don't want to build against Dale
artifacts that basically renders your
build useless right and you wouldn't
even know that it was useless until the
next day when you built again and you're
like oh I'm I'm now discovering what I
should have discovered 24 hours ago
which is that my code and this this
artifact don't don't play well together
so and then besides that developers are
going to need those artifacts to do
builds on their local workstations
anyways so you may as well just set it
up as part of your build configs or your
script or whatever so that it's so that
that pulling in those artifacts into the
build is available to everyone and it's
done the same way each time so the
consistency factor is really important
too because you don't want to end up
with the like builds on my machine
problem which you know is great but
we're not shipping your machine alright
so that's artifacts let's let's keep
talking about cloning so every time your
build runs as I just mentioned your
build server clones the repo
into the current build directory and as
I also mentioned before when get clones
are repo'd in clothes it closed the
entire repo history by default so even
if you don't have like large files
tracked in your repo this operation is
naturally going to take longer and
longer over time as your repo builds up
more and more history it's not that sort
of thing that you notice day-to-day but
like if you look back over you know
months or a year you would notice an
increase in build time unless you use
shallow cloning for your CI so with
shallow clones only the current snapshot
of your repository is cloned in or
copied in rather so this can be pretty
useful for reducing build times
especially if you have a repository
that's been around a long time and
you've got you know umpteen years of
history worked in there but sometimes
your build Maybrick there may be
situations where your build requires the
full history and won a kind of goofy
thing about I don't know if it's goofy a
thing about get is that when you are
pushing from a local a local copy or
sorry a local clone of the repository
back to the repository of record or you
know this is referred to as origin a lot
and get so when you're pushing changes
back to origin get once the wants to
have the full repository history
available in that that local clone that
you're pushing from as I've get one dot
nine and I believe the current version
is two dot one right now but as I've get
19 they do support making simple like
pushing simple changes back to the
origin repo without having the full
history in the the local the local copy
but if you're doing anything more than
say using the maven release plugin which
will you know check out your palm update
the version check it sorry check out is
a still him in / force mode it will it
will commit a new it will write a new
version and commit that and push that
back to the repository on your behalf so
that's like happening all in the course
of your build so a simple change like
that might be just fine
but if you're doing anything that's
pushing changes back in an automated way
that's much more sophisticated than that
shallow clones probably won't be
compatible with what you're doing it
will probably want the full repo history
there so if that's the case instead of
doing a shallow clone you can catch the
repository on your build server like
clone the full thing but then cash it on
your build server instead ah I had a
good joke here and I sort of messed up
my line anyway you cash it and where do
you cash it on your agents I'm a big fan
of the Americans I'm so waiting for
season two to come out on Netflix so
this is the first of many caveats I'm
going to throw at you today and because
see I is a goofy caveat filled world so
cashing your repo on the build agents
really only benefits you if you are
using persistent build agents so if you
if you are using like ec2 or cloud
foundry or your own private cloud to
spin up and tear down build agents every
time a build runs clearly caching isn't
going to get you anywhere because you've
got a blank slate to come into every
time anyway okay so shallow cloning and
repository caching I think that's all I
wanted to say about that they're pretty
slick ways to kind of manage your build
time and also to to take a little bit of
load off your CI server as well now you
can do these things with any system that
you're using but we we think that
they're really handy so if you're using
bamboo or if you are think about
thinking about trying bamboo we set it
up so that you don't have to go through
any sort of gymnastics on your build
server it's just these two check box
boxes down here so it can really be that
easy it maybe not that much more
complicated on the system you're using
now so i encourage you on what monday i
guess when you get back to your office
add this to your list of things to play
with all right let's get down to the
future branching stuff so whether you
make a feature branch for each
like we do or if you make them at kind
of the epic level you are going to end
up with a lot of active branches in your
repo maybe 775 of them perhaps and as
people who take our craft seriously of
course we want those feature branches to
be as clean as possible so let's talk
about CI on the feature branch so if
you're already working with get you
probably also know that feature branches
tend to be fairly short-lived since we
do a branch for each issue our feature
branches tend to live like two or three
days like maybe as long as a week but
usually more like two or three days
nonetheless even though these are dinky
little short lived you know almost throw
away branches it is really important to
practice CI on the branch because if you
don't and if the first time you
integrate your work with everybody else
is is the first is when you merge up to
master you're going to be hit with all
kinds of nasty surprises you'll have a
big red broken build on master which
means that you can't release from that
point you can't create new dev branches
from that point and it's kind of an all
stopped all hands on deck fire drill to
clean it up and nobody likes that and it
sort of defeats the whole purpose of
using a branch and merge workflow in the
first place I think because like I think
the primary point of that whole exercise
is to keep master in a clean and
releasable and usable state so setting
this up the old-fashioned way to set up
CI on the branch is to make a clone of
your build configs for master and then
point those configs at your future
branch what a drag that sucks especially
if you got a lot of branches besides
that we're human and we forget things we
especially forget to do things that are
tedious oh I forgot to do the thing I
hate darn sound familiar so between the
tediousness and our tediousness driven
forgetfulness getting CI on to feature
branches the old fashioned way is pretty
painful the news fashion way is to get
your CI server to do it for you so if
you're using Jenkins and oh that's a
pole we didn't do audience poll who's
using Jenkins right on who's using
Hudson
one Hudson hold out I was a Hudson user
back in the day any bamboo users my
brothers awesome alright so for those of
you who are using Jenkins there is a
plug-in called the branch / build wait
sorry build / branch plugin like all
Jenkins plugins it's free so it does
exactly that it when it finds a new
branch in your repository it finds all
that then the configs that are pointed
at master clones them points them at the
new branch but I will hasten to point
out that that build / branch plugin is a
less robust copycat feature a copycat
that came on the scene about six months
after we built that exact function
functionality and more into bamboo so
jenkins users you're welcome either way
the pole the whole point really is to
spend less time configuring your builds
and more time coding which is what you
like to do anyway right so that's
getting feature branches under CI so
we're super stoked when we when we
started using this in bamboo but we've
discovered one little problem with all
this branch build stuff so we have
almost 500 developers I think about 500
and they each put changes to their
repost several times a day on their
branches mostly and so if each git
commit is getting built that's a lot of
builds and unless you can scale your CI
system instantly and infinitely your
build Q is just going to get backed up
so take for example just one of our
internal bamboo servers and we have
several it houses 935 different builds
and we plugged I think at last check 141
build agents into it they may have tried
to scale it up to like 150 or 160 by now
but 141 is the last number i got so
we've got all these all these build
eight hits on this on this bamboo
instance and we've used best practices
like artifact passing and test
parallelization to make sure that the
builds are a short and concise as
possible but still building every commit
on
every branch was clogging up the works
so we could just set up another bamboo
instance because hey it's free for us
and toss another 150 agents on it and
then take some time to transfer a bunch
the builds over to that new one but we
kind of felt like this was maybe just
kicking the can down the road a bit so
we kind of backed up and said well is
that even really what we want to be
doing and the answer was no not really
so what we found is that a good way to
balance testing rigor on the other on
the one hand with build resource
conservation on the other hand is to
make the builds on the feature branches
push button or manual like not manual in
the sense of like you're launching it at
the command line manual in the sense of
I go to my CI interface and I push the
button that says go so the feature
branches is where most of the change
activity is happening so this is our
biggest opportunity for resource
conservation and developers actually
find that it fits into their workflow
quite nicely they like the extra control
and the flexibility that that the push
button builds give them because
sometimes you know you make a commit and
you push it just almost to have a
bookmark in place that you can go back
to but you know full well that all kinds
of things are going to break so you know
it's kind of nice to not build that and
not have to wait for the build results
to just be able to push it go have lunch
play a little basketball come back make
another change and then build but for
critical branches like master and any of
our stable release branches like that
one v1 dot to it we decided that that
was really important to get feedback on
every commit and get it really quickly
so we kept the automated build triggers
on those branches these are branches
that we release directly from that we
use to make other feature branches and
and in theory right in theory because we
use this feature branching model the
only time code comes in to master or a
stable version branch is a merge commit
coming in so you know given that given
that it's this whole body of new work
coming into the branch we felt like it
yes that is absolutely critical to get
feedback on that right away and get it
every time so we kept the the automatic
triggers there this is what we found
works best for our teams and your teams
may push to their branches you know more
frequently or less frequently but you
know it's but hey you have options and
options are great so it solved one
problem the build q getting backed up
problem but another problem still
remained so since feature branches live
only a short time their bills are active
or need to be active for only a short
time so let's do the math again we've
got however many developers times all of
their short-lived branches and over the
course of a few months and certainly
over a few years that's going to tally
up to a whole lot of abandoned branches
and potentially a lot of abandoned build
configuration ever going to get built
again because there's no activity
happening on them it does nothing but
waste CPU cycles and just drag your
whole CI for servers performance down so
boo to that this is another thing that's
really easy to forget however so we can
automate that too I actually don't know
how you do it with Jenkins so that's
your homework for the week in bamboo you
you can simply did I have a screenshot
of this nope getting ahead of myself ok
so in bamboo when you set it up to to
manage your branch builds you can say ok
after two days or 20 days or 200 days of
inactivity on this branch just stop
paying attention so it's kind of nice to
have have that off of your mental plate
and then the another option is to just
move away from polling all together and
have your repository sort of proactively
call out to your CI system when it
receives a new change and that needs to
be built
so typically this is done by way of a
hook in your repo and as it happens we
recently added an integration between
bamboo and stash that makes the the hook
set up unnecessary any'stache users
stash everyone loves stash so once stash
and bamboo are linked on the back end
it's for all of you atlassian admins out
there i'm talking about app links once
they're linked on the back end the these
repository driven triggers just just
sort of work out of the box you just
select it Addison it's a drop down
option that you can select from with
with no hooks or special configs
required but again you can do this with
whatever tooling you're using it's it's
totally this is a process thing it's
totally tool agnostic the point is that
by doing it this way you'll never have
to worry about disabling branch builds
because the builds will simply stop
getting triggered when there's no longer
any change activity happening on the
branch so they just sort of self retire
and fade off into the sunset sort of
quietly so let's see we've covered a bit
quite a bit of ground already we've got
cloning repo caching triggers feature
branching okay we're kind of in the
middle of feature branching but I want
to switch gears a little bit at this
point I want to talk about a common
objection that you hear when you're
talking about CI and feature branching
and that's that that is that when you
are doing feature branching you're not
doing pure CI and that's totally true I
am not bothered by that I'm a CI
pragmatist more than I msci purist but
still it's true you don't have everyones
incremental changes sort of stewing
together on one branch which again is
the point right because it tends to make
that branch very unstable and really
hard to use da da but pure CI does carry
the advantage of knowing immediately
whether the change that I just pushed in
is going to conflict with the change
that you just pushed in so how do we get
the best of both worlds how do I get
immediate integration feedback or pretty
immediate integration feedback without
creating chaos on a critical code line
that everybody else needs to use so I'm
going to talk about three different
methods that various teams and developer
atlassian use and you can kind of like
try them out in mix-and-match this is
more homework so the first option is to
rebase your branch against master during
development so for those who are not
super familiar with get yet rebase it's
it resets the commits of origin for your
branch and then all of the the changes
that you've made on your branch since
you you since you made the branch are
replay it on top of that so it looks
kind of like this so running a CI build
against your rebased branch provides a
pretty accurate preview of how your
changes are going to play with what's
already on master when you merge
upstream so it's a good idea to rebase
once or maybe twice a day if you're
going to go this route for sure do it
right before you make that final merge
upstream when you've completed
implementation now caveat maybe caveat
number is this caveat number to rebase
is best for when you're the only one
working on your branch if you do this on
a shared branch it is going to mess up
everybody else's local copy and it's
going to fork force them to reconcile
their clones of the repository with the
the rebase pneus that you've just pushed
to the repository of record and they
will probably get very grumpy with you
for making them spend time on that so
friends don't let friends rebase their
friends branch another popular option is
to have your CI server merge master or
or whatever branch you need but I'm just
going to say master for now merge master
into your feature branch about once a
day or maybe every time you build even
so this solves a couple of problems
prevents your branch from drifting far
away and it shows you again how your
changes are going to play with what's
already on master when you eventually
merge your changes upstream caveat
number three however is coming at you
remember what I said a few minutes ago
about shallow clone and repository
history history so merging the branches
is one of those sophisticated operations
where get does require the full repo
history to be present in your low
copy so if you're going to do this use
the repo caching instead so despite that
caveat I do think that auto merging is
really worthwhile and it offers a couple
of advantages over rebasing three I
think so the first is that your
repository history remains intact so it
would be if you hear people talking
about like oh get is really scary you
can rewrite history I don't know if I
want that that rewriting of history like
what they're talking like rebase is what
they're referring to because it does
reset the commits of origin for your
branch but that doesn't have to happen
if you're if you're doing if you're
merging your branch before you build on
and build against it the second
advantage is that you can completely
automate this merging with your CI
system I am aware of no CI system that
offers support for automated rebasing
probably for good reason and then the
third advantage is that when you
automate with this with your build
server you can choose to have that
merged code pushed to your branch
assuming all the tests pass you can even
opt to have it pushed upstream assuming
all the tests pass so that if you're
working on something on your feature
branch that the rest of your team
depends on you can push that upwards
incrementally and then they can absorb
those changes so you're not you know you
don't end up in a bottleneck situation
and to the surprise of exactly no one we
did build that into bamboo as well I
think the Jenkins build per branch did I
say that right this time billed per
branch yes bill per branch plugin may
support this I can't remember but bamboo
definitely does so you you select the
two branches that you want to merge and
then you tick the checkbox if you want
to go ahead and push it back to push the
merge code back to the repository after
your CI tests run against the merged
code okay so that's option number two
the third option is I think the closest
that you will get to pure CI while still
doing a feature branching workflow and
that is to use a shared integration
branch within the team's branch
workflow so this is kind of like the get
flow way of doing it I've labeled my
branch up here integration I think get
flow calls it develop but the concept is
the same so when you've completed
implementation on your feature branch
and you've got a clean see I run there
you merge up to the integration branch
and you'll probably find that it
conflicts with something that somebody
else has completed and merged up to
integration so you go back to your your
feature branch and you resolve the
conflicts get a green build merge back
up sort of rinse and repeat and what
you're driving at is a green build in
both places on the future branch and on
the integration branch and then at that
point you can merge your work up to
master or whatever your final
destination is and I think it is best to
like go back to the feature branch and
merge that directly upstream like so
rather than merging integration upwards
because you may have like there may be
stuff on the integration branch that
might you like you just got a green
build there so like in theory it should
be okay but there may be stuff on the
integration branch that isn't actually
ready for primetime yet that you don't
that that other developer doesn't
necessarily want to push up to master
just yet so that's one reason the other
reason is that when you do things like
you know put your your issue key into
the feature branch name or your initials
or some sort of human readable
indication of what that feature branch
contains its then really easy to look at
the commit history for master and
instead of seeing merge commits
integration merge commits integration
you see merge commits dev 30 merge
commits dead 45 it's just crystal clear
what came in so do your project
stakeholders and your your team leads a
favor and do it that way okay hooks I
mentioned hooks a couple of times
already and I want to dig into them a
little bit more and tell you you know
tell you what they are and tell you how
you can use them in a CI context so you
can think of sorry hooks
as gets plug-in system they let you hook
into certain get operations and then
customize the behavior repository
behaves when performing that operation
so if you look in the dot get directory
of your repo not now because I have your
rapt attention but after this if you
look in the dot get directory of your
repo you'll find this hooks directory
and that contains a bunch of sample
scripts I don't know maybe three or four
sample scripts that kind of give you an
idea of those sorts of things that you
could do i'm going to give you even more
of an idea of the sorts of things you
can do so there are two broad classes of
hooks client-side and server-side
client-side run on your local
development work space and server-side
hooks not surprisingly run on your get
server you can also categorize hooks as
pre and post hooks it's usually a pre
receive posters post receive pre receive
hooks are invoked before get actually
completes a certain operation and if
there is if if the hook script runs into
some kind of trouble it will cancel that
operation post received hooks on the
other hand one after an operation has
been completed so there's clearly no
chance to go back and cancel that
operation but it will carry out further
tasks for you so you can use hooks to
automate things like like a client-side
pre receive hook if I if I'm checking in
code before I actually commit that code
I want to have get run checkstyle just
takes like three seconds usually and if
I've got you know if I've tipped the
threshold of violations that commit will
be rejected and then I have to go back
and clean up my stuff a pre received
server-side hook could be used for
actually I'm going to hold you in
suspense on that one because we're going
to dig in a little bit more post receive
client-side hook so a good example there
is let's say that I check a new branch
out and bring that into my workspace if
I am say relying on large artifacts
pre-built binaries image libraries that
sort of thing I'm not tracking them in
my repo because I'm a good get user and
but what I can do is use a hook to go
out and grab all those things and pull
those into my workspace for me so that I
can get up in
have a chocolate instead of doing it
myself and then a post receive
server-side hook if you do emerge or if
you push code to the repo you can have
get this get hook like notify your
team's chat room so it's the server side
previous yeah server-side pre receive
hooks that I want to focus on because I
think they are really powerful
compliments to see I you can use these
pre receive hooks to basically you can
think of them as sort of like wealth
elite ninja guardians who are protecting
your master branch from bad code evil
code so developers are generally
conscientious enough not to push that
broken code into master but you know
 happens right like maybe I didn't
realize my build was broken maybe I'm
sharing a development branch with
somebody and they broke the build and I
didn't know it maybe I just forgot to
check whatever so to give master a
little bit of extra protection you can
use a hook that looks for incoming
merges to master or any protected branch
that you're concerned with and when it
finds an incoming merge it will call out
to your CI server and look at the latest
build result for the branch that's being
merged in and if the latest result is
broken it will reject the merge and
you'll have to go back fix up your stuff
and then try the merge again so my
colleague at atlassian guy named tim
paterson who's one of our completely
amazing developer advocates wrote a hook
script that does exactly this and made
it publicly available on bitbucket i
will give you the address in a moment so
you can grab that customize it with your
own URLs and IP addresses and such and
play around with that in your repository
and then the other thing that I've seen
teams struggle with a lot is code
coverage especially because oftentimes
you are retro actively writing tests to
cover legacy code that is eight years
old and was never really written with
testing in mind and it is so effing
frustrating it's so hard and it's even
worse when people then start checking in
more code to that repository without the
appropriate
reg and you're like ah my hard-won
coverage stat is slipping away before my
eyes what can I do about this you can
use a get hook that's what you can do
about it so Tim also wrote a get hook
that is it's again it's a server-side
pre receive hook it listens for incoming
merges to master or whatever branch
you're concerned with and when it finds
one it will again call out to the CI
server and it'll check the code coverage
stat on your on the branch being merged
in and compare that with the code
coverage stat on master and if the
coverage on the branch is inferior it
rejects that merge and you got to go
back and write some more tests it could
be considered a little bit draconian
depending on I know it's a little like
it could be considered a little
heavy-handed but it's I think it's worth
playing around with um and why not
because Tim wrote that script as well
and it's also available on bitbucket so
it really costs you nothing to give it a
shot oh and I should clarify that this
this code coverage hook it does not
actually run like calculate the code
coverage for you it is like you'll need
you would need to do that as part of
your build like run covert or Emma or
whatever you run at clover maybe
probably nobody's using clover but you
could so you got to do that part as part
of your build then the hook just looks
at that it just calls into the server's
API or the CI servers API and just grabs
the the number and does a straight you
know which number is bigger sort of
comparison so here's where you will find
that I'll leave this up for a second so
you can write it down so yeah this will
take you to a bit bucket repository
where tim has put these two hooks and a
couple of other hooks I believe they're
written in Ruby I think he also has one
for enforcing check style and there's
another one around checking checking
build status i think that one is
designed for like when you're about to
check out a excuse me when you're about
to make a new branch it will call out to
the branch that you're going to branch
off of and just let you know like hey
just so you know the builds read right
now you might not want a branch from
this point or you know choose an earlier
commit to branch from so I think there's
like three or
or hooks in there that you can download
and play around with so let's wrap this
mess up these are the five things that I
really want you to walk away with first
do you take advantage of gits facility
for easy branching and merging to keep
unproven code off of master second keep
your repos lean and mean and take
advantage of shallow cloning and
repository caching whenever you are able
third don't put don't don't do manual
cloning make your CI server do that for
you please you'll you'll thank yourself
fourth use build resources efficiently
and delete your your abandoned branch
build configs when you are done with
them so share clean up after yourself
it's a lot like kindergarten and forth
use get hook they they can silently
invisibly and stealth ninja lee protect
master from human error or just perhaps
laziness so i'll leave you with some
free stuff to check out this is a
screenshot of source tree anybody using
source tree right on I I started using
source tree when I first started working
with get and oh my god it made it so
much easier so this is a desktop client
for Windows and Macintosh it is free I
believe you have to register your email
address but we don't put that on a news
you know like a email list or anything
like that you won't get spammed so don't
worry about that it's at source tree
opcom you can download it it's you can
it it's basically a UI skin for pretty
much every command every operation that
you would ever do with get so it's great
if you're just getting started it makes
the adoption process a lot smoother if
you're already a get guru and you just
prefer clicking buttons to typing things
at the command terminal sorcery would
probably be a good fit for you and the
other thing is atlassian calm / get this
is our get tutorials site it goes
through tutorials on a whole but like
dozens of different git commands walks
through a number of different workflows
including the ones I
brought up here there's webinar
recordings from like various get
flavored webinars if you really like
hearing my voice you'll you can find it
some more that on there and enjoy my
voice for another hour or so probably
see some of the same slides what else Oh
articles yes our developer advocates
published articles about get on that
site maybe once a week or so so it's
really a treasure trove of information
free no email required just have at it
and with that you can dig in we have 14
minutes for questions wasting no time
what's up oh the squash commits wait if
you auto check out oh if you do the
automated merge thing I'll see wait I'm
trying to think if that's even would
that even apply because that's okay you
so you squash some commits on your on
your local oh are you talking about like
does get like how does that play with
the the need for the full repository
history it's fine yep you can totally do
that with squash commits great question
others I think I saw the back go at
first
um dang that's a good question I know
how should I call it my lifeline and ask
no no no no so like if it's a
server-side hook it'll just live it'll
just live there in on that server as to
whether it gets cloned along with the
repo I really don't know but it wouldn't
make any difference because it only gets
invoked when you push things to the
server now if you're going to do client
side hooks you like those then I that I
guess then it does matter I don't know
should we should we fire up HipChat and
ask all right let's do that alright
Marcus I hope you're around where are
you where is my mouse pointer more
importantly I never get the screen setup
right there we go
alright let's see if we can get them on
video
hey hey you're now speaking at javaone
are you stoked oh no it's freezing oh
yeah yeah I can hear you okay so we had
a question about client-side get hooks
do you happen to know if they get cloned
right along with your repository hang on
just one second sure okay so this is
Marcus he's one of our bitbucket support
engineers now you know his face okay so
the question was when you've got a
client-side get hook installed like deep
does that get does that get copied up to
the repo and then everybody else who
clones the repo like pulls that
client-side hook down with it or do you
have to like reinstall it every time
along with the repository so any any
hooks that you have a few save he wrote
feeling a little later check that you
had a jury issue key or something like
that before you push it yep every person
would have to copy that into their
repository or put that into their global
get configuration okay cool did you guys
hear that by the way is the mic picking
up my computer speaker okay sweet
alright cool thanks Marcus I think I
think I not for the moment but stand by
we may have more or should or should I
or do you want to just hang on
again hang on i'll just this message
babe okay cool all right that was fun
next I wish my boss could hear that
okay um well I don't really have some
much in the way of success stories with
long-lived feature branches as so this
sort of reinforce or as demonstrated by
the fact that our teams don't do them we
do the the issue level branches anybody
else using like long-lived feature
branches that is it working out okay
right on were you able to hear that ok
ok sweet who else
so it depends on whether we're talking
about a SAS product or an installed
product so for SAS products we tend to
release right off of master there may be
a tag added I I know at least one of our
at least our Alaskan marketplace team
does it that way for installed products
whoops whatever for installed products
okay you guys can see my calendar and my
stuff whatever I don't care maybe less
than professional but it's okay i feel
like we're all friends now so for
installed products like when it's when
we do end up cutting a release branch
i've been referring to them throughout
the talk as a stable version branch so
you cut that off of master and that's
going to contain all the stuff that you
want to release and then there's you
know that that bakes for a couple of
days um you know we're always dogfooding
stuff like internally to the team and
then let's say it's a new release of
stash so at the point where we're ready
to cut that stable version branch well
now we're going to start deploying that
to the instances of stash that the
entire company uses so it kind of goes
through another another like a staging
you know baking period and then if we
discover defects on that version we will
first make so we'll make the bug fix
branch off of the stable release branch
first fix it merge it back to the stable
branch and then cascade that merge down
to master and and to any other versions
of the products that need to carry out
that fix knows that seems to be working
for us glad it's working for you right
on I think we have time for like one
more yep
mm-hmm um actually oh shoot did I lose
Marcus I think the bit bucket team might
do that
uh-huh well to be perfectly honest you
don't entirely avoid it like it does
happen sometimes and that's exactly why
t some teams choose to do the the shared
integration branch I think I'm pretty
sure the bit bucket team does that they
were they were encountering that condos
those conflicts on master often enough
where they felt it was worth the extra
step to go to integration but a lot of
our teams who work on like the stash
team for example like all they'd like
stash is an installed product only
there's no on demand hosted SAS version
of it so for them they you know they
need to make branches off of master when
they need to make new feature branches
and then every you know six weeks or
something when they need to cut a stable
branch so their tolerance for broken
builds on master is a little bit higher
than say bitbucket who releases to
production a couple of times a day so
it's really it's just a matter of what
your tolerance is ok well i think that
takes us just about right up to the time
thank you so much for coming Stoke that
you guys came</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>