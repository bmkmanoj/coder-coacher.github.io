<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON3942   What’s Coming in JMS 2 1 | Coder Coacher - Coaching Coders</title><meta content="CON3942   What’s Coming in JMS 2 1 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CON3942   What’s Coming in JMS 2 1</b></h2><h5 class="post__date">2015-12-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/x5zDEGrCYQ0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello good afternoon everyone and
welcome to this session on GMS my name
is Nigel deacon I where oracle we're on
a developer on the JMS team working on
open message queue and weblogic in
addition to that I'm also the spec lead
for JMS specification and in addition to
this session i'll also be leading at the
JMS boff which is tonight at nine
o'clock here in this room actually i'm
tending the bath to be an informal
gathering where hope we can those of you
who would like to come along we can have
a discussion about some of the topics
i'll be talking about in this session so
we don't have time for to answer your
question well even if we do have time to
ask a question please come along and
community discussion at the late hour of
nine o'clock here it will also be an
opportunity for you to make suggestions
about what you think we should be
looking at in germ is 2.1 in addition to
what i'm going to talk about now so this
is what I'm gonna be talking about in
the next 50 minutes or so I'm going to
start by reviewing the main features
that came in the most recent update to
JMS that's Gemma's 2 point 0 and then
I'm going to move on to discussing some
of the new features which are being
considered for the next version Gemma's
2.1 which is planned to be released as
part of Java e 8j mez to point a then i
was released just over two years ago as
part of java ee 7 now two years on these
are the full the full app servers that
I'm aware of that support java 37 and
Gemma's 2 point 0 as of now in addition
to these app servers there are several
standalone geminus implementations that
supported as well and one very new
addition to this list top right there is
Oracle's weblogic server which I'm proud
of because I work on and which has been
launched this free with this week over
an open world and which now provides
full support for java ee 7 so now
because it takes time for vendors to
roll out support for Jemma's two point
oh i know not everybody else is using it
so let's have a
let's try out the cloud might versatile
facility you have a quick poll and
pardon okay so let's have a go so what I
think you meant to do is you're meant to
bring up the we should have a poll to
find out who's on pot the cloud nice
application but let's just go ahead and
we'll have a go and see if it work so i
think it's an experimental sort of thing
so the question i'll do i'll ask is have
you used JMS 2.8 yet so if you want to
bring up the cloud Mike crowd bike it's
a clout just crowd might not play cloud
might would be a good name as well yeah
have a quick poll so have you used
Gemma's to point over yet if the answers
yes pick a if your answers nope it'd be
just click pause for the pole so modest
there's no 56 is now so that means quite
a few you haven't had the opportunity to
to you to get who try not to get tangled
up so let's have a show of hands now if
you wanna put your hands up if you have
used Gemma's dewpoint oh ok so and now
if you want to put your hands up if you
haven't okay thank you very much so well
I think that just that means it's
probably good idea for me to have a
quick recap of its new features of the
new features James two point oh so the
new main goals are the main goals of
Germans to point o were simplification
and ease of use and in particular to
catch up with some of the ease of use
improvements that had been made to other
job respects like ejb over the years
since the brilliance 1.1 the previous
version and to show you how JMS to makes
things easier let's just look an example
the kind of code you have to write if
you want to send a message in the JMS
1.1 application running in the java e6
app server so that's this is before
James two point oh now this should be
very familiar with anybody with quite a
lot of people here and this is a simple
method that takes a text string and send
it to JMS queue as a text message very
simple so just to go through the things
i hope you probably already know
is first of all so first of all you need
to inject the resources you want this is
Java EE so the resources you want here
are the Q and the connection factory you
then use the connection to create a
session use a session to create a
message producer use the session too
well the connection had to create the
connection the connection to create the
session the session to create the
message producer use the session to you
also use the session to create a text
message you then set the body on the
text message you then use a message for
you sir to actually send the message and
that sends a message and then right at
the end you have to close the connection
after use now actually once I made a big
mouthful of this meal of this but once
once talents is doing is actually very
simple what's going on but it really is
quite a lot of code just to send a
message now here's what the same method
could look like candle client right now
in germs to point o this issue and what
I'm trying to show you here is the main
feature which was added in jerez to
point 0 which is a new simplified API
simpler API so here you inject the Q and
the connection factories you did before
but then you use the connection factory
to create a JMS context object this is a
new object the main object of the
simplified jameis API now once you've
got that the scope to sender text
messages are very simple you critter
Gemma's producer object and then to send
the message you simply pass in the
string you want to send no need to
actually create a message object you can
but you don't have to do in this case
and then if you use as we are here at
java 7 tribal resources block when
you're creating the Germans context so
that's the try with the sort of ordinary
brackets and within the old me back its
you create connection that when you get
to the end of the block it automatically
calls close for you so it's purely
beating you know if you're familiar with
that in Java Java 7 but it's basically
affecting the compiler puts in the call
to close for you in the last brace
effectively of the try block no need to
explicitly call clothes so just a bit
simpler and it actually improved
simplifies particularly the exception
handling there because you don't need to
have a an exception you don't you don't
need to have a catch block around
the you will have that you don't have
worry about catching exceptions from the
clothes if you're doing at that you just
just have one catch block so as you can
see anyway the if you use Gemma's to
point o the simplified API the old API
still there then your code is rather
simpler it's basically the point I want
to get across but Gemma's two point O
went a bit further than this because in
addition to introducing the simple API
it also introduced the ability to inject
Gemma's context objects into your
application directly so that reduces the
amount of code you need to write store
further so in this example then there's
there's no code here that actually
creates the Germans context from the
connection factory instead what you're
doing here is he using at inject
annotation to inject the jammers context
object it's like connection directly
into your application and once you've
done that you can then use it straight
away and not only do you not need to
bother about creating the journalist
context you don't actually need to close
it after use so we don't need to try of
the resources block here or calling
clothes that's just done by the
container for you now as lots more that
can be said lots more that could be said
about certified API but the key thing i
want to say here is that what gem has to
point o did was to make it simple to
send a JMS message particularly in a
java application when you can make use
of at inject annotations just made a
simpler to send a message and the same
improvements also made it simpler to use
the receive method to receive a message
synchronously but what James didn't do
is offer any improvements to the way you
receive messages asynchronously in a
Java EE application particularly you
still need to create an MDB gem message
written bean so effectively effectively
we've got a bit of unfinished business
here I think and to it to make mdg msnd
be simpler and that's the main goal of
James 2.1 to complete that unfinished
business by improving jamis MGBs
we go so I'm going to come back to that
but before then just quickly review some
of the other new features we're adding
James to point o you can now send
messages asynchronously this is
essentially a this essentially
performance feature has synchronous end
for java SE clients because it means the
call to send no longer blocks whilst it
waits for the acknowledgement an
acknowledgement from the server that
your message has been safely received in
the server instead the call to send
returns immediately so your code and
Carolyn do something else while the
messages can currently being persisted
in the server for example and when
that's taken plane that's completed your
message is safe you're an
acknowledgement private acknowledge them
to be sent back to the client and then
you'll get a call back on the sender
side so you can so you don't have to
wait for the message to be acknowledged
effectively by the server but you get a
call back when it happens so that's it
synchronous send you can also create
multiple consumers on topic subscription
now again this is essentially a
scalability feature again for java SE
clients particularly and the idea here
is to allow multiple consumers and it's
multiple threads to or even multiple
JVMs to share the work of processing
messages from the same topic
subscription that's not possible
previously you only have one thread
previously to that consuming from a
topic subscription list we using an MTB
so this gives you in fact the idea here
is to give you some the scalability in
some java at pure java SE application
some the scalability of using MTBs
without using MTBs another feature was
added in James 2 point 0 with delivery
delay idea of here is when you send a
message you can specify a delivery delay
in milliseconds the message will be
added to queue or topic straight away
but the jamis producer won't send it on
to a consumer until after the Liberty
layers passed quite simple feature
deliberately count that's a message
property that makes it possible for a
consumer if it receives a message with a
redelivered flag set to find out how
many previous attempts have been made to
deliver it this provides you with a
standard way to find out whether this is
a sort bad or poison message which is
being endlessly we delivered
because if it's being weasel it at 10
time do you think well perhaps I might
want to give up on that the last two
features that's no recount the last two
features here are particularly intent
are well are intended to make it easy to
create JMS applications we've run in the
jar in a jet java ee app server resource
definitions which is a general feature
in java e7 their annotations or XML you
can add to your code which caused the
queue or the topic or the connection
factory objects to be created in jndi
for you and so that's resource
definitions and there's also a feature
called the platform default Gemma's
connection factory and essentially all
that is it's a built-in connection
factory there's always available in the
standard place in any Java EE app server
always the same name so in a simple
application you just don't have to
bother wearing creating that in jan di
or installing it for you you can just
simply look it up directly from the well
known standard place in the application
so it's just sort of a built in
connection factory it alls it's also a
default connection factory which is used
in certain cases where you don't specify
a connection factory so for example if
you inject gems context which is I did a
couple slides back and you don't specify
the connection factory that you could
then it's going to eat then the app
server will use the default connection
factory for you and that will basically
give you a connection factory that's a
guaranteed to connect to the built-in
jameis provider so that was Jamie's two
point oh well moving on quickly what's
in the pipeline for Jemma's 2.1 well
James 2.1 is in the process of being
developed this is jsr 368 in the java
community process and work started on
that last year and i'm pleased to
announce that the first early draft of
gems 2.1 was released last week there
are certainly hope they'll probably be
further drafts which had additional
features before we reach the formal
review stage of the spec of gems to
ponder one and the current plan is to
release Gemma's 2.1 together with the
rest of Java EE eight in the first half
of 2017 so this is the same time scales
as the rest of the Java EE platform
well as i said the initial focus of germ
is to point to one has been to complete
the unfun i'm calling the unfinished
business that I said was left over from
Jamie's to a point oh and improve the
way that you can receive messages
asynchronously particularly in jonathan
applications and that means improving
jameis md BS so let's have a look at
some of the things we're trying to
improve so here's what is simple Jameis
MDB looks like right now this example it
listens for messages from a cue let's
just look at the various parts of this
so in order to configure that this MDB
should receive messages from a
particular Q you need to specify a
number of activation properties you can
set these using annotations in the code
as we got here or you can also do it
using XML and deployment descriptor and
if using annotations like here you need
to specify an array of activation config
property annotations and for each of
them you have to set property name and
property value the things you need to
configure now this is obviously verbose
generic as you also say constructing a
rave annotations they're not
complication is also messy and it's easy
well I find it easy to make silly syntax
errors like forgetting which type of
bracket you want when you're doing that
just waste a bit of a waste a few
seconds trying to compile but that's the
worst thing here is that the annotations
are totally generic remember MV bees are
not just for at JMS so these antigens
totally generics and so it's less
obvious what you need to specify one you
want to use them for Jonas so in this
particular case we're setting two
properties to activation properties
we're setting a property called
destination look up to the jndi name of
the queue that we want to send messages
from and we're setting a property named
destination type to specify the
receiving messages from a queue royal
than topic these are standard activation
properties defined to the jet ejb spec
but you're having to pass them in those
text strings as I said wait sitting here
is named named properties as key value
pairs so because property name is just a
string you need to know some from the
documentation or whatever what the
property now
to set is and the other problem is that
if you make a typo in misspelled it any
might then it'll still compile but
you'll get some sort of failure at run
time when of course it's more of a
hassle to fix and also since these
property values are always strings
there's no time checking so if you look
in the second of these properties you
resetting destination type which is a
standard property in the jkb spec we've
got to set it to Java xjm as cute as a
string rather than as a Java class you
despite this being compiled code so
that's pretty crude we should better do
better than that another problem or it
sort of issue perhaps on the problem
with jamison db's is that you're forced
to implement the Java extra JMS tour
message listener interface this means
that the callback method has has to be
called on message which has to take a
message object as its only argument so
the first thing that every MDB has to do
just about every MGB is to perform a
cast to the message object to the actual
message type that you're expecting which
is simple enough none of this is
complicated but it's just more
boilerplate which classes up your code
and the last issue with dermis MVPs I
just want to mention is the fact that
it's an MDB and the thing about MGBs is
they've got a fixed life cycle when the
application has started the MDB starts
listing for messages and then the MDB
will continue to listen for messages and
process them until the applications shut
down there's no way no standard way to
Stan listeners to start an NDB listening
or stop it listening part way through an
application I just I wanna talk about
life cycle i'm talking about the life
cycle as the MDB as a whole here I know
there's a slightly separate life cycle
that you may be aware of for moving bean
instances to and from pop pop from a
pool I'm talking about the overall fact
the MDB starts listening when you'd only
when you stand the application and no
later and that continues to the whole
life cycle of the application running so
so so that's the only be life cycle and
the other thing possibly an issue is
that once you designate a class to be an
MDB I can't be anything else it can't be
a servlet or a session bean or CDI
managed bean it's just got this one
purpose
so before I say what we're planning to
do about all this I do want to say that
md bees are not all bad not at all first
of all unlike the first of all that
defines decoratively which I'm saying
that's a good thing you don't have to
write any code to connect to JMS or to
create the MGB and start missing for
messages all you have to do is create
the class and annotate it correctly
deploy it and it starts running so
that's basically a good thing and the
other thing that's enormously important
the MGBs is their scalable a big feature
of MGBs is that they can typically be
implemented you using a pool of be
instances so that you can process
messages from the queue or topic
concurrently whilst keeping each MDB
instance single threaded so scalability
is that well a big feature of MGBs
jemmott well MVPs in general so what we
going to do with JMS with md bees in
jeremy's 2.1 what we're looking at two
things we're planning to these are not
equal we applying to introduce a new
type of germ assembly B which will
address some of the problem of the
issues i just mentioned apart from
perhaps the Faculty's still an NDB so
improved jamis mbbs and the other issue
that we're looking at is to consider
whether we can allow other objects to
listen for Jemma's messages tickly in in
a java application server specifically
CDI managed beans and i'm going to talk
about both of those let's talk first
then about wats plan for JMS md BS in
Germans 2.1 well we're proposing to
introduce a new type of dermis NDB and
wanted by the name I've coined the
proposed that we call these flexible
jamis mbbs just so we can refer to them
and the point about these is they won't
be configured using generic activation
properties like before they're going to
be configured using simpler and jameis
specific annotations in addition to that
users would be will be freed from the
need to implement the JMS message this
interface so they don't have to provide
an old message method and instead
obviously they have to define a callback
method but can have any name they like
and possibly we have the possibility if
we want to actually allowing the MDB to
have multiple callback methods though as
I'll say later I think jury's still out
on whether that's actually a good idea
and the callback method can not only
have any name the user ones but can also
have any number of parameters depending
on the parameter type and what
annotations you've said these can
provide direct access to the message
object self or the message body or to
specified message headers and message
properties so these are still MTBs they
still follow the standard MDB lifecycle
and they can still be pulled scalable e
like jamis MVPs now so let's just look
at an example so here's a flexible gem
smdb that listen to the messages from a
queue just like the previous example few
slides back but notice how much simpler
code is now the MGB is still annotated
with message driven at the top it's
still an MDB but the other annotations
have moved to the callback method itself
which in this case I've just called my
message call back just to make it clear
that it's a you've made up name can be
any name you like and instead of an
array of activation config property
annotations we now got a single
annotation called JMS queue listener so
it's obvious what this class is doing
and in this case it's got an element
called destination look up which is used
to specify the jndi name of the queue
the jammers coolest orientation defines
four elements or attributes like well I
think they're called elements will fit
of annotations defines four elements
tegan set which is the correspond to the
for act standard activation properties
that are relevant for Jemma's cues so
I'm not inventing any new properties
here these are the ones already need UAB
spec for JMS it's just that we're now
making them elements of an annotation so
that means that because they're not
property names of strings if you
misspell them then it won't compile
instead if you misspelled connection
factory look up it won't compile so
immediately discover you've got it wrong
it'll and hopefully your idea will
remind will actually hidden to store it
should be indeed if you forget what the
options are here you can obviously press
whatever the short keep the key is it
control
some control space or something in
Eclipse and which one the other
languages and it'll just remind you what
the options are so it's just meant to be
a bit easier to write your MBBS so what
are the proper we got here it should be
fairly obvious connections have to look
up specify the connection factory
destination look up to specify the queue
message selector if you want to us
message selector and acknowledge mode
which you can specify if you're not
using a transaction to define the Act
mode actually as used to define whether
you want oops okay or auto back in fact
now since ur i should say since ndb's
use transactions by default so this one
would use a transaction by default in
this build a case the acknowledged mode
annotation we actually value would be
ignored but I'm included here to ship to
sort of show you it's available and also
to show you that also acknowledged is a
enumerated type so obviously again you
don't have to worry about finding the
exact string you have to set
acknowledgement to acknowledge mode to
now which it moment it's a string and
finally this annotation specific use so
there's no need to specify if you
actually look at the javadocs for this
there's no irrelevant properties that
are relevant for topics and also you
don't explicit need to say this is a q
ee knows that this is listening on the q
what about topics well here you've got
choice of two annotations depending on
whether you want to use a durable or a
nondurable subscription this is the
annotation for nondurable subscriptions
it's called JMS nondurable topic
listener this annotation also defines
four elements you can set their the same
as the fourth of q's again because this
destination is just the topics you don't
need to specify the destination type and
because it's just for nondurable
subscriptions you don't need to any d
can't specify sort of properties which
are elit there are no elements relevant
there's a job subscriptions to sort of
distract you or confuse you here if you
want a durable subscription then you
might have guess the annotations called
gem that's beautiful topic listener and
this is this is the one that's got two
extra elements available to you which
are relevant for durable subscriptions
and allow you to specify client ID and
subscript
name so now let's look at the callback
method itself I said they can have any
name and any number of parameters though
the method must return void and as the
parameters themselves you've got a
number of options now currently when
you're implementing a message listener
the callback method has one parameter
which must be of type message this means
you usually have to cast it to the
expected message type text message bytes
message or whatever with flexible jamess
NDP's the parameter doesn't have to be a
message object so if you're expecting
only text messages to be delivered then
you can actually have a parameter whose
type is text message as we got here and
so when a message arrives it'll be set
to the text message object beings livid
since it already cast all ready for you
so you basically save the one line of
code that you the first line of code
which would amuse live you have cast you
can go further than this if you're
expecting only say text messages you can
also set the parameter to be just an
ordinary string in which case JMS will
automatically extract the message body
payload and then pass that in for you so
again it saves you the call to get text
if it's a text message now this will
work for other message types as well so
if you expecting bytes messages you can
set the prams to be a byte array or
expecting map messages you can set the
prams to be a map and if you're
expecting object messages you can set
the promise to be the type of the
payload object itself so lized object
itself now should say you don't have to
define it well we're not have it for
James to bundle we're not having to
define any new conversion rules here
because we've already got a method in
James 2 point 0 which will do this for
you it's the method called get body on a
message object which is a new method in
James took my day which already returns
the message body as an object of the
specified type so we basically following
the same rules through already there in
that method so that's that's the message
so that's parameters that can be the
message itself or the message body you
can addition to that you can specify
that a particular parameter should be
set to a particular message header or a
particular message property and this is
done by setting annotations on the
parameter itself so got two annotations
shape shown here the message header
annotation that allows you to specify
that the parameter must be set to a
particular message header this example
shows you a parameter which will be set
to the JMS correlation ID header jameis
has defines 10 12 different headers
things like miss GID expiration time we
delivered flag and so on and each of
those can be set by setting the message
header annotation to a particular
enumerated type there's also a message
property annotation and that allows you
to specify that the parameter must be
set to a particular property from the
message message property now in Germany
properties are identified by name and we
sort of that's we're stuck with that so
this example simply refers to a message
property called price it's a string so
why use these well it's just to simplify
your application these are things you
can do already but it simplifies your
application by removing boilerplate code
now the new listener annotations we're
defining or all on the callback method
not on the MDB class itself so that
gives us the opportunity if we want to
take it of defining allowing the user to
specify multiple callback methods so
here I've give an example of an MDB
which listens on two separate queues q1
and q2 so if a message arrives obviously
that a separate cue list annotation for
each so for message arrives from q1 the
first callback method is called and if a
message arise from q2 then the second
callback method is invoked so certainly
flexible enough to say in the since this
was suggested in the community a few few
months back we have received mixed
feedback on whether this is a good idea
because some people think it's a you're
sore digging a pit for the user to fall
into particularly as it makes a little
more complicated to know how big the MDB
pool is you know it might be obvious to
us but users immediate need to think
that it'll have got to call back methods
then essentially to get the same
throughput compared to MGBs they might
need to define the NDB instance
twice as big and that sort of thing so
not complicated but if given the purpose
of all this is to make it simple easy to
use we just need to make sure we don't
accidentally sort of introducer
something that makes it more difficult
to more likely people will do the wrong
thing so that's something that was one
of the many things that we welcome
feedback through on the early draft and
I finally we need to define just one
more annotation and that's to allow
proprietary activation properties to be
specified on the callback method now
just about all application servers and
resource tab does define additional
non-standard activation properties you
can specify in addition to the standard
ones so for example if you're using
glassfish you can specify property
called reconnect attempts and a property
called reconnect interval now it doesn't
actually matter what these do do the
point is is that we from the spec point
of view we recognize the users will
still want to set non-standard
properties like this and decatur for
this we're proposing an annotation
called jameis listener property which
allows any property to be set on the
callback method essentially and this is
a repeatable annotation so you can have
as many of you as you like if you'll set
more than one property and basically
this is just a slightly simpler
equivalent the old way of setting
activation properties that i showed the
beginning but it's less verbose you
don't need a raise here there are people
annotations and then on the callback
method not not on the NDB class we have
a question
what about multithreading concerns for
multiple call back methods in a class
well of course that's for us to define
but I i think the position here was the
MDB instances remain single threaded I
mean that's actually defined an ejb spec
as a as a requirement and that doesn't
change here so with a given MDB
obviously you can have messages
delivered sort of concurrently from two
different cues but they'd be caught it
but they wouldn't be called on the same
objects the same time so these are still
the basic principle of MGB as being a
single threaded callback single-threaded
object so when you write the callback
method you there's only you can be sure
there's only one thread running at a
time that still stands and now it's
still stand with to call back out
methods as well and that's why I
mentioned that the MDB pool would need
to be bigger if you had to call back
methods because obviously you're not
going to call the same beam from T
threads yeah in fact that's the so the
first that right sir so this isn't
finished there's a number of issues that
need to be finalized and the first is
that point about multiple callback
methods is that a good idea the second
question is whether to allow callback
methods to throw checked exceptions
because we could it's up to us and
thinking answer that is yes mainly
because the null message callback can
throw an unchecked exception now so it's
not a big deal to allow a checked
exception though we might not want to be
a bit more specific about the rules on
how exceptions are handled anyway and
the third is sort of related that in
that having what happens if you've
specified the callback method has
parameters well if you specify the
callback method and if he turns out that
for the message that's arrived you can't
actually set the parameters so for
example you've got parameter of time
text message and but the next message is
actually a bytes message you actually
can't set that so what you do now
obviously I think in this case the apps
you should have some sort of exception
that needs to be handled by the app
server
but you might need to handle them a
little bit differently because if
there's just a mismatch of types there's
no point in redelivery it just to the
same md because it'll fail for the same
reason so you might want to do something
like standards were dead message queue
or you might or somehow take some action
again this is something that needs to be
decided and again we'd welcome
suggestions so well flexible jam smdb is
a condom big new feature of jams 2.1 and
we'd like to seek more feedback on it
while we continue to look at other new
features so we've just released last
Thursday what's called an early draft of
the new spec and which basically adds a
completely new chapter describing
flexible jmsn DBS and there's also a set
of Java Docs which define all the new
annotations so that's a little
screenshot from actually the spec itself
it should be quite readable I hope so
please do download that take a look and
let us know what you think particularly
on some of the unresolved issues I
mentioned anything else you see and tell
us whether you think it's a good idea so
that's JMS md B's let's move on some of
the other features yeah that have been
considered and in addition to making jam
assembly B's more flexible we've also
been looking at allowing other types of
Java EE object to listen for messages
and in particular we be looking at
allowing CDI managed beans to listen for
Jemma's messages now the goal here is to
bring jameis listeners into the
increasingly popular world of CDI and
make it easier to exploit the power of
CDI in your jameis applications now i
should say in this section I'm going to
be run more tentative than I've been so
far simply because this is very much
work in progress
so the basic an idea as I've said is to
allow you to be able to take any CD I
managed bean and make it listen to forge
a mis msgs simply by adding a callback
method and some annotations like those
we've already discussed for mbbs now it
sounds simple if you put it like that
but there's more than one way and what
this could work and the next few slides
I'm actually going to sort of have a
little bit the discussion about some of
the issues we've been looking at but the
questions we need to answer include when
is the jammers consumer created that's
the object that correct connects to JMS
and receives messages how many jam is
consumers do we want to be 11 consumer
for every instance of the beam that's
listening or one consumer that's
delivering to all the instances you know
the sub doesn't options here and indeed
listen to beam itself when is it i'm
going to call this the listener beam
that the purpose of this discussion
winds that actually created well the
answer some of these questions depends
because these are busy the CDI beans on
the scope of the beam and but even then
i think we've got more than one option
so to answer these questions and perhaps
just to recap some basic CDI as well i
think the first thing we should do here
is look at the technology that's already
in CDI for sending messages about the
system and that's CDI events so it's a
little diversion into how CDI vents work
and i'm not necessarily the big expert
in CDI but that's but let's have a look
at this so the basic idea with events
and CDI is that one part of the
application can find event when event is
essentially any java object and another
party application can receive those
events base and these set of
synchronously but not they're not
actually a single as the mound to file
an event the first thing you need to do
this little example is to inject an
event object in your application now i
think i'm actually missed the name of
the class slightly misleading because
despite the type of the eventual
injecting as being of type event this is
actually an object for firing events and
when you inject it you need to specify
the type of the actual events that it's
going to fire but once you've done this
the final event you simply call the fire
method and pass in the actual event
object simple enough
so how do you receive this event in CDI
well you need an observer class with an
observer method which uses the at
observes annotation to specify which
specifies the type of the event you want
to receive and perhaps a qualifier
annotation as well and having defined
this code well what happens then when
you fire the beam when you fire the
event and the answer that question
depends on the scope CDI scope of the
observer beam so bear with me for the
bear with me here now by default observe
the beans like CDI beans in general are
dependent scoped you can annotate them
as being dependent at dependent or but
you don't have to because that's the
default that's why I've sold it that
would put that as a comment so okay so
if the observer beam is dependent scoped
then what happens when an event is fired
well what happens in CDI right now is
that each time the event is fired a new
instance of the observer beam is created
the observer beat the observer method is
then called to deliver the event to it
and then the observer beam is then
destroyed so a single shot now because
the observer is a CD I managed bean you
can you're free to inject it insert into
your application but those inject
instances are irrelevant here they just
ignore to end event is fired so what if
we took the same approach and allow the
dependent scoped see the i-beam to
listen for jameis messages so here's
what it might look like with so again
it's just a Java object with a callback
method which is defined in just the same
ways for a flexible dermis MDB in this
case i'm using the gem as coolest
annotation to specify that we want it
this beam to listen to receive messages
from a cue from particular q so if we
observe that if we adopt the same
approaches for dependent scopes observer
beans then each time a Janus message
arrives from the queue then a new
instance of this listener being will be
created the callback method will be
invoked and then the listener beam will
be destroyed to enough and just again to
follow the exact follow the existence e
with CDI event see if another pass the
code has actually injected an instance
of this of this listener being into the
application then they're ignored when
delivering messages they're called
athens never invoked so we only ever
call the callback method on a beam
that's created specifically for each
message that's just how just like
happens with CDI event at the moment
with dependent scoped listener beans now
I think that approach would certainly
work I with JMS but we might want to
extend it slightly to make it a bit more
scalable and to allow messages to be
delivered concurrently in multiple
threads so if it had happened each
message we could still be sent to a new
instant a new separate instance of the
beam so the beam itself could stay
single threaded we just have multiple
threads doing this so I'm suggesting we
could invent an annotation called max
instances which could specify how many
threads and hence how many concurrent
instances we'd want to create as time
and who knows we might want to decide
it's a bit expensive to keep creating
and destroying listener instances like
this I don't know why CD I haven't
thought about this so we can allow these
to be pulled in some way so the instead
of destroying an instance after use we
could return it to a pool now you might
be thinking all this is sounding rather
familiar because isn't this how ndb's
work and the answer is yes it is so
effectively following this approach has
effect and with this sort of extolling
the CDI event approach plus an extension
for concurrency we've essentially
reinvented NDP's where I'm actually
being MTBs so the question I'd like to
ask is would this be useful we now have
a plausible definition as I said of how
James listener beans might work if they
were dependent Scout but there's another
possibility which just want to mention
that there's you know another another
option we could we could use that what
I'm calling it better and think of a
better name of this net better name than
this but I'm going to call it here the
alternative approach which relies on the
in which unlike the first approach
relies on the listener being actually
being injected into the application now
in the previous sort of n style approach
and he injected listener beans were in
ignore
what but in this approach they're the
ones to which we actually deliver
messages now a big difference from the
first approach is that as we are is in
this case then is we're sending messages
to the same beam instance that the users
interjected into their application so
the application call other methods on it
which gives you the option to do more
things so just in this simple example on
the Left we've got a simple listener
beam with a callback method there it
receives messages from a queue and each
time this is called I'm suggesting an
increments account of all the messages
received so far we've also given the
beam another method which returns the
counter meth which returns this count of
messages so that's the beam over on the
right we've got a servlet for put into
which we've injected this beam and say
give an example of how you would
injector this beam and since this beam
is dependent scopes then the moment the
servlets created then the injected
listener beam is also created and that's
how dependent scoped objects work and
I'm suggesting that's the point at which
this beam starts listening for messages
and then at any time and then once
you've done that as a new message each
time the message arrives you can then
call the callback method on that
injected injected instance and because
you've also got a handle on that object
in the in this code it means any time
any what time and I thought of giving
example in the service message anytime
the occurred that injects it can always
call my other methods on it missing so
for example it could call that other
method to find out how many messages are
being received so far again we might
want to think about concurrency because
there's a single instance in this case
for each depend so basically because
we've only got the injected we're using
the injected instance rather than just
freely instantiating new objects for you
and sister for every message we then
effectively we've got one instance which
means that if we want to keep the
keep the beam single-threaded then we
obviously have to call messages call the
callback method wanna you know once the
time said increase increase throughput
we we would want to and allow more
threads then basically we'd have to
allow messages to be delivered and
currently in multiple threads on the
same instance and that obviously means
that the beam would have to be written
the call it myth has to be written to be
thread-safe by default which lobstery an
extra bernal developer and you could say
it's a drawback of this approach oh and
I'm suggesting yeah max the Reds
annotation to configure it and perhaps
even the default that says it's single
threaded so you know the point that you
really want to just get across here is
there may be a dot another way to do it
which has some advantages and some
disadvantages so yet summarize there's
two alternatives and one of the things
the eggs we could go into this in more
detail but one of the things that
obviously expert group and the community
in general needs discuss is which of
these approaches to which if either of
those approaches we want to take for
dependents go beans we could offer one
or indeed both or neither of them now
leaving those questions leaving that
dilemma hanging in the air there's some
let's move on from dependence coke beans
and look at normal scope beans and let's
start by looking at how a normal scoped
observer bean currently works in CDI now
the term normal scope in CD I simply
refers to any CD i scoped other than
dependent and that means request scope
sessions curb conversation scoped
application scoped or as well as any use
defined scopes now from a user's
perspective beans that have got a normal
scope can be thought of as existing only
within a particular instance of that
scope what CDI calls a context so the
beans exists only within their scope
their context so for requests go for
example there's only ever one context
there's one context for each request in
progress so here we have our observer
been again except this time of made it
request scoped as an example now the
important thing to understand here is
that
observer been instance for a particular
scope context remember we look at this
is a CD I hear that the one thing to
understand is that the observer been
instance will only receive events that
are fired witness within the same scope
context that's just our CDI works so
it's not a general purpose listening
mechanism your own listening to to sort
of mess two messages to eventer the fine
from within the same context i should
say if the instance does not exist when
the event is fired their and CDR will
create an instance of it this will carry
on until the context comes to an end the
request or whatever so how then would a
normal scoped james listener beam works
and I'd say we've got a bit of a problem
here because if we followed the same
approaches for CDI events then a listen
being padonia received JMS messages
which was sent from within the same
context the same request or whatever
depending on the scope but that's not
really how jameis works singe ms you
don't actually receive messages from a
sender you receive messages from a queue
or topic and these are completely global
so I'm suggesting that for normal scoped
jams listener beans we just can't simply
follow the example of CDI vents instead
we need to invent some new rules for how
they should behave and I should say so
far I hadn't found a proposal that I
think would work for all scopes and but
there is one case where I think we can
define some usable behavior and that's
if the beaners application scoped and
we're going to do now is just watching
the clock I'm actually so I'm actually
going to skip over this because I think
we want to move on to some of the other
aspects of Germans 2.1 but basically
there's i think we probably could define
a way for applications get jealous
listen to beans to listen what we could
do we can define some plausible rules
for how an application scout being
collision for Jemma's messages but i
just actually just like to we can go
through this in the buff you're
interested but well we can go through
this in more detail above tonight if
people are interested but we just have
to move on now but perhaps
perhaps it's time for another poll and
I've just been talking for about 15
minutes on the idea of CDI managed beans
listening for Jeremy's messages because
it's it has been a question that's come
up from the time and I suppose one of
the questions is that is this is given
us so many options and some uncertainty
is to quite how this would work do you
think this is actually a worthwhile line
of inquiry for the German spec itself so
the question I'd like to ask you is
would you like the ability for CDI
managed beans to be able to listen for
jamis messages and if you want to use
the the app please choose a for yes and
be for now so just a short pause so do
you think we should continue sort of
pursuing that bearing in mind that if we
don't bet if we spend time on that we
can't spend it on something else how we
doing so far is thirty-six percent be is
64 yeah so I think that's a no is it
okay thank you we can continue to
discuss that at the boeuf so that's all
I'm gonna say about CI beans as jamis
listeners just one other feature we need
to look at one more feature I think we
need to look at to improve the way you
can receive messages asynchronously in
java applications and also so far i've
been talking about improvements to
Jameis listeners that have been defined
decoratively md bees or CDI beans but
also gem-set but JMS does have the good
old message method set message listener
on the message consumer or james
consumer in the new API which allows a
listener to be defined programmatically
which is you know simple enough and very
flexible however the java spec says
you're not allowed to call set message
listener in a java application in the
web or civil of container it's just
simply not allowed it's been the case
for a decade of a decade or more 15
years it's not allowed though i know
that some gems
either as an absurd to allow it and
basically for JMS 2.1 I'd like us to
look at whether we can remove this
restriction because that simple simple
change would open their whole world of
flexibility to people writing Java
applications the main issue really is to
make sure that XA transactions work ok
when you're using them ok I just wanted
to go through a few of the other
improvements being planned for gems 2.1
the first is reviewing the gem expect to
see if we can make good use of some of
the new features in java SE 8 and
there's one job so you know suggestions
please but there's one Java 8 feature
which I think we should certainly make
yourself and that's the ability to
define repeatable annotations now since
Gemma's two point oh it's being possible
to define a germ as connection factory
in a java application by adding a JMS
connection factory definition annotation
to your code i mentioned this is an
example of resource definitions that i
mentioned a bit earlier on but if you
want to define more than connect one
connection factory in the second class
you need to create an array of these
annotations and pass them to into a
jeaious GMS connection factories
compound sorry Jenna's connection
factory definitions are with the S on
the end compared annotation so you've
got one annotation an array annotation
holding the rave annotate holding an
array of annotations ok but anyway you
can see it's a bit complicated and on
the Left that's on the left and what I
what I'd like to be able to do is in
Java EE eight you shouldn't have to do
that because we can make JMS connection
French definition a repeatable
annotation so users if they want to have
two of them they can just put two of
them there but that code at the moment
on the right will not compile just if
you ever tried it but it should be in
Java EE ate the same applies for JMS
destination definition annotations which
is the new annotation used to define a
JMS queue or topic once again you won't
need to wrap multiple such annotations
in the compound annotation but you'll
just be able to repeat it so very simple
next new feature proposed for Jemma's
2.1 is a standard way to control what
happens if you're trying to deliver a
message to an MDB or possibly a message
listener and it's frozen exception now
currently what the spec says if you have
an exception thrown from onyx you know
I'll message then the message I well the
cut in most cases it basically it's
saying message was going to get
delivered again however if doing
delivering a message again calling the
on message again that causes another
exception then you might end up with the
same message being delivered again and
again and again now most that's called
to the poison message problem now most
app servers and gems providers will
handle that is this a common problem and
by adding some extra features that allow
you to control the number of times a
message will be redelivered and
typically once that limit is read being
reached the message gets diverged to
some other q known as a dead message
queue these are features that exist for
most every app server out there Jamie's
provider and users have told us that
they think this should be standardized
and loss I agree and I think it's but my
particularly be needed now got flexible
MGBs it's all consistent with that that
might throw a checked exceptions or
where we might have delivery failing
because of a conversion error we want to
send it to dead message queue so I think
as a minimum we probably should allow
should not so much allow you know that's
allowed now we should standardized well
those prop setting those is allowed now
but I think we should standardize on
allowing to specify redelivery interval
which defines the maximum which well
that defines a minimum delay between we
delivery attempts a reason live really
limit which defines the maximum number
of redelivery times you'll redeliver it
or try to redeliver it and a dead
message destination dead message queue
which is where the message is sent when
it reaches the redelivery limit now many
most Gemma's providers may have more
settings than this to control it but
this is slight sort of a bare minimum
that I think we should try and
standardize on and if we can apply this
so i'm talking major MGBs particularly
here but if we can apply it to ordinary
mess
listeners as well we should another
proposal which for Jemma's 2.1 is the
ability to deliver messages in to md
bees in batches and the idea of living a
batch of messages is to allow multiple
messages to be handled in the same
transaction which might increase
throughput in sometimes and this
featured really nearly went into Germans
2 point 0 but we pulled it out at a late
stage because we thought the API was
getting too complicated but now we've
got Jeremy simdi bees we can simply make
this another meth another option on the
when the user configures callback method
so that's batch delivery another feature
on the list is defining some new
standard message acknowledgement modes
as well as allowing Gemma's providers to
define their own this defines mainly to
ordinary job SE clients here and the
existing act modes don't need me to
explain but basically the suggestion is
at the moment is that the stat is we
standardize on two more modes one called
no acknowledgement mode where the
effectively the message is deleted from
the queue or topic immense delivered and
individual acknowledge where which
allows you to acknowledge an individual
message rather than being faulted to
acknowledge the whole all the messages
lived by the session so obviously we
have a lot of apps serves already and
provide these and so this would be case
if it can we standardize this common
behavior already and also custom
acknowledgement modes maybe just a
general feature to allow app servers to
invent define their own so these are
think these are new and custom message
another modes what else an API to create
connection factory objects traditionally
surprising that Gemma's doesn't actually
find a standard way of creating
connection factory traditionally you've
been expected to use some proprietary
tool to create it and then bind it jndi
so you can then use jndi codes look it
up now that could be a bit of a burden
particularly in the java SE application
what some users want is to be able to
create a connection factory using
standard Java code and not use jndi at
all now this is going never going to be
completely portable but I think you
should have a go so essentially we need
to allow a user to take effectively a
set of properties and from that call
some API and use it to create a
connection factory preferably without
actually having to know what the
implementing classes and thus amidst
established ways to do this in Java but
one possibility is to define an API well
a standard factory of connection
factories there's actually independent
of what James provider using something
like drive something like driver manager
in jdbc and perhaps you could call it
connection factory creator so you know
plenty plenty of things to know specific
proposals here but generally an API to
create connection factory is a
frequently asked request for for JMS
there's a similar need to be able to
create a standard API to create Q and
topic objects here prom slightly
different in that we already do have
some API to create cubes and topic
objects create Q and create topic
methods on session gems context but the
problem their problem the moment is that
the Q named topic names you pass in and
not actually portable fact this spec
actually says they're not portable so
and I think we should have another look
at this and see if we can make them more
useful come to the end here is every
slot every time I'm every time we're
working on JMS is best scope to add
clarifications and move restrictions and
we should continue to do that there's a
number of Corrections jammers to two
features that that I want to include
mainly in the light of actually
implement of Gemma's two point oh is
that we discovered possibly that there's
a couple dozen some features that would
have made it easier to implement
particularly an app server and we
managed to work around them but it may
be good to address those in Germans 2.1
so well that's where things stand injure
most people at the moment are given you
a very high speed look at the direction
we're going and there's still plenty of
things still to do
and lots of scope to get involved if you
want to now I said the first early draft
of the spec is just out so please go and
have a look at it I hope it's quite
readable just one new chapter diff
covering flexible Gemma same db's and
you can download it from either jameis
hyphen spec Java net which is exactly my
website on behalf of the ballot and
sorry it's the expletives website or JCP
org you can download it from there you
can follow me on twitter and last but
not least and i know i'm conscious we're
almost out of time so if you want to
explore this more with me please come
back to the discussion here at nine
o'clock at the ball possibly three
minutes for questions you could ask any
so or you put your hands up basically as
to or you can ask it through the app go
ahead I think well the answer is there's
no work at the moment do you think there
should be and couldn't you I'd welcome
I'd love to have a discussion we have
discussing straight after I'd like to
hear what what what people what you
think we should do so and so there's a
boilerplate answer if somebody says are
you doing something and I'm not quite
sure the first thing is can you please
tell me what you think we should be
doing because that's the way to take it
forward so be delighted to to have a
suggestion you can as you talk to me
there's a if you get to join respects
java.net there's a jira you know bug
tracker people have welcome to log any
requests you like there and they'll
definitely get a response so any other
questions
yeah yes yes the idea is is that the
that was the example I gave was
listening with of multiple callback was
listening to different cues but the in
general they would just be different
annotations so you could have one call
back was a durable subscription one
could be a queue or it could be the same
cube you listening on two different
message electors it would effectually
behaving like two MTBs really but you're
just showing the same class okay this
I'll be hanging around afterwards if
you've got any questions or please do
come back to the boss at nine o'clock
tonight and happily to explore it and
particularly the discussion on CDI
through interested in pursuing that more
we can go over that again so thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>