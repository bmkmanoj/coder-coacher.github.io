<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Migrating a JSF-Based Web Application from Spring 3 to Java EE 7 and CDI | Coder Coacher - Coaching Coders</title><meta content="Migrating a JSF-Based Web Application from Spring 3 to Java EE 7 and CDI - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Migrating a JSF-Based Web Application from Spring 3 to Java EE 7 and CDI</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/D5Tzf2DMnDQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for joining my talk I know it's
sad news javaone is almost over but i do
think now at the end i have quite an
interesting topic for you it's right
from real life I'm going to talk about a
migration project I did my team did for
one of the major German car
manufacturers so this is no hello world
stuff today so this is real life my name
is Leon Durham err I'm I'm German as you
might hear perhaps a little I work for
QA where we're a small project house
located in Munich so if i say munich and
car manufacturer you can do the math
which car manufacturer that is then yes
let me do a quick survey who of you uses
spring or hairs use spring in the past
ok so the majority good so who of you
has used je doesn't matter what version
in the past or is already using well
equal who of you has migrated spring to
je yet one very good so I have one here
who has perhaps felt the pain or not the
pain of doing this migration before I
tell you what I will talk about I will
tell you what I will not talk about ok I
try to do this as neutral as possible I
know there's this well war going on
between spring versus je for quite some
time now i will not do that because I
think it's not beneficial I always was
the opinion both technologies could well
coexist so I try to stay as neutral as
possible here and do a top pure
technology i will show you quite a few
code snippets from spring and how those
code snippets translate directly to to
the jec di world before we start just a
brief overview of the systems
architecture to give you a bit more
context about the system we're talking
about I will try to explain the
rationale behind the migration
and then we just start straight into the
code where I show you some spring code
snippets I outline the differences and
similarities between both technologies I
try to show you some patterns and
strategies how we come from the one
world to the other world possibly
discuss some implications on the system
architecture if there are any and of
course highlights and problems and
challenges we've been faced throughout
this migrations project so what you see
here is the conceptual view of the
system we migrated the system is called
air errors in after sales information
research imagine that as a huge wealth
search engine for vehicle related data
we have technical documents we have 26 6
million records of every car produced
since I don't know 1970 we have fault
indications instructions how to do
repair instructors how to diagnose the
system correctly so a whole load of
information in our system on the left
hand side you see the clients we do
support of course we have like we're a
browser-based application we're JS JS
ever plication so of course we have the
browser's client all sorts of brother
browsers down to Internet Explorer 8
even which is sometimes a pain we have
our own air client that's a more kind of
a thin wrapper around the internet
explorer to do your to do your work that
one's written in on the.net platform and
C sharp and we have loads of other
third-party applications that use like
well dll's which we put which we provide
that talk to a REST API the system
offers we will mainly talk about this
air central bit here because that's the
central web application as I said before
and of course that's to talk about it's
mainly based on spring we do use some je
5 api's
the whole system runs on a glassfish to
server so pretty old jdk six glass fish
too well but it does its job we have
several others things the our main
primary database is the so called air
repository that's sort of solar database
which provides us with the with the
search capabilities where foreign
gigabyte solar index to do all the all
the heavy lifting all the searching but
we do have relational databases as well
we access the document storage which
basically is a file system we have
something called the airbus which is
like an ESB basically so you see we're
having air is the name you can come up
with pretty cool names like we have the
airbus we have the air control down here
with something called the air loaders
they are pretty important there are
standalone applications they do like the
ETL job for us they they load the data
from loads of relational databases
transform them and then push them into
the solar repository the system went
life end of last year November last year
and by the end of this year we will
reach full capacity that means world
wide usage 16 languages 50,000 devices
back here several users were expecting a
17,000 concurrent sessions per hour so
if you have a bit of JSF experience you
know that this is not an easy task
concerning memory usage but everything's
running fine everything's running stable
and smooth customers happy users are
happy we're happy qualities fine almost
no defects so a valid question now would
be why on earth would you want to
migrate that system and the short answer
in our case is IT governance okay our
customer has an IT government's
department and when we started when we
started off with the first prototype and
be the first initial version that is
three years ago now we never made a
secret out of the fact that we
would be using spring to build a system
spring in combination with je 5 and at
that time that seemed to be okay but two
and a half years later well people
change opinion changes of course the
internal IT infrastructure changed and
improved and now suddenly they said well
well there's this new version available
we want to homogenize our internal IT
infrastructure let's yeah you have to
migrate so they send me an email that's
the long answer they put loads of points
in the email and then in the bottom line
it said like for further information
please visit Erin group this block you
find further details there so that
wasn't even there kind of own opinion
they just set these other points and I
will not argue about these points
they're all definitely valid points from
an IT government's point of view okay
most of them are about cost of course
they want to operate as as efficient as
possible they want to operate cheap so
there are all valid reasons if you start
a new project but if you have a running
project that's been developed for two
and a half years whoo that's quite a
mission and of course our first reaction
was were no way no way we do that no way
this is even possible I mean we knew see
the I a bit from you know from the press
and from the internet we know okay yeah
there's this new play around but that
seems hard after all if you if you if
you're in the in the project for two and
a half years you start using a framework
like spring to the full potential right
so to see that one here spring of course
you do you're well we do most of our
wiring using annotations so we have
annotation driven injection and we also
use constructor injection and if you
look on their net the first thing you
see is well CDI always uses field level
injection can I do constructor injection
with CDI hmm we were unsure to give your
wiring some more expressiveness or
we had some custom spring annotations
okay so you don't have your ordinary at
component you have something called for
example an air result converter for
infotype well that's the german acronym
here for a technical document or for
fatso card which is the type of the
vehicle so in this case it's more toward
which is a motorbike can see di do that
we didn't know without further research
then come to well the usual xml-based
wiring of your components I mean usually
have that in a spring application as
well I know you can do beam
configuration but in our case we had the
xml version of that well for sure CD I
can't do that right I mean there well
it's all about annotations and not XML
anymore so we were kind of worried what
happened to to those constructs which we
had yeah not every not everything wolf
was annotation based another thing here
is CC that here for example that's a
spring provided factory being 22 to fire
up and a cache manager from the eh cash
so that's from the spring context
support module or yeah that's pretty
spring specific what about that one
factory beans in general yes we had
those as well if you ever had the the
need to outer wire makita marks in your
spring application well that's all the
code you need to do that again poo CDI
we didn't know property place all the
support you inject configuration values
so yeah we're deployed in a test
environment integration environment in a
production environment in an approval
environment we have three different
integration environments they're all
slightly different you know imports in
URLs and whatever so what you usually do
if you have this little snippet up here
you say well my basic properties that
provided here and I have the option to
override those properties using basic
system properties nice and easy
deployment in multiple environments
possible CD I didn't know at that time
aspectj you know the Swiss Army knife of
every developer for cross-cutting
concerns that's an easy one here for
doing some logging you know method entry
time parameters XYZ do the invocation
and then method entry are the exception
or a normal return value it took it took
50 milliseconds so we had that one here
as well programmatic beam look up using
a registry or also called service
locator pattern you know sometimes you
have the need to dynamically look up
things based on some criteria so you
don't want to use auto wiring so
basically you do this here okay so all
you have to do is implement application
context aware and then you have the so
this registry is a wrapper around the
standard spring application context hmm
spring specific again bean profiles new
feature added in I think spring 3.1 so
it can have environment specific spring
context definitions so you can say if
I'm in a mock environment I want to fire
up those components and if I'm in the
the real environment I want to fire up
the the database version of those
components a nice powerful feature again
while that's xml-based CDI probably not
if you take it even further if you look
at frameworks like camel or Moo they all
have their custom spring XML Diaz adsl
of course we had this as well you know I
always wanted to ride one of those and
here here we go so that's the XML
namespace for a finished state machine
so you know you have those end in start
States and you have different
transitions and all that so how about
that one didn't know and last but not
least I would say unit model unit in
module tests we heavily relied on the
spring test framework awesome framework
for power you can fire up dedicated
spring context instances put just the
test one single beam if you like so
pretty cool feature again pretty sure
here well well CDI is not about this
here so we ended up with quite some
questions and quite a few questions but
well somehow we were interested it made
us interested is that possible we knew
okay it must be possible but how much
effort would it take us to to do this
migration to give you some figures the
whole system including a central and the
loaders about 450,000 lines of code so
pretty big so how much effort would it
take to do the migration so those
questions here are kind of our well
migration path now okay we will kind of
work through all of those questions and
I hope I could I can answer those
questions I personally think it's those
challenging projects that will make life
as a developer really interesting right
i mean borrowing pojo development no one
wants to do that but it's those things
where you start to learn new technology
and start to learn new API so we said
hey let's get on with it challenge
accepted so what we did first is well of
course my personal real je project was
back at the time when it wasn't even
called je when it was called j2ee 1.4 so
of course we had to do some homework we
had to see what's out there and we had
to we had to find out which areas of the
of the je architecture image you see
here we would get in touch with of
course managed bean cdic di extension
that was pretty clearly we had to have
some replacement for our dependency
injection so yeah we definitely have
that one JP a JMS yes i said before we
had a relational database so with jpa we
have JMS for some asynchronous and for
some asynchronous things so we have
those as well interceptors JT a java
enterprise beans common annotations
concurrency utility so those were all
we said like okay we might need those ah
ejb of course when running in an
application server transactions of
course annotations of course concurrency
utilities very nice feature finally not
firing up those will a threat pools on
your own in an application server always
been a bit of a gray area so finally we
have this one here and of course we're a
web application so we need those up here
as well web fragments a jsf expression
language we had a our REST API so we
needed to get in touch with the you know
the latest development up here servlets
of course so once we've done that and
once we identify those things well we're
maven based system well we figured out
those maven coordinates we we need to
use and here was the first surprise I
mean look at those nine coordinates that
was it so throw 15 odd spring
dependencies out plus transitive hole
and put those in and that seemed like
wait so that seemed like wait I know
some of you might say well there is this
one je mega all you boys are available
I'm a bit burnt with those ueber jars
just recently tried to have hem crest
all and more peterhall plus j unit in
one class loader and you know what i
mean so don't do that I think it's
better to be more detailed here on this
level to just and to be able to decide
okay I need this I need this I need that
and that's it so those were the new
coordinates and we're that was the first
impression where we thought okay oh that
looks pretty lightweight I say where
maven based system built system we have
like a hundred plus different maven
modules think it's a 120 and they were
the main unit of our migration you see
here on the on the left-hand side a
snippet from the IDE so what we usually
have is our we have our
business components in this case is a
Mac listed which is like a basket we
have an API module which contains like
data transfer objects and interfaces we
have a core module which is like the
main business layer stuff going on when
you know the persistence the business
logic the entities if you need so those
are in the core and then we usually have
a dedicated you I module as well
containing jsf managed beans plus in
some cases X some some XHTML fragments
so I see here the left-hand side we have
like usually every model has its own
properties file and his own swing
context definition so what we have to do
is replace all spring annotations found
in all the code of those modules and
replace them with the CDI equivalent
step one we have to replace the xml
context definition which probably beans
xml and well we have to care for those
well instances defined in those usual
spring context definition and find a
suitable replacement for those as well
optionally we had to adjust the
components perhaps to benefit from
latest AP is offered by CDI or je as I
said we had to find and build substitute
for spring specific features and again
last but not least the the unit and
integration tests had to be adjusted had
to be well migrated away from spring the
test framework towards the well whatever
framework we see in a minute
it is already in production yes yeah
that's a good that's a good question let
me skip to the next slide and I will
give you an answer to that one i'm
currently will still out with the
GlassFish to version spring based
version so if all goes well then perhaps
it's the next version but the problem is
that there is currently no commercial
support for glass fish anymore and our
customer was one of those who had
commercial last fish support version 2
and 3 so for them it's now a bit of a
pain not to have that anymore so let's
see where that leads us and when we will
what we wouldn't be able to to push that
in production so I said first thing both
are well both support annotations and I
said before we mainly used annotations
so the the mission was to will take
those spring annotations and transform
them to their CD I equivalent and that
turned out to be quite straightforward
even though you have subtle differences
in well lifecycle and meaning so you
have the usual at component on in spring
you can have a component with a bean
name as well so what you can do is just
have that whether you would translate
that to add named well but be careful
here not every bean needs a name why
should it if the beam is like in the and
the back end layer and not directly
accessible in your inner jsf pages then
just throw out the name it's just not
required so in most cases what you do is
is the scope stuff here which is really
relevant / default spring beans or scope
singleton so that would translate your
application scope let's go prototype
it's kind of dependent the equivalent
scope request your reckless cope scope
session your session scoped and to do
the wiring you usually have Auto wired
and the equivalent would be at inject so
pretty straightforward for those things
well don't do well a global replace so
what I did what we did is like step
through every class step through every
line of code and just do this manually
and try to see okay where it's
appropriate can I throw out the name do
I need a name what's going on here so
that's the first thing be careful with
the scope yeah default scope scope
singleton which would translate your
application scope it's dependent in CDI
so think about which scope you really
need here then the next trick is or the
next tricky thing is that CD I always
use this client proxy spur default
except for a dependent and in spring
it's kind of the other way around you
have to explicitly tell it that you want
to go proxy so again here this is you
have to think and this makes it for
example difficult why if you have the
ordinary beam in CDI you cannot have
constructor injection you can you have
to have this default constructor luckily
we'll all interfaces so we were safe
from that part so our wiring was based
on the interfaces and then even in CDI
you can use constructor injection again
so that saved us I think a lot of work
and a lot of pain so all this here might
influence your wiring style also be
careful was final we had to take out
quite a few finals on methods and
classes on all that yeah so that's the
basic wiring of course sometimes you've
seen it in the previous pictures there's
something called a qualifier to
distinguish various implementations
spring has it CDI has it this one's
definitely straightforward you just
replace that qualifier with that
qualifier and you're done
sometimes in spring you can use at
qualifier with a name yeah that's really
a name raw that's not that's not
possible in CDI so if you have those
constructs the recommendation is to do a
proper qualifier annotation so for this
one translated to that one again here
the name is really not required i mean
the this thing has a purpose this thing
has a meaning so we decided not to use
ad named in this case so to give it a
proper a proper meaningful annotation
stereotypes so the CDI at stereotype
annotation is kind of the equivalent to
having custom spring at component
annotations so what you do here is you
you you giving your components and your
object some some some purpose so you
have in spring the usual you have a net
service or at repository and well that
usually makes sense in a bigger software
architecture you have like components
that have a specific well purpose and
mission so you would translate those
with the at stereotype again yeah so you
see here you have an add component with
scope prototype and here a few more the
target and the retention so here in this
case this would directly translate to
its theory type with a dependent one
thing you have to look out here is
perhaps the target annotation in spring
we found usually we only had the target
type because you you only apply those
two classes because you have produced a
message and CDI it makes sense in most
cases to to have type and method at the
at the target annotation yeah so pretty
straightforward as well next thing I
said all of our modules head lower
headless private spring context
definition and well throw that one out
in the most basic form it was only those
two lines in here
eh well I have annotation config and
deer spring please scan this package for
my components well that directly
translates to what kind of an empty bins
XML where you say be in discovery mode
annotated done and at this stage why
don't know fifty sixty percent of our
modules were already migrated well leave
the tests aside we come to them later
but the most basic wiring was done now
adjust the scopes just the stereotypes
adjust the the qualifiers adjust this
one and you're kind of done well almost
so let's come to some more Oh to answer
your question here at the front if I go
back to this one here what you can do is
you can tell spring to accept those so
you have a way to tell spring hey listen
I'm not going to use a component anymore
i'm not going to use scope singh of many
more I now want application scoped so
you have a way to kind of paralyzed so
you tell your team now you use the new
annotations please for all the
advancements you do so later on of
course when you when you kind of merge
the migration branch with you with your
life development back together you're
not in so much pain and of course for a
customer when we when we initially said
no we cannot do that one of these things
we said well we have to stop development
for for like you know several weeks we
have to stop development we can't
develop any new features because you
want this technical migration and that
turned out not to be not to be so harsh
yes good so let's come to some more
interesting stuff so that was kind of
almost easy so we have our xml-based
beam wiring I had the example before we
had the the cache manager we had factory
beans so what about this one well first
you think ricktum LCD I can't do that
but the answer is surprisingly short and
easy well you you have this powerful
feature called producer methods and this
in a way directly translates to several
producer methods and if you look at this
factory beam from the from the spring
worm framework the only line that
matters is where the the correct
instance gets created and that's kind of
here so you say new cache manager full
from the configuration you give it you
have a dispose method so in the in the
previous example here you had the
destroy method so that would translate
to a disposal method and it just call me
silly but you know most of you have
probably read like a pragmatic
programmer a clean code or something
where it always on about you know
speaking names and this one produces an
application scoped tightly caching tyler
is german word for parts so this
produces an applications called parts
caching cash manager I mean this is so
readable so those little things that
make it worthwhile
yeah we actually sort of advertise our
application context so give me give me a
few more slides I think I can answer
this question in a few more slides so I
talked before we had like this wiring of
configuration values and at first we
thought no direct equivalent here so
this add value annotation where you can
say please inject me the value some
property from this property file into
this beam didn't seem possible if you
start looking around on the net you will
find of course a lot of answers and yes
it's possible so what we did is we had a
look around and well luckily we found an
awesome Delta spike project and that
provides you with a delta sky
configuration mechanism all you have to
do is implement this class here a
specific class and all you have to tell
Delta spike here is where is my where's
my property file and then it will kind
of when it fires up when delta spike and
the whole CD I environment fires up it
will read in those property file and
then you can add inject this
configuration property at the place you
want so great first we feared oh god we
have to write loads of code to do that
here we found out great and the
configuration mechanism has the same
power is springing out so it looks for
system properties it looks somewhere in
the Janey I environment and finally then
it looks in the property file so it has
like I think four different steps where
it looks for the property so same
flexibility as before so my tip here is
if there's something myth missing in CDI
or supposedly missing have a look at
delta spike they they did a good job and
while implementing those missing
features perhaps
spring aop so you see here that's the
spring version here up here you need to
write this to to automatically activate
all those aspects this was the
implementation I showed before you have
an esper a component annotated with
aspect and you have the ad around
annotation here for your foyer advices
again CDI has that support as well very
easy all you have is an interceptor
binding annotation so we say well a
performance locked so we can annotate
our classes or methods which we want
this advisor this this aspect to be
applied we annotate that one and then
you have a simple class annotated with
the interceptor binding annotation and
the ad interceptor annotation and that's
about it and you have the around invoke
annotation so again here almost almost a
direct match the only difference
activation you have to do that in a beam
in the beans XML so you have to tell CDI
okay for this archive I want that
interceptor to be activated but again
not a not a big deal so this is
seriously my most favorite a code or
feature in CDI it's the way programmatic
bean lookup does work in CDI first of
all application context is the spring
thing where you find all your beans you
have something called the bean manager
in CDI or be manager a pretty low level
you have to write a certain amount of
code to get your instances all of that
one so our first approach was the
registry i showed you before we migrated
that one too from away from application
context-aware towards using bean manager
but this registry was kind of a pain
anyway because it was static and
everywhere in our code we had like
registry get get my bean get my beans so
to test this one was always horrible
because of the static pneus so then at
some point we decided well we don't have
to use that one we can migrate to
something better okay so first of all
though news be managed
a two-level don't use a static registry
either gruesome testability use those
two lines here so you have this instance
construct so you can tell CDI please
inject me an instance of something and
this instance thing here now gives you
the full programmatic being look up
possibility so either you say actions
get if you don't care which instant it
is or you have the possibility to then
say well please select me an instance
with annotation X or in this case please
select me an instance with the name with
the given name so you could do a named
look up in this case for example and
awesome yeah a way with the static pneus
the the tests were so easy suddenly I
mean with the aesthetic registry this
kind of destroyed all possibility of
executing tests in parallel because
you're over set the static registry and
the one test set up the registry here
the next concurrently running kind of
destroyed the registry from the other
one so we had to kind of tell j unit
well please run everything sequentially
so with this one we were we were lucky
again so we kind of threw that one out I
understand sometimes there's the need to
do this to do a beam look up from a
static context again here Delta spike
beam provider provides you with a
service locator like we implemented
manually so seriously this this instance
construct is my most favorite feature in
CDI now you just said you have like
different environments and the need to
activate certain beans based on an
environment or not we had that also when
we run in a mock environment and
integration environment we need to have
a different component implementing some
interface and in the real production
environment we had another bean so we
use the spring bean profiles feature for
that to implement this and now we didn't
have this beam profiles feature anymore
so the first thought is yeah well CDI
does have something like alternatives so
well we use this alternative feature
well almost the problem with the
alternatives is
you have to manually activate them in
your beans XML you have to tell them for
this for this thing do that or you can
even do it with it with an annotation
but that's kind of static so you don't
want to rebuild you don't want to
rebuild your application every time I
want to deploy to a certain environment
so that didn't seem very suitable so
what we ended up is we implemented our
first CD I extension so what we did is
we had like an alternative stereotype
which we call profile alternative which
knows a list of profiles like test mock
def in prod and we implemented a basic
CDI extension which observes for the
process annotated event and basically i
shorten this one obviously for brevity
but what you can do or this CD I
extension does it checks ok this
alternative must it be mustered stay
active for this environment because I
have certain environment and system
properties set up and if not we just say
veto and CDI then kind of ignores this
one at that turn out really really easy
or surprisingly as a suitable
alternative view we could have used
Delta spike project stages for this one
we didn't because it didn't quite fit
our needs so much well also we will
implement our first CD I extension for
this one again not much code it was just
you know getting into this new thinking
this new technology thinking so now we
come to another interesting bit how do
you do those how to migrate away from
those custom spring XML namespaces I
mean why did we do them in the first
place well because this is much more
readable than having those nested nested
nested spring bean context definitions
so we did that and of course we say hmm
now what to do with this XML so the
first naive approach perhaps was but but
it did work what did we do well
we implemented in code to have the
readability we had a nice fluent api
with a builder pattern and we combine
that with the producer method so in here
you have returned a finit state machine
from start to end with transitions from
to when and you get my point obviously
there a load more transitions here and
that was kind of the the weak the weak
spot on this approach if you have
hundreds of transitions then you have
like this monster method and check style
or whoever freaking out on saying you
owe this method is too long so we
thought again and looked a bit around on
the net and came up with an approach
which i think is pretty cool as well so
again we use the we implemented a custom
CDI extension that reads those legacy
xml files we clean them up a bit we
threw out all the spring namespaces
which we didn't need and just left our
own namespace in we created this CD I
extension that observes the after bean
discovery we read and parse the
configuration files that's just plain
Java code reading xml files and building
kind of a metamodel our internal
representation of well what's in this
xml file and then again here we use this
bean build a construct taken from apache
delta spike to dynamically register this
Finnick state machine bean we just and
create this finished state machine bean
we just read from the xml file and make
that available for injection than by the
CDI environment so this f is M instance
factory then internally uses the Builder
which we just saw on the previous slide
so again not much cold i think the CDI
extension hair like about around 270
lines of code if you implement this in
spring after namespace handle plus a
bean definition parser so you're not any
shorter there I mean that's the spring
way and that's the CDI way but again
pretty well once you once you got a head
around it pretty easy to implement
yes we also use JMS we had the the
spring version and in our first version
we didn't use any message driven beans
or anything we had just plain spring JMS
module support so this is pretty spring
specific now again here it turned out
that the sending bit while the sending
bit we boiled down to those 1237 lines
of code with the new APN with the new
JMS 2.0 api so you inject the cue you
inject this JMS context and then you say
here record my protocol entry so that
was for ya recording interactions with
the system in a relational database but
we didn't want that to happen a
synchronous we just said well we have
fire-and-forget take this protocol entry
and just restore it whenever you have
time for it and we implemented a simple
message driven being to just well do the
storing for us now the receiving end of
story so again not too hard what was
really hard and painful and a lot of
work was kicking out spring test
framework there was so massively you
through our system so that was
definitely very painful so in most cases
what we did we basically replaced the
spring j unit for class running with the
mojito that was a good match because in
most cases we used spring only to inject
mocks into our test objects well mojito
can do that as well so that wasn't that
that was okay so but this simplified the
test and obviously the the execution
time decreased you didn't have to fire
up this the spring context anymore you
didn't have to care for us the spring
context dirty again we have to
invalidate it again so here you you
every test is nicely isolated but what
we really wanted is to have like how
could we be sure that a jar a module in
its in with its internals is it does
wire properly without wiring all the the
outer bits you know only this module in
isolation so we looked around
there are a few options you have CDI
unit Delta spike test control and
obviously a quillian which is not very
unit testing anymore it's more an
integration test but doesn't matter and
batter now really to be really hard just
for one beam for example to fire up the
the context that seemed impossible well
we didn't found a suitable way to do
that so on the end to achieve this we
use the quillian I don't want to say
that the others are bad or anything they
just didn't work for us really very well
so that was definitely hard taking
spring test framework out so you see I
could go on and on and on as obviously
there were a few more changes my buzzer
says I have only a few minutes left to
speak so I'm going to speed up a bit so
there was a lot more code to migrate we
had spring task executions available or
used again here we found a sink methods
or finally managed executor services so
finally we could kick out those manually
managed thread pools and use the
container provided threat proof of that
one that was good obviously in this
whole migration we had to upgrade a few
versions as well we were on jpa 1.0 so
we migrated that one to 2.1 nothing
special here we migrated the the test
away from spring tests again to towards
plain unit tests using jpa plus DB unit
too well initialize odd or h2 in-memory
database properly so that went pretty
smoothly another thing with that turned
out to be more work than expected was
the ejf web layer migration so once we
find out that kind of the the old style
of the old style annotations from jsf
are kind of deprecated now and will be
removed in the next je version I think
so what we did is homogenize all those
annotations and went away from managed
bean towards application scope named
beans we removed the registry totally
with the instance construct and again
here they simplified the unit test and
the test call it to you just what
you know usually when you when you
develop it's kind of hard to well clean
up your mess sometimes and I was like
the the opportunity to do so so what
happened 28 days later in a few thousand
lines of code later perhaps some of
you've seen the movie and I have to
disappoint you we didn't have any
zombies running around well perhaps me
because it did too many night shifts but
so no of course we had a running
application on glassfish version to
version four not to anymore for and we
were so astonished the migration efforts
were magnitude slower than initially
anticipated when I say 28 days this is
calendar days I did the migration on my
own I've been on a parent fifty percent
parental leave and I had to promise my
wife not to work doing days so I did it
during night so I probably only spent 14
days to do that so seriously I was so
astonished that this was even possible
in such a short time of course we
weren't not quite finished yet we had
the load of components there so here is
the challenge were well using CDI from
java SE na te anymore we have quite
complex spring XML namespaces where we
know how to do that now and we have
comprehensive usage of spring jdbc that
one tough again well probably brought
jdbc here at this point yes so some
lessons learned and perhaps my personal
resume first of all I I definitely do
you think je CDI yes the fully up was
with spring in my opinion okay so for us
as a project house we have two sharp
knives now and if we have a customer who
wants stability and and standard api's
and all those reasons I gave you it at
the beginning those those governance
things no nothing wrong with God using
that stack je seven CD I definitely I'm
a different person now as a super yeah
lightweight and super that doesn't mean
that spring is
not super or anything okay so you might
have those customers who well don't like
that stack or I'd like to be more on the
edge and have like the you know latest
latest latest stuff then perhaps there's
also the opportunity to spring again
well you never know but for for us as a
project house is good to have both both
sharp knives in our pocket and use what
either is appropriate for our customers
some convenience is still missing but
that's I mean it's a standard so they
day of course they put out everything
into this standard but CDI gives you
enough flexibility to well extend it
using CDI extensions and also like
projects like Delta spike open source
community is definitely adopting this
new stack so I think there's nothing
really missing one thing question
rethink established patterns and best
practices there's a quite a good book
from Adam beam which I which is a thing
event Amazon Prime customer you can lend
it for free have a look at that one it's
pretty good okay it gives you some nice
new ideas perhaps how you could do
things in je differently as you would be
used to doing it in in the spring way
okay I'm definitely more careful when
binding to a specific framework again I
would have never thought yeah I'm in my
element don't know 20 years career that
I would have to would have to do a
migration like this this is like the
thing you you when you start the project
you say well we you see the Iowa world
wii u spring but that we had to my do
this migration of very unexpected but
again so things can happen so if you
think twice when you bind to a specific
threat the specific framework and
perhaps it's well smarter to kind of
implemented wrapper around this yeah you
live and learn and thanks for listening
and it's time for questions
yes the yes the system is centrally
operated by a central web operations
team and you only have glassfish you
have a really old weblogic version as
well but at that time when we started
the project yes yes yes
oh yeah I I forgot about that one I will
with the next question promise yeah yeah
so the question was how to migrate like
connection pools or third-party objects
right well probably my answer is
producer methods probably producer
methods perhaps if you have things like
those those those spring XML diesels
perhaps it's worth having a look at a CD
I extension but to keep things simple I
would say just go for a producer method
just instantiate those those objects
manually I mean then it's code it's
simple code you can test it that it
works correctly so there's nothing
against this way nothing nothing to say
against this one so probably your best
choice is producer methods yes sir
spring whereas the time you
spring-mvc and how to come to that
decision initially and the second part
of the question is is kind of the flip
side how much more difficult would it
been okay so two part question first
question was why did we use jsf in
combination with spring well it was JS f
plus primefaces primefaces
super-powerful framework you know we
have like your tables your buttons or
whatever and if you would have used
spring MVC you would have to implement
this all on your own so but again that
that kind of only showed well it does
work you can have a spring back end plus
a jsf based front end how much more
difficult would it would it have been if
we'd used spring MVC that was the second
part of the question well depends how we
did a similar project where we had like
this nice fancy HTML lish anger which is
one JavaScript major Travis to blood we
called it's not angular it's the jQuery
it's jQuery we had like a jQuery based
kind of front-end talking talking rest
with the back end and we had spring MVC
implementing and publishing J's and
things if you would have this kind of
architecture world will just go for
jax-rs if you would have spring MVC with
what you have JS peas perhaps as view
and then you have your model and your
controller I mean the controller you
would migrate probably to you well Jays
have managed beans which are then also
the model and then you would have to
care for all those J's peas and migrate
those two you two to facelets probably
um probably quite some work but I think
there is a way to go to go either way
the question was if we have spring
security and I project our project and
the answer is no at this customer they
have their own kind of container
integrated security environment they use
siteminder 44 kind of application or
Apache level authentication and then we
have to use a special library to get
hold of those credentials from this side
minor authentication so no no spring
security yes sir yep
so the question was why did we you why
did we implement features on our own
which are kind of already provided by
the Delta spec project well the one
feature would have been the project
stages they didn't quite fit well you
could only activate one project stage at
a time but what we have is we had like a
combination of different we we do mock
but in integration so we had like a
combination of several system properties
and that's why we decided on that one
too to implement it on our own and
perhaps we were also keen on doing our
first CD I extension so that one's this
one there well we did use it for the for
for testing at a certain places we did
use it for the configuration value
injection so we did use it over there
but again perhaps here if you can kind
of do it on your own in an easy way then
why bind to the framework there the
question was any issues with spring
transactions are answer short answer no
no issues we had those in the especially
those parts where we had like a spring
service or spring service component
having injected an entity manager well
that won't translated to a stateless
session bean and you're done so no
issues there
honestly having to package up this
always this jar and having to put em and
having to know okay put this xml and put
this properties in put those five
classes in put those classes from this
external one in very tedious very
laborious to to get the shrink-wrap
right okay to what kind of package that
one up so if there would be a nice
easier way that would be that would be
good but apart from that it saved our
live on that on that part because we
couldn't get those other two test
frameworks working properly for our case
so according was good there no not yet i
might to do after that talk now and now
we didn't so
for the aspectj the the question was was
what was the solution to my wedding s
peck j that was interceptors plane CDI
interceptor mechanism so you have your
interceptor binding annotation so you
enter tate all the methods or classes
which you want this interceptor to be
applied you implement the CDI
interceptor for this binding and you
have to activate the Interceptor in the
beans xml so i got the sign at two
minutes left okay not that much to be
honest a 12 megabytes perhaps but but
it's smaller okay so it's definitely
smaller
it's not
so you see I so the question was well I
I try to find the question why why we
migrated aspectj also away from well
because it's not part of spring that
that's true but there is a dedicated aop
module spring aop and aspectj is one of
the options you then have in the spring
universe to implement those
cross-cutting concerns the reason here
being well CDI provides you with exactly
this same mechanism with the interceptor
mechanism so there was no need to do the
aspectj way if it's all incorporated
easily and nicely into the CDI universe
so final question I would say
so the question here was if the aspect J
component on aspect matched to the the
CDI interceptor nicely when the short
answer is yes it did we only had a
simple at around annotation and that's
what CDI gives you here as well that's
all you need you you can use dependency
injection as well and yeah it did match
quite nicely okay thanks a lot and we're
done</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>