<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Coding Java EE 7: Making Easy Even Easier | Coder Coacher - Coaching Coders</title><meta content="Coding Java EE 7: Making Easy Even Easier - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Coding Java EE 7: Making Easy Even Easier</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/402uAauldDQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Aaron Gupta I work for Oracle
I'm also called known as the Java EE and
GlassFish guy being with the team for
pretty much its entire lifespan back to
99 it's come on mr. Java
mr. Java all right and my name is
Lincoln Baxter I work for Red Hat I'm
the project leader of JBoss forge and
I've been involved in various EE specs
from JSF to CDI so I guess we're gonna
get started we have sort of a loosely
structured talk for you guys today
because we know slides are boring and we
think that the code really speaks for
itself so that's what we're gonna show
you excellent so and that's one of the
beauty of Java EE 7 in general you know
you don't need to have any slides to
talk about the technology
so we truly believe code is king so
we're gonna get started
a typical thought process when you're
building an enterprise application or a
web application is I want to do batch
processing how many of you use spring
batch it's ok you can raise your hand
don't be ashamed oh oh let's go
different question how many people how
many of you write a java application
that runs standalone or as some process
you have to kick off to do some work ok
so that's sort of a sample we are
looking at exactly now what we're gonna
do is you know as well as part of Java
EE 7 one of the new functionalities that
we have added in the platform is to do
standard batch processing jsr 352 now
each standard is done as a jsr this is
json 352 that's where you can read the
detail so what we're gonna show you is
what it takes to build a standard Java
EE 7 batch application but before we get
there let's see where we are today so
I'm going to show you a proprietary
batch application which is built using
traditional spring stack right and then
we'll show you know sort of the matrix
between the two applications by the way
all of this code is checked into gate
and we'll share the github repository
URL actually send Lincoln's get a
repository so you can see all this code
live today and if you want to see even
more than what
showing you today Arun has a repository
in his github account which has over 160
examples of how to use Java e7 and all
the new features there and it's a
fantastic resource all right let's get
started then
so the first thing I run is going to
show us is a spring batch application so
something that you would probably put
into a nightly job or something that
gets kicked off periodically you know a
lot of us up to do these things and
spring has done a pretty good job of
making that simple
but we're gonna show you how that works
and then what it looks like in Java EE 7
right so now when you're building a
spring batch application or a spring
batch application for me it was hard to
figure out how to get started with a
sprinkle string batch application you
may say I'm biased I'm the Java EE guy
after all but anyway I reached out to
the community and said okay guys I want
a simple spring batch application so
there was a spring advocate by the name
Chris Shaffer he quickly pulled up
archetype I use this archetype to build
a simple spring batch application very
very very trendy you know and as a
matter of fact a lot of Jace or 352
concepts are coming from spring backs so
the applications would seem very
familiar so you have the same concept of
a job XML which describes how your job
is going to be run or what are the
readers processors and writers those are
your typical attributes reader is what
is reading from a source processor is
processing the item and then is giving
to writer for aggregation which then
writes to a database or to a different
stream so those are my typical concepts
of when I'm building a batch application
now if I look at it for example here
how's the font font is really poor how
many people in the back are having a
hard time reading this okay okay I
thought so my bad I should have fixed
that earlier
I'm gonna move this to you guys over
here on the right can see us okay there
you go so now this is a very trivial
POJO person with two attributes first
name last name then I have a person
fieldset mapper and folks who are
actually spring fanboys you know they
would know exactly how this thing works
you can take a class and use these
mapper fields to kind of set the fields
get the fields
okay well the emphasis over here that I
want to show is once you have created
and this is a very trivial boilerplate
application build using that archetype
but once I've built that application I
want to compile it into a war file okay
sign up recompile the war file in a
networks are not reliable anywhere so if
I look at so for example my traditional
application is I'm reading the data from
a CSV file and I want to populate my
database so I need a reader which is
gonna read from the CSV file which is a
stream or a reader or whatever it is
then I have a processor which is gonna
validate the record and eventually I
have a writer which is going to start
writing to the database now you don't
want to write to a database for each
read so you read process and aggregate
and then once you have done bunch of
records together then you write it down
right because we're we're talking what
if you have you know millions or
billions of records that you're doing
here if you're gonna write to the
database once for each of those records
it's gonna take weeks so you want to be
able to do this as an aggregate and
group these things together effectively
right and all of those are done in a
transaction so it's a container manage
transaction you don't need to manage it
there's inherent checkpointing support
all of that okay but once you have built
our basic spring application let's see
you know once I have built the
application by the way I'm using
NetBeans IDE this is a standard maven
based project there is no IDE dependency
here is completely ID agnostic in that
sense but once I've built my war file so
this is how I'm looking at my war file
and you can see I have given full
credits to Chris Shaffer he's the one
who wrote the archetype so now this is
what my war file looks like you know
it's got a bunch of classes let's look
at it there's a bunch of XML file spring
is tends to be XML heavy now there are
approach is shifting going more towards
annotations then you got more XML and
then you got your data files over here
now the crux of me is really Wow
I don't know if I want to count it like
a rough estimate about 20 libs 20 jar
files that are bundled with my war file
itself that to me is a pain point that
to me is a management pain point if I'm
deploying that war file why am i
deploying my runtime or my container
with the app file it's an app it's not a
container so because the container
should provide that functionality that's
exactly what Java is 7 is doing now for
the first time VMware pivotal
SpringSource whatever name we call them
they are actually contributed to jsr 352
so they've done active contribution to
J's or 352 leading about helping us
define how the standard should look like
I think that's helping IBM define what
the standard should look like so with
the spring you get a war file with the
20 libs in there you can take you it is
portable you can deploy in any container
of your choice but the library
management is your own choice now let's
take a contrast if I were to build this
application using Java EE 7 okay so let
me first show you how a standard Java EE
7 application would look like first of
all I just have one job XML which is
called as job description and the job
this is my simple job it's an XML and s
JCP dot org namespace a standard Java EE
7 namespace a job could have a step or
multiple steps this is a very trivial
jobs just a single step in there and if
you wanted another step you just put
another step right over that right
exactly so you could have multiple steps
and you could define flows and you can
define splits and you can define
partitions all of those artifacts are
possible just by using this simple basic
concept of a job XML now in a job or in
a step you could have a chunk which is
what we were talking about so remember
read process and write so I have a
reader a processor and a writer so
that's sort of my basic entry point to
my job now once I have defined the basic
entry point of course I need to define
my reader
and writer reader again is very trivial
if I were to open these three files for
you guys so if you look at my item
reader that extends abstract item reader
coming from a standard Java X batch
package here I have open method on line
60 which is where I'm saying hey this
reader is going to be called once and
let me initialize my streams with a
stream reader JMS queue WebSocket
whatever it is wherever you want to read
from initialize that connection over
here and then read item is called
once for reading an item it's a very
simple separation of concerns design
pattern where you are purely dumb
reading the item you're not processing
the item in any sense you go to my item
processor so whatever item you have read
here the return value is automatically
passed to your item processor so then I
have my item processor just simply
putting a implements item processor one
simple method here called as process
item and in there all I'm doing is I'm
validating that okay this is my record I
am processing if the record is good I'm
going to pass it back as this so I'm
going to create a new person entity and
if the record is not good then I'm just
going to reject the record by returning
literally no so very intuitive very
simple programming model and finally you
know once I return my person over here I
have my item writer and in my item
writer I have this simple right items
method I could of course have open
method here as well where you can
initialize my connection to the database
or the stream where I want to write to
and once I get my list here list is
where all the aggregation is happening
remember we were talking about we don't
wanna do a write for a read so you read
process read process aggregate and then
you write say for ten items all of that
with checkpointing transaction you know
automatically by the runtime which
brings me to a point that I was gonna
ask me started talking about this so you
said you were gonna build a war well why
would you actually want to build this
into a web archive if it's just a
process you're gonna have to run
overnight well why do you need a web
server for that
and the answer is because you get access
to all of the EE resources all of the EE
specs like transactions like JDBC
databases JPA you know all of that stuff
CDI that is built-in for you and you can
just take advantage of those services
that that come with the application
server exactly and as a matter of fact
here for example we are just saying okay
just inject my energy manager and that's
how I'm gonna write to the database now
remember we saw that job XML for example
here I'm just saying my item reader how
does it work my item reader I have put a
simple annotation here saying @ named
which allows this class to be injectable
in an expression language which is what
my job XML is so you can see the entire
cohesive integrated platform working
together to provide you a simple batch
programming model right I think one of
the things that you'll notice is the
biggest difference between e6 and e7 is
things are really a lot more cohesive
we've really worked hard to make sure
that the specs are interacting with each
other well that you can actually use
things and that the integration points
are much more friendly in EE 7 than they
were in 86 and most of that comes around
CDI and the expression language I think
absolutely absolutely so let's take the
example we we have this batch job right
and we do want to be interacting with
the database at some point whether
that's reading from the database or
writing to the database or both how
would we do that I switch over to my
screen here and the answer is well
because we're running in the application
server we can take advantage of the
normal EE capabilities that we would
have in say a web application so if I
wanted to use a JDBC datasource I could
simply use the app data source
definition annotation specify the
connection parameters of my database in
this case we're using the h2 database
that I've specified in my palm here so
I've included this as part of my
application and then I'm just using this
annotation to specify the connection and
then I use the app resource annotation
to then look up that data source that
I've defined here by its name
and once I have that data source now I
can get a connection to it and do normal
normal JDBC operations like you would in
any JDBC application so here when I'm
starting up this example servlet it's
just going to create the database with a
single table that it's called hits and
every time we access that it's going to
insert a value into that table and you
know then read it back out again and say
how many times it's done that very
simple trivial application but just
wanted to highlight the resource or at
datasource definition annotation which
is something that I think a lot of
people overlook and by the way that
annotation was added in Java EE 6 any
Java EE 6 complain app server yeah today
you can still use today yeah right but
it's now you know available with the
batch facility so that's a very simple
example and I know that JDBC is sort of
old school and not very popular anymore
but let's say for example you want to
use a JPA in your batch job well JPA got
a pretty big bump in the Java EE 7
release JPA to 12.1 2.1 and in that case
we don't need any dependencies in our
pom file other than the evap eyes this
is something you'll see in all of our
examples it's just one dependency to get
you all of the functionality so how do
we use that how many people here are
familiar with JPA already most of us
okay how many know or not
ok so for those of you who are not
familiar with JPI there's a file called
persistence XML which is used to do the
configuration for this spec and in
persistence XML you're going to specify
the name of a data source and/or a JDBC
connection for which JPA
the java persistence api will connect to
and then you specify what classes you
want to use as the mapping so you're
going to be mapping database tables to
that the objects and then some
configuration options for the specific
JPA provider that you're using in this
case we're just using a standard JPA
provider we're not using these special
things from hibernate or from eclipse
link so it's all very simple but there
are a couple new things in JP
two for one a lot of people define their
data model define their database using
the entities and they use the entities
to create the database and do updates
and all of that but another frequent
pattern is the database is already
defined for you and you have to say map
your objects onto the database by hand
another pattern is you're using the
objects to define the database schema
using the annotations but you don't want
to let the application do the updates
for you you want to give that to your
DBA and let them do the updates and the
table database creation for you and
handle the the the incremental changes
that previously was something you could
not do with JPA because you couldn't get
a sequel script out of the objects
unless used proprietary tool that would
do that right now with JPA 2.1 the
schema generation the database
definition language generation is
built-in so when you define your model
using the at entity table ID version no
column mapping annotations you can
simply run the application with these
parameters defined in this case the
schema generation attributes of
properties and say I want to generate a
script and put it in my slash temp
directory and these are the file names
so I'm gonna actually deploy this real
quick
so while it's deploying it if you
realize on the schema generation
properties you can say generate my
schema by default it generates it from
an entity so if you have a JP NR T it'll
take that entity as it is converted to
your DDL and put it in there you can
also say my database action is create
and drop don't do from metadata which
means energy take it from the script so
I'm bundling my script so I call the
schema generation properties as a means
which will allow you to increase you
know a share more love with your DBA
which is typically hard exactly so here
we can see that in my temp directory we
have a few files that were created and
if I open these files
it is DDL for the database type that I
specify
in the persistence XML file in this case
I think it's a default hypersonic or
Apache Derby right database just general
DDL language and this script can be
taken and run on any any compatible
database and the model that we recommend
is take this DDL give it to your DBA let
him to you in it create indexes etc and
if the model changes like say the data
definition itself changes then you can
generate the entities back from it and
then not gonna do sort of an iterative
cycle where the entities and the scripts
are sort of more in tune with each other
right so let's say I've got the customer
table here well what if I don't want a
capital C from my for my table
definition well I can go back in here
and I can use the table annotation and
specify a name and I'm gonna make that
all uppercase customer then I'm gonna
redeploy
and when this finishes running we will
see that the DDL file has actually been
updated actually did that work
well I couldn't create my script for
some reason well that's why it's a demo
yes but it tried and that's how that
works
let's try that one more time you know
doesn't want to do it for me today but
we can move on yeah now if you go back
to persistence or XML another thing I
want to highlight here is if you look at
line 5 for example something new that
we've introduced as part of JPA 2.1 is
what we call as a default data source
now if you're building an enterprise
application you are likely building most
likely building a database bagged
application if you're building a
database bagged application typically
your deploy script would say oh go ahead
deploy this data application but before
that create this JDBC resource or jinda
name etc now if you're building an such
an application there is a default data
source that is defined by the Java EE 7
platform itself that means if I just
remove the JTA datasource element here
completely from this persistence or XML
then that default data source will kick
in which gets bound to a database at
runtime by any Java EE 7 compliant
application server yet again increasing
your portability of your application
simpler seamless out-of-the-box
experience this means that there's
example applications we were telling you
about earlier should run on any e7
compliant application server really
trying to live up to that promise of
real portability between these these
servers these implementations so there
are a couple other features that were
introduced with JPA 2.1 and these are a
little bit more interesting than schema
generation the first of which is the
named query feature so if you're
familiar with name queries from JP 2.0
you had to actually create an annotation
called I think named query and then you
know specify the name of the query
something and then the query itself
which would be you know like from
customer where from customer C where C
dot ID is less than 40 or something like
that right well that's great but it
makes it difficult if you want to do say
you know hot swapping during development
and
you change an annotation while
annotations don't get hot swaps because
you have to change the class definition
JP a two point one introduced the
ability to add name queries at runtime
meaning that you can run and debug and
develop and enquiries over and over
again when you change this you're
changing a method body which is much
easier to hot-swap and that's just
something to do to increase productivity
it also means that you could potentially
build a named query dynamically
depending on certain needs in your
application I would say probably you
would want to use the court the type
safe criteria API generally but it just
adds level of flexibility that will you
know just make it make it possible to
use JPA the way you want to for your
architecture and once you have figured
out what your name query really looks
like then actually go ahead put it in an
annotation and use it and spread it to a
wider world I think with resultset
mapping at it as well know so that's it
for for JP a 2.1 I think this is the
major my major enhancements other than
the ability to add I believe indexes
yeah in the JPI spec yeah so you can add
indexes here up in the table annotation
which was not possible previously you
would have had to use the specific
hibernate or Eclipse link annotations to
do that which would make your
application on portable harder to
migrate harder to migrate between
versions of the same app server if they
changed something under the covers and
this is just again making it more
standard weight no switch gears so we
talked about batch application we could
read from a stream a reader could be a
JMS queue one of the api is that got
heavily revised as part of Java EE 7 is
JMS 2.0 long over to you
JMS 1.1 was literally done in december
2003
so almost ten years ago and that was JDK
1.4 I mean think about no generics no
annotations nothing of that sort no for
each all that concept is kind of weird
now ten years back but now that's all
there so the biggest goal for JMS was
really to catch up with the language and
the platform and add those capabilities
if I show you a simple code you know
this is from line 55 all the way down
the
the screen is all the code you need to
write to build a simple sender no I just
want to send a message and this is how
much better it is in 87 well this is
real this is do look at how little code
this is this is incredible
I can remember that and just pull it out
of my head anytime I want so here I mean
let's try to understand the issues with
this code well I'm doing sort of a
lookup of a connection Factory I'm doing
a lookup of my destination then because
you know there is no try with resources
earlier so I got to do connection equals
null here create a connection start a
connection create a session create a
producer create a message my intent
really is to send the message but all
that boilerplate code required by the
API because that's how the API was
designed that was a thinking at that
process and we are not even talking
about sort of my exception handling
these are all catch checked exception
you need to catch an exception and
connection is closing then you so all
that pure boilerplate code okay let's
take a look what we did with that in
Java EE 7 with JMS 2.0 by the way in one
of the big things of course about Java
EE in general is we have to maintain
backwards compatibility so this API is
what we call as classic API as part of
Java EE 7 the new JMS API that is
introduced is called as the simplified
API so let's take a look at the
simplified API and see how it looks
that's all the code that I need once
again I like that expression wait hang
on hang on a second classic message
sender and simplified method sender give
me heart attack now do you wanna
remember this code or discount is this
still JMS that is still JMS absolutely
that's the WebSocket you're just
playable so let's take a look let's take
a look now in this classic message
sender there are other tricks you have
to document this code not forbade if
somebody is inheriting your code they
will have to figure out why is this API
so convoluted you know why there are so
many calls but the funny thing is
because this is an EJB right so we got
just simple stateless annotation here
AGB speck earlier used to say hey or
what I don't care what these parameters
are I'm gonna ignore it
eg B is the king I'm gonna run my own
transaction I'm gonna do my own
acknowledgment so it is messy you know
you have to document that as part of
your code come here let's take a look at
JMS slash WebSocket code
first of all JMS context is a brand new
object that we've introduced as part of
Java EE 7 that is sort of my entry point
to the JMS API where my
producer-consumer all those objects are
kinda encapsulated into one I'm saying
inject my JMS context and what's missing
here is my connection Factory just like
my default data source I have a default
JMS connection factory that kicks in
automatically and if it if you don't
have a default connection factory I mean
you already have a default connection
factory but if you don't want to use it
then you can of course define your own
connection factory you can still do
things the way it was done in EE 6 if
you really want to but this is by far a
simpler approach now also notice here
the add inject annotation from CDI is
being used to get these resources which
is another example of that tighter
integration yeah one of the big focus of
Java EE 7 in general has been creating a
more cohesive platform you know using
technologies more strongly aligned with
each other so I'm just injecting JMS
context here I'm injecting my
destination here that ok this is the
destination I want to send the best part
is in the send message method now from
the context I create a producer I send
the message what is the message and what
is the destination I don't think you
need to document this code it's pretty
self-explanatory I'm sending a message
to a queue so I think to me was very
important in this case is it improves
the semantics readability of the code
now if you give give this code to
somebody in your team they won't look
and thrown back at you that it won't be
a Dilbert comic strip you know you would
they would like it oh yeah I can handle
this code
no this is so the question is how much
extra configuration is not being shown
here that's behind the scenes so let me
show you one configuration I'm glad you
bought that point actually so for
example this is my destination typically
when you give a JMS application you
would say here what create my JDBC
resources no longer required because I
have a default data source create my
destination or create my JMS connection
factory no longer required because I
have a default connection factory now in
Java is 7 what we also introduced was
this JMS destination definition
annotation by which you can even define
your destination in the app itself so
literally a sender and a receiver know
web.xml no other XML deployment
descriptor files just two files one for
sending one for receiving I mean I just
happen to put them to clean code you can
of course merge them into one file as
well
so no other additional and I think that
kind of goes back to the title of our
talk making easy even easier if you
could describe the original JMS is easy
so one of the other things that was
introduced was an enhancement to the
Java transaction API and arunas going to
show you this I'm really really happy
about this API because previously in
order to use transactions you would have
had to use a container manage
transactions an EJB and we all know that
EJB is a very popular specification but
now you don't have to use a jb so we no
longer use EJB but we have container
manage transactions you are allowed to
do user manage transactions in any of
the manage Java EE component let's see
how we do container manage transactions
outside EJB
so I have a POJO you know public glass
my transactional beam no annotation on
its of pure POJO now in this photo I am
injecting two beans okay I'm just saying
inject my dear bean and I'm injecting
the same beam twice now if you recognize
the way CDI works is when you say inject
it does not take an instance of an
object and inject it right there it just
injects a proxy and at the runtime when
you ask for an object it says okay let
me look what scope it's being asked for
and if the bean exists in that scope I
will create an instance or get an
instance and then put it in there right
if the beam is a bean that needs to be
proxied you'll get a proxy if it's a
bean that is just something that gets
past you you'll get an actual instance
of it but in this case you know if you
well all that you continue explaining
and then I'll get it
that's good that's good so my data bean
for example we added a new annotation as
part of JTA called as transaction scope
so the moment you put transaction scope
in the bean that means this beam
instance is tied to a lifecycle of a
transaction so if there is a transaction
then the bean is active can be
instantiated if not then it won't work
right and that is when the beam will be
a proxy because if the bean we're not
transaction scoped it's just a bean when
you ask for it you'll get one but
because this bean has a lifecycle that's
tied to that transaction the container
is actually going to manage the bean for
you so when you access the proxy it'll
give you the bean that it knows you need
to use instead of just some random being
out there right now let's see how we're
gonna use that transaction scope beam in
a container manage transaction outside
EJB container so I have three different
scenarios here scenario one is where I
just put the simple add transactional
annotation and I'm let's take you I'm
pretty stoked about this annotation as
well because it really gives me saying
you just put the add transaction
annotation now this was possible earlier
as well where in using CDI Interceptor
bindings you can define a transactional
but then you were on your own like how
do you define its separate binding how
do you implement those and
how do you do command rollback checked
exception runtime exception you were at
the mercy of EJB for all of these things
you know I don't know how many people
have had to deal with EJB XML and how
many people enjoyed it but you would
have this concept of an application
exception well what is an application
exception it's an exception that was
from your application instead of a
system exception which is the system
that was from like the system as if
that's somehow not part of your
application and which is very confusing
and now we just have a very simple
transactional annotation and an
exception is an exception exactly and
the GTA specification defines very clear
rules that if there's a checked
exception the method is gonna continue
if there's a runtime exception the
transaction is gonna automatically roll
back so the fact that you put a
transactional annotation on a method
that means just that method is
automatically managed in a transaction
by the container so the container which
is the JTA plus CDI plus Java EE runtime
will start the transaction for you
before the method starts commit slash
rollback when the method ends based upon
the conditions and preconditions and
postconditions and look at this now in
the method what we're doing is we're
saying mean 1 dot get ID and bean 2 dot
get ID now if I look at the gate ID
method is just saying this basically
running the object identifier for me
right a cheap way of getting the name of
the object is a string that's correct
now here I'm just printing it out so
what's really happening is when I say
beam 1 dot get ID and beam tool or get
ID because there are two proxies
pointing to the same instance of the
beam because this instance is tied to a
transaction scope so you get the same
beam but once you print the ID the ID is
going to be exactly the same so not only
you are getting a container managed
transaction outside EJB but you're also
getting a no transaction scope beam
right no matter how many times you act
you access my data beam from within that
transaction it's the same data beam and
then in the second method because I put
a separate a transactional so the
transaction starts right before the
method starts executing it's committed /
rollback at the end of the method when
scenario 2 is being called that's the
brain
new transaction now you again you're
trying to say beam one get ID and beam
to dot get ID but remember we said is
going to be tried to our transaction
when the transaction is committed the
beam instance is no longer available you
try to get a new instance of the beam
and then a new instance comes to you
what is different from the previous one
so the object identifiers printed here
are exactly the same but they're
different from the ones printed over
here and finally in scenario 3 I wanted
to make only scenario 1 and 2 is
transactional but because scenario 3 is
not transactional I try to access that
beam at rail throws a context not active
exception right because there is no
transaction the cd-i container says well
you just can't do that right now you
have to wait so let's shift gears a
little bit we've talked a lot about the
batch the backend technologies a lot of
the stuff that ties everything together
well
what's happened on the front end right
we have all these new web frameworks
coming out a lot of people using
javascript a lot of people are using
rest and you know rest is is been around
for a little while now but we've finally
sort of caught up on the esight mm-hmm
and so how many in in the room use JSF
ok how many of you wrote your own file
upload or use the component library to
do it right the JSF specification is not
supported file upload for probably eight
or nine years I think mm-hmm and now we
have file upload it's like one of those
bait Pickers in Java a fax Oh finally we
have date picker in Java effects now
right so it's not fancy it's not new but
it's there and you can use it so JSF
file upload here is file upload not only
do we have file upload but we can do an
AJAX file upload so we can do a file
upload in the background and show a
status so if i do i make a new text
here let me just see two projects okay
so I'm just gonna copy this readme which
has just a little bit of information on
how to use these examples I'm gonna copy
that to the desktop and then I'm going
to upload it to our server so I'm going
to choose the file from the desktop
readme dot asked you doc and I open that
and when I click upload
oh that's right we need one this and
yours there's a bug in in wildfly that
makes this network well that's why it's
outperform guys hang in there so still
working on those fixes but there's the
ajax file upload that happens in the
background so what else do we have in
JSF UI should have code behind it oh
yeah right sorry
he'll upload code would be helpful so is
this hard to do hopefully not we can go
take a look at the source behind this
and the file upload is just a simple H
input file tag you point that at a bean
that's going to contain the contents of
the file and this is just a simple
getter and setter that takes a part
which is part of the servlet
specification so the multi-part request
has many parts multi-part and a part is
the file that's what you get when you
use the file upload component right now
this does upload the file to the server
it does not persist to the server that
is something that you need to do because
once you have the multi-part over here
you are responsible for persisting it
wherever you want to do it in the server
right so the part gives you access to
the stream from the httpservletrequest
from the client it's your responsibility
to get a handle to that stream like
we've done here and then stream that to
somewhere on the server to something the
database hopefully not and do whatever
you want with it
sure was nothing specific in Java EE 7
per se itself but there are lots of
frameworks that are available for
example or Killian is a good framework
which you can use which allows you to do
multi container testing and there are
marks available in our Killian which
allows you to do that testing wherein
you say I mean the our Killian project
is actually it's basically a full test
harness for w/e and the way it works is
you write your application you write
your test code and then our Killian is
going to take your test deploy it to the
server and then that test runs against
the application while it's in the server
so you have full support to any
resources that you would have on the
server in your test case and it's really
very easy to do what's called micro
deployments to test little individual
pieces of functionality out of your
application and if you're if you're
looking for a testing solution I would
definitely look at our Killian and I do
work for J Boston it is the de Vos
project so I'm a little biased but it's
really the only testing solution I work
for Oracle and that is indeed the only
solution and it works really well I mean
we test we use it to test the app server
we use it to test all of the
specification stuff that we do we use it
to test all of our projects it's it's
really nice so what else has been added
to JSF well Wizards
when you are doing business applications
or client facing applications or even
internal applications you pretty
frequently want to be able to guide
people through a process where you start
with step one they fill in some
information depending on the information
they put in you'll take them to step two
you know and walk them through a process
well doing that has been pretty much on
your own for the past eight years as far
as the eCos but now in JSF 2.2 we have
support for flows that come right out of
the box and the way this is going to
work is we have a
hello my config and the flow dot XML
file and this is really just a faces
config file you could do this in your
faces config file that's great if you
wanted to this is just split out into
its own to highlight how you can sort of
encapsulate flows into their own their
own chunks of code together so not only
you can define the flows you know
definitely like declaratively like this
you can do them programmatically where
you have a flows definition so that
programmatically you can define how the
flow looked like right so here we have a
couple beans we have one and here's the
example of how you would define a flow
in Java you have your at flow definition
annotation and then you inject a flow
builder parameter and that flow builder
is what you use to set the idea of the
flow which is basically the name and
then setup the paths that that flow is
going to incorporate but for the sake of
the example we're gonna use the XML
configuration and one of the good things
about flows is it heavily relies upon
convention over configuration so if you
follow the convention you don't need any
of this you know I mean you literally
define the flow like okay I'm gonna
click on this button what's my next
navigation page and things like that all
of those are default conventions here we
are overriding the convention by writing
our own configuration right so here if I
open up the first page of the flow we
can see that at the end of the flow the
user is going to click a button and
that's going to take them to the next
step flow 1a which is this file right
here so that's just a naming convention
that makes it very simple to navigate
while you're in your flow and then flow
1a has an option to go back to flow 1
and then it also has an option to go to
the next step flow and B where we can
then finish the flow I'm gonna click go
home that is going to trigger this
outcome action that takes us back to it
actually invokes the method
floo action on flow n beam and then
takes us out of the flow so we can see
that running and jsf flows so here we
can enter flow one and currently the
name of our flow beam is flow one beam
we have we are in a flow and the next
step doesn't have a value so if I go in
and type a Rin Gupta into our beam here
and then press back now our next step
does have a value because we've filled
it in an example of using a transferring
state between pages of a flow and the
reason that works is very similar to the
at transaction scoped annotation we have
a flow scoped annotation and we've tied
it to our flow one it's good to be in a
flow yeah so the flow scope is going to
keep this being alive for as long as
that flow lives when we exit it the beam
is gonna go away then we come back in
we'll get a new B question yes and one
of the cool things about flows is what
we're showing you is just a single level
of flow you know these flows could be
arbitrarily nested so you could have
flow and a sub flow and a sub flow call
a flow from a flow pass parameters from
one floor to another flow all those are
possible you know there are elx fashions
like faces contact dots something those
are all extended to include all those
flows expressions right so that's flows
and I'm very quickly going to show you
one more example from JSF which is the
html5 path through attributes if any of
you have tried to use JSF with html5 you
probably know that it's very difficult
to get an attribute on a JSF component
to actually show up in your web page
because H JSF in the past is just
stripped out all attributes and they
just don't show up you have to add them
with JavaScript or something like that
so the way this works in just F 2.2
there is a new property that you can use
on your input components and that
property is the P prefix so P is the JSF
pass-through namespace and
you can use that just to pass through
any any any attribute you want it's sort
of a free fun thing
and they weren't hard to realize is that
P prefix is not fixed the namespace is
fixed you are free to choose any
namespace prefix for that namespace to
uri matic right i could name this pass
and then just use pass like that okay
okay good and that's how that works and
it's a very simple feature but also very
convenient if you're doing things with
JavaScript on the client doing things
with CSS frameworks and that sort of
thing one of the places this is very
useful is for example html5 added those
type attributes you can for example on
an input text you can say type equals
color or number or length or things like
that
now with JSF it would ignore that
attribute because hey I'm a renderer I'm
an HTML render kit I don't know what
that attribute is I'm gonna ignore it
now on H :
input text you can say P : type is equal
to color and it will automatically just
pass on to the user agent which is your
browser and your browser is html5
compliant and you just render it nicely
right so one of the things that you're
using if you're probably using JSF is
CDI on the client side and CDI in
general has had a versioning increment
from CDI 1.0 to CDI 1.1 and just to
cover one very simple feature of CDI 1.1
that might trip you up if you're used to
dealing with CDI is the changes in beans
XML the first change is that beans XML
is not required you can basically just
put a jar file in your application your
whole application itself will be a CDI
archive and without beans that XML CDI
will still work this is different from
CDI 1.0 now that highlights the concept
that Cydia is such a cool programming
model of Java EE 7 that we decided to
make beans dot XML optional that by
default is enabled right you shouldn't
have to turn it on it should just be on
and so the other thing that was added to
support that feature is the bean
discovery mode because you don't always
want every meaning every Java class in
your application to be a bean
so in this case we have the discovery
mode annotation and I've selected
annotated the other possible values are
all or none ice apologise as many as a
little small but what this means is that
only be only beans that are annotated
will be actually available in CDI and if
I select all everything in my jar is
gonna be available available and if I
select none the jar will be ignored
exactly well something else that we
improved as part of Java EE 7 is jax-rs
not something but big big improvement in
jax-rs in general now one of the
features of jax-rs that i would like to
personally highlight is the client api
as you recognize as part of jax-rs 1.1
the effort has been primarily to do
server-side development take a POJO
sprinkle the annotations and that POJO
is published as a rest endpoint in a
path sub resources standard HTTP get put
post delete all those verbs are
available with Jeff's RS 2.0 which is
now as part of Java EE 7 we have a
standard way to write a client to invoke
a rest endpoint and completely
independent it need not be hosted on a
jax-rs server any rest endpoint can be
very cleanly involved so once again
let's take a look how you were suppose
you were doing it before if you were to
invoke a rest endpoint from Java so if
you are supposed to do it before Java EE
7 then you would create a URL I'm just
keeping it generic then you will make a
HTTP URL connection then you have to
understand how my servlet request works
and also you have to set up your do
input do output except the char said you
know what your content type is then you
do you know ugly string formatting
concatenation and all of that this is
where you're proposing preparing your
post request finally you write to the
output stream and then you start reading
the input stream all that boilerplate
code is required just to do a simple
post mm-hmm if you were to do a get then
again the same thing because you have to
set the do output method falls by
because by default you know it's post
and then if you were to use Jack's be
with it say your standard at Jack's be
that won't work out of the box because
you know the way wrapper classes were
the way XML serialization work you have
to create a wrapper class you know
understand how the underlying machinery
works so there's a lot of boilerplate
code that's my son's Taekwondo class
there's a lot of boilerplate code that
you need to write to make sure you can
understand the underlying wire
representation and convert it to your
domain objects so literally all this
code just to put a simple post request
just like classic and simplify the API
let's take a look what we have done in
the jax-rs to client api and again this
is an example of how EE is taking
innovations from the industry and
standardizing them so if you've used
rest easy rest easy as the client API
that works you know previously but now
you don't even need that you can just
use what's provided out-of-the-box with
EE and it's even simpler right and I
think that's a wonderful example because
they were five or six different
implementations of jax-rs Jersey you
rest easy a lot of others they all had
their own client API taking that
feedback and standardizing it with
everybody of them contributing back so
I'm taking the best from everything
exactly so now here I want to make a
post request so first of all I say
client builder that's sort of my entry
point to the jax-rs to client API I said
give me a new client on the client I
said the target so same URI I'm setting
up here then because I'm making a post
request so let's say I'm taking that
HTML form and posting it to a rest
endpoint so all I create as a
multivalued hash map on the hash map I
say name I add the name I say age I add
the age and then on the target which is
the web target that I received by
pointing to the URI I build a request I
post a request and I say this is like an
HTML form so once again very readable
fluent builder API that just builds upon
the previous methods and you just fired
the call right away all right
similarly with get I can say target
build a request get and when I'm getting
I can just say give me the response back
as a person I don't care about on the
wire representation XML JSON
I want to deal with pojo domain objects
and that's what I'm getting so I can
just literally iterate over it the
syntax can be pretty elaborate if you
want it to be so you can start
specifying your sub resources resolving
the template specifying what is the
media type on the wire
so what I'm showing you is literally a
tip of the iceberg there's a lot more
that you can explore in vivo class right
so rest is one of the I guess I would
say it's still emerging technologies
more and more people are using it and
more and more people are also using
client technologies like JavaScript and
web sockets and for a long time if you
wanted to use WebSockets in Java EE you
were just kind of out of luck like you
just you couldn't really do it you could
you know now you can use jetty or Tomcat
and they have their own sort of native
implementation of WebSockets or the
JBoss say a7 has its own native
implementation of WebSockets and that's
actually what I use to put together this
proprietary example here and I just want
to tell you a little story about how
hard it was to get this to work in order
to get WebSockets to work on JBoss seven
I had to install a native binary file
for my operating system into the
application server modify the server's
native library path to point to that
file then figure out when it didn't work
that I needed to boot the server in
32-bit mode because that binary file was
only working for 32 bits and then once
that was all working I had to find the
right API to use from atmosphere to get
to work on JBoss in this case the word I
needed the native JBoss serve with
extensions library and I also needed
this atmosphere JBoss very specific to
this technology suite oh right oh that
would help if you could see this yeah so
I needed the native JBoss library for
you know interacting with the JBoss
internals and then I needed the
atmosphere JBoss specific library that
interact with those internals for you
and
this in the code looks pretty JBoss
specific right I've got this chat
servlet here I've got this atmosphere oh
sorry no a servlet definition where's my
a chat oh yeah okay right yeah so it
extends WebSocket servlet here which is
an atmosphere servlet fixed base class
that is specific for JBoss it even says
a very very early experimental thing to
get WebSockets working and do bus this
is like production atmosphere code and
you know once I've got that I've got you
know the ability to listen to events
when the servlet socket was created I
can write to the socket I can listen to
when the socket was closed or when we
actually received a message from that
socket but I had to jump through so many
hoops to get this to work and write code
that was very specific to the
environment that I'm running in there's
no way that this is gonna run on any
other server and probably not even any
other version of this server it's just
not going to happen so with the e7 we
have the standard web socket API which
is very nice again it's a simplification
and a conglomeration of all of the best
practices that we've learned from web
sockets in java application servers and
servlet containers today and it's going
to look pretty similar we have our chat
server but this time we just annotate it
with server endpoint and we have our
socket path which in this case is just
the application context root slash
socket once we do that we can now
annotate a few methods that are going to
handle our WebSocket events so when we
open a web socket session we will get a
notification this method in a servlet
will be called and we can respond to
that by writing some information to the
client saying like hey you're connected
here's what you missed and when we get a
message from the client similarly
there's an annotation for that on
message received in this case we just
get a text payload and we can do
something with that text we can in this
case create a chat message out of it
this chat message is going to
just take the text and store it and then
we can again respond by sending
something back to that socket then on a
socket closed we can remove the client
session from our list of active sessions
the reason we're tracking sessions in
this application is because it is a chat
program so every time someone connects
we're going to take their socket put it
into the list of currently active
sockets and then distribute messages to
everyone so this running looks like a
very very simple dumb chat client and
when I connect to that over here I have
two different browsers running just to
prove that this is actually going over
the sockets and not just sort of using
browser state tricks so between of these
is IE both cool yeah I use the modern
browser
they're both ie6 so here I have Chrome
and here I have Firefox Aurora silver on
Chrome I'm actually on Firefox so you
can see the chrome window I'm going to
send a message it says hey Arun awesome
talk on e7 and it didn't go over the
socket
I guess it's being a broadcast to
everybody in the conference yeah
I just restart here all quick now one of
the things that we were dealing with
when the GSR 356 was started at a given
point of time and before Java is 7
they were literally like 15 to 20
different implementations of WebSocket
that were available each having their
own nuances and own programming model
this is what truly gives you a simple
capability simple API how you can do
server-side endpoint annotated
programmatically client endpoints same
way annotated programmatically and this
works across all Java EE 7 app servers
well I don't know exactly why it's not
writing back to the client but you could
see on the server we actually did
receive the message from the client it's
down here in the bottom I apologize for
those of you who are in the back we can
see we got a are in and I'm assuming
that if we send a message back we also
get it on the server like they're
talking in the Internet
all right we're talking to herself so if
you can switch the screen sure now a
couple of more things I wanna quickly
cover so first of all this is the
repository it's a github repository
Lincoln 3 that says github repository
where all the source code is available
so you can see batch CDI jax-rs blind
everything we talked about is all over
there by all means take it fork it pull
it whatever you want to do we are more
than happy to take contributions we want
you to use it that's what exactly we are
here for ya and if you want to see a
runes massive repository of 160 examples
of Java EE 7 that's over at github calm
slash Arun - Gupta in his job e7 samples
repositories last thing we we would
really appreciate if you go online and
give us a good feedback if you had fun
yes one more thing actually so I yeah
one last thing as Steve Jobs says at
4:15 I have a book signing going on at
the Java lovin bookstore if you guys
wanna ask more questions or get a copy
of the book by all means stop by the
Java nook store yep and if you want to
follow us on Twitter
Arun is at Varun Gupta and I'm at
Lincoln three spelled out th REE thank
you for coming all right</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>