<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>クラウドにおける次世代3Dモデリング | Coder Coacher - Coaching Coders</title><meta content="クラウドにおける次世代3Dモデリング - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>クラウドにおける次世代3Dモデリング</b></h2><h5 class="post__date">2017-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-czgnNqDXmQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello konnichiwa my name is Michael
Hoffer I'm from Germany and it's my
pleasure to be here and to talk to you
about next-generation 3d modeling in the
cloud
so the agenda of today's talk is we go
through a few historical motivations
about how programs were developed a
couple of decades ago and then we will
explore visual programming performed at
runtime and compiled time so there will
be an explanation about meta programming
technologies that you can do at runtime
while the program is running and at the
compile time so you would do the
creation process of visual programming
environments while the compiler is
running and then we go briefly through
the 3d modeling because this is a nice
application for visual programming and
from the description of the talk you
might have guessed that we are talking
about the future of ideas also and if we
have time I will show you the prototype
of this IDE
running in the browser via J Pro so it's
a java application originally you
wouldn't for the desktop but it also
works in a server client environment and
then runs in the browser so a lot of my
work at university as a scientist is
motivated by this quote from Donald
Knuth he is a famous computer scientist
and he said an algorithm must be seen to
be believed and the best way to learn
what an algorithm algorithm is all about
is to try it so that's exactly my point
so future IDs should be a lot more
interactive and should be a lot more
friendly to actually keep developers and
users together so that they can
communicate about the actual program and
the development so now a few historical
motivations how our programs developed
decades ago I mean most of us in this
room are too young to remember that from
real work at least so maybe you've seen
those punch cards in museums
editing programs was not interactive at
all like a couple of decades ago people
would prepare these punch cards not even
on the same machine where the program
would run eventually and then after that
you had to load the compiler which is a
completely different step not like
nowadays where the compiler actually
expects all the program while you're
developing and then only if you were
lucky enough to get a working binary you
could run the program finally but that
were three distinct phases like three
stages in the development process that
were completely isolated just because
the technology couldn't run all of those
together um but the point is the
compiler actually contains useful
information that you can use for more
than just compiling the program and
that's also one important thing we will
discuss later on and of course there is
an exception we use the compiler
information like the abstract syntax
tree for giving some intelligence in the
program and do syntax highlighting and
that kind of things but actually for the
end user these information is not used
at all so how many of you are
programmers raise your hands a few
programmers are there so you okay
perfect that's great and I don't know if
you're familiar with those visual
programming languages that I will show
you here these are just brief examples
of programming languages that were
invented for developers but this is not
something that an actual user would use
this is just real program environments
most of all like domain-specific
and it's certainly like LabVIEW is a
very popular one except for also a
couple of decades that it's nice for the
type of PS else we need measurement
devices and like electrical engineering
stuff and the scratch of blocky ones are
good for introducing to programming but
they don't scale so you would never
write a real big application in scratch
or blocky or that kind of environment
and then there is some structured
editing approaches it's called green
foot stripe this is also rather new
editor that tries to reduce the errors
that you can make in the environment but
also only developer focused even much
earlier there was um
somebody his name was Sutherland and he
invented a visual programming language I
think it was in the late 60s like 68 or
something and he actually already had
the idea of having an environment that
users could use while they were actually
programming without knowing that because
this is just a visual representation of
a program so I like his ideas and I
think we should sometimes look back to
see what people already came up with so
now how can we do visual programming how
can we implement environments for visual
programming as I said earlier there are
two different approaches there is the
runtime approach and a compile time
approach that we will discuss the
runtime approach works like this it uses
the so called reflection API to
visualize automatically visualize any
java objects that's running in certain
JVM and that can be used to
automatically give user interfaces for
API and give users the possibility to
interact with them so that's the runtime
approach you would normally use the
binary object code or byte code in Java
to do that kind of work and then there
is
another way of doing that you use the
intermediate representation that is
inside the compiler it's called the
abstract syntax tree and instead of just
throwing that away you can also use that
to automatically create a user interface
and communicate by instrumenting this
abstract syntax tree communicate between
the source code the actual program and
the end user so let's look at the
runtime approach so that I developed a
library called literal reflection
library and it is a framework for
automatic code generation and this means
that you can just specify the
functionality so it's kind of
declarative you specify the
functionality that the user interface
should have like in this case adds two
numbers and then you get the user
interface automatically and it also
allows you to do some kind of workflow
management and allows you to do visual
programming by specifying data and
control flows between different
components so now let's concentrate on
the visualization part when you look at
ordinary source code you will see
something like this it's a lot more
complex to just take the input from the
user add those two numbers and return
the result and as an experienced
developer you will probably notice that
this is done wrong I mean you could use
design patterns to introduce separation
of concerns like Model View controller
and it would look much cleaner than this
mess over there but when students start
programming they do something like this
because they haven't learned about
design patterns yet and certainly you
have to be an expert in either swing or
at least Java to figure out what's going
on here because I mean of course at
like line four or something it says add
integers but still you don't you don't
follow the functionality of the program
but in the code example on the right the
small one it's pretty clear even for a
non programmer to see what's going on
you just say hey I have one method and I
add two numbers that's it it's pretty
clear and you don't have to add any
binding to the user interface because if
it's done automatically you don't care
and that's also the point that you can
switch user interfaces and also you get
validation and all that kind of stuff
that is not covered in this simple
program which looks complicated even
though we just want to do some simple
calculations so how does vrl accomplish
that between the java objects in memory
and the user interface is a so-called
object inspector and it has three types
of visual representations for api so
there's one object representation it's
just a container for methods that you
see in the middle like the method
representations and then there are the
type representations on the right and
type representations that means you have
a visual representation for certain data
types and they can depend on your actual
domain so they can be different and by
that you can compose really nice
interfaces from just very little code so
here's an example for a color chooser
you can just the code here on the right
if you write that in vrl it will
immediately give you the left-hand type
of rotation and this can be used by by
ordinary end users so there's no need to
make a distinction between the developer
who wants to have a nice representation
of the code for debugging for
prototyping and the end user because
this actually is fine people can use it
and then there is um
for example 3d visualisations you can
defined point in space as triangulations
to that and return that and vrl will
figure out okay this is a 3d
visualization I will give you an
interactive OpenGL Java 3d or whatever
kind of component that you can interact
with and this also works for other
complex applications so at University we
do also all kinds of scientific
applications this one is from
neuroscience so this is the
visualization of protein distribution in
brain cells just to show you that
actually but just very little source
code and by using libraries you can come
up with nice user interfaces for certain
domains and yeah after that after
finishing with URL I developed them we
developed at University IDE called vrl
studio which you can use for teaching
and learning but also for actually doing
pretty nice applications for all sorts
of things you just have to have a Java
API and then visualizations for your
data types and there's a plugin system
that allows you to develop those so if
you're interested on the webpage we have
also all the features covered it's all
open source I will give you a brief demo
this is a call to so the canvas and
let's just add some source code to it
this is our our world
let's say hello Tokyo I can compile it
and instantly create an object and you
get this visualisation out of that so
there's no need to actually do the UI
programming yourself everything is
composed for you and you can of course
also request different visualizations if
you want to but even the default one
works nicely for most cases so here is
the example we just add a and B and we
just ignore this code here is just for
sterilization purposes we don't have to
cover that right now let me compile it
create an instance and here we are we
can add two numbers
and it can also create a new instance
and you can define a data dependency
between those two components we have one
to it and to get the result and it also
works by evaluating all the dependencies
that we have declared version with just
this one it will invoke the dependencies
as well and a very nice thing about this
environment is also that you can always
access the source code that defines the
user interface so you can just click on
any component actually here with what's
your insight all about you know you can
just click on the three buttons and you
see the source code that defines this
component if you do this with your
regular browser email program or
whatever it's going to be hard because
you have to download the source code you
have to go through various build steps
which are complicated and you're not
instantly told what does this part of
the program actually do yeah and 3d some
example as well like this just compile
that it takes off just a little bit more
time any when it's done it looks like
this so it's pretty easy and instead of
just writing the nodes here you could
just load them from anywhere do a
complex calculation to perform the task
and after all it's just an annotated
Java or groovy API that you define here
and you could also visualize external
API s as well yes so that's about the
demo um also Bureau Studios open source
there is also a shell environment so I
started the development before K shell
was announced so it is a groovy shell
that serves the purpose quite nicely so
you can actually even add
let's let's try that doc do you see that
no you can't even see so there's some
problem with the screen I just explained
it so you could type in the cell
environment and then you can also show
the visualizations on top so you could
just tell it to instantiate any kind of
object that's reachable by our class and
module path and then visualize it and
interact with it as well
okay now back to the slides so now we
have seen the runtime approach how that
works now let's have a look at the
compile time approach because the
runtime approach covered nicely API
visualization so the public API could be
visualized without any problem but how
about the actual control and data flow
this is something that you would have to
do manually like we did which is that
this is the data dependency between
component a and B and we can do better
by using the so called ast and the way
we do it we take the ast and introduce
an intermediate language model for that
and this intermediate language model
communicates between the user interface
and the ast or the source code so the
language model can also be used to
describe programs as data structures so
you can have algorithms that operate on
those programs and manipulate them and
that's what we do to add all sorts of
instrumentation and also for the UI
generation this is actually just you
compile the program first then it's a
data structure a language model and that
is being processed by some algorithm
that manipulates that language model
instance and the language model is just
a nice API that you can work on like to
declare compilation units classes or
invoke
loop's and so on and the goal of that
would be a language model that looks
like this so you have the source code
representation on the left hand side and
the actual runtime data on the right
hand side so the way we do it is like
this so we have the language model in
the center it's the most important part
and the compiler there is divided in the
compiler the editor the compiler in the
actual compiler back end that writes
java files to the file system in the end
the language model takes the ast is
input so there is one transformation
from is T to a model and the model can
be translated into source code again and
that's used by the instrumentation
algorithm so you see two versions of the
same source code like on the left hand
side we see the compiler just the one
static method returning two plus three
on the right hand side in the
instrumented code box you see the very
same functionality but instrumented and
it will generate events for the user
interface so that the user can actually
see the intermediate data the user
interface has a binding between the
language model and the UI so whenever
you change the user interface the
language model will be changed as well
and that will trigger changes to the
source code again so you can see the
source code representation and the
visual representation at the same time
yeah and then the instrument
instrumented source code can also be
written back to the file system so the
Java file actually contains the
instrumentation if you want to if you
want to your code to perform better then
you can just leave out the
instrumentation where it's not important
and since it's a language model-based
instrumentation we also have the
advantage of translating into other
languages without relying on the
instrumentation capabilities of the JVM
itself but we are free to actually
export the language model to different
languages which might not have HIV M or
other kind of compatible runtime so now
let's have a look at the visual design
language here I don't know if I can't
really lumen then I will just show that
in the life example before we proceed
okay I don't have internet it's bad
because then we don't see the actual
cloud example that I want to show you
later so I try to connect again
so what we are trying to discuss is the
actual visualization of a sample program
that generates 3d geometries and that we
can print on a 3d printer as we have
shown in the demo area so let me try
that passwords over there
okay seems to work now let's see whether
we can run that so at the moment I'm
showing you the client version of that
it's just a client desktop application
so if you see here is the compiler at
work so it actually just started to
compile the source code on the left-hand
side and gave us a nice visualization
and the visualization on the right-hand
side can be used to actually visualize
the runtime data as well so I'm just
trying to make it a little bigger for
you and we can also zoom in when I
select the source code it will select
the visualization as well so it's really
goes both ways and let me open up
another window like this one here you
will see a method call and if I am going
to change values here let's just say I
want to change the radius from 0.65 to
something else the source code will
update and the same thing will happen if
I introduce new functionality to the
source code let's just introduce a class
called a and it has a method
for method like this
and the compiler will give me a new
component so we open let me see
yeah it just saw that we we can add I
don't know how much you will see here
because it's rather small but you you
notice that there is another component
which doesn't have functionality in it
right now maybe like soo min so like
this and we have another method call
that also has this declaration and so on
inside and I can also close this here
and it will close the actual class it
will delete it again so now it's gone so
we can go both ways you can just develop
textural in the textual environment or
in the visual environment and you can
also run the code directly and it will
give you all the intermediate data so
everything you see here inside it zoom
in again and you can interact with Elvis
everything so there was just the Java
API that we used to develop to design a
3d geometry and this interface for
example could also be used for just an
end user if it just type in the numbers
and you could think of more complex
examples in for real production code and
the user could just use this environment
here and without the cables and still
actually when you save your project it's
just source code and developers could
improve that source code and hand out a
new version and the user interface is
going to be developed automatically or
you could think of like taking out
components and designing a front-end in
a layout designer or something but still
the actual program is all visualized
let's look at this method here it's
called create difference and it pretty
much explains what the method does it
just takes a cube and a sphere and it
computes the difference between both
geometries and then returns the result
so even if you don't have that
you can still kind of follow what the
actual method does and you can debug it
so because I mean think of it if you um
the radius of those geometries is wrong
and they don't intersect in the way
you're you want them to because it's
probably something you want to design
something nice and beautiful a debugger
would never tell you whether you're
wrong or not I mean because the debugger
just tells you about like the raw
numbers inside it doesn't do any really
sophisticated visualization of your
program tool and what you also might
have noticed is the fact that everything
here to get a unique color and this is
what we do to visualize code coverage
and also some kind of profiling so we
see the axle that the different
operation here consumes the most dpu
time which is kind of logical like
creating the three objects is not that
hard but doing the actual geometric
calculations is much harder and then you
can also tell the user I mean which
parts of the applications were like
hungry and which were not so they get
some kind of feeling for that so without
having to use like a clip or any other
complex IDE to track down the
problematic areas and also cover it if
they just run certain parts of the
program will give them kind of a feeling
for which part of the code are actually
relevant for the program in which part
parts are not so that's the idea behind
that
it's just another example of kind of an
adaptive profiling everything that you
can visualize gets profiled and
everything else isn't profiled for
performance reasons because then you can
profile a few things at one time without
slowing down the whole program so and
one application for this kind of user
interfaces for me in research was 3d
printing so like performing 3d modeling
and software is great for designing
patterns like I mean I should have one
with me you might have seen those it's
like a triangular pattern that can move
and you can also come back to the booth
to see that and also bigger ones like
this ones and designing patterns with
code is really simple if you are a
programmer and so 3d printing them is an
interesting technology that opens new
possibilities because these parts you
are actually moving and they come out of
the printer like this so if you would
subtractive you would use subtractive
manufacturing for that it actually
wouldn't work you would have to assemble
those pieces you couldn't just print it
in one piece and it could still move so
just briefly the difference between
additive and subtractive manufacturing
is like for the subtractive
manufacturing you have raw material and
you want to cut out a certain geometry
in this case just a simple deliverer and
then you cut out the material and you
have a lot of leftovers from that so you
waste a lot of material but in the end
you get a nice finished object from very
solid yeah very good material properties
but there is another way to do that to
use a so-called filament plastic wire to
add up the object layer by layer and
then you get an object you can have even
holes inside which
compatible with the other technology
before 3d printing was introduced yeah
here you see the 3d printer in action it
just prints a small piece for robots I
won't run the whole video I mean we have
a 3d printer here if you are interested
and you might have seen that elsewhere
okay so this is um how the pattern looks
like if you run it put it under an
electron microscope so this is a really
nice pattern there it really looks like
the visualization on the left hand side
so this was just a small tool that we
analyzed for materials properties it's
just one through a few samples and yeah
I mean 3d printing was used even in the
80s I think but it was only used it for
industrial processes like to him have
in-house tools that were rapidly
produced but only since a few years it's
really gaining popular attention so the
public gets interested in it because it
gets getting cheaper and we have
applications interesting medical
applications and IOT related
applications and yeah you can also build
robots and all sorts of cool things
before for Hobby purposes so there is a
platform called thing worse and it has a
lot of different geometries there so if
you're interested in 3d printing you can
just go there and we also put up a few
pieces there for like building robots
out of raspberry pies and other you know
devices and so on yeah so that's about
3d printing we use the environment that
you've seen before for the actual design
process and yeah but we are also want to
move on to like having a more flexible
architecture and I did an interesting
test that I just want to briefly show in
the end and how can you run in salivex
of the cloud and there's one product
called
J Pro but actually translate the Java X
scene graph I mean traffic is just a
desktop technology and it's translates
the scene graph and allows us to connect
with the browser so everything will be a
nice SVG see graph in the browser and
the program looks almost like that
that's the one and performs really
nicely as you can see this is just to
tap one of my is many tabs in the Chrome
browser and this is the very same
application that we saw before
so I can just select source code again
and I can run the program as well so
we'll just take some time and it will
show the the geometries here
so that's pretty cool I think because
you don't have to change your actual job
of Xcode and you can run it on mobile
phones than any kind of mobile devices
and you just run the rest of it in the
cloud and I think this is really nice
because then people can use the tablet
to participate in like generating
geometry for example I've talked about
things worse before and then you could
add like an editor two singers that
allows you to write the algorithm change
it and then download a changed file and
you could run the process all over again
collaborate and yeah that's what that
idea so it's like a more complex version
of editors that you know on pages like
get up they have also syntax
highlighting and so on but you could
even use a visual editor for that
purposes yeah so I want to thank you a
lot for attending this talk I show you
some resources there I mean there's zero
studio if you are interested in that
type of development my name is MIA soft
and I I just learned because it's my
first time in Japan that me oh is a
popular name in in Japan but I didn't
know that in Germany it's just a
shortened version of Misha Hoffa you
know we just used assortments for that
so that was
funny story there and I'll also publish
my source on github slash meal there you
will find all the source code all the
examples that we went through and I
would like like to ask you whether you
have any questions that you want to ask
about the visual programming the 3d
printing or anything else don't be shy I
mean we have a couple of minutes
yeah so you you go by with English okay
you have a microphone yeah that's
perfect
used two different environments to
create the visualization like one on the
localhost and one on these yeah so the
one that we saw in the beginning was a
swingin application it's hard to part
with a browser so that's a local
application
do I have to click a button like that
after i download vrl can I access it
directly like how did you create that
nice with the source code and the advice
no as well the the first environment let
me just go back to that with this one
and this is the desktop application you
have to download that before so you have
to download that and then work in that
environment and then the one where it
was in your Google Chrome browser yeah
that is the other one so I have the
source code on github because I'm a
researcher you know as Auliya people can
build end-user applications from that
and this one you can run in the cloud of
course you would have to run your own
cloud instant at the moment I mean I
have a small version running in my my
cloud instances but then you can just
navigate to a specific link and then you
get this interface and you can work with
it in the browser and it also works from
the phone so but I don't have to have a
server set up right here
so you cannot try immediately so if that
is I can only get this rate
right right here you can only get this
the other one if I'm github I mean it's
a research project there's a source code
and you can run it and then on your
computer and then use it on your phone
or tablet or whatever okay got it yeah
any other questions
okay if you don't have questions you can
also come to the demo booth if you want
or I'm running around for a couple of
hours probably and yeah we can have
private discussions as well if you like
so then thank you very much for your
attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>