<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Development Operations in the Cloud  A Use Case and Best Practices | Coder Coacher - Coaching Coders</title><meta content="Development Operations in the Cloud  A Use Case and Best Practices - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Development Operations in the Cloud  A Use Case and Best Practices</b></h2><h5 class="post__date">2016-09-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cHKtarV9aQI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone so thanks for joining before
we start I want to thank all the folks
over here on the Left giving us AV
support that was that got really
interesting really quick so thank you
thanks guys over there for getting
everything resolved my name is Greg
stack Nick I'm product manager in oracle
and i'm joined by jeff stevenson he's a
development director and we work on the
same product together the Oracles
developer cloud service so today what
we're going to be talking about is
DevOps in the cloud and we'll be talking
about use cases and best practices I am
we are going to be it's a very demo
oriental session so we'll talk about
we're going to show you some things that
we're working on that are not released
yet so you'll see some roadmap things
some unreleased stuff you'll see some of
our real source code as part of these
demos so you're safe harbor statement
just saying that you know what I'm
showing you is a lot of it is kind of
upcoming stuff so the what we're going
to be the order of events that will be
talking about is first what are the
challenges that development
organizations are facing and why am I
they consider cloud services or cloud
providers to host their development
infrastructure I'm going to talk about
our service a little bit it's not really
a product pitch is just to give you a
sense of what it is that we develop and
then I'm going to hand off to Jeff and
he's going to take you through our
development practices and some of the
lessons that we've learned doing
implementing continuous delivery
implementing DevOps and kind of give you
a sense of some of the tools we use and
how we do monitoring and performance
analysis that kind of stuff so it's
going to be a little intro a little bit
of our product and then a lot of
examples so the goal is development
teams and probably more the goal for our
managers is they want us to be able to
release release more release yesterday
release more often and do it productive
do it cheaper do it more stable I mean
so there's a lot of ways that we can
achieve that a lot of our a lot of teams
including our team
move to agile so that we can shorten our
release times and be able to produce
products more quickly and then also
DevOps so being able to kind of merge
some of the responsibilities of the
development team and our operations
group so that we collaborate better
together so it's not just we hand off
the release and then it goes into this
black hole and then someday it shows up
in production so if you think about
challenges especially if you're doing
on-premise development just a show of
hands how many of you are currently
maintaining all of your infrastructure
today your source control your disks
your build servers all that kind of
stuff so quite a few okay so you and as
you know and as we've seen internally
with Oracle whenever we're going to
start a new development project and we
don't have the infrastructure it'll is a
long process right we need to put it
hardware requisition need to order
software we need to figure out which
components that we're going to use in
which versions once we get that hardware
we need to find a data center for it to
live at least from us that process of
acquiring the hardware getting it
installed and actually getting someone
to maintain it for us in our data center
can take months and so that's typically
one of our biggest challenges is just
getting that physical infrastructure in
place the development team will start
working now in addition to physical
infrastructure there's also kind of the
team interactions and how we want the
team to work together to be most
productive there's a lot of development
methodologies I've worked in other
groups with within Oracle that followed
a waterfall method where you know we
were just building these long release
cycles and delivering products like once
a year once every 18 months there's
other methodologies like agile where
you're doing scrum or conv and stuff
that can shorten those cycles and change
the way that development teams interact
and we'll be looking at a little bit of
how we do that
let me get into Tibet def process but we
also need to have tools to help us kind
of understand what is it the developers
are working on what collaboration tools
do they have and also kind of what are
they doing to streamline deployment so
in terms of specific infrastructure
pieces you know we need to think about
how we're storing our code so what is
the version of every using version
management and if we're on premise it
might be fine to do a centralized
version control like subversion but if
we're distributed we're working on an
open source project most of our
customers are using git because we're
disconnected you get the whole
repository on your on your laptop or
your desktop machine you don't have to
worry about synchronizing to a central
server all the time how are we doing
testing what are the frameworks that
people are using if you're using Java
development or you might use one set of
tools if you're using you know
JavaScript or node a different set of
tools pythons a different set of tools
so what's based on our experience and
languages where the tools and testing
tools are going to use and then how are
we going to do automation are we doing
continuous integration continuous
delivery we just do a cron jobs so
there's a lot of options out there and
then in terms of team infrastructure
what how are we tracking our development
tasks are we using a system like a JIRA
or a bugzilla to track tasks if we're
doing agile are we documenting our user
stories and organizing them into epics
and so there's a lot of questions that
we have to ask there and so as part of
that automation is really important how
many just out of curiosity are doing
continuous integration today all of you
awesome so continuous integration can
start very simply where we're just
automating our builds up for every check
in and running some local test maybe
automating our unit tests so as how many
are moving toward continuous delivery
where every check-in can produce a
release great love actually quite a few
okay so that's what we're going to show
you as well as how we've been able to
implement
within our team and so the idea then is
that we're not only just building our
your file or father in your unit test
but then automating our higher level
testing our deployment and making sure
that after any given check-in that we
could be ready to release off the master
so the ideal solution for an on-premise
environment is something that you know
we can in a reasonable amount of time
get the hardware available configured
with an IT staff and with some
components that hopefully work well
together and the reason why a lot of
companies are looking toward a cloud is
instant access ease our provisioning and
you can scale out very quickly there's a
lot of cloud providers that offer
development infrastructure amazon
through stanback better amazon has tools
um you could use between their code
commit and code deploy cook pipeline
Asher has a whole set of continuous
integration products and code management
you can get things from IBM with bluemix
what are the some of the other ones JIRA
jira there's a hosted gear where you can
get the whole atlassian sweet what we
provide and this is where I'm going to
give you a bit of a product pitch is the
developer cloud service it's a free
service that we provide with Oracle
cloud and it's just giving you your
DevOps and agile tools and so when we
think about the release process or
development process what we're providing
with our service is the ability to
manage your issues and user stories and
epics work them into spritz if you're
working in a scrum or conv environment
automate your building test cycles so
that if you're using your Java developer
you integrate your unit tests your
static analysis code scans your higher
level tests with selenium things like
that different set of tools if you're a
JavaScript developer and then ultimately
giving us collaboration tools and I
think Jeff will be showing you how we
use the collaboration tools internally
things like code reviews so we're
developers are working on a feature but
before they're going to
that feature branch into master or into
a release branch they want to get
feedback from their teammates in their
manager as to whether what they're
working on is satisfying your the
requirement it fixes the bugs that kind
of thing and so Jeff is going to show
you how how we use that internally and
how it has made us higher quality more
productive our service is polyglot so we
support a lot of different languages a
lot of utilities that you might be using
if you're like a node developer java
developer python PL sequel all those
kinds of things and i'll just show you a
really quick intro to our web interface
we also have integrations into the some
of the common IDEs like eclipse and
netbeans and jdeveloper we also have web
hooks so if you had a third party
service like JIRA or slack or hipchat or
any other of these kind of an external
service we can connect to those with our
web hooks so let's just take a look at
how the environment works so then when
we show you how we develop the features
you'll kind of get a sense of what that
what the end result looks like okay so
I'm in my service this is a multi-tenant
service it's free so anyone that comes
to the Oracle cloud gets this dev
environment and so I'm going to create a
project so in our service a project is
basically a team work space so it's all
of the code off the builds all the team
interactions
so we're making a new team a new group
space for everyone that's in this room
we're all going to be can all
collaborate together and so as we're
going through this I may want to sample
some sample code so we publish a lot of
sample code that you can just populate
into your git repositories with some
sample builds and some sample tests so
you can learn other kinds of concepts so
I provisioning and so what happens now
is we're just created an infrastructure
for you so we'll see that create a
dedicated maven repository so you can
push your binaries will create issue
tracking system so you can manage your
user stories and epics and development
tasks get repository build system so our
build environment is based on Hudson so
it's a dedicated Hudson master we are
responsible for the uptime the
maintenance you just define the build
jobs and then we will take care of the
the running on the execution of those
build jobs around your schedule you can
scale those out scale them back to to
meet you know the load that you expect
let's see what else the code review
system is being provisioned so it
usually takes about one to two minutes
to provision this entire team space and
compare I can think about what we've
what we have to do internally like if we
want to get a new server for our source
code before we started using this
internally and it could take as months
and instead we're within two minutes
we've got everything for our team and so
then maybe I want what I want to do is
just start to invite some of the
teammates so Jeff will come in into this
space and him and this is connected to
our ldap so anyone within the Oracle
network can get added to these projects
and so then what I have are a number of
different features so on the left are my
activity events and you'll see our real
activity stream that we use for this the
project that we use to develop but this
is giving us a sense of what's happening
at any given time so as a development
manager I may want to know who's been
checking code in who broke the build did
our deployments succeed did someone
update their requirements document all
those kinds of things are captured here
is
events so I see that you know we made a
check-in into our master branch so I can
go and take a look at that very quickly
and then we have a static view of the
repository so we can browse in take a
look at you know what the code is what's
the history of the code you know get
into the commit history get into oh look
at individual lines of code in which
commits they came from and then also we
can do things like branching on the fly
and do ad hoc doof's so here maybe I
want to go back into the repo and I can
go in and make a branch so we can do
some feature work this is all web-based
interface of course it's also available
for any get client within your IDEs
whatever we also may want to make you be
an issue so let's just say create create
the space I'll sign it to me maybe this
is really light just one story point
and so then we've got an issue in here
maybe want to add that into a sprint or
something so we have some tools for
agile so you can take your backlog we
can organize them into Sprint's dip bird
down charge progress reports all those
kinds of things so we'll create a sprint
around this I only have one issues or
one user story so it's pretty basic
start this yes yes so we support either
time or story points so you can do hours
days and then we can constrain your
sprints based around how about whatever
you say so that you don't take on too
much for a sprint yeah I thought I
called the sprint one now they're you so
just add this in here start it say we're
going to end it in two weeks and then
we're off into our active sprint board
so then what we see is that you know we
have different states all configurable
call it whatever you want and add more
states move them around to the progress
and then you know for a more for a real
spread then we seen burn down charts and
reports and stuff as useful so you know
who's been fixing their bugs and we do
take care of you know weekends and all
those kinds of things the build
configurations so as part of the sample
app I did include a bill job so that you
can learn in this case this was about
building a Java app that's going to push
to a docker container but you can see
how the how the builds work so this is
just a very simple build job it's maven
based and if you're familiar with Hudson
or Jenkins it's just a different
interface that we did it we we have our
own JavaScript framework called Oracle
jet that all of our cloud services use
so that we have a consistent look and
feel we just reimplemented the server
using the that look and feel but you
know we're just going to build off of
master
add some build steps we support multiple
build configurations we can script
whatever we want but then ultimately it
skewed right now so it's just waiting
for an executor it'll run and then we'll
save the results back to our cloud
storage and anything that we build we
can deploy so Oracle cloud has a lot of
different types of endpoints that you
can deploy to Java node docker
containers mobile apps and so this is
just giving us a way to set up automatic
deployment rules so that you know if I'm
developing an application am I might
want version one to go to a European
data center version 11 to go to a US
data center continuous deployment to a
pre prod environment all these kinds of
rules can be set up so that's a just a
basic overview of the of the service and
then I'm going to hand it over to Jeff
to talk about how we develop the service
and some of the lessons that we've
learned working on this for the past
what is it three years now holy cow any
questions while we switch laptops yeah
today it's only in our public cloud it's
free so if you have an Oracle cloud
account this comes with it we do Oracle
does have a on-premise cloud but our
service is not in there yet
alright I'm Jeff Stevenson as Greg
mentioned earlier I'm the development
manager of the developer cloud service
and Greg asking to do of a talk about
how we actually use the service to
develop the service we weed our own dog
food and in the process we've
established a process that we like to
thank include some best practices and
I'm happy to share those with you guys
today so a little bit about our team and
how much we use the service we developed
so we we have the whole developer cloud
service in one project like reg showed
you earlier you know we created a
project it took a minute or two so the
whole developer cloud service is
contained in that one project and I'll
show you that in a second it has 40 git
repositories one binary repository for
storing our built artifacts and the
artifacts that we need to build against
that's about 170 people on the team and
about 50 which act actively contribute
code on a regular basis the other
project members are you know other than
developers include things like QA and
documentation for example we do about
200 commits a week and we do about 50
builds a day if that seems like a lot of
builds for 200 commits a week that's
because a bill it's not just building
the code but it's also maybe a belt is
deploying code maybe a build is running
functional tests maybe but a build is
running unit tests maybe a build is
monitoring deployed software so we use
builds for a lot of purposes Hudson and
Jenkins are very flexible in that way
and so you know these are all
continuously dealing with our our code
as it's being developed and I also said
being you know monitoring our existing
code we have to date about 21,000 issues
and 250 wiki pages that are part of the
project so i'll show you our project
here
what's up oh how many unsolved issues I
don't have that number but i'm sure
there's over a thousand if you know how
it is that a development project not
every bug that someone files is you know
becomes your top priority but we try to
figure out and fix the the ones that are
the most important there's some
resolution issues with a projector so I
apologize that the resolution is not
quite right here on the projector but
hopefully you can get an idea of what's
going on so this is our developer cloud
service project and over here on the
right you can see that big long list of
40 repositories that I was mentioning
before and in the middle is our activity
stream where you can actually see real
people doing real work so hey we've
gotta build running that's updating one
of our staging environments with some
new code let's see a task has been
updated Matthew Hawkins push to commit
you'll see him again later lots of
builds succeeding some builds failing
maven repository being updated with
binaries and so on and so forth so this
is the tool that we used to collaborate
on the code and I want to show you a
some real work actually happening real
time so I got this email this morning
from the system and it says Matthew
Hawkins has requested that Jeffrey
Stephenson reviews code changes made on
a task in the code cloud server one of
our git repositories and see here we
have links basically off to the actual
code the branches and to the merge
request ID so I can actually go and back
in the system here I could have followed
that link but just to show you here
merge requests look at all the open
requests sure enough here's the one
deadlock caused by rejected project
build blocker that looks serious
so here matt has described the issue and
I might want to look at the link tissue
the actual bug that was assigned to map
to face so right here in the code review
tool there's a link to the issue that
was filed against the developer to fix
so I can click on this issue and I can
see what was the problem okay so the
problem was there was actual deadlock in
our real code in the Hudson area and
we've captured a trace from the JDK
indicating what the Java level deadlock
is and then down in the issue here we
see it was followed by one of our
developers Roy you pulled out some
interesting parts of the trace and then
they've analyzed the problem and that
here is submitted to merge request and
that's when I got the email that said
there's something for me to review so if
I go to that merge request I could read
matt's description of the fix and i read
it a little bit a bit earlier basically
what happened is that when Hudson calls
down into a plugin it often has a lock
and if this method was also using
synchronized block and there was a lock
order deadlock between the lock that
Hudson held when it called us and the
synchronized block so mad has proposed a
fix here and I can see in the system I
can go look at the commits it only
happens to be one commit but I could
show the details of the commit and this
is the interesting thing that changed
files so if there had been multiple
commits it would have collapsed all that
down and showed me everything that the
developer is proposing to merge into our
patchset 1641 branch so here I can see
what Matt actually did and I can see
that he's changed the handling of this
rejected projects set that used to be
that that rejected project set was
created lazily inside of this get
rejected projects
and it was a synchronized method and
that was one of the locks involved in
the lock order deadlock and now i can
see that instead what he's done is in
these green lines which hopefully show
up on a projector he has instead created
the synchronized set in the reed resolve
method which is a method that's not
going to be called by hudson which is
holding the lock so if I want to I can
go and and approve this request if I
like the way that this looks or I could
I could comment on it that would receive
an email with those comments and he
could make further changes and then push
those changes to this branch and then
that merge request would automatically
get updated with the new commits those
change files had show his changes and I
would get an email saying he's made more
changes but actually like the way that
this looks and what also makes me feel
extra confident here is that I see on
this right-hand side linked builds
success so one of the features of the
system that we use is that you can
associate a bill job with a merge
request so not only do you get the
satisfaction of a human having reviewed
the code but you can also enforce
whatever your development teams policies
are around code quality for merges so in
this case this job builds the code built
the branch under review and it also runs
the unit tests and so I have that extra
confidence knowing that the system has
already validated that the code at least
builds in the test function so this is a
real deal merge request and this is
something we actually need to do and I
feel confident here I can go ahead and
click the merge button here I can choose
if we want to squash the commits so we
have a policy on our team that it may
when developing a feature you know you
may develop a feature over a month and
it may involve lots and lots of commits
but when it gets on to our main line of
code we want only one commit which
represents that that new feature so
typically we squash the commits and I'll
also tell it to go ahead and resolve the
issue that was filed against Matt and
there's a there's a sample commit
message
you're saying that we're merging this
fixed end and a link to the defect so
that also in the commits comments
there's that that comment will be there
yeah
through here it's it's all or none you
could do that by so it's a little bit
tricky because these commits you have
you've at least push these into the
repository on this branch under review
so what you could do is you could create
a new branch and then you could squash
the commits into those two sections and
push those to the new branch and then
merge that that'll be one way to do it
you have the full power of gift but in
this tool it's it's all or nothing so I
went ahead and actually merge that and
now there's a record in the system that
that's merged and if I were to go back
to the activity seeing stream I would
see that all of that happened let's see
here yep that's me Jeff Stevenson close
that review and then we're also going to
see a commit out at by commit and the
system that we could go and click on and
if we go back to the actual issue
bear with me one second
we would see that the issue has now been
marked as resolved and the merge request
is automatically updated the issue with
links to all the commits and back to the
ridge request and involved branches so
that's part of the system there's a code
review for every change and in the
slides here that are attached to the
presentation basically goes through that
process of the developer getting
assigned to bug doing a get transaction
to push a fix for that bug submitting a
merge request reviewers getting notified
the submitters getting notified of
comments the link build job running they
may need to push additional commits not
an example that I showed you reviewers
ultimately approve or deny their merch
request and then it gets merged in
hopefully and that link tissue
automatically gets closed with the
result of that merge request but that's
not the end yeah go ahead it works so uh
yes so yes yeah absolutely so um so what
this system will do is that merge button
there you won't be able to click that if
there are merge conflicts and it's up to
you to use standard get tooling a
methodology to fix those merge conflicts
so that's one reason why you might have
to push additional changes to the review
branch is because you need you may need
to manually merge with the latest on
your development line to fix conflicts
once that merge request actually goes in
then that automatically triggers
continues continuous integration
continues deployment that's
automatically going to trigger another
built so if you remember the the merge
requests already built the branch under
review so we we know that those changes
at least on their own compile and pass
unit tests but now it's going to get
merged into that patched at 16 for one
branch or maybe our mainline master so
in both cases we have build jobs that
are automatically
going to trigger a new build of that
special branch the tip of our
development line or passionate 16 for
one is our release that's about to go up
and that's going to produce new binaries
and it's going to push those new
binaries into our maven repository if
that build fails again the system will
notify the developers via email that the
bill failed so they can go and check it
out if the build succeeds and updates
are maven repository with those binaries
twice a day in this case of this patch
set 16 for one branch we take our latest
code of all of our binaries from all of
our repositories everything that's
passed on that branch and we're going to
actually use the belt system to
automatically update a staging
environment with that new code and if
that succeeds then two things happen one
is that our QA get an email saying that
there's a new bill that's been deployed
and they you can see that the fit there
there are fixes now that are marked is
fixed by the developers but that haven't
been reviewed by QA or verified by
queuing and then now they can
automatically get that email and go and
verify those bugs in that staging
environment the other thing that happens
automatically is we have automated tests
we use selenium for functional testing
driving through the browser and we also
have rest based tests and that's going
to kick off the automated tests again on
that branch so what's nice here is that
somebody filed a bug a developer got an
email they fix the bug they submitted a
merge request I got an email as a
reviewer the merge request I reviewed it
here live before you and I click the
merge button now automatically a build
is going to take that update our
environment notify QA and they're going
to fix it they're gonna they're going to
validate that fix and then it's
automatically going to you know run all
of our test Suites so at the end of the
day without really you know much
coordination happening outside of the
system you know we're going to have that
bug fixed and a bill done and you a
verified and automated test passing and
we can take that build
and then promote it to our you know
production or staging environment so
what about a day in the life of a
developer service manager so what do I
actually you know do all day so in the
system as greg was showing you we have
agile planning tools so we can assign
bugs into Sprint's a review merge
requests like i showed you here and then
actually also manage the branching of
the system so we do a release about once
a month with new code and then we also
do periodically if we need to fix a bug
like in a you know in a hot fashion for
a production customer we might need to
go and do a fix on top of one of our
release branches so i cut that i cut the
branches and one of the things that i do
is impose the rules on those branches so
here on our system if i go back here to
administration I I can see there's a
branches tab here and if I look at the
the ranch we were just looking at for
our release that's about to go out
that was our patch set 16 14 16 for one
branch
this release is about to go out so I
want to make sure that
not anyone can change anything on this
branch so i'm going to put restrictions
on that branch and i'm going to restrict
the push to only people who have
approved merge requests i could also a
strictly restricted just to the branch
administrators and i'm going to also
disallow force pushing because at this
point in time I don't want anyone doing
anything except for adding a additional
commit onto the end of the line so
something as a manager that's very
powerful to do is be able to impose some
order on some of your branches and I can
submit reviewers here that are required
for these specific branches so if we
have a branch that's already released
and what we're accepting on that branch
is only hot fixes then the bar is really
high so i would need to approve maybe
our operations people would need to
approve but if we have the tip of our
code line then the bar is low then we
might still require a merge request but
just by appear for example
you
so on I guess I didn't understand the
question yes I think I think I just
dangerous question so part of what that
merge request process had associated
with it was linked build job and the
bell job that we happen to use builds
the codes and run and runs unit tests
however the bell jobs are very flexible
so for example if you wanted to I don't
know run fine bugs or something like
that and do some static analysis of the
code on that branch and you wanted to
fail the build and reject the merge
request if they introduce new violations
then you could do that we don't happen
to do that but we could yeah I picked
fine I i picked find bugs out of the air
but yeah sonar is a beautiful tool for
doing static analysis where you can plug
ins for lots of different you know check
style lots of different languages lots
of diff things you can do there and get
a nice beautiful report so you could
definitely use sonar to pull from the
repositories and analyze your code
that's not part of this is not part of
our build process but the like I said
those Mel jobs are really flexible so if
you wanted to enforce some additional
rules you could one thing that I do at
the end of every day is I get should go
and read the activity stream so the nice
thing about using this tool versus what
we had before on premise because I'm
premise before we had continuous
integration systems and we in source
code as well but that the source code
management as well but the nice thing
about this particular tool here let me
is because all of it is under one roof
so to speak and it's all integrated
there's only one place to look for the
sum total of everything that's happened
this day and this this is the activity
stream and you can filter it by the kind
of activity so for example I often turn
off pushes to the maven repository when
I'm reading it in the evening because I
don't care so much about those but I do
want to see people's updates to their
issues to their commits the commits that
happened the builds that succeeded and
failed um and so it's really nice that
you get that single system that takes
you all the way through from the bug
being filed to the build being built and
deployed and you have a record of it
here because when you're doing constant
releases like we are for our cloud
products where we're not releasing once
a year but what's that are we releasing
like I said once a month and we're
releasing hotfix is on top of that we
need to really like clear like chain of
record of accountability on one who did
what so if a customer is facing a bug in
production and there's a bug fix that's
in the works somewhere I need to know
exactly where it is and I need to know
where it is on its way out into
production and so by having everything
trapped in one system here it makes it
really easy to answer those kinds of
questions a couple more points
one of the things we do not necessarily
with the system that I showed you but in
general is we monitor our production
instances and so we actually use four
kinds of monitoring of applications
running in the cloud high level
monitoring where we have a simulated
user logging in and drop driving the
browser using selenium to actually click
through the product make sure that it
actually is working at least for that
particular simulated user and then we
have increasingly lower level monitoring
so we have AB health monitoring there's
a script on all of our production VMs
that runs every 15 minutes make sure the
container is up it sends rest request to
the container make sure the container is
responding it checks other things like
connectivity between VMs it checks that
you know file systems are writable
things like that that we are necessary
to keep our system in working order and
whatever that thing fails again alerts
the development team that there's an
unhealthy server let's also have
operating system level monitoring so we
use Oracle Enterprise Manager to monitor
all of our VMs actually and check CPU
usage memory usage the disk partitions
aren't full all those kinds of things
and then we have a fourth kind of
monitoring which is just back up
monitoring so our system is designed for
high availability so any code that you
for example push into our system is
replicated so it's not on a single filer
and that replication is done constantly
but we also need backups and why do we
also need backups if we have that highly
available data and the reason is well
you could screw your code up right or
you could delete your repository and you
could come back to us and you could say
you know or what you know you could
corrupt your your-your-your code in some
way you could come back to us and say
like you know oh it's great that you
have my data but I screwed my data up i
want my data from yesterday so that's
what we have backups as well and we used
centralized log management so we use the
elastic search log stash cabana stack to
gather logs from Oliver
our VMS and our fleet and build
dashboards on top of them for reporting
so i can show you here it's a screenshot
of some of those dashboards so this was
a screenshot i took quite some time ago
but it gives you the idea so here we can
see you know monitoring the production
system in this length of time here back
in 2015 there were 34 projects created
we did 5,000 builds 719 gish get pushes
22 projects were deleted so we can with
that elasticsearch logstash Cabana stack
that gathers all the logs from all the
VMS and allows you to do these queries
across them you can get this nice
activity based information on who's
doing what but then it you can also get
information on what's not working so I
can show you another screenshot here of
a dashboard that we built in cabana that
is querying elastic search for
exceptions that happen so again in this
screenshot from a while ago we can
actually see there was a problem there
were two unknown host exceptions and a
whole bunch of i/o exceptions spread out
over this time period and we could drill
in there and we can actually see you
know what the exception is on what
server it is and what was going on so
this is another tool that we use beyond
the health monitoring to actually
monitor the systems that are running in
the cloud there's one additional thing I
want to say about this which is that
elastic search you can just curl it a
request and it'll a query to see you
know if there are any provisioning
exceptions so in our system when like
Greg showed you creating a project when
that fails it caused causes a
provisioning exception to appear in our
logs so if that ever happens we want to
know so the beautiful thing about
elasticsearch is you can
programmatically access it you can
programmatically write something that on
a cron job or whatever makes a request
off to elasticsearch querying for
provision exceptions in a certain time
period and if it returns any results
then you can alert your development team
that there is an issue there that they
need to
look into yes
chargeback what do you mean by
chargeback yes okay so we we do so using
the tools like cabana there we connect
and also metrics code that's built into
our runtime platform we keep track of
who's doing what activities based on
users and report those metrics out
through enterprise manager and through
other sources so we know who is doing
what we have it's a multi-tenant based
system so the cost is fixed we do
occasionally scale up based on load but
we're not charging and in this case it's
actually like a free part of the Oracle
public cloud so we're not actually
charging customers based on usage it's
completely free but we keep track of
usage and of utilization of our servers
just so we know when to scale in and out
one of the points so one of the things I
also do is I sometimes work with
contractors the system is really good
for contractors because it's really easy
to provide someone access you can create
a project that has people from your
company and add to the team anyone in
the world add 2 team people from your
your your contractors that you hired you
build your whole development project
there and at the end of the project you
know if if you want to disengage from
that contractor you're left with a fully
functioning development environment you
can also make the contractor submit
merge requests to you so they're not
actually able to change the code
directly and you can like you know
follow the progress of their work that
way so one of the beautiful things about
cloud hosted development tools is that
at your whim you can add anyone in the
world to collaborate with you so what's
a summary of what I see is the benefits
of cloud hosted development so the main
point is don't keep your developers
waiting Greg showed you how easy it is
to create a project in two minutes
something that a lot of companies you
would have to call IT or whoever's
managing your build farm or whatever
go and get budget and add new computers
and configure them and add more
repositories that all takes time
developers are very expensive so we
don't to keep them waiting the beauty of
this is it's all self service that gives
the development team the power to create
their own projects to decide who's part
of those projects and we handle the
security and the and the availability of
that you know like that cloud system
because it's all integrated like I was
saying before you can track all the way
from the issue to the commit to the
merge request to the build to the
deployment to the you know on production
monitoring all in one system and its
scale is elastically with your needs so
another thing you know like I was saying
before developers are expensive maybe
you're paying them a dollar a minute so
why would you know if you only have
on-premise a couple of machines in your
build farm why are you making them wait
they're going to go off and get a cup of
coffee and that's going to cost you more
than it would have cost you to spin up a
vm in a cloud somewhere and perform that
build on demand so VMS cost pennies an
hour and developers costs you know like
a dollar a minute so if you start
thinking about it that way then you
don't want to keep your developers
waiting you want to want to use the
elasticity that's part of these cloud
hosted development tools so that your
developers never have to wait if you
need a test environment spend one up if
you need an if they scheduled to build
and you've got two builders running spin
up a third builder because these things
are cheap and you pay for what you use
yeah
so you meant like if you were interested
in using a system like this like
developer cloud service and you had a
global team so right now we we have you
pick your your region basically so it is
deployed around the world but you would
need to pick your sort of home region
whether that would be us or europe and
that's the way we we work it but
everyone in the in that you know
obviously in the world would have access
to it some people's access would be
faster than yes
yeah so that's another great thing about
that you can also do is like in your
bill jobs right is have them actually
generate the documentation for your rest
api is based on annotations so we use
swagger to point 0 and we annotate our
code when we generate our documentation
in that fashion and then we also have
our documentation team that's actually a
member of that developer service project
where we have our code so they can
actually see as features get implemented
and they you know one of the beauties of
continuous integration is not just for
the development team in the QA team to
be able to validate that they've that
the fix that they did actually works or
the new feature actually works but the
QA team as well so the QA team is
automatically getting notified whenever
new features get implemented and they
have that staging environment as well so
they can go and immediately start trying
them out and writing the doc question
yeah interesting like as we try to get
faster right when your customers find an
issue with your product do they have to
call your support staff are they able to
enter kind of a problem statement into
your issue tracking system yeah so
Oracle uh may operate differently than
your company in this regard so Oracle
has a support organization and customers
can interact with them in a variety of
ways they can call them they can email
them they can chat with them actually
and what happens is the the support
engineer is the one who actually files
the bug on behalf of the customer and
that would end up in our system that i
showed you before
yep is there anything that you're doing
around capacity testing absolutely um so
uh capacitive testing is to really
important for this product I mean I
showed you that that our team is using
it as dog food right but we're
essentially one you know one tenant in a
in a multi-tenant system and so so what
we do is we use a technology called oats
which is Oracle technology for recording
user operations and we have basically
like 10 different operations that you
could do with the system that you would
do with different frequencies like some
people are doing build some people
updating issues some people updating
wiki pages so we record those oats
scripts and then we run simulated you
know the oats tool allows you to run say
like 300 simulated users with a mix of
those different activities against the
system and and and you can see where the
bottlenecks are and we do that actually
on every release so on every monthly
release we repeat that process to make
sure we haven't actually regressed in
performance because we don't want to
find out in production that you know we
made a regression that when the full you
know the the full load comes from from
from thousands of tenants and not just
one that something falls over now if
that does happen then like I said before
you've got all that nice tracking where
you can go right back to where the
problem actually came from and produce a
hotfix in a build and get the fix out
there quickly but absolutely we use that
oats technology to to do scalability
testing a scaled-down environment yes
exactly yeah and then the last question
was you know you have a unique system
here
yeah like I if your live build goes out
and you pushed out a critical book now
conceivably you're gonna have all the
tests to handle this book is there
anything than a unique challenge where
you're developing using the system that
you're actively changing uh so it and
general it's been extremely good I would
say we often find bugs that QA didn't
find in there in there and so like I was
saying like twice a day we push out all
the changes to a QA environment that
they test but that environment doesn't
have real data it has QA data and some
some bugs you only find when you have
real data and so we often find those
bite by eating our own our own dog food
and and we are in the so we're we're
basically in the middle after QA has
validated we start using it and it
doesn't go out to customers until we've
used it for a while yes yes you could
say that but QA is constantly validating
so um you know all we need for is
basically you know that they get that
email that says there's a new bill that
there's stuff that's been fixed and
automated tests run if all that if they
sign off on all that then we take up the
bill all the time so so we're not taking
it up once a month we're taking it up
multiple times a week actually yeah you
may not be the right people for this
question but what what do you say to a
potential customer it's my head my
company has a cloud offering as well and
so I'm curious about your thoughts on
this what do you say to someone who says
it sounds great everything in one place
all these benefits but we're not willing
to put our most sensitive proprietary
information in your cloud on the public
Internet you know we need to have it on
premises what what do you say to them to
try to convince them that using your
cloud is a safe way of doing things so
uh customers doctors sometimes do have
that concern absolutely and there's
there's there are many ways to skin that
cat so one is this argument doesn't work
but I
think it actually makes sense is that we
put more time and energy into security
of this system then then your IT guys
put into security of your on-premise
system that is guaranteed by by a huge
factor and so but that argument doesn't
work it's also guaranteed to take them
off so yeah but it doesn't doesn't work
so there's there's two there's two
additional ways one is one of the
features that is coming as part of the
work of public cloud and I'm sorry too
it's going to sound like an ad it's not
something to be an ass thing is is that
virtual virtual private cloud where
those VMs are basically an extension of
your corporate network and the traffic
between you and that system never leaves
your your extended corporate network
it's not traveling over the public
internet that satisfies a lot of
customers the other is that Oracle is
doing this thing called a cloud machine
where our services can run on premise in
your data center and we basically lease
you the hardware and the software and
that's another way to to go but there
are many companies that store their
source code online today I mean look at
the popularity of github so it's not an
unusual thing to do but for some
companies it's it's it requires some
leap of faith to move their development
operations into the cloud and hopefully
some of the benefits of having this
integrated system and having the
elasticity and having someone else
monitor it for you you know are a big
enough of a draw that that's all don't
make the leap
question sure how many environments do
you setup typically set up like dev QA
per project uat and so forth as your
provision provision all these different
environments that concept yo yeah so we
have so we have some some standard
environments we have a one on the tip of
our code line that's updated
continuously we have one on whatever our
next release deliverable is and then we
have another one which is like a pre
production environment which is on what
we're almost about exactly to put into
you know the production environment or
what we already did put in the
production environment so if we need to
test a hotfix we have something that's
that's matches on the production
environment that we can put there and
then we have the production environments
which are actually minis you know spread
around to different regions around the
globe yep like a feature branch yeah
that's what you're talking yeah so um so
sometimes unit tests are like compiling
if you've implemented a new feature
testing it locally and you you know if
you may want to share it with you any
want to run like the all the functional
tests or you may want to share it with
QA before you actually merge it so in
this case we spin up a a small size
environment similar like what we use for
say our dev environment that has the tip
of our code for that branch and then
that that environment is short-lived
environment for the purpose of testing
that branch and then we dispose of it
once we're done testing that branch
that's on demand right now go out of
your way to you can do that automated
from our build process we do we seem to
do all right with 44 most changes with
the two environments that I talked about
before that are preset up and
automatically updated but there is there
are wouldn't we implement big features
we will spin that up and we do have that
automated so we can given the name of a
branch we can spin up one of those
environments I didn't show that today
but you can we do do it
you can't do it yeah absolutely so it
depends if there are the decision
whether to roll back or to roll forward
sometimes depends on on like what was in
the patch if there were for example we's
database so like schema changes and
stuff in the patch could be hard to roll
those back it's possible so we most
often roll forward and just fix the bug
but but yes so if if we never rolled
back but if there were no schema changes
that the mechanism there exists to roll
back
you
yes so one of the things that we do
which is important to me is there are no
there is only this train we want to make
sure that what we tested and what our QA
tested and what we installed in these
lesser environments is the same thing
that's running in production so we never
have the case where a third party or us
goes and for example applies a weblogic
patch to our production systems instead
what we do is we make it part of our
development process we is the
development team we consume that patch
that's one of that would just be a bug
fix to consume the patch and we put it
through this continuous integration
process and it eventually pops out the
other side in production so we make it
part of our regular release process to
consume security fixes and other fixes
from from other from things we depend on
so if they had a hot hot patch that that
they required that it was a really made
sense to roll out then we would have to
have it we would put out that patch all
right thank you for listening hopefully
something in there was was useful to you
in your projects and I'm happy to talk
more after the after the official
presentation if you have more questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>