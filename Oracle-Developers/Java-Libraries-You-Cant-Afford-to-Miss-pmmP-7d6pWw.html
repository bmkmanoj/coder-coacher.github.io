<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java Libraries You Can’t Afford to Miss | Coder Coacher - Coaching Coders</title><meta content="Java Libraries You Can’t Afford to Miss - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Java Libraries You Can’t Afford to Miss</b></h2><h5 class="post__date">2016-09-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pmmP-7d6pWw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you for coming hello everyone are
you having a good time at job one this
year
excellent nice let's see some hands who
is here for the first time agile won wow
that's amazing
Wow incredible enjoyed a lot please do
talk with people that's my
recommendation personal recommendation
do networking it's not it's amazing to
see so many new faces to this conference
anyway so as you can see from the title
this is Java libraries you can't afford
to miss and when you say something about
ourselves oh yes first of all that's
important
well my name is sick shell Reece and
this is Andres Alma right
we are from Mexico but we live in
Switzerland we love the chocolate and a
cheese very much so
Andres is a Java champion we run the
hacker garden you are all invited to go
to the hacker garden here at JavaOne
perhaps you have heard this runs at the
in the Java hub in the middle of Java of
there's a hacker garden what we do is
that we we connect people if you're
interested in one of the projects are we
going to see today or any other stuff
just go there and it's very lucky there
we're going to find somebody is also
interested and then the idea is to do
some code perhaps to hack some code in a
good way
okay yeah well we are also involved with
groovy gree phone you name it we are
into open source and we love to share
knowledge we love the open source now
before we get into the topic proper let
me remind you all the small machines
that are outside of each one of the
rooms the polling machines this is how
you can give us a quick feedback if you
like the talk awesome if you didn't like
it that's also good because that's how
we can make things better so please
don't forget to vote ok thank you very
much now I have we we had to say a
little bit of a disclaimer of the of the
libraries of the projects are we going
to see today they are all of them open
source to begin with so you can play
with them without any restrictions
without any problems but also these are
libraries that we have personally
with them so we use them in our daily
work we use them with our customers so
we know where things might break and
where things actually work pretty good
yeah they are there is a sea of
different libraries and projects that
you can see in the Java consistent it's
so big that we cannot mention all of
them so we thought that the ones are
going to see today are the ones that you
definitely have to have a look but
because they're going to make you be
more productive but most importantly
they're slowly bringing back a smile to
your face
so that's important we are not only
going to show you the libraries we are
going to show you a living example and
the code is going to be online so don't
worry about that yes so hopefully by the
end of the session some of you will have
a face that looks like this one that's
our goal
okay that's the goal exactly okay so
here you have here's what we have here's
the challenge most of you or most of us
have to deal with the web in one way or
another and most of us now are trying to
figure out how this thing works with
micro-services most of these macro
services expose their behavior through
the means of a rest-based API right so
what we want to do is build a java-based
application that is capable of consuming
a REST API but we also would like to
have these components to be as small and
reusable enough dry yes
keep it dry we want to say no to
boilerplate code do you guys like
writing getters and setters and updating
that code and over and over again right
I know IDs can generate that but source
code is auto-generated by the ide gets
outdated immediately right after you
just generate there are now sub to you
the boarding is up to you now to
maintain that machine generated code and
also testing it's always important yes
if you are not doing testing we should
be doing tests so these are those are
the libraries this is the preview of
what we're going to see today of course
we need to write our production code and
we need to test it so for
we're gonna have a look at juice okay
HTTP retrofit Jenifer Eric's Java
Ambassador Lombok SL f4j yes you can
pull all these things together in a
simple coherent application it's not
just because this is a buzzword of
popery of libraries note they're
actually each one of those makes sense
for a particular as scenario yes and for
the testing ones we're going to cover
general params mojito jikido a utility a
spark and were mark as I said before we
will have the examples the code will be
this available okay so the REST API that
we chose to use an example is the github
API why well basically because it's one
of the most popular out there is
well-documented and chances are that you
have encounter in one way of another the
latest version of the github API is
located at that URL it has a very good
documentation for now of all the
different operations that you can use or
do you have access to from the github
API we're going to use only we are going
to query only the repositories so just
to keep it short
alright so Corinne our repositories
using the github API is described in
that URL the word you will get the
slides later but basically what it says
that given an URL query such as the one
at the bottom get orgs and then give it
a name of any organization a ballot one
you will get a JSON payload as a result
the JSON payload is actually quite big
because depend on how many repositories
and owner has organization then you're
gonna get a huge list and each
repository also has a huge set of
properties we are only listing the ones
that we're interested in and that that
my friends will come back later into
effect that we don't have to pass all
the properties only the few ones that we
need all right in order to make this
application work we will need to and I
will have any recommend you to use the
pendens injection is anybody here
not aware of what dependency injection
is Wow that's great
that's why 2016 and we all should be
doing everybody should be doing some
kind of a penile injection perfect we
will need to deal with HTTP calls so we
will need some kind of HTTP client and
handling rest behavior we definitely
need to find a way to passed JSON
payloads into Java objects we will need
a way to get rid of that boilerplate
code and definitely we need to handle
concurrency why because the example
application are we going to show today
is it's actually a Java fix application
hold on just don't leave the room follow
me out here me on desktop is still
important and we're using enjoy effects
because it's easy to showcase but many
of the libraries that you'll see today
you can put them to good work on the
server side as well okay so we are going
to handle concurrency because we don't
want to get the freeze effect in the
exactly so all the code that you're
going to see today is ready available at
this URL just take a moment for pictures
you will get the slides later so let me
show case the two there will be two
versions of the application and I want
to show you today so let's see the first
one running we use Gradle as the build
tool of choice by the way we really like
it and there is the small application
let let me make it a bit bigger there we
go so basically in this application what
you do is that you give it a name of an
organization let's see if or a couple is
an organization a github and see how
many repositories has Oracle open source
are on github to do to to stick in some
time I think that I've set a time out to
be a minute
Hey look at that we found 30
repositories open source by Oracle kudos
to her for doing that and this little
apple
just goes through the first page of
results and doesn't do anything more as
I said depending on organization you can
have many many repositories so it will
be bit if we can paginate resource so
the next version of the application I'm
going to showcase performs that or has
that behavior so I'm gonna really run it
again and notice that this one has a
little bit of well additional
information so let's look at now this
organization and let's load as many
repositories and has let's see how many
think I know the number should be close
to 245 and you see that that label
updating itself interesting thing that
this list is sorted automatically and
it's very easy these things to do with
Java effects anyway this is the kind of
implement the code that you're going to
see if you go into the repository all
right Erika so the first step is
dependence injection I am very happy
that most or all of you previous prima
said we know what the penance injection
is there are many ways to do it
basically what you done is you have
components interfaces classes after
classes concrete s it doesn't matter you
want to have these instances be wired up
together ready up whenever you need to
do it to use them so for example I have
this github interface that we're going
to make use in the application somehow
we need to attach an implementation of
this interface to the components that
need to consume their behavior right so
this is how we do it we annotated using
add inject people that normal spring
they use a different a notation called
at outer wire it just works the same and
the controller component will just
consume two dependencies that have been
injected easy-peasy I will say how do we
make this happen well turns out that
juice is the reference implementation of
a jsr whose name or number is J's are
three three zero is the J's are that
standardizes how we do the
Injection in the Java platform it's very
easy to configure juice you do it
programmatically some alternatives will
might use xml or some other means you
can configure bindings in many different
ways
you can have bindings in the single
scope or prototype scope or any other
kind of scope in the web applications
typically you might use session scope or
application scope you may have providers
which are basically factories to that
create a lazily instances or any values
that you want to be in C injected in
components all right so the advantages
of using juice is that it first is the
reference implementation of the J's are
so is the first project that knows how
to implement this this new set of api's
you can bind
interfaces concrete classes abstract
classes you can have providers lazy
values you can even bind constant values
and we use I think we will see that on
the test cases if I had a mistaken and
it has a very extensible lifecycle which
means that when the container creates a
new instance you can here if that
instance is ready or you can here when
an insert has been injected to something
else and react to those things and then
customize further your application okay
and raise why are you talking about so
many well why do you make an emphasis on
using reference implementation of yes
art because the j-stars are the the way
that we standardize a common behavior in
the java ecosystem and in that way if
you program your applications following
the API is exposed by IDs are in theory
and most and most of times in practice
it's easy to switch from one
implementation to another so we really
recommend you to follow that idea yes as
you can see Android gets really
passionate really quickly and it starts
speaking really fast but this is a
session that we want to have interaction
so please raise your hand if you have a
question at any time yes please do I
will do I try our best to answer it as
best as possible of course
as a bonus if you happen to be using
juice in your system already oh yes
then you get access to these for the
library called guava now what I was
created some years ago and it gives you
access to new collections if you ever
have the need of when you have a map and
giving a keep you always get a body
right well if the map is working
correctly but if given a value do you
want to know which key is attached to
that well that's what buy map does for
you if you want to have a list of values
attached to a key and just access that
list of Bali with so simple get input
instead of do manually handle the list
that's what multi map allows you to do
if you want to have two keys associated
with the same value something similar to
what a table in a relational database
works that's exactly what you gather a
table data structure and so many other
things in the case of JDK 6 they provide
functional programming supports such as
predicates and actually I cannot say too
much about that because I just I
migrated to dedicate pretty much in that
in the day that it was released so you
will say perhaps it only makes sense to
use this extension see you're still
running in JDK 7 or deallocate 6
everybody here using JIRA K 8 in
production lovely 60% of you for the for
those that not that are not yet using
JDK 8 please please give it a try and in
those of you that are using JDK 8
already give it a try to dedicate 90
early access this how we can give
feedback quickly and we don't have to
suffer using an API in the future that
we didn't like so much
anyway but I mentions juice but it's
also spring for doing the pendency
injection the spring is actually my
favorite project and I'm going to talk
just about the spring book or I know
there are plenty with spring related
projects but if you only use a spring
core you get dependency injection but
did you also get more things you get
testing support you get jmx anybody here
using jmx
perhaps a few hands well I don't know if
you know but using jmx to create jmock
or spring to use create DMX
why and he's so easy so damn criminal is
she'll be being should not be allowed JP
a jdbc and serialization is so easy just
just put a spring on it and it's almost
like it were meant to be magic my
personal favorite its
internationalization it's also so easy
to do it I mean we don't have an excuse
to not have our applications now in
different languages yes that's true okay
now look have given a little bit of
information of dependence injection
let's turn into the proper behavior of
the application and before we get into
their behavior perhaps you would like to
monitor how the application does or how
it's performing or you just simply want
to know what it's actually doing right
there are many ways to do logging all of
them are wrong
all of them have issues but for all the
many different options that are out
there perhaps sll 4j is the least back
reading a system actually project that
you can have the interesting thing about
SL f4j is that it allows you to route
all the different calls from java.util
logging commas log in and lock 4j into a
same place so it funnels all the calls
into one API so now you haven't
controlled in just one place if you want
to enable a lock level or enable
different offenders another great thing
that isolate for J does for you is that
all the login statements support
variable arguments this is very
important because sometimes the message
that you want to format
it's expensive to calculate but if you
supply the all the parameters in
variable arguments that the message is
going be going to be composed fully if
and only if the logging level that you
want to call it's actually enable or not
alright okay so let's get into HTTP
everybody loves HTTP so how many options
are there to bill an HTTP client we have
plenty of options in Java but how many
options are out there to properly build
a rest-based client
http/2 and yes now nowadays you have to
think about HTTP to HTTPS indeed the
future yes well let me tell you you have
access to ok HTTP this is written by a
company called square you might have
heard that one they are very active in
the Android communities many other
libraries they write they take into
consideration performance and memory
footprint so they're pretty pretty good
I will recommend ok HTTP over Apache
common a budget client because this is
much more newer and core support HTTP 2
now creating a client is as easy as just
create a new instance of that one then
configure our request object you can
configure headers you can also configure
network interceptors if you want and
then just invoke a call you get a
response object or which you can grab
the body you can grab the headers and
you can parse this team from JSON or XML
it just works it's very easy to do so
the advantage of using education to P
again is that is it gives you basic
basic access to HTTP and HTTPS oppose
authentication and supports OAuth is
very easy to configure it's extensible
via factories and supply supplies a very
same lifecycle for handling all the
network course and network calls and
interceptors alright yeah this is cool
ok but talking at the HTTP level is
still very low level we are Java
developers we want to use our Java code
and jelly beans right yes so why did we
put a Java layer on top of the rest api
how do we do this
how do we keep in track or the the
proper response how do we keep track of
headers how do we handle errors all
these things we have to do over and over
all over again regardless of the type of
application what I happy to say there is
another project out there called
retrofit that the promise is this and
it's actually how this works you define
an interface and supply and use this
particular
this type this call is a class that is
supplied by retrofit and you annotate
these methods using also a special
annotations from retrofit but this first
method says is that I will issue a get
call to that URL follow me this format
is you might remember this is the format
that the github API requires and we
annotate one argument with this value
which should match what we're seeing
here in this order annotation perfect
and when the result comes back the
github API says I may have additional
results and those resources are supplied
by the page here is the link to the page
so that URL is what we're going to use
next for the subsequent calls if we do
it this way then what retrofit allows
you to do is create a Java language
proxy that maps around our interface and
internally will issue all the network
calls for you using ok HTTP you don't
have to manually create HTTP client
retrofit will do it for you
it is like fane actually fane is another
project from Netflix that it's inspired
by retrofit but I have found that
retrofit is much easier to configure
that Fame but that's again my personal
experience so here we are telling this
builder to issue a network call to this
URL the API give up the comtesse the
base URL for talking to the github api
and we are going to use the jackson
converted Factory
why Jackson Jackson is another
interesting library that's perhaps is
the one of the most used and it's quite
class is I don't know if it's fast but
it's very very popular this will allow
us to map JSON objects into Java objects
I will see that shortly so once we have
created the the proxy in this way we
have access to that and just issue the
call using the Java interface that we
define it we supply all the types that
we need and
as as a result we are going to get we're
going to go back one slide we're going
to get a list of repository objects so
they may have been everything just
happens automatically
we are retrofit yes almost for free so
with retrofit you can wrap Rascals very
easy around Java interfaces you can
stand the behavior beer factories and it
relies on ok HTTP right next step we
definitely need to deal with
multi-threaded code because as some of
you may recall from from the time day
that you wrote swing applications and if
any of you still write Java FX
applications there is one golden rule
every interaction with the UI has to
happen inside the UI thread so whenever
you're reading properties from a widget
or writing properties to a widget
must be inside the UI but everything
else such as a database call or a
network of must happen outside the white
tray if you do not your application will
appear to freeze while the update but
the the computation is happening and
this would be a bad thing to have
remember we want to deliver the best
experience for our users so the first
thing that we're going to look at is
that well the JavaScript community has
come up with an answer for this it's
called promises what if we were to have
promises in Java well we do there is
this project called Jade affair and what
you do is what we're going to do is
change the repositories call to return a
promise object and this particular
promise takes three our generic
arguments the first one is the type of
the result is going to be a collection
of repository objects the one in the
middle is that if this operation happens
to throw an error where we're going to
draw trouble jail if the promises API is
done in such a way that you can throw
any type not just exceptions not just
troubles and if you happen to have
intermediate results then this is the
third type in the case boid
we will see that in a moment so
basically you do this and now how we do
concur do we define or how do we make
use of these promises
well we inject a new type that's a
better buy Jennifer called the firm
manager the firm manager knows how to
include background tasks they can also
be cancelable tasks or future tasks and
here we're making use of the deferred
object right there this Wayne call
actually takes a single method interface
but given that you guys are using JDK 8
we are now using also land expressions
basically what we're doing here is this
API thing repositories that the retrofit
proxy so here we are issuing a network
call to the github API once we had the
response and it happens to be successful
then we just publish the whole body and
notice that we say response body but
that gets translated automatically into
a collection repository thanks to
retrofit thanks to Jackson and if it's
not successful we just simply draw an
exception and that's it Andres why are
no we using completable future why are
we not using completable future first
because completable future is only
available in JDK 8 secondly completable
feature is too fat it's too big it does
many things and promises in this case it
knows exactly what you want to do and
it's a very it's very concise API it's
much easier to understand and to to
learn than compatible future but this is
just how we produce the promise how do
we consume it this will be the cold or
the controller or the logic and I'm here
in the middle of the slide here we have
the call to that github object that
knows how to create the promise we grab
the reference to the promise and then we
change some behavior if the promise
happens to produce intermediate results
then those resource are going to be
added to a list if it happens to fail
that we're going to print out the the
the starters for now of course we should
be do some kind of blogging or or maybe
we should send that information
somewhere else across the system will we
see that in a moment
but regardless of if the the computation
was successful or did it fail we want to
always do the following thing which is
update some model state to be ready
so in summary Jennifer gives you the
concept of promises which is really
useful promises can be chained you can
use Java 8 lambda expressions and method
reference just like we saw here and this
one and most importantly Jade Affairs
should be used when you have a one-shot
execution
you might remember swing worker from
back from JDK 6 the thing is that you
are spinning up a background thread for
the computation and once it's done you
come back into the UI thread this is the
same thing in jail affair but it's not
in any way is strictly tied to UI you
can use Jade affair on the server side
as well and just as an additional treat
we have the author of the Jade affair
project right here sitting in front
raises no any other questions if you
have any other questions then please
come to us we are the hacker garden
anyway we also have a reactive
programming for you right because most
people now are interested in to reactive
programming but how do we jump into
reactive programming what is reactive
programming reactive program is nothing
new is just events and streams of values
there are some projects and perhaps the
most well-known is Eric's Java there's a
URL basically what we do instead of
using promises you're going to use an
object that is capable of pub of
reacting to data coming down the
pipeline you can decorate the pipeline
with different operations so in this
case what we're doing is we get the
observable directly from our component
we'll see how that is done in a moment
and if we happen to have a limit
remember when I showed the application
that we have text about how many
elements we want to see if we have a
limit then we decorate that up several
with that take operation this means that
the producer is going to send data as
much data as it can produce but the
consumer or the subscriber is going to
stop until certain limit is reached and
that is the take operation we also
because we will be issuing Nebel calls
perhaps the neighbor is too slow so we
want to add a timeout we want to say
that whenever you subscribe we change a
state and whenever we terminate
regardless if it was successful or there
was an error we're also going to change
the state it's a very important when you
subscribe you make sure which trail
you're using in this case we're saying
subscribe on scalars dohyo
which is a background thread that via
schedules class know how to handle you
may have different karma schedulers and
there are Java supplies already made set
or schedulers for you finally when you
subscribe there are two actions whenever
a new data a new data elements is ready
we're going to add it to a list of
elements and if there is an exception
somewhere down the pipeline they are we
going to simply print out and that's it
how do we combine things together
turns out the retrofit has an extension
for Erick's Java so what we do is that
we simply change change the return type
of our previous defined interface
instead of saying call we say observable
response once we do this creating the
proxy requires one additional line of
code which is telling retro fee that it
should be eric's Java aware so we just
register the factory and that's it
and that will be enough just for
consuming the first page but because we
define it to entries how we can compute
two pages well the code that we need to
in order to concatenate all the results
is actually to fit in two slides but
here is the card of the whole codebase
what we're doing is for each page we are
going to create a list of repositories
and we want all those different lists to
be concatenated into a single list and
we want all those values to be attached
into observable but observable it's not
a list of repositories it's an
observable or repositories for that we
need to issue an operation like flat map
and it we happen to get a new page
coming back in the headers for the
response that's what we have access to
the response then will follow that page
and to catenate the resource so at the
end of this whole operation what we get
is a simple observable of repository
objects regardless on which page they
were alright so Eric's Java gives you
access to the observable pattern if the
libbers dozens of operation shows as box
and sip and reduce concat a flat map
many others and also supports
backpressure which means that if the
producer happens to create data faster
than the consumer the subscriber can
handle then you can tell the producer to
wait up wait a second slow down buffer
those things so when the consumer is
ready to get the next set of data
instead of just getting one element it
gets a collection of enemies and now the
consumer can do the job a few other more
stuff that you can see in in reactive
programming so far to get right
remarried you have any questions just
let us know we said something about
extractions right yes yes right now we
were handling at sessions very basically
printout would it be better if we when
we encounter a problem that we notify
another component so let me show case
that I thought for a moment was honestly
I didn't know that Oracle had
repositories on github I expected that
to help fail
and glad that I was mistaken so let's
use a bogus organization name here let's
see if this one fails yes it fails and
the code for this one works in this way
let's go back to the presentation and
basically this is what we're doing we're
using another project called Ambassador
this is an album bus and then bosses are
very useful to connect components that
do not know each other but I still want
to communicate in one way of another I'm
aware that guava has an event bus but
ambassador as America happens to be much
more performant than a one in guava and
this one also has well I prefer the
style of annotations so this particular
class we inject an event bus that is
capable handle events of that particular
type this is how you register a handler
you can filter those handlers there are
many ways that you can raise them this
is the easiest one the important thing
is that the argument type is the type of
the event that you want to handle and
finally publishing events can be done
just like this you have an act a
reference to the event bus object you
can publish which means it going to go
immediately and the event bus will wait
for all the handlers to do their job or
you can also publish in a synchronous
way so the advantages of using
Ambassador that I believe is much better
than the event bus provided by guava and
that there is a link to benchmarks
showcasing why it's better but be aware
that the author of the library is no
longer than active in this project so if
you encounter a problem then a bug or a
feature will be albe the most load to
come it's still good though and we use
it in production ok
the next step will be reducing the
boilerplate and some of you might have
heard of this project is called
Lombok basically latches on into the
compiler phase and generates new biker
you supply hints to the compiler using
annotations so for example in the case
of a person class if we want this person
class to be a well-behaved pojo what do
we have to do well we have to create
suitable constructors right we have to
prepare in the case of the final fields
profile perhaps expose Gators no setters
and with their it has to be a
well-behaved pojo it has to have a
correct implementation of equals hash
code and perhaps to a string this is
tarsem this is bothersome and I know
that the IDE can generate code but why
should I have the IDE general that code
when I can have a compiler generated
back out for me and this is what we're
doing right there with those annotations
if we inspect the byte code generated by
the compiler it will have equals and
hashcode and two string and do it the
right thing but our code will still be
concise your source code will be small
the biker will still be the same thing
as you were to be generating these
things using the ID here's another
example of the event class that we are
using in the application this is all
that we have to do and it's and in the
Lombok is friendly enough to order an
annotation source as the non-dual
annotation so that if you attend to
create an object an instance of new
instance event supplying a null value
you will get our runtime section saying
I expected an unknown object finally
here's the usage of that new instance
event and the person class was annotated
with builder so we have what is it's
called a fluent interface API for
creating instances so the advantages of
using Lombok is that it reduces the
boilerplate code it relies on the
annotation processing tool so if you're
using Lombok in your IDE if you're
saying it in NetBeans
the apt tool is enabled by default so
you don't have to do anything at all if
you're using IntelliJ you have to do
check or take a checkbox in your IDE per
project and if you using eclipse you
have to check that thing and also you
have to locate all the jars in the class
pad
so NetBeans and IntelliJ in this case
are a bit better because they are able
to find Lombok and any other apt
processor jars automatically from the
class pad extending Lombok is not for
the faint of heart you have to target
the clay java compiler or the eclipse
compiler so you have to know some the
internals so I don't expect you to write
an end transformation but at least I
will spec you to be able to consume that
transformation very easily yeah that's
it I guess now we're ready to switch to
testing okay see how more time I guess
most of you are familiar with your unit
yes have you heard about testing gee
some hands good you guys where do the
Jade Unified talked about yesterday that
was very very popular well in case that
you're still using Jenny for a because I
believe Jade unify has not been
officially released yet it's almost
there you know yeah you can parameterize
methods and test cases but you can only
parameterize a single test case a single
method in a test case or all the same
mentor the methods have to use the same
arguments you cannot parameterize
methods with different cardinalities and
different argument types
what j-unit brands gives you that
capability so now you can parameterize
anything you want and it's very easy to
use you have to use a custom runner and
you annotate the test method with you
can supply the test data immediately or
you can also define a test data provider
which could be a class or could be the
name of a method inside the same test
case and those are the advantages pretty
much I like j-unit brands because it
gives me better
support for different parameterizing or
data provider strategies as a matter of
fact the next step is that when we are
testing our classes in unit tests we
need to make sure that where our
collaborators are as thin as possible
and there are some options out there but
most of the times we turn out to marking
libraries of which they are some but I
will definitely give you a
recommendation for mojito mojito I found
to be that is the easiest one to learn
and it has a very I feel thought DSL for
writing your expectations so here I have
a basic example of how you can test out
our controller class and what we want to
mock out is the sample service that the
controller needs to have access to so
fears we set up our collaborators we
mock the service then we define our
expectations the when method right there
is an aesthetic metal coming from mojito
I'd really like to use the static
methods or static imports as a matter of
fact and then we simply say on that
controller get service object we invoke
the say hello method so this is real
code this is noise strings and we supply
that input value which is by the way is
coming from j-unit params and when that
happens and if that happens we're going
to return a value and that value is
going to be the output variable that we
also get injected using genuine params
then we go into the next step which is
in the stimuli block when we actually
mean book the controller and finally we
come into the verification phase when we
assert that the controller has the right
thing but we also verify and in this
case this is more like a stop not much
much like a mock that they that this
particular stop was invoked in the right
time and with the right number of
invocations and with a right number of
arguments and the right type of values
and there are more other things that you
can say for example instead of saying
verify that the controller was invoked
once or only we can say at least
and a number or at most and a number so
you can give it a range what I like
about mojito is that as a fluid DSL
based on static methods is very easy to
learn it provides us support for stops
mocks and a spice spice are real objects
for which you only want to mock out or
stop out a few methods but the rest of
bad behavior should be the real
production like behavior you can mock
interfaces after classes and concrete
classes and also happy to say that you
happen to have more questions on mojito
here we have in front the author is
Stefan favor of mojito thank you for a
great library ago if you happen to be
using j-unit and jews and you love
mojito there is another player called
Yukito
what does Yukito allow you to do you can
inject components into your test case
just like this one and you can of course
you will use J unit and this injection
happens because Yukito has a juice
container already internally but for any
type that you do not define a binding
the juice container will ultimately
create a mojito mock for you you don't
have to do it by hand and what we're
doing here in the before method is that
we expect an instance of a sample
service to be supplied to us this sample
service instance happens to be a mojito
mock that they jockey to contain a gave
to us so we just have to define our
expectations on that mock and then on
the test method make use of that one and
we can verify that that Marc is doing
the right thing for us so if you're
using juice already do keto should be
the natural extension when doing testing
arraign it realized oh I said the same
thing about maketo yukito there we go
you get oh sorry
so combine that you need juice and
mojito you can bind multiple instances
to the same time so you can parameterize
tests also using the keto and
I think I didn't have an example for
that one but you just go to the web page
and then they will see excellent if you
are feeling adventurous and if you want
to give true a give a try to other
languages outside of Java then please
give it a try to a spark a spark is
written in groovy and it gives you the
same or almost the same capabilities as
Jane you need and mockito and similar
source a matter of fact the author of a
spark used to be a khalipa Stefan and
they share ideas of how spoken through
these barriers and it was inspired by
mojito so here's the same test case it's
a parameterised test case but using spot
which is also separated in different
blocks in the case of a sparks and spark
the blocks have semantic meaning so
during the given way phase is where we
set up our collaborators or the marks in
this case during the web block is where
we issue the stimuli and in the dam
block is where we might have have our
assertions do Unix is there something
wrong out there in the dam block because
the output thing happens to be a string
and how do we compare strings in Java do
we use the equals equals operator no we
don't what we will love to use it right
well guess what groovy has operator
overloading and the equals equals
operator actually invokes the equals
method for you so even though you're
looking something looks wrong is the
right thing to do in the groovy language
and I don't think that it's really
interesting is the names of the methods
yeah when you see the reports you can
actually read clearly you forget about
test one failed and you're like okay
test one for you that's very important
the name of the method a string and that
string is parameterize double and yeah
it just give it a try I would you won't
be disappointed so it is a groovy based
yourself but you can test Java code
without
any problems you characterized multiple
methods just like j-unit params they can
have different cardinality and different
types in the same test case there's an
Spock talk later on today or tomorrow I
scan cows in here yeah well there is
still as Spock talked said today or on
Wednesday about a spa certainly do not
miss that one finally because we're
testing concurrency we will eventually
find that we have a dis background task
going on in production but we need to
assert that is doing the right thing at
the right time how do we make this
happen
well I wait till 'ti give us access to
some capabilities such as that one the
await call what with this thing is doing
is that is going to pass the current
execution thread so the test thread for
about two minutes you can supply any
kind of timeout until certain condition
is met and I'm using a metal reference
here but that happens to be a hamcrest
matcher and I should know the model gets
stayed is a callable the equal to is a
hand Chris matters so the first option
is how I'm going to extract a value from
somewhere and the next step is how I'm
going to match it against that
particular condition so this whole test
if you remember the implementation of
the repository is called the real one
accessing the network has to be run in
and background thread so when we issue
the call to controller node we're going
to trigger that in a different thread
where we need our test case to wait
until something happens if everything is
fine the model state the state property
in the model changes to ready regardless
and if there was an error or the other
repositories were fully processed so the
reasons to use a what ility are it
provides you a DSL for testing
multi-threaded code it has extensions
for groobie for java 8 for Skala code so
you can use the scalar functions or Java
8
expressions or gruba crushers all the
conditions can be customized using ham
Chris matters and there is one more
thing that you will find in the code but
not in the slides is that if I want to
run a functional test case that means
let's do this
grilled GW test if I run want to run a
functional test a test case that means
I'm going to launch the real application
the real UI and a1 somehow somehow I
want that button or the text be able to
have that kind of interaction how do we
do this
in the web we use selenium or webdriver
when in the case of Java effects we have
a project called test effects that was
exactly the same thing
and that we're going to use that one but
what I really want to do is that if I'm
running this test in CI I don't want to
hit the real gift hub API server don't
we right because we have a rate limit
and we don't want perhaps you want to
use your authentication but you'll still
be limited to 5,000 calls an hour so
what we want to do better is to supply a
fake server and for that we use a
project called wire mark so let me show
you the test running you see at the UI
popping up that's fine and here is there
we go this is actually no hands yes
exactly and that was hitting fake server
that I can showcase it here let's make
it this bigger so there you go wire mock
is an you can use it in many ways I
prefer to use as a unit rules so this is
telling my test case that I'm going to
have a fake server on port 8080 once we
have set it up here is how we define the
expectations so given that we have an
URL that matches this pattern we're
going to respond with our response that
takes the Stars 200
with such content-type and eventually
with some JSON payload so once we do
that test FX you click on the button and
actually fill out the text click on the
button wait until something happens you
see that with the weight support in test
FX is not as great as an air utility was
but once this condition is met then we
can assert this this thing is true and
setting up wire mark is easy there's
another example that we can see setting
up a delay so it's okay to prime your
server to reply to a particular request
but we don't want the request to do the
response to be given right away we want
the server to wait a few seconds in this
case 200 milliseconds after before the
response is given out so throttle yes
all right so we're almost done and these
are some of the libraries that we have
found our berry so we have found many
others but we only have less than 60
minutes to share with you let me remind
you again that the whole code base that
you saw today is ready available
everything works and you can copy the
copy one is licensed under GPL and that
then let me tell you some words about
open source let's share the code and if
you want to know more about these
libraries you are again you're more than
welcome to join us and the hacker garden
space and the exhibition floor just at
the middle of everything we also have
some nice stickers like this one for you
not right now but we will have another
hacker garden for that well thank you
very much for spending some time with us
I know you have an option
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>