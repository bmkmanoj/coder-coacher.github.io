<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Using ANSI Role-Based Access Control to Secure Java Enterprise Applications | Coder Coacher - Coaching Coders</title><meta content="Using ANSI Role-Based Access Control to Secure Java Enterprise Applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Using ANSI Role-Based Access Control to Secure Java Enterprise Applications</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CM9jGQXgA7g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Sean McKinney and to my left
we have John field and I'm a principal
with joshua tree and john is a architect
with pivotal and today we're going to
talk to you about using an CR back
inside a java ee applications and so we
want to make this a discussion we don't
want it to be a monologue and so we
invite any questions that you may have
if they're if they're relevant if we go
down into a rabbit hole we may have to
take it to the parking lot but you know
we'll see how it goes and so I want to
start out with a pull and find out out
of this audience how many of you are
familiar with ansi role-based access
control anybody familiar with it we got
a few hands so one really really you
know but anyway um so that's that's good
because I want to explain to you what it
is and and why you need it so but our
agenda is basically we're going to we're
going to introduce you to our back and
it looks like we need to have that
because a lot of you guys don't know
what that is and then we're going to
talk about some misconceptions and we
may not spend a lot of time on that
because if you guys don't know what it
is then it's probably not a big concern
and then we're going to talk about how
you can implement it within your within
your systems and and then we're going to
talk about where you implement it at how
do you enforce role-based access control
in your systems and then we have a
couple demos and hopefully we're going
to get we've got a little bit of a
technical problem on one of them so we
may just have one demo and we're going
to wrap up some questions
so the ante are back is it started out
in the academic world and it's probably
back in the late 80s Early 90s and it
was a formalized model for doing
role-based control role-based checking
within applications it's not specific to
Java it's for any kind of computing
environment and it it evolved from the
academic world into a an N IST model and
it lived in that ni st model place for
several years before ansi adopted it as
a formal specification in 2004 and so
specifically the the part of the
specification we're going to focus on is
insights 359 and that's the base and
insights 359 has its it's a data model
and a functional model and so the data
model is is right here and you have
these entities and these relationships
and these should all obviously if you if
you live in the security world these
entities are I'm sure not foreign to you
how many security geeks do we have in
here not that many okay yeah so these
are you know obviously you got users and
in roles are then a naps traction layer
to then assign permissions and the idea
here is that you know you you want to
have that there so you don't have to so
you don't have to assign permissions
directly to the users and then that cuts
down on the number of entitlements that
you're managing inside of your
enterprise and I don't know why that box
oh
got to love it and where it gets
interesting it's where you start getting
into that into that and what that is is
that's an object for which the rules are
activated into the online session and
the idea is is that you may be assigned
to many roles in a role could be
particular from a business perspective
you might be a customer you might be a
manager you might be an administrator
and you might be assigned to many roles
but that they're not necessarily going
to be activated for a particular online
session and so this is the part that a
lot of people miss is that and what that
does right there is that that gives you
the concept of least privilege which is
to say for a particular session you're
only granted the power that you need to
for that session and do your job and no
more and then there's some ancillary
concerns that are handled by kroll
hierarchies which it's an inheritance
relationship between roles so that you
can specify base roles and then have
child roles that inherit that that
inherit the permissions which cuts back
on the proliferation of the number of
roles and makes administration easier
and then you have static separation of
duties right there which is a constraint
that's placed on those roles in the
assignment and what that's all about is
the fact that you know you you could be
a manager there's a manager role and
there's a customer role but the two
should never go together for whatever
reason right it could be a conflict of
interest and so rather than depending on
the applications to enforce that you can
do it from a policy inside of an are
back engine and then you have this thing
right there which is dynamics separation
of duties which is our back three and
what that does right there is that gives
you control over which roles may be
activated in a session
so the the use case there might be that
you're a manager you've got to you might
be assigned to a manager role you might
be assigned to an administrator role but
you can never have the two activated at
the same time in a given session there's
a toxic relationship between those roles
and they can't ever be applied at the
same time and again a lot of times we
depend on the application to enforce
that and that's a problem from a
compliance perspective because how do
you know they did it right and so the
guys that antsy thought that this was
important that this is an important
aspect to security for authorization and
so they added it to the specification so
all of these taken together it is would
give you one hundred percent insights
359 compliance and there's very few
there's very few there's very few
identity management systems that do all
four yeah so any questions on that this
is this making sense yep okay I'm going
to go through these misconceptions just
real quick because it might illustrate
some some features so our backs a word
that gets thrown out gets thrown around
a lot and people say that they're doing
our back because they got roles I got
rolls some are back right so I'm user
roles i'm using permissions and I'm
Solamar back and and and that's not
necessarily the case and so a lot of
times people will design security
systems that are based on say a
directory and directories have they have
constructs like groups and a group can
be a collection of say users or it can
be a collection of another kind of
identity and you can use that group in
conjunction with access control lists in
the directory to do authorization things
but that's not our back because when you
log on to that directory all those
groups will be applied to the session so
there's no concept of activation and so
you're missing the the principle of
least privilege there every user when
they log on they get access to all those
things and so that's one of the things
you look for if you're if you ever want
to do our back is that concept of that
role activation is very important and
this is just the same thing on the other
side is I've gotta roll with the
collection of permissions is that our
back and and no a role is a mapping
between users and permission so back to
the first slide with the diagram it's
it's it's a mini mini to mapping between
users and permissions so there's there's
a lot of frameworks out there that do
security Springs one of them and how
many people use spring ok there's ok now
I got some hands ok and spring uses
rolls right and a lot of times you'll
you'll have annotations on a page or on
a on a URL that that constrains that
page by a roll and but that's not our
back because there's no concept of role
activation so again every when it with
spring and in the spring concept of a
roll there's no there's no concept of
activation in there and so it's not it's
not our back but you'll hear people say
it's our back but it's not
it's an academic model and it'll never
work in the real world and that's the
one I love is that you know a lot of
people are able to say what is what
works in the real world and what doesn't
work in the real world with any kind of
authority and that's absolutely false it
does work in the real world I've been
using it for 15 years in production
various places and it's a very effective
model but I'm not alone there's use
cases out there so if you're interested
check them out the whole reason for a
role is so that you cut down on the
number of entitlements being managed by
the security administrator and that's
what our backs for you'll hear that one
it's just so that we can make life
easier for the security geeks and that's
it and that's not it so our back is in
addition to a management facility for
administrators to use it's also a it's a
framework that shared across
applications and it's a common facility
that makes things easier for system
integrators and it makes things easier
for application programmers because they
don't have to invent different ways of
doing things and when you're in the
business of integrating a lot of
applications together they benefit if
they use the same model and so that's so
the real benefit of our back is is in
that it's making things easier for the
system integrators
nice good
okay our back doesn't work because in
our app we have over a hundred rolls so
what's the point you know it's it
doesn't make things any easier and and
this is something where I'll point back
to spring in the way that they've
implemented their security model is that
it ties it to a role and there's no
permission there so when you do that
you're going to have a natural
proliferation of too many roles and so
I've seen applications that have a
thousand roles and if you've got a
thousand roles you're doing something
wrong for a single application so you're
probably using the role as if it were a
permission
but our backs not a panacea so I can
solve all your problems it's not going
to fix pastilles it's not going to make
things perfect so it's it's a model used
effectively it will help but it's not
going to solve all the problems that you
have
can we get this mic over here live all
right great thank you okay this is one
I've heard it's dead right it's an old
thing it's over 10 years old nobody's
doing anything with it and and that's
absolutely false there's the the ANSI
standards body is actively building
adding things to it there's there's new
specifications that are that are being
put together right now and this one here
is for interoperability between
different are back implementations so
that they cooperate together and this
one here is more of an attribute an
attribute based facility so that you can
do dynamic authorization and so it's
ongoing
and it's not too complex it's actually
pretty simple so i'm going to show you
i'm going to give you an idea what goes
into implementing an hour back system
yes i think one of the things that leads
people to think that it's complex or why
you're not seeing adoption is because
there are plenty of products out there
that do security and contain things like
roles and groups but in fact don't do
our back they don't do the are back
model and migrating to that is a
challenge for that product and so you
don't see that adoption of the are back
standard but the are back standard
itself is actually fairly simple to
understand and in fact makes your life a
whole lot easier if you implement the
model it's in its entirety right I think
we're sometimes these things fall down
is when you implement only half the
model and then you don't get the value
that you thought you were going to get
you don't actually have the
functionality that you thought you were
going to get because you haven't done
the complete implementation so one of
the things that we really want to
emphasize is that doing the complete
implementation including things like the
session object is really critical to
making it real are back right and
there's really no payback for doing a
half-measure you don't really want near
beer you want the real thing and getting
real are back where you have session
activation of your roles is where the
payback comes that's where the real
value in the security is and having that
consistent model across your
applications is what enables you to have
a rational security architecture across
the enterprise right one of the biggest
challenges you come across is that there
is a role implementation of some
description in everything you buy but
none of them are exactly the same and so
rationalizing on one consistent
standardized model is actually the way
to start to get some real value and get
some real cost savings
it doesn't work for fine-grained
authorization so fine grain would be
defined is where you have instant space
data that's being considered within the
permission check that's false okay so
and actually you can do it with with the
base which is 359 insights 359 so you
can put instance data in that object
operation mapping but you're not going
to go very very fine grain and if you
need to go very very fine grain then
you're talking about insights 494 which
is the new one doesn't support
attributes so there's there's another
access control model called attribute
based access control and we use that
instead as if people haven't been doing
authorization on with attributes for 50
years so we've been doing it for a long
time the problem with attribute-based is
that you get really close to the
application and when you get close to
the application it's very hard to have a
common model and so antsy took a stab at
it with this 494
I'm let's get this one okay so we talked
about what our back is and we talked
about what it isn't now we're going to
talk about how to do it so I'm going to
break it down to three steps obviously
you need a network in a database stack
okay there's no right answer there it
might be a database it might be a
directory it might be a services model
it depends on your requirements we're
going to show you a open source our back
engine it's built on top of the
directory and it certainly does work
inside of the directory and I've done it
in the past with a database and it works
fine with the database to they both have
their advantages we're not going to go
into it now you need to have a data
model right so in order to do this
you're going to have entities and you
only really have five very simple
entities and so it's pretty simple you
got a user of course you've got a role
which is just a container to hold that
many too many mapping between users and
permissions you have an object which is
right there in an object's what maps to
the system resource so that'd be like a
file or a database table something like
that and then you have an operation
which is an executable image of a
program so that be like add update
delete so and then that pairing is a
permission which then gets mapped to the
role and and then you have this you have
this session but that session might be
transient it doesn't have to be
persistent so it just depends on how
you're implementing it with fortress our
session right now is transient so we
don't store it anywhere it doesn't
persist and you need to have a
functional model so if you go to the
insights 359 specification which I can't
show you right now because my laptop
isn't live there's a functional
specifications for exactly what an see
our back is it describes it in in very
precise detail and but it doesn't it
does not tie it to a implementation so
it's it's defined in a very abstract way
but basically you have three
administrative interfaces that become
your API you have an admin interface
which as your provisioning methods which
is part of the model so adding a user
adding a role and in a permission a sign
in the role to a user granting a
permission to a role that's all part of
the model okay it's it's all part of the
engine so if you have an answer you are
back engine all those api's are
available to you you don't have to write
them so it's not just about access
control it's not just about checking up
permissions and seeing if you can do
something it's about administration and
it's also about review and this is where
you get into compliance what permissions
does does a user have what do they have
access to what roles do they have how do
you know is that important it's it is if
your security geek it's very important
and so how is that done an see our Beck
describes it right there there's an API
for it so there's an API to say you know
what roles do you have what permissions
do you have all the way across
everything you need is right there and
then finally you have the system and
that's really what we think about when
we when we think about something like
this and that is authentication
authorization the runtime stuff so these
three components
out of these three you're going to have
probably about 35 or 40 methods so if
your implementation doesn't have that
then you're not our back I can't do the
demo so we'll just talk about it for a
minute so part of this talk was we put
together a sample application for you
and at the end we'll say it will give
you a link and this sample app is as
part of it is also we're giving you a an
hour back engine as part of an it's open
source you can pull it down you can
install it everything you need to do an
see our back is part of that link so we
include a directory openldap we include
a GUI for doing for pulling it up and
doing provisioning scripting utilities
the whole nine the whole nine yards
everything's there and so for this
particular sample app what I did is it's
it's using apache wicked I don't know if
is there any wicket users out there all
right cool and it's a maven project you
just pull it down it's got a palm you
run it it pulls everything down and the
way it's working is that it's doing
security inside of three layers and as a
security geek you want to put security
in multiple layers you don't want to
just do it in one and this is a java
talk and we like java ee security so if
you're doing security you're not doing
java ee security then i got asked you
why so part of this open source
implementation gives you a a security
implementation that runs in tomcat that
does our back and the demo actually has
tomcat it has that that security
provider in there it has openldap on it
and it has its application so the the
Java EE security is doing your core
screen okay that is can you get in the
front door okay
you authenticated okay that's cool and
then it has a a role check to say are
you in the right application that's very
coarse cream so every in this model
every web application would have one
role that would be checked at that level
which is to say can you get in the front
door and that's absolutely bulletproof
okay there's no there's no circumvent
it's going to work it's easy you don't
have to change your application why not
use it the next layer and it's spring
now I know I was kind of talking about
spring we actually like spring string is
a it's it's a wonderful tool for doing
security and what we've done with this
demo is we've configured spring to work
with Java EE so that the that the role
check that spring does it gets from the
container and then the container gets it
from the fortress policy decision
decision point so again here you got
coarse-grained can you get in the front
door are you in the right place you can
authenticate here are you on the right
page can you get to that page okay so at
this point everything's done without any
programmer interaction at all okay it's
all declarative and so any application
can do that if you're using spring if
you're a java ee app why are you not
doing that okay now inside it here
that's where the app is okay so this is
a patch you wicked app and that's where
most people put their security they put
in there okay and don't put programmatic
checks and stuff like that and that's
usually I mean it works but you have no
failsafe so if it breaks you're screwed
well we've got security there too so in
this case it's finer grain so you can
see the granularity level from course
goes to find as you go up our stack so
inside of here what paid what links does
a user see what buttons do they see
that's all controlled by the fortress
policy enforcement which is doing
role-based access control and then you
have the concept of a role activation so
that the user has a pic list of what
roles that they want to use and then
based on that it will seal it'll give
you a different view of the app you'll
have different pages you can hit so you
might sign on it
customer and you'll get one view you
might sign on as administrator and you
get another view say map the enforcement
done inside the sample application at
this level is done in the application
framework so we created a custom wicket
controls for buttons and links and
things like that so that their security
aware and then you just inside your code
you just use this overridden component
and and based on what role you have
activated it will go to the policy
decision point and in the button may or
may not show up if the user does not
have a link but they're smart and they
say well i'm just going to enter the URL
because i know what that page URL is
they might have bookmarked it springs
going to catch it okay the spring knows
you're not supposed to hit that page so
i had a demo where i was going to show
you dynamic separation of duties which
is that you know we had a user that had
the user was granted two to three roles
so you had the user was assigned to roll
one roll two and roll three but there
was a toxic relationship between roll
two and three and so if they tried to
activate through the activation in the
app if they tried to activate this one
and that one was activated to get an
error and vice versa so that's in the
demo app on the link will share it with
you at the end of this talk pull it down
check it out it also has a patchy
selenium tester that goes through the
use case so you don't even have to click
the button you just download it you
follow the steps you fire up the test
and it will run through this use case
for you and show you what you can do
with an CR back yeah and so guys keep in
mind this takes about three minutes to
do so you definitely want to hit that
link you know before the before the
conference I ran a test for Sean and it
downloaded flawlessly and unbundle
flawlessly and basically got the thing
goin in like three minutes and you can
actually watch the role activations
happen so button
not available when you have let's say
buttons you should have only with roll
tree and you're active with roll to
right now you don't have your button
turn off that role and turn back on the
role that it's mutually exclusive with
and sure enough those buttons appear you
know it's it's basically magic but it's
done with wicked
there's the link so part of that is also
like we said there's a directory there's
Tomcat there's a tomcat security engine
there's fortress and there's a user
interface for doing our back policies
mm-hmm so you know try it out it's
actually going to take a little more in
three minutes because it pulls its
dependencies down via maven so it'll
take a lot of pull those dependencies
now but with the dependencies down it's
about three minutes to install a fully
compliant ansi are back engine and i
really wanted to show you that but I
can't so so now it's John's going to
tell you about how were to enforce that
well I did that download and I got real
excited about the ANSI are back
implementation I actually found pretty
quickly that this is something i could
use in a customer POC that i had been
working on so I work for pivotal I'm in
the solutions architecture group and I
had a customer problem that I was
working on and had always wanted a real
are back ansi implementation so the
solution that that sean is describing
actually fit the bill quite nicely i had
some unique challenges that were related
entirely to the app and not to the are
back part but we actually work through
those and i've actually got a demo as
well and in my case the the live demo is
backed up by a quicktime movie so at
minimum we can watch the movie at the
end it's about 90 seconds i was telling
Sean I've compressed six months of work
into a 90-second video so I don't know
what that says about my productivity but
at the end of the day it's a pretty cool
demo to see so let's dive in so what
sean is just described for us was really
a discussion around three particular
places where our back enforcement can
happen and we're talking about doing our
back within the wicked framework
leveraging the container the java
container and leveraging spring security
and its integration with the container
so that's basically three architectural
touch points where you can involve are
back on i think there's probably a few
more and what we did is we talked about
it
together a model what I like to call the
reference model son of an are back
enforcement reference model kind of
gives you the full picture of the places
in which you could do our back
enforcement's and it's kind of a
prototypical java application stack and
it shows the the usual big animal
picture of things are familiar with if
you've been developing an enterprise
java so we're talking about things like
having a tomcat engine hosting servlets
and maybe an open ejb engine that's
hosting your enterprise javabeans on
this kind of covers you know the typical
deployment what you'd see in most
enterprises and I've called out six
specific places where our back
enforcement's can happen so starting at
the top you can obviously do this in
your application right one way to go is
to download the api's get get your hands
on the open source kit sorry about that
I guess you can still hear me get your
hands on the open source kid and then
just start coding into your application
put the are back api's into your app you
could go that way in some cases that
might be the only way you can do it
maybe you're not running in a container
maybe you've got some specific
enforcement that's needed within that
app that's different from what the
container deployment descriptors can
handle so in that case you would do it
in the app but then you probably want to
go down the stack in order to get kind
of broader coverage so we're going to go
through this picture I'll be pretty
brief and kind of surveying the six
options but then we'll talk in
particular about the way we actually did
it in the customer POC which is that we
did that integration into the j ee
container and in particular with a Jack
provider okay we'll talk about what Jack
is says I'm gonna even Jack before yeah
sure good question yes the slides are
definitely available you know and the
end the demo program as well not the
demo all show but the demo that sean has
captures all of the same technology
components that you can you can get a
look at so let's dive in let me go into
this picture we're going to talk a
little bit about each but we'll talk
mostly about that soft gooey center
there your application your application
framework and the java container i
started to dive into this the
application you can do your
back enforcement's in the application
that's certainly an option it's perhaps
the only way when you need fine grain
controls and it might be a good choice
if you're just going to get your feet
wet let's say you're just new to our
back you want to actually try this out
take it for a test drive see how are
back works out in an enterprise setting
for you then doing it with one app is a
perfectly good way to get into the game
right low risk you can choose an app
that suited to it something that you
have control over and then go down the
path of doing that implementation I
think that's great that's probably the
best way to start the challenge is that
you don't necessarily see the ROI when
you're doing just one app right so if
you want to do are back enforcement's
and you want to see a genuine ROI on
that investment you probably want to do
it across the enterprise applications
and the more applications you do then
the better pay back you'll see because
the whole point of it is some of these
capabilities like dynamic separation of
duties is only meaningful across
multiple applications imagine a user has
two sessions of two tabs in a browser
where they've got two applications live
at the same time being able to do that
separation duties across those
applications it's only meaningful if
both applications are enabled right so
that's a use case that's real world you
know you see in financial situations
financial services companies especially
in things like government and
intelligence those kinds of applications
do exist and having that session object
is the only way to do that you can't do
it across a single application so doing
it in one app is a good start but it's
probably not the way you want to end up
so to get those benefits of adoption you
probably want to do this across multiple
apps and when you're talking about doing
something across multiple apps now we're
talking about doing it in the framework
rather than do it in a single
application push it down right instead
do that enable mint within the app and
so this is actually what Shawn's demo
shows is that we don't just enable the
application what we do is we enable the
wicket components and so you have things
like an are back aware button or an are
back aware link or a page and the
developer who is charged with doing the
business application is just writing
business use cases they're making use of
things like an are back aware button
without having to worry about how that
works right so you keep the issues of
how to deal with the security
infrastructure away from the application
developer and as far as I can tell
that's always a good thing right so you
don't want to have that code tangling
one of the risks of doing it in the app
is that you could potentially get code
tangling between your security
enforcement code and your business
application logic so keeping those
separate having that separation of
concerns the best way to do that is to
do all of the security stuff down in the
framework and in particular we want to
push it even further we'll push it down
into the container okay so I've already
occurred this one examples from wicked
the our backhoe air page link or button
in the case of spring if you wanted to
wire this into the spring security
infrastructure relatively easy to do it
requires some explicit beam wiring where
you're going to pull together an R back
aware access decision manager folks
familiar with spring security at that
level basically you do some bean wiring
within your application context XML and
you're going to say i want my exes
decision manager to invoke a collection
of role voters each role voter looks at
some grant that authorities based on
what the users permissions are well it's
not too hard to add in an hour back
aware a genuine arm back aware access
decision manager or our back aware role
voter so I'm pretty familiar with spring
coming from pivotal so I use it all the
time and and this is definitely a route
I would take if you have a big spring
shop right maybe that's the the most
productive way the most kind of lower
low resistance way to get it rolled out
okay so let's talk about the container
nice to do it in the app better to do it
in the framework what if you have
multiple frameworks what if your
organization doesn't just use spring
what if you have a dozen different
frameworks that developers across the
globe have to have chosen and on top of
that they have different versions of
that framework right on different
platforms it begins to become a hassle
that even if you do do the enablement
within that framework you know I have
something of a maintenance concern about
keeping those frameworks up to date all
right so depending on your situation it
might make more sense to do this within
the Java container
right so let's push it down one more
level let's get it out of the app
completely do all of this with in the
Java container you've got some benefits
there right now a specific example of
this which exists right now you can
download it and start using it is
actually the fortress Java century
plugin so century is essentially a
tomcat realm provider tomcat has this
ability to be able to plug in the tomcat
container enforcement to a back-end
policy decision point and that policy
decision point will tell tom cat when
you're doing your container managed
enforcement's this user is allowed this
user is not right so there's a contract
there between the tomcat runtime and the
backend policy decision point which in
this case will be fortress so plugging
that in gives you the opportunity to
have real are back enforcement within
Tomcat and you didn't have to write a
single line of code in fact it's really
easy to do here's the complete XML
configuration to make that happen right
all you need to do is when you're
configuring that Catalina default host
localhost every developer I know has
this on their laptop you can just throw
in that additional element for realm and
class name pointed towards fortress
century implementation and you'll get
full are back compliance for that Tomcat
realm without doing anything but
downloading a jar it looks pretty cool
to me ok a little bit more about the
container again as you cook down in the
stack you get I think kind of a
guarantee of better service level
compliance across your enterprise if you
had every app managing this individually
you might get yourself into some some
deep water but if you're doing it at the
container level there's a lot of
benefits here because you're going to be
able to do things like ensure consistent
can service service level for all of the
apps within that container type all
right if you do that across your
enterprise and it's also going to
improve your operational processes
because doing our back is not just about
the conversation you have with the
developers right you can have the
discussion around developers need to use
this tool kit and this is the basic
secure
the architecture model that will adopt
but then having done all that there are
other things downstream right you need
to also deal with stuff like you have
auditors you have regulators right and
those things are real part of your
business process so what's easier do an
audit of every single app individually
or explain that the are back enablement
is in the infrastructure and basically
if you audit the the implementation of
the infrastructure every app that runs
in that infrastructure is guaranteed to
be compliant so the further down you
push it the better it gets pretty much
when you tell the auditor that you're
doing container manage security the
conversation ends in terms of how that
apps being secured so it's a good way to
shut him up yeah and as I was told once
in anything in security especially and
I'm a security guy right now I admit it
I'm a secure a geek if we have to do
this more than once I'm not interested
right you don't want to have to do these
things on every app across every
location that you have in the business
you want to do it once right so doing it
in your container is the closest you're
going to get to that there's a
advantages to container security that
extend beyond our back so single sign-on
something that jumps to mind so
delegating security the container is is
a good thing for authentication as well
mmm absolutely okay so one last problem
what if you have lots and lots of
different containers all right what if
you not just a tomcat shop you don't
just have let's say weblogic everywhere
right what if you've got every container
under the Sun that was ever created and
deployed into your infrastructure you've
got every version of tom cat and every
version of weblogic and websphere that
was ever created and now the the guys in
the new business unit using Geronimo
because they're from the open-source
crowd right now you have yet another
problem you have to actually do this in
a way that makes it manageable across
that harwich units enterprise and
realistically I don't know of any
enterprise that's not heterogeneous so
there's an answer for this there's some
smart people who thought about it and
they came up with jsr 115 so j sr 1 15
is the java authorization contract for
containers and it specifies a standard
on how to plug in a security provide
writer into that container managed
security right so you describe your
access control rules within the
deployment descriptor of the app and any
Jack compliant container with a Jack
compliant provider will be able to
implement that security right there's a
couple of facets to that standard
there's a deployment time contract we
are actually consuming the deployment
descriptor and building up the policy
representation and then there's the
runtime half of that contract where the
runtime requests are actually coming in
and your rujuta cating the decision and
saying yes or no based on the particular
context of what's what's happening on
that thread so jack is the standard that
says if I as a security provider
implement to that standard then my
security interface my security provider
back-end can work with any of the Java
containers okay it's a very good thing
to have and this is in fact the approach
that we took in my POC we went through
to doing enforcement's via the jack
there's a little wrinkle to that story
that I'll bit too but we stuck firmly to
doing it as a jack style implementation
so one last thing before I move on is
that it's just kind of an interesting
side note it's kind of important to note
that the jack standard actually went a
little bit above and beyond it actually
took another step and it unified the
enforcement semantics across java ee and
java SE security and there's actually a
lot to that there's a there's real value
and having that and one of the things
we'll talk about later on one of the
constraints here is that you can use
your Jack provider as your Java security
manager so when you crank up your java
runtime and you're actually running the
JVM you can specify dash D security
manager when you do that you can say
what class should we start as the
security manager for this JVM it's nice
to be able to use the same provider
class within the JVM that you're using
up in the Java Runtime container for j
ee right rationalizing that is a good
thing right general rule and security
lots of vulnerabilities occur because
two things are out of sync right so when
you have one thing that's supposed to be
the same in two places it's really
really good if their rep
saying the same thing and not two copies
or two different things so generally a
good thing that they included that
capability although it's not critical to
the POC it's important to know all right
so here's the challenge we want to do
enforcement's we want to do real are
back enforcement's within an application
and we want to do that against a jack
compliant provider but we can't actually
replace the jack compliant provider
because the one that's there is doing an
enforcement job against a set of
resources that we can't replace ok
because the policies that are relevant
there remain in scope that's not within
my domain that I can control so i have
to leave that in place and yet in
addition and the are Mac controls ok now
we're going to make it even harder on
top of that i have an application for
which I don't have the source code ok so
changing the app is not an option it's
basically unavailable to me to change
the source of that app the joke is that
the application programmer died and that
we can actually get the application
changed all i have is binaries right
turns out that's actually true in this
case that we don't have the original
application code ok we also don't have
the framework code so an easy route
would be that programmer died too yea
high mortality rate or undaunted
security people I guess I don't know but
we had framework that is proprietary
framework so this thing is developed
quite a while ago and it's a very
functional very rich useful wonderful
application framework that was used in
developing this app I don't have the
source for that anymore ok how do i do
enforcement's when I don't have the
source for the app or the framework and
I can't change the jack but I need to
add our back well there is an answer
right you know a drumroll please how do
you do that turns out that there's a
little trick called aspect-oriented
programming anybody ever use aop alright
so aop is the answer no matter what the
question is aop is the answer just kind
of keep that in your back pocket
okay you can do anything the coolest
thing about aop and I love this part you
can just replace vinyl classes not a
problem it's great thing right so apply
aop to this problem okay and we'll dive
in now i'm going to go into the picture
remember our picture here's our sack
reference model of all the ways you
could do this will Speier about this
stuff relevant for the p.o say we'll
take it down a notch to what it really
looks like so don't worry about the OS
right now can I don't worry about the
stuff the layers below the jvm and we're
not going to worry about authentication
at the moment let's assume just
authentication is delegated to the
container okay yeah we have a user of
making requests of this application and
requests are going to cut flying it and
we need to be able to secure these
things so three pieces to the puzzle the
first piece is that we need to do
something with that application
framework so I've implemented aop advice
where I've actually done some before
advice on the application framework and
when the application program makes a
call to the framework and says open and
read file I trap that call and make a
request to the jack okay so user request
comes in trap that using aop before
advice around the framework code and
call the Jack of course the jack doesn't
know the answer because the jack is a
dedicated jack that already has other
policies it does do but it doesn't know
about my new resources because the
things that I call resources are in that
framework and those things didn't exist
in the policy that exists in that jack
so what do i do I put a 0 P advice
around the jack provider okay I wrap the
jack provider with more advice and I
intercept the call to the jack now if
the call I see is something that is
container managed security for the
existing stuff that's actually described
in the deployment descriptor just let it
go let the jack do its job and I do
nothing but if the request came in for a
permission which is an are back related
permission
then I can trap that call and send the
request over to fortress fortress being
my favorite open source implementation
of an R back engine so the request goes
through this proxy and impul thing and
that's really just an implementation
detail but I want it to be accurate in
the picture so I included it there what
it is is that the proxy is a wrapper
around that Jack it's a very very thin
veneer it only uses pure Java and the
aop aspectj wrong time and so I don't
have to worry about class loading issues
because right there on the jack i'm on
the system class loader and so to make
that work cleanly we want to get all of
those extra classes that are going to be
needed off the system class loader so
with Sean's help clever trick basically
push that stuff off into the info class
which can be a jar file its its anywhere
else within the file system right and
doesn't need to be on the classpath of
the of the system classpath loader which
in this case you know the Geronimo
loader ok so here's a quick look at what
it is at the code level just a little
bit of pseudocode but it's pretty close
it's pretty accurate defined a pointcut
a pointcut as aop speak for i want to
intercept this call when this happens in
the call stack I want to inject new code
here and so that point cut describes
that when there's a call to policy
implies my opportunity to use my laser
pointer so right here describing policy
plus implies that means anybody who
calls policy or any of its subclass
subtype implementations I want to trap
that call and I want to get access to
the arguments passed in to that policy
implies call when that happens I do in a
round advice on the jack and the round
advice is basically saying put a c-clamp
around the jack method implementation
when it tries to adjudicate the policy I
call proceed first which means ok
continue run that method decide what the
result is from the jack and then if the
result came back yes fine let it go
that's fine by me right I don't really
mind that but if it came back no and the
permission type was an are back
Commission type then I call the are back
engine
alright make a call to fortress check
access and I actually pass that request
to my impul classes where it calls out
to fortress and guess what I can get
stuff like roll activations on a session
which wouldn't have been possible in the
container before alright so I'm getting
true are back with things like
separation of duties on the active
session by calling out from this Jack
advice just a quick snippet it's not
hard to do this is how you configure the
aop advice both on the jar file for the
jack and also on the application
framework jar basically you put this
into meta-inf you got to have an AOP xml
file that says what's the name of the
class you want to inject and you're
circling back the comment about the
security manager a compliant jack
provider can also call the java security
manager if it doesn't know the answer
and so if you actually dig into the
source code of the Geronimo Jack
provider which I've done you can see
that it delegates the calls that if it
doesn't have the solution for for the
permission implies whether it does or
does not imply then it'll actually call
the JVM security manager and let it take
a crack at it and so for reasons like
that you don't want to necessarily mess
with the existing Jack provider and for
us the the more effective the more
economical way to do this was to leave
that implementation in place and just
provide advice to any Jack compliant
provider well the jack provider
programmer died too ok last comments
here is that the security you have in
all of this are back infrastructure up
until your application is only as good
as the assurance of the underlying
platform right so if you're you can have
the coolest are back implementation with
the most rigid security within your
application you've done code scans
you're quite confident in the app itself
doesn't do you any good if the
underlying platform can be compromised
and so a future on this and not
something that I can demonstrate today
but Sean and I have been thinking a lot
about is that you can do these are back
enforcement's at the level of your
privileged users who have sued or
privilege at the OS prompt right no
reason you can't do that well the other
thing is that it offers the opportunity
for a backstop if there's a
vulnerability inside the application so
like the the thing with Java that just
came out recently where there's there's
a way of circumventing the the Gamble's
and basically defeating the runtime
security model so i don't know if you
guys saw that there was a there was a
vulnerability announced not too long ago
days a week or two ago but basically the
java wrong time had a vulnerability so
that the security model was broken by
doing a stack over on basically it's a
buffer olive loaf yeah ever so having
security down you know defense in depth
is the way we usually say that having
security down at the platform level
helps as well ok so wrapping up quick
summary I didn't show the movie yet but
if you guys are actually interested I
can show you the movie it's actually
kind of cool you can use real are back
now real are back is available and it
does have value for enterprise apps
don't go for the near beer go for the
real thing right getting real are back
is where you want to be and in the 8020
rule just to leave you with a couple of
kind of basic you know simple takeaways
I think what we're saying here the
summary is use our back it's available
today do it with container managed
security you don't need to do it in the
app you can start to experiment there
but you ultimately want to do this in
the container and there are open source
available open source implementations
available right now you know downloaded
kick the tires I think you'll be pretty
amazed at the you know kind of the level
of implementation for something that has
been a long time in coming I'm a big
open source fan I kind of feel like it's
about time we finally have something
like this because this is a missing
piece in the puzzle okay one last
comment I guess is the there's a buff
tonight I think it's the same room you
know same bat-time same bat-channel but
actually not the same time it's 530 this
evening basically this room open source
identity and access management expert
panel so if you're interested in open
source security tooling and I
Kennedy management tooling this will be
the place to be we have time for
questions I hope any questions comments
tomatoes please sure so repeat the
question is exact word example of a
toxic relationship so that that's kind
of typical examples financial services
it happens a lot but kind of one will
all experience when you go back home is
that you can create an expense report
and submit the expense report but you
can't approve your own expense report
right you might be an approver you might
be a manager of team and you can approve
expense reports but it's not possible to
approve the expense report if it's your
own expense report right so there is an
example of a separation of duties that's
a static separation of duties on a
dynamic separation of duties would be
something like I'm working on a specific
account let's say I'm logged in on a
particular account within a banking
application and I'm allowed to do
certain actions to that account but I
can't have that account open at the same
time I access a different account right
so you must end the session on the
previous account or end your permissions
your roles associated with that account
before you can do some other function
like maybe the case is separation of
sales and marketing &amp;amp; Investment Banking
right so you can you can sell stocks and
give advice on what you should buy and
sell but you can't do that at the same
time that you're actually offering
advice to the company you're Hawking
right that's not possible it's that that
goes against regulation we can go
through the demo I'm sorry question yeah
and I'll be
ok so I'll repeat the question show and
tell me if ever get out right the
question is essentially the the UI
component to how do you manage things
and actually make it usable for both the
administrator and also the end user what
does it look like when they're actually
doing things like activating a role for
dynamic separation of duties I think the
short answer is that the demo shows that
it would be good to see that demo so if
you want to come by we can actually show
it to you on the laptop here we just
won't be able to project it we cannot
figure out a time but we can pick it off
on if you want to yeah the other thing
too is if folks have time and you'll
want to see the demo I have a QuickTime
movie where I show the application I
work done actually views into the log
file that show where the intercepts are
happening and where the where the
call-out to fortress is changing the
result the container was going to return
but any case we're out of time thanks
very much for your attention appreciate
you coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>