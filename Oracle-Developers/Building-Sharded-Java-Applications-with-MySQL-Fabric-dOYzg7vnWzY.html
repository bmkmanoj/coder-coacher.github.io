<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building Sharded Java Applications with MySQL Fabric | Coder Coacher - Coaching Coders</title><meta content="Building Sharded Java Applications with MySQL Fabric - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building Sharded Java Applications with MySQL Fabric</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dOYzg7vnWzY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right I guess we'll go ahead and get
started welcome everybody I'm Jess
balint I'm a developer on the MySQL
connectors team this is building sharded
java applications with maya skill fabric
so first I just want to get an idea of
who's here and what you guys do so if I
get a show of hands maybe how many of
you guys are already using MySQL and how
many of you guys are building sharded
applications on mysql and do you have a
custom sharding solution or using some
frameworks okay okay I think that's how
a lot of people are doing it and now we
have a product to address that and I'm
gonna talk about it today has anybody
heard of MySQL fabric anybody go to the
MySQL fabric tutorial yesterday get an
idea great person so I'm gonna talk
about fabric and I'm gonna talk about
sharted applications from a fabric
standpoint so I will talk a little bit
about fabric and give you an idea of
what it is and a little bit of an idea
of an idea of how it works mostly from
the client standpoint so I just want to
encourage you to ask questions if you
have questions about fabric or how it
works or something doesn't line up with
what I'm saying just raise your hand and
I can answer questions about that I do
work directly on this on these programs
as a developer so if you have questions
just let me know and I can give you you
know detailed information about how
things work or how things might fit into
your applications or systems so anything
I say is not a promise it's not binding
so all right so as I said first I'll
talk about MySQL fabric and just give
you guys an idea of what it is
after that we'll talk about fabric
clients and this really incorporates a
continuing kind of exposition of what
fabric is after that we'll talk about
specifically the connector GAAP is and
this is how you're going to you know
build your applications is going to use
it sorry use the api's from our
connector J our JDBC driver after that
I'll talk about some application
approaches and this is how you can
use sharp fabric from your application
and there's suffering several different
features that you can use and there's
several different approaches you can use
to make use of those features so what is
MySQL fabric it's a framework for
managing server farms and so what that
means is you have a lot of servers you
have a lot of different things going on
you have replication going on you have
different pieces of data in different
areas fabric can help you manage that
and it can help you build applications
that'll take a lot of the work away from
either building custom solutions for
that or doing it manually and if people
are taking photographs we are going to
publish these slides will publish in the
open world website so just don't feel
that it's necessary to take photographs
to capture the information they'll be
online later so there's there's two
right now there's two core features that
fabric provides the first one is high
availability groups and what that means
is right now just master-slave
replication so if you have a master in
some slaves you basically have what
we're calling a high availability group
and in fabric you can manage high
availability availability groups as as
kind of atomic units so if you have
different sets of data in different
replication sets you know you can manage
that high availability group and any
number of high availability groups can
be managed by one fabric system the next
feature is sharding and sharding is kind
of falls under this scaling area in this
Venn diagram and what that means is if
you have a big set of data that you
can't split up sharding will basically
allow you to partition that data into
different sets of servers and then
you'll have to route your applications
queries to different servers and a lot
of implications come with it so fabric
will help you manage that
so a little bit of detail about how
fabric is set up one of the main
components is what we call the fabric
node so the fabric node is separate from
the application databases it's kind of
something else that's off to the side
and it manages the state of the farm so
if you if you do have a replication set
up it'll manage that that replication it
will work on it I'll have a failure
detection and dual automatic failover
and it'll know which servers the master
and which servers are the slaves and who
is a slave of who and provide that
information to your application so it's
a source of the farm State for
application clients so what this means
is that you know it centralizes
replication topologies so when your
applications want to do a write to the
master they can get the information from
fabric and they won't have to have all
have a separate configuration that
you'll need to update for each client
and then like I said fabric implements
high availability and charting across
servers in the farm so you can have any
number of servers and groups you can
have a lot of groups and all those are
going to be part of your ultimately your
charted system so fabric clients so if
you do have a fabric system one of the
main components is a fabric enabled
connector and just as you have a JDBC
driver or connector for your application
to connect to the database now you have
a connector for your application connect
to a fabric farm so what that connector
does is it fetches the topology of your
MySQL instances from the fabric node so
that fabric node that just has that
whole farm state in there that the
connector will go and it'll find out you
know who's the master who are all the
slaves where should I rock quarries to
and then inside the connector it's going
to make connections to individual
database servers so there's no proxy in
between there's no extra network hop for
every single query something like that
the fabric clients can communicate with
the fabric node with either xml-rpc
or MySQL wire protocol and that's new in
in the fabric 1/5 and what that means is
that internally when we fetch that state
information it's going to be using one
of these two protocols and if you want
to write another utility that's going to
connect to the fabric node either for
administrative or for application level
request routing you can use either of
these two and so with the MySQL wire
protocol you can basically connect to
the fabric and treat it like it's a
database server and and make a query to
it or send a command to it so the the
MySQL fabric in the quotes over there is
the main command line program that you
use to access fabric and so that's going
to work with the same principle same
communication protocols so the fabric
connectors they maintain a copy of the
state of the farm or more specifically a
state of the part of the farm that
you're using in your app different
applications and what that means is that
when you create a connection to a fabric
farm it's going to go out and say hey
what's this what's this farm you know
what are the servers in it and how is
the sharding set up and what's the
configuration and then it's going to use
that to create the individual
connections to the database servers so
the the TTL here that controls the state
expiration so ultimately there's always
going to be something that changes
they're giving me something that fails
something that's going to need to be
updated from the fabric server into the
clients and the TTL is what controls
that so it's time to live so if it says
you know five minutes is your time to
live at some point before that it's
going to know that it's gonna be facing
an expired state and connect to that
fabric node and say hey is everything
the same or has something changed and we
call this the connector cache
so the connector cache like I said it's
a copy of relevant state of the farm so
if you have you know five or ten or even
more high availability groups and you're
only using one from a specific
application it's not going to fetch all
the information for all of them only the
one that you're using or ones that
you're using and the same thing with
sharding so an H a group in terms of the
metadata in terms of what it gets back
from the fabric note is just a set of
servers including their role which is
master/slave in their status which is
hopefully available and it could be
faulty so servers that are slaves are
servers that are masters that aren't
reachable any more will be updated their
status will be updated in the fabric
node and so the client won't attempt to
make any more connections to them in
terms of sharding so as I was saying the
sharding feature in a sense layers on
top of high availability groups so if
you have let's say three or four shards
for shards each shard is going to map to
one h a group so in each shard it's not
just one server but it's a set of it can
be a set of servers meaning one master
in several slaves so you do have high
availability within each of the shards
this diagram illustrates basically
everything that I've been talking about
but in a hopefully comprehendible form
so if this is your application you know
you have a connection here it's
connector G as your connection and over
here is the connector cache and so as I
said that's the state of the farm that's
that's the topology information and the
sharding information and to populate
that connector cache we have a
connection to the fabric node and that
happens inside the connector and then
once we have that topology information
we use that to create physical
connections to each of the individual
database servers and then if you can see
I know it's a little bit small this over
here is our master server and this line
it says read writes so I'll read write
more importantly the right part of that
queries are going to go towards the
master and then over here we have two
slaves which you are
be accepting read queries so we call
this a physical versus a logical
connection in connector J so from an
application standpoint you would have
let's see I'm not sure what this is
typically so the physical connections we
would have one connection from the
connector per database server from the
application standpoint you would have
one connection to the farm so when you
make a connection you're saying I want
to connect to this farm of servers and
then inside and connector J it would
make connections to individual database
servers so right here has physical
connections and then this larger box
that says connector J would be a logical
connection from the application point of
view so the application is making one
connection to the farm you know one JDBC
connection object and then underneath
it's making several physical connections
internally to each individual database
server so ultimately there will only be
one connection active at a time so when
you start a transaction or you do some
you know database query it's gonna say
you know what are the parameters am I
supposed to be going to a specific shard
am i in read-only mode and at that point
it's going to pick one of the physical
connections and it's going to use that
to route queries to that database server
and it is possible if you need to know
that for some reason you can ask the
connector to provide the information on
which physical connection it's using and
you can get the IP address of the server
and the port of the server and that type
of stuff
so this talks about the fabric enable
connector in the connector cache just
like I was talking about so there is an
internal set of connections to physical
servers and that works in a way that
where you make a connection to the farm
there are no initially there's no
physical connections it waits till you
actually want to perform a query and
then it says what are the parameters so
if you have you know 100 shards in your
system and you create a connection to
this dis charted fabric farm
you're not going to immediately have 100
physical connections made to each of
those shards so the routing is performed
on transaction boundaries and this means
that in the middle of a transaction you
can't change the shard key you can't go
from read-only mode to read write mode
because that would involve different
parameters that would change what the
current active server should be so after
you commit your transaction at that
point you're allowed to change change
those parameters and then if you specify
specifically an H a group that's
something you would be able to change on
a transaction boundary read write mode
sharding information which is the key or
the tables and internally we also do
load balancing so if you have several
slaves and you run some read-only
queries and you commit a transaction and
then you run some more read-only queries
they might go to a different slave it
depends on the the load balancing
algorithm this diagram is an idea of how
a connection is made to just an H a
group so not considering shard are
starting for the for a second we we see
up here the connector is connecting to
the fabric node and that's just getting
information about the topology and then
here we have on the Left we have the
readwrite Court or sorry the read-only
queries the green ones are going to the
slaves and the red arrow on the right
from the connector is to the master and
then that master is replicating to those
two
slaves so physical connections to shards
so as I said before the shards the
partitions they point to a che groups so
each shard basically is a partition of
your data and so each shard is
represented physically by a group of
servers that that store that data so in
the fabric system we define this by
creating shard mappings and basically it
says you know this key range goes to
this shard this group of servers and
this key other key range goes to this
other group of servers and there is a
concept of having shared data across the
sharded data set and this is in what's
called a global group so the global
group is is basically the non shard of
data that you have in your system so if
you have sharted data you know we use an
example of employees if you have some
other kind of global data like companies
you wouldn't want to shard that because
it would be it wouldn't be partitioned
in the same way that employees would so
you would store it in this global group
and then it would be available on all
all of the Charlotte servers and that
when I say group I mean H hey group so
it is a again a set of an a set of
servers can configured in H I
configuration the shard mapping is
defined on the database the table and
the column so if you have an employee's
database you would specify which table
and column you're gonna shard on so you
might have employees table and then
employee ID and so the employee ID is
going to be your basically your range of
keys that you're gonna be able to use
and then you would specify which there's
two algorithms which range or wish which
hash range is going to be on which shard
for that employee ID field and the
routing on shard keys is provided at
runtime so what this means is that you
can change the shard and key in between
transactions and operate on different
data almost continuously
so here's an expansion of the diagram
that I just showed so before we saw some
queries from the connector going to
master and slave and this one expands it
to include two different shards on two
different H a groups so the red
connector gets the mappings from the
fabric node and then it routes the
sequel queries to both let's see this
one on the leftmost here would be a
connection to the master and then that
master is replicating to these slaves
and in this diagram we have some extra
read slaves here so the connector will
get all that information from the fabric
node and we'll be able to make decisions
on where to route the the application
requests based on that and so these ones
on the left side would have a a disjoint
shard key range then then the ones on
the right side so on the left side we
might say employees you know 0 to 1,000
on the right side we would say employees
1,001 to infinity so just to go back
over this the application connects with
the fabric enable connectors so from the
application point of view you're
connecting to a farm of servers you're
not connecting to the fabric node you're
not connecting to the individual servers
you're connecting to the farm of servers
and then you're specifying what the
criteria is for your query the fabric
node maintains the farm State so that's
that's something that you don't have to
worry about in your application you
don't have to add slaves to every single
application server instance you don't
have to try and centralize that in any
other way and the connectors ultimately
make the individual connections so this
is the physical connections to the
physical servers so internal to a
connection it could be using one
physical connection it could be using a
lot to different slaves because you've
using a lot two different shards there's
a lot of possibilities does anybody have
any questions about the fabric system so
far yes
oh the question is what are the water
all the black lines so the outermost
ones here on the left and on the right
are going to the master nose masters
those red lines are replicating to all
those slaves so that would be a right
query and then if you had a read-only
connection that these inner black lines
these two right here would be going to
slaves so it could be these slaves here
it could be other slaves in this other
part of the group those would be
read-only quarries going to the slaves
yes in this diagram yes the I guess
there's no explicit mention no that but
yes the way I've described that it is in
sharded setups it's possible that you
could create different h.a groups and do
whatever you want with them
but from a sharding perspective if this
was a sharded configuration then yes
each of these HJ groups will be separate
shards I think it's just on here to show
that you can have kind of separate
levels of scale out for read queries so
you might have this as your main kind of
H a group and you might be doing backup
and specific high-priority read queries
on some of those and then have extra
read slaves in a different class for
some reason but there's not really no
distinction from our our presentation in
our or doing here in the back yeah
there's all kinds of stuff and that's
the content for the remaining part of
the remainder of the presentation so
there's all kinds of stuff if you have
more questions afterwards yeah yep yep
good that means you get it yep
generally there shouldn't be there is a
little bit of extra steps when you first
make a connection to fetch that apology
information and there can be points in
time where you have to refresh that
information but there's there's no
general extra amount of work that needs
to be done I mean that those routing
things that need to be done you know if
read only I mean that's an extremely
trivial thing and the sharding lookups
it's conceivable that if you did have a
extremely large number of shards then it
would take take a measurable although
still very small amount of time so we
are keeping that in mind and making sure
that either it doesn't impact anything
or there are ways to mitigate it yes sir
customers go here
every query
matters or help
I'm sending you customer yeah that's
that's essentially how the sharding
works so once I get into the api's and
stuff and that the further part of this
it should make more sense yep sure if
you use an asynchronous replication you
still have the same implications that
you do on any you know MySQL replication
configuration yeah I mean currently yes
yep that's right
sure yeah yeah yes right now the
connections are saved inside the farm
connection and there is no provision for
managing those or getting rid of them
besides closing the connection we do
have some idea about good ways to
address that in a way that's flexible
for different requirements and different
setups they are established lately so
what we do is we make a connection to a
group in we make individual connections
to groups so if you do have a ton of
groups that could be a little bit of
memory overhead but there won't be all
the connection the physical connections
to those groups until you actually use
them yep one more yep
yep our MySQL indeed does have fabric
support and whether that works for you
is something that we can discuss or you
know evaluate your application all right
so let's move on so now I'm going to go
through an example and this should kind
of get you thinking about how that how
an application works over a fabric farm
so this is an employee's database and
this is an example that we've kind of
adopted in in several pieces of
documentation and several the demo
applications so it might be familiar to
did you guys talk about this in the
tutorial no okay if you've looked at the
documentation or anything you might be
familiar or when you're locking in at
the documentation after this you'll
you'll recognize it so what we're going
to do is we're going to make a shard
mapping and we're gonna use the employee
ID and that means that that's our key so
everything's gonna be partitioned by
employee ID and I just put a note in
here if you're playing around and you
want to change it to last name as an
exercise you can do that too to make
sure you kind of got the idea and want
to play around with it and make sure I
don't know just try things out we're
gonna use two shards the first one is
called employees one and that's going to
be ID 0 and above until the next shard
so we only specified the lower bound the
next one is going to be employees two
and that's going to be 1,000 and that
will wrap around back to zero so this is
using the connector J fabric demos which
are included in the connector J
distribution so our H a groups are going
to look like that diagram we were just
looking at we have a global group though
so the global group as I said it stores
the shared information for it for the
whole data set that you're charting so
we might have tables like a department
or project stuff that's not
big enough that requires partitioning in
your system so employee correlated
information will be sharded and so this
means that stuff like HR records that's
not in your you know employee table
additional tables that are employee
correlated will also be charted so HR
records are performance reviews I'm sure
you could think of all kinds of stuff
and then the individual groups for the
shards so we have employees want
employees to and each of these shards
stores a copy of the global tables and
obviously the employee information
that's that's part of that partition of
the data set so what physical instances
are we're gonna have so if you remember
each of these is going to be an H egg
group so each one is going to have at
least one server but can have multiple
servers so in the global group we have
at least one readwrite our master server
and any number of read-only slaves
within reason so that rep that global
group is going to be a replication
master to the individual shards so that
shared data when you update it in the
global group it's going to be replicated
down to the individual shards and that's
how it's it's copied down as shared
information to all the partitioned
information and then the same thing for
employees wanted to do we need to have a
master server there and then each group
master like I'm saying is a slave to the
global master there is a diagram I'll
show you in a minute oh there it is
perfect and this just illustrates what I
was saying so this global master this
this global group is where your shared
data is and this global master is going
to replicate the shared data to tell
every individual shard master so that
that shared data is available in your
your partitioned shards
so the shard mapping it consists of
several components and this is this is
the fabric model for for building a
shard it's set up so we specify our
global group all our groups are gonna
have names and we call this employees
global so when we create the shard
mapping we say employees global is our
global group next is the sharding type
we're gonna use range charting so that
means that employees with a certain ID
are going to be in a certain ID range
are going to be in one shard and another
range ring mean a different shard the
other possibility is hash charting which
you can use if you want to have a
distribution on some integers and not
have them grow in shards unevenly so all
the shard of tables have to be
partitioned on the same key so this
means that if you wanted to shard on
employees and also on some advertiser
data you can't shard on both employees
and advertiser data unless you create
some kind of surrogate key and split
them up so everything has to be
correlated to the main shard key that
you set up but we can have multiple
tables so here we might have like
employees and employee HR so the HR data
is correlated to the employees but it's
in a separate table but it'll still use
the same key which we call EMP and oh
here and we just use that as our primary
key on both those tables maybe it's not
enforced so if you have more than one
row in the HR table per employee it's
still gonna work so the shard index is a
component of the shard mapping and what
the shard index is is it says which key
ranges go to which groups so that's
gonna say key 0 and above which is going
to go to a thousand because the
so yeah zero and above until the next
shard is going to go to employee one and
a thousand and above is going to go to
employee two so these two right here are
what we are calling our shard index so
if you're if you're working on this and
you create a shard mapping the first
thing to do is say sharding create
definition range that's our starting
type and employees global that's our
global group and then the one key thing
that you need to pay attention to here
is this result and that's your shard
mapping ID so the fabric system does
support any number of shard mappings so
you can shard employees database you can
shower other databases as long as
they're separate and they would just be
considered separate shard mappings so
we're going to call that our mapping IDE
I wrote it up here so if you follow
along just make sure that you pay
attention to that you can see some other
information from the requests we are
time-to-live 3 it's it's expressed in
seconds so this information would only
be valid for 3 seconds and then we would
have to go back to the fabric node to to
refresh it so here's the rest of the
commands so the first one we did before
and we got back a mapping idea of 2 so
it says creation of shard mapping we
have to specify the sharding type and a
global group and it returns the idea of
that new mapping next we have to add the
tables to the shard mapping and so when
you add the tables you add all the
tables that are sharded on that that
main key that you're gonna use so in
this case we specify add table and then
mapping ID which is an environment
variable and then database table and
then our key on that table next we
create the indexes and the format of
this is the group and in the lower bound
and in the group and in the lower bound
so in this case we have our the shard
and what group it maps to so this will
create two shards
so in terms of sharding from a java
standpoint the sharding is not
transparent if you're using JDBC and
what that means is that you do have to
hit to the connector what the shard key
is and we'll get into the API so you do
have to say what the key is and that
that's used to route the query to one of
the shards another thing is you want to
do a manual assignment or a generation
of key values because you can't use an
auto increment it might like to
violations of the shard keys you know if
you were doing inserts on a table and
you didn't know what the key was you
might get a an auto increment value that
goes out of the bounds of that shard the
transaction scope is limited to data and
single shards so this means you can't
for instance in insert data about
employees multiple employees that are in
different shards so that would have to
be two separate transactions
additionally modification to global data
have to occur on the global master so
they also can't occur in in the same
transaction as modification to sharded
data and a fabric enabled connector is
necessary and that's that's connector J
in this case which would handle most of
this stuff for you so now we're going to
look specifically at the connector GAAP
eyes
the fabric system is relatively new the
first release was about a year ago and
connector j5 130 had support and the
most recent release v 132 now v 133 we
only support fabric 1/5 and the later
releases there was a change in
communication protocol and that is
something that is forward oriented so
any more changes in the communication
protocol won't completely invalidate
older versions that the connector like
this one did so back to the question
about how we use this stuff so first
we're mostly going to look at
connections to H a groups individually
so to make a connection with a to a
fabric farm you specify this dis fabric
marker so normally just have JDBC MySQL
now you have JDBC MySQL fabric and
instead of pointing to a database host
we point to the fabric node and in this
case it's localhost and then afterwards
as normal we have the database we have a
lot of new connection properties fabric
username and password and that's for
authentication to the fabric node and
that is optional so if you have a system
that you don't want to have to specify
that you can disable it so fabric server
group nate fabric server group name
means we want to connect to one H a
group so if you only have one H a group
a couple of servers or several H a
groups and you're not charting you would
use this fabric server group name
connection property and that would allow
you to connect to that just that group
so for sharding we have fabric shard key
and fabric shard table so if you want to
hard-code these as connection properties
if you have a connection that's only
going to operate on a certain subset of
shard of data on one shard you can
specify the key in the connection
and this last option fabric report
errors is kind of a distributed failure
detectors so the connector is able to
report errors from connection errors
from different servers back to the
fabric nodes so the fabric node might
not realize in a certain amount of time
that a slave is down that a masters down
and the connector can be proactive and
report these backs so the fabric node
can make some decisions on that so this
fabric report errors allows you to
enable or disable that that specific
behavior so accessing h.a groups with
properties so this is gonna be our
standard standard JDBC URL and API so we
can do this without any code changes all
have to do is change that connection
string it might even be in your XML
files properties files whatever so to
connect to an H a group we would just
use this fabric server group name
property and that would just be your
group name when you created in the
fabric node and then connection set
read-only controls the master slave
access and this can only be changed in
the transaction boundary so like I said
you can't start a read-only transaction
and then flip it over to - not read-only
mode and start trying to insert data
the question is do we check check that
yes we do check it so if you're in the
middle of a transaction of a read-only
transaction and you say set read-only
false you'll get an exception and it
won't affect your transaction you can
still continue on
it's a recoverable exception so here
I've just have two simple examples of
probably what a lot of people are doing
driver manager gate connection not so
much anymore but if you're writing some
code you want to use this stuff you just
have to put that fabric marker at the
top and put your connection properties
in there and then boom you have a
connection to a fabric managed farm of
servers and then here we have an example
of a data source in spring you have the
same thing in your application servers
you just specify the extra parameters
down here and make sure to include
fabric in your url so property versus
API configuration now we're getting to
some of the stuff that's outside of the
JBC standard possibilities or code
interfaces so the properties are
configured during the connection
creation you can't change them in any
standard way through the JDBC API so if
you set that stuff in your connection as
connection properties you can't change
it during the course of the connection
the API is allow augmenting or replacing
those property values so if you want to
setup a shard table as default and then
specify the keys as your application
runs and routes the different shards you
can do that using the api's and these
are not in JDBC API so they're
extensions so
so dynamic H a group access means you
want to change which group you're
connecting to or you're using during the
lifetime of a connection you can do that
with the api's and charting same thing
if you want to change charting
information during a connection which a
lot of use cases will need you'll need
to use the API s if you do have a
prepackaged application or something
that you're limited in terms of code
changes it might be a problem so in
terms of API is we have a class called
fabric MySQL connection and so what you
do is you get your connection and if
it's a connection pool it might be
wrapped but you cast it to this fabric
MySQL connection class and in the case
of jad before JDBC for if you need those
specific JDBC form methods you would
have to use a separate interface so one
of the methods that we provide as clear
server collect server selection criteria
so the server selection criteria is the
read-only mode and the sharding
information and what it uses to
determine where it's going to route a
transaction to so the clear server
excuse me and it's hard to say clear
server selection criteria is what you're
going to use in between transactions or
to clear everything out to to restart
setting those criteria some of the other
API is our set server group name get
server group name so that'll allow you
to change the server group during the
connection lifetime get current server
group will return you a server group
object so if you did have some reason
that you wanted to know the H a group
you can do this through the API is that
server group will have a list of the
servers that are part of the group and
their role in their status
so the sharding api is you can specify
these with shard key and shard table
this is just for reference mainly you
can find this stuff in the documentation
so these are these are the functions
that you would call if you were writing
a sharded application and you wanted to
change the shard key during during the
runtime
another thing is we have this this query
table so if you don't want to specify
the shard table directly you can specify
all the tables that you're using in your
query and if we detect that one of them
is a sharded table we'll will route it
to the proper shard if none of them are
sharded tables then we'll route it to
the global group so this kind of gives
you a little bit of abstraction from
having to know in the application what's
charted and what's not in the case that
you want to you know plan to do
something different later or have the
opportunity to be able to change stuff
at a bigger scale than then getting
locked into one sharding configuration
so to query the sharded data we notify
the connector that it is over shard data
and so you either have to call set shard
table on one to tell it which shard
table you're querying over or as I was
just talking about add the query tables
all the tables that using in your query
and it'll be able to determine that for
you so for the shard key you have to
provide with the the set shard key call
and after that once you begin your
transaction this is like creating a
statement or preparing a statement
something like that it'll be able to use
that information to either make the
physical connection needs or find the
physical connection that you needs to to
route that transaction so I'm going to
go through our employees demo which is
in an in a source package under this
path and there's some links here if you
download this this is a description kind
of an annotated version of this demo
application and it'll tell you what it's
doing and why we're doing it and how it
works
and this right here this link gives you
fabric configuration for running samples
just tells you how to set up the
employee database and how to get that
the shared data and the sharded data and
how to set all that stuff up for this
example and it demonstrates the use of
many properties and api so if you're
starting out and you're trying to get
this stuff working look at this example
it's got a lot of stuff
they're just spend a little bit of time
and look at what it's doing and try to
understand how you can use it so here's
some Java code so what we're doing here
is we're just connecting with a go over
here
we're just connecting with the fabric
server group connection property and
we're connecting two employees global so
in this case we connect to the global
global group and since we don't do set
read-only it's going to be routed to the
master we create a statement and then we
create the database close the statement
in the connection so that'll create the
database on the master group which will
in turn create it on each of the the
shards so in this case we do something
similar so we're getting a connection
but in specif instead of specifying the
server group directly we specify the
shard table employees that employees
that's our charted table but since we
didn't specify any shard key there's
there's no routing to an individual
shard so this will go to the global
group the same one we were just
connected to explicitly so this means
that you don't need to know the global
group name you can just say I want to
connect to this charter table and since
I didn't set a shard key I'm not going
to any specific shard I'm going to the
share the data the global group and so
now we create our employees table so
here we get into some actual sharding so
here we're casting the connection like I
was talking about before we cast it to
this fabric my SQL connection interface
in this line here and that provides an
interface that gives us all those
methods we want to call for this
charting so here we have some arrays
with some data we have IDs one and two
go in the first shard 10,000 one town
10,000 one 10,000 two will go in the
second shard so we create a prepared
statement on that connection and we're
using the same connection from before
we're connected to this employees that
employees shard a table and we create a
prepared statement and here we call
connection dot set shard key and
I guess this is running in Auto commit
mode so we're not explicitly committing
our transactions here so it's unlikely
that you would get an error if you're
changing that because you're committing
your transaction after every statement
implicitly so once we once we hint that
shard key that ID right here we can just
use our JDBC prepared statement just as
we normally would set in such string you
know give it the data it needs to bind
to the statement and then execute it so
at that point when you call that execute
update it's gonna say okay I have the
sharded table I have the shard key I
know I'm not in read-only mode go to the
master server so it's going to go to the
master server and execute that insert
statement and since it isn't excuse me
since it isn't is in Auto commit mode
it's it's not gonna require an explicit
commit now when we're gonna look at that
data when you're on this it looks a lot
better than it does in code so we'll
print a table with the employee number
then first name and then last name so
what we do here is we prepare a
statement so we're going to look up
employees specifically by ID and so each
of the IDS we're going to loop over them
and say connection set shard key just
like we did in last one so the first
idea is going to be one and again
bind the parameter execute the query we
did not specify read-only so this will
also go to the master and if you specify
read-only it'll be routed to one of the
slaves if they exist and then we go
through the results set print it out in
that table and then close it so what
this is going to do is it's gonna
execute four separate queries one for
each of the IDS that we had up here and
it's going to print out each of the
employees that we inserted and then
afterwards we can say set server group
name global go back to the global group
you could also do this
you could clear the service selection
criterion specify your shard table again
and then we just drop the table just as
a cleanup for the for the demo so you
can run it over and over again so what
you should pay attention to here is that
as I said this is a good example so if
you're gonna try this stuff out look at
it look at it and if something's not
working say what did I do and what are
they doing and how is it different so
first of all we did non sharded data
access through the global group and we
did this in two ways and we specified it
explicitly and we specified the shard
table with no shard key and the shard
key is is provided on the connection so
you are able to have prepared statements
left open and they will be routed when
you execute them the transactions are
routed based on the shard key
information and the read-only mode of
the connection server-side prepared
statements are not well supported in
this model and the obvious reason for
that is that they are pinned to one
server and we don't know that there will
be available on a different server or
and we don't keep track of them to reap
repair them anywhere else so we do have
some support for hibernate and this is
using a hibernate for feature called
multi-tenancy so hibernate does have
some provision for this and it does
require a lot of manual configuration
and what we've done is we've created
some code that basically does all that
manual configuration by getting the
topology information and the sharding
information from fabric and then just
creates all the individual tenants as s
fabric calls them and through this
fabric multi tenant connection provider
and allows you to use those through
through hibernate the shark is provided
as a tenant idea transaction creation so
how do we do that so there's again as an
example it's it's kind of a bunch of
boilerplate code that you have to use to
get this working
but it's real simple you don't have to
do much beside it's copy and paste it
into your your hibernate session factory
creation a lot of people familiar with
hibernate some a lot yeah and then to
begin a transaction we have this here
session factory I guess I should be
lowercase but with options to an
identifier shard key open session and so
instead of the normal open session to
start your transaction you have to
specify the shard key as the tenant
identifier so you're able to use that
that sharded data set through multiple
different api's if you're using some
JDBC parts of your application some
different applications some using
hibernate you can still reuse it so the
last part of this is kind of how are you
able to how are you able to integrate
fabric into your application and that
depends both on your application and
your data set how your data set is going
to be either an H a group or sharded and
what opportunity you have to make
changes to your application and what
what you want to do basically so one
option is that is the property based
JDBC connections and this can do a lot
for you but it's also limited the
advantages that you only have to change
the JDBC URL you don't have to make any
code changes in terms of setting shard
keys or specifying server groups or
anything like that so if you have JDBC
code it's still going to be JDBC code
when you use a H a group through this
approach it does require that you
specify read-only on connections some
people do it some people don't
it does have a lot of benefit in JDBC
especially with MySQL there's a server
explicit read-only mode now so it will
enforce that on the server it's suitable
for connection pools so if you have
connection pools all you have to do is
update the update to properties in your
connection pool configuration and it
will work just as a work before
and again as I was talking about in the
beginning these are logical database
connections these are connections to the
fabric managed farms so these are
individual database connections so an
example would be at the bottom here like
database hosting you could host
databases for customers and this means
you don't you don't have any
requirements on the schema or how the
customer uses the database you're just
hosting it form so you would have one h
a group per customer it could be one
master it could be one master in ton of
slaves the physical instances are
managed independently for each customer
so each egg each h a group per customer
is going to have its own configuration
and no data is shared across those
possibly different schemas the client
application would use a separate data
source and a slash connection for each
customer so it depends what your
application are or your applications are
or if you want to give the customer
direct access you can just use this
connection URL fabric server group and
then specify the group in the connection
so for sharding if you have a no host ID
application like WordPress or something
like that you might want to shirt shard
and have one shard per customer
and so again you can manage physical
instances independently for each
customer but you can have a shared data
set shared schema across customer
databases this means you need to have
the same tables for the sharded data and
the shared information is gonna be
replicated from the global group so
again the client application would use a
separate data source or connection for
each customer but instead of specifying
the server group name explicitly would
specify the table and the key so for
dynamic sharding as I showed earlier the
tables can be provided with the sharding
api or a property so a lot of times you
will shard on one table and you might
say we're starting on an employee's
table and you don't want to have to add
code to add the query tables you don't
need that level of kind of abstraction
from from the data
lay out so you can put the table as the
property and then specify the key with
the API so the key has to be provided
before the transaction begins and once
the transaction begins it locks you into
a physical connection so it's not able
to be changed after that the big thing
is these charting api's might require
significant code changes to your
application if you have an application
and you're doing all kinds of data
access everywhere and you want to move
to a sharded model you're gonna have to
go in and make that call that set sharky
call that's the absolute minimum you're
gonna have to do to move to a sharded
model like this if you're using JDBC API
s there are some opportunities to do
this with AOP and spring the delegating
datasource is an interesting ones so
basically it doesn't have a fixed data
source it can have a pool of data
sources and you can write some some
little bit of code to make the decision
when the you know whatever if your web
application when the web application
requests a connection you could have
some thread-local set somewhere it might
be the user ID and then you can use that
to hand a connection back even call set
shard key through a a piece of code
that's not at the kind of request the
database request level so you could do
something like that in spring and I know
some people have been doing this for
sharding for a while so it is a an
approach that's out there the last thing
I want to talk about is this low-level
fabric node access so as part of our
implementation we obviously had to
connect to the fabric node in get the
sharding information the server
information and we created some classes
that you can use if you want to connect
to the fabric node for tooling or for
your own types of charting needs
the first one is fabric connection
that's the higher level one and the low
level one is XML RPC client and these
these API is the methods on these
classes provide the same commands as
MySQL fabric and this is used internally
in connector J so what we can do is we
can create and destroy groups so if you
want to do this in
and a tool that you read in Java you can
use these classes if you want to add
remove promote servers all of the
commands that fabric provides are
accessible with these api's you can do
your shard setup you can do sharding
administration and it as I said it's
useful for administrative stuff all
right so that's that's the the technical
stuff so you just got to remember fabric
manage fabric manages farms of MySQL
servers the H a is implemented H a
groups its a master-slave replication
right now asynchronous and the sharding
is built on top of these H a groups so
fat connector Jia has support for H a
and sharding read/write splitting does
require using the read-only mode on the
connection H a group access will works
good with property based configuration
if you don't need to change to a
different group during the connection
lifetime the sharding likely does
require coding to the API so that may
require code changes it may require code
changes if you can do a flexibly in
spring or may require code changes in a
lot of data access code and hibernate
support is available so it is an option
so when you get home and you want to
read more about this stuff go to the
manual the manual has tons of good
information on fabric fabric is part of
MySQL utilities one five two just came
out and it's a ga release of fabric 1/5
it just came out right at open world and
another thing is the forum's come on the
forums there's people looking at them
all the time get your questions answered
ask questions and have discussions
there's a lot of opportunity there we
have some blogs the years MySQL high
availability calm it's not fabric focus
but it does have fabric based content on
it and other replication some of the
engineering blogs we have some of the
fabric engineers VN mots offer any Oh
myself you can check on their for for
fabric related
information there's a lot of tutorials
there's a lot of informational how
fabric works where it's applicable we do
have some other sessions we did have the
fabric tutorial yesterday tonight
there's going to be a high availability
and backup off and that will cover a
replication and that's at 5 o'clock I
think it's in at 6 o'clock this evening
check the schedule I think that's in
Moscone South tomorrow there's a fabric
presentation about high availability and
on Thursday there's a fabric
presentation about elastic scalability
with OpenStack all right any course the
bluffs at 6 o'clock so what that is
correct so you can take pictures on your
cell phones if you want to go to any of
those yes sir is there any implications
using connection pooling so the biggest
thing that I can think of would be what
would we're asked about earlier which
was are the physical connections left
open and they are so there's no built in
facility right now to manage those
physical connections so if you created a
connection to the farm and left it open
for a long time you're probably going to
ultimately wind up with connections to
almost all your database servers whether
that's an issue or not is another story
it is yes it's got to go to the fabric
node but it doesn't have to make
connections to the physical servers so
that that does happen later on down the
line when you start your transaction and
it has to choose one of those physical
connections it'll make a connection if
it has to so you could move move some
kind of latency or some kind of a work
that you initially were doing when
creating the connections down the line
because of that any other questions
about fabric or connector J okay one
more comment I had I didn't write on
here there is a connector J bought if
you're using connectors J there's a
connector J Boff tonight at 8 o'clock
it's in this same room so if you have
ideas questions about this stuff or
other connector J features or just MySQL
stuff and how it interacts with
connector J come to that I think we'll
have a pretty good discussion we have
some pretty in-depth information if you
are a connector J user thanks everybody
for coming
sorry it's at 8 o'clock
yes in this very room thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>