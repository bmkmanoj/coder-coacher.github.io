<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Applying Groovy Closures for Fun and Productivity | Coder Coacher - Coaching Coders</title><meta content="Applying Groovy Closures for Fun and Productivity - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Applying Groovy Closures for Fun and Productivity</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/URkFOLywex4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's get started welcome to the session
on applying groovy closures for fun and
productivity my name is Venkat
Subramanyam we're going to focus pretty
much on closures in groovy and look at
some really fun features available and
things we can do with it best time to
ask questions or make comments is when
you have it so please don't wait till
the end any time is a great term for
questions comments anything you want to
share absolutely
don't hesitate at all so we're going to
talk about a little bit about closures
first and talked about what they are and
then we will look at a number of
features this is some of which are
something we could do in other languages
but quite a few of what I'm going to
show you is I would say rather unique to
what GUI offers in terms of closures so
what is a closure that's the very first
question well before we talk about what
a closure is will first talk about
lambda expressions so for example you
can add a list for example let's say a
list of numbers start with these numbers
here and you want to iterate and print
these values you could simply say list
dart each for instance and given an
element you could say print the element
so this becomes a little iterative loop
and you are using an internal iterator
to get the work done
as you can see here I don't use any
slides but if you're interested in load
the code examples you can download them
from my website the link is also
available in the very end so you don't
have to rush down to write this down it
will be around floating around so you
can note it down later if you're
interested so we can see in this
particular case we used what is called
an anonymous function an anonymous
function is a function with really no
name it takes parameters and has a body
and the return type is often inferred in
this particular example the function is
taking a parameter which is named E and
we are simply printing the value in the
case of groovy though we can reduce this
even further by simply using a favorite
term called it and it is really the it
that one parameter if you're going to
take one parameter you can either
specify the parameter name or simply use
the word it but of course if your
function is taking more than
one parameter don't try something
created like eight one eight two that
doesn't work you can only have a no
parameter name in that case well having
said this though if you were to write
something along the lines of print e you
can see that in this case we got every
value in the collection and we printed
it but on the other hand if I said times
two we're going to print the double of
the values given to us but let's go
ahead and take a look at this for a
second what are we dealing with if I
highlight this lambda expression if I
ask you what is e it's very clear what e
is e is the parameter given to this
lambda expression in other words this
lambda expression is pretty well
contained it's got the parameter e given
to it it knows what two is and two of
course is the is a literal so it's got
everything it needs on the other hand if
I were to say let's say factor equals
two and now I'm going to change the two
to factor in this code now if I
highlight this code notice in this case
we know what e is e is a parameter given
to us but what in the word is factor
well factor is undefined within the
context of this lambda expression and
this lambda expression is unusable
unless we have a way to tie down what
that factor really is so this lambda
expression is going to go on a hunt and
look for this factor for it to be
complete and so it goes into its own
defining context such a search is called
lexical scoping so it goes into its
lexical scope meaning its own def
defining scope and says hey do you have
this factor and sure enough there's a
factor in its own defining scope and it
binds to that particular factor if you
want to imagine imagine a little creepy
hands that come out of this lambda and
grabs that factor on line number three
and that concept the creepy concept is
called closed over now obviously
somebody taking notes wrote the word
close over as closure
and the term closure stock so a closure
is nothing but a close over a lambda
expression with an unbounded variable
that has to close over a defining
context is called a closure so in at
least conceptually you can say that this
is a lambda expression however this is a
closure but in groovy we don't care
in groovy we call everything as closure
lambdas and the closures now sometimes
this happens you're sitting next to
somebody who is very pedantic and you
say closure and they get very angry at
you and they try to debate you into
saying that's not a closure
that's a lambda what you do is you
quietly get up and walk away right you
will never get into argument with people
or pedantic use like whatever and just
walk away because does it really matter
right so the point really is we call it
closure and groovy we are very relaxed
in naming it we don't get hung up on the
terms like that
so lambdas and closures are just about
the same for us in groovy even though
there are technical difficult
differences with it okay how do you
create a closure well creating a closure
is extremely simple as you can see
simply put a curly bracket and put a
little body of code in it optionally you
can define a parameter list if you want
to you can also store this in two
variables if you are interested in for
example let's say I want to repeat this
on two different lists let's say so
there's lists one here and I also let's
say have a list of two on my hand where
my listed two contains let's say a bunch
of other values 20 30 40 and 50 and so I
could pretty much say here on list 1 I
want to do it and also on lista 2 I want
to be able to do this as well well the
problem here is we duplicated code well
you know lambda expressions are cute but
that doesn't give us a free ticket to
start duplicating code right duplicating
code is still evil in that front as well
so what do we do about it well what we
can do is we can save that away into a
variable so we could call it as
rent it for example and then save it
into a variable and now we can simply
pass that over here as printed for
example and say here take this function
and work with it right so we could pass
that as printed as a parameter that we
can pass into this function so we can
store lambdas or closures rather into a
variable and then you can just pass them
around very easily that becomes very
convenient now but on the other hand how
do we really receive closures so let's
say we have a function that we are going
to use I call that function foo because
in programming sessions you're supposed
to have a function called foo so I took
care of that so in this case I'm going
to receive a parameter let's say so I'm
going to take a value and a closure as a
parameter in this case maybe I just will
call the closure and pass the value
let's say times 2 that's a very simple
closure of a function that I'm writing
so the function foo now is going to take
a value of 3 and I'm going to say in
this case print it so when I called this
should be no surprise it printed a 6 as
you can see and the reason as we sent a
3 and food took the 3 and turned around
and called the closure with a double of
that value and our closure simply
printed it but if you look at the syntax
over here the syntax is a little bit
noisy this is not an idiomatic way we
write code and groovy now before I talk
about the idiomatic way we could have
done something like this we could have
said closure comma value well if I did
it this way notice a closure is the
first parameter and the value is the
last one and so in this case you would
have said closure first and you would
have said the value like this however
and you can also have multiple closures
to a function to your project could take
your function could take to close yours
3 closures whatever that you want to
pass in however if you're writing
closures and you're going to pass only
one closure it is a idiomatic style to
put that closure as the last parameter
rather than anywhere else and the reason
is last parameter is special less
parameter special like
last children in families are special I
know it because I'm not one of them
so the point really is that they kind of
what are the last children do they hang
to that Paris like there are parasites
forever right that's what they do so in
this case notice how I can move this
right outside of this function call and
the space for a fairly light syntax as
you can see this convenience is afforded
only for that last parameter if the
closure was anywhere else in the
parameter chain you cannot enjoy this
fluency so as a result you normally only
put it towards the very end when you
write code like this so as a last
parameter to pass them so as you can see
in this particular case you got foo and
you are passing the value 3 and a groovy
knows that because there is something
else attached to it you're going to pass
that as a closure to this function and
that word closure that you write update
whatever you call it becomes attached to
that particular function you are passing
in this case and so as a result this is
mostly how you would be writing but
because groovy is pretty fluent in its
syntax you could do quite a few other
things as well as you can see here and
in this case who is taking 3 as a
parameter we drop the parentheses but
have to use a comma to it compensate for
that and then we are passing the
parameter the closure after this so we
can work through that fairly nicely so
this is an example of how we can pass
closures and some of the fluencies that
we get access to as well as you can see
in this particular case now that we saw
all of that I want to talk about one
other really cool feature that closures
for white let's define a closure called
greet over here where the greet is
taking let's say a name as a parameter
and I'm going to simply say hello and
print the name of the parameter well in
this case we could for example call this
and say greet and I'm going to send
let's say Joe over here well you can see
that it says hello Joe so that was
pretty simple we call the closure we
pass a parameter to it and the closure
of course the parameter name actually
tied over to this now of course you
could have minimized this by saying
hello and you
set head it but I find rather very
insulting to call a friend as ed so
normally I like to pass a parameter in
some sensitive places like that right so
we passed the name over here we are
printing the name of the variable as you
can see that works properly okay now
there is a nice feature of the closures
that I really appreciate in groovy and
that is when a closure is evaluating if
it comes across something that it
doesn't quite understand but rather than
throwing a fit closure closures
automatically do a routing to water call
delegates so a delegate is an object
that attached to a closure and it turns
out to be a very powerful concept to use
so when a closure hits on a particular
function it doesn't understand it
immediately forwards the call to the
delegate and says hey delegate do you
know what this is about can you handle
it in that regard the delegate enclosure
in groovy is really like the prototype
inheritance facility available in
JavaScript what are the real power in
JavaScript an often-overlooked power in
JavaScript is the prototypal inheritance
you can actually imagine carrying a bag
with you and you make a request to the
object if the object doesn't know what
you're talking about
it would reach into its prototypal bag
and look for those properties and then
there could be a chain of these calls
forward as well in a very similar way in
the case of glue way if a closure
doesn't understand something it will
automatically forward it so in this case
for example I where I'm going to change
this a little bit here I'm going to
simply say right here that instead of
calling hello I'm going to change it to
a function called to uppercase let's say
now obviously when I run this code it
fails and the reason is that we have no
clue what to uppercase this but what's
not very clear at this point is the
failure did not happen right away the
failure happened after a dispatching and
the dispatching actually failed it went
to a delegate and asked for it
so as a result I could say for example
salutations over here and let's say the
salutations I'm going to define as hell
and let's also define this as howdy for
a second then I could say for salutation
in and then I'm going to say the
salutations that we are working with and
I'm going to then call the greet dojo
inside of this that's going to still
fail for a second but in this case I'm
going to say greet delegate equals
salutation and now if you notice it
doesn't fail anymore because we have
attached a delegate to the closure so on
line number two when we invoked the
method since it doesn't have a clue what
to uppercase is it immediately runs over
to the delegate that you attach it so
happens in this case the delegate
actually is a string and the string does
understand what to uppercase is and as a
result it was able to dispatch that so
as a result what we can do is we can
create closures but then we can modify
the delegate outside and so to say
change the behavior of the closure
without modifying the closure now
imagine this in inheritance inheritances
rather very static right you inherit
from a class and you are stuck with it
whereas in the case of a prototype all
inheritance inheritance is actually very
dynamic it's as if you are changing the
delegate and you're changing the code
behavior of the object or the class you
are working with so prototypal
inheritance gives you that kind of
capability and and delegates really are
a pathway to a prototypal inheritance in
groovy as it as it turns out to be we
can exploit this very nicely you to
create some really fancy interfaces so
to understand how we can do this I'm
going to fall back to imagine for a
minute this is Java code right I know
this is hard but imagine this right so
what are you going to do you're going to
say public class has to be right because
there's no other way you got to say
public public class and then you're
going to say in this case let's say
mailer for a minute and what am I going
to say with the mailer I'm going to
write a public void - method well what
does the - method really take it takes a
string which is going to be lets say an
address and in
case I'm gonna output let's go ahead and
say output and I'm gonna output wort I'm
gonna output the word to write let's say
so I'm gonna write that to method
likewise I'm going to write next method
which is the from method and I'm going
to simply print from I've got another
method which is called the subject
method which takes a line and that's
going to print out subject I've got a
body method which is going to take a
message let's say and then I'm going to
simply say body and then finally have a
method over here which is going to be a
sender method let's call it as send and
all I'm going to do here is simply say
sending right so that was a very noisy
Java code but it's time for us to use
this Java code well of course you can
write a public Ward may void main but
I'm going to skip that part and pretend
that it exists but how do we use the
mailer so mailer equals new mailer so we
create an object of mailer and with all
the glory of semicolons in there and
then I say mailer dot - and who is this
mail going to well you should know who
it's going to go to it's none other than
myself and then the mailer is is going
to come from where so somebody's got to
send me this email well the email is
coming from none other than the Builder
on my server and of course you may
wonder what kind of email it's going to
send and it usually prompts with send
disco ml every day it is your code sucks
and then of course mailer dart and it's
going to tell me how it sucks it right
doesn't stop right there it explains to
me how the code is sucking today and
then finally mailer dart send we can
call it to have that send operation
anybody who has seen code like this
before everybody right now what is wrong
with this code well where do we start
well it's noisy isn't it
if you look at this code look at the
noise in the scored male or male or male
or male mailer if you do this somebody
sitting x2 they may strangle you right
because it gets very noisy and and very
old very quickly
okay that was noisy and the other
problem is what do we do with the object
when we are done on line number 26
should be reused the object or should we
not reuse it well guess what there are
only two answers to the question right
if you should use a new don't you have a
waste of resource if you shouldn't and
you do you got a bug on your hand so how
do you normally answer that question
well you're trying to figure this out
and somebody has this bright suggestion
they tell you why don't you look at the
Javadoc well how did that go for you
last time right
so the other day I had to look up a
function called pass through honestly I
did not understand what pass through
means so I looked at the Javadoc and the
Javadoc promptly told me this method
allows you to pass through right so the
point is dar my Doc's are called insult
the programmer because they don't tell
you anything except repeat the same
thing as a method name right then you
get a bit more creative you tell
yourself I got a great idea
I'm going to start looking at this code
after all it's open source that is the
pathway to start cursing the programmers
now right because now you start looking
at the code and you start cursing them
who wrote this code anyways I don't
understand and that kind of leads to
nowhere right well what is my design
this is easier to understand and use so
notice what I'm going to do first well
the very first thing I'm gonna do here
is I'm gonna go back and make this
method send as a static method
well because send is a static method I'm
not going to call it on an object
anymore I'm gonna call it directly on
the class itself so I'm going to say
mailer dart send I notice that I'm gonna
call the mailer directly from here on
well at this point of course we are
switching over to a groovy syntax and
you may look at this and say wait a
second can't you do this in Java also
well we can do about 50% of what we're
going to do here in Java the other 50%
is somewhat unique to groovy so I'm
going to get rid of these noise in the
code so let's get a few things over here
so system dot out dot and let's get rid
of that noise right here and then let's
also get rid of our double quotes if I
had double quotes anywhere into single
quotes I probably had a few places where
I had that so double quote to a single
code I'm that picky I don't want any
noise whatsoever and then we could also
say remove the semicolon along the way
as well and we could just get rid of
that ceremony so we remove a
you things around in this code we could
also most likely get rid of the public
void and change it to a deaf for now so
that's good enough so we got quite a bit
of code removed already well now that we
have all those things gone let's see
what we're going to do with this code so
we have the two method as you can see
right here we got the from method
sitting nicely that's great and then we
have the sub method also these methods
are all what are they doing well there
are pretty much a void method they're
not returning anything in Java if you
were to apply this pattern you would be
modifying these methods to start
returning that this object but but very
clearly in groovy we don't have to go
that far at all so what I'm going to do
here is I'm going to go back to the
sender method and in the send method I'm
going to accept a closure as a parameter
and now in the method what I'm going to
do is I'm going to create a mailer
object so you mailer like we did before
and I'm going to then go ahead and send
closure and send in the mailer to it now
once the closure is done with the mailer
I can complete the processing and I can
do the sending operation so now to make
use of this I'm going to say mailer over
here and then now that we have a mailer
on our hand I can simply use that mailer
continuously and then we could do
something along these lines so when I
run this code this time
well the mailer is of course a parameter
being sent to the send method as you can
see here and so that part worked well we
gained some but we lost some the gain we
have here is that if you ask me what
would you do with the object after line
number 19 the answer is what object are
you talking about right because the
object lifetime is within this block of
code and as soon as we exit the block of
code that object is no longer available
in scope so by design it's very clear
that this object is very contextual
we're not going to use it right
afterwards so that's pretty darn clear
but we still did not eliminate the noise
in the code after all as you can see so
in order to eliminate the noise in the
code
it would be very nice if we can remove
the mailer from here and we can write
something along these lines just say -
from subject and body well unfortunately
that doesn't work well what can we do to
make that work right so in this case
what we're going to do is we going to go
back to the code we are no longer
sending the mailer as a parameter
because this guy is not receiving an
explicit mailer as a parameter anymore
but we know one thing for sure if you
call a method like the from or to our
subject and we also saw this a few
minutes ago if that method is not known
to the closure you know exactly what the
closure is going to do about these
methods right what does it do it invaded
runs over to a delegate hey that's a
great idea we can use that in that case
so I'm going to go back here and say
closure delegate equals and then I'm
going to say mailer and then I'm going
to call the closure after that so notice
now we have something extremely
lightweight unit goes near towards a
very fluent code you have seen code like
this if you have looked at things like
Gradle or if you looked at going for
example the constraints that you specify
in Gorham is exactly this format so this
kind of click is used quite heavily in a
lot of different places so bailer dot
send basically says hey I don't know
what a - and a from is I'm going to
dispatch this over to the a call - the
delegate and as a result you can see
that it quietly went over to the
delegate well that seems reasonable so
far except we did something really
really bad if you look at this code
while this is really charming if you
look at the send method we received a
closure and what did we do on line
number nine we stiffed a closure right
went to the closure and said hey closure
here you go and you stuck something to
his delegate now we know one thing right
changing an input parameter is
punishable under law I don't know if you
read the state of California law
recently right so they
they have you know real punishment for
people who take variables and then
mutate it right so that is very very a
poor practice we shouldn't do it well
what do you do if you want to change our
object but you feel really morally wrong
to change the object you can make a copy
of the object and change it so what I'm
going to do is I'm going to define a
closure clone equals closure dot clone
and now that we cloned the closure we
can say over here closure clone dart
delegate yeast mailer and then call the
closure clone after that so that feels a
lot better but unfortunately that causes
one other problem you look at this code
and say wait a second
that is three lines of code and then
they told me in groovy everything is one
line of code right so so you kind of
feel you're a little cheated because the
language should really take you further
well thankfully you can actually do that
so all you do is a mailer dot width and
you pass the closure to it and that
takes care of that very nicely for you
so the width method does exactly what we
just saw it takes a closure sticks a mix
a copy sticks there delegate into the
copy and invokes the copy and the
delegate it sticks is the target object
on which you call the method so that
works automatically for you and produce
that result for you so that is
essentially the purpose of the width
method so that is an example of how you
can write a very fluent interface and
what we did in this example is we made
use of closure to build a nice fluency
into our interface great now the next
thing I'm going to talk about is called
carrying no I'm not talking about that
spicy Indian food that I love so much
we're going to talk about something even
better than that well then why did they
call it carrying are they crazy or where
the people really fan of that spicy food
well this actually came about based on a
guy who worked in lambda calculus he
worked actually in calculus in category
theory and he
was really popular in doing some really
good work and of course he passed on and
years later people came along and they
started doing more research in this area
and they wanted to really named after
him and if you really think of having a
celebrated life we would not want to
have a life where your first name
becomes a language and your last name
becomes a concept in your field right
isn't that awesome
well that guy's name is called Haskell
curry that's where it came from so
Haskell curry of course you know the
language called Haskell and of course
curry is carrying and hostel carry was a
mathematician of the Esther years and he
did a lot of research in the area of
lambda theory and of course after he
passed on they decided to give this term
on his name but what is carrying though
well in back in lambda calculus there
are a couple of things they were
interested in mathematicians were
interested in proving correctness of
algorithms now I know that nobody in
this room cares about things being
correct right I mean if we did we won't
be programmers right so we kind of live
on the edge we write code and it fails
and we live on I mean the other day
somebody said what is everything works
what do i do how do I spend my time
debugging right that kind of problems we
are normally faced so who cares about
being correct so what they care about
correctness and they said one way to
make sure things are proved for
correctness is to make things
predictable as if you send one input to
a function then it is more predictable
rather than when you send more than one
input so the essential idea in
functional lambda calculus is functions
only take one parameter well like I said
that's great but most of us don't care
about it at our level of programming but
there's another thing we care about
which is removing duplication and code
so if there's a way to remove
duplication in code we certainly can
favor and so we can use currying for
that purpose to understand this I'm
going to define a closure called a log
closure and
closure takes three different parameters
it takes a level as a first parameter it
takes a date as a second parameter and a
message as a third parameter now what
I'm going to do here is I'm going to
simply print out let's say print the
level here the date over here and then
I'm going to print the message as well
so I could do something like this I
could say for example today equals new
date and then I could call the log and I
could pass these three things I could
say warning and once I call warning over
here I could say today is the date I
want to send this warning and I could
say starting is my message likewise I
could put one more which could be a
running for example so when I call this
one you can see that it's printing that
information but the point though is
these two were fairly noisy and a bit of
a duplication so what you could do
instead of doing that is remember again
that this is actually a closure so what
you do is you can say rather than
calling those two functions like this
I'm going to first of all define a
little closure call log warning today
right and then I'm going to say equals
log dot Curry and then I'm going to say
warning comma today so in this
particular case we applied a function
called curry now Cuddy is really cool
because it takes a closure and returns a
spicier closure back to you right so
that is the nice part about currying is
that it has cashed in those two
parameters so your original closure was
taking three parameters and you cashed
in two so now you have your quotient
only taking one parameter but the other
two has been you know cashed in so as a
result you can have that in there so now
I can say log warning today and simply
say starting right here and I can say
log warning today and I can say running
and I can print that so you can see that
that was very effective because we
carried those two parameters in here so
cutting is some
thing I really like a lot how were in
GUI to point in the groovy 1.8 if I'm
not mistaken they went in my opinion a
little overboard with us and so what you
can do is cutting was this nice little
feature and it is very useful and I
still like to use currying but somebody
got a little clever and they said well
what if we want to curry other things as
you can see here we curried the first
two parameters you could Cudi the first
parameter you could curry the first two
parameters you could potentially curry
all the parameters if you want to in
that case you're pretty much tied all
the values only exercising it without
giving any parameters nothing wrong with
that but the question is what if I want
to curry not from the left to right but
from the right to left
well seems like a initial idea in the
beginning right okay that's great
so I want to curry what I want to say
define log and what do I want today
let's say lock today starting it makes
it maybe warning it may be an error I
don't know right so equal to log dart
and the name for this is called our
curvy now so far so good but the
question now is I'm cutting from the
right side so does it mean I provide the
message first and the date after all the
way provide the date first and the
message after who here things you would
provide the message first and the date
after so look at the number of people
who raised the hand who thinks you will
give the date first and the message
after right I mean we could put this to
a vote right I mean we live in a
democracy right but therein lies the
problem right no there's no right answer
to this question and it doesn't matter
what the right answer is about half the
people go zoom are wrong right and
that's why I hate this feature right and
it turns out it is exactly this is what
this is why even more hit the feature
because it's right opposite to what I
want it to be right I mean why do I care
about anybody else right so the point is
if I were to call this in this case for
example
or curry and I'm gonna say starting
because that's the first but you know
hands when more hands went up for that
and I'm gonna sit today and I'm gonna
then go ahead and call log today
starting and warning and when you run
this notice it said warning starting and
then date you can see that that didn't
quite go well right and so the answer is
they actually did our curry but they
still look left to right right so to me
that is a way to cause confusion right
so my recommendation is use curry and
that is a good thing but use our curry
if you really hate the people you work
with right then that way it will sit
there and keep scratching the head and
not figure out what's going on now you
say alright that was a little bad could
this be any worse so one thing I do
hundreds is laughing right so the one
thing I do is this is this is my own
fault I I love spicy food and I go to
Thai restaurants quite often and I go
there and then they come over and I tell
myself prepare this mentally don't do
this banquette right and then they come
over and say your spice level and I'm
like tell me and well one to ten one is
you won't even taste it
ten will serve the food and out of the
ambulance for you
and I'm like Levin and I am repenting
that night right and that is me it's
like bring it on and so that is called
an curry and curry is so spicy you won't
feel your tongue anymore
right so what does an curry do and curry
says I'm going to pick some values in
this list and I'm going to carry those
right recommendation don't go there it's
not worth it right so cutting is a nice
concept in the case of an curry you can
actually specify which parameter
starting which parameter you want to
start carrying and the reason I don't
like it so much is it starts moving
towards you know kind of losing
readability at that point and any time a
code is fluent but
makes you think my argument is that's
not intuitive enough to work with right
so Cuddy is awesome use it I'm reluctant
about our curry I would definitely stay
out of an curry as well because that's
really hard for me to cope with so we
saw what currying does I want to show
you one other really cool feature that
is very powerful to use so in this case
I'm going to say a print info and I'm
going to take a closer as a parameter
and I'm going to go ahead and call this
method print info and I'm going to pass
to where II and print eat right so I'm
passing a closure to it as you can see
now within this function I'm going to go
ahead and print some details so we can
see it so the very first thing I'm going
to print here is I'm going to say print
closure dark maximum number of
parameters right so you are asking how
many parameters exists this is a very
awesome feature because the property
name is longer than my name makes me
feel really proud right so the point
here is that you asked him what's the
maximum number of parameters this
closure can take and it's pretty obvious
right the closure is taking one
parameter because we said e but on the
other hand if I said over here a comma B
you can see that that number is actually
2 but on the other hand if I take that
out and if I said print it what do you
think it's going to be one that's
absolutely correct but rather than
printing it if I say print foo what do
you think it is now tricky it is still
one it's just that you ignored the it
right so if you really want zero you got
to put that silly arrow mark right and
the arrow says no I really don't get any
parameters right so if a closure doesn't
have an arrow it takes one parameter all
the time if it does have an arrow it
takes as many parameters as you
specified before the arrow in this case
we didn't specify anything as it is zero
likewise we
also do other things in a so you can
inquire here something called a
parameter parameter types and you can
ask him what's the type of the parameter
you are really receiving in this case of
course I got an int I could also say a
double for example you can see it's a
double I could also pass another
parameter in this case I received two
one is a double one is an end so this
gives a nice way for us to dynamically
work with closures right and if you are
looking for an example of where this is
being used this is one of my favorites
you could for example say an example
like for example let's say you have a
languages names on your hand so I could
say Lang start each and I'm going to
provide a closure to it
I call it entry and I simply print the
entry right here and look at the fact
that it took entry as a parameter
but the real cool thing about this is
you say dot each but without really
creating a fuss you send a key value
pair and then you can say here is the
key and here is the value and notice
that this each method is so smart it is
able to use either one of those versions
and so take a while guess what the each
method is doing the each method receives
the closure smells it and finds out the
number of parameters it takes if it
takes one it sends a key entry to it if
it takes two it breaks the entry into
key and value and sensit right so you
can create your own API where you can be
that flexible to your users and they're
going to be really enjoying your api's
because you give that kind of
flexibility and so how do you do that by
receiving the closure and examining the
maximum number of parameters and then
based on that you make the decision to
do whatever you want to do and that can
become very very powerful for you to
work with so all right now I want to
take the next level where you can do
with closures let's say we have a thread
equals new thread and I'm going to say
thread dot start to start this
particular thread now of course for this
you couldn't
you runnable and then once you create a
runnable you could say public void run
and then within this you could say in
another thread and then of course you
could print out in Maine right so you
could run like this so when you run this
code you can see that that thread was
running in another thread and then of
course the Maine is running in the main
thread well but that was a lot of
ceremony in the code there are a couple
of different things we can do here the
very first thing is you are creating an
interface I'm sorry you're implementing
an interface
well closures can readily stand in
wherever an interface is expected so
what you can do is rather than sending
all of that you can remove that fluff
entirely and you can just pass the
lambda directly the closure directly in
this case now of course you may say what
if my closure is taking multiple
interface has multiple methods you can
send a hashmap where the key can be the
method name and the value can be a
closure but you don't even have to go
that far work that hard in the case of
groovy you simply call the start method
directly now you know that in Java the
start method is a instance method
well groovy has added a static method
called start to the thread class to make
it convenient so what you do is you
simply go to the start and you can
simply provide the code you are
interested directly to the start method
of the thread class so start can take
closure as a parameter and then run it
in a separate thread so you can start
you know doing some of these
conveniences if you are interested to
take a look at the jeepers library and
jeepers have some really nice
convenience to start off code in
different threads
they got ability to do what is called a
sync and you just simply say a sync and
give a code block and you can run
asynchronously and another thread you
can also set up timeout properly for it
and then it runs in a pool of thread and
stuff like that so it's well worth
looking at jeepers to see what kind
exploit they make on closures pretty
nicely to make these things much more
interesting to use well with all that
said I want to talk about another really
cool feature let's say we have a method
we're going to implement which is
factorial now I want to say factorial
and I got a number as a parameter coming
in and one way to find the factorial is
to say result equals so we could say
result equal to one and then we could do
a little iteration we could say value I
starts from one two let's say one two
numbers right so we could say number and
then we could say in this case result x
equals and then we could multiply the
index so we could call this and say
factorial not factorial factorial and
then we call the factorial let's say
with the value of five for example well
in this case of course we are running
this factorial for the value five and it
says it's 120 now of course we could
push this a little bit we could say I
want on it for a thousand for example
right and if I run it for a thousand
obviously you want this to be a value
for a big decimal or big integer so you
could say big integer is the value that
you're working with that way it doesn't
lose the information and you can work
through these these values and do proper
multiplication right I won't worry about
the value being 0 for now but the point
really is if you push this even further
what's going to happen the point is it
doesn't seem to be bothered by it you
can change it to produce the right
result but it seems to work just fine
but the problem is this you are using a
facility here of a pure iteration that's
what you are doing here but we all know
that while iteration gets the job done
the really cool people use recursion
right you know this right remember when
you went to graduate school
whom did you hang out with the folks who
did recursion right you got together
every night and you did a little bit of
recursion right that's where the real
fun is so the recursion is awesome so
you say
dude we got to really write this as a
recursion because recursion is more fun
because we can solve a problem using
solutions to subproblems well that makes
sense so what do you do for recursion
you could say something along the lines
of if number is equal to one I'm going
to simply return the one otherwise I'm
going to return number times factorial
of number minus one right so that makes
sense you can run this immediately it
works so you you're writing recursion
having a good time but there's always
this one dude and you know around you
who doesn't like you and what does this
dude say yeah you think a question is
cool huh why don't you try this what's
going to happen
yeah Stack Overflow exception most
likely right
depending on the size you're going to
end up with a Stack Overflow the party
is over everybody has left right and you
sit there really really upset so how
cool would it be if we can really use
recursion right so the question is cool
except when you want it to really
recurse right and the minute you give it
a large value it blows up with the Stack
Overflow exception how sad it is well
let's switch gears we'll come back to
this problem in a minute but let's
switch gears to write a method called
foo and I take a number as a parameter
in this particular case what I'm going
to do is I'm going to call the method
foo and if n is equal to 1 I'm gonna say
throw new runtime exception and I'm
going to say blow-up right so this is
going to be a very upsetting method else
I'm going to simply call n times 2 n
minus 1 so let's call foo with the 5
real quick and notice what just happened
here it blew up but if you look at the
output you can see that we are about
five levels deep shouldn't be a surprise
right so if you notice we call foo on
line 5 foo on line 5 few on line 5 on
line five and then foo on line 3 your
fire levels deep in it right so it
should no surprise at all to anybody in
this room right because you're calling
recursively and so you kept calling this
calling this calling this
you hit that and you were five levels
deep in the stack hey that's exactly why
we got a stack overflow exception as
well when the size of the input was very
very large well it turns out there are
some other ways to do this there is a
fantastic book out there if you haven't
had a chance to read it I cannot
recommend it enough just Google for
these four letters s ICP it stands for
structure and interpretation of computer
programs and the structure and
interpretation computer programs is a
book written by Sussman and Sussman and
it's a phenomenal book about a lot of
very interesting you know programming
ideas and how we write algorithms in
that book they distinguish two separate
things they talk about what is called a
procedure versus a process a procedure
is the code you write the process is the
one that actually runs so a procedure is
an iteration you wrote guess what how it
ran it ran as an iteration no surprise
procedure is iterative processes
iterative you wrote it as a recursion
that's a recursive procedure how did it
run as a recursive process but the real
gain comes in when you can write the
code as a recursive procedure but it
quietly runs as the iterative process
what's the benefit you get
expressiveness in the code you can write
a recursion but when you run it you
never have the problem of recursion
because it quietly turns around and runs
as an iteration this is like having a
little pill where you can eat everything
you want to eat but never at your
waistline right if you find that to let
me know I definitely want more travel I
do I can make use of that but at least
we have a solution here so what is that
called
it's called tail call optimization so
tail call optimization is where a
language compiler potentially is smart
enough to realize
aha this computation is the tail
position and so I can optimize this to
turn into a iteration look at line
number eight in line number eight what
is the last operation we perform
a little tricky but it's the multiply
right the last operation is multiply
what does that mean when you get the
line number 8 you're going to say here
is an I want to call multiply but I
cannot I'm gonna hold my stack and call
foo again you're going to hold the stack
because of that and in the upper level
what do you do you again hold a number
hold the stack and go up until you hit
the roof and blow up but what is the
last operation is the call to foo itself
then you don't have to hold the stack
because the last operation is foo you're
like you know what I'm done with
everything I don't have anything else to
do other than call that method I'm going
to step down from the stack and then
call that method now I don't have to
hold the stack to make this call right
so a compiler can do a nice optimization
well here's the good news
there are compilers that do this quite
very well one of the great languages
that does that is called Haskell has
told us incredible optimization tail
call optimization at the compiler level
another language that does it
wonderfully is Erlang a third language
that does wonderfully is closure and a
fourth language that does remarkably
well is Scala now in all of these cases
you say okay the language does all of
this which means we got to have a
compiler that supports it well that
means they would have to go mess with
the groovy compiler and messing with a
compiler is the last thing you want to
do because that becomes very expensive
and has other repercussions but they did
something really smart when it comes to
groovy they decided why don't we play a
trick on closures after all when you
call a closure you can decide whether to
return back from the closure and a loop
and recall the closure with a different
parameter then you can kind of simulate
a tail call optimization very nicely so
notice in this example we just saw right
now when I run this code right here you
would notice that it's five levels deep
now I'm going to change this alert
I'm gonna say that this foo is going to
be a closure so I'm going to say define
this as taking a parameter end right
here and what am I going to do with this
if n is 1 I blow up if n is not 1 I am
going to simply call foo one more time
and this time I'm going to say call a
method called trampoline so trampoline
is a special method this is a cousin of
the curry method we saw earlier right
and well curry spicy trampoline is cute
so what trampoline does is it says I am
going to return to you a closure right
away and that closure is called a
trampoline closure so in effect what you
do here is you call a trampoline on this
and so when you call the method foo
what's going to happen is notice it blew
up but do you see the number of levels
of stack you are in you are in one level
of stack not in five levels anymore
because it quietly converted this to an
iteration rather than a recursive call
right so as a result we can rewrite our
factorial like so we can say factorial
and then in the factorial we could say
this is going to take a parameter of
whatever the end parameter we're going
to pass to it and then we could say
pretty much in this case if n is equal
to one then go ahead and call for the
fact to be returned so you're going to
pass two parameters your fact and n and
if it is not we got to say else call the
factorial dot trampoline and in this
case we're going to say a factorial
times the value n + n - 1 and then dart
trampoline outside attack then we can
simply call factorial but this time
around we would pass in a 1 comma
whatever value we are interested in
passing now at little disadvantages we
are passing two parameters here instead
of 1 but let that not be a worry because
you can nicely wrap
entire thing into another function and
then you can simply pass one parameter
and that function can then pass the two
parameters so you can get the best of
both worlds very easily right so
trampoline is really a tail call
optimization purely written using using
closures so as a quick side note I've
been working with multiple different
languages over the years so I know what
close your Haskell Erlang and all the
other languages I mentioned I know what
they do they do it at the compiler level
I've also programmed with groovy I kind
of know what groovy is doing at the
language level so when I got into Java 8
I got excited about Java 8 and when I
started writing the book on Java 8 I
said to myself
would it be so cool if Java 8 has pill
call optimization well to my sadness
Java doesn't have tail call optimization
but you know programmers never take no
for an answer right so I said I'm going
to have tail call optimization in Java
so actually implemented take off in
position in Java pretty much using very
similar approaches to what groovy is
doing by really exploiting closures and
it took me about only about you know
wasting of about three days of my life
but after that I've got something that
is absolutely note enough know used to
anybody but makes me happy that I
actually was able to implement that in
Java right so the point is that you can
actually exploit this and this goes back
to the point that somebody was
mentioning before the session hey you
know I may not use this directly but I'm
reprogramming another language I could
end up using it which is exactly what I
ended up doing is I was able to actually
produce a tail call optimization in Java
based on my experience with these
languages and how they are able to
provide it that can be very valuable
well the last thing I want to talk about
is memorization this is one thing I love
about about our field we will work very
hard to find terms nobody understands so
what in the world is memorization well
they could have told you caching but
that would make sense to you so we
cannot so memorization is simply caching
of data now where do they use this they
use this in a wonderful field called
dynamic programming which is anything I
love because any programming is neither
dynamic not
programming and so dynamic programming
is an algorithmic technique where you
introduce enormous amount of redundancy
and as a result by caching you turn what
will be an exponential operation into a
linear operation let's take a look at an
example of memorization and this is
already big into groomy so let's take a
look at it so to do this I'm going to
create a Fibonacci number and the
Fibonacci number it's going to take a
number and and in order to produce the
result of this I'm going to say if n is
equal to 1 or if n is equal to let's say
n is equal to 2 we know that the
Fibonacci number for this is one else
it's going to be Fibonacci of n minus 1
plus fib of n minus 2 right so remember
the fifth series it starts with a value
of 1 1 and then you add the last two
values so that's 2 and then 3 5 8 13 26
and so on right
that's your series so if we were to call
this let's go ahead and try it I'm going
to call fib over here with just a value
of 1 and I try a 2 let's say and what's
going to happen when I try it with the 2
well with the 3 that seems to be working
let's try it with the 5 and that tells
us it's 5 try with the 6 that becomes an
8 you kind of get the feeling that it's
working right but let's talk about how
much time this is going to take so I'm
going to say time it over here so I got
a little code called time it and what
does time it do it takes a block of code
measures the current time executes the
block of code and tells us how much time
that code took to run right so time at
code so time it dart code and I'm going
to call fib and pass let's say to do it
that shouldn't take a long long time at
all right very quick and I'm going to
print the value so we can actually see
the value being printed and I'm going to
try this with let's say a 10 and you can
see that took that much time let's try
with a 20 now guess what's going to
happen
when you say fib of a number what does
it do it finds the fib of member minus
one and number minus two right keep that
in mind
what is about number - 1 need it needs
the fib of number - 2 again so you going
to compute the fib of n minus 2 twice so
notice how many times you're going to
repeatedly do the word because computing
n minus 2 is not just computing n minus
2 it's computing the entire value below
it so there's a huge amount of
redundancy in here so now if I say 30
right here
and a that's really fast isn't that 35
that's okay let's try 37 that seems to
be okay 38 40
let's write this one Li one last example
remember reading Hitchhiker's Guide to
the galaxy one of my favorite movie
books there waiting for the meaning of
light the universe and everything and
and it's a phenomenal thing because I'm
reading the book with my children and
they've been waiting for what 7 million
years for the answer and I'm like hey
that's an np-hard problem right because
that's taking so long
right exponential time to compute right
so I out there running 400 right maybe
my several generations from now will
have an answer for it and you can
probably hear my laptop run really
spinning right so you can get the point
that's very very slow what do we do
about it
so here's an idea I'll take another one
minute before wrapping this up so I'm
going to change it so what I'm going to
do is fib equals I'm going to say n as a
parameter so notice in this case we are
writing this as a separate function or
our closure will be equals but now I'm
going to say give an N if n is equal to
1 or n is equal to 2 return the value 1
otherwise else what am I going to do fib
of n minus 1 plus a fib of n minus 2
however I'm gonna call memorized right
at the very end
very smart operation it quietly hijacks
the closure and puts a proxy in front of
it the proxy says when you call me I
don't have an answer I'll do the work
but before I return the answer to you
I'll cash it and return it well the more
session only works with the functions of
pure meaning every time you call it
gives the same result right and so it
very mildly takes care of that for you
so now if I go back and run this code
notice how instantaneous that was for 40
in fact brave go ahead and try 400 right
and you can see that it is able to give
the results in a heart speed because
it's like hey I cashed all of that for
you so and of course there's a problem
here the problem is when you memorize
you're using more memory but here's an
area where they did really
well memo ace takes other parameters you
can give up around recalled the least
recently used parameter meaning if they
are running out of memory are getting
close to it they will toss out things
they are not using frequently and you
can give a lower buffer you can give a
higher buffer they have gone really far
into providing phenomenal support for
memorization but you can see that to use
it takes almost no effort right this is
like everything is disorders made and
it's served to you all that you have to
do is enjoy it right so that's really
nice as you can see so we looked at a
number of facilities available in terms
of closures and closures really are on
steroids in groovy
not just land expressions but all these
methods and facilities added to it and
and every time I work with it I keep
discovering other things you can do with
closures if you're using groovy there's
so much you can do with it if you're not
using groovy why are you not and you can
also use some of these features and
other languages as well and I hope that
was very useful for you to put this to
use and I thank you for your time
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>