<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ask the JDK Architects | Coder Coacher - Coaching Coders</title><meta content="Ask the JDK Architects - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ask the JDK Architects</b></h2><h5 class="post__date">2016-09-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ztoT5wXxJ5s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon welcome to ask the JDK
are
we are here to answer questions
hopefully you are here to ask questions
if not we can all leave this is one of
the shortest slide decks I've ever
created don't believe a word we say ask
questions if you're shy or if you're out
there on the internet watching the
stream you can tweet questions at me and
I will select and read a limited number
of them so who wants to go first I know
by the way if you're in the room that's
why we need the other microphone sorry
if you're in the room please come up
here to ask your question because if we
repeat it we will distort it and that
way everybody can hear what you're
saying I like distorting the questions
what you can destroy it okay
nope come up here please
so I would I was just attending meeting
a session before this one about jigsaw
and I was wondering if I'm doing
development at a client I'm building
some libraries and I've got you've got
your XML files public-private that kind
of thing now he's got jigsaw coming in
and you can actually shield off or
actually just exposed parts that you
want other libraries to use so if I'm
just doing my own library or creating a
module why would I still want to do
private stuff and not just make
everything public and then shield it off
by the module info I'm sorry I didn't
follow that so if I've got a library so
I'm creating a module right right I've
got old code under my own control yes
why would I still want to make stuff
private since I can shield off parcel
and I don't want anybody else to use
you're the only developer whoever works
on this code do you trust yourself two
years from now probably no I mean I I
don't trust myself from two years ago or
two years from now I mean certainly if
you if you control all the code then
yeah maybe you don't need to do anything
okay but it you know as soon as one more
developer comes into play whether it's
somebody in Europe your own organization
or somebody maintaining some open source
thing that you depend on what life gets
riskier okay I have a counter question
for the room how many people in this
room as Java coders have used the
private key word to protect code from
yourself ya see exactly yeah
accessibility modifier send a signal
right you know they send a signal about
whether this is you know serving the
code immediately adjacent to it the code
in a slightly larger circle or or the
whole world and it's it's hard to keep
those in your head and that's why we put
them in the code um I neglected to have
us introduce ourselves but it might be
obvious anyway I'm mark Reinhold up with
the slug gun and marks the chief
engineer I'm the jvm architect John rose
Brian gets language architect and we all
work for Oracle and for the most part we
enjoy it believe it or not oh so poll
question how many people have downloaded
and and played with an early access jdk
nine built did your existing code work
did it did it break did it break
violently did you figure out why ask him
yeah well they're there they're catching
up Remmy already has a built but that's
caught up with that how many people have
downloaded and played with a jigsaw
early access did your existing code
break have you done downloaded the the
jigsaw EA within within the last two
weeks because it might be that more of
your code broke sorry it's shifting
ground bleeding edge any more questions
we should ask we are no wait we're
supposed to answer them yeah we're just
here to answer questions we can ask
questions too I mean if nobody's going
to ask please come up here
so that means some discussions before
about ahead of time compilation is a
part of Jillian coitus is whatever it's
used to be like committing old ways so
what's this state they're in ahead of
time compilation right now we have a
project on going for the last couple
years on ahead of time compilation we're
using Grall the Gras core which is an
open source product as a project as a
base we are able to compile ahead of
time the Java base module and you might
ask what's the benefit and we've learned
over the over these months a very
important rule of thumb which other
people who have experimented with aot
have also found I think and that is that
a ot gives you nearly all of its benefit
in the first 100 milliseconds of program
execution so there it turns out to be
extremely difficult to find to find a
way to beat the online jit after that
point I think there's probably things
more that we can do there but the
straightforward aot will basically shave
off approximately up to a third maybe
ten percent to a third of your first
hundred milliseconds of execution and
that sounds pretty pale and puny and
maybe that's why you know maybe that's
why Java got along without that for so
long but we we think it has some
particular uses for future
implementations of Java where we're
actually taking an old technique out of
the labs of a self bootstrapping system
implementing Java on top of Java and
they're aot is a requirement rather than
a nice to have so that's our that's
that's the reason we're doing a ot now
is we were looking forward to an
eventual project to to to replace more
components of the JV j SJ to se stack
the jdk stack on using java as an
implementation language instead of c++
or assembly code John said j2se he
really meant java SE yes thank you sorry
and
and and you know comparing static to
dynamic compilation is a lot of people
assume well compiling ahead of time is
better because you're not doing this
extra work at runtime but but in reality
like everything else it's a trade-off
and so you're trading off compilation
quality against compilation time at
runtime so dynamic compilers will always
beat static compilers in terms of the
quality of the code they generate
because they have more information with
which to make better optimization
decisions so you know for a lot in
previous attempts at a ot compilation
people were always disappointed that the
aot compiled code was slower than the
dynamically generated code it just you
get to peak performance faster and so a
OT really is mostly a startup play and
you know for programs that run for as
long as seconds it's you know it's not
actually that relevant and if you want
to write a little program that starts up
fires off a few packets and then shuts
down you might use other languages today
for that already but we hope eventually
as a ot becomes mature that we will be
able to write components like that in
you know in Java and the there's there's
early indications that that's quite
practical because some of you may have
seen some of the presentations by people
in the labs on technologies such as the
substrate vm which is able to shrink
down a hello world type job a program
into a bundle about as small as a sea
program that starts up about as far as
as fast as a sea program so there isn't
there is a sort of extreme amount of
work that you can do in the hundred
millisecond x time scale and so I think
we'll eventually we'll get there what
but we're you know we're just taking
baby steps right now as far as the the
product is concerned but the labs
experiments look very promising and we
expect within the next year to have some
some open source activity along this
line
for the API such as unsafe that we don't
want to use anymore there's usually good
replacements for those that there aren't
any replacements planned as far as Oh
like son mis signal why not just make
those into api's and bless them as being
available to use or can we have a
timescale for replacing them somehow so
the general philosophy on this is laid
out in JEP 260 you know as we are we are
gradually providing standard
functionality for much of what's in the
Sun misc packages and other unsupportive
things right of our handles which Paul
sandoz is sitting the back has been
working on and handle many many of those
cases but are we know there are a number
of critical api's like some has gone
Saif that lots of people depend on even
though they're technically unsupportive
so they will be there until there are
replacements and then they will stick
around until at least one major release
after those replacements existed a
question question from Twitter I think
this is for Brian what are the chances
of Jeff 286 which is local variable type
inference making it into a JVM near me
soon this soon mean yeah it's kind of my
question so if that's code for JD canine
the chances are zero it was not ever
part of the plan for nye and despite the
article in the server side today which
claimed that it was and despite the fact
that we at the keynote said several
times this was not 49 but it's not the
world's biggest feature so using your
judgment about well it's not for nine
but it's not huge you can think about
what the implications that might be
little it will be in some release
afternoon with it with a relief with a
number greater than nine probably
if you could limit your answers to the
java or oracle business and technical
space for this question but what keeps
you guys awake at night at the moment
I'm not going going to comment on any
business things that might keep me awake
well what what keeps me coming to work
how about that is the fact that we have
an extraordinarily vibrant ecosystem for
its built built by and for nerds like us
that that runs a huge proportion of the
world's computing and does so rather
well and still has room for improvement
and the improvements look like they
would not only be beautiful and
satisfying to work with but also
incredibly productive so what keeps me
going is the the next 20 years of Java
dude oh yeah and then and amplify that I
would say that the the long-term road
map of the the set of the set of
sensible improvements and enhancements
that we can foresee now and have a
pretty good idea of how to do and are
just quote a matter of Engineering is
better than it's ever been
this is kind of a specific question but
one of the things that slows down our
vibrant Java ecosystem is a digital
signature algorithm called RSASS a PSS
and so in Java 8 we recently upgraded to
a latest and greatest Java 8 I think
update 66 I decided that that needed to
be validated when using TLS 12 and it
doesn't validate and I'm wondering if
there's any plan for support for that
algorithm it's Microsoft's default pki
cert algorithm oh that's a good one you
have stumped the panel sir whoa it is is
this an algorithm for which there was
already support no it support was added
in this in this eight update well it's
kind of referred to in some of the Java
documentation it's there's a openjdk
there's a there's a ticket for it jdk 80
146 293 oh yeah that one yeah but why
didn't you say so that that may not they
meant that may not help unless some of
these googling back there for extra
information but it was kind of not clear
whether support would come for in jdk 9
or ever do we have anybody from the
security team here Jeanette Sean yeah
you want to find Sean Mullan or Joe or
Jeanette hun can probably answer answer
this question or security dev security
Devon okay okay thank you
weirdly kind of connected but not
because of security but because of
release of features now we are getting
jigsaw and a more modular JDK is there a
possibility for a more frequent release
cycle of features in modules hmm
fascinating question uh quite possibly
so one of the big reasons we're
modularizing the platform the JDK is in
fact to make it easier to evolve but
maintain an evolved going forward at one
might imagine no more a more rapid pace
we don't foresee any time in the near
future having some sort of mix-and-match
of modules where you could take a base
module from JDK 9.1 and mix it with your
HTTP client module from JDK 9.4 and
throw in a couple of 10 modules from jdk
10 that becomes a support nightmare but
definitely modularizing the platform
going from that bowl of spaghetti if
you've seen the ugly diagram to to the
fairly same model graph makes for a
platform that we can evolve more more
quickly because the components are
actually identified and independent and
somewhat protected from each other
hi so my company which might be
emblazoned all over the back of my
t-shirt of course has a java agent yes
which our java business depends on and a
reliability problem emerges because at
the point in time that we transform
classes we really just want to transform
bytecode but we find ourselves tangled
up in the middle of a class load because
that's the way the instrumentation api
is currently implemented that we
intercept the class load there's another
framework that does a similar kind of
thing but the instrumentation interface
is actually hooked to the just-in-time
so it's not actually the the the
bytecode transformation is not actually
done in the middle of somebody else's
class load that's already been resolved
it's done later just before the
just-in-time actually executing can you
name this other frame workers yes
Lucille are yeah and the points they get
out of frame work there's an entirely
different black work ok so thank you
you're right so you meant something
running on how I yet I didn't I didn't
look into I didn't mean to be snide in
any case it's a little simpler in some
respect because they're not in the midst
of a class load when they do the
bytecode transformation and so they
can't get tangled up in deadlock
scenarios with badly written customer
custom class loaders and so on and so
forth and the question I have is whether
there's any possibility of evolving the
instrumentation API in a way that would
reduce the likelihood of the kinds of
very occasional very specialized issues
we see the long tail of reliability
issues hmm good question um I don't
think that anybody anybody has has
thought deeply about improving that API
recently I'm thinking I'm thinking
j-link is the answer here at so 11 of
the one of the tools that that comes out
of JD canine and modularity is a link
time step so historically you compile
java source code to java bytecode and
then all linkage happens at runtime
and there are a lot of operations a lot
of optimizations that are sort of too
early to do at compile time and as
you're pointing out or a little bit late
to be doing at runtime and so since Java
hasn't historically had a link time
that's left you in kind of a you know a
limbo situation so Jay link is a tool
that processes class files jar files etc
after build you know but before runtime
and we use J link to do all kinds of
things to produce custom images to strip
debug symbols out to do byte code
optimizations turn you know reflective
look up into you know static you know
static references and for the sort of
bite good instrumentation that you want
to do that seems like an ideal
application of jail Inc which has a
plug-in architecture so you can define
j-link transformations you know and and
that way it happens once offline at
build time and then when the bike code
is loaded into the vm it's it's all
ready to go yeah so yes well there's one
proviso though Jay link only works with
explicit modules if you have a pile of
jar files on the classpath today you
could probably apply similar strategy
maybe and maybe rewrite them ahead of
time but Jay link can't it can't pre
link just random jar files because it's
it's it's chaos yeah but you know in in
5-10 years time it might apply to a lot
of code so the massive legacy code runs
inside a massive recursive class loader
in vacations and part of your problem is
that its legacy but of course part of
your value add is that you work on
legacy so there's no easy answer I will
say that that Java doesn't really have a
just-in-time moment the way clr does
because they have a warmup period in
possibly in the interpreter so you've
got to capture the byte codes really
early but I think the right answer
long-term sort of the let's say the
architectural right answer is to do
these sorts of transfer
orms earlier rather than later and do
them in a in a static setting and that's
why we're that's one of the benefits of
working with jay lincoln modules and
even a ot and some of the other features
like class data sharing were aiming to
be able to move more of the sort of Java
provisioning of application code into
the before startup and that's where
that's where we would see improvements
being made rather than tweaking the
instrumentation or the agent stuff to to
add more capabilities to do those kinds
of things statically in jail angkat and
we're doing that even in jdk nine now
it's a fruitful area to to work in yeah
thanks when I say we're doing it at
night I mean we're doing it in the
implementation for example method
handles are being spun statically where
they used to be spun dynamically things
like that yeah we use j-link of course
to build the JDK itself so yeah that's
all yeah it does really need to work it
works it does work it's cool okay
question from Twitter we probably each
have our own different answer biggest
single Java regret if you could give you
you know so much to choose from if you
go back in time what one thing would you
change I'm already on record with my
answer so i guess i have to say at its
serialization and and not the concept of
serialization the approach to
serialization which is a magic scraping
of fields that that allows d
serialization to bypass constructors the
gift that keeps on giving I so so many
things that could be regrets are just
categorized for me as well that's the
way it was at the time and we found the
optimal way to move through the
situation and get the best available out
of the out of the opportunities but i
would say that one thing that I regret
especially this year seeing how well
project Panama is turning out is that
when I proposed it in 2005 it was
heavily vetoed by the
the people that were running stuff then
yep that was that was sad project Panama
is really cool it's very panel was
extremely cool so Brian's regret is is
quite high on my list but I would say my
top regret is in 12 or maybe one dot 3
at the latest we should have done a
module system you know everybody's life
but those of us who work on the JDK and
everybody uses it would it would be so
much nicer right now because the DH is
this I don't know how many years project
I've lost count of designing a module
system that could be retrofitted on to
all of the code in the JDK and the even
vaster you know I'm out of code out in
the world in a sensible way has been
tough it's been fun and challenging but
we'd done it earlier if we've been
better for everybody sir so the Twitter
question actually trumped my question
but I've changed it a little bit so mark
put up the Q&amp;amp;A slide there i'm just
saying that this is ask us anything
about jdk is that okay you can ask the
jdk art architect whatever question you
cook all right so we might not answer it
yeah or you might not not like the
answer this is the antidote of that
question or so in the iphone style which
was the best release of java since Java
but the best release since 10
I think that has an easy answer the best
releases the one we're about to ship all
that's true at any Franny at any given
point I'm I'm a pretty big fan of 88 was
it was very nice oh I'll do 82 yeah as a
side note we were we were amazed at the
adoption rate on eight well yeah it was
faster than we've been in a long long
long time we also know that the adoption
rate of nine will not be that fast
that's oh that's okay we're good with
that we've made peace with it
there is a facility in Java in the class
loader to load the class is there any
way I can unload the class yes you can
drop all references to it and to the
class loader and to all objects that are
instances about a local number manually
I to do it on my in my applications I
had a different version of the product
so I spawned a new class loader with the
new version of the job but at the same
time because memory footprint is
increasing I have to say that i sat down
the previous one so how quickly I can
close the URI class loader from the
previous one will it clean the memory
hey you you cannot explicitly release
the class just as you cannot explicitly
release an object yeah but you know
because if you were to release a class
you know try to try to unload the class
and there were still instances of that
class around bad things would happen
right so you have to make sure that no
instances of that class are around and
that's the job the garbage collector so
that garbage collector will eventually
discover there are no instance of that
class around and no instances of you
know no references to the class loader
and then the classloader week garbage
class yeah but there's a PIV to provide
to do the garbage collection right
Georgie see something yeah you don't
ever want to call that no do not ever
call that yeah this system DC is is one
of those things that seemed like a good
idea in Java 10 but is actually in in
most in most cases as a disaster to use
because it does a you know a full a full
garbage collection which can be very
time consuming when in fact you don't
need to do a full garbage collection and
there many there there you know where
many instances of people doing systems
off GC and libraries and you know you
know this is like I'm just a time bomb
hidden in the code and the people
discover years later that the source of
their performance problem is that they
were using this XML library that
stupidly called system GC too often
there is another API point though for
releasing everything it's called system
exit no and I'm not just joking either
that is that is the way to really
release everything like hot upgrade we
are doing so we need to replace the old
version of class with the new assoc you
you can't do that you can kind of fake
it out by using some
higher level frameworks like I was GI
that that the put you know they like
everything else you see you had a level
of indirection so so there's sort of an
abstract concept of a bundle and if you
update the bundle then it's old class
loader is is let go and a new one is
spun up and then other bundles will
eventually refer to the new class loader
and that all works but it's an awful lot
of mechanism you know if you need it you
can use it but you know that's that's
not how primitive class voters work in
the platform thank you sure um let's see
Twitter Brian any chance of currying
arguments and lambdas not something
we're working on right now where we have
other things that we're working on right
now that we think are of greater value
such a diplomat good okay good idea or
bad idea well it it's it's just really
really really really far from the 50
most productivity-enhancing things we
could be working on certainly I think
it's more of a philosophical request
than a something that really makes a
difference in terms of everyday
productivity and they're just so many
other things that would have more of an
impact yeah what what killer API that
hasn't been written yet would require
currying above all else I don't think
there is one there are killer languages
that use currying but Java has enough of
its workarounds that it doesn't really
need them need currying apparently in
Scala you can do nice things with
currying so maybe maybe I'm wrong maybe
there is a killer application from Scala
some killer API that could be moved into
Java if only we had currying well and
you don't see it and to take an even
more obvious example so how many people
here have like noticed that Java lambdas
can't call themselves I don't see every
hand in the room going up there's two
yeah so you know one of the first lamb
to hack days that I did I you know and
and it was with London jug with there
were a bunch of a bunch of academic
showed up and they like pitched hissy
fits of like are you serious you calling
this a lambda it can't even call itself
you know you guys are dicks point it
and this was an engineering trade off
the you know we were able to simplify
the semantics significantly by not you
know and not having to accommodate this
and it hasn't turned out to be a big
deal right yes it would be nice to be
able to write factorial like you do in
the computer science textbooks as a
recursive lambda but in reality in terms
of getting in the way of the everyday
job of java programmers it's a complete
non-issue so you know in a perfect world
yes of course we'd have all these things
but it turns out that one can get an
awful lot of work done without them and
you know all but two people in the room
haven't noticed so sometimes pragmatic
trade-offs you know are pretty good what
make us Java most popular one of the
most a public language in the world why
is Java not the most popular language in
the world yes I know if I think I think
he's asking why why is it one of why why
is it mmm because ya know I'm in when
white job is so popular in the war oh
why what made it success what made it
successful well i mean the the the key
the core values of the platform from the
very beginning have proved very
attractive to to a large number of
people readability compatibility of
course i mean i'm blanking on the other
three right readability compatibility
productivity performance transparency
transparency compatibility is certainly
a very you know possibly the biggest you
know the fact the fact that code from
many years ago in binary form still runs
as i showed in the keynote i took swing
set to jar from jdk five and it runs
just fine on on a jigsaw EA built that
that's a pretty powerful thing and it's
not something that you find in all
platforms you know in some ecosystems
like for example this one you know the
nature of them is such that the the
dominant force in the ecosystem can
force people to go through phases of
income
the changes and that actually works out
java the java ecosystem doesn't work
that way so we've always tried to be
very responsible about evolving it that
also that kind of relates to another
question on Twitter do do you think that
at some point Java will break
compatibility in favor of faster and
easier innovation yes I I think we are
we are grab we're you know as I see it
and I and I suspect like to call eggs
agree we're we're going through a slow
phase change where we are we are ready
to recognize that some things just don't
belong there we're ready when we need to
make forward progress to remove old
things in in java SE 9 we're proposing
to remove for the first time ever we are
removing 6 methods I you know baby steps
but but you but you have those six
methods were we're preventing a clean
modularization of the platform if we
kept those six methods then if you
wanted to use anything in the java.util
package you would all have to carry
around all of swing and awt that's not a
good solution an attorney you know and
we were careful about this we studied
like all the jars we could find on maven
central and elsewhere and found that
these methods were actually very rarely
used so you know low-risk thing that
we've even been very clear about it we
gave notice when when job seh shipped
thinking of these six methods our
history we've removed a few other
mechanisms in in in jdk nine that were
either standard and not and rarely used
or non-standard and rarely used and
these are all documented in in the
various jep's and of course in nine
we're also we are also encapsulating
most jdk internal api's now from a
purist standpoint that is not an
incompatibility because after all you
should only be using the standard API
drain and nobody here uses non standard
a PSP right oh sorry you know so so it
yeah it is a it is a practical and
compatibility
but we've we've tried hard to
communicate all that and provide tools
to to help people move beyond it and
explain the reasons for it because we
know that for you know in some cases it
will be painful you know and further
down the road I can imagine entire
subsystems perhaps being jettisoned from
java SE do we really need to carry
around jax-ws and jack's b and korba
very useful to some people but do they
actually have to be part of SE mmm maybe
not so you guys wanted to refund
compatible well I want to go back to the
previous question for a second and then
already found compatibility so iiii
think the you know one of the
fundamental things that's made java so
successful is its commitment to
unobtrusive safety right so if you
compare java to what was around before
then which was mostly see there were a
lot of there were a lot of aspects where
you had to manage safety yourself you
have to manage pointer safety you had to
manage type safety you had to manage
memory safety and java managed to take
these responsibilities away from the
program in a way where you didn't really
miss them and you had the the runtime
you know i'm doing garbage collection
for you you had you know a somewhat
stronger type system which got stronger
you know further over over time you you
can't munge a pointer into an int you
know that you know the platform keeps
you from doing that so there are entire
categories of bugs that you just can't
make in java and if you're not wasting
energy avoiding we're chasing down those
bugs you can focus that energy on more
valuable activities and i think having
found that balance of unobtrusive safety
i think was kind of the secret sauce and
they're like any other success there was
also a little bit of luck it was the
right thing at the right time and we had
another secret sauce the thing that i
have come to value even more over the
years is the quality of the original
specifications which has been maintained
but if you if you look at the at the
Java language spec you and you and you
learn to lean on it and to
implement it and look for all the corner
cases and how they're documented it is I
think it's that I think it's maybe the
best programming spec programming
language spec ever written it certainly
is in it's in the top ten got to be it's
in the top five yeah and and and you
look at the authors gosling steel joy
they put in a lot of time and effort
into doing it and and it's it's been a
gift to millions of people their
successors have carried the torch well
because they have awesomely care that
are huge job Alex was here he's one of
the successors but he's next door
talking about modules and likewise with
the with the jvm specification which was
started by Tim Lindholm beautiful work
and and and and work that was not
perfect nothing nothing's ever quite
perfect but was very strong as a
foundation for building something that
would be compatible something so
compatible that you could do clean room
implementations of it there iBM has made
a business and Oracle made a business
aside from hospital with J rocket doing
a cleanroom implementation based on the
specs it's very difficult to find a
similar success for a specification like
that
so at the session a couple of years ago
one of the questions that got a lot of
interest was the prospect of using utf-8
is the default platform encoding is
there any progress on that or new
obstacles that you found in moving
towards that glorious future thank you
for the reminder I'm not sure anybody's
yeah no no I I'm extremely sympathetic I
don't think anybody has looked at that
recently what you know what one could
say that if we're going to do that nines
the release to do it because we're
breaking everything else anyway right
yeah thanks for the reminder alas the
amount of utf-8 text in the world is
just increasing particularly with emojis
and the default platform in coatings
particularly on Windows or the 88 51 yet
just aren't the right choice because
utf-8 Texas is almost all of the Texas
in the world now yeah no I mean hey I'm
nus utf-8 all the time how many people
in this room consciously avoid utf-8 as
a platform encoding when they when they
launched Java waiting Craig 0 all right
well that's a data point yep
you can ask one question more question
so you get back in line yeah okay so how
do you stay current with technology
continue learning more like what do you
do do that it's overwhelming talk to as
many people as we can who are not
involved in our own little bubble
ecosystem read everything we can watch
conference videos it's it is a lot of
information to process but you just have
to decide to be open to it because it's
so easy to focus on that which you're an
expert in and miss everything that's
going on outside and so you really have
to make a conscious effort to broaden
your input sources and make time for
them at multiple scales so learn what
your colleagues are doing down the
hallway learn what your colleagues at
they across the ecosystem are doing
learn what competitors are doing make
friends with your competitors and then
learn what people that you don't
normally cross paths with they're doing
and then since we are in computing go
read some math and some science and so
this year I read a couple books by
Raymond Smolyan on mathematical logic
just a brilliant refresh on that stuff
that it gave me fresh you know fresh
eyes for what I do so it works at
multiple scales yeah I I often Mei that
I I make a regular point of trying to
keep up with the programming language
academic research that's kind of where I
came from is hard there's an awful lot
to read there's an awful lot of it that
I just don't understand anymore but but
but but it's out there and another thing
I found helpful is I occasionally go
back and reread papers that I read 30
years ago to sort of get re-inspire by
you know what whatever beauty and
clarity I found at that time I think
probably every every five or six years I
go back and read the steel in Sussman
lambda papers there they're just you
know golden keys to so many things
what are the chances of type inference
for a local method for method return
values and maybe for relieving us from
the semicolon that's two questions so
you'll have to go back in the line for
the second question type inference for
method return values is extremely
unlikely and the reason for that is with
the exception of private methods you
know methods are part of your API and
there's a binary compatibility
consideration you don't want the return
type to subtly change just because you
change the body of your implementation
and now all of a sudden you're
programming / no longer links because
some other client that called your
method thought the return type was this
embeds that signature in the class file
and now you know the signature has
changed arguably that's not an issue for
private methods but that means that then
refactoring a method from private to
non-private you know is you know is a
less easy refactoring the short answer
is never going to happen now I'm for
philosophical reasons and the semicolons
so be serious
that's both the short and the long
answer hit there's there are the list of
things that are more important to work
on the mat is virtually infinite there
is a field where colon relief is
important but it's medical so um given
your greatest regrets and the the
likelihood that Java could break
compatibility of things could we ever
see a new serialization mechanism and
removals of the current joyful
serialization which yeah it's certainly
quite possible that serialization can
improve it seems unlikely that we could
fully get rid of the existing
serialization mechanism because there
are situations that basically won't
serialize under anything but the current
situation so we can't necessarily take
away the existing mechanism if we can't
replace it with something that is you
know compatible across the board that
said you know we've been making you know
a certain certain amount of progress in
identifying a serialization mechanism
that is safer easier to reason about
results in smaller object streams to
which code could migrate and and we
think that's probably about the best we
could do but it's definitely something
we want to do I'll be more aggressive
than that I want to take it out and
shoot it one day one once we've had a
viable replacement for you know ninety
eight percent of the use cases I just
it's just the number of security
vulnerabilities we had to fix because
that mechanism is just too painful if
you look at serialization what it really
amounts to is a secret contorted way of
adding new constructors to two classes
sometimes undeclared and
that that just doesn't work very well
with any other part of Java's workflow
so what what we what we need is some way
of declaring constructors in a much more
disciplined and reviewable auditable way
and then for the other end of the
equation coke instructors that that can
take apart an object into the operands
to the constructors and and so that you
know there's there's ways ways to do
this and the way we have now is
incredibly contorted and low-level and
impossible to understand but you know
everybody who's tried to do this nose of
course they want to be able to take an
object apart into its contents and then
put it back together but that's a that's
a that's a handshake and a process that
the author of the class needs needs more
control over or there's never going to
be any security yeah I'd like to remind
everyone that one other reason why Java
is so insanely popular it has always
been the very high quality of its
libraries from the very beginning when I
came to job as an application programmer
and that was one of the things that drew
me and that's still what draws people
from other languages where it's often
very difficult to find a deep set of
standard libraries such as in C++ for
example or where there are so many
libraries to choose from all of varying
quality of implementation and languages
the children who name a name such as
JavaScript where this is something that
Java really excels in so I wanted to
bring up that utf-8 remark that came and
turned that a little bit to the true
java.lang.string nowadays javed erlanger
string as of java 9 is no longer a
sequence of 16-bit core values
internally the library however still
exposes this fiction and it is super
inconvenient for developers who more
more run into characters that require
two 16-bit core values to be represented
the only thing that one can do right now
so you can turn a string into a stream
of the Unicode code points which is nice
it would be nicer if one could also
easily put it back it's not pretty right
now it would be even nicer if the API
cleaned up to present a string as a
sequence of what it actually is is there
yeah is that something that someone is
looking at so going back to that regrets
question using utf-16 ucs-2 as as the
native encoding that's it's in my top 10
I don't think it's in my top five but
it's definitely one of those things
where you know it was a it was actually
a controversial decision at the time it
was it was seen as very forward-looking
and pious 16 bits it's gonna be plenty
right now we've heard we've heard that
before on in so many other dimensions
money yeah yeah 600 point I don't know
introducing another string abstraction
I've seen this happen in other languages
and it's extraordinarily painful i think
in hacen haskell there are two different
two or three different string types that
are commonly used and fighting a Python
is that has always had this weird
distinction between you know strings and
sequence sequences of characters i I'd
love dived love to see a better string
abstraction that internally allowed to
utf-8 that provided you you the ability
to do arbitrary indexing but in some
cases may be made it you know a log cost
rather than a constant cost no it's not
actually well pretty modular code points
but anyway it's it's it if your jobs
ever had value types then there could be
a data type for code point if
hypothetically speaking at ever had
which would be the basis for a additions
to the string API if that would be more
convenient for programmers to use
without the cost of boxing so in that
hypothetical future things might be
better
mm-hmm part of the problem is that we
ask that people use the indexed act care
at accessors are treated like a raise
but stringz are really concatenate able
lot logically concatenate able symbols
symbol sequences and so if you if you're
willing to back off and treat them as
streams like you observed then you have
a more natural way of getting code
points out of them but if as long as we
supply classic c-style for loops and
iteration that uses i and i plus plus
and you know get get element at I it's
there's going to be a severe performance
problem with with allowing strings to
contain anything I think anything other
than a fixed size element so we're we're
moving away from the old for loop but
it's still it still tends to hold hold
us back on the decisions we can make
about about data structures especially
the one that's at the center like string
any data structure at the center Verity
like stringer array it's very hard to
evolve that what's your opinion on
spring framework and in particular like
do you feel like it's not needed because
Java can do all of that already or do
you feel like it's a good way to you
know simplify things and kind of
improved Java language which framework
spring Osprey blue it's a framework some
people find find it useful it Brian I
think you know more about it them yeah I
mean I I think application level
frameworks work at a very different
level than language does right so are
you know our job as language and
platform designers is to provide the
sensible set of primitives and
programming model in which you can
express you know the things that you
want to express both applications and
frameworks but you know frameworks the
role of frameworks is to abstract out
common application tasks you know to it
you know we eliminate redundancy and
improve reliability applications and you
know that's perfectly since
thing to do up at that level but you
know down at our level that's you know
it's all just application up there from
our perspective it's really important
but you know from where we sit you know
whether it's spring you know Java EE you
know time Tommy whatever I it's it's
stuff up there and then we have to make
it work well but sometimes you have to
put in hooks to make frameworks work
well in other words a framework can be
at first written on top of Java
unmodified but once in a while you find
places where like maybe hooks for
hibernation or something like that yeah
we you know at that point what needs to
happen is that the framework people need
to engage us and say you know if you
were able to give us these hooks here
then we could make our lives together
much better as indeed they have and they
do that only times out here so in a sort
of a forward-looking example of that
would be we want to be able to code
without what I call dinosaur so many
dinosaur threads in our applications we
want a reactive programming model where
there's if events that trigger other
events and you don't have to have a
multi megabyte thread pulled along
behind you and so in order to do that
you can you can use Java threads to
emulate actors and reaction points but
they they have costs and so maybe there
are some things we can do in the in the
in Java in the future which would allow
reactive frameworks can run more
efficiently on top of Java so there are
there are I would say there are lots of
potential cut points down into the into
the system which we you know need to
develop alongside our friends that are
building on top
I'd like to ask you personally while I
de tool editors you use for editing Java
and why you choose those so I'm a big
IntelliJ fan i've been using IntelliJ
since version two of their product which
is probably like 16 17 years ago or so
at this point it's by far the best Java
ID I mean I've tried i cried them all
including many of them that are out of
business and there's no comparison in
order emacs IntelliJ and netbeans and
you know if you want the bits right
there in your fingers and you want to
build a write macros that work on the
bits and emacs is your friend it's it's
the it's the hackers multi-tool yep
emacs it's wired into my fingers I've
been using it since sometime in the late
1970s you know occasionally NetBeans if
I need to you know make a GUI or
something but that in my lack of work
that's pretty fair any chance to see in
the future of shorter release cycles or
minors and majors or something that do
go resulting more agility oh sure
there's a chance what should that's so
that's actually an interesting question
so we we spend a lot of time thinking
about how long the release cycle is you
ought to be we look historically at how
long has it been in the past and of
course it's been highly variable
sometimes for problems that are not
engineering problem problems at all but
you know corporations merging and stuff
like that what is the optimal cycle I
think something that we definitely want
to look at especially given the
experience of nine being this feature
driven driven release is you know would
would the platform with the wider
community be best served by a more rapid
release cycle that had a strict you know
a really strict train model which was
just okay every year we're going to ship
at this time if your features ready you
know six seven months before then you go
in and if it's not ready then you just
wait so that's something you know we've
already done some thinking about will we
switch to it I have no idea I'd be
curious to know how you know it's always
been our sense that a yearly cadence
would be too fast for a fair number of
users in the ecosystem lot you know lots
of we we here we here both directly and
anecdotally lighting a lots of companies
they only know they've got big
deployments they only want to have to
test and qualify everything once every
two or three years so if you were gonna
ship a new version of java SE every year
they would just skip you know skip
versions and that would be bad and so I
don't know so I mean how many people
would like a yearly dearly cadence
strict strict strict train model like
you know like eclipse and a number
number of other projects do six seven
how many people prefer a feature driven
model where there are one or maybe a
handful of big features and feature
doesn't ship until those are done
interesting day within fifty percent
interesting data thank you i will not
predict the future what are the top
things you'd want to remove from java
like your top thing mark already named
his yeah i think we are we already
answered that question bigger biggest
regret I I would like to I we are so
concerned with compatibility because we
don't want to break trust with the whole
ecosystem right so removing stuff is
really difficult so if you ask what do
we want to remove that's like an idol
Idol dream but there are things we want
to supplant too we want people there are
items which we want people to stop using
so much and use better things
serialization has been mentioned already
I would say I mentioned the the old
fashioned for loop I'd like to see less
use of that can't remove it but I'd like
to see it streams or the new style for
loop or a new new for loop that sort of
his scream like that that would be
better that would be something I'd like
to use to supplant the old for loop and
even more important but in a similar
vein another another killer of program
abstraction and parallel lies ability is
mutability mutability at by default i
would like to perhaps not remove but
supplant make it make it easier for
programmers to work with immutable non
mutable persistent constant data
structures and have that be the
notational sweet spot rather than
currently which is everything is mutable
and everything has a race condition in
it I'll second that one I think closure
has found a really nice balance between
mutable
immutable yeah they're that they're
definitely good ideas to be to be
studied there mutability is the
exception should have to pay for every
use of the assignment operator and the
price goes up with every version yeah
hey revenue opportunity new business
Manu oh yeah so jigsaw we know i'm sure
you guys knew at the very beginning i
was going to be very difficult to pull
off and been proven by how long has
taken it was there have to be even
harder as you dug in were there things
that you're like how the hell did that
even work i mean as you tried to dig in
even with all the preparation were the
things that just totally surprised you
that we're in the product as you try to
give me things inside the jdk yeah yeah
some of the cross connections like those
those six methods that we're removing in
nine so i actually have a bit of fun
here so John why did why did the pack
200 API need event listeners because of
progress bars I apologize seemed like a
good idea at the time that's a it's a
legitimate reason but amongst the
methods we removed for the event
listener methods unpacked nadra oh sorry
sorry they're gone yeah I me there there
there were lots of surprising things on
the plus side you know there was
fortunately a fair amount of informal
discipline over the years you know even
going back to the very beginning to try
to keep things clean to try not to have
gratuitous dependencies I mean sure we
found stuff where you know some some
code in the corporate implementation was
reaching into the guts of the XML parser
like oh really but I you know I remember
back in the day working on 11 with the
first release I worked on and I happen
to notice that you know a well-meaning
engineer and the AWT team had put some
get icon methods into java.lang system
which seems like a good idea i mean neo
you might want methods in the system to
get icons for the running java program
or whatever
and I went and asked to meal in Lindhome
about it and he said what because it was
just an obvious you know even though we
didn't have modules it was just an
obvious violation of what informal
substance systems we had and so you know
I'm grateful we had at least the
informal discipline over the years so
that it wasn't so painful that only took
like five years to detangle the JDK more
than that we started in 2008 it's 530
last question any chance to bring
features from alec project home park
into the GDK or any plan to reduce the
amount of boat up on a plate I I believe
there would be zero chance of features
specifically from project lombok coming
into the JDK by Brian would you agree
with that somebody missed the keynote so
at the keynote on on Sunday we did talk
about boilerplate reduction features
they were not specifically a project
lombok but we we do care a lot about
boilerplate and we do have you know a
number of features on deck for
eliminating every day boilerplate we
showed local variable type inference we
showed the ability of the compiler to
generate default constructor equals hash
code to string you know type operations
so so yes but you know exactly what
those features are when they are what
version they come in to be determined
and maybe they make it easier to program
without mutability need okay one last
item this just in from Sean Mullan are
our security lead the Microsoft RSS
RSASS a issue is known for other people
have reported that we will look into it
after John Tolin all right with that
thank you very much thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>