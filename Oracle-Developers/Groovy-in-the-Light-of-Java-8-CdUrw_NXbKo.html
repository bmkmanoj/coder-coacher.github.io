<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Groovy in the Light of Java 8 | Coder Coacher - Coaching Coders</title><meta content="Groovy in the Light of Java 8 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Groovy in the Light of Java 8</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CdUrw_NXbKo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to this session of a groovy
in the light of Java 8 so some of you
may notice that I am NOT uniform I am an
impostor sorry so I am NOT replacing him
because I'm French I'm not placing him
because I also work for pivotal because
I am one of the Ruby committees so my
name is selling shampoo I work on the
brewery project for three years now and
I am committed for example the study
compiler in groovy too for those of you
who were a mess assertion about trades i
implemented traits and the game is very
sorry but he missed his plane so well
you know in France there was a strike
again with that France so he's not there
he gave me a slide deck I'm not used to
have so many slides this something like
200 slides in an hour so I do my best so
let's start so first of all who knows
the glue grube weekly already so okay so
if you want to have news about Lulu you
can register the Ruby weekly newsletter
and each Tuesday you have all the news
about the groovy ecosystem so there is a
day to register on that mainly list you
can go the new website there is a link
where you can risk register so this talk
is about groovy and java aids so the
question basically is do is still need
groovy if we have each other aids it's a
good question no so for those of you who
think no we don't use screwy anymore you
can get out thank you so why actually
more than just we have each other hy
groovy in Java 8 actually Java 8 added
some features that we had in grief along
for example closures Landa's are very
similar so in this talk we're going to
talk about those similar it is the
features
are in groovy and not in Java and the
opposite so you will have the full
picture and you will be able to decide
after this session if you still need
movie so how many of you use groovy
excellent right already some of you so
maybe some are already aware of what
lambdas are okay good so let's talk
about that so we have some features
which exists in both groovy and Java
with the tire differences and we'll talk
about that so Java 8 first of all this
is not talk about java age if you want
you have talked about Java 8 are plenty
of them much better so it's really
driver 8 in the light of groovy in that
sense so if you want more details go to
sessions about our age we will focus on
some features like the new syntax the
api's etc that you have in july eight is
a lot a lot of new stuff internet
actually sir take it take a look if
again right so first java a contains new
syntactical constructs so we have lambda
expression method references more than
just syntactic sugar for example and
interfaces you have default methods in
one knows what default methods are java
8 ok so we'll talk about that you have
announcements on annotations you can put
basically annotations anywhere anywhere
the code makes it very clear see anyway
lots of new stuff in Java 8 so in bold
this is what we will focus on today so
first landis so what I'll lambdas for
those of you who know groovy lunders
look very similar to closures ok that's
so so so similar so you can right now
things like that in Java things that you
were used to writing
actually you can use list of students
and filter traits string and then you
have that predicate students s with the
arrow so something similar to what we
have a closure is actually and an
expression without brackets without
anything it's just a single expression
actually Java does something here
without telling you it converts a lambda
into a functional interface so a
functional interface nothing but an
interface with a single abstract method
so single method interfacing single
methods so loud as can be converted
transparently so for those of you who
knew Ruby due to for example you know
that you can do the same closures so in
groovy you would write that okay so this
is what you're used to do so it's very
similar victory the difference is that
we have final instead of filter we have
collect instead of map and Max is the
same so you have different verbs but the
action is basically the same one
difference maybe someone knows between
the two now actually in this case we
creating will be intermediate this after
each call so you have a list created
here list here list is the max is called
on the list in Java actually you have
streams so it's lazily evaluated so
streams ABR have some interest on we're
going to explore them a bit more after
so lambdas actually had multiple syntax
as possible in Java the simplest one is
the first one so you only have a single
expression no parent s etc
it's very simple syntax second one is
when we had multiple arguments you have
to put those brackets but you can still
avoid having the curly braces and the
last one is with those braces so you
have to use the last one in case you
have actually multiple statements inside
your lamb leg out if it's a single
expression you can omit that it's very
simple what Java is able to do is
actually inferring those argument types
depending on the context use them so you
have some smartest july eight that
really makes the good much more
enjoyable much more grooving and it was
before java it's so you probably enjoyed
the right now he used to groovy so this
is the new stream api we can create a
range of integers and you have for each
method so it's basically the same as the
each method in brewing okay so we will
seeing that actually we have lots of
similarities in well maybe I don't need
groovy after all see the second is very
similar it's a it's an app for each ok
what would you do in groovy actually we
can replace this and we have the
implicit it so this is something that
you don't have a clean and Java one
difference or if the implicit argument
it's ok for the rest it looks very
similar you can use print line instead
of your system out print line so you had
it's a bit clearer that not much ok
oh that I don't think you have that in
Java 8 actually in groovy you can put
default arguments and closures you don't
have that and loved us okay so improve
you can define a closure like that and
say okay the default value for the
second argument is 10 and it works then
you can call it and then you see that
actually i'm using def so i'm assigning
a clear to something but it's not a
functional interface it's just a closure
it's an object which is a closure and
that is important so I can call multiply
with the tournament's it has sex and if
i omit the second argument to be it's
taken 10 okay so this is a feature that
you have a movie for free but groovy is
also dynamic language so you don't have
to specify the types for argument's you
can use of course compile static I know
you can is it of course but if you don't
want to in if you want to be purely
dynamic you can do that you can say okay
I have two arguments and I'm calling + +
well if the method + exists when i call
this closure it works if it doesn't you
will throw an error at runtime but
that's okay and writing test okay so i
can go other with two int's it works and
then with the strings and it works too
because the plus method is actually
defined on both integers and strings so
you have volume polymorphism actually so
this is something that you don't have in
july eight cool build this how many of
you use builders movie not so much okay
because this is probably one of the best
features of the language we'll see why
so actually there are some projects in
Java 8 I try to do some kind of builders
are a groovy and this is what it looks
like so imagine some kind of builder
that would generate this powerful
pom.xml file that you have Navin you
want to generate it with Lundy
expressions so you can do that this way
you can probably not be in excellent
market builder whatever but unit is that
you have those variants and you have the
numbers so first you see that we repeat
pom everywhere and there we have none
des will be zero arguments and in fact
Java forces you to write empty
parenthesis and an arrow so it's much
better than having a lot of anonymous
inner classes just to define a builder
okay still there's a lot of garbage code
in that slide do you agree with that so
in groovy what what would it look like
Natalie in groove it's much simple
because you can have well it could be a
xml markup builder whatever you can
write that code directly you don't have
the palm here you don't have heel you
just write what you want to generate
it's clear and actually looks clearer
that XML file that will generate right
you can read that so one groovy allows
that because groovy enclosures has the
notion of delegate and it's this is
something that is very special to groovy
only groovy has that closures have
delegates and the delegate is the
implicit receiver of a message in a
closure basically so when you call that
molar version
this is actually a method called done on
the delegate and the delegate is nothing
but palm which is variable that we
define so Ruby makes very easy to write
that kind of dsl's business so yeah you
agree that Saturday cleaner much more
readable that Java 8 version you want me
to show the Java solution no I won't do
that so if you said no the exit is the
back so more features that really
provides that you would probably not
find in Java 8 one of them is
memorization so take a closure some kind
of lambda some kind because start some
differences you can memorize on it and
what it does is actually that if you
call method second time with the same
arguments the result would be immediate
it's cached so we have that because
actually groovy closures are not coerced
to functional interface closures are
objects in Rui so you can manipulate
that you go cool memo eyes on a closure
object and this metal those catching for
free if you don't use a closure we have
an ast transformation anyone doesn't
know what an HT transformation is
excellent so just annotate this method
with memorized and boom caching for free
try to do that which other eight I think
you can well you could probably do that
with lumbar those of you who use that
book
any idea what this is Tara kosher so its
tail recursion yeah it's yeah but it
generates a proxy yeah there ya down
yeah but basically you can have caching
only you have to process everything
before and have some kind of wrapper
that executes aired so yeah closure and
tail recursion so enclosures since our
object you also have some a method
called trample line and what it will do
is basically avoid the problem of stack
of a flip okay you have a method which
which is recursive if you know it is
tail recursive you can call trample line
and then it will modify the clear intent
on it just to avoid stack overflows so
for the factorial written that way you
can add an accumulator your strength
line and then you have no problem of
stock of the flow again if you're not
using a closure but the method you have
a tail recursive annotation that you can
put in the method and then it is
transformed in such a way that it will
avoid stack of flow so it's rewritten at
compile time good method references so
for those of you who know a bit about
chata eight this is one of the major new
features after eight with regards to
dundas we're again we're used to use
that in ruby but slightly different so
imagine that kind of swing ish code
button set on action and then you can
use the London instead of creating an
anonymous inner class because etc just
use a single expression
print line evens well you can replace
all that with that system out double
column print line so this is a method
reference you just say okay I'm going to
call that method print line that's easy
and actually very practical to use you
will see much more code like that in the
future and this one because it's more
compact it reads better basically once
used to it of course so that three cases
you can use a method reference an
instance you can use a method reference
on a class and then it would mean that a
class the method you're referencing is a
static one but you can also use this
notation which is a class referencing an
instance method so for those of you who
know method pointers in groovy there is
actually one case here which is not
covered in groovy anyone has an idea
which one no last one actually this one
is not covered by grouping you cannot
use the last one so in Ruby the syntax
is actually using the ampersand you can
use that and internally it's not a
method reference in the sense of Java 8
method references because in groovy we
have closures so what this returns is
actually closure and the last one we do
not support that because we cannot
reference an instance without the act or
instance so the last one is not
supported by Ruby and one of the
questions that we have today is now that
Java 8 added the double column
hesitation should we support it yes or
no and what would be the semantics of
that because in Java aids it is a method
refer
in groovy it returns a closer always a
difference between the two so if you
have ideas if you're free to tell us
we're still not we still haven't decided
what we're going to do with that we have
basically three choices either adapt to
Java 8 syntax and drop some features
that we have in groovy or improve our
notation so that it suppose it supports
actually instances of method references
open question so far so good a question
okay so does anyone know that equity in
Java 8 you can have static method in
interfaces I have waited for that very
long time I mean static methods and
interfaces just avoid all those s
versions of the classes collections
arrays etc those exist just because you
cannot have static method in interfaces
well this is not true anymore in Java 8
you can define static method in an
interface so you can have strained up
empty directly defined on the stream
interface this is really cool this is
really cool so cool that I have a
problem because it's not supported in
groovy into it so we can't if you write
an interface in groovy you can't
currently add a static method inside you
do not support it and one of the reason
is that we support all the three decades
so when you combine groovy we target
multiple JDK as possible you have five
six seven yet no it's only six seven
eight and nine is in testing so we
support multiple to your gaze and
actually this
Speight changes so if you build some
library relying on that brick on all the
da case so something you have to know
anyway default method in interfaces so
for those of you who were actually in my
talked yesterday about rates you
probably know what our default methods
does anyone doesn't know what default
method in interface is everyone Wow
school so you can have default method
interfaces and that's really cool too
because it's traits in relate you have
traits some kind of trades not boost
that we're implementing agreement some
kind of trades so you have possibility
to have default into default methods
with a default implementation direct
meanness in dirty face so you don't need
to provide your own implementation if
you can rely on a default one okay
that's really simple so in groovy we not
had that we don't support the default
keyword we don't support writing
interfaces that have default methods we
can use them if you use GT KH and roomy
23 you can use interfaces with default
methods but groovy itself doesn't let
you write an interface that has a
default method instead we provide
threats so trades are some kind of
default methods but the big difference
is that it is meant to compose behavior
so you have small bricks of behavior
that you will compose in a single object
and the difference with Java 8 default
methods is that trades are stateful so
you are allowed to have two fields in a
trait so let's see with an example what
it means basically in Ruby first of all
you have a new key word in Greek
three which is trait to define a trait
and you say flying ability so I often
insist on using ability because creates
are really meant to design capabilities
so saying flying ability on just flying
just describes the intent of the trait
and you define a method fly and flying
and then what you can do is just a class
implementing the trait and then you will
inherit that method directly so you you
bring the default method but you have
straight support state which is not
supported by each other a default
methods so you can use a field a
property actor in Ruby and then if you
do bird implements named then you can
use the name property directly on the
bird it's that simple okay the trades go
beyond that because you can actually
inherit from different rates you can
compose multiple trades into a single
instance that means that we have some
kind of multiple inheritance movie
available which is not the case with job
eight and multiple inheritance without
the problems come in multiple
inheritance otherwise we just kill the
language right so multiple inheritance
means that you can define two trades
which have the same method and actually
its name the say it's taking the same
arguments returning the safest yes it's
just that actually I am extending a
person and implementing kitesurfer and
web surfer and problems that whoa how do
I know which method will be code so
groovy selves that just by saying okay
it's the last one that wins
actually there are more strategies that
you can use and trades you can choose
precisely which method will be called if
you're not happy with the default
behavior approving so you could choose
to use the other methods you have lots
of strategy as possible and trades are
very powerful for that so if you are
interested in designing by capability
and really having something that
composes behavioral to single operatives
traits are what you need repeating
annotation is also something that you
have in 28 so it's syntactic sugar for
only you can find basically in jp-a
whatever where you have all those rapid
annotations just to be able to set
multiple annotations of the same name so
you can use twice the same annotation on
the method without having to use that
wrapper annotation so this is done using
the repeatable annotation on schedule
which just declares that ok now I am
allowed to omit that it's just saying
schedules is a reputable annotation so
you don't have to use schedules with an
S here ok right
so groovy doesn't support that something
you have to know Ruby doesn't support
repeating annotations we will do we will
if you have time to implement that and
submit a pull request would be very
happy just we don't have time to
implement that but it's in the schedule
so will be supported annotations
actually enjoy they can be put
everywhere you have a type so you can
find that kind of code no no your name
well it's a cast so why not put an
annotation because it's tied I can put
the list of none else trains etc etc so
you can put annotations everywhere
that's cool but it can also produce very
verbose code with lists of nonverbal
list of not nella bubbly stuff imagine
that kind of code you will find that in
the future because obviously it's a
feature that people will abuse we still
do not support that in groovy so one
reason is that I would run eyes a bit
build and we have to have read it so
last summer we have we had Google's and
half code student at work on a new
grammar so we will be able to support
that soon but not yet not yet in groovy
23 nauru to fall yes that that's just to
say if we have more annotations like
that actually with groovy in AST
transformations it also means that we
have more hooks where we can plug AC
transformations and perform compile-time
stuff so imagine non know for example we
can provide hints to the compiler to
check actually compile time that
something is not done but ruby has
things that obviously java doesn't have
so in the GE e word you're used to have
a class with the 20 annotations the
beginning and
two lines of code inside a bit like that
but with more annotations and the
problems that you stack annotation stack
annotations technicians and it's
everywhere and you bring that to another
class okay in groovy you can shorten
everything into an annotation collector
annotation just create a meta annotation
annotated itself with annotation
collector and the two annotations that
you aren't actually and then it means
that you can replace whole annotation
with a single one so you can shorten
annotations replace the whole block with
a single one in stone at compile time
and for example for those of you who do
reflection actually at runtime item you
would find those annotations not this
one it's highly customizable you can do
a lot of stuff that's really practical
especially if you're into dsl Oracle yes
so the new driver 8 API is there are
quite a few new debate IP I'm sorry one
of them is the date and time maybe I so
this is an example of how you manage
date and time in Java 8 for those of you
who know draw the time it's almost
exactly the same and finally it's in the
dedica jdk we had to wait until JDK 8
you have a distance date I maybe I'm
decade so you can write that lines of
code you have the semicolons everywhere
probably in groovy we could replace that
with some kind of operator overloading
minus just use minus instead of medical
and what is interesting with this slide
is that you can help because Ruby is not
just a language it's also a lot of API
is that leverage lengua
and this is probably the easiest way to
contribute to groovy you can take that
kind of api's and grew if I them make
them easier nice at using Ruby submit
pull request and will be very happy to
have that so you can use the new API in
groovy you would use it today exactly
yet like you sitting generate not much
interested what about a new groovy
module specific to each other time to
the new date time ap up instead groovy
provides for actually a very long time
probably one of the first features of
groovy the time category and the time
category allowed you still allows you
actually to use that kind of notation
two years first three moons please 15
days etc so it's still not more readable
than this one so even if we have
interesting api's with daytime api's but
this one is not bad too and it's 10
years old the stream API so I gave some
examples of the stream API in the
beginning of talk so not produce any one
so this is MapReduce explain 26 years
old right thank you so stream stream API
is probably the new API that you will
use in every new project if you start
survey using Java 8 in that you use the
old collections API there's something
you do wrong this is the new way to
write stuff small functional way so you
take a list of persons and you called
stream and it returns a list it returns
a stream
of persons not a list of us and then you
had all those methods available filter
nap sorted etc be careful of collect
unfortunately Jerrica aid came out way
after we decided to have collect method
in groovy the correct method in ruby is
actually the map method so if you switch
context it too often go crazy so in
groovy actually we could do that final
collect salt joining etc so it's really
you see that jetta is not that bad now
obviously you can do that but the good
news is the agony you can use the groovy
the jeddak 88 stream api in groovy right
now and we don't have to provide our own
streaming API just to provide lazy
evaluations so if you use jdk 8 and
movie well do that you can do that you
can use closures instead of unders it's
not because we don't support the lungs a
syntax that actually you can't use API
is using lambdas because it's just a
matter of accepting an interface so you
can use I love with the clutter and it
works so it's not because you're using
Ruby that you're doomed to using the
older ap is final etc that ok ok so yes
what happens here exactly some type
questions sun is single abstract method
so if you accept an interface that has a
single abstract method so we can curse
the closure directly internet that
interface just like java this optional
so those who do functional programming
know that for a long time optional is a
way to avoid nullpointerexception it's
yes it's basically it's safer to use
that it comes at a price the price is
performance because JVM doesn't handle
that very well you still have it in
directions but basically the idea is
that you have to handle nulls explicitly
so you create an optional of something
so it's an optional strain because it's
a string and then you have methods an
optional like or else which means if
it's no then it will return something
else you have if present basically if if
it's not know etc so you have to handle
something explicitly to check if the
value exists or not and of course you
have to make sure that option on the
optional the human ability itself is not
know otherwise oh yeah back to you the
old way of handling nuts but in groovy
that's not what we were used to do for
years in groovy we have chose to handle
else did you know that you can customize
the truth in groovy we can as boolean is
important in Ruby you can implement as
boolean actually tell the run time when
a value is true or false so it's a very
useful trick to know about Ruby
implement it as we lay a method and you
will have shortened code so let's see
what it looks like who's that guy and
this the a visa / operator so let's take
that optional and make it a bit groovy
yet maybe we could use the Elvis
operator to handle optional because
optional forces you to call is present
is absolutely cetera but maybe we could
do that use the operator just
to shorten the code and make it more
readable more instructive and this may
be named is actually some customized
through on the optional class so this is
not done but someone on the mailing list
works on the topic we have a ProQuest
already done for that so we are fighting
I would say with the problems of the
semantics on the performance at runtime
in case you call method directly on an
optional because the problem is the same
as in Java you have to end wrap the
object every time so it's not merged yet
but if you're interested in developing
you API so an optional make it more
groovy just by syntactic sugar take a
look at the mailing list and approval
question feel free to help us anyone
knows what Nath's own is so not
Nashville a song so now phone is the new
JavaScript engine bundle with jdk 8 it
is match match match match match faster
than the previous one which is RINO so
you can use actually the engine the
JavaScript engine of not an asshole
engine directing Ruby you can use the
script engine an editor get the script
engine by its name lass home and then
you can call each other trip director
from groovy music so that is one way to
use javascript in groovy and backing
engine would be NASA I won't comment on
that
but in groovy we also had projects light
grew script and when those would Bruce
get is so it's a pretty impressive
project basically converts privy code
into JavaScript code so you can write
groovy everywhere so groovy service I
gravina client-side and funk I said it
would be converted into JavaScript sorry
why do you laugh okay so groovy effects
is actually something like that it's a
builder Batum July effects and if you do
Jenna fix I hope that you would prefer
using that instead of the language that
you have in factory in javafx which is
playing Java this is the kind of
builders that you can have with groovy
effects much more elegant I'm gonna
insist on those because I yeah we have
15 minutes left on this 200 slides or so
let's go Father so groovy and the Java 8
story is not just about 28 it's also
about the ecosystem and one thing that
we're adding in groovy 24 which is
already in beta state is Android step
support so anybody rights Android
applications already do you like it like
to write Java would you prefer to use
groovy yeah so now you can use groovy so
actually you have beta 3 available you
can use groovy so I wrote two blog posts
that gave gives some description how we
can do that the good news is that
actually the New York Times is going to
write its next application using Ruby
pretty cool and even if it's in beta
actually they're already enjoying it and
why well because there's no data antec
300 so you still have the
animals in a class paradise in android
you know you have to write an 11 senior
classes everywhere so imagine that could
everywhere in any Android application
that actually can replace but that in
groovy I don't know which one is more
readable I have a doubt ok so do that
please try groovy on already there's an
application Alexa actually already
deserve deployed on google play which
was root for the break-ins okay let's so
let's keep the ecosystem part you have
lots of project this one is actually
interesting Spock I'm pretty sure you
use that and spark uses that kind of
syntax which is totally impossible to
have in Java 8 right just because it's
compiled on magic in action here and
we're transforming everything to
something actually read one okay let's
keep that cradle how many of you don't
use Gradle you should be ashamed I know
you had no choice J bars etc so yeah for
the last 15 minutes we'll talk about the
modules that we have actually in greeley
and just select a few of them so groovy
modules exists since groovy to so before
groovy to you had the big drawer with
everything bundled since chromate you
actually can select which modules you
want so you don't have to use the big
reveal all genre and select them so
let's give you a few examples of what
you can achieve groovy so that kind of
syntax for EM scripting i don't i don't
expect many people to use n-never days
still it can be useful for example last
week someone asked me what was the
easiest way to end zip a file
groovy and it was just a one-liner using
and builder you just write you and build
a dot and zip with parameters and done
so just at the end mobile and you have
that for free so even if it's even if
aunt is probably not what you would use
for building an application today you
can still use the features from aunt
directly in a brewery project very
interesting to do that Jason everybody
does Jason today okay so Jason actually
groovy has a JSON builder again builders
and low garbage with the Jason parameter
everywhere receiver etc it's very
readable and ruby has the fastest json
parser available today it's faster than
jackson faster than Jason whatever you
want agreed to three had the fastest
Jason pastor of the JV n it's pretty
cool to know that and there are actually
benchmarks proving that proving so
passing yet you can just pulse I don't
know if it can be easier than that you
know policy just take the URL path text
and then you can use these syntax which
will you'll never have that with there
by eight even Japan I in Java ten you
want have that it's the J path picture
so you have commits that committeth
Arthur the name that is so easy and you
don't have to create an underlying model
just to be able to manipulate Jason just
two lines of code just to pass Jason
this is something I really enjoy your
library to treat a new template engine
how many of you know the new druid
template engine that we have
3 2 3 ok so it's an engine which is
actually bundled in spring boot by
default notes the default engine being
used because it's pretty fast I creates
a template engine which is very fast
because everything every template is
statically compiled to bytecode so
unlike timely for free marker whatever
this is byte code generated from a tent
late so you pay the price at compile
time and then move super fast and the
templates look like that it's a builder
so you can right Carl's then cars here
is actually a variable in vining and it
can call the each method and generate
that and what it would generate is this
excellent so it's a template engine
which is suitable for any kind of markup
based language so HTML XML but you can
also use it to generate plain text if
you want it also works it supports
multiple features like internal
internalization yes difficult for me to
say that you have layouts etc lots of
future it's an interesting yeah really
interesting engine so how you create a
template agree it's just like the good
old template engines and groovy have a
create template method and then you can
create whatever you want compile
statically everything are good
so even what I have shown you what is
your answer to the question yes of
course we're still in groovy so why
waste in the groovy many many answers to
the question I have just given some
hints first of all groovy was never
meant to replace John and it is not even
if now we can write a full application
in groovy you have compiled static if
you want you to make it even easier if
you really enjoy compiled and errors
that doesn't prevent you from writing
unit tests on ok still can have that so
Ruby is meant to be a companion to Java
so all the API is that you find in Java
8 you can use them from groovy you can
enhance those api's we have given some
hints about what we want to have from
Java 8 and burrow from gramma 18 groovy
and improve that synthetically for
example this is important groovy is a
companion desire and actually groovy
always goes a bit beyond what Java has
to offer so we are not saying that we do
better than Java never do that just sing
tactically different we can go beyond it
can come with the price performance
price whatever but the idea is that
groovy is always a superset of what Java
has to offer and make it cleaner easier
to read easier to use increase your
developer productivity actually so the
questions today that are still open and
that you as a community can participate
in is for example the lambda syntax
should we support an under syntax so why
this question is important is because
it's turkey a groovy always told you you
can copy and paste java code and it will
compile actually with Java 8 code it's
not true anymore because if you copy
code containing nandez not compile
because we do not support number syntax
so should we serve all the lambda syntax
knowing that we had closures which would
mean to very close in taxes for
difference yeah it's an open question
you you probably have your opinion don't
hesitate to tell us what you would want
to help the question of method
references repeated annotations this is
not an original equation but now that we
have a new grammar ready to be merged
will be much easier for us to implement
that the default methods ability in
groovy to implement default methods
interfaces again the problem is that if
we do that we break compatibility with
all the decades so if she compiled
something in groovy that has that you
would wouldn't be able to use your
groovy library on all the three decades
it's up to you or three static methods
etc so a lot of open questions the API
announcement so for example daytime API
etc operate a little you are important
so we always put that slide on that guy
in the sky because one of the most
important features of groovy is not the
language it's the community you are a
feature you decide guys what you wanted
in the language if you want to do
something tell us and if you want to
participate test so meet verrucous were
very open
there's new basically it is not plan the
plan is yours okay time for questions I
five minutes I did it all the slides yes
yeah so the question is if we have an
idea how we could support both or not so
yes we have ideas one of the ideas would
be that we could support I told us
that's my favorites we could support a
yonder syntax but internally use
closures so that would mean that we
would have semantic differences between
a closure and a lambda in groovy so a
single object the other option is to
support a syntax and have them behave
like lambdas I'm not a big fan of that
because there are slightly different
semantics between lambdas and closures
for example in the way the capture
variables and I think personally it
would be difficult for groovy users to
make the difference between the two I
think it's in Ruby you have that kind of
problems with multiple sin taxes and
slightly different syntax a slightly
different semantics answer I'm not a big
fan of that in the last one of course is
not supported not a sin tax at all and
let groovy leave its own life and
separate from Java starting from now you
decide
so if you want so the question is what
it's coming in groovy so you have a talk
actually by guillaume tomorrow if you
manage to get there so he will be giving
more insight that what's going to read
to fall group III etc but basically we
yet we add support for android going to
develop a new mop new matar a protocol
that right so the question is what we do
when we compile java in maven grade or
whatever and that you have java code and
ruby code so all the code in groovy is
handled by the Greek Empire on the
Korean july's and all my java compiler
so we do stop combinations so this is
one of the reasons today that degree
compiler is slower if you activate join
compilation because we have to generate
steps for every class so it's price
with the performance difference between
lambdas and closures it's difficult to
say today so if you jdk 8 correctly
performances of landis is pretty good
but it's also proof of Ruby Rogers I
would say the main difference is in the
stack traces that you can have because
you have intermediary classes with
groovy that you don't have with Landis
and well even with land as you would
have open stack traces because of all
the internal conversion that they do if
you find a stack trace with number phone
you would probably understand what I
mean okay I'm running out of time so if
you have questions to desert 8 you talk
for me after the session thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>