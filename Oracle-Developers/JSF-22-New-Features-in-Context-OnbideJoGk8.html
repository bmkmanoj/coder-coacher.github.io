<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JSF 2.2 New Features in Context | Coder Coacher - Coaching Coders</title><meta content="JSF 2.2 New Features in Context - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JSF 2.2 New Features in Context</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OnbideJoGk8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">morning my name is Ed Burns and my
colleague Roger contained Roger and I'm
working on jsf for a really long time
and you know what's gotten to where it's
at with the help of participation from
the community and I'm really glad you
guys made the effort to come up really
early I know it's very hard to do at
javaone depending on what you did the
night before here is our agenda today
this is just for of the large variety of
new features that are in jsf 2.2 we know
we can always you can learn more about
it on the website jsf java.net and let's
get right into it we're going to be
talking just about what we've already
done with JSF we're not going to be
talking about any forward-looking
statements any new product announcement
saying like that this is just what's in
the JSF spec and a technical
presentation about that our approach in
2.2 was the same as ever right we want
to leverage the existing API and bring
new functionality so what we since jsf
10 every UI component has had a boolean
property called transient and it really
wasn't used very much but if you set
that boolean property to false I'm sorry
if you set the transient property to
true then the thing won't participate in
state saving so really all we had to do
to make this work was expose the
transient property as an attribute on f
colon view and more importantly we had
to make some changes in the life cycle
specification for restore view and
response state manager and this idea was
brought out by another colleague that's
unfortunately not with us here today
Manfred dream so Manfred Roger and I are
the JSF team at Oracle the
implementation and specification team
and Manfred was really instrumental in
creating the this feature maybe there's
some things to keep in mind though so
when you set f Cole and view tranxene
eagles true first thing it must be on
the outermost view in the facelets
inclusion so when you have Facebook
pages you don't need to have an F colon
view of course
because everything will automatically be
put inside of an F colon I mean a view
route you I've your route but you can
have an F colon view if you do it has to
be on the outermost one of the facelets
pages also if you have you scoped
managed beans they won't work if the
view is marked stateless which kind of
makes sense aside from that the other
thing to keep advised keep in mind is
the user interface component state such
as which tab is selected or which tree
node is expanded or contracted if you're
using a prime faces thing with like data
table and you have your sortable columns
all of that state information is is
what's kept in the UI component state so
if you turn that off that will be lost
so really this feature is useful when
you happen to have pages that are using
components that don't have state fulness
attached to them or they don't need it
rather so if you have a lot of pages
like that you can make use of this
feature right so this is kind of what I
just said really again when you compare
jsf with other approaches to web
application user interface development
state fulness is the main thing that
differentiates us from a more restful
based type service on the pro side you
can be really lazy with your user
interface as far as state concern is
concerned you don't need to manage it
you just throw those components in there
and you know that when the post happens
or when they get happens to the
lifecycle everything will automatically
be restored for you and on the con side
though you know you have to deal with
all that performance management the next
feature I'd like to bring to the
presentation here is resource library
contracts and this is a feature that's
extension of to existing features in jsf
the first is resource libraries to
review a little bit what we did with JSF
20 there the story for delivering user
interfaces via HTML has always been a
four-part story you will actually
was a four parts there was a two-part
story one and CC mosaic came around and
it became a four-part story who has
things got more mature the four parts of
course being the markup the CSS the
JavaScript in the images jsf Wando only
dealt with the life cycle the core life
cycle only dealt with the HTML part and
then component libraries had to provide
their own filter or servlet or other way
of serving up the CSS the style sheets
I'm sorry the CSS the JavaScript in the
images when jsf to dot 0 came along we
managed to bring that into the life
cycle so that was you know 2009 or so
that's resource library's research
library contracts takes that concept and
combines it with facelets so basically
it lets you put facelets inside of
resource libraries and it does it by
defining this contracts directory and
I'll have some more content explaining
what that is but basically any template
client that honors this informal
contract can be used with any resource
library contract that implements that
contract let me explain what that means
so you in jsf 204 resource libraries
there was a special directory in the web
app route called resources now we have a
special directory in web app route
called contracts or a corresponding
location in the classpath so when you're
using facelets you have your template
client and then you have your template
and the core thing here is what are the
names of these holes where you're going
to put your content so if you're writing
this thing you need to know what these
things are called so you can say you i
define name equals that so really that
constitutes a usage contract between
these two elements the template client
and the template and the contract
consists of what is the name of the
template file what are the insertion
points and also if you'd like to take
advantage of this what kind of resources
are defined outside here so if this
guy's bringing style to the world and
you want to apply that style inside here
then you need to know what are the CSS
classes and other things that you might
want to reference from outside so once
you have those three things that really
is a contract in which consists of you
know the declared templates the declared
insertion points and the declared
resources now once we have a contract as
I mentioned earlier you can bundle these
things in the contracts directory or in
jar files in the web and Flibe and once
you now have this set of things to look
at you now have the set of available
contracts so any page in the app can now
take advantage of any of these contracts
that are defined here so basically when
the app starts out up it goes around and
searches for all these things and makes
them available the important thing to
note that in this case though the
convention is there can't be any
duplicates among these things right so
I'm going to say you know there's a
template file in here called navigation
header or something like that and there
might be another one here also called
navigation header that would be a
problem but if you're careful about how
you offer it you don't need to worry
about that right in the common case you
know what your templates are you're
going to going to avoid having
duplicates however in a world where
modularity is very important it might
not be uncommon to run into duplicate
cases or other scenarios where you'd
like to configure which pages can use
which templates and if you want to do
that you can have the from this syntax
in the faces config file just as the
little stopgap simplifying measure we
also added a contracts attribute to F
colon view so here you're saying any
view that as a child of this guy either
directly or included via facelets can
take advantage of any of the contracts
listed here and so when I say that
contracts equals contract a then only
the template files in this file and this
contract rather are available to this
page another important thing
the instant you have some kind of faces
config syntax for this the everything is
available option is turned off so it's
either entirely explicit or entirely
open there's no way for us to
distinguish between the two cases okay
so all of the basically you have a
resource library contracts element and
inside there there's another sub element
and inside there there's a URL pattern
and that describes which are the
contracts under that thing so we're
going to go to a demo now and Rogers
going to show this feature in action so
first of all first I'll show you the
demo and then we'll go into NetBeans and
look at some code so this is just a
little demo we put together just to show
various html5 layout samples so if I
click on sample one that's just a simple
layout these are all various templates
that we're defining as in the resource
library contracts so let's see how we
did this in some code
ok
so let's take a look at the index HTML
page this is the page that will be
inserted into our templates you'll see
if you're familiar with facelets
templating this markup shouldn't be no
surprise to you you'll see a UI define
there with the name of main content that
is what we're going to be referring to
in our contracts our templates so it's
just a simple page with some links on
there one thing you'd like to know you
should know is the f co and view tag on
the top this is where we specify how we
can navigate between the various
templates so let me bring up the
templates so in this example i think you
working towards having the templates be
customizable on the fly and that's not
necessarily something you have to do I
mean you providing user customizable
skinning is a feature that you could do
in your app with this thing but it
doesn't have to be that way you know you
don't need to expose the ability to
change templates to the user of your app
right so you'll notice as I had
mentioned there's a contracts directory
and under the contracts directory this
is where we define our templates so for
the contracts that you saw on that demo
page let's take a look at the first one
here you'll see where we basically this
is the UI insert that's where we insert
that main content into this template and
the rest of the contracts for this demo
are pretty much the same we're basically
taking that main content and inserting
it into these templates so the part of
it that has to be the same are the names
of the insertion points right and you
know everything else can be completely
different and you notice the way we have
this structured under each of the
contract sub directories we have you can
put your style sheets to affect the
visual display of that individual
contract so it's nicely nicely packaged
under there
right you want to say anything else sir
yeah I think that's it are you going to
show the pram thing or swapping it by
passing in a different value of that's
not a part of the demo and then don't
worry about it but it's not I mean I
have it in the mark-up I explained that
in the markup on the F calling view tag
okay on the top here okay so but yes the
purim is basically letting you pass in
what contract to choose in the query
string right that what right you can see
that up that you can see that up here on
the f cone view tag we have that al
expression on with the pram all right
you were to go back real quick you can
see right there on the top template
equal contract one right and if i switch
template equal contract to and so forth
so this is just one way you can you can
one mechanism you can use to visually
switch between your contracts okay all
right let me go back here
the next big feature I want to talk
about is faces flows this lets you bring
modularity of behavior to your GF
application the previous feature
resource library contracts let you bring
modularity of appearance so once you
have these two axes of customization
really can have a lot more flexibility
with how you evolve your jsf app over
time mmm what is the flow it's an
application sub-module that has a
well-defined entry and exit point you
think of it like a room there's a door
you go in and add or you go out input
and output parameters pre and post
handlers builds on the concepts of
navigation that have been in jsf since 1
dot oh right so again it's not hard to
learn this if you've already learned jsf
and you already know how navigation
works it's just a little step up with a
little bit more functionality inspired
by ATF task flows spring web flow and
apache my face is cody and it's a
feature that's been a long time in
coming again when you look at a
specification you don't look to the
specification for cutting-edge
development rather you look for the
specification to standardize best
practices that are already out there so
that's why you know here it is in 2013
and now we finally have a flow thing you
know it's we wanted to make sure that
all of these other players that are
doing the innovation got it right and
then we can pull in the bits that are
just the right thing for us again you
this pattern of having a special
directory in the web app root or a
special location on the classpath and
you know a flow can be called from any
place any view in the application that
is it as a single entry point you can
pass parameters and return values and it
has a well-defined interface contract so
the internal implementation details of
that flow don't need to be known by the
collar they don't hear using a flow
technology of some kind in their app
already web flow or ATF or something or
cody ok i think this is a
great feature to add because without
some kind of flow thing you end up with
basically your entire app is a single
function with lots of go-to statements
in it and that's very hard to manage and
it's certainly not good computer science
practice so prior to jsf to point to all
of the navigation in the app was only
between pages we call them views but
their pages usually now with flows we
have several different node types the
view the pages that we had before and
then these four additional ones method
call switch flow call flow return each
of these other ones is another thing you
can navigate to with an action button or
a command button or you know it doesn't
have to be the H colon command but and
of course the prime faces richfaces
whatever button you want or link will
work with this feature at runtime this
flow is represented by an instance of
this class and a flow is composed of
these different view nodes that I
mentioned before also there's a whole
nother feature that sits behind this
feature called client window that I'm
not even talking about today but it's a
big feature that basically finally lets
jsf handle tab browser tabs and browser
windows correctly so you know you can
finally now when you have a browser with
several tabs or several different
browser windows that are all pointing to
the same app if you're using the client
window feature they'll finally be able
to distinguish between themselves and
not have collisions anymore and you'll
be able to detect the case where you
know multiple like let's say someone
copies a link from one you have an H
cone link on your page and you open a
new tab then you have multiple tabs
facing that same window the system will
let you catch that and detect it
gracefully it's a little bit of extra
work at the application level to do that
but the point is now you can at least
figure it out and do the right thing
whatever the right thing is for your app
another important point is authoring
these flows you can either do it next ml
or using a builder API ok so the view
nodes represent the pages and the ID
attribute is used in navigation rules
optionally you can identify the VDL
document used to render the view if the
ID of the flow node is different from
the actual page right sometimes that
happens method call nodes they let you
invoke logic from the flow graph and
lets you decouple the invocation of
logic from the UI component arrangement
in the views basically it's a node that
is an email expression we call that
method and the outcome from that thing
is either where to go next or we have a
way to declare a default value if you
want to call a void method for this
switch nodes are pretty much the same as
method call knows except you have a big
list of them and the first one that
evaluates to true will have its outcome
taken and there's a default outcome you
can do let's see okay flow call nodes of
course this is the important thing this
is how you go from one flow to another
so these flows are arranged in a call
stack just like you would have in Java
methods and when you are in one flow and
you call another flow then you get a new
level in the stack you can have new flow
scoped concepts flow scoped data that is
and of course you can pass parameters
and return from there and return node
that's what you navigate to when you
want to leave the flow lets you identify
return values to be passed back to the
calling flow okay so in order to define
one of these things you need to say what
the name is where does it's what's the
start node and optionally you know what
are the input values and if you're going
to have a initializer and a finalizer
those things can be declared also this
is the an example of the Builder syntax
it's hard to see but you know you
basically have a CDI producer method
here can you zoom it your exit out of
the presentation and then we'll just do
something like this right oh that's not
what I want well I'll just talk over it
all right okay you have a CDI producer
method and you say this is at produces
and you have a method that is passed the
flow builder and there's some other CDI
information you have to pass on there
and basically you get past a flow
builder and in that thing you can have a
number of methods that are give you a
fluent api for describing this thing so
everything you can do in xml with
respect to flows is also doable with
this float builder api ok that's it for
the faces flows feature now we're going
to talk about html5 friendly markup
people would say to be about jsf oh boy
what are you going to do for HTML you
know you're going to rewrite all of the
HTML basic tag library and provide new
elements for all of the things that we
now have an html5 or we looked at that
option in the expert group and one of
our expert group members Frank Caputo
from Hamburg who was recommended to me
by Adam bean join the export group and
made a very big contribution he was also
quite instrumental in the resource
library contracts feature he said well
why don't we take advantage of this tag
decorator concept that we've had in
facelets since the very beginning and it
will let us have passed through elements
and I'll describe what I mean by that
but it'll basically let us leverage
what's in the new html5 spec without
having to define new tags for everything
before i get into passed through
elements which i think is the heart of
the html5 capabilities in jsf
point to a few other more basic things
the html5 doctype is now always rendered
by default if you need the two dot one
behavior where the doctype comes from
the pages themselves you can declare
this which says if you're processing
facelet pages as opposed to JSP pages
and you have this X HTML file extension
process it as XHTML and it will let the
whatever you declare as the doctype in
those pages continue to pass through
okay so with passed through attributes
here the attributes are basically well
there's two approaches to html5 markup
in jsf the first is you use regular jsf
components you know h kool &amp;amp; f call and
c colon P colon whatever and if you need
to pass additional attributes so you're
using you know jQuery UI which needs
data dash attributes for example you can
instrument your existing jsf components
with these attributes using the
pass-through attribute feature okay so
there's a couple different approaches to
this the first is the namespace approach
so if you declare an xml namespace with
this URL here then any attribute you
place on any jsf component tagged with
that namespace prefix will just be
passed through to the rendered markup
anything you like there the other
approach that's a little more
old-fashioned style is we have an F
colon tag that lets you define a pass
through attribute so here we have an
input text with a single pass through
attribute on it and so now we're going
to have this rendered markup input type
it goes text and then placeholder equals
enter text you can put multiple of these
inside any component or there is a pass
through attributes which takes a map and
every key value pair in that map will be
rendered as a pass through attribute
it really means that the name of the
past two active food should be a true
should it be correct good good I that's
a bug mm-hmm yep the other the other way
to do it is to flip it around here and
this is passed through elements and this
is the feature that I always tell people
is the best part of wicket comes to jsf
and people always would say to me about
wicked oh it's great because you don't
have to have any of these funny tags
right well that's one thing the other
thing is when we created jsf the whole
value proposition we were trying to
bring was let someone else worry about
all that complicated HTML CSS JavaScript
you know you want to give your page
designers more richness of expression so
they can have a you know some kind of
component that is an accordion component
or a switch list component or all these
kinds of UI components that didn't exist
in HTML let's make a custom tag that
does that and when jsf first came out
that was a good story because the world
of the web designer and the world of the
you know software developer were kind of
two separate worlds there were these
designer people and they know how to do
HTML and you know the software
developers they just want to do
components and let someone else worry
about the style well as things have
progressed web development skills have
become a lot more widespread so the set
of people that are you know would be
offended if you take away from them the
power to control all of the pixels and
all of the layout and things those
numbers of the numbers of those folks
has grown and we would like to make it
so they can use to SF too so with this
feature you can really just write plain
HTML and then sprinkle some attributes
in there and we have defined a way for
the attributes that your sprinkle again
to produce mappings that turn into HTML
components on the server side but the
rendering of that stuff is exactly how
you specify in the markup and this is
how it looks
maybe there's a new name space we added
xmlns JCP org slash jsf and you might
wonder okay what is this xmlns JCP or
whatever happened to java dot suncom
well that's still there and you know all
of the old ones all of the tag libraries
that existed before jsf 2.2 you can
still use Java suncom of course it will
work you don't have to go rewrite all of
your pages and put xmlns the JCP org
everywhere no you could use Java suncom
for all these things that i'm showing
xmlns does acp org except for the new
things right like for example this
feature so this is a brand new feature
and the other stuff I've shown that's
brand new features we didn't go and
define backwards ones for that or did we
deserve then we have can you just use
java dot suncom everywhere even for the
new stuff or did we say only the for the
new stuff you have to use the new Marco
but we said just up in the new stuff you
have to use them in one okay all right
so yeah for the new features we didn't
like backwards do it so the safest thing
then would just be to use all xmlns JCP
org but it'll work in most cases both
ways alright so here's what this looks
like when we define this namespace than
any piece of markup on this page that
has one or more attributes that are
coming from this namespace will be
considered for the mapping thing that
I'm going to describe next so the nice
thing about this of course and this is
what people say with wicket is the
ability to do a file call and URL and
see something that looks sensible so
that's nice the other thing that people
say about wicket that they like is you
know you have to you can just write the
markup and then of course on the Java
side and what you have to define the
component tree as well that piece you
don't have to do with JSF so that map
managing the two different trees and the
mapping between the two of them that you
had to do with wicket you don't have to
do that with JSF okay
so this is what I get me this is what I
mean when I talk about the the mapping
business when we did jsf Wando we took
HTML 401 and said let's make tag
libraries for all of those things and I
mean let's make corresponding elements
components for all of those things we
once we did that we were able to now
define a mapping so that when you have
most of the HTML that's there it'll
automatically get mapped to the
corresponding HTML basic syntax and if a
mapping is not found then we just let
the markup pass through unaltered so
this is how we're able to use new
components like progress and fields that
I think and all the other new ones they
can pass through these are so many
examples for mapping there so for all of
the things that are anchors you know we
will turn it into the right thing on the
server side either a command link or an
output link or a jsf link depending on
if this attribute is present and the
complete list of mappings of the
elements and component tags is described
in the VDL doc for tag decorator or the
yeah that's right I think this is a
there should be a slash there isn't
there the class is tag decorator the
package name is Java X faces view
facelets tag decorators so there should
be a slash there but basically go to the
Javadoc for jsf and look for the tag
decorator class and that's where this
mapping table is defined one of the all
right so the real power here of this is
you can mix and match this HTML native
approach with other nested tags so you
could have you know an input type equals
text or an input type equals tell or
color picker all these other attribute
types that you have in html5 and you can
a Jack safai them you can add listeners
to them all of the things that you
normally do value change listeners and
converters and all the things you would
normally do with JSF will still work
you okay and so this will describe what
happens if there is no existing mapping
I just basically it says let the
rendering happen by the markup and the
decoding will happen by a very generic
kind of render called a panel actually
javax faces panel render type javac
space is passed through element well
that works also so you can all of the
client behaviors that's what Ajax for
example is one of them are other things
you want to define custom client
behaviors that still works with this
okay so now we have Rogers going to show
us a demo of this feature in action
right a little bit of a disclaimer here
I this demo was used in my boss
yesterday and I wasn't specifically
showing pass through but it's it's an
html5 page used a JSF page but in the
page I'm not currently using any pastor
lancer attributes but you could easily
do that so but nevertheless I'll see if
we could run through this demo here it's
basically it shows you that yet
continues to show that JavaScript can be
used very easily with JSF to really
enhance your jsf pages for richness
okay so so this is using some html5
features canvas for example choosing
input type color and basically what
we're going to show and it's also using
web socket in the background java ee 7
web socket so what we're going to show
you is manipulating pixels on this
matrix and if the network gods are with
us and this rubber band holds up
hopefully we'll be able to see this is
wireless by the way the only reason i
have a wire connected to this robot is
for power because the battery was
running low so this is all over Wi-Fi
I've got my role Wi-Fi hotspot here so
you can see I click click a matrix here
click a pixel here and I don't know if
you guys can see that as I I'll hold it
up for you license ah it's kind of
fragile all right I just know not that I
don't trust you no no I understand i see
that i see the rubber band there right
right so you can see where i can change
that I've got some various patterns here
that's cool so you can see I'm it's
basically using web socket so when I
basically I I keep track of the pixels
on the matrix here on the canvas that is
I i have an onclick handler registered
with the canvas as i click that the
fires off WebSocket send some data some
coordinates and stuff to the matrix it's
not exactly i'll explain the
architecture a little bit when we just
run through this demo I can change the
color I have an input type equal color
here I can basically scroll around so if
I make this red and I click column
cool I get the columns I can change the
color again to something else green
diagonal so they're just various various
patterns here I can reset if I don't
want to do any trails I can do a row
here so that's that's how that works
nice thing about the nice thing about
this is i also have this from my ipad
guys probably can't see this but I'll
control this from my ipad so you
basically see it updated on the matrix
on the UI and the ipad oh cool so i can
see you can see where i I'm controlling
it from the ipad here now one of the
things i'm also using in this and we'll
look at code real quick is how many
people have actually done html5 how many
people are familiar with moderniser so
moderniser is a nice little tool that
you can use with html5 to
programmatically detect if a feature is
available it's not available then you
can fall back and do something else so
what i'm doing i'm using modernizer in
the code actually for the input I pickle
color so input type equal color is
available on google chrome for example
but it is not available on the iPad and
some mobile devices so I have a
modernizer check in there which
basically checks to see if input type
cool color is available if it's not I
remove that input type pickle color from
the from a DOM and actually i'm using a
third-party library in here called GS
color so you can see that it's some
little different on the iPad if I click
on that it's got out you know it's um
it's a different color control so when
you're doing any any type of html5
programming you want to make sure that
you can make sure that your markup runs
on very
devices and browsers and so that's
that's one of the differences there
about responsibility with in a world
where you have tagged lives the problem
of supporting all the different browsers
that's four stood off onto the poor sod
who has to develop the tagline if you're
going to take responsibility of writing
the HTML yourself then you're taking on
yourself all of that different kind of
browser support so all right so look at
some code real quick there's a lot of
code to this demo but let me explain how
this works the architecture it's really
it's using java ee 7 technologies like i
said websockets to me when you have
robot modules some of them this did this
particular one runs a see sketch on here
so it's written and see a small c module
so what i needed to do was I have when I
you when the on click handlers is
activated it sends a WebSocket request
over to a WebSocket endpoint that i have
written in java and that WebSocket
endpoint will open up a java socket
connection to this c module send the
data across and the C module basically
updates the pixel display feedback comes
back and then the UI gets updated
accordingly so that's pretty much the
pieces to this this architecture but
keep in mind also that there are you can
run tiny web servers on some of these
modules as well so you probably could do
a WebSocket connection directly to the
module if you want to going to do it
that way so this is the H so this is the
main markup you see the HTML doctype had
talked about various namespaces here so
what i've done here is i've written how
many people have used composite
components so what i've done is i've
written a little WebSocket composite
component in the h5 namespace you can
see that it accepts a channel which is
the actual URL and this particular
composite component also allows you to
specify a handler so the handler
basically handles information coming
back over
WebSocket connection and the matrix
handler is the thing that updates the UI
so you can see feel sets here for the
various controls no as I said before you
can use the html5 friendly markup
feature in JSF 22 dot to very easily
with this if if you have a need to also
have components on the server as well
that's that's the event of it if the
HTML friendly markup feature it allows
you to and you know i personally i
prefer the GSF colon thing because it
leaves the mark-up as close to vanilla
html5 as possible and but at the same
time it will also allow you to have a
component on the server the standard jsf
component way so it kind of gives you
the best of both worlds let's see what
else here I'll show you the WebSocket
component here real quick so this again
is just a WebSocket jsf component it's
basically calling a javascript function
in it will so basically in it the web
initialize the WebSocket channel
and this really is just some JavaScript
how many people have used WebSocket
before right so this is just pretty
standard stuff as far as a JavaScript
API for WebSocket you define or not open
something to process your messages when
the stuff comes back again to handle the
channel initialization and so forth so
this is all nicely packaged in a nice
little composite component you basically
just drop it in a page and you've got
WebSocket functionality in your page and
let's see I think that's all I want to
show from the web side let me see if I
can
so this is the this is the matrix class
and you'd see where I have various
functions on here let me go back to this
is basically just the socket handler
class this is the one it's just a Java
class that uses regular Java io which
will which allows you to connect to and
pass information to the sea module on
the robot for the matrix if anybody's
done any socket programming there's
really not much there so I guess that's
all i wanted to show for this demo any
questions the top page oops
okay right there yeah but it's not all
the old ones week if you want to just
use xmlns JCP org everywhere you can now
in this page i'm using java dot subcom
for the h5 composite component namespace
okay i can have to though you don't have
to right right you can that works with
say either one right the new GSF okay
definition for that namespace would that
replace both the h and the f no it's
only for when you're doing passed
through stuff or if you're using regular
jsf components right no no could use
doesn't actually at all well that's a
isn't it that's a namespace for the
composite component I've written for
their web socket composite component
yeah so the convention for composite
components was anything that starts with
java dot suncom / jsf / composite is a
shorthand for creating your own
composite component libraries and you
know xmlns that JCP org will work here
too so you just called it h5 because
that's his composite component library
for this demo all right
okay I misplaced the clicker so I'm
going to do it this way oh here it is
okay well actually we're coming to the
end that was the the demo there was the
last thing the spec is available here at
JCP org I don't remember that you are
all I just always go to gcp org and type
in the number and press the button so
the number is 3 44 in this case an
implementation is on jsf java.net and
that's it we have 10 minutes left for
questions so it was right here in the
front and I'll repeat the questions for
the video great question the question is
is this only e7 and the answer is very
enthusiastic no it is not only seven
everything or showing here will work on
you could just take the jar and drop it
into a jobbing e6 container jsf has
always had a tradition of lagging one
version behind the EE version that were
embedded in so when java e5 came out
even though we were introducing jsf one
to the older one would still be
supportive when java ee 6 was coming out
we introduced jsf 20 but you could run
that on a glassfish v4 or v2 container
that is the reason is we wanted to make
the maximum adoption possible right so
we know that basically a lot of people
use tomcat to run this thing who is
using tomcat to run their jsf apps all
right a fair number of people and it
takes a while for tomcat to come up to
the next version of servlet and JSP that
goes along with the java ee version so
we've been one version behind and that
still continues to be true the only
thing you need to be aware of is if
you'd like to take advantage of new
features in EE 7 that are 7 native such
as l three point 0 or some of the
features in CDI 1.1 such as
let's see the ability to inject CDI
injection into bean validator constraint
implementations that's a new feature in
CDI one dot one and bean validation one
dot one so those things are EE 7 native
and those won't work but you can take
the JSF implementation and drop it into
any 6 compliant container and it will
work just fine the important thing is we
produce builds we compile them with JK 6
so you won't run into any you know
unsupported version error 51 mess okay
let's a question in the back localizable
well there isn't a separate their
localizable using the existing
localization mechanism so you can put
properties files in the jar just like
you normally would and that once you put
a resource library contract in a jar you
can put a face of config in there that
declares the supported locales and that
sort of thing so yes there localizable
is just as much as anything else is in
jsf which brings up a point about
composite components composite
components had an extra little piece of
localizable goodness where each
individual component can have its own
set of properties that we're localizable
but there isn't anything like that in
this feature in front now you're using
contracts instead of resources what is
the page look like to be able to
identify where your image
mm-hmm so the question was now that
we're using contracts instead of
resources what does the page look like
to be able to reference your style
sheets and images and such well it's not
that we're using contracts instead of
resources we're using them in addition
to and even though because the resources
that stuff still works just fine like it
normally would just an additional
capability when you can put templates
into the mix as well and so you can
refer to them using the H colon you know
output style sheet output image just
using the same thing syntax as you would
before okay yes you do yeah the question
was do you have both Resources directory
in a contracts directory yes the
resource directory is continues to be
valid okay no definitely not replacing
and it's supplementing it any other
questions right there in the middle
well the question was if you say f colon
view stateless is true does that allow
you to use avoid the view expired
exception well the answer is yes it
would because the view expired exception
is thrown when the system tries to
restore the state and it can't find it
so if when the system sees that it's
transient it knows hey okay there is no
state to restore I'm not even going to
try so yes it would more questions Oh
hold on in the back what do we support
regarding CDI one dot one okay that's a
very good point one of the things that
we have with CDI 1.1 is the initializer
and while it's a called there are two
events that CD I won that one added that
let you track the creation and
destruction of custom scopes using a CDI
the event the CDI event system I think
it's called initialized and destroyed
but there's a basically CGI events so in
jsf to dot too we added two new scopes
that are CDI custom scopes flow scoped
and we also added view scoped now we had
view scoped already in jsf 20 but it was
the old-fashioned jsf managed beans view
scoped now we had a CDI version because
in the next version of jsf we're going
to be deprecating the job x faces bean
package because CDI is the recommended
way of going forward now everyone that's
using java x faces bean is anyone using
java x faces bean nails a big fan yeah I
like it too you know the nice thing
about it is it's it's simpler than CDI
there's no proxying you know there's if
you really want to know that the beam
that you get is really just the same
beam that you created someone else just
called new for you instead of with CDI
it's this proxy thing and there's all
this other stuff happening you know
that's one of the differentiators
between old fashioned beans and jsf
beans but we
did add these new scopes for CDI scopes
and if you do that one of the features
in CDI one that one is this initialized
and destroyed and that will work for
those new scopes I mean all the other CD
I won that one features will just work
if you're in a CD I won that one
container the risley isn't too much
that's specific to one not one I guess
the big takeaway for CDI regarding jsf
is that flows is entirely dependent on
CD I so if you would like to use flows
outside of CDI then you won't work
because it's the flow scoped is there I
mean I guess you could use it if you
don't want to use flow scope because we
did add a new implicit object so you
know you know how you have an el
expression that can have requests
session or application scope there's now
a flow scoped but i think that itself
might be implemented as a CDI thing so
generally the story is if you're using
flows you have to have CDI enabled one
of anyone else I've gotten I want to
make sure everyone who wants to ask a
question has a chance to do so and
people that have already asked them
anyone else who hasn't asked one yet
have a question to answer okay
oh okay well Neal setting up our talk
tomorrow at eight thirty i mentioned
what do you do if you have regarding
html5 friendly markup if you have a tag
that isn't really providing a mapping
and what you need to do is very complex
you know even with regarding html5 you
can produce a custom tag decorator
that's something that has been in
facelets since the beginning and you can
still do that of course so custom tag
decorators will still work even outside
of this html5 friendly feature I think
we have time for one more question
anyone else right
okay the question was I made the
statement that flow scoped was dependent
on CDI and can we is there something
else like Apache Delta spike or
something my answer there is I think
open web beans would probably do it for
you so you need to have a CDI
implementation of some kind so Apache
Tommy is a very good project and it's a
great answer for those that are using
tomcat and they want to take advantage
of the larger features that EE offers so
but still not go full into the full
container realm of weblogic or websphere
or glass fish or something like that
they still want to stay in the Apache
world patchy Tommy lets you do that
because it basically is a bundling of
all the my faces open web beans and tom
cat and a few other things to bring all
the specs into implementation for them
well for glassfish 3 we have a CDI 10
implementation that's weld so that will
work just fine absolutely it works of
wonder though yeah I'm sorry I didn't
make that more clear the Delta between
CVI 10 and 11 is rather small so most of
what we as far as like you know being
ticket features when you compared to
like 0 and 10 you know of CDI so yes
everything everything entirely will work
on CD 01 dodo no problem at all even the
flow of course yeah all flows will work
with CD I want oh no question about that
no it's it's the jsf spec owns the
Declaration of flow scoped and also the
CD I've you scoped so those are defined
inside our world okay right okay now
they're definitely java x faces Flo Flo
scoped and java X faces view view scoped
all right thank you very much for your
time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>