<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Emerging Languages Bowl: The Big League Challenge | Coder Coacher - Coaching Coders</title><meta content="The Emerging Languages Bowl: The Big League Challenge - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Emerging Languages Bowl: The Big League Challenge</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9YLmPHEzGHI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to the second edition of the
emerging languages script bolt I see a
few faces from the previous script both
the big leagues these are the early
leagues
hopefully at one time in the future very
close we will see one of these languages
happening in the big leagues for today
well my name is Andrew Solomon I am a
Java champion I'm a polygon programmer
proponent I really like to use different
languages but I am NOT the important
guide these are the important people
that you should pay attention to we have
four languages for you today and the
four those are new to the script board
rules each one of them will have five
minutes to present the basics of the
language of what the what are the feel
of the language and on the second round
they will have six minutes to showcase
what is really interesting and what is
appealing for this language and then we
open up for questions and after that we
will decide the winner so you guys will
help us decide the winner so without any
further ado please gentlemen introduce
yourselves starting with me
my name is you said huh yeah okay
my name is Turk Onika work for canoe in
Basel Switzerland representing Vega
today and as of today I am called the
officially most distinguished ambassador
for the one and only pure functional not
strict frontal programming language for
the JVM thank you
I'm Charles Nutter I have worked on
JRuby for many years I created the
language I'm talking about today called
Mira and I do lots of other little
projects around the jvm world
I'm Stephanie brother worked for Red Hat
and I work on the salon project which
I'll be showing later on hi my name is
Hadi and I work at JetBrains and I'm
presenting Kotlin okay all right so now
we begin Dirk you have five minutes to
show Kate frigging take it away so will
you stop yeah right now all right
okay thank you you who in the room knows
Hesco the language Hesco a few of you
okay
Vega is it has come for the JVM that's
it and all the people that know Haskell
know that this is thank you for the
applause this is it this is what we need
and therefore frigate is different from
all the other languages that we see on
the JVM it is very different you will
just not believe how different that is
since we have pure functions I claim it
is the only language on the JVM which
has pure functions what does it mean to
have pure functions if you can say that
the Java code that you see here yeah and
you only see the type signature saying
there's a fool that takes a pair of T
and U and returns a tee what could
possibly happen in that code and then
there's a figure function it takes an
alpha and a pair of alpha and better
returns now far now forget about the
Greek letters you can use Latin letters
as well
so what could possibly happen in the
Java space everything could happen
everything imaginable Under the Sun
could happen in that code right it is
most likely that it returns the first
energy of the pair that doesn't print
anything to the system out does it to
any lock statements does it change the
state of a doesn't return a null is it
maybe going to the database is it
launching the missiles and starving for
vote law we have no idea this is the
difference to purely functional language
we're in the purely functional language
either a is returned and if it would do
anything else it would appear in the
types you'll see no types at all at this
moment that it is strongly typed and the
type system so strict that you cannot
possibly escape it and
there's no possibility that that there
is a print line' in this code and since
you have these guarantees you can you
can have this kind of function for
example in a software transactional
memory and reuse it as often as you want
because there's no possible side-effects
you can cache results because given the
same arguments it will always give you
the same answer it has no state if it
would have stayed the state would have
been needed to be declared here so you
can easily cache the cache the result
value that's are you saying that nobody
in the right line we use Frigga to
implement them nuclear missiles because
you can only do it in general the
question was is it impossible after
every frame the question would it be
impossible to write failure to start
third world war I hope so you have to
declare your side effects and that
declaration circulates up the call stack
in the very same way analogous to how
its checked exceptions are handled in
Java
that's it that is the innominate way I'm
Tom thanks you're done okay so you
missed minute-and-a-half
all right does that mean I get six and a
half minutes
III grant mine too okay okay okay so so
Mira started out as a way of building
ideally parts of JRuby which is written
in Java in a language that would be more
approachable for rubyists and it kind of
evolved into essentially a ruby syntax
for writing Java code Java classes I
have to say we have the coolest logo
because of this that took almost a whole
day Illumina
so let me talk a little about Ruby ruby
is a clean expressive very beautiful and
compact language dynamically typed
language but it's often slower than C or
Java or any other statically typed
languages that you are used to on the
other side we have Java which tends to
be kind of noisy inelegant a lot of
ceremony very verbose but it has the the
benefits and sometimes the detriments of
static typing but it also generally is
much faster than the dynamically typed
languages
just because it's an easier life easier
sort of thing to optimize so the goal
with Miro was to take the surface level
features the apparent features from Ruby
some of the syntax the support for
closures the support for a rich set of
literal syntaxes arrays and hashes and
whatnot but compile it down basically to
just Java class files so that rather
than having all of the Ruby overhead and
the Ruby runtime to go with it
you put in what looks like Ruby code and
you get Java class files out the back so
the the general premise is what if we
could take this sort of contrived Java
class here and basically write it using
the Ruby syntax without all of the extra
ceremony and that's essentially what
mirror gives you in this case we only
have to declare the one parameter here
as being an int the field a indicated by
the @ sigil there then gets inferred and
the return types of these methods
everything else is also inferred keeps
things very lightweight and very clean
the syntax similar to Scala if you're
familiar with that I'd say that mirror
is kind of somewhere between Scala
groovy and Ruby as far as the syntactic
features that it includes lots of
features that we pulled in from Ruby
still more that we can add other things
that we're working on like extension
methods considering type conversions
pattern matching and whatnot but for the
most part currently shooting for like a
Java a 1.5 level of language features
and then we'll continue to move on Java
1.5 with closures perhaps probably the
killer feature for for Mura the
languages that your source files your
dot mera files compile to
classes and that's all you ship there's
no runtime library of any kind required
for all of these features even in the
smallest cases with the other languages
you've got a megabyte or two of jar file
that you have to ship that can be a
limitation that can make users and other
developers unhappy because they've got
more libraries to worry about and if
you're doing small profile applications
embedded applications Android apps not
having a runtime is a huge benefit a
simple Android written in mirror using
closures and all the type inference
features that we have all of the
apparent features from Ruby still
compiles down to just a few class files
15 kilobytes and it runs great some more
quick examples here so this is the Ruby
code that you would have to print out
hello world this is exactly the same
thing in meera puts is a sort of a
top-level keyword that allows you to do
essentially system.out.print line
without all of the extra overhead here's
a ruby code for a simple fibonacci
algorithm all that changes here is that
we had the types for the the incoming
value and because it's recursive the
return value as well if this was not
recursive and it could be inferred
completely the return value would also
be inferred from the value in the the
body of the method an example of
optional arguments here we have a and B
getting assigned one and two behind the
scenes this compiles down to exactly
what you'd write in Java it changed on
you few overloads of these methods
together adds on the additional missing
arguments and then finally calls the
main body here also you can see that the
typical operator overloading that you
would expect in Ruby also works here you
can define plus minus etc on types as
the same ways that you would with Ruby
closures again here we have a list we're
doing in each over that and printing out
every element again no requirement for a
runtime library at all and it all works
pretty much like you would expect in
Ruby a closure passed into thread new
turns into runnable automatically again
still no runtime library required and
the magic just happens in the class
files we generate macros are also
supported I'll talk a little bit more
about this in the second section since
three two one done down exactly okay
good so now we go to salon right so what
is salon it's a new programming language
that is meant to be powerful readable
and predictable it's meant to be a
language with the the good stuff that we
have from Java which is readability and
predictability be able to learn it fast
and to maintain it in in teams and it's
more than just a language it's a whole
platform with tooling and modularity
built into the language so last year we
released version 100 which was the first
production ready release of salon and
since then we've been busy working on
one not one which is to be released this
week of course the you know was supposed
to be release at the air beginning of
the week that it will end up being
released at the end of this week notable
features are that it compiles the
language to the JVM so you can run
everything on the JVM you can run
everything exactly the same on the
JavaScript virtual machine as well so it
allows you to run to write in the same
language on the client and on the server
you can run on the browser on nodejs or
on the JVM that was actually my demo
from last year here we have a cross
platform SDK included which is sort of a
prerequisite because you could use you
can use the JDK as well but you know if
you use this alone SDK then you can use
the same as DK on the client and on
JavaScript and on the JVM and it's it's
not just the language it's really
everything we ship with everything to
allow me to to make your life easier so
a great command line that is based on
grid with plugins as well a great ide
that is also great and works in in
eclipse and is as full featured as as
the java ID for for eclipse and the
great module repository as well which
allows you to polish your modules online
and document them online and everything
so some people may ask okay so we just
got Java 8 which has a bunch of new
features like closures and mixing so why
would we need another jvm language so in
that comparison then salon is a bit like
Java 8 except on top of that well you
know it has its it's inspired by the
same principle which is it's easy to
learn has a clear syntax and has
generates annotations it also has
lambdas and makes sense but it's it's a
bit more than that on top of what you
get with Java 8
we also have modularity you know we've
been we I really hope that we will get
modules in the JDK in in Java one day
and any few lucky will get in Java 9 but
it was promised with as early as Java 7
so you know and I'll just wait to see it
happen on top of that it also works on
the JavaScript VM which is pretty nice
so you can work you can work on the on
the browser on the server we have great
type inference so very different from
the type inference in Java where we
really specify LS types refight generics
as well which is something that we've
been missing for a long time from Java
real function types which I will talk
about later on more powerful type system
defaulted parameters a great meta model
which allows you to browse through all
the modules currently defined which
packages they have which classes and
annotated with what etc we have growing
ecosystem as well lots of modules in the
SDK promise module vertex integrate
great vertex integration where you can
write your verticals in in salon have a
build system which also allows you to
reuse your language not only on the
browser on the server but also during
the build guide on web framework which
has been started which looks very
promising one Hana and two IDs well I'm
almost done
the roadmap as I said we've released one
other last year this week we're really
seeing a 1.1 which has over a thousand
bug fixes and performance improvement as
far as the language features it there
are very few language changes in this in
this version small improvements there
the big language features that are going
to be added are going to be added
insulin 1.2 next year including
sterilization which should actually come
in in in between 1.1 and 1 or 2 which
will allow you to send objects from
JavaScript p.m. to Java VM and then
you're done okay thank you so now we
switch to Kathleen there you go I I
don't actually have any slides sorry is
this being recorded yes it is I've got
to be on the record okay so yeah I'm
representing Carlin Carlin was born out
of need which is kind of aligned with
very much a lot of the things that were
born developed by gerunds we've been
developing a IntelliJ for coming up to
15 years next year and along with
IntelliJ and most of the other tools
that we develop most of them are done on
JVM apart from a bunch of dartnet tools
and during this time we've as you know
if you if you know a little bit about us
we've developed IDs for many languages
right language comes out we pretty much
get the ID support for it but during
this time we've stuck to Java and so
Carlin was born out of need it was born
out of finding a language that is
suitable for us that serves a series of
purposes and the main goal of Kotlin was
and still is for japanese ourselves to
use it but like anybody in these you
know nowadays it would be crazy to
release a language that's not open
source of course unless you're Apple or
Microsoft so we made it open source and
there's been an uptake in the community
and people are liking
people are starting to use it so Colin's
main goals are for it to be as fast as
Java more concise than Java which isn't
saying much I mean it's not a setting
the bar high they're safe so we have
null safety in Kotlin expressive it it's
we have the goal of trying to make sure
that the code is more about expressing
intent as opposed to expressing
implementation details and considering
that we have about 15 years of code base
in Java one of the top priorities is and
always will remain to be interoperable
with existing Java code so you can talk
to Java from Kotlin and you can talk to
Cottenham from java in addition to the
JVM Kotlin also targets JavaScript why
because everyone does it so if we wanted
to be and with the hipsters we had to do
it as well
that does give you a series of benefits
such as being able to share the exact
same code on the on the server and on
the client if you're doing web
development and our roadmap is that
we're hoping to release 1.0 sometime
spring is next year that's the kind of
the aim if we do it great if we don't
then I lied but we're now at approaching
milestone 9 which has some important
changes and we already have a lot of
companies using it that we are aware of
that are using it in production we're
using an in production at JetBrains
we've got a couple of internal projects
running Karl and also the account system
that you all use is running Kotlin and
our tools are starting to use it as well
so IntelliJ is already adopting in with
some tests and plugins done no more I'm
done oh you're done ok so we have two
contestants that decide to burn off
close to two minutes each so we have new
extra time what can you tell us each one
of you
what is the current version of each
language and how many years of how how
long have this language have been since
their inception frig is about three
years now
I'd say inception any version numbers Oh
where's numbers three three duck and
then very low number at the the last
tends to PI uh yes tends to PI I guess
could be and that was just you know this
may or Marsh if I'm listing okay mmm not
quite sure when I started Mira but it's
probably been about five years of
on-and-off development I haven't been
involved with it recently other folks
that picked up the the mantle and
continued to carry it forward the
current version is zero one three which
is a little misleading it's much more
functional than it would seem for a 0.1
something looking for you know Java 1/5
parity features to get her actual 100
out but it's coming along and there are
folks using it for production
applications right now I think I already
answered that during my talk but yeah
it's been it's been three years since
inception essentially and we're at
version 1.1 at the end of this week and
you know we see more and more adoption
in the online in the discussions and so
it's looking good alright so we're at
milestone 8 m8 and we're about to
release milestone 9 but seeing the news
this week with Microsoft and Windows
going from 9 8 to 10 we're thinking
about also just naming it milestone 10
so that's
on the table so how long have you been
how long it's been about just on the
four years four years all right
okay so now we go to the second round so
you have had already a slight feeling
for each language on the second round
this gentleman will try to showcase
their language of the best out of the
possibilities so that at the end we
choose the winner so we begin now with
Fraga six minutes so the first important
thing is that you have Haskell on the
JVM so the s Keller's can can now employ
their knowledge about Haskell on the JVM
for example writing something like my
times MN equals M times n and once that
have they'll have Haskell NV like most
of us have for such a nice and clean
language but do not know had no no no
actual way of doing this on the JVM
before they now can and they can learn
Haskell if you're a Java developer so
this is what you write if you want you
can give you type yourself that helps
depend for computation for static for
interoperability with java you compile
that and by the way this is IntelliJ
IDEA
which does not have a native Frigga or
it's called Haskell it's it's got
Haskell and that's what I'm using as you
see now what I thought I would
appreciate and there's an open item
please vote for it for Vegas support in
in do a big idea because it keeps that
it know now here I'm in in groovy or
Java that makes no difference and I'd
like to call that service that's in the
class freaka service ah look I get it I
get the import and there's my times
method you wouldn't say so three come
3.4 and then
that'll run okay three times for 15 use
Frager for financial company looks like
my you get some extra integers that's a
bit good anyway it is most likely I
guess it didn't it didn't Kampala make
them some some other values before
anyway the the most important thing is
pure functional compilations and having
pure function in the first place but
then the type system is a hindley-milner
type system and that means you get
really very powerful type and friends
far beyond what you can expect from
other languages far beyond and here is
one of the typical effects of this you
can have methods like the clean methods
here the YouTube newest ones that
declare no other context it's called
Mona fat anyway its context so you can
be sure that there is no database access
no I own whatever in these in these
functions and you can reason about these
functions in a totally different way and
if they want to launch the missiles here
they have to declare it like the mutable
one that we have here and then every
caller also have to declare this you
have to be in the very in the
appropriate context in order to call
that mutable function that's it so it
stacks up and it keeps the mess
manageable
okay these are monads be brave
the history is we have some history of
languages that try to introduce
something new and also Java so Java said
Java promise was no more pointers do you
remember the times but we do have no
pointer exception how does that come so
frame is different and Frigga certainly
has a number of differences here that I
listed there is no state anymore unless
declared explicitly right and since we
have no state we also have no statements
on language without statements that
Calif crazy yes
there's only expressions you can see the
whole main method in your java public
static void main having a consisting of
only one big expression and it's only
billable syntax sugar to put this into
separate lines
there's no interfaces there's something
called type classes is which is much
more powerful than interfaces may be
something but more like trades you can
compared to trades no more classes and
objects but some data types there is no
more inheritance but polymorphism that
is interesting you can have polymorphism
without inheritance and no more live
references there is no null in the game
that the maybe monad Frankston in
comparison this is this is comparison
made by mr. Simon Peyton Jones and who
is the brain behind Haskell I would say
nowadays you can divide the language
landscape into languages that they're
useful they come from how do I run a
command and then the abstract over this
or you can come from the logical side
and say oh this is my logic how they
make it run on a machine and Java in
groovy they are very practical and
useful and I'd say most languages are I
wouldn't want to offend anybody for
placing him in a certain area
anyway the Frigga is much closer to
Haskell in that regard since we are on
the JV I mean we have light binding
there's not as many currents
as Haskell has that we're close by
functional programming matters it is all
about modularity we have to you have to
dictate your you have to collective
functions and you can combine them at
your will and if you would like to to
join the effort here are the coordinates
and this has the the person after which
this is named it was great guy and in
the end please fill the feedback forms
yes and we're done so that was Frigg a
now we go with Mira
alright I thought I'd run through a
couple more examples of mirror just
because I think I feel like Mira code
kind of sells itself it makes it really
obvious how much nicer it would be to
write Java this way rather than to write
it and in the Java we know this is
actually a fractal generator at the
console generates a Mandelbrot set but
this this code which is basically ripped
out of a ruby benchmark for running this
this Mandelbrot generator is exactly the
same in Mira this is the same file
there's no changes required at all it
still has all of the the conciseness and
the cleanness and the beauty of ruby but
it compiles down to a almost identically
what it would be if you wrote the longer
uglier java version of this in fact the
only thing that's different in this
script here is that in our iterate
method for the main body of the fractal
we declare what the argument types are
to doubles that we're passing in and the
rest is all identical to what you would
write in Ruby the rest is all inferred
and it runs essentially as fast as the
same Java code because it is just the
same Java code with a slightly different
syntax that looks a little more Ruby
like another simple class showed one in
the the slides here we have a hollow
field that's getting inferred as a
string we've got a holo method that has
a string being passed in very simple
very similar to the way you would do it
in Ruby but it compiles down to exactly
what you would expect it to if it was
written in Java code mentioned macros
briefly here's a very simple macro for
doing square root without calling
through the math
class in the JVM this actually gets
expanded in place all types are
propagated appropriately so if you had
two versions of this macro in two
different places with different types
they'd expand in place those types would
propagate through and you'd get the
normal compile errors saying this macro
expanded there's some type issue once it
actually expanded at that point macros
also can take a block of code which will
then be used to run this logic inline
and expand it at the place where you
invoke the macro here we're taking in
some value and all that really matters
about this value is that you can call
two char array on it that could be a
string it could be a char sequence it
could be some other type when it expands
in place it figures out what the actual
type of the object is and the rest of
the logic works just as you would expect
sort of like a duck typing but in a
macro form similar to the way Ruby would
do it a quick little swing example here
again here we're declaring basically no
types this is all just run as a script
this is the identical to what you would
write if you were going to do the same
thing in Ruby certainly much smaller and
much cleaner than what you would write
in Java now back to one of the killer
features here I can I can run this of
course as a normal script on the command
line and it will pop up my little swing
window and it'll do what it's supposed
to do the magic however and and the
thing that I wish there were more
languages doing this on the JVM is that
if I compile this mirror see and compile
the swing example down what I get is
three class files and these are all you
would ship with your with your
application you stick these in a jar
file with no other dependencies and you
have your entire app with all of those
features again no runtime library you
can basically swap Java C for mirror C
and start using this language no other
requirements for you on the community
side very recently I discovered that
there is now a beginning of a NetBeans
module so that you can have mirror
support I was using that to show all
these examples currently it's just a
syntax highlighting but very soon it'll
be it won't be very difficult to add in
the
additional code completion and whatnot
because it is a statically typed
language this can all be inferred very
well other projects out there pinda is a
framework for generating a quick mirror
of wrapper application for an android
app again very small applications it'll
generate the rough structure for you
give you a few simple command-line tools
to build the application when you write
your nice clean mirror code you have
your tiny little Android app with no
other dependencies required except what
you choose to put into the application
dubious a similar little framework for
doing Google App Engine applications
again no other notion acquirements
except what you have actually add and
you can deploy it on on Google App
Engine tiny little apps and it runs
great the last thing I wanted to show in
the slides here our last couple things
this is a not in the current version of
mera but I'd still like to put it back
the possibility of having a dynamic type
similar to C sharp so that if you want
to actually fall back on dynamic
dispatch really true duck typing just
declare it as dynamic and then again
without any runtime library it will be
able to do dynamic dispatch based on
standard Java dispatches so any object
that has passed into this as long as it
has a get class method which all objects
do or as long as it has that two char
array method we can do it dynamically
optimizes with invoke dynamic and it all
works just like you would expect so
whenever you got a method that you want
to use across many incompatible types
maybe dynamic is a good way to do it
plugins are out there for building all
this stuff there's mirror plugins to do
the compilation phases there's more and
more community interest in building up
the infrastructure around mirror now I
do have to say it is not Ruby this is
not something you can take rails and
throw it into Mira and it will suddenly
run like it's a java application but it
does feel like ruby and that's the
intent of this to try and keep it as
small and clean as possible with the
apparent features of Ruby I have a
future slide here of future features I'm
happy to say these are all done now we
do have a self-hosted compiler basic
generic support and IDE support is
starting to come along as
so if you want to check this out mera
org it's fun language to play with and
hopefully you'll give it a try
no right thank you very much Charles so
now we go into the next one salon take
it away alright so last year I did at
this ball I did a demo of client and a
server written both in salon one running
on the browser one running on the JVM
and talking to each other over WebSocket
this year I wanted to try something
different and and a colleague of mine
challenged me to say by saying you know
you shouldn't do a demo with a big you
know big shiny things you should
challenge intellectually the people that
you're going to demo so I'm going to if
not challenged intellectually at least
focus on one system one very little
thing in the in salon and try to see why
we came up with with the type system
that we have and how it works so I'm
going to talk more specifically about
closures and how they work in Java eight
and how they work in salon and why they
differ and why the difference matters in
in Java the first thing you know in Java
they added functional interfaces which
are interfaces which have only one
method that is not implemented so you
don't have you don't have support for
optional parameters in Java but let's
pretend that we do and implement it with
the normal pattern which is you have
method overloading with two methods and
one of them is going to chain so I have
a method M here calling the second one
with a default value for the parameter
so you can invoke essentially this
function type with no parameter or one
parameter and then I have other function
types one function which takes an int
and one function type which takes no
argument let's see what I can do this I
have here a method take optional arc
function which takes a function and you
can invoke it invoke the method with
zero parameter or one parameter the
interesting thing here is that if I have
another
arek function that takes an int function
then I cannot pass it this function
because you know it doesn't work like
this in Java in Java you don't really
have function types you have functional
interfaces and at some places the
compiler is going to transform your
lambda your lender code into an instance
of that interface that you're going to
pass but not in every place so for
instance here I have a function which
does accept you know an int parameter
that I cannot pass it to another
function that takes a different type of
interface that would also accept that
parameter it's the same thing it should
be compatible but it doesn't work then
if I want to make it work I have to
declare a new lambda and in this case
that word it works I say okay well I'm
going to pass a function which takes one
INT and calls the function that you know
I wanted to pass in the first place
or you need to use function references
and then you know point to the N
function of the the F type that works so
that's that's a little weird and the
other thing that you know whenever you
declare a lambda and you store it
somewhere you need to tell what the type
of this thing is so you need to say okay
this land I'm going to store it into
something of type function this is where
the magic happens and it's wrapped into
an instance of this function suddenly
this thing a you cannot pass it anymore
to take arc function because it's not of
the right type it can only pass an
implementation of it directly so there
is conversion there is implicit
conversion that happens and only a
certain places and not everywhere now
compare this with Salone which does
support function types and does support
optional parameters here I have a
function with an optional type optional
argument it takes an integer and it has
a default value so you can invoke it
with one parameter or no parameter and
here I have a function
which expects another function as
parameter function which takes an
integer you can invoke it function which
expects another function as parameter
which takes no matter what is the type
of optional art that we've seen here
that has an optional argument and we can
infer it on the left hand side and you
can see that the type inference says
that it's a function which returns
anything which is typified and takes an
integer with any calls here at the end
which means it's optional so this thing
is essentially well typed in Salon you
can pass it to a function which takes an
argument which expects one integer
arguments you can pass it as is you can
directly pass the function you got in
the first place or you can pass a lambda
as well you can also pass it to
something which expects a function which
takes no argument at all and you know it
just works because it's of the right
type if we look into more details what
the type of this thing is because here I
use type inference we have actually the
type that is inferred here a syntactic
sugar anything and then the list of
parameters it is actually you type
callable which has type r meters for the
return type and the list of parameters
as a tuple so f is of the type callable
which takes no arguments but it's also
of the type callable which takes one
integer it's actually proper full type
is something with a union type it's a
callable which accepts no arguments for
one argument of type integer right and
that is pretty much my demo because i
don't have time for the rest so thank
you anyways alright so let's go with the
last one how did so do I get all the
remaining time no you got six minutes
this is this is Java this is a customer
and as you can see that it's a lot of
boilerplate code some people say argue
well I don't care because the the the ID
generates it for me but that's still not
a valid excuse so let me show you a
better version of a customer this is a
another version why is that better yeah
can I make it bigger use the
presentation I'm not I'm not too good at
IntelliJ is that better no right is is
this counting as my time yes okay so
here's my customer right can you see
that okay if not you're gonna have to
move closer right so there's my customer
here's a better version of the customer
anybody tell me why it's a paying
customer and you can see that basically
what I've done is taken all those lines
of code and I've reduced it down to one
okay
so all of that boilerplate code that we
used to write before now it's just a
single line of code now if I want to use
this in Cartland this is like my main
entry point in calling I can just write
val customer we have type inference so I
can just say Val paying customer and
then what I'm passing in that line at
the top here what you're seeing is
basically the primary constructor and
Kotlin so you pass that into the same
line as the decoration of a class so I
can say a B and C okay that's it that's
how I use the customer from Collin okay
there's no new keyword you don't need
that we try and write as little as
possible now one of the things that I've
said is that we try and be as compatible
as possible with Java so this is in the
same project if I go to the main file
which is a Java file makes a match in
the same project I can actually use it
from there as well so I can say paying
customer paying customer equals new
paying customer and passing the values
right and now watch that if I do paying
customer I get to get and the set and
all that okay so I get that
interoperability with Java without
actually having to declare those types
okay
so important that you can use Java from
carlin and call them
Java two ways now let me show you some
more things as I said we try and cut
down the amount of stuff that you need
to write okay because the less code base
you have the better so one thing that
you do often in Java is you do you know
checking for a specific type and then if
it's that type you cast it to that type
to then invoke some method we have Auto
cast in Cortland so you don't have to
write that anymore so here it checks to
see if it's of type provider if it is
the compiler automatically infer that
that is of type provider I don't need to
do an explicit cost again okay
pattern matching we have some sort of
pattern matching not the way Haskell has
unfortunately which I love but we do
have pattern matching in statements when
is the equivalent of a switch statement
so you can have ranges you can have
function calls negations everything in
there okay now one thing with Collins
again is about being expressive so here
is how I can do a hash map and then map
one value to another value and the
important aspect here is in this code
you can see that I have for model in
price in car so I have a pair and we've
cut out the type infrared out the
explicit types we've named things
exactly what they're meant to be right
so it's all about trying to be more
expressive in the code and also that you
notice that we have string interpolation
so that's a quite nice one thing that we
have in Cortland is a concept of
extension functions so if you come from
c-sharp you're familiar with that and
it's very very easy to extend existing
classes whether they're calling classes
or java classes so what i'm doing here
is i'm taking the double type and i'm
extending it and adding a function to it
called two euros right so now any type
double has this function called two
euros and then it this is the actual
instance of that object right so single
line of code basically and i'm just
extending that with no new functionality
and you can take that even further you
can actually extend types you can add
extension properties as well as
extension functions so here I'm taking a
big decimal and I'm adding an extension
property and then I can do things like
2.0 pd- 1.0 now notice this - what I we
what Colin also has is the ability to
override operators by using certain
conventions so if I do an override of if
I could declare an extension function
called - what I'm doing in fact is
overriding the - operator okay okay we
do have modern things now it's ironic
that they call high order function and
lambda expressions modern since they
were out since 1936 but we have lambda
expressions as well quite clean very
easy to do things and let me just show
you a few examples of how you do that I
mean you've already pretty much seen
lambda expressions but let me show you
some more things here literally more
things so that's objects we have
Singleton's so if you just want a
singleton you don't have to declare the
pattern you just create an object called
single turn and going back to this
modern to this modern note to these
things let me show you this last thing
here what I'm doing is I'm creating a
higher-order function which takes a
function as parameter and I'm creating a
function called using that takes a
closeable does something with that
closable and then calls closed right
often we forget that we need to do that
so what I've done is create a function
called using that takes that and then
automatically closes calls close and you
can use that in this way I can say using
function etc now Colleen has one cool
feature which is if the last parameter
to a function is another function I can
drop the brackets so I could just do
that and I'm afraid we're out of time
done tom perfect so thank you very much
gentlemen
and so now it's time for you guys to ask
questions to the panel and please if you
guys could repeat the question for the
recording so who was to go first yes
please
so the question is what is the most
initial usage of your particular
language coming from the community use
or unusual unusual
can you define unusual yeah but can you
define that I mean what do you mean by
that
something like you want to make a safe
language and somebody use it to write up
thermonuclear launching my soul
development and you're like I could say
for Mira I've heard the Mira compiler I
don't believe it's in there now it used
to also have a back-end to generate a
Java source so since we can just
essentially generate plain Java code
with this syntax generate Java source
which was used for someone who didn't
want to do GWT anymore they wrote it in
Mira instead and then just had an
intermediate phase to create Java but
because it is a runtime dependency free
there's folks using this on smaller
embedded devices smaller JVMs that
misses are missing features code
translators that turn it into some other
language or some other bytecode or
assembly that doesn't necessarily have
all the same Java features only what you
actually use in the language is what
your dependencies are I know what else
well in the at least in the escal space
and I guess that translates one-to-one
into free get mr. Simon Pedro's likes to
say is a scale is the finest imperative
language on the planet and this is
because many people use it really as an
imperative language instead of a factual
one because the syntax sugar that makes
look at is as if it was imperative is so
nice that may count as being unusual
for salaam I don't think I have any
unusual anecdote in mind but I have
something that surprised me in code in
so on we have refight generics and that
means that when you call a function that
accepts generic types it actually knows
what instance of the generic type
arguments you pass to it and so I saw in
frameworks that now they're using it
without they're using method calls with
generic type parameters and not passing
any parameters to the function so it
looks like you're not passing any
parameters and what they're using in the
function is actually the type arguments
because they have access to it they
don't need to you know in Java you would
pass a class for instance as parameters
say instantiate this thing you pass a
class literal in Salone you don't need
to pass any explicit parameter you just
you know pass type arguments and it's
funny because you think okay this cannot
do anything there's no parameters but
yes there is
okay so paddy any any thoughts on this
not really because I mean we've we've
purposed Colin to be kind of like
industrial languished for multi-purpose
things I think the only thing that was
kind of surprising for me is to see a
new language being built using Kotlin
which we use it for you know it's good
for DSL but I didn't expect someone to
actually create a new language on it so
all right any other questions for the
panel yes
why the organization tools to create a
new language covariances what do our
decision
so so the question is if you could this
detail gives a little detail why the
language was created in the first case
there is no organization that stands
behind three years full spare time
activity like 99% driven by mr. go back
so I'm not quite sure you better ask him
but I would say it's mostly a language
envy you work on the JVM and he does as
well as in his day job and your and
that's Haskell Envy yes you would like
whatever has come yep that's it well the
organization that originally started
Mira is me and now it is basically just
a community run project that there's
number of different committers working
on it the original goal was basically to
create a ruby like language that
essentially compiled down to Java
something we could use internally in
JRuby to make it more approachable to
Ruby developers but since then it's
grown to be a very full-featured
language that still has managed to avoid
the runtime it's kind of an interesting
a thought experiment as well as a useful
language how far can we go with language
features without introducing additional
dependencies above and beyond what's on
the JDK and I think we've done pretty
nice job of it
so for Salaam I think one of the one of
the goals for this new language for Red
Hat from the point of view of Red Hat is
to have a language that would be the
equivalent of you know what would it
what would it look like if we started
Java in 2013 and not you know in 95 so
in terms of features all the features
that got added today to the Java
language over time had to deal with
backwards compatibility and had to make
choices and concessions to this because
they can do everything they wanted with
a new language with the same idea behind
the language which is you know working
teams in the industry good tooling etc
easy
to learn with the same mindset that's
that's how we created salon and and and
yes we were able to make things happen a
lot faster than if we had waited for
Java to get them like modules they
announced modules for Java way before
salon you know was announced and yet it
was so long they've got modules way
before Java got them so you know it's a
lot easier I'm not I'm not throwing the
blame on Java because it's it's very
hard with with backwards compatibility
and everything to introduce breaking
things like this in the language in a
new language it's a lot easier and so we
were able to get all the features that I
talked about earlier in in the language
which we would never have been able to
get into an existing language okay so we
have time for one more question
No
all right well so I'm we're about to
close this edition of its emerging
languages is great but first please
let's give a big hand to our
participants now we do the boding so the
question is which language will you use
to launch missile nuclear missiles the
question is obvious this is Cala so
let's hear it for frag a
best Earthfall Mira Salaam and Cullen
I'm just gonna say that this is one of
the few sessions a job one where we can
see the three major IDs on stage at the
same time behaving like gentlemen
right right am i right
so again thank you very much I think
that the winners are every each one of
them because these are still emerging
languages but you can use that in
production pretty much all of them now
we have heard from the own voices that
they have people used in in encode in
production so we encourage you to look
at the projects look at the home pages
if there is a future that excited you
just give it a try and we hope to see
you next year all right thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>