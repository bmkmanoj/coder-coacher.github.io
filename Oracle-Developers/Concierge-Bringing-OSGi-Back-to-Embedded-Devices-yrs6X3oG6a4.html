<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Concierge: Bringing OSGi (Back) to Embedded Devices | Coder Coacher - Coaching Coders</title><meta content="Concierge: Bringing OSGi (Back) to Embedded Devices - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Concierge: Bringing OSGi (Back) to Embedded Devices</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yrs6X3oG6a4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well good morning everybody and thanks a
lot for coming out from my talks early
my name is Jana Gana Maya I'm with IBM
research based in austin texas and prior
to joining IBM i was at a place called
eth zurich doing my undergraduate and
graduate time they're mostly revolving
around topics like software modularity
and how they can be used for distributed
systems but one of my freakin area of
demoing and work was also embedded
devices and today I will talk about
concierge a project that I've done a
long time ago and that I'm doing again
and then how to bring osgi back to
embedded devices so let's talk a little
bit about embedded devices and how they
have changed before we talk about
concierge so traditionally embedded
devices have been mostly fixed function
devices you know these typical small
integrated circuit kind of applications
if they have a user interface at all it
used to be very limited very functional
of course and a lot of the discussion in
the past in the realm of embedded
devices was more about very low-level
things you know what's the right
instruction set for a given problem
what's what's the best operating system
do we need real time or do we not need
real time and so on and one thing that
was very special about these devices is
that typically the software is is very
much tailored to the device architecture
sometimes even implemented in bare
assembly so that used to be the world
until a couple of years ago and what we
see is that embedded devices as such are
really evolving so I didn't mention that
on the picture of here you see what used
to be an mp3 player so there was state
of the art until something like the ipod
k road so that also implements the same
idea of an mp3 player but at the same
time it's almost like a little computer
that can run apps that can do a lot of
things you know
so we increasingly see a new class of
embedded devices emerging that there are
no longer fixed function and no longer
deployed once and never touch again kind
of things but typically built around
advanced processors many of them are
arm-based devices very close to to
mobile phones sometimes and and all in
all an unlike larger set of capabilities
that you have fun on the hardware side
they try to give you a more enhanced in
a user interface and usually experience
in that these things are touch-based for
instance and something that is very very
recent development is that pretty much
all the vendors are trying to build
ecosystems around their platforms so
that the hardware itself can be used for
for many many things and thereby they
add more value to their customers and
give them additional reasons to buy the
devices so just one example how you know
a typical fixed-function device has
evolved in in the event of mainly mobile
I think mobile is one of the big drivers
towards more richer user interfaces and
in capabilities so on the left hand side
what you see is a thermostat which is
kind of a classic example it has a small
chip in it and it has a display and it
doesn't really do much except you know
controlling your furnace and AC that
that used to be the design on for four
decades almost and then didn't really
improve much except that we started put
LCDs in it and then larger LCDs but that
was about it so if you want to get an
impression of what mobile did to to
these kind of devices just think think
of this more modern implementation of
the thermostat you know this one it's
it's not a coincidence that it kind of
resembles the design of the iphone it
actually was created by some of the same
designers that
started a new company but what's what's
really special about this device is that
it's no longer just for controlling your
furnace and AC and that's about it it's
a connected device that is control or
can be controlled through the internet
because it has a proxy in the cloud and
now you can either directly interact
with it or you use for instance your
mobile device and do the same kind of
functionality through through a proxy
interface so that's just a little
motivation to see what kind of
challenges we see in embedded devices
and what concretely we are talking about
where we talking about things like you
know smart home and smaller environments
it among other things it's that
something else is that this thing here
has a lot of sensors inside so for
instance it will just be kind of unmute
it will be black until you approach it
you know so it has a proximity sensor
and when you walk towards it it will
turn itself off and so on um a clear
trend that we see is that we used to
talk about ESS and embedded systems and
software and what we talk about now is
Maury SSC because we need to add the
cloud into this equation many of these
devices have kind of a foot in the cloud
and interact with the cloud either they
derive content like some would draw
information from from from the internet
from news feeds from whatever some of
them kind of have a reflection of the
functionality in the cloud so in order
to implement this idea of kind of a
continuous platform that that people can
program to its of course now attempting
again to run kind of the same software
stack on both the cloud and the meta
devices because that helps people to
build applications for your ecosystem
and one trend that we see here is that
for instance technology that used
the client side only like javascript is
now getting increasingly popular also on
the crowd side on the server side by
things like no j s and so on that's of
course more the interaction between the
web browser and the internet but i think
in the same way and we can say that java
on embedded devices has been very
popular in the past and then it kind of
flattened down and i think it's on the
rise again because the more you're
trying to implement this idea of the
contiguous and continuous software stack
between cloud elevated devices the more
it's tempting again to use kind of the
same the same language runtime
environment on both the cloud and the
embedded devices and we see this in
smart home iBM has an initiative called
IBM smarter planet where among many many
other things we are doing embedded
devices that are interacting with Excel
so let's talk about Java on embedded
devices job on embedded devices the the
reason why it was initially popular was
that of course it solved a couple of
issues that embedded devices have they
are not really like personal computers
that they all follow the same design so
you can expect a significant amount of
heterogeneity among different devices
and that's definitely one of the
strengths of the JVM you know wherever
you can run a JVM you can run Java and
it's more likely that a piece of code
that you write for one platform also
performs on or runs at least on a
different platform of course what I said
it's also true you can run the same kind
of code on both the embedded device and
the crowd so you can change the way how
you distribute your coat that's that's
all benefits um the problem with Java or
embedded devices is mainly you know
updates and maintenance because most of
the time you deploy a device and then
it's out there in the field but every
now and then you want to push updates
you need to push security fixes you need
to add
new capabilities maybe to the device and
that's the problem that Java doesn't
really solve except with the traditional
you know kind of windows XP way of you
need to reboot your device so that was
the situation already more than a decade
ago and the solution to some of these
challenges was really osgi you know osgi
was invented for embedded devices in
particular these set-top boxes that
people use for the television sets and
the idea was that these are devices
where people have them at home but they
are really owned by by an operator you
know they are given away to the
customers in order to receive for
instance television programs or you know
participate in smart home kind of
applications so the operator has an
interest to update the software over the
wire or over the air from time to time
and that's of course the reason why you
want something like osgi in and I will
later and explain what exactly you want
it's it's not really acceptable that out
of nothing there there is a screen
popping up that tells you oh by the way
I will reboot your device in 10 seconds
or so you know because the user has not
opted into this you know so these
operators were interested to do updates
on the fly with as little as possible
interrupting the the user of the device
so that was the idea behind all shy and
and that's the reason why we started
talking about modularity at all you know
it's exactly the problem that you want
to update pieces of your application you
don't necessarily want to update the
entire application and you want to do it
in a way that you avoid disrupting
everything that is currently going on um
I think to best understand what osgi
does it's good to look at the
alternative so what does plain Java give
us in terms of module management well
from from a deployment perspective the
only thing that Java really knows about
modularity is the jar file
so you can distribute your application
code into a set of libraries or you can
pull in libraries if you need them and
then you put them on into this mythical
cusp off so you concatenate all the
libraries and then you tell it this is
the main class and now go ahead and run
it you know the problem with this
approach is if you try to answer any of
these questions from kind of a system
maintainer perspective you know which of
these jars by the way contains the main
Clause of you know who knows you have to
look into them you know they are zip
file so you can look into them but the
system doesn't help you with answering
these questions you know even worse like
what is the dependency between the food
or jar and the bardo jar we don't know
is it safe to replace bardot jar or not
we cannot tell you know what happens if
i upgrade it to a different version will
the systems to run or will it just you
know die we can tell that's the problem
with Java with plain Java and there are
lots of interesting side effects that
this structure has one of them being
that the class path or the way how the
class loader deals with this initial
class part is in the fashion of a linear
scan so you can if you have kind of a
degenerated situation by just switching
the order of the jar files come change
the entire behavior of your program so
that's that's relatively error-prone so
let's see what ohci has added to improve
this situation oh she is really about
modules as a first class citizen of your
system so modules in osgi are called
bundles and technically what they really
are is just they are java files with
additional metadata it's relatively
painless to just take an existing jar
and turn it into something that annoys
GI framework would understand at least
in such a way that can load it this
additional metadata that I'm talking
about is exactly specifying these kind
of dependencies between
for in modules so first of all it gives
your module a name that is independent
of the file name which is already a
great improvement it gives it a version
and it tells you that you can have
certain expectations connected to a
version so now we can uniquely identify
artifacts in our system and then
whenever we want to share code between
these modules we have to explicitly
declare the dependencies and that's of
course to the benefit of the system that
it can now do kind of impact analysis
like it can tell you what are the
precise dependencies between the two
modules and in which way do they
interact so it's no longer coming out of
nothing the the piece of software that
runs the knowledge GI application is
called the framework for the good or the
bed so that's the thing that you invoke
in your Java JVM and from there on you
can start loading for instance bundles
and the primary task of the OSGi
framework is really helping you with a
lifecycle management of your software so
you can for instance install new bundles
or modules at runtime you know you can
update things at runtime you can
introspect your system at runtime it
helps with these kind of questions so
technically of course what modules give
you is it gives you a way of isolating
your units of code and and that's one of
the strengths but maybe also one of the
initial burdens in adopting osgi mm you
start with a situation where nothing is
shared and you have to explicitly tell
the system what to share so that's most
of the work in taking an existing
application modularizing it finding the
right granularity of modules and making
it communicate again interact again at
the points where you want it the good
thing is that once you've done it you a
most of the time you end up with a piece
of software that is much easier to
maintain and that's much more extensible
so this is just an illustration of what
the osgi view of a module in its life
cycle is
I don't think I will really go into
details but of course it allows
interaction with a specific bundle in
that you can for instance start and stop
it individually and you can uninstall it
individually and then the idea behind it
is that since the framework your piece
of software maintains your models look
it's perfectly a way of all the
connections of your modules it can only
take down the set of modules that are
directly impacted by a lifecycle change
so the question what happens if a
specific bundle is uninstalled well
nothing until you really force it to do
what you want but at this point where
you tell it now go and refresh and and
really perform the action that I've done
what I will do is it will take down all
the bundles that depend on this piece of
software and then you can bring them up
again and that's really the idea of you
know being able to update without
interrupting your your system so this
had I think you can already imagine that
an osgi a framework or an oci
application is a much more dynamic piece
of software and then requires some
discipline all these actions fortunately
will send events which your application
can and possibly should listen to so but
that's that's another small burden in
adopting osgi um this is a view of what
an application on osgi looks like just
for those of you who never seen it
before and for the osgi experts in the
audience I apologize for having to spend
so much time on it but you see that you
have specific bundles which which other
modules the unit of sharing the lowest
level of unit of sharing an osgi is
packages so it kind of nicely embeds
into the way how you would structure
application java and then you can
explicitly declare that a certain
package in one bundle is exported and
another one can declare that it needs to
import it and that means at runtime it
we'll have a way to just retrieve the
classes in this package without any
further ado and your system will now run
in the kind of modular fashion so one
important thing to observe is that the
packages themselves can also be
versioned and at least in osei are four
and further that means that you can run
multiple versions of the same packages
side by side if you do it right and the
classic use cases you're running an
application on an app server and you
need two different versions on lock for
J for historic reasons or whatever for
two different applications on your app
server that's perfectly possible with
with osgi whereas the problem when when
running the same things on a single JVM
without anything like osgi or anything
that that does things similar to osgi is
that you know the same class lauder
through two different class or is this
runtime incompatible you will get class
class exceptions so osei helps you to
kind of separate things that have
nothing in common by knowing the
dependencies that you think they're all
right arm I forgot to mention but
whatever you feel that you have
questions just feel free to interrupt me
so don't don't be shy I think I
hopefully convince you that you know
this decompositional approach and
composition at runtime brings a lot of
benefits in terms of maintaining
software particularly for embedded or
long-running devices the problem is when
you do this you gain something but not
all of it because your system in the end
is still tightly coupled you have more
freedom now which kind of packages you
can consume and you're limiting your
dependencies naturally by having to
declare them but in the end if the
bundle has declared a specific import
and you have nothing in the system that
provides this the corresponding export
guess what it won't run right so there
is a way to deal with this and similar
situations in a more
to see cup of way and the idea behind
that is osgi services so whenever you
have something in your system that you
want to offer to other bundles but it
could be optional or it could be that
you can consider your clients can
consume 0 to n of this these kind of
patterns it's a very good idea to use
services for them and a service in the
end is nothing but a java class
registered under one or more interfaces
plus a set of properties of shirley so
you can do this in your application by
interacting with the oci framework
through the bundle context and say you
know this is my servers this is the
object or now go and register it and
then other bundles can retrieve it from
centerpiece of the system which is
called the service registry and they're
very nice thing behind this is that from
the moment on that your bundle has
retrieved a service or through a service
reference and then the service there is
ZERO overhead to it because it's a real
Java object so if you come from kind of
an application server perspective there
is no proxy fication whatever going on
it's it's the real object that you get
so the runtime overhead is relatively
little and this again is thanks to the
origin of osgi being embedded systems
you know in the days where people were
thinking about doing something like osgi
proxy fication zor software was
unacceptable on an embedded device
because it would have imposed much more
over so the nice thing behind services
is that it decouples your components in
a very elegant way and at the same time
it further limits your dependencies
because now whatever kind you have is no
longer dependent on all the
implementation details of a specific
service but it's sufficient to have a
dependency to the service interface you
you really nicely height the concrete
implementation and that in the end helps
particularly on embedded devices you
know
okay I talked about the service registry
already that's a centerpiece in your
system where you can just ask queries
you can ask for specific service
implementing for instance a specific
service interface you can also ask for
the service metadata in that I said that
you can register just key value kind of
properties with the service and then you
can go out in your client application
say I want to have all the services with
this set of properties and the service
registry will give you a set of
references not yet the real thing once
again this was implemented in the first
place for not very far powerful devices
so you wanted to make sure that you take
the hit of retrieving the service only
for those services that you are
interested in so the service reference
gives you access to the full metadata of
a service and then you can still decide
if you want it or not but as I said from
the moment that you get the real service
object there is no more further runtime
overhead and you can just interact with
it as if it was given to you as an
object in the standard java application
okay um that's just another
visualization of you know how two
bundles could be coupled loosely coupled
through a service let's get to concierge
um when I started with concierge there
was I think around 2006 if I'm not
complete Europe 2005-2006 I was just
getting into osgi I had used it a couple
of years ago and then not used it for a
while and and it was kind of getting
more interesting to me again because of
a use case that I was trying to
implement on little robots that that had
an edit kind of system and at this time
I was really interested in the question
of what is the real minimum overhead
that you can get a chief if you want
something like all shy on your embedded
device and I was kind of frustrated in
that the implementations that were out
there in those days seem to me
relatively heavy weight you know both in
terms of footprint and in terms of
runtime performance so I started to
implement concierge as a kind of way of
teaching myself osgi and answering this
question how small can you make it how
little can you make the overhead for all
those kind of embedded devices and I
ended up with an implementation that
implemented the OSGi are three core
specification which was just about to be
superseded by our for at this time but I
thought our three was sufficient and I
ended up with something that had only a
footprint of 86 kilobytes which was
quite effect or less of all the other
implementations in those time and it
proved to be useful to at least a couple
of people especially in the embedded
systems realm on the one hand because it
was small and low over it but it used to
be also used in for instance for people
to teach osgi you know I got a couple of
comments from people that told me look
we like your code because it's really
readable you know it's just seven
classes and seven inner classes whenever
we want to see how osgi works internally
we look into your code because we have a
realistic chance of finding the piece of
code that doesn't and understand you so
I was pretty happy with my
implementation and was running it on a
whole set of interesting devices like
this year is an Intel mode which was
Intel's answered to the small sensor
network platforms that were coming out
in those days I hacked a couple of
commercially available devices and you
know put my own linux on it and run
concierge on it but the real problem
that I had in which was driving me
through the development of concierge was
that all in all these devices were very
very different they were different in
terms of you know the kind of hardware
specs that they had but most importantly
they were different in that you would
only get specific JVMs for certain
platforms you know
unfortunately many of them had very poor
level of optimization themselves so out
of the jvms that you see here I think if
I'm not completely wrong j9 it's the
only one that had just in time compiler
at all you know all the others were
purely interpreter and this was kind of
bad in that it exaggerated the problems
that i had with other implementations
that were more targeted towards desktop
machines or even servers in those days
because there is nothing that cleans up
your code and that cleans have your
performance problems you know the
interpreter will just do whatever the
code says and if the code is very
verbose and not optimized it hurts you
multiple times or you know it hurts you
by a margin on those devices which
already have relatively small CPUs so
just to illustrate what kind of problems
I faced on those devices we all know
that it's a good idea to use the final
modifier if you can so you want to make
your methods final to give the vm a hint
that it doesn't have to further look in
your inheritance hierarchy for things
that possibly override it at runtime so
it should be able to optimize much more
aggressively knowing that the method is
final and then if you declare your your
arguments final of course it can
optimize this in that it knows that you
know once they are declared and set to a
value the value will never change if you
look at the performance impact of
different combinations of using final
you see that this is kind of the
behavior that you want you know when you
use it you get a runtime benefit well we
see this exactly on on the kind of full
fledge JVM version 1.5 it doesn't really
work on 14 for interesting reasons
although it should have worked and if
you go to the interpreting VMs and even
some of the jetted VMs the the impact is
marginal so that was really the problem
getting consistent behavior and
consistent performance on all these
devices and I had to optimize concierge
in in very very interesting ways one
part of the optimization was finding the
right way to express my code finding the
right style of Java that would run well
on an embedded device you know and we
must not forget that you know osgi if
you want to look it from this
perspective is no value by itself it
adds value to the application so people
don't want to spend a lot of overhead
just for being osgi you know so those
kind of things were one big part another
part was the devices in those times
we're using a compact flash for instance
or we had some that had IBM micro drives
those had really high latency so osgi
supports restarts of the frameworks in
that if you shut it down and then just
start it up again and tell it to restart
and will restore all the burners that
you had and as a consequence of this it
has to persist all the bundles that you
install in the first place before it
starts them which means it has to write
them to disk in some form or the other
form and there was another big big area
of optimization how to get the balance
persisted in the right way and how to
read bundles back from from disk till it
turned out that for bundles that have no
native code the best way is really you
keep them a jar which is kind of
counterintuitive but the effort in you
know deflating the the archive cannot be
amortized for most of the bundles of a
run time when you the class order starts
to read the code from them on the other
hand unfortunately you cannot log native
code from Java files so at the point in
time where your framer figures out that
you hide native code in the bundle it
really has to explode the bundle there
was the rule of thumb pin those times
and I could show in various experiments
that really the best way was that you
would only
a deflated to the point that you hit the
native code and then you still leave the
rest in archive was those are the kind
of things back in 2006 so what I ended
up with was an implementation that was
running pretty well on a variety of
ameri devices of those times so I
apologize this is not very well visible
but the main points of target of
comparison in those times were on blood
flow fish on the one end and then Oscar
which was kind of the predecessor of
felix i would say and you see that when
running a specific suite of tests over
them those were the tests that clock the
fish used for for their own development
there were performance of the the
runtime that you got with concierge on
the different platforms was quite
substantially better you know than the
other implementations I didn't really
compare to equinox in those days because
equinox started off as an awful
implementation so it had to do much more
from the very beginning so that that
didn't seem fair and a Felix was around
already but it also started out for so
this this is comparing apples to apples
implementations that implemented the
same level of standard so one example of
even a commercially available platform
that use concierge was the buck I don't
know if you knows it notice it in those
days but they had a great time building
this platform which consists of these of
this base unit it runs I think an
embedded arm and Linux and then the
phone Amy on top of it oh and you could
buy all these different hardware modules
that you could plug into the platform
and the idea was that you could build
nice demos and nice applications by you
know combining these modules and then
writing some code that does something
with it oh and this hardware modularity
Maps 12 12 or shy modularity
in that each of those modules would have
a driver that ultimately would register
a service for itself on your osgi
framework so that the application could
just wait for the right set of services
that it needs to pop up when you click
in all the modules that you need and
they would start up and do something
cool they had a camera for instance and
it was Wi-Fi enabled and has had a
display so they had applications like
you could take pictures and I've Nora to
whatever cloud was called in those days
and that was pretty amazing for those
days and it was using concierge as
they're all shared platform so at least
the first revision of this device was
running concierge so let's talk a little
bit about you know what osgi are three
was and and what we've seen after our 30
the word was relatively simple in ohci
are three in that you all your bundles
and and pretty much your packages were
unique you know you would deal with the
situation that you had multiple versions
of them that that wasn't really part of
the osgi three model so it was more
geared towards running things that are
either mutually exclusive or a single
application on a single platform if your
bundle had an import or if you bundle
would export something you usually would
also import the same package just to
maintain consistency because then you
know the first that comes exports and
everybody else even if they provide the
same happen to provide the same package
will import and everything will kind of
use the same consumer provider sorry
there was the the word in r3 and and for
a very long time I thought that's
exactly what you need for embedded
devices why would you write one more you
know that's why I kept concierge yet at
r3 level now with recent developments in
mind especially what I try to motivate
at the very beginning that people are
increasingly wanting to run the same
software on the embedded device as they
run somewhere else
I think that's no longer true and then
that was my motivation for driving
concierge again and making it our five
compatible so bringing it up to to the
most recent standard so of course in
between of our three and our 5s are for
I for was a major shift away from from
the paradigm that I've just shown you in
that the big big improvement of our four
was that you could now run multiple
versions of the same bundle at least
from the perspective of a client and the
idea was that you would use it for for
instance on the server side where you
had multiple applications that share
some code but then you have these
situations the one needs j unit 3 and
the other one needs j unit 4 so you need
a way to have these things coexisting
and in the end some of these
requirements were really driven by the
fact that the Eclipse IDE and the entire
Eclipse platform were picking osgi as
their underlying runtime infrastructure
and of course if you code in Eclipse you
have plenty of situations where some of
your code is tested against j unit 3 and
some of it is tested against jay you in
for so this this is the reason why it
works at all you know so now we edit
proper versioning to both our artifacts
and our packages and this helps the
system to only while kind of creating
visibility scopes of visibility that we
call cost basis so only those bundles
that declare dependency in the end are
wired against a specific version and the
framework will make sure that no bundles
sees two different versions of the same
thing it will prevent you from doing
that so in that you can have multiple
class bases that are disjoint and don't
interfere with each other but you can
still run them on the same jvm you can
still run them on the same osgi fragrant
there was one of the big improvements of
our for another improvement or at least
addition to the way how you can use ohci
was the introduction of require bundle
and this can really came
from the idea that you would now run
much much larger applications on top of
an osgi framework so in many situations
naming every package import was no
longer feasible and require bundle gives
you well to say I want all the things
that are exported by this bundle and I
call it by its name and no longer by you
know the set of things that it provides
so oh she ir4 brought it more towards
large applications on a desktop I would
say oh sei our five is the next logical
step in that it makes osgi fit for the
server side oh and making it fit for the
server side means that this is the kind
of infrastructure that for instance
almost every je application server uses
underneath you know one thing that we
added in our 5 and which is almost the
the most interesting addition to the
standard is that besides package
dependencies we can now declare
dependencies that are not even code
anymore so we can say that for instance
my platform has a specific capability
and I can declare that my client bundle
requires a specific capability and those
will be mixed and matched in the same
way as you would do it for packages of
course not influencing your class
learning but they will get resolved in
exactly the same way and that way you
have a much richer way of of talking
about dependencies so platform
capabilities are one possibility another
possibility is if your bundles provide
something else than Java you know now
you have a way to properly talk about it
previously you were kind of doing
awkward things like putting them into an
artificial package structure and then
loading resources in such a way that you
would almost you know exploit exploit
the the fact that you could see a
directory as a package that's no longer
required so this this gives you a richer
way of expressing things that are not
necessarily codependency
another thing that we added is we added
a lot of interesting ways how userspace
bundles can manipulate the behavior of
your osgi framework and this again
really comes from the application
servers because now you can have a
bundle in your system that explicitly
Heights other bundles from a subset of
your models you know or that
specifically hired specific services or
that at the point in time where you Lord
code from a bundle it will perform
bytecode manipulation of the Lord class
so it can weave them and add orthogonal
concerns to it I think you see that much
of it really makes a lot of sense if you
want to run or if you want to implement
an application server and osgi
unfortunately if you think about it you
know concierge started off as something
very simple and lean you can quite well
imagine that all these new requirements
make it challenging to still be you know
lean and running well on embedded
devices mmm and I picked just one
example to illustrate what kind of
challenges you face I talked about you
know these great generic capabilities
and even your traditional package
dependencies or require bundle
dependencies can now be expressed as
generic capabilities and in fact it's a
very good idea to even do it so within
your framework now the problem is that
resolving a bundle in terms of packages
or require a bundle there's something at
you when you start your system up you
know so it's a very very computationally
intensive act that you get when you
install a new bundle and you want it to
start you know it hurts your runtime if
you don't do it efficiently in the old
version of osgi of course I build index
structures to speed up this process and
that's what everybody else did you know
you would have a registry of all your
packages so that when you start a new
bundle you could basically in awe of one
tell if a provider of the package was
there or not and you could make
decisions based on versions
by having auxiliary index structures
that tell you which version you would
best pick at runtime now in this
extremely generic capability requirement
model all these of the optimizations are
basically void if you look it from this
perspective because now you want to do
it with you know the entire world of
dependencies but you lose the specific
optimizations for packages and a naive
implementation that just use generic
requirements capabilities will have very
interestingly higher runtime if you try
to run any reasonably large applications
on top of you know and by large I mean
just think about how many bundles you
start when you launch it Eclipse IDE or
think about I know of some of our
clients which build their entire
infrastructure for running millions of
users web sites and they easily have
hundreds of bundles that they use in
their platform so this kind of shows you
the tension between still being lean and
adopting all these these new
capabilities of course what you wanted
to do if you were on the desktop or
server devices that you know you just
factor out your packages and bundles and
treat them in the old-fashioned way or
and then all the generic capabilities go
into a different space and you run less
optimized with resolving them but they
are less frequent so that's okay the
problem of course is that we have memory
constraints plus we now have a lot of
interesting introspection ap is that
need you to very often tell you about
all the capabilities in the system so
either you make the introspection very
expensive because it now has to join
these three kind of data stores or you
just duplicate everything you have them
separately to run index structures over
them and you have them in here that's of
course not a good idea if you really try
to optimize for small devices so I think
by now I've solved this problem in
concierge by just making the way how I
index things generic in that I can tell
you for every of these generic
capabilities what its name spaces
and the namespace knows about the
characteristic properties that filters
will usually ask for you know and by
that way you get the same kind of
optimized behavior without duplicating
all your packages and once again you
easily have hundreds and hundreds and
hundreds of packages in your system so a
package lookup will hurt your
performance if you don't do it right
okay there was just one example I could
talk a long long time about all the
things that needed to be optimized to
get a realistic implementation of our
five that still runs well and embedded
my current status it's not yet entirely
spec compliant but I'm I think i'm on a
good way to towards it the goal is to
become fully expect compliant and in the
very near future and currently my
footprint is about is below 350
kilobytes so I think that's a realistic
target which I think personally is
pretty remarkable if you just look at
the way how the osgi api at the
interfaces that that a framework needs
to provide has already grown i think
more than hundred kilobytes is just the
OSGi api if you compare it to the r3
version of concierge so it's it's in the
process of getting towards compliance
and the target is bring it into the
Eclipse Foundation which is very
exciting to me um we are in the process
of creating and we've already achieved
to create a very flourishing
machine-to-machine ecosystem in the
Eclipse Foundation you will see a lot of
very very interesting applications
around smart home about m2m applications
that are coming out of Eclipse and the
problem is that the existing osgi
implementation that runs the IDE
contains quite a bit of special sauce in
order to do so and that's for historic
reasons you know so in some sense it
provides much more than just an osgi
framework plus it's optimized for a
different kind of point in the design
space in that it tries to help
with running very very very large
deployments so I think concierge will
try to occupy a different point in this
space and that i'm targeting it too
small and embedded devices and
consequently doing the kind of
optimizations that i talked about making
sure that it still runs on the smallest
devices and that's why in the near
future we will have two different osgi
frameworks in the Eclipse foundations
each targeting a different domain I'm
trying to still keep it readable it's
it's harder for our five but i'm
currently at nine full-fledged classes
so that might drop or add by one or two
and about i think 40 in our classes
which is the problem with java that we
don't have function pointers so you end
up creating inner classes in some
situation but i think it's still
realistically a readable implementation
that that can still be used if you want
to educate yourself about the internals
of osgi oh and I'm trying to be
backwards compatible in that at least up
to the point where Java 8 and the
profiles come out I will try to keep
your code at a level that you can still
compile it for a 14 framework the reason
why this works is I mean osgi our 5 has
edit generics but at least in the Java
15 compiler you have the option to
compile it with the jsr 14 target which
can consume genera fight code and still
produce one for compatible binaries so I
will restrict myself up to the point
where I think it's safe to transition
into the future to a subset of the Java
language that can still run on 14
frameworks and hopefully in the future
we will see the latest and greatest JVMs
being more applicable to to embed it
again and then we can move on so among
other things of course one of the goals
is that having a very small
implementation should hopefully make it
easier and more rapid to also innovate
within the osgi Oh lights and trying
experimental
in a more timely manner than used to be
the case for four big implementations in
the past okay I of course have a little
demo here so it's possibly very hard to
see but this is my bigger bones that
form that i have here on my desk it's a
relatively nice embedded arm cortex a8
platform that runs angstrom Linux still
quite resource-constrained in that i
only have 256 megabytes of ram and of
course subtract the amount that Linux
already takes and I'm writing java SE
embedded 17 because i am not yet done
with keeping the discipline of making
everything 14 compatible and it runs a
very early alpha version of of concierge
so let me just switch screens so that i
get see my own input so this is this is
my console and just to give you an
impression you know what it means to run
in an optimized way if I just start
concierge on this platform it takes
about three seconds to start and this
even includes the very verbose output
that I still have four for development
once I've started it well I have a osgi
framework with a little shell that I've
just loaded so i can start interacting
with it for hoops for those who have
never seen an osgi framer that's the
kind of things that you want one thing
that I've kind of chosen at the very
beginning of concierge in that I will
keep in the newest version is that I
will provide a lock service with the
framework that's a tiny tiny overhead in
terms of footprint but my experience is
that especially on embedded devices
debugging is relatively hard so if you
have a framework that provides a lock
service you can get both framework and
application output in the same lock
which otherwise is very difficult
because you have a bootstrapping problem
and so the lock service is there by
default and you
can turn almost everything that the
concierge framework does you can turn
logging on and make it dumped into a
file or to the screen or whatever you
like so that's not very interesting
right now I can start install the bundle
the stress test bundle and started so
that generates some randomness and now
installs 10,000 services on this
platform which takes I think six seconds
or so so you see it performs pretty well
now it does I think a million of curious
over it that takes a little bit longer
but yes the point is I think it's
realistic to expect that this this this
framework will still run very well on
embedded devices despite featuring you
know the entire functional set of osgi
are five so of course the console is a
very low level way of interacting with
the framework and we have started to
talk about more interesting things let
me start a different version of
concierge I'm personally working on
something that is a rest interface for
osgi as an alternative way of
interacting with the framework and
originally I've done this more full out
application so if you wanted to run osgi
in a platform as a service fashion
that's what you want but of course there
is absolutely no reason to not also use
it on on an embedded device so just to
show that I'm not cheating this this is
the landing page of my bigger bones I'm
really going out to the real device and
now I can run pretty much my entire
management of the platform remotely in a
browser and let it communicate with my
embedded device through rest so that's
just the visualization of all the
bundles that are running and I can do
introspection in that I
can get for instance the header of my of
my bundles and then I started it with
the shell bundle so of course I can stop
it just to prove that I'm not cheating
shell is gone you see I can restart it
again shows there again so that's that's
just an alternative way of how you can
interact with with the system or and
let's of course much closer to what you
want it if you would run applications
that spend from a meta device to the
cloud and possibly you need to maintain
them from a center point um let's get
back oops to the presentation um this is
becca know
ok
I still see you know my screen that's
okay doesn't matter
literally the wicked okay so another
thing that that is very useful for doing
osgi on the embedded device if you want
to reach out and connect to other
services is that of course you can use
something that we call remote services
and that's something that I've done
initially also as part of my PhD the
interesting aspect of osgi services are
that if they are nicely loosely coupled
and you restrict yourself to call by
value semantics you can just take an
osgi service install a little piece or
middleware and you have a distributed
system that that was the point of the
initial chapter of my thesis and the
OSGi Alliance has picked this idea up
and created a broader specification
around it which is called the remote
service admin which properly structures
the act of dealing with remote services
and so on but of course of that that's
the way how you can now consume services
that are provided on a different
platform and use them as if they were
local minus the network latency so maybe
I have time for just one more and kind
of experimental thing that I've done of
course being a researcher I need to
present something that is a little bit
cooler than just you know that page so
to point out what what the precise value
of osgi is in terms of embedded systems
I created a system that would take a
reprogrammable platform which is the
sightings vertex to board that features
an FPGA and by the virtue of osgi
services having a runtime lifecycle that
you can for instance interchange
services at runtime and make you client
rebind to to certain services I've
created a system that deals with modules
that contain both a Java implementation
of a specific service and the bite the
bit code the bitstream that is used to
reprogram the fpga plus a little driver
that interfaces with this fpga so in
some sense I've abstracted away from the
fpga as a reprogrammable part of your
platform throw an osgi service
and then my system is capable of seeing
which kind of bundles in your in your
deployment support this mode of
operation and for instance on a mobile
device it would try to always pick the
application that currently runs full
screen and accelerate those functions
and the other one would run in the
background on the CPU slower but still
running so that's my prototype system
I've implemented it on top of the
sightings or CPU I don't really have
time to go into details but I tested it
with three VMs that are round for this
platform it's it's a PowerPC based
platform so of course iced tea in the
two flavors of zero without jit and
cacao which is an experimental jet and
then our commercial IBM j9
implementation that we run on the
PowerPC servers um and I've use
concierge for that plus a little piece
of middleware that I called Jagger so
the point is FPGAs can be reprogrammed
in very low latency so literature
literature tells you maximum 30
milliseconds so it's feasible to do this
swapping hot swapping of accelerated
code at runtime so let's just look into
what the runtime benefit is I've used
Triple DES encryption as one of the
examples of a function that is can be
very nicely implemented in hardware
because it exhibits enough low level
parallelism oh and if you compare these
lines you see that the Java
implementations of triple deaths in the
cryptography libraries or have a pretty
high runtime if you get to larger
buffers of course in particular the ones
that don't have just-in-time compilation
but still those who have jit are by a
significant factor slower than if you
would want to implement it in native
code and use lip test so by having a
hardware implementation and swapping
this into your system and running your
Triple DES encryption on the FPGA you
see that in my new system the curves for
my java program that you
is it and an alternative see
implementation that uses the same kind
of capability are identical so in other
words I have ironed out all negative
performance impact of the JVM or and I
run significantly faster than any
software implementation that uses see
and live desk so that's that's a nice
application and hopefully it shows you
what kind of flexibility and
capabilities you get if you structure
your application in terms of all GI
services oh and I hopefully could
convince you that if you want to run
osgi on an embedded device concierges
possibly the platform that you would
want to look into alright so that was
all and I'm happy to take questions I
think the time is almost over but you
can also come and talk to me one by one
afternoon thank you any questions yes
the framework yeah I mean the old
version are three is still around the
new version we are in the creation
review process in Eclipse so pretty soon
you will be able to download the source
code and will start to generate builds
know you can run whatever JVM gives you
currently 15 compatibility oh and yeah
for instance the the 17 embedded that I
used on the BB bull so there there is a
17 embedded that for specific arm CPUs
that you can use yes and once I've
really done you can run it on 14 JPM's
as well but not yet oh yes I think so
yeah no yeah they Oracle even has a
specific JVM for the Raspberry Pi so
that's that's the safest yep
for abundance yeah i mean III would have
said yes you do you do something like a
console or so nowadays i would use the
rest interface because in the
specification that I'm working on we
will even support that you upload a
bundle as part of your of your rest
message so this device for instance
doesn't have internet access so i can
not just point it to a URL and it
downloads it from it but with the rest
interface i could do it at the point of
operation and then push it to the device
as part of a risk message and yeah this
rest specification was released last
March as an early access i hope that i
have it on the slide so if you're
interested in that you should be able to
read about it and it's still scheduled
to come out with the osgi enterprise
specification early next year yep
yeah so of course you can run all of
this and you can run all of this if you
find an implementation for it so far I
haven't started implementing compendium
services other than lock service and a
couple of things that I used to use for
my own demos I think the more the
ecosystem grows the more likely it is
that people will also start for instance
implementing something like declarative
services in in a similar spirit and I'm
already very happy to accept you know
prospective committers and work with you
if you wanted to do something like that
oh and I will definitely support from
the platform level and also you know
guide to how to optimize these things
for embedded devices but it will take
some time until we see you know an
ecosystem adding additional value to to
the barrel SGI frame work ethic okay
thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>