<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building Modular Cloud Applications in Java: Lessons Learned | Coder Coacher - Coaching Coders</title><meta content="Building Modular Cloud Applications in Java: Lessons Learned - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building Modular Cloud Applications in Java: Lessons Learned</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qiyTCWVj3I4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everybody and welcome to
our talk thanks for showing up in big
numbers it's always encouraging for
speaker so this talk is titled building
modular cloud applications in Java
lessons learned and it discusses
actually what we've been doing in the
past two years or so while building calc
applications obviously in a very modular
way and so we will talk about the
challenges that we saw and how we
overcame them and what we are still
doing so before we dive into the content
that is quickly introduce ourselves so
my name is a better man i'm from the
netherlands i work for a company called
luminous whereas above the surface
company and a product development
company i'm a fellow at luminous which
means i'm well kind of a firefighter so
to speak so i do work for customers and
i have some internal responsibilities as
well besides my day job I'm also a yahoo
users group leader for the Netherlands
Java user group which is a young huge
group of about 3,500 persons and we have
our big annual conference events coming
up in November and this is paul babacar
and he's also working for luminous he's
an architect at the luminous
technologies which is the product
development part of our company and paul
has been heavily involved as the
architect of the system that will be
talking about today for the next hour
write em on the bottom right of the side
slide you see a little love child there
which is our book it took us nine months
to deliver so that's why and it's it's
available well actually it's published
this week so it's it's still hot off the
press and basically if a book signing
later today so the case for this talk is
called pulls on and bills on is a
educational system which is focused on
bringing personalized learning
experience to students and this started
out as a crazy idea actually and well
after about two years it's starting to
grow completely revolutionize the Dutch
education system because what the system
does it's it analyzes the learning style
and the way the student learn likes to
learn and it will serve the students
with contents in a way to this it will
challenge him and it will suit
style of learning so learning is an
interesting topic to speak about
especially if you're talking to parents
because everybody has an opinion about
learning and how their child is is is
doing so we went into all kind of
interesting discussions already and what
well for us the really interesting part
is how to realize such a system which
starts out as a crazy idea and then
becomes a revolution after that so right
now this system is heavily used in the
Netherlands already and we're still
rolling out to more and more schools a
fresh school year has just started at
the end of august or at the beginning of
workers actually and so well we're in
the middle of a new school year but
we're still adding features to the
system and we're also getting ready for
international rollouts so there's been a
lot of other countries and governments
expressing interest in this system so
which means that we go and go to cloud
skill or or or web skill with this
system as you can see it runs on a
tablet and it just doesn't run on a
single tablet it can run on all kinds of
tablets and also in a browser and we'll
talk more about the application cell
later on so when we talk about cloud
applications what exactly do we mean so
um in my definition a cloud application
is something which i could call an
application which is delivered as a
service over the internet right and so
actually it's like a modern web
application so to speak but it's not
just that easy as just developing web
applications because cloud applications
have well a lot of impact on your non
functionals rights on your
non-functional architectural
requirements especially on things like
availability scalability and
extensibility and how you deal with
those because while you're dealing with
virtual hardware you're dealing with
commodity notes so yeah well
distribution and load balancing and you
know a big data and stuff like that
those are well they become interesting
again right so we'll talk a lot more
about those some observations to make
and when we started out this project is
that well like I said it started as a
crazy idea and so we took an extremely
agile approach to developing this
software because if you start with a
crazy idea then you know after a while
the idea goes
like this and it goes like this and you
get a completely new idea so the thing
is our software should be able to cope
with change and coping with change is
difficult I mean as a human it's already
difficult to cope with change let alone
if you have to think of an architecture
like you have to think it upfront and
then be ready for changes that will come
if you have no idea when it will come
and where it it it will hit you so this
required an architecture that is able to
handle change and not only the
architecture but also the codebase that
should be able to cope with change right
because if you will start working on
this project with a couple of guys and
you type in lots and lots of code and
then the idea changes and you get new
features and and new requirements then
well you cannot start over all the time
right so you have to keep on refactoring
your codes and well keep on having a
stable a codebase that you can rely on
so things like unit testing is really
important of course but also having an
architecture which is able to deal with
those things now luckily for us there's
already a solution for that and that
solution has been around for well
actually quite some years I think it's
even 50 or maybe 16 years that the first
time this whole this idea was proposed
this idea is called modularity i think
it was proposed by Edgar Dykstra in the
in the late 60s or summary in the 60s
where he talked about modularity in one
of his research papers so modularity for
us is the ultimate hl2 because it
doesn't say anything about the
methodology of how you develop software
but it does say how you develop your
architecture a modularity actually
starts at a design level so at the
drawing board so you have to come up
with a good design so you design small
and well disposable components
disposable meaning you can just throw it
away if you no longer like it or you can
just replace it with another
implementation of the same functionality
and you can even have different versions
of the same functionality in your
production system so modularity for us
protected our code base from well
architectural rot rights or technical
depth if you prefer those terms
right so for us having a modular
approach to our design and it gave us a
way to to isolate our functional
problems then focus on creating
implementation and have a well as
separated contract and implementation
stuff and this actually just designed
101 so if you want to explain to someone
what actually modularity is well I'd
like to go back to University design 101
and say or what do well what did we
learn about having a good design likely
do things you shouldn't have too much
tight coupling or you shouldn't have
tight coupling at all if that's possible
but I don't know of any system that has
no coupling at all right if you don't
have things in one class and I don't
think that's a good solution as well so
you should prevent tight coupling but
you should promote cohesion meaning that
some parts of your system can just be
isolated so I try to depict it over here
in the in the picture so that the little
cubes they are like isolated functional
parts all right so they do something and
for that they need some classes which
are the black dots and those classes
they need to work together right so
those classes have some form of coupling
and they can't you all they have to know
about each other because they they work
together to perform the logical and
functionality but then the left cube as
well doesn't have to know about the
internals of the red cube maybe it has
to work with the right cube which is the
red line in my picture so it has some
well-defined interface so it knows how
to interact with another piece of
functionality in the system but it
doesn't have to know about all the bits
and pieces within the cube right so the
dots on the left hand side of the
picture do not connect directly to
adults on the right hand side of the
picture right so that's preventing
coupling everything to everything else
in it in the system and the cohesion
part is well there are some parts that
have to work together some some
different logical parts and they have a
well-defined interface and the way to do
it is by using interface implementation
separation right so if you want to
achieve modularity in your application
architecture you need actually three
things everything starts out that there
is at the design level like I already
mentioned
so you got to have an architectural
focus on modularity which means you got
to make a good design and a good design
starts with applying that just the two
rules that I just mentioned right if you
have a good design you need to take that
design from paper to coat so the classes
that you code up and the interfaces they
should resemble the well the drawing
that you made of the architecture now it
doesn't stop here the next thing that
you should do is take your functional
lumps and pieces or modules and you
should also bring them to run time so
you can still enforce modularity at
runtime so for this Java is coming up
short because in Java we have things
like public private protected and stuff
like that but it's really hard or
actually impossible to completely hide
the implementation of stuff behind an
interface because there's always a
possibility via reflection or if you're
in the same package to do accidentally
or on purpose excess implementation
classes well there is an interface right
so you can still circumvent the whole
modularity thing so that's not good so
in order to have true modular architects
you need something to enforce the
modular architecture at runtime and for
that we needed something on top of the
JVM and in our case it was osgi because
osgi is a modular runtime that you can
run on top of the JVM that will enforce
separation of the cubes or the modules
that you saw in my picture over there
and it also defines a way to interact
between different surfaces in your
system to speak in aussi I turn so SGI
right now is the only viable option of
doing true modularity there are some
alternatives you might have heard of
jigsaw for example well who who hasn't
heard of jigsaw because they've been
talking about it for nine years now but
it won't be here till 2016 if it's ever
will ever see the light of day right and
jigsaw actually is it's on a different
level because it will mostly be about
modularizing the JDK itself about
cutting up to jdk itself so it's not
directly meant to modularize your own
architecture and more like motorized
your own application
so if you want to do more Liberty now I
think oh she is a very good choice so
when we start talking about our CI we
hear a lot of people say okay okay okay
osgi you supposed to be really complex
and it has to be it has a horrible
tooling so how can we build a robust
system if if you bring in so much
complexity so this might have been true
in the past then the couple in I think
in the last couple of years a lot has
been done on the on the front of tooling
and frameworks and right now it's
actually really easy to use it and the
tooling is on such a level that is that
the whole development experience is at
least on par if you compare it to
traditional development stacks like
spraying or or Java EE the thing is
though you don't want to end up with
just Java as a kind of like
functionality and do everything yourself
reinvent the wheel yourself right so
what we do want to have is also the high
level enterprise AP is that we're used
to in traditional development stacks so
we want to do something like access a
database and we want to do something
like have restful services and do
security and stuff like that so we don't
want to reinvent the wheel for all those
things just because we are using our CI
but the good news is that a lot of those
libraries are also available standalone
you so you can just pick some and then
you can create your own a la carte
development stack and well we found a
way to just combine those high-level
Enterprise api's that we are used to
when programming in traditional
development stacks and bring them to our
modular development stack as well and
we're going to show you a lot of it in
the remainder of the presentation for
those are the three things that you need
in order to do a modularity in your
architecture so we think that oci is a
de facto standard module system I don't
think it will ever make it into a true
Java standard I mean it had like 13
years for that and still didn't happen
so I think with jigsaw eventually coming
up it will probably never happen but
then still because it's running on top
of the JVM that doesn't have to be a
problem the other thing that I want to
stress though is that just using osgi
doesn't give you more hilarity and I
mean some people think that just
using a framework you know gives them
the benefits of using that but I mean
you can you have to still be careful
about what you do so everything starts
at the architectural level you have to
come up with a good design first
otherwise it will just be one hairy and
mess right and so the other thing is
Marta Laird he doesn't come for free
with a framework so I think it's time to
shoot a little bit codes I mean you can
do that all right let's look at some
codes but before that I actually want to
show some pretty pictures here so i'm
not going to show you the application
itself but this is a demo application if
you use you can find them get up as well
and it's just a small vector of
application that shows well how you can
set up a modular architecture in like a
real-life small application but a part
of that you will see here i just want to
mention a little bit how those modules
are structured and what is actually part
of a module so all those small boxes
that we have here all of those are
separated separated oci bundles and in
that bundles or either api's or there
are always your services so if you just
look at a orders part of this system of
course there's something about orders in
the webshop then you can highlight a few
modules that are related to that order
functionality i will show you that in
code in a minute so we have so much from
javascript code that's not shown here
but the javascript code talks to rest
services and we have BF + 0 gie serves
and exposures restful web services for
each part of the system so we have that
for products we have that for orders we
have that for customers etc etc that's
already the first way to motorize a
larger system if you look at the rest
service itself itself it's just about
HTTP functionality so we don't you don't
do any business logic there as soon as
you want to do anything with with orders
for example put an order in the database
the restful web service just talks to
the orders API this is just a Java
interface the Java interface is also
packaged in a separate API bundle so we
prefer to just completely separate
implementation from api even in separate
bundles because then you can completely
swap out and implementation and replace
it by another one if you have a if you
build an application like we did with
the system that bird talks and talks
about it actually quite often happens
because well your API can more or less
stay stable in many cases but as soon as
you are FF drastically different ideas
about how something should work after
you tried it in in practice for example
you might just want to throw away from
implementation just start over again
that's often just quite easy and because
those bonuses are so small often they're
just a few classes in an osgi bundle as
we use it and it is actually feasible to
just throw away everything in a bundle
and just completely start over which
gives you a lot of freedom to develop
and level as well if you look at the
orders API there's probably an order
surface or something there and that's
implemented by osgi surfaces and will be
packaged in another OCR bundle as well
so that's if you go all the way through
the stack that's more or less how it
often looks like you also see there are
some arrows pointing from different
services to other AP ice so for example
the order surface also depends on the
products API any more important thing is
that it just depends on the API there's
a public API that's what you want to
share this with that's what you want to
keep stable if we can make changes to
either the order API or the products API
without breaking the other one which is
very convenient of course you want to
keep the amount of arrows that you have
pointing out or in what you want to keep
it low in most cases because if you have
no arrows pointing to all different
modules all modules know about all other
modules then you probably still on very
often flexible architecture because well
you're still kind of depend on
everything else they want to keep those
low but of course there are some
well-defined connections between those
modules if you look a little bit of a
bigger picture of of the system I said
this is web shop so it's a application
running in the browser at the top you
see I from front-end modules so
our javascript is all html5 JavaScript
the the demo application is built at
angular we also tried to modularize that
so even though the user interface fees
and we split up in different fictional
parts packaged up in oci bundle and that
way we also have modularity at that
level and actually we have a whole talk
about it tomorrow tomorrow afternoon
then we also have some security filters
and stuff like that and all of that is
just different bundles and because there
are different bundles we can replace it
again or just turn it off turn it on
whenever we we want it's kind of the way
that we split everything up so
everything that you can define as some
piece of functionality in your system
you just bundled up in a specific in its
in a separate ogi bundle so keep those
bundles as small as possible so how does
it look like in code what I have here is
eclipse and any clips I've been the
tools if you are doing osgi development
or are going to OC I development is
really look at being littles because
it's by far the best and easiest way to
do all shy development it's basically in
OC I know it's basically in Eclipse
plug-in let us take care of all the
things you have to take care of when
developing widow she I so for example
generating the import headers and I will
show you in a minute that's all taken
care of by by be nettles B&amp;amp;D tools if
you can read my shirt then that's the
one so I'm don't don't worry about the
red crosses everywhere this because you
don't have an internet connection and I
clean my cache which was a bad ID so
it's not compiling in a moment but it
doesn't matter this is a very small
application but if this starts to grow
if i look at my the big project that we
were talking about it's exactly the same
structure it's just a lot more projects
and all those projects they generate one
or more hours I bundles so for example
here we have a web show those front end
as you I that contain some JavaScript
code
and what we want to look at here is we
have a generators folder this is done by
BD tools and in their BF our in this
case the app script and HTML codes we
just pick set up but it is actually an
osgi bundle with a manifest not MF as
you can see here so let's am such a look
at some some cult I just want to give
you the whole picture so let's start
with some JavaScript code this is an
angular controller and in that angular
controller we invoke a restful web
service on / orders so it's just an an
AJAX call to do restful web service if
you look at a restful web service that's
actually packaged in a completely
different project remember this watching
vet results from the front end or do I
so that's my UI module or one of the UI
modules and all the order functionality
is in a project vector of those orders
and if you go into there we see we have
three different packages here and those
three different packages are also
packaged in three different OS your
bundles I will show you that in a moment
so the first thing we can look at is the
restful web service and the restful web
service here we created by jax-rs and if
you look at it i'm down to project 2
volt ugly talk a little bit more about
later on you can find the functionality
to use Jack's arrest in Austria
environments right there I'm so it's
just plain luxurious but this is
actually in our GI service as well so we
registered as knowledge a surface and
framework more or less picks it up and
exposes the restful endpoint so we here
we have to place order method and that's
the method that will be in folks on the
post / orders URL and the less thing
that happens here is that being folk to
order surface you see the functionality
or the code here is very simple it's
just really about well doing some
security checking and getting the
customer name from from the request all
just on the on the web level as soon as
we start talking about orders we go to
order surface the order surface
it's injected here right to the top and
order surface is also an osgi an osgi
surface and we use apache felix
dependency managed to do to actually
inject that into this class and by that
you see this this whole rest webservice
plus doesn't have anything osgi related
in it it is just plain Joxer s Jaffa
codes it is an orgy I surface but you
don't have to do that much for it the
only thing we have to do is write an
activator here this might look like a
lot of code but this is just setting up
some dependency management there's only
osgi related codes we have to rise 44
here so that's really quite easy I will
not go through all this codes right now
I want to go back to the order surface
and I want to see what order service
actually is so the order service is just
a plain Java interface and this is just
about orders so we don't want to put
anything about products here or
customers is just about orders that's
the way you can get a more modular
approach and its order surface if you
look here at the right is packaged in an
API package and right here you see a
little green icon which means that it's
an exported package this is a public
package and exported means in osgi terms
that other other bundles can actually
see this class and use it in their own
implementations and if you look at the
implementation the implementation of
this order service package in orders
d'mongo there is a mole implementational
on top of MongoDB after moombah order
surface which implements order service
interface once again there's nothing
about osgi here the only thing that we
need for our GI is just activator and
here we have some functionality to for
example list orders from a mongrel
database and here we use once again done
down to project to actually set up the
connection with with Mongo in a very
natural way to oversee i miss we will
talk about them now to a little bit
later so it is just from from front end
all the way down to the date
how this works in its well it looks very
much like any other kind of Java
framework that you would be using like
Joffe for example of course we use Mungo
here so it's a little bit different but
besides that it's really not that much
more difficult or something like that
because we're using or shy but we do use
all those different modules and i want
to show you that as well because if you
look at the and i wanted to say if you
look at the generators folder of this
order's project we will see the
different oil bundles but because it
doesn't compile I don't have any
generated code which is inconvenient
then I will just look at the beam
defaults beam defaults or actually the
descriptors I thought well make sure
that we set up the the right build parts
and make sure that we have to write
exported packages so I said earlier it
that we have two API package and API
package exports the API codes that we
have right here and that way it's
available to other bundles what we also
see here is that we have a calculated
imports right here and this is something
that B&amp;amp;D tools that's right and it's
very important because if you're using
our GI you have to set up your import
headers for you have to do package
imports of all the packages that you use
and if you have used osgi before you
know that's actually a lot of work if
you would do that by hand and you should
not do that by hands so what beanie tous
is doing it's doing byte code analysis
every time you do a compile and it will
figure out which other classes you
depend on and generate those calculated
imports it that way it will completely
automatically set up the import headers
in the generators jar files as well so
you don't have to take care of anything
yourself so we do have the full modular
approach this is foolish I services
based approach but it's really not in
our way it's really not that different
from a development experience then on
another stack but we do have all the
nice features from from the modular
approach what are the other nice things
about this is that if you actually run
it you can make code changes and you
will see them live in your application
so you don't have to ever restart a
container or something like that that's
just one of the nice little benefits of
using bindi tools and using osgi so I
said before you can download this
application from from get up you can
look at the code there and that gives
you a pretty nice ID about how you will
do this in practice and once again
although this is a small application
this architecture skills all the way to
build a very large applications that we
are also working on this is something
that just gets bigger with more bundles
and more projects but the whole
architectural ID states stays the same
and with that let's go back to the
clouds okay so and let's talk some more
about the architectural things that the
clouds and shorts up for us so first
let's go back to the the thing with
cloud applications so what distinguishes
a cloud applications from a regular web
application so and when we look at it
which is a couple of interesting
requirements first off a cloud
application mostly just is a bleep
application so we're talking about
modern web application and you should
think html5 javascript javascript
frameworks right so this is something
that just comes with defect and it's a
modern web application the interesting
trend is that the user interface part of
the application is nowadays mostly
offloaded from the server to the client
so we are harnessing the processing
power from the browser for example which
is powerful JavaScript engine and as
opposed to running everything on the
server in a state full web framework
like we used to do for the past couple
of years or maybe there's something
that's that is still being done a lot
the good thing about that is that no
state full web frameworks as the name
implies scary a lot of states making it
harder to skill the application so
offloading the web framework from the
server and make it completely vanished
from the server and having it on the
clients reduces a lot of the processing
power that you need on the server and
you have no states so it's will skill
very easily what we still do have on the
server is some sort of an API layer
about how the client can interact with
the server and for that html5
applications use restful web services so
the entry points in
the server side part of our application
our restful web services right then they
are consumed from html5 and JavaScript
or or angular as Paul just showed you in
in our application the interaction
between the client and the server is
mostly document driven and document
driven is actually well the user is
filling out forms and walking through
some wizards right so that's the typical
interaction that you have with with
these kind of web applications and so
for that and we say well if we had like
this document style interaction why and
not use a document style database so
that's the reason that we chose a
MongoDB that's one of the reasons
actually the other reason is because we
are gathering a lot of data about
students for example profiling data but
also the content that we serve to those
students we need what's called a
web-scale data store so we need a
database which is easy to skill and can
handle very large amounts of data and
it's also pretty resilient for failures
so for that well we took MongoDB and a
MongoDB skills easily and because we
have document styling direction it's
easy to store documents in Mongo and the
document style interaction with the
restful services in Jason and Mongo also
and will pretty much stores the
documents in well the binary form of
Jason so we do some simple mapping back
and forth from the database and saying
this is a pretty convenient program
model so the other thing is if you're
handling lots and lots of customers or
clients at the same time and you also
need to have something like a
multi-tenant solution there's a couple
of ways that you can reach that the
easiest way is just to roll out the same
system over and over again for different
customers or in different places and the
other thing is to distinguish between
certain customers by bypassing some sort
of an ID so you can distinguish in all
the layers of your architecture between
what customer is actually active in your
in your system right so if you look at
the right-hand side of the picture you
see our well technical layering so the
whole UI presentation and stuff is all
going an HTM
5 in JavaScript and then some JavaScript
MVC framework so once again we use
angularjs but there are some other
options out there as well then restful
services the entry point into the server
and as Paul just showed you by looking
at the code the restful services
themselves are also osgi services so
from the restful services on words it's
all I was young then the all the rest of
our a business logic and all of the
api's are also all oci services now see
I bundles and they run on top of Apache
felix and apache felix is one of the
available osgi implementations and what
we really liked it very much so that's
why we chose Apache Felix over some of
the other oci implementations out there
and then for storage so I already
discussed Mongo and the other stories
particular stree so we use amazon a lot
and sometimes you need to store some
binary data so you need a blob store so
for that we use amazon s3 but if you
want to run another cloud system then
you just replace it with something that
the other cloud vendor has to offer I
saw the whole idea is actually the same
now previously we talked about we didn't
want to lose the productivity experience
that we have on a regular or on a
traditional development stack so if you
want to be productive in oci and you
want to connect to databases and have
security and access blob stores and do
something with you know social stuff and
want to do search and profiling and
stuff like that you need some some extra
stuff and sometimes you can just grab
one of the well-known libraries which
are out there because they are pretty
much oci friendly they are already
bundled up you so you can immediately
start using them from an osgi
application but sometimes those
libraries that you are used to they no
longer work because they are not very
modular in nature by themselves or they
are not born on top person as an osgi
bundle so for this we resorted to an
open source project called am tattoo and
I'm dad who has a whole bunch of what I
call well Lego blocks so they are ready
to use OSD i enabled building blocks for
cloud applications it's an open source
project so you can just go there there's
lots of tutorials for all of these
components
you can take these components you can
start immediately well building of or
making them part of your own application
and using them to for example access
MongoDB or do security or do search do
remoting do restful services and stuff
like that and they are harnessing the
well known solutions out there so for
example for restful services like you
saw in the code that Paul just showed
you it was just using the jax-rs
annotations so you're just programming
in jax-rs which is a framework that
you're probably used to for doing
restful web services and you can now
also harness that framework and in our
own osgi alykhan stack using these
components so by adding I'm data to our
technology stack we actually can now
check all the three requirements that i
spoke about earlier so we start out with
the architectural focus so we have a a
really clean and neat design and we take
that to run time by using our GI and
enforcing the bundles and the separation
of implementation and interfaces and
then finally we add stuff from the UM
data projects too well actually keep the
high level API Enterprise experience
that we are used to when building with
with other stacks so this actually
complements our architecture now so much
for the technology the other interesting
things is to to take a look at em
deployment because how do we get our
software on the clouds and how do we
make sure everything skills and for that
I want to turn it over to Paul again
episode of course it's nice if you have
a modular architecture and a modular
codes a development time but it would be
a waste if you just packaged it up in a
huge war file and then just deploy it
also an application server because then
every time you make a change to a single
bundle you would have to take the server
down reinstall your huge part of our
file and have all the problems related
to that so it would be nice if you can
also have a more modular approach to two
deployments besides that of course when
running a cloud we set the system that
we are working on it's running in the
cloud it's quite large scale or a lot of
students using it or else you need
elasticity that you can achieve better
clouds but how do you actually do that
so we have been looking at the different
path offerings out there from a
different providers that that are in
that area and in a moment there's really
not anything that's me fit for what we
are doing because there's either a very
strong goal if like like strong rules or
a strict mechanism how you deploy your
code which is never in a modular way so
you always have to package things up in
a big file which is well we note and
really no good you're very limited
control on the scalability aspects so in
most providers you do have some other
scaling functionality but you can't be
well trigger or configure that in a very
convenient way or if you look at Google
App Engine for example there are all
kind of strict rules about what you can
do with class loading it cannot do with
class loading and their osha will not
even run correctly without without all
kind of tricks so there is nothing
really out there that we works out of
the box in a in a convenient way so let
me move down a little bit and we started
looking well how can we do this
ourselves and actually turn out to be a
lot easier than you might expect so what
we use now is just yes we are running
mostly on ms one but you can do the same
thing on another and cloud providers as
well and in there we just one run no she
run time so we use apache Felix's
runtime we don't need any other kind of
application server or something
something like that on top of that and
then the most important part that
actually makes is a passion fire mental
level go into a lot more detail there is
that we use provisioning server and
provisioning server we use apache edge
we are also one of the contributors on
the on that project and its really the
cornerstone of this whole deployment
strategy and then of course we have some
building blocks to get more high-level
api's and that's i'm down to that bird
just talked about the big probe this is
you have a lot of freedom we can do
whatever we want here so we can exactly
customize the stack as as that we wanted
to actually that's
quite easy it's it's really not
difficult to do and well if you know
what to do you can set it up quite
easily yourself as well of course the
corner of that is that there is no
fitness report no finance report that
you can well ask questions or something
like that when you run your application
doesn't deployed and so let's look a
little bit about a deployment structure
so in our case for there for the pilsen
system we accredit cluster per school
that's for several reasons one of the
reasons is that this way we don't have
to take care of mill Tennessee within a
code base which keeps things a lot
simpler different schools have different
configurations so schools are actually
not running the same set of bundles but
they have different authentication
providers even different learning styles
within their system and so we swap out
different kind of modules for different
school configurations and it's also nice
for scalability because it's much easier
to scale a cluster for a few thousand
students compared to scaling cluster
four million students for example yeah
this is quite obvious then we have a
cluster of mongo a replica set
clustering for each school and that way
we can also scale moon role quite easily
without jumping too much hoops you can
even take it a little bit further if you
want higher availability this works for
us it's very important to well never
have downtime because students are using
system pretty much 24 7 because we're
also in different parts of the world at
the moment so we have a load balancer
that's one of the amazon services and a
load balancer can be spreaded for amazon
on different availability zones so you
can spread across different data centers
with amazon the whole datacenter goes
down that happens a few times in the
last few years then it will
automatically fall back to the three
other data center you still don't have
done done done you could even do this
across regions so for example in the
data center in Asia and one in Europe
but that's a little bit more expensive
and don't do that yet but you could you
do that with the same setup
to actually get some scalability and
it's very important to have horizontal
scalability so but what we really want
to achieve is that if loads increases if
for example a school starts with more
and more new students and load increases
that way or the time of the day changes
and more students are online in the
system we just want to add more machines
to the cluster and get more more
performance out of that the only way you
can do that is by horizontal scaling so
that's that's something you have to be
aware of all the time to be able to
horizontally scale there's one very
important thing to keep in mind and
that's it that you don't want to have
state in your web server notice so
there's of course still state in
application because you have to keep it
somewhere and directly to places that we
currently store state so one place is in
the user interface itself as that we use
angularjs so a lot of the UI
functionality just runs completely on
the client and that's where you can also
keep stage for for the UI so the UI
related state never even reaches the
surface if you do want to persist state
for a longer time then it goes all the
way down to mongrel every store it there
and there is nothing in between there is
no state full session beans or something
like that that we that we need for state
this is something you have to keep in
mind all the time so this is something
you have to be aware as soon as you have
a little bit of state for example using
HTTP sessions well then it starts to be
a lot more difficult at least two skill
because initiation replication all kind
of stuff like that where the current
state of Technology is quite easy to
achieve this in a completely horizontal
scalable way because you don't really
need the state in any other places and
if you have that we can actually start
do out of scaling because in our case
well the users pattern of pilsen is very
predictable in the daytime all the
students in school are online they're
using the system non-stop but an email
few students might do some homework but
most of them are just watching TV and
doing other stuff so it would be a waste
to pay for surfers that we that we never
use Amazon is pretty nice but they are
not cheap so if you have a lot of
servers running for nothing it's really
drawing money down the drain so what
they have is antiquated cluster per
school as a set and each cluster has a
load balancer even if there's only one
noted and in the in the in the night we
might have just a single small nodes in
the early morning we know a lot of
students are going to log on so we just
add some larger machines in that in that
picture so we have a lot more okay can
get a lot more performance out of that
we could do this reactively so we could
just move your servers monitor the load
on the server and then start scale
observers within our case well the users
pattern is exactly the same every day at
eight or in the morning students start
and the service has to be ready so we
just start them up around that around
are done at the end of the day the exact
opposite happens students are done with
our school day they go home and we don't
really need that much performance
anymore so we scaled down again and in
the night we just run on one or two
small notes so that we don't have to pay
too much to Amazon this is of course
something there for everyone once is one
of the key reasons that you want to go
to the clouds and people have been
talking about a cloud for a long time
and one of the well the things that
people always talk about well you have
like this elasticity but it turns out
well you still have to set up some stuff
to do elasticity especially if you want
to do that on as provider so how do we
do that and specifically how do we
installed our software on a note because
of course we have our bills on code how
do we get that on the surface when a
scale up and down and it just give you
an ID if you look at a pulse on release
you have about two hundred bundles so
there's quite a lot of bundles that you
have to upload and configure somehow and
of course we don't want to do that by
hand every day
so the cornerstone of this whole setup
is Apache ace and apache ACC
provisioning server and a professional
surfer just keeps all our all bundles so
what happens to be uploads all our
bundles after we do a release to Apache
ace and here it says on the picture we
do this from a development machine but
you can completely automated from a
build server so that's what we actually
do in practice so when we do a release
all the bundles and other configuration
files are uploaded to pass you ace and
apache issue group those two features
and distributions are kind of different
distributions for different schools and
then on the right-hand side of this
picture you have a whole set of servers
I know shores and an ace are called
targets and actually if you look at it
those targets don't have to be cloud
notice of course in our context there
are clouds notice there ms or notice but
you could also just be small devices it
could be embedded devices even and we do
that for some other customers so ice can
be used in a lot of different context so
a states in the middle and as soon as a
surfer comes online it will proficient
our software it will proficient as a
distribution to those surfers those
servers will install those bundles and
start running it and every f'n new
server online so if you look at apache
ace and you are just started up then you
will see user interface in the browser
it's not very pretty but it kind of
works and you see there are four columns
so that you can group your art affection
to feature features and distributions in
practice we don't actually use the user
interface that much because if you have
a lot of bundles like we do it's not
very convenient and you wanna automate
that it's much possible which you can
completely script virtually age so that
you can run it from a build server maybe
even continuous we do that we do that as
well so you don't have to look at that
too much but then still um we have
perpetual ace and well apparently we
have some other scalable surfers but how
do those servers actually get proficient
how do they start well the first
question is how
actually start up those notes because at
eight thirty in the morning I don't
really feel like starting two hundred
new servers every day to start a day for
schools of course we have to have some
automation for that this is something
that you currently need some cloud
vendor specific functionality for and as
I said we are currently running on
Amazon so we use the MS on auto scaling
functionality which is just a surface
you can configure it there you can
define one to have a cluster cluster
minimum five machines maximum 20
machines for example and you can define
some rules that you say at a tourney in
the morning about the cluster to be 15
notes and at four thirty in afternoon I
want to scale back to five notes you can
easily define it they will give you an
example of that amazon will then take
care that at eight thirty in the morning
those 15 notes are started and the thing
that starts is just an empty linux image
question yeah
if not nice your application just
right I will get into that just a minute
so what happens we started an empty
linux image basically and the only thing
that runs on there is Apache Felix and
within Apache Felix we have one bundle
which is the management agent of ace the
management agent will don't go back to
pursue a civil register itself and say
well I'm a new note and I would like to
have some software about you ace then
can NC well your note for school X and
it will push the release for that
specific school the note will then start
up those bundles and in about 30 seconds
later you have a completely functional
notes when out of scaling starts up a
note it's also register to the load
balancer for that specific cluster that
happens completely automatic for Amazon
the load balance will then start pulling
the notes and if I ask you are you there
yet are you there yet are you there yet
oh there you are there you go yes some
requests so as soon as the notice online
it will start surfing
that you can configure a lot for that
and we put them very low so in that case
it takes about a few seconds but if you
didn't configure that correctly it can
be a few minutes until you start seeing
them we don't actually see that it sits
waiting a minute emotional time so if he
I one scale down we don't have to do
much we just kill a note so if we're out
of scaling you configure that is for
tourney 430 in afternoon you want to
scale down to five notes well we just
terminate 10 of them and outer scale and
we'll take care of that we don't have to
share down cleanly or do any maintenance
on those we just kill them and they're
gone there's also gives us automated
failover because if for some reason and
load starts to fail it or software
failure on our side or a hardware
failure on Amazon site that actually
happens once in a while then machine
might become in healthy and a load
balancer will notice that node load
balancer will see this note is not
healthy anymore it will then look at the
out of scaling rules and it will see
well there's only four notes left but
you have to configure that around this
town which the data should be at least
five notice tell engine will go back to
out of scaling I said well please start
a new nodes and we will go through the
old I'm diagram again and starting new
nodes and after a minute or two we have
a healthy cluster again that's quite
easy and especially quite easy because
we don't do any management we never have
to manage those notes if a node needs to
be updated or becomes unhealthy or their
memory leaks or whatever we just kill it
and it was not a new one which is very
very convenient this is just to show you
how you can set up an auto scaling
cluster with with Amazon and there's the
console IPI that they offer and this
effort that's all you have to do to
actually set up a new cluster so if you
have a new school this is what we have
to do one time this is one time setup
besides that you might want to set up
some rules
that define when you want to scale up
and down they're not shown here that's
all you have to do and the rest is all
well managed by ace more or less and as
I said the nice thing about this is that
notes are completely disposable if they
don't work correctly we just shoot them
and they will be replaced by something
else something fresh again that's a lot
more easy than doing the surfer
maintenance that you have to do in a
more traditional environment very f your
big app server that has to be kept
online also to keep the cluster healthy
today the three well nice for
maintenance as well okay then um switch
gears a little bit let's talk a little
bit about developer tools so we have
seen after I answer another question
come talk to me afterwards this is not
easy to answer okay so let's move on to
developer tools we are also kind of
running out of time jogs to move in a
little bit we've seen out how to look at
this an architectural level we've seen
some codes and we have seen the
deployment strategy bill let's talk
later about tooling so just in general
if you are doing a Java projects what do
you need you need an ID preferably it's
fast turnarounds I just can't stand the
fact that you would have to wait on a
maven build for example before you see
code changes that's just not working for
me so I want to have fast turnarounds of
course we need something like version
control and we have to integrate there
somewhere importantly we have we have to
you have a contains integration and then
of course things like an issue tracker
and Vicky etc so let's look at a few of
those the first thing they are going to
look at is continuous integration
because a lot of people when you look at
the Indy tools they start to worry about
continuous integration if you look at
B&amp;amp;D tools I've shown a little bit about
that you will see that you get a hot
reloading of code and all your code is
nicely generated in ID stuff like that
but it's not easy to see how that
translate to doing offline builds on a
build server well if you use PD tools
you actually have two different options
for offline building out of the box we
generate end files and you don't have to
do anything with those end files besides
running them so all the dependency
management etc is all taken care of by B
and D in a very osgi natural way and
then just execute the belts so you
notice through any thing anything years
out there recently we added the second
option in B&amp;amp;D tools which is a greater
support and so you can also use Gradle
to do more less the same thing this
might look a little bit different than
your well the greater builds that you
would look at normally because all the
dependency management is not taking care
of by great obits taken care of by B&amp;amp;D
because all the other metadata as you
need for dependency management is part
of the OCR bundles already that's the
manifest files that's also why nathan is
not really a nice fit for oci
it works with oh she I there's a lot of
projects doing oci together with Nathan
but it's it's really not that convenient
it's just making your life difficult we
get a lot of questions about this
because people are familiar with Nathan
but you really don't need it you
shouldn't you shouldn't want to have
that so if we can do we can just built
in a git push do things like code
conference and stuff like that that'll
seal integrates that with ogi an ambien
d alright so let's go back to work
alright so just a couple of minutes to
just wrap things up so what we try to
show you today is how modularity for us
has been the ultimate agility tool to
which actually the true goals that you
want to have if you want to be
ultimately flexible they want to be able
to cope with change so both on the
deployment level and on the
architectural level we can just throw
stuff away if it if it just doesn't work
or we can replace it with other versions
and also well modularity is no longer
difficult right so the ids are actually
pretty old like i said and with tooling
that we have available today and the
components of you have available today
you can be as productive as you can be
in a regular or traditional development
stack so that that really works for us
in the in the past two years then well
if you want to have to elasticity and
you want to take modularity to the next
level then the combination of having an
modular architecture with the stateless
architecture is is the way to go and
stateless can only be achieved if you
can be completely completely stateless
so well that means throwing away all the
state any application traveling away the
service is a stateful web framework and
moving there to the clients or moving
into the database or moving it to a very
temporarily cache cache which you can
throw away like any minute and then the
last thing is which Paul just showed you
is how we do cloud deployments and while
having like a scalable log balancing
architecture from your cloud investiture
provider is one thing but the key to
success here is apache ace which can do
the whole provisioning thing too well
both our servers and also to our ad
devices
come back to the questions in a in a
minute right so to wrap this up the talk
is just short just one hour talk but
there's of course much more to tell so
for the past nine months we've been also
writing a book about this so this starts
by how to build modular applications
using osgi and components that we showed
you today and then the second part of
the books also talks about how to set up
your deployments and how to deal with
the things that we dealt with in the
past couple years so the book is
available as since this week and they
also have them here at the Hilton so too
today at two thirty we have a book
signing and I heard there will be a
couple of free books so if you are in
line early then you can get a book for
free in otherwise probably available in
the bookstore ram as well so so far for
the shameless self-promotion and well
then if you need more information this
is the UM dotty website I'm dot org so
here you can find more tutorials about
how to get things up and running Paul
and I recorded some screencasts on on
how to get started with your IDE with
B&amp;amp;D tools and how to be productive with
the UM data components and there's a
couple of tutorials on the side and you
can download all of the UM data
components over there and we've even got
some more resources so if you want to
know more about apache ace or about who
we are or about B and D tools you can go
to the URLs mentioned on the slides and
then if you have any questions we were
almost out of time so if you and if you
have any questions please come up to us
afterwards or reach out to us either via
email or through Twitter we're pretty
active on Twitter as well and with that
I'd like to thank you for your attention
and for showing up thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>