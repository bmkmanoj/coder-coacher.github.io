<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>OAuth 2.0: A Standard Is Coming of Age | Coder Coacher - Coaching Coders</title><meta content="OAuth 2.0: A Standard Is Coming of Age - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>OAuth 2.0: A Standard Is Coming of Age</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6kJVbM6-8AU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to my talk to about 12 and if I
were working with what some of these
bigger companies the next slide would be
this cool disclaimer slide I really like
that a lot but unfortunately I don't
work for a big company so we don't have
we can't afford those fancy things and
so I have to make up my own disclaimer
so I try one so this is a talk about
security bone dry matter so I don't know
what you'll be doing in here but anyway
depending on your mental Constitution
this could cause a lot of extreme
boredom confusion or sheer paranoia so
you'll want please don't complain
afterwards if you suffer from any of
these symptoms after this talk and one
more thing I I don't care about any
intellectual property which might be
contained in this slide feel free to use
it that's why I'm here for okay having
said that should be enough for a
disclaimer my name is uber free lesson
don't even try to associate these
letters with what you just hear hurt if
you're not from Germany it won't work
and as you probably can imagine I'm not
a hardcore security guy so usually on a
strategic level I'm thinking about the
role of IT in post a jar times and on a
technical level I'm more into building
resilient highly scalable systems but
since I'm also building quite big web
and cloud applications i also have a
keen eye on security that's what the
space this talk is based in ok so what
we have for you basically it's we will
look at all to from three different
perspectives the first one is a
conceptual perspective the second one is
the protocol level and the third one is
code perspective
we put a few more pieces in there so to
the left on and the right to fill up the
gaps in between the point I want to
bring about to you is that Roth so
that's at least what I try to achieve in
the next 50 minutes or so it's
surprisingly easy to use and there's no
reason not to use that if you might have
her if you might use that will have a
requirement for that in your project and
if I'm able to bring that across then
I've got my point on ok and if you might
not understand anymore this ancient
language anymore i also have a
translation to their into a more living
language for the guise of today ok but
anyway so let's talk about was too what
are the players in this was just little
recap about the what it's about where
the players first of all it's you
sitting usually on a browser called user
agent and all those specifications and
then there's an application with
protected resources usually in the hello
world of all that's a server containing
photos photo server and then there's
another application called client in the
or speak which is usually in the hello
world example that's this photo book
server and assignment is this one you're
working you're just within this photo
book side and say wow that's a cool one
I want to do a photo book based on the
stuff that the site offers to me and but
there for this application needs to get
access to your photos which you start on
another server which is protected and
the problem in here is just quite
straightforward these are protected
resources I mean these are your photos
these are worth protecting for sure and
usually they're protected by some sort
of credentials
login username password or whatever kind
of credentials and you usually would
have to give those credentials to this
other application but you don't want to
because you don't know how reliable that
one is whatever they're doing with your
credential otherwise and so on I mean
it's never a good reason to spread your
credentials across several places and
you also don't want to have these
credentials on the wire because you
don't know how reliable this connection
is and what's going on so what to do
application should have access to the
protected resources what you don't want
to give the Prudential to that and what
you're looking for actually is a
solution which is easy to use and secure
I mean easy to use and secure that's as
likely usually as having our big vendor
application server running smoothly with
less than 2 Giga two gigabytes of main
memory but anyway hoss hope the last to
die so Twitter started up with that
Ahmad 2006 they thought about a solution
for that and soon some more companies
joined in and they created kind of a
draft standard in the end of two
thousand seven and the gif gave it to
they used it quite well and it worked
quite fine and they also gave it for
standardization and the standards
committees did a decent job so in a
Standards Committee instant which
usually about two and a half years they
turn it into a standard this RFC was the
number whatever you can read it there
and everybody was quite happy and as was
what's used quite widespread to standard
everything is fine but there were also
some complaints about it one of the
complaints was client a quite complex
client security handling no it's it's
working somehow anywhere I tried more
often
and it is client a complex client
security handling so you have to bring
some arguments into the right order get
some digest out of their work with some
nonsense and all this queer security
stuff for a security guy that's quite
straightforward everybody else it it's
just creepy so they those client
programmers don't don't didn't really
like that and also it's got a quite
limited scope it solved that problem but
it only solve that problem and nothing
else nothing less but also nothing more
and a lot of enterprise guy said mean
why are we accept that this WS star
stuff isn't so nice in some places we
also want to use these nice rest stuff
and so on and but we need some security
security and that's not enough for us so
it's at least it needs to be extendable
so we would like to use that but it's
not enterprises ready so what their
they've be calling it and ok another
standards committee started another
working group started just after the
first and it was released in the
beginning of 2010 and they also did a
decent job again which means it just
used them 31 draft versions before they
could agree to a upon a standard 42 and
someone in between so in the middle of
2012 Aaron hammer left the standards
committee Aaron hammer who doesn't know
him was what the major driving force
behind earth one and also for a long
time after earth 2 and don't know why so
lot of people thought then we think that
Earth is dead because Aaron left and I
don't know what happened maybe it was
kind of a wake-up call to the standards
committee or whatever but three months
later the standard was out so our sea
was finished ok and there it was you can
read down there I included a link to a
post
Aaron where he talked a lot about his
frustration about this standards
committee process and why he thinks that
all through sucks and so on and he
started also renting a lot about all
afterwards it's partially because of his
prostration of the process for sure but
Aaron's also very smart guy so it makes
sense to look into his arguments will do
that later so about his criticism out
was to but it's a little bit later first
let's look how owes to works we've got
that slide before and in all of this
application with protected resources is
split up yep here it is into two parts
so the other parts stay the same it's
you working with a user agent you are
called resource owner in both terms the
other areas cloud applications called
client application or just client and
you've got an authorization server and a
resource server down there so the
resource server is the one really
holding the resources in this case in
the hello world the pictures and the
authorization server is all is taking
care or about all that authentication
and authorization stuff okay I shouldn't
do that I think everyone's awake again
sorry so and there are some interactions
defined between those four players every
interaction pattern is called in all
terms of flow or a grant I don't know
why they call it as well they call it
this way it's fine and what we are
looking at here in our example is the
so-called authorization code grant which
is the successor of the original
flow that all one defined we don't have
the time to look into all the floors and
I'm sure you wouldn't be awake anymore
if I would have completed the last flow
so let's stick to one okay before you
can start with an interaction your
client application has to reprieve some
information it needs to get an idea
signed and in case of a confidential
client I come back later what that means
also a client secret and in return it
has to provide a redirection you are I
to the other party to the party
operating this authorization server
resource server the standard doesn't see
anything how this information is
exchanged so you can meet under a bridge
in a shady corner and whisper it into
the others here whatever standard
doesn't care so it just says before you
can start up your client needs to have
this information it needs to have an ID
and in case of an confidential client
also needs to Evan a secret some kind of
credentials it's also not going to find
what kind of credentials just
credentials it's more flexible and
almost one okay and also it needs to
know some so-called endpoints and so
called authorization endpoint and in so
called token endpoint this is usually
open information so you usually can look
that up or for instance if you go to it
into the API descriptions for Twitter or
Facebook or something these adjusted
here are the you r is for those
endpoints that's it okay and then you
can start up with first step on a
conceptual level is that this client
says I want to have an authorization
code that's the reason why this flow is
called authorization code grot
it's doing this usually by set it this
happens usually so you're browsing
around in the application say I I want
to connect to this resource server over
there and then usually this server just
this client just sends you a page to the
browser where the link contained or
button or something like that which is
going to direct you to that
authorization server to the
authorization endpoint that's one of the
two endpoints I just mentioned before
and this request basically says hey I'm
this client and I want to have a an
authorization code and then the standard
stops again it just says okay and now
it's the turn of the authorization
server to go back to the resource owner
which is you and ask resource owner if
that request is okay for you so that's
what's usually what's happening there is
so for instance you say connect to
Twitter that's when this page is pop-up
or said this other application wants to
get access to your Twitter account is
that fine for you yes no but it's not
specify how specified in the standard
how exactly this has to happen though
it's up to your fantasy and let's assume
that you say yes then in turn the
authorization server sends back and so
called authorization code which is
forwarded back to the client application
this authorization code now encodes the
client and the user because meanwhile
you have authenticated so it's always
bound all these codes are bound to a nap
location for the client and to our user
usually two more things about the
authorization code because all this
communication goes across your browser
its treated as in potentially insecure
environment the brow
that could be compromised for some
reasons and therefore they say this
authorization code should be a short
lift token or information short-lived
code so the standard recommends do not
give it a lifespan for more than 10
minutes I mean 10 minutes it's a lot of
time in computers terms but anyway
that's what the standard says and also
standard says if this token is used more
than once then probably it was
compromised please revoke anything
that's based on this token we come to
this in the next slide so the next step
here is now you have that also relation
code yes at the moment the client just
this client just in the first step let's
go back to that one just identifies
himself with its ID not at secret
already and however you're going to
authenticate it's completely up to the
authorization server so it's not part of
the standard it just says you need to i
authenticate somehow as a user but we
don't care how you do that so it's it's
flexible but it's also undefined so it's
a pro and cons on the same at the same
time so yeah okay next step now you have
that authorization code was not yet
usable as an access token so next step
is that you go directly to the
authorization server and say I want to
trade that authorization code for an
excess token it's a direct communication
and everything if everything is right
then the authentication servers
authorization services tells you here
you go here's your access to use it be
happy have fun ever and live happily
after ever after your client application
two more things about set to say about
that so here if it's a confidential
client the whole flow
made for confidential clients it has to
authenticate itself right here in this
case here in this flow the client has
also to authenticate by providing his
credentials his secret which you
provided quite at the beginning and also
authorization server said before needs
to make sure that this token is only
used once this the code is only used one
sorry so if the code is he received the
code a second time he should try to
revoke all other tokens which were
issued before because he cannot say
which ones did attack her and which ones
real request yeah and then I've got that
token and here I go I say give me the
resources i want to have and here's the
talking by the way and you do that over
and over again in here now you
communicate with the resource server
which means it has to communicate with
the authorization server to figure out
if that's token is well it that this
client application presents them again
standard does not specify how this
communication works again flexibility
but also on the other hand less precise
few more things I will go through quite
briefly be course I don't want to cause
a sorry excuse me
how question is how long the tokens well
it it's up to you you can define that
you will see that in the protocol flow
that you can define how long you want to
let the toe cliff so I've seen
implementations which have tokens which
are well it for ten years which i think
is not a very good idea and I also know
implementations that deal with tokens of
our which are well it for an hour or
something like that so question is how
do you prevent to someone else to use my
token that's the first thing up here the
whole or two standard relies on using
SSL or TLS however you name it so you
shouldn't use that without anything like
TLS so secure in your conversation
otherwise there is no means yes you
would see that in the protocol flow
because it's it's plain text in there in
the header and if you don't encrypt the
line this is easy this would be an easy
steal definitely question is what the
information contained in the token
actually nothing it's just it's bound to
a client and a user ID again but it's
just no pake token usually so you can
encrypt more information into that where
you see in the protocol flown on the
next slides how how the token looks like
but it's it's just something which
refers to her
yes so the remark was that you can also
use the token for introspection so send
it back to the authorization server and
then you could get some more information
about which client is it onto and so on
next week that's what's usually be done
so what for instance for we are doing
our implementation is then that we just
figure out which user just sent the
request navigation yes clients but wait
gods are each day question is if you can
pass tokens animality client environment
no it's not cover us it's always binds
to one application usually I mean you
could define a cluster of applications
being one application but I'm not sure
if that's a good idea it might make
sense in some scenarios but usually
token always bound to one application ok
let's try to
sorry
you need to have ssl certificates for
sure yeah so question is if you use SSL
do you have to have all these
certificate infrastructure setup which
use for SSL yes you have to so the
resource server and authentication
server needs to have ssl certificates
for sure so i talked about end points
before client types i talked about these
confidential clients and there are two
clients defined in ross one is
confidential clients these are clients
which are which can keep a secret or
kind of credentials usually these are
web applications which are running web
servers which are running behind
firewall something like that the other
type of client is public client
so-called public lines these are usually
things like JavaScript applications
running in the browser where you say you
cannot make sure that this secret is
kept safe because the environment is
unsafe in which is running so there are
some other flows for that type of
clients for but we probably won't have
the time to scan through them I also
let's look through the list just client
entity fire I talked about client
authentication talk redirect your eye
maybe just a little more information
about that it's also possible based on
the standard that you can register more
than one you redirect your eyes so
several redirect your eyes in this case
you have always to send the redirect URI
with your requests so that the
authorization or authentic authorization
server knows where to send back your
request when it forwards it in the last
step of the earth series of the first
flow of the first part of the flow and
you can also just register a partial
your eyes so just root part of it so
that you also have to provide the
redirect URI with your request and it
must start with that stuff that you just
registered before and you can use
combinations of that I'm not sure if
that makes any sense
but you could do that based on the
standard that's about your egg your eyes
access token scope is one thing I just
left out in the first part you might you
might know that for instance when you
try to connect to Twitter so sometimes
you get a request like this application
not only wants to read your tweets but
it also wants to write tweets in your
name and it also wants to see your
personal information or profile
information or whatever and it also
wants to get access to your credit card
information whatever you still out there
and of course what and so you can define
kind of scope parameter which says it's
not only an get access or no access but
it you can also define more grey fine
grained access levels but it's up to the
authorization server which kinds of
values it provides a scope parameter so
you can define that on your own and you
usually shirts then put that on your
webpage where describe AAPL wherever or
to the same place where you will also
describe holder your eyes for your
authorization token endpoints are
nothing a refresh token I come back to
that later and client state is just
information in that first flow you can
imagine if your quality session
environment which your client
applications usually are and you get a
redirect into your client you you need
to recover the context in which that
request was sent and that's what the
clients state information is used for
you will see that in the next slides
when you go to the protocol level okay
up to here where a normal question
organization the client or the resource
and the authorization server the
resource serving the authorization
server or the client and the
authorization sir I mean theoretically
probably yes but I don't need at the
moment mate maybe I'm missing a point
but I don't see a reason for them using
AWS at all because if you're already on
the same side just access your resources
I doesn't mean that's not okay something
from the client precise in the DMZ and
the resource that is accessing the site
in network so the security
infrastructure now from the required
that the or thought to exist okay more
resources that are accessing on the
outside world to our protector okay so
comment was that there might be
security-related so based on the
security policy there might be scenarios
where you really have to set it up this
way
thank ya ok so this remark was then that
reason is that if you can use the O's
stuff with existing SS or applications
with your evening I don't see reason why
you can't do but as always you have to
figure out your own security
requirements and if it's suitable or not
yeah ok let's move on to the protocol
flow because at least I want to show you
some code in the end and so let's try to
get on we've seen that before so
question is then how does a request like
that look like I mean up to now we just
talked about the conceptual level now
let's fill it up with a little bit of
bytes if we look at this standard
defines here that you usually use a get
request here and you go to the endpoint
so assume here that / also rise is the
endpoint you I of that server and he of
server example com whatever you have to
define a response type response type is
just a flow I don't know why they call
it a response type here and codes that
just means in this case authorization
code grant so okay let's pre-final
here's your client ID here's the state I
just talked before and here's a
redirection your I usually normal your l
escaped form that's it basically I mean
no secrets in between and that's quite
straightforward as a response then here
you get something back like that it's a
three or two so that's a found which is
redirect usually and which you get here
and it just uses the redirect URI you
just provided before here and then you
have the authorization code in plain
text in here and also it returns the
state to you so that you can restore
context basically I mean that's as you
see here no ssl no protection it's plain
text the state is just an arbitrary
information that the client can send in
you can see that in the slide here it
just sends it in with the request and
then you can use that when you come back
to restore your context it's up to the
client so the authorization server
doesn't care i just make sure that it's
sent back okay and then the next one
here they say now we're using a post so
it's it's mixing up a few things in here
so every request and response has a
different format so it's using pot it's
going to the other end point to the
so-called token endpoint and what you
find in here is now we don't call a talk
about response type anymore but about
grant type and it's not called code but
authorization code don't ask me why it's
specified that way and maybe it's just a
little bit more distraction and fun or
whatever reasons they changed it for
here's the code I just got before and
the redirect your eyes standard says if
I send it back in once I have to set it
in all the time the redirection your eye
and it must be the same as I sent it
before okay it the only interesting
thing in here is this strange thing
that's where the client authenticates
itself so it's not prescribed by the
standard how you authenticate yourself
as client but or defined but it says at
least you need to offer one
implementation and this is this one it's
the basic authentication where you use
your client ID as user name and your
client secret as password and then
username cologne password base64
encryption and that's it and send it in
here that's what every authenticate
authorization server needs to support
okay and then we get back hooray again
something different now a JSON format
again
don't ask me why they did is this way
but they decided to use Jason right now
and what you have in here is then the
access token itself as I said before
it's bound to a client application and
to a user it's a token type or supports
different token types but it only
describes one token type that every OS
server must implement and implement
which is the bearer token and it expires
in which is more sort of an information
its expiry in second so nothing you can
use in your code base its just oh it
will live for an hour about from now so
and refresh token I talked about that
before that's an easier way to get a new
access token if this one has expired
without go to the whole flow again so
that's where the refresh tokens meant
for okay and if I would have used the
scope parameter in the first place it
would also show up here and but here you
would see then the scope that was really
granted so if you as user would have
said I don't want to give that
application access to my credit card
information which you probably would do
then it would show here you've got a
question sir refresh token is usually
well it till the end of time or until
your server dies you could also issue
another refresh token whenever you issue
whenever you refresh your access token
but there are some problems in between
we just had an AA applications so we had
a client client application for
on the iPad and for some reason I don't
know why some of our users had two iPads
and then the fun started so we I said
before I shouldn't do that anyway and
when the fun started so access token
just expired we they sent in the Refresh
token ban the client the one client just
said in the Refresh token it we sent
back a new access token with a new
refresh token then they switch to the
other iPad and their access token wasn't
valid anymore and it wasn't known
anymore and there wasn't any when the
Refresh token also didn't work anymore
because we just killed it with
refreshing the other one so you can
refresh but there's a trick so as a
catch in between so usually it's a it's
a big our discussion around if it's a
really good idea to use refresh tokens
or not I mean on the most of the big
applications use cookies then for
implicit authentication which in turn
just opens door for CS cross-site we
could see I RF attacks then on the other
hand where you then have to go and
secure your flow a little bit more so it
all has its pros and cons there's no
perfect solution for anything in 30
the timeline of the session that
initially was you
excuse me
the token is well at four-thirty yes
okay
I'm not sure if I got your question
right but when you go through
authorization clever you just first get
this authorization code which is just a
short left one which you exchange then
for that access token which you get back
here and this has a expiry this one and
usually again the Refresh token is not
bound to that expire you can bind it to
it but there's a catch with it yeah yes
right as long as you're actively
refreshing again then you don't need to
re-authenticate and go through the whole
flow you can't implement you but your
server like that oh for instance a
facebook or twitter or something they
don't use the Refresh token if you go
for them they just as I said before they
just use some kind of cookie based logic
to Rio CENTAC eight implicitly so that
you don't always have to authenticate
yourself and click these pop-up screens
and all that stuff again last step in
here is using that access token for sure
which is then you just to get on the
resource you want to retrieve here's the
one with a very cool name one I just
want to access and here's the talk not
just sent notarization header and it
says its bearer authentication and
here's my token in plain text again no
ssl no security ok that's basically the
protocol flow for the authorization code
grant both also define some more flows
we don't want want to go to get into
detail today therefore these so-called
public clients it's a so called implicit
grant which completely relies on the
redirection URI there are no secrets and
then there's my
you most beloved flow that's the
so-called resource owner password
credentials grunt I always have to read
that because I can't keep that in mind
and it's just the perversion of the
whole earth idea because now what it's
doing here is it says send me your
credentials and I give you a token I
mean that's exactly what we did what we
wanted to avoid with or sending giving
the credentials to the client and here
the client censored credentials and then
but admittedly in some Enterprise
context this might made sense so if you
just use that behind your firewalls in
your internal network that might be okay
but please don't use that on the
internet and then also the client
credentials grant if you just want to it
is client just sends you his own
credentials so for getting sxs just with
the application not bound to a specific
user and the Refresh token round that
flow which just talked about that's the
flow that belongs to refreshing the
access token then there are some
extensibility built into all tools so
you can define additional flows you can
define the messages you need for that
you kinda fine you can define additional
token types and so on for instance
there's a recommendation standard out
there about so-called H mech tokens HTTP
message message authentication code
tokens which are basically the kind of
tokens that were used in North one which
you can also use without SSL and set
additional flows and they're also
derived standards meanwhile around there
like the open ID connect standard which
based on all or the UM a user management
access but all those standards are quite
heavy weight quite enterprise-e and they
don't know have a lot in common with all
anymore so my personal feeling about
those is if I don't need to use my avoid
them because they're heavy weight
I talked about criticism Aaron did a lot
of bashing of all of two after he left
the committee and there are also some
other guys around and the main point of
criticism they have about OAuth 2 is
first there are too many compromises
built in you know those 10 has always
work with these words must short may and
if you go through all those draft
versions a lot of mass were turned into
shorts and shirts were turned into may
and may just completely disappeared so a
lot of compromises were built in
throughout the process of creating that
standard and of course a big issue is
that is not it hasn't got any built-in
security that it solely relies on the
usage of SSL so no ssl nothing's one if
you have a man-in-the-middle attack
you're just screwed and it doesn't help
you anymore and especially with the
barrett open so all these securities are
guys of course say this parrot open is
just a joke I mean it's a plain text
talking just written into an
authorization header that's not security
that's whatever and also was to allow
so-called self encrypted tokens these
are very tempting I mean every time you
have an access to the resource server
you have to go back to the authorization
server in some way and ask it is that a
well it's token oh that costs time you
have a database access or whatever and
even if you have a cash it for that or
but it costs time it would be so
tempting to use in different way just
saying this token contains all the
information to make sure that it's well
it and it also can't has encrypted the
user and the client ID into it and
whatever and when it expires and so on
it's allowed based on the standard but
on the other hand if this token is ever
compromised you have no way to revoke it
anymore because it's immediately used
the resource server doesn't go back to
your author
asian server and a spirits well it you
just said oh yeah that looks like a
reasonable told me I it's okay so it's a
problem its security point of view your
the question yep oh that's a tough one
for me because I'm not so deep into jazz
anymore yeah could you I think question
was if I could off with jars
so just a quick basic question was if
you could use a connect or two with jars
in some way and you for sure can in some
way but it's there's no standard
mechanism around there so you have to
implement it yourself maybe there are
some something out there if you google
for it but I don't know actually
the self encrypted all about yeah that's
that's true but if you're a security
expert which I'm not you really have a
big issue with just sending such
information in plain text across its
plain text also why even if it's an
encrypted line because also this
encrypted line can be compromised in
some way their attack vectors against
ssl available so just short-term ago the
cipher suit it turned out at some of the
Cypress roots we're very vulnerable
could be hacked very easily even without
a man-in-the-middle attack and so for
instance right now you should update
your Cypress you that you allow for us
SL service to use and so on you had one
ok
so since we're a little bit late we
should go on here and transfer that to
the next break coffee break sorry about
that but need to go on I mean you
deserve your coffee after that and I
won't stand in in between you and that
stuff so the recommendations are quite
straightforward the standard allow gives
you a lot of flexibilities it gives you
a lot of maize which you may do or shall
just should do but no one tells you not
to enforce that stuff and when you set
up your own earth infrastructure you can
enforce lots of things in there to make
it more secure and if you can do use the
HVAC tokens which are a lot more secure
than the bearer tokens and which you can
also use without SSL if you want to so
if so even if someone hacks your line
you still have another level of security
in there also the H make tokens you can
use to take a digest a fingerprint from
your message so you can make sure that
your message is not tampered with which
is quite nice so you can make keep the
make sure the integrity of the message
to set just send around so these had a
lot of advantages disadvantages a lot of
the standard if the libraries which
around do not implement that but it's
not a big deal implementing that you
said we did that it took us about two
days one day to understand the
specification in one day to it really
implement the stuff so but what's quite
straightforward don't use self encrypt
the token I told you before why I
shouldn't that and by the way because we
are foreign forced to use SSL always
check to certificate to make sure that
you don't become vulnerable to men in
the middle attacks even if it's a little
bit more effort okay that's just basic
the wrecker basically the
recommendations we have a few more
minutes left for how that feels like in
code so we're on the Java one so we
should see some Java code
of course I use the Apache mo library
for that unfortunately in Java there
aren't many good libraries around the
spring library is quite good meanwhile
the embo was quite promising meanwhile
it's called Apache all true for some
reasons renamed it but there's not a lot
going on there it's okay you can use
that but probably have to patch it in
one way or another to make it work and
so we did our own patches because it's
also based on the draft standard 10
which are is used by many
implementations still and we patched
that to comply with the at least for the
parts we are using to comply to the RFC
but sorry we didn't contribute that yet
I still have to convince our developer
who did most of the code to contribute
back to the Apache project maybe on I
will be successful we'll see anyway
you're the first one we have to accept
this get requests how's that looking
like in code so just to show you it's
quite straightforward to set up a server
by the way I don't show you how to
implement the client that's dead easy I
don't want to insult your intelligence
so just google it and it's dead easy to
implement or client what server side
here let's start with that one what I'm
using is the Jersey library here so for
the jax-rs so we're going for the
authorization end point right here and
what I just factored out is something I
call a security data store I mean we
need to have some tables in the
background or some storage in the
background where we store some
information about the clients which are
registered about the authorization codes
which we issued and the tokens which we
issued and so on and that's just behind
that interface okay we have to get and
what's going on here is first we're
taking the request and rep and validate
the request which is very easy with them
typical library
instance for Amber it's just I create
the so-called or authorization request
object based on the original object and
that's it implicitly it fires a lot of
validators you can extend those valid
data to do and it does all the
validations it can do in place so all
required parameters they do they have
the right format if there's a format
constraint on that and all that stuff
that happens out of the box not a lot to
do here then of course I have to
validate the redirection your eye
because that's something it cannot do
out of the box because now it has to go
down to your own security database and
that's not built into the protocol so
what we are doing here is just against
quite straightforward I extract a URI
from my request I go down to the data
store and just try to repeat retrieve
the URI registered for this client I
mean the client sent in his ID and I go
down and look for the URI here i just
did it a little bit easily so i'm not
going for multiple registered your eyes
and i'm also not going for just base
your eyes so i just say if they're equal
ignore case then everything is fine if
not thrown exception so amber also
provides you with some nice exceptions
with provide you with the right arrow
formats and all that stuff watch what
you need it's quite straightforward I
mean otherwise I would have used
something like starts with us whatever
to extend that yeah and then validations
basically done and then this magic step
happens based on the standard which
means right now it's up to you how you
ask your resource owner if this request
is ok forever and what I just did here
is I assume we are just using going back
to the early days of the century doing
Justin JSP and a servlet and because
it's straightforward to show it so we're
building some kind of your eye where we
are going to forward to and building
that your eyes also quite
straightforward
take your base your eye you append all
the parameters you have to use them for
the authentication or which you have to
return again for instance like scope and
the state information which you need to
present on the screen or which you need
to return in your response that's
basically it is not a lot of code to for
the first step now this jsap is doing
its magic you will indicate yourself you
agree or upon its ok this client may
connect to me and everything's fine and
then we assume that we want to send back
that authorization code so here's that
methods which just as a servlet has that
request and response object in here what
are we doing here we extract the user ID
which we meanwhile I'll have in place
and we also extract the client ID and
now we have to create that authorization
code which is another call to our
security data store so what we need here
is again some kind of a table so the
first table for the client was just a
cable with the client ID the client
secret and the redirection your eye or
your eyes this is another table we need
which is has the authentication code in
it the client and the user which is
bound to and the time to live and it's
already if it's already used or not
that's basically it I mean it's not a
big big deal to implement things like
that ok and then what you're doing here
is you'll get your redirection your i
append your parameters and just redirect
to it again straightforward it's not a
lot of code I mean I left out all the
error handling and stuff like that for
this based on our production code
simplified or not it's some places but
basically an extract from all production
Crowden it's not a lot more besides some
error handling and tiny details in
between next step is then this token
exchange so just look into that
again here is another step we require
here's to validate the client because
right now it'll Center Kate's this is a
big row secret staying with that base64
and how to handle that I mean again dead
easy let's split it up the first one in
two basic and the base64 encoded part
then let's decode that part Oh as always
is based on utf-8 sets the standard
let's call a decode that by the Cologne
and then the first part the left-hand
part is client ID and the right-hand
part is the client secret and that's
basically it and then we just have to
check if this client is registered and
well it and as the secret matches and
we're done again and if not we saw an
exception this we had before it's
another kind of wrapping another kind of
the validation again and then we have to
get our exchange the token which is just
going to the beta base looking if the
authorization code is still well it if
it's not yet used and if everything is
fine we create in the third table we
create an access code where we just
store the access code the time-to-live
maybe the Refresh talk access token
refresh token time to live also expiry
date use our client ID and also the
authorization code is based on because
if in case we have to revoke that one if
the observation force came backwards and
mark the other one the authorization
code has used again also not a big deal
all of you can probably program that in
10 minutes or whatever yeah and then we
have to build our response and that's
just some boilerplate code for used for
Jersey one thing I left out here
actually I should also validate if the
client matches the authorization code
when I go in here so usually it would be
better that if the validate client would
have returned the client ID which is
then put in here as an additional
parameter but that's basically it
which but this would have wouldn't have
fitted on the slide anymore and
therefore I left it out sorry yeah and
if we try to build that one again
straight forward all the stuff is in the
library basically it's just a fluent
interface we have here we would put all
the stuff it here and convert it into
Jays matches and we're done
straightforward okay and using it I mean
that's also again very easily first you
have to extract your token in the filter
and then you have to validate if it's
okay extracting is again just wrapping
and validating is going to the database
store looking if you know that token and
if it's everything's fine and if you
know the talk you can also use that
mechanism forces that's what we are
using we enriching the session by the
user ID and applied dan where I would
love resistant to learning anything
anyway and yes and enriching the session
so that we have all the information in
place so we just inject that in the
filter and everything and then we can
use all the the stuff later on here but
we're doing a web application so we're
not based on jazz but on something
differently but probably can also find a
different way for using that with Jess
then yeah and that's basically it what
I've had to say so what you can see in
here is it was quite quickly now for the
for the code I had in here but but it's
not a lot of codon is not very hard to
implement that so basically my core
message is off to is ready for use it's
quite easy to use you've seen the code
and if you use it just don't go for
least security that's basically what I
try to bring around let in this hour
thanks a lot for your patience</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>