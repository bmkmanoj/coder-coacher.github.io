<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Faster Java EE Builds with Gradle | Coder Coacher - Coaching Coders</title><meta content="Faster Java EE Builds with Gradle - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Faster Java EE Builds with Gradle</b></h2><h5 class="post__date">2016-09-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/j70nVjDc2Lg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">great I'd like to welcome everybody to
faster builds with Java EE and Gradle so
a little about me first I'm co-author on
the ejb3 in action second edition book
and also the NetBeans certification
guide the ejb one of course deals with
heavily with it java enterprise
javabeans and the sum of the EE stuff
that we're going to be talking about
today and how to better build it faster
with Gradle so first introducing Gradle
for those of you that aren't familiar
with it or just heard about it from the
Android ecosystem it is an open-source
build automation tool it's under the
Apache 20 license it builds upon the
lessons learned in apache ant and maven
as well see as i go to the presentation
it's actually almost 10 years old right
now it was first released back in 2007
and has slowly been growing in
popularity ever since it uses a groovy
based DSL not an XML file format which
is the biggest departure in terms of
build tools because the both maven and
aunt use use XML so Gradle is actually
uses a programming language is dsl to
write the build files it uses a directed
acyclic graph to determine the bill to
order it supports multiple languages not
just Java so it supports C++ C Objective
C so you can do you can develop mobile
applications native applications with
Gradle as well in fact large parts of
the JDK I believe are now built using
Gradle including the javafx stuff it has
a rich plug-in architecture making it
easy to extend and extend the build
extend the built-in stuff that comes
with it if it favors convention over
configuration but is easily customized
and adapted the last point being very
important if you're coming from a legacy
project that may be aunt based or even
older than that using shell scripts it
is easy to get it into Gradle because
Grail does not force a project structure
upon you you can easily adapt
what comes out of the box unlike the
other two build systems the build file
can be version to like the dependencies
so for example if you've ever run into
trouble with ant there are actually
changes between ant version 1.6 and 1.9
so that a file written with 1.6 does not
necessarily run with 1.9 so just because
your your stuff isn't version control
and you check it out doesn't mean that
you can build it with the current
version of answer if you've got code
from 2004 going against an to check it
out and if it's a complex build build
process it may no longer run you may
actually have to go out and find that
version of ant and hope that that
version of amp still runs on the current
JVMs it features the background Damon to
reduce build time so once you get it
once you invoke it the first time it
leaves Damon running behind the scenes
so that the next subsequent builds are
faster it supports incremental builds
and this is the reason why running code
out of IntelliJ and also the clips run
so fast because they have they don't
recompile the entire project from
scratch every time you hit build right
so we made a change to one file it just
recompile that file doesn't recompile
the entire system so that is one of the
benefits of Gradle is that it supports
incremental builds and tasks that you
write and build processes that you add
to it can also take advantage of that
incremental build logic so that anything
that you develop can also know whether
it has to run or not it supports built
in profiling out of the box there's
actually a task that you can run that so
that you can ask for it to profile your
building tell you where it's spending
all of its time it does support building
projects in parallel so if you've got a
nested project structure will build the
sub projects in parallel and it does
have some limited support for doing task
task parallelization it has got built-in
ant and maven integration on the ant
being the better better of the two in
terms of support with the ant
integration you can actually use ant
tasks in Gradle so you can real Everidge
it you can even use snippets of ant
logic or you know entire blocks of ant
scripts in your in your Gradle file to
help you move along it supports several
different central repository so it
supports maven center
Jay center which is quickly becoming the
de facto center and also i EV so you can
pull IV artifacts out and down using a
Grail so if we look at the evolution of
the build systems in 2000 we had ant
which we were all excited about because
it freed us from make and from shell
scripts at the time right that was it
was it was like an epiphany the first
time users like this is great then after
a couple of years and 20 thousand lines
of XML files during the debug stuff he's
a second yeah you know the dependency
nightmare started you know with like a
you know a thousand jar files that
you're trying to manage with your aunt
file you know then then came along made
men to try to solve the dependency
management in the project structure so
no longer did you have to try it if you
cooked up checked out an Apache project
spend a whole day trying to figure out
how to compile it and figure out how to
locate the dependency so that it would
actually build maven solve that project
but it put you in a straitjacket so if
you didn't do things exactly the way you
wanted it to it was painful and you
would have to write a very often have to
write a plug-in to try to get around the
limitations and then on top of that if
you had an existing project that was
substantially large you'd have to
refactor in order to get it to work
right and get it effectively into the
may have an ecosystem which depending
upon where you work that's not always
possibly can say well just give me a
couple of weeks I have to switch build
systems here nobody nobody can touch
code and so Gradle builds upon all of
them lessons learned from from the past
20 or so years so Gradle versus maven
which is the primary point of comparison
Gradle has a fully configurable
dependency graph which may even does not
i'm not sure why the green things are
getting cut off on the overhead
projector they're not here it does
support tasks exclusion so you can you
can specify that certain task student
run it supports the concept of dry run
so you can say execute this as a dry run
so you can see what's going to happen
when it actually does the build what
tasks are going to get executed before
you do it so they'll tell you I'm going
to run this task i'm going to run that
to ask want to run this test so you know
and you can then then dig in if there's
a problem try to figure out why it's not
going to run
our desks it has advanced support for
build for task ordering so you can say
you know this task must run after this
other task list so you can construct
complex execution orders between tasks
that depends upon whether or not you
know depends upon how put up in other
tasks etc so we have like things like
should run after must run after
constructs it has it supports custom
distributions so you know with maven
you're outputting a jar file you're
outputting a war file what if you want
to output a war file and a zip file
containing the war file and some
instructions so you can easily do that
with Gradle it does have repository
aware caches so that if you're using two
different caches sorry two different
repositories and they've got two
different versions of a dependency it
can help you resolve issues with this so
that can things like that can lead to a
nasty undone reproducible behaviors
where you have we know 11 dependency
from one repository over writing a
dependency from another one version
conflict resolution so you can specify
with maven your kind of locked into how
it decides to resolve the pendency so if
you've got two things including the same
dependency which one's going to actually
win out maven has rules with that with
Gradle you can say well I want this one
you know it's further down on the graph
but you know I want this one to win out
you can have file-based dependencies
which is very important if you're
migrating your build system over to
Grail you can have Gradle for part of
the build process so something new
you're building you can use Gradle for
that and you can pull in as a file
dependency something that's being output
by your existing ant build so you can
say okay you know I've read the you know
this new module that's downstream it's
written using the build system uses in
Gradle the dependency that it's pulling
in is not available in a central
repository or published any repository I
want to pull it off the file system to
integrate it with the existing build you
can do that
it's got the ability to do build
comparison so you can do builds between
two different two different builds and
compare them it's got custom dependency
scopes so you can specify so you can
actually add dependency scopes like with
maven you have provided you could add an
additional dependencies scope for like a
annotation processor or for some custom
tasks that you've written it's got
replaced by rules so for example you can
say that this you can specify which
version of a dependency you want
replaced by in addition with with the
house I'll handles dependency if you
have a library that you're pulling in
from like say Google guava which was
previously named differently the name
escapes me which previously had a
different name and you've got to
dependents these ones pulling in the
older name of the project and the other
ones pulling in the newer name of the
project with Gradle you can say well
these two are the same project it's just
renamed it will only import at once
right so you don't end up with two
different two versions of Google guava
under different names on your build
process so there's actually huge this is
just a small subset of the differences
between the two of them but Gradle has
got just there's quite a few other
benefits to Gradle and quite a few other
differences to it with that now question
is why use Gradle besides just some of
the reasons why i have given with
dependence with the better dependency
management and build system one of the
major ones is that google has switched
over the android has switched android
over to using Gradle so this is a big
commitment and a large block of
developers will now be using Gradle
going forward for doing Android
development so this is definitely going
to push tooling and other things forward
so this is the real shot on the arm for
Gradle so the questions so sitting here
in this presentation you said you want
to go home and go back to work and use
Gradle do you need to learn groovy in
order to use it the answer is no but
it's a good idea you can you can
you can write you can write plugins for
Gradle using Java and for many of the
common things that you have to do out
there there's either plugins already or
snippets of code that you can you can
paste and so no you don't have to be
next you don't have to go out and and
read the thick groovy book in order to
and then read the Gradle book after that
in order to use Gradle it's got a much
smaller learning curve do you need to
completely refactor your code base no
you can specify where depend where the
source code files are where your test
files are too Gradle and it will build
with them so you do not need to go out
there and stop all development while you
refactor your code base do you need
additional IDE plugins in order to use
Gradle most likely yes unless you're
using IntelliJ you'll need you'll need
plugins for it alternatively Gradle can
generate does have plugins that will
generate IDE native projects for your
project for you so it can generate an
intelligent project that can generate a
Eclipse project for you do you need to
change your build process it depends so
switching over to Gradle it's probably a
good idea to read to re-evaluate how
you're building things in a process
because there's different ways of doing
things do you need to pour it over your
entire build system no you can pour it
over pieces of it you can invoke a great
parts of you can do like new modules in
your system and invoke Gradle from Han
tor for maven there's ways of doing that
and can you embed custom and logic so if
you have a heavy investment in some ant
scripts that are doing all kinds of
customized stuff you can embed that in
your Gradle files and you can use that
you don't have to rewrite everything try
to figure out how something that was
written ten years ago works must all
dependencies originated from a
repository no you can have deposited
reply dependencies coming off the local
file system etc can artifacts be pushed
to a central repository so if you're
using something like artifactory or
nexus yes you can publish to it and does
it work with jenkins it certainly does
there's how to's them how to run it it's
basically you know like using an tour
or mainland so why Gradle for java ee
projects well java ee projects are large
and complex and we've got millions of
jar files and complicated build
processes that have to go in there so
for java ee projects you know we have to
you know we might be doing wisdom we
might be generating code from Wiz dolls
you know generating wisdom code from
from Java code we might be running Jack
speed logic to import to convert xml
schema files into objects using Jack's
be running you know complex integration
tests with a container where we want to
fire up a database run some tests do
integration testing stub out stuff using
like our Killian so we've got all kinds
of very complex stuff that has to be
done and for which you know a couple of
robust build tools is beneficial so in
terms of you know why you know why
Gradle versus ant ant lacks dependency
management being a major one among other
things and large amp files are a
nightmare to debug especially the 20,000
line varieties written all kinds of you
know complex logic ten years ago maven
isn't flexible it wants its its way or
the highway type approach with things
and very often you have it's you have to
end up having to write custom plugins
for it which is kind of a black art and
then deal with turning to version those
and get those into your build process so
getting up and running with Gradle if
you haven't done it already is fairly
easy and it's installation is similar to
aunt or maven it is not terribly
complicated you download the binaries
from Gradle org you set up your add it
to your path you Radel home it is a
command line program right like Anton
maven so instead of an through maven or
mvn you got Gradle and the installation
structure down below is fairly
straightforward it comes with excellent
documentation instead of web pages which
are handy if you're flying if you're on
a flight need to get some documentation
but it's fairly straightforward and on
top of that although I put up here the
command line it does have a GUI
interface to it which I'll demonstrate
at towards the end of the presentation
which allows you to invoke invoke and
manage the build from a GUI myself
standalone Google
with it so it's the only build system
that actually comes with its own desktop
GUI so the key Gradle files the build
file is build decorate them so the
build.xml and that uses groovy dsl
configure configuration settings go in
settings a cradle the local settings are
in your home directory Gradle that great
old up properties and you'd put like
your database settings you know like if
you're if you're doing integration
testing you put your database settings
in there the local repository is under
your project cradles of course you
wouldn't check that in and the build a
cradle is equivalent to your palm and
build XML except it's a lot shorter than
either of those two so the Gradle Damon
which I mentioned by default or earlier
is enabled by default you should if
you're using Gradle you need to disable
it on your continuous integration
environment so by default out-of-the-box
Gradle runs the daemon by default on a
continuous integration box you do not
want that Damon running behind the
scenes you want every build to be fresh
you don't want to do any Cashin or
anything behind the scenes and so this
is a recommended becks best practice
from from grail you can display the
current status and find out how many
Damon's are running by doing Gradle
dadash you can stop Damon's by doing
Gradle dash stop and then down below
there's the setting that you can put in
your configuration file to disable the
Grail Damon for like a continuous
integration environment ok I'm getting
up and running with Gradle is fairly
straightforward so from the command line
you can issue Gradle in it which will
create a new project can create the
initial set of files for you with some
pre-populated values in them it will use
the palm pile if presence so if you have
a palm pile in the directory it will
actually read those dependent it will
read the file and try to create a Gradle
file based upon that that is still an
incubating feature so it does not get
everything right so I tried on importing
the cargo tracker java ee demo
application and it got it mostly right
so the only thing it did not get right
was the profiles which you'd have to
which you'd handle differently with
Gradle anyway you wouldn't take the same
approach that made me
just because grails got more features in
that in that area so it gets it gets
emotionally done it gets the most of the
it gets all the dependencies in it gets
a sub projects done correctly but you
know it's it's a good starting point it
saves you from a lot of repetitive code
editing and copying and pasting but it's
not not the end-all and it can it does
handle multi-module project so you can
an aim it at a suitably complex maven
project with multiple modules and we'll
import it optionally when you run the in
it you can specify that you're creating
a Java library a scholar library a
groovy library and we'll set up the
project types based upon that with the
initial the default plugin basic
basically does nothing and just critical
sorry it creates a build file in the
settings file but doesn't create any
source directories for you and it sets
up to use by default J center which is
quickly becoming the default repository
this one I've been reading has evidently
it's it's has got some security
enhancements over than the maeve it's
better security wise in the maven one it
uses https and in addition it doesn't
have the indexing performance problem
that you have with maven repositories or
so I've read there's documentation says
that the the reason and reason google
picked at j center for android is so
that they wouldn't have to deal with
that could reduce the startup time of
the Ides when reading when indexing the
repository so if we run Gradle in it you
know with type library creates this
directory structure over on the right
with the initial setup files now if
you're starting from an existing source
code project obviously wouldn't take
this approach you create your you might
still run in it but you would start
editing your build.gradle file and
specifying the paths for your source
directories and where that stuff is
located and we'll see that and see that
in a minute when I actually go through
that the initial Gradle file that gets
created is as a bond screen so it's a
pretty straightforward file we've got it
has applied plugin which will over in a
minute with the plugins mean the
repositories and
the dependencies down below so it's much
more compact there's there's a ton of
comment it puts in a ton of comments
initially to tell you what's going on
you can strip all all of those out but
this is much more compact than the
equivalent pom file and certainly much
more compact than the ant file okay and
then from the command line to actually
build it you run data Grail and then
dash Q for quiet if you want to suppress
some of the output but you can run
Gradle to find out what you can execute
because your first question when you
start using Grail is you know what tasks
do I have available what can I run and
Gradle dash tasks will give you
basically dumped and tell you what tasks
are available to run so as you can see
her run dash tasks and we've got you
know assemble build and they're grouped
into categories for you and I'll show
you how you can actually create your own
groupings for your own categories
they're pretty close to the ones that
you expect so if you want to do a build
of your projects you do Gradle you know
build to build your project and this
will go through your files so there's no
more like with ant having to open up the
file and say okay what tasks are in this
file which one do I execute you know
which one generates wisdom files so just
some more you know in it rapper rapper
will generate rapper files which you
include with your which you check into
version control and those rapper files
are basically a bootstrap for doing your
build process so this is that that where
I mentioned before that you want to
version your build process so that if
you check it out 10 years from now it'll
still build the same version of Gradle
correctly and then a bunch of other
things for you know working your model
projects etc and then build output goes
into you have your standard snapshot
that goes into the output so and we'll
as we go through this will eventually
get to the very complex Java EE projects
and tests there but first question with
with with Gradle we have the concept of
projects and within projects we have
tasks this is very simple a similar to
ant and also doesn't agree with maven we
can have dependencies between projects
dependencies between tasks
and then with the build file that's a
high level the two things that our
projects and tasks moving on to it
within the build file we have so the
question is when you're editing a build
file what's available how do you know
what to type and what you can enter so
the build file itself corresponds to the
project object right so the build Gradle
file basically the current context of
the project object so if you pull up the
documentation the actual Javadoc for the
project object in Gradle that gives you
that that will show you what methods
what variables you have access to etc so
as you can see the apply apply plugin
there's actually an apply method right
for repositories further down there
should be actually a property so all of
these map to so dependencies gets mapped
to the dependencies so there's a
one-to-one relationship between the Java
classes and the contents of what goes
into the file and this is the same for
tasks as well so when you implement the
task within it you're working off of the
task objects you're dealing with objects
okay and then the same thing with tasks
as I mentioned so here we've got you
know as you'll see when some of the code
samples we've got first last you know
enabled the enabled property for
enabling or disabling tasks so in terms
of defining task so it looks a little
bit different than and so we're actually
the first one is defining a task and so
the the properties description is a
built in property where we provide a
description it will print that out on
the command line the EXT is basically
we're adding a property dynamically to
the task object for this particular
instance of the tack object which is
just an ad-hoc property that we can
access down below and as you can see
since we're using Ruby we can we have
access to the string interpolation so
it's actually that ad hoc property is
getting interpreted in there and then do
first as before it executes its dual
asses afterwards and then the next one
is just different syntax for basically
doing about the same thing we're adding
printing some stuff out and then the
third approach where we're using you
know the the closures so this is all the
first three ways of basically defining
tasks and then the last one down there
we're actually creating it we're
instantiating a copy task and we're
configuring it to do something right so
we're basically kind of you can kind of
think of it as if we're going to San she
ate this copy copy tasking and we're
going to pass parameters to have a do
something to copy a file in terms of
task dependencies we can have tasks you
specify depends on you know the order
sorry the dependency so the third
depends upon the first and the second
and I've set the default task for the
file up at the top okay I'm one of the
nice features is we get task grouping so
you can actually specify define a task
grouping and then we can put the tasks
in that group so that when we do that
listing of task from the command line it
shows us the it shows us the tasks
nicely group so you can group all of our
tasks as we go through this like all of
our doc or tasks in one block all of our
wisdom generation tasks and another
block and so the IDS like IntelliJ on
our the grouping so here have added my
grouping and you can see it has it over
in a little pop-up window and displays
the tasks underneath it now one thing
that I've kind of touched on with some
of the code samples thus far are plugins
so as you can see there's a bunch
there's some plugins are very important
to the ecosystem interactions going to
be using many plots seeing many plugins
as I go through this presentation today
so the default one that that for java
projects that we have by default is the
java plugin which includes you know
logic basic tasks for doing compliation
generating a jar file running java dot
generating Javadoc etc there's also an
application plugin and then there's a
maven plugin for being able to use to
from maven and the ones that we're
primary are going to be interested in
with today are the ear plug in and war
plugin because that's what generates our
java ee artifacts for
there's also a idea an eclipse plugin
for generating the project projects for
each of those IDEs there is a huge
ecosystem of plugins and very often
there's several plugins for the same
type of task so there's at least four or
five different at least four or five
different ones for docker which will be
seeing so there's a huge ecosystem of
them out there to choose from and it's
easy to write your own so that being
said moving on before we actually get to
the Java EE stuff there's great Oh
supports multi module projects so
there's two different ways of doing this
there is the hierarchical layout and
then the flat lay out in the flat
layouts where you're different your
modules are all under the same directory
and then you've got to build file with
all the build logic in it whereas a
hierarchical you've got one overarching
build file and then the sub each one of
those sub modules module admin admin web
etc they each have their own Gradle
build file as well so this is kind of if
you're used to the the maven approach
we've got the maven pom file and pom
files in each one of the sub modules is
basically the same thing and this is the
approach i will be using throughout the
demos today in the presentation so the
hierarchical layout just kind of driving
home the fact that you have a build
Gradle and the settings that Gradle in
each one of them so we've got the
overarching project with the build-out
Gradle and settings that Gradle and then
Gradle files for each one of them now
one of the nice things with Gradle and
with Java EE projects is that we can
specify up we can specify a common set
of settings for all of the sub modules
so we can say you know all of our sub
modules are going to be java-based
they're all going to use Java 8 we want
them all to have idea project files
they're all going to be version 1
they're all going to pull there's their
dependencies from maven central right so
we can at the high level project we can
define a bunch of things so that we
don't have to paste the same thing over
and over again in each one of the sub
modules and then in the top level so
this is the top of a project on top of a
project we specify which
r sub modulus which ones are we included
and so whenever working with any of the
module is great it will look at the
upper project and look at you know which
projects are a part of it to figure out
what needs to be built okay so then in
the sub modules you'll have the root
project name which will be the name of
the the overarching project so in the
case of this example it's CT Java and
then each one of the sub modules in
their settings file says you know my
parent project is basically CT Java and
then we can declare dependencies in each
one of the modules on another module by
saying compile and then we're depending
upon you know core project depending
upon how far we're drilling down okay so
it's very easy to define dependencies so
within a module you can say this module
depends upon this other module from the
upper level module you can say all the
modules are using Java 8 they're all
using this this set of configuration or
tasks so we can even define tasks for
all the projects in terms of IDE support
this can be a bit challenging so for for
java ee projects you will need or I've
only had luck with the ultimate edition
one that you have to pay for other than
that when i tried to use the community
edition it doesn't recognize like the
the tag the like the JSF tag libraries
it refuses to recognize those so you
very much need to if you're for the
intelligent when you need to use the
paid version it does support java ee the
NetBeans I've got the NetBeans Gradle
plug-in to work with simple projects
with multi-module projects I've had
trouble where it doesn't actually
recognize it correctly which is very
frustrating and when I have done when I
have loaded just a simple war project
into NetBeans you lose you don't have
all of those nice context menus where
you know you want to run the project in
glassfish or or in Tommy he it doesn't
it doesn't he lose all of that context
stuff so hopefully that plugin will move
along eventually and then for eclipse
you will need the Gradle plug-in Gradle
where does provide a plug-in for eclipse
which is fully fully featured so
installing the Eclipse plugin
you have to download and install that it
does not come by default so you just go
to the update Center you can get that
off of their website for the NetBeans
one to add support to NetBeans you need
to go into the plug-in and download it
download the Gradle support via the
plug-in dialogue so the only IDE out of
the box that supports Gradle is a
IntelliJ and if you're doing the EE
stuff you need the ultimate edition so
let's look at so the first java ee
projects just kind of try to demonstrate
the power of being able to migrate over
an existing project i'm going to take a
a wharf a war file that's created an
epic as created a java ee project
internet beans using ant build and
convert that over to Gradle right
because the this project structure that
NetBeans creates for examples is not
compliant with it's not what a greater
would what the Gradle plug-in would
generate or used by default and that's
not what maven would use so this is just
kind of a good example so here we've got
the the filesystem view of it so we've
got our source code under source test
good on your test or web artifacts under
web so it's not the typical like maven
type layout and then under we've got our
Java classes configuration files etc
okay so in order to port this over we
create one file melissa's this is what
it took to port that project over and on
top of that there's there's one other
constraint that I added in there for fun
which was a custom library that wasn't
available in a Content repository right
so you know some output of some other
project so this is the Gradle file to
pull that over so if you look at the
gigantic Gant file that NetBeans
generates which you know probably prints
out to like fibers you know 10 or 15
pages this is the equivalent file so we
have I use the IntelliJ plugin so I
could open this project and IntelliJ
I've got the Java plugin oops I've got
the Java plugin i specify that
the that we that this is going to output
that this is going to use the war
plug-in i specified my set central
repositories i use a pull in the lib
director so down down here where is it
so this is the going to pull in the
libraries from the file system the one
that's not in the central configurations
for the closure compiler I get my iPad
that there that's from another project
but anyway so down here i specify the
location of the source directories and
the resources so this this project
actually i cut it off I didn't include
the tests in it but this is all it took
to port that NetBeans project over into
Gradle okay it was very flexible and
then for our dependencies our custom
library gets pulled in right here it
looks in the local directory and appends
jar to it to pull it in and then for the
war plugin i specify you know that the
web directory has the resources the web
and you know and all the HTML files in
there so this is a bare-bones
configuration so this is all it took to
port that project over into Gradle and
then the configuration endpoints that we
have available for the war plugin we've
got you know from you know the location
of our web in the classpath directory
you know where we want the web data
where the web.xml file is being pulled
from etc
so that's moving over a simple file now
let's look at doing something a little
more complex so we have a complex java
ee project or let's let's look at doing
like mint javascript minification with
it so say this project had some in
addition to having some Java code we
have some JavaScript code and we want to
minify that and we want to use the the
the Google closure compiler so here I
include the Google closure compiler I
set up the output directory for where
the minified output is going to go and
then I have a custom job custom task
that I've written which extends the Java
exec task so this is a kind of thing of
this this is a java object which are
basically instantiating and extending
and i can figure it with the output
directory and i make sure that directory
exists and then i specify the parameters
to invoke the the closure compiler to
minify my javascript okay and then
finally set up the war task to include
the minified javascript and i've
included a flag to indicate whether
minification is enabled or not so that
if i'm a debug mode I'd you know unless
unless otherwise specified it would
would unless this is set to true it
would not minify the files so there of
course would be other tasks in there
because you'd want to you know change
the what actually goes into the faceless
files in terms of what files are
important because you'd also be doing
concatenation etc so that's that's a
basic example more sophisticated example
on the next one looking at Java EE if
you're using the criteria API with the
jpa metamodel right you need to generate
the metamodel from your entities so in
case of doing this here you need to
write a custom add a custom plugin I
haven't found any plugin in a central
repository that does that but you'd
brought bit rate this basic Java
annotation processor which is going to
use Eclipse link and part of the
challenges in the
a sand in this example here is using
eclipse link which doesn't work well
with the like the Java 8 annotations
some of the changes in Java 8 so it's
still it's still like Java 6 so I can't
see any it can't come it can't process
some of the newer some of the newer CDI
code I believe if i remember right so i
actually have to isolate it when it does
the violation so this is so up here this
is a groovy class or of extended default
task and i've written a lot the logic in
here actually invokes the annotation
processor to generate the the JPA
metamodel which I'm then going to
include in the source in a separate
source directory as a part of the build
so that I can then use this in my class
files so then this this right here is
more of the plug-in where I set the
destination and the source sets to add
the generated source code to the build
output of it and then using the in order
to use the the plug-in I need the Gradle
API and local groovy added to the
compile time and then this proc Java
which will run selectively over the idea
of the data model and generate the JPA
metamodel for my project okay so this is
depending upon your project you may or
may not be using the JPA metamodel to
build up type saved queries if you're
not you don't need that but it is
possible to do it moving on to more to
the next I guess the next level 44
Gradle which would be handling ear
projects so if we have a suitably
complex ear prod a fairly simple ear
project but one with an ear ejb a web
module etc and we want the output of
course to be you know the standard you
have our ejb jar file or our web jar
file etc then the directory with our
library directories we'd use the ear
module to accomplish this this of course
is fully configurable so we can figure
it where the differences we can specify
the deployment descriptors so we specify
under the dependencies the ejb module
the
the eager lib which project to pull for
that and so that that's that's that's
basically all I mean the documentation
that's online is fairly comprehensive
for the for the settings are available
for this but this is basic this is all
the code that you need to write to get
an ear module up and running with Gradle
so if you compare that compare this to
like the amount of code that you have to
write an ant build file is it's a much
simpler now if you're if you're working
on something that's the war plugin
provides the provided classes scope so
Gradle by default does not have the
concept of a provided scope which you
have in maven provided being your job
EEE ap ice so you don't want those
bundled up in your in your war file so
if you're not using the war plugin or
you're doing a project sub-project you
want to make sure that you do not
accidentally include the other
dependencies you can use you can define
as I mentioned the introduction Gradle
has the ability to add scopes so in this
case here I've added a provided scope
specifying that the classpath for that's
going to include the java ee 7 AP ice
right and then i set up the IntelliJ
module to include that provided scope to
match it to its provided scope and then
I've added that to the compiled
compassed path for the source sets and
so this is basically adding a provided
scope to a non war based project so for
whatever reason i'm not i'm not using a
war plugin and i needed to add the
provided scope that's that's how it
would do that now one of the other
common tasks with with in java ee is
using jack's b to do code generation so
in this case i have a i specify i'm
using the Java plug-in of course and
then I pull them that there's a
third-party plugin that wraps the jacks
p compiler which generates the java code
from the xml schema files including my
repositories in this case here of
included both j center maven central and
then
the the Jack speed dependencies and then
I specify for the jacks so this Jack's
be plugin has a configuration point so
those under Jack's be in your file you
specify the configurations for this
plugin here underneath Jack's be and I
specify my schema directory and when i
run the build it reads in the files that
are in that schema directory and
generates the jacks be entities for me
right so moving on to the jax-ws client
so very often you will have you want to
generate you're invoking another web
service you have the wisdom files you
want to dynamically as a part of your
build process generate the client
implementations of those classes so
there's a plugin for this that's
available the the name of is this WS
importer plugin so the generated source
will end up actually under so you'll
have you place a under your meet your
source directory you'll add a whistle
directory with the package name of
package containing wisdom file and it
will put this generated source code in
this package for you I'm actually in a
separate location that's not in your
classpath so anyway so that's that's
that and this is the actual Gradle file
for generating the generating that Java
code from the wisdom code so here I'm
applying that plug-in which is actually
going to come from the Grail plugins
repository set up the classpath for it
so this is setting up the builds to
dependencies for the build script
dependencies that are being pulled in
for the build script and that's
basically it it scans through the
classpath and looks for those wisda
files and then in under the build output
directory you'll see a generated source
with your source code and that gets
added to the source code source set for
your project so that when you build it
or when you work with it in the IDE
you'll have access to these classes and
you can call these glasses and invoke
the service so this is an example
of generating a jax-ws client web
service client for that as well and
there's there's other plugins out there
for for like processing swagger files
for like rest of 11 points so there's a
huge as I mentioned there's a huge
ecosystem of plugins out there that can
do just about anything that you'd want
to do so moving on docker images now
there's two different things that you
might do two different types of tests
that you might want to do with docker
with Gradle so you might want to use
docker to actually build Gradle images
so you might want to have your output
one of the artifacts of your output of
your build being a docker file right so
you you build your app to be deployed
and you also build an image with the
deployed to Tommy or weblogic etc and
upload that to your repository or you
might want to run docker during testing
has to help to aid with the like
integration testings so for an example
one use that I've used the the doctor
execution during build time is to
actually use a docker container for the
for the integrations test for the
database right so as opposed to having
to set up and maintain the database for
running integration tests which every
time that the tests are finished running
you want to destroy the database you
don't want it kept around you on every
developer having to have a database can
use the docker instance for this so as a
part of the build before it runs the
test cases it launches the the docker
runs the database and dr. and once once
the unit tests finished if if the unit
tests were successful it destroys the
docker the docker container so I don't
have to go in there and do any
explorations afterwards so for so for
running that the easiest one is the
planet to docker plugin which gives you
the ability to which this can also build
docker images although I haven't used it
for that it gives you the ability to run
so it's got this plug duck or run plugin
which makes it easier to run just about
any docker container for building docker
images there's two plugins and depending
upon which one you want so this one the
transmode allows you in docker to build
up the docker build up the docker image
basically within the Gradle file where's
the other one will actually use the
remote dock or API and a docker file
that you provide usually I'm working
with an existing docker file so i use
the second one even both of them are
suitably powerful enough so for building
a docker image this is Gradle file which
basically uses an existing docker file
that's in the build to generate a docker
image so i specify my plugins up above I
need to include this class because it's
use down here in the task for building
the image so i specify my plugin for
being the remote api the second one on
the previous slide and then the location
of where docker is running and then it
runs it uses that it finds a docker file
in the current directory build runs
build on the dockerfile tags it and puts
it puts it in a local repository so this
is all code that was required for doing
that for integrating building a docker
image into my into my build now the more
complex example so this is just running
this is just how to run a docker
container from a Gradle build so here
I'm using that planet or docker run
plugin that I mentioned earlier
specifying my that employing it from the
Gradle plug-in repository setting up my
dependencies for that so this is the
dependencies for the build script and
then down here I provide the
configuration for the docker run so I
want to run the postgres I want the
image I wanted to be named docker dash
test and want the image to be postgres
and when it's run as the daemon wait you
know sleep for 100 seconds or 100 I
think it's 100 milliseconds afterwards
to make sure it started up before moving
on to the nest task and pass in the
password now I could parameterize that
and you know put it so this this
password here I can then use and
elsewhere in the thing so using running
this file and run running this Gradle
file and typing docker run on the end of
it will actually fire up the postgresql
container for me as a part of that so
that's that's all nice but so let's look
at a example of integrating this into a
bill
integration build we're running our
Killian tests and we want to fire up
docker with our database before we run
the test then and then tear it down at
the end of the tests were successful so
to do that the first thing we need to do
is to basically register our own test
monitor implement the test listener
interface to keep track of any test
failures so here I'm within the within
the i'm going to register this as a
listener on the build process so that
when it runs the unit runs the unit
tests I get told after ever it runs
every test and I can find out the test
results for every test that it runs
where the test was successful or not
right so you could even you could do
something like this type of integration
like if you're doing a build and adding
unit tests for hours and hours you could
have it starts sending out you know text
messages you know after the first test
fails if it takes like in six hours to
run your foe regressions so this is the
the docker file right here where I'm
pulling in the test monitor the build
script pulling on the planet or again
and then what I've done down here is
I've added a listener to Gradle so I've
registered a listener on the to listen
for unit tests successes and failures
and I set up the test test so i'm
actually changing the dependencies of
the test task right so i'm saying that
the test depends upon run so that before
tests can be run the Gradle script will
run my dot will run the docker run that
I pulled in from the plugin and then the
test is finalized by can kind of think
of this is the finally block docker stop
and so it'll run docker stop after it's
done however in my code back here what
I've done is I keep track of the number
of failures so if any of the tests fail
I say disabled the docker stop task so I
set so i get the so i retrieved from the
project the doctor stop task which has
been pulled in as a plugin and i set set
the enabled the false which disables it
and so if if any of my unit tests fail
during the during the execution will
leave the database in place so i can go
look at and see what the data what the
status of the data and the database
wasn't know what did it insert wrong
what was the final state
so that's that's that that's looking at
dr. integration now a few more things
for java ee one is working with running
integration tests so very often for your
configuration files for you'd want to
pass in like the database parameter so
if you're not using if you're using
docker like on a continuous integration
machine but the individual developers
are using databases you can actually you
can use the maven plugin for actually
doing the substitution on your file so
in this case right here I've templated
out my persistence XML file with the URL
and database passwords etc and then
within the build file I am pulling it in
from my these are actually getting
pulled in from the Gradle properties in
my home director like you would do with
maven pulling in the settings that are
then getting blita din to the
persistence that XML so that my
integration tests know where to X what
database they're supposed to use this is
also demonstrating the the do first on
the test a store right here I've
extended I've changing with adding
behavior to the test task so before it
runs the tests making sure to copy my
beam stud xml files over so that my
beans discovery value is correctly set
for running the integration tests so
this is you know if you've ever wrestled
with maven where you didn't have your
beans of XML copied over when you dredge
run your integration test is very
helpful and then the last part in terms
of getting Gradle up and running with
arquillian it's just a matter of
including the dependencies and your
Gradle tests yes or your arquillian
tests will just run so I have a complex
set of integration tests which fire
things up and also run and docker so
this all works out of the box so there's
nothing there's not that hard so it's
very easy continue to use merculian and
then in terms of a couple of additional
things for for Grail just some
miscellaneous things I've added in you
can do
so for example we've got a bunch of
anything so for we can do you run the
Gradle you I first so I mentioned at the
beginning of the presentation this is
the only build system with its own UI I
can run the Gradle you I going to start
up takes a minute because it's actually
analyzing the project
hopefully yep there we go so let's get
built up a tax-free so you can actually
invoke Gradle and control it from this
UI so it's the only build system that
has that now there's also dependency so
we can print out the dependency tree and
there are plugins that will allow you to
look for conflicting dependencies and
various other things we're doing
analysis on this but this is going to
print out for this project
so as you can see for this is actually a
fairly basic project but it's pulling in
tons of dependencies so we can actually
look through this to figure out where
various dependencies are getting pulled
in from you can do a dry run so Gradle
build will show you what it's going to
do if I if I ran the build so as you can
see because I've rip run the bill before
there's nothing to do so everything is
going to be skipped so that's one of the
other things with Gradle one of the real
benefits is that with the incremental
compile it knows what it built last time
so if you run if you if you change one
module if you change one source code in
your project you go back to Gradle and
say build it only builds what changed it
doesn't build everything it doesn't
recompile all the source code files for
that module
and there's also a great old profile
I've got a couple of profile reports
open already ports
so this is built integrate all this
isn't a plug-in
so here we can see where the where it's
spending time on the builds you know
each part of the process so I mean this
is a very simple example in a very
simple project if you scale this up to a
one of your a large enterprise project
having this type of thing you know you
figure being able to troubleshoot you
know the build time suddenly went up
today somebody checked in some code
somebody checked in something yesterday
and where where where is it spending all
of its time so great was God's got
built-in profiling support so we can
look at configuration dependency
resolution tax execution you know where
did it do the work and how much time did
it spend doing everything so this is
very powerful being able to have this
level of insight into what's going on
with your build and so with that old
thank you and if there's any questions
yes
so you're so the question was whether to
do top down or yeah
it depends upon how much depends upon
how complex your build process how many
plugins you're using and the the
sophistication with the plugins right so
if you've got a very calm pits if it's
just a large project with many palms and
all they're doing is basically
dependencies then running the in it and
having it out put stuff but if you're
using profiles you're using custom
plugins all over the place I would
probably take it and go one at a time
for doing it and take that and take that
approach as opposed to train it as
opposed to trying to tackle the entire
thing at once I don't know that's
usually I decompose things and for most
of the ones I've had where I've been
dealing with this trying to move stuff
from hand over to Gradle not necessarily
from maven to to bug rail any other
questions
yes
ok
yes in fact you saw one of the examples
I used a maven plugin in my build so yes
it is it will be dependent upon the
plugin oh hopefully yeah I don't I have
not I've not I've only worked with
simple plug ins with that I don't know
what that plug this will be dependent
upon what that plugin is doing in terms
of how easy it will be in order to pull
it it yeah yeah other questions okay
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>