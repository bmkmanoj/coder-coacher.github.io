<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>“Please Log In”: Authentication and Authorization in Java SE and Java EE | Coder Coacher - Coaching Coders</title><meta content="“Please Log In”: Authentication and Authorization in Java SE and Java EE - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>“Please Log In”: Authentication and Authorization in Java SE and Java EE</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pBDqIavwMYw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">first of all thank you very much for
coming early this morning
in this session I talk or talk about the
authentication and authorization API in
the in both Java SE and Java EE so the
roughly the first half of his
presentation I talked about Java SE it's
a jazz API and on the second half of the
presentation I show you the Ramzan road
in Java EE and just because API which
appeared in Java 6 before I start let me
introduce myself my name is Maya Mira I
work as a software engineer sorry so you
probably don't know sorry
because it's a French small French
engineering company but we are focused
on the Java platform and what particular
and sorry is that we are dead we know
dedicated to contributing to open source
so up to 10% of the our workforce is
dedicated to contributing to open source
project in the Java community so thanks
to this strategy we we could contribute
to some some big Java community projects
such as well which is the CDI
implementation or GlassFish or so
recently the ceilin jvm language service
also very involved in the local
community because it's the main sponsor
or an organizer of our local Java user
group and offer a one-day conference
which takes place it's here now which we
caused edge at summer camp but let's
start with the Jazz API under AC so
first jazz
it means Java authentication and
authorization service so it's an API
that has been around Java for a long
time now because it was available as an
extension since Java I see went 1.3 and
it was integrated in JDK 1.4 so it was a
quite long ago the purpose of of jazz is
to provide application a way to stay
independent of the login of the
authentication protocol so the
application actually delegates the
authentication to an external module and
the application doesn't know the
authentication protocol that is an
underlying jazz also allowed to define
user based security words in your
application
so to control the access to your
application so let's start with the
authentication part so as I said you're
in regis applications delegate the
authentication process so they get it to
a login context which is actually an
external configuration and login context
can call one or more login modules the
login modules they perform the actual
authentication so the login modules or
the only only part that is bound to a
given technology before we go over there
I need to give you some quick
definitions in the jazz world when we
talk about a subject
it means the authenticated user or
service that is executing the
application and a subject can ask
principles and credentials the
principles are the identities of the
subject so it's user name typically or
it's grouped and the credentials are
information that are used to
authenticate the subject so it can be
for instance a token
so in this model is the application
delegate authentication to rag in
context and login modules but this login
modules often need to interact with the
user so just provides a way to do this
through callbacks so when the login
needs interaction it calls the
application and the application performs
the interaction so I show you some code
to perform actually an authentication
we've just and to configure the elegant
context under so to to use the callback
handler for our user interaction okay so
yeah I have a simple main class which
actually only performs authentication so
it's more clear to to see the code so
using the Jazz API we create we load the
login context by giving a name this name
my login context here references and
external configuration but there sure
you just after from the login context we
simply call login and then if we don't
have a login exception then we can
assume the authentication with
successful so authentication is really
simple just now to configure the login
context you simply use a log in that
config file
so there's the system file and the JRE
and you can use your own files and this
configuration consists in simply listing
login modules so here I'm using the NT
login modules which will take my Windows
authentication information
I'm telling us that it's requisite so
I'll talk more about the policies later
but here it means this module must
succeed
for the user to be authenticated
I can pass some parameters so here I
activate the debug mode of the alleged
module so when I run the application
okay I hope you can see so all the this
early detection in white is the debug
mode of the Dragon module so the lagoon
module is showing everything from my
windows authentication information to my
name my domain in my groups and my
application simply says ok
authentication was successful now I open
another project which is roughly the
same but I will use a callback handler
and another again module which requires
user interaction so this logging module
uses a hysto and it asked from for
Nadia's of the key the password of the
key store and the password the optional
password for the key and to provide
interaction with the user when I load my
login context I also pass a custom
callback handler and this callback
handler simply react to callback objects
depending on the type so you can have
output callback which prints information
name callback to to read the user name
and the password etc
now when I run
okay so I have some debug information
here then the the module calls the
application to ask for the the key areas
the keystore password so I'm sorry this
is in French because of my system here
is infractions and then from it from
distant functions are again module
carries on and reads my my key in the
Keystone okay so let's continue with the
authorization part of jazz so jazz allow
the application to create user base the
access control rules so you can manage
permission at the at the user level and
in your application you can check
specific permissions but you you define
and you check programmatically so the
authorization needs three steps in jazz
first you can get the user information
once is authenticated so you can get the
subject from the log in context and you
get the from the subject you get the
principle and credentials you think the
subject you can tell just that you want
to run an action in the name of the user
so when you use do as orders privilege
you set the the authenticated subject in
the security context of the security
manager so the difference between us and
us privilege is actually if you use us
privilege only the user the subject that
you you're using is checked so if this
reflect has permission
it can run the action when you use the
simple do as actually the security
manager checks the whole course stack so
if you have different level of
authentication you have to check
everything
and finally in your new action you need
to check a permission to check if the
user has given permission so the other
access controller class here I show you
also the cut to three steps and I show
you how you can manage the user
permission in a security policy file
but the first part is authentication
here it's the same then we just read and
print the user information here so we
can get the subject from the docking
context then we print every principal
every public cannot create credentials
and every private credentials and what's
more important here we create a
privilege action which actually does
nothing but check the permission here
check the permission and it shows okay
permission is granted and we execute it
in the name of the subject here the my
permission here it's nothing special
it's just it simply extend the
permission class and with method of not
really interesting right now but you
simply have to extend permission and you
create your own permissions that you can
check to manage your permissions in the
Java policy file you can grant to a
given principal a set of permissions so
AI grant the principal of type and T
user principal which is me Maya
and I granting the my permission with a
parameter test so here again I'm using
the anti logging module
okay so yeah you see at the login module
is not in debug mode so everything that
is printed is from the application so we
show the principal so you can see in
principles we have the username the
domain there is groups so I could
actually set the permissions for for a
group of all domain and I print their
credentials here and my action is
running yeah because my permission is
granted now if I change for instance the
permissions let's comment this out
I can grant permission to the domain
which is bender here and we can see that
permission is still granted because I am
in this domain know if I set another
domain okay now I don't have the the
right permission so the access
controller throws an exception yeah
so this is how you enter a user that is
not authorized okay so I told about
policies for the login module because
actually in Allegan context you can you
can cost several login modules if you
want you can chain saraghina modules and
to control the behavior of this chain
you use policies on each leg in module
so I'm logging module can be required
which means the logging module needs to
succeed succeed for the overall
condition to succeed but the next login
modules will be executed whatever a
module can be sufficient which means if
this dragon module succeeds then you
don't execute the rest of the
eigenvalues it's okay it can be
requisite so it's kind of like the
required so the Riggin must succeed but
if it fails you stop and you don't call
the next dragon modules and it can be
optional which means we don't care as a
result we just want to try this dragon
module to get the principles and
credentials that are associated between
the modules you can also share
information such as user name and
password to avoid repeated repeated in
user interaction
now to finish and the Jazz but I show
you how to write a small login module I
guess someone so what you have to know
to write a login module that jazz music
uses a two-step login so for you should
take the chain of modules each module is
called one first time in the right order
for the login phase which performs the
actual authentication and when when the
overall authentication succeeds there is
the second phase for commit on each
module or if the other authentication
fails as the abort fate that is called
on each module and that also
initialization and logout that you need
to handle in the login module so I show
you some code on how to write a login
module with a request an damp user
password authentication protocol but
it's just for the demo actually 10
checks that user is the same as the
password
so my mean file my min classes are the
same there's nothing special here so the
logging module must implement the login
module interface I have some some
attribute yeah but actually it's only to
store the state of the Dragon module so
I won't go further in this now and the
method you need to implement as the
initial initialization so you get a
subject a callback handler the shared
state which can contain chat passwords
and options so you check your parameters
you stall them
you read the option sorry I have two
options which are debug and module
banner to print a banner when the module
is executed then the most important part
yeah
is the login method so here we do actual
authentication so for this plug-in
module we need a username and a password
so we will ask the application to give
us a username and password with
callbacks so we have a name callback and
password callback if the option is set
we also send the text output callback
with the banner then when we have the
callback array we we call the callback
handler yeah and we read the username
and password using the using this
information we call you know an internal
method to perform authentication so I
can show you but it's really it's really
done meth area simply cause not secure
but if authentication succeeded we
return simply true if it failed we throw
a failed login exception with the reason
why logon failed through the login as I
say this code on each login module and
then depending on the overall begin
result if the authentication succeeded
or failed
we caught the commit or about so commit
is when the overall authentication
succeeded but this given login module
may be failed if it's optional it can be
faked this module kind of failed and the
overall process succeeded so we need to
indulge both case so if this login
module failed just destroy it state yes
if this login module succeeded we need
to commit the principle and credentials
that we authenticated so in the in the
subject here we add yeah I only add a
principle but I could add credentials
too so I add a custom principle you know
which only contains the username and
then we clear require some some
information such as the password or
username so the other case is about so
it when the overalls indication failed
yeah or we we never commit to the
principle so all we want to do is
destroy so yeah you have to condition
but actually just for the for the for
the printing of what's happening but we
simply destroy the inner state of the
login module and finally in the logout
method we need to destroy every
principles or credentials that we added
to the subject
then the login configure simply specify
the class of our custom login module the
policy and the options so here we print
which was to print the banner so when I
run my application here's the callback
handler shows the banner and then it
asked for the username so I need user so
user and that's one must be the same so
user 1 user 1 ok yeah
password is the same so authentication
is successful if I use a password that
is different from the username ok they
login with your face
okay so that's it for the the Java SE
part now we'll have a look at Java EE
so in Java EE before Java EE 6 we had to
use rounds and rolls round for
authentication and roll for
authorization
so in Java EE the container offers a way
for further another indication of
service to the application so the on the
web layer you can set security
constraints and you can set realms to
define your your set of users but I give
more info just after the API offers the
Sunda a way to express access control by
using roles you can specify which role
can access which resources and the
enterprise and web application actually
delegate authentication and
authorization to the container so here
again a small set of definitions to the
realm it's actually a channel to access
a storage that contains the user
information and the grouping information
users and groups users can be an
individual or a program which is
accessing the application a group is a
set of user and a user can have several
groups generally and what's important is
to understand the difference between
user groups and roles because worlds are
only an abstract name which which
actually is the permission to access a
particular resource in a particular
application so for the to use the
authorization with realms we follow
three steps so the first is to create
your users and groups in your
and your run then you define your
abstract rules in your application the
visceral can do this this world can do
that and then you map your users and
groups from the round to your world in
your application okay so the first step
is registering you registering users and
groups and you know actually it's
totally vendor specific because your
realm can be can access a file database
and held up whatever and the actually
the configuration of the realm in the
Java EE server is also vendor specific
so depending on your Java EE server you
have to configure okay I access this
room which is a fire or which is the
database on your application you define
your roles so yeah it's a standard way
it's $10 API so you can define rows on
each jb's level so you can use the
deployment descriptor or annotations now
so you need to declare the roles in your
application you need to to tell which
roles can execute an EJB class or a jb
method and you can tell okay this EJB is
nobody can use it obviously everybody
can use it
you can also declare roles on the web
resources so it's defined on the web
tier using a third security constraint
so you declare which resource are
restricted and which words are allowed
to access the resources finally to map
your own through the users and groups
here again we are back to a vendor
specific January deployment descriptor
to map one role to one or more groups
and users and one user or group to one
or more rows now for the authentication
part actually authentication must be
performed by the web of the up client
chairs
because eg bees don't have a way to
perform authentication so the EJB
container only relies on the propagated
identity from the other containers so we
focus on the web tier here on the web
tier you can define security constraint
in the deployment descriptor in with
security constraint you define actually
resources collection so you specify
which resources of our restricted by
giving a URL pattern and HTTP method set
you you also define an authorization
constraint to specify which words can
access the given resource correction and
actually to tell the Jie container to
perform the authentication you need to
add the login configure in the
deployment descriptor and the Reg in
configure defines the authentication
protocol so under standard protocols you
have three types of authentication that
are supported the basic can digest HTTP
authentication which are nearly the same
so it it uses the HTTP headers to
perform a sonication
with username and password you can use a
form based authentication well the
application can provide the HTML form to
further input of user username and
password and finally is the client
certificate authentication was a browser
of the client sends must send its
certificate I show you quickly how you
can configure around so I'd use
GlassFish for the purpose of the demo
but it will vary depending on your on
your java ee server i'll show you how
you do write your application using the
$10 api and you know i use a simple
basic HTTP authentication protocol
okay
okay so yeah I have a simple web
application where I have a public
servant and a private servlet so of
course the private servlet will be in
the restricted area so yeah I define
victory a security constraint and
everything that is on the path private
so my private servlet easier I configure
my application to authorize the role
authenticated user to access the private
page and I set a login config with
automated basic and I said Terrell name
here is fine because it's one of the
default realms in GlassFish it's around
that stores the users and password in a
fire and finally I declare a list of
road but are used in the application so
if I look at the Servet yeah both my
public and private servlet do you know
is the same thing they try to call an
EJB several operations so one that is
public one that is secured so only for
the authenticated users and one that is
only available for the enemy so if I
look in my EJB okay
yeah this class level annotation I
specify the rules that are used in my
EJB so authenticated user and
administrator so no annotation here so
anyone can call this method yeah
the only world allowed is authenticated
user and
here it's an administrator
yeah yeah just GS please but get the
result of the the operations yeah now I
get a local GlassFish server here but is
running so I'll show you how it's done
figure
so this is the less fish admin console
so I go on the security part
I have the lift of my realms so the fire
realm is the one I'm using and yeah
because it's a glassfish specific realm
I can manage the users and groups
directly yeah so I say to my two glasses
that any user in this realm will have
the users group yeah and then in my okay
yeah we have the users group every user
so the last step is to map the group
users to the role in the application so
I do it with the GlassFish web.xml which
is vendor specific and yeah I set role
mappings to say okay the world
authenticated user in this application
is mapped to the group users and the
role administrator is mapped to a single
principle yeah which is the user admin I
will run my application
it's not not yet deployed
and just
drop it
so
okay so this is my public page so yeah
I'm the user is not authenticated so I
can only call the public operation if I
go to the secure area I try to access
the private servlet the server asks me
for from my username and password okay
so I'm authentic 18 here I'm user 1 so I
can call the private operation which is
only for authenticated user role but I
can't call the admin operation now I
need to clean the cash because Firefox
remembers what I what I typed ok now I
log in as the user which has the name
admin so I have the the role
administrator so I can use this
operation to
okay so that's it for the realms yeah
now I show you just peek which appeared
in Java EE 6 and which provides a
standard API prophets just big stands
for Java authentication service provider
interface for containers and it's in the
full profile and actually will just be
you can create standard portable and
pluggable authentication modules so
what's very interesting here is that you
can share mr. Gein modules across any
Java EE server and you have also to know
that it can work on the client and
server side so the purpose of Jass big
is message level security what's
important here is that the logging
module
well the authentication server
authentication modules can access the
message layer so this means your module
can access your HTTP requests or your
stop requests for instance so it means
you can write login login modules to
support more complex authentication
protocols such as SP nigo or open ID and
you can support actually any any storage
or like LDAP or database because your
logon matures course the storage he
wants just peek works with for
interaction points to end the client
side and turn the server side so I
focused on the server side because it is
a most common one on the server side we
have two interaction points which are
the validate requests so this operation
I'm sure he gets the clients requests
and authenticate the client then when
the client is an authenticated if
dispatch is request to the service and
then the response can be secure securing
the response is needed when the client
wants to authenticate the server so you
can sign the
Spence for instance in in your jazz peak
module and what what you what you can
see here and in this list rima that the
very date request can ask the client can
can send a response to the client to the
name you need to send me some
information to authenticate so how do
you configure just peek it's the most
painful part in GlassFish its
configuration is not standard so to
specify which module to use with which
application it's everything is vendor
specific and even to specify what I
start again in your application you want
to specify ok this application will use
this module and on your server you need
to configure some modules that are
available both sides or vendor specific
okay now the authorization part is the
same as with the round because it's the
world part so role part is the standard
API and it's it's a very very fine API
so you use your rules your security
constraint and a role mapping was
important is to not declare a login
configure the cause log in config
is for authentic authentication and
authentication is configured by
specifying the security provider for
your message for a message the
authentication that is you want to
specify your your login with your Jazz
peak module in your application so there
are two types of modules severus modules
and clientís modules so I focus on the
service server as modules today ok so I
show you how you configure your module
in the GlassFish server and how you
configure your application to use just
pick module
so in this demo I'll be using an
existing luggage module that I I found
on the internet so this is an open ID
authentication module so we can see that
the images are really shareable because
it was not written specifically for
phones a spec for a glyph for GlassFish
so the application is the same as one as
showed before but yeah in my web.xml I
don't have any login modules yeah any
login coffee
sorry so I'm not saying I want to use
the basic authentication I'm saying
using the vendor specific deployment
descriptor but I'd be using the provider
that I called open ID for Java provider
this is an arbitrary name this is what I
configured on the GlassFish server so on
the GlassFish server I get message
security my session is already expired
so on the message security I have two
layers actually those the only layers
that are defined as of today in the jazz
speak specification httpservlet and soap
so we are using the HTTP layer so I
create I created an open ID for Java
provider and you can see it's quite
simple in GlassFish you're just telling
you're using this service module give by
giving its class name you can add
properties if the module supports them
so when I run my application ok so again
I'm on the public page so not
authenticated not in the security
constraint when I go to the to a
restricted resource the server wants me
to authenticate so yeah
this page is not part of my application
this page is sent by the server of
module so I give my Papa ID URL so
hopefully ok so I can't access the
Verisign labs well I have an account
so I'm redirected to the Semantic Web
site to to login in my open ID account
and then I choose to authorize or deny
this application so yeah allow and
authenticated yeah and I can access the
private and the admin only value because
I defined this user as we had been okay
so to finish the presentation I show you
how you can write your custom several
authentication modules so we have five
operations here like as in as in jazz we
have initialization and cleanup we have
an operation to tell which massage are
supported so if we support roughly HTTP
or soap and we have two method to
validate the request it is to perform
authentication and to sexual response I
focused on the request validation here
because it's a release the
authentication part so we we look at a
custom service module that uses VSP ego
token but only to get the token we don't
call a
notifications have it's just for the
purpose of the demo okay so the server
as module implements this interface here
again we have some some attribute to
store the module state and we have here
an array with supported message types in
its operation you know you get some
policy information that you need to
store you get a callback handler
actually the callback handler here is to
to send the result of the authentication
to the Java EE server it to tell okay
authentication was successful so here
are the principal and you know secret
here is the user in the groups that I
authenticated and also you have options
so here I have defined an option which
is debug and one which is groups where I
can set a list of default groups for
every user so it's simply a comma
separated list of group names so they
get support in message types simply
returns the array that I showed you to
tell we support the HTTP request and
response now the most important part of
the module is validate requests so the
first we need to do is to verify if we
need to authenticate so we use the
request policy here and if if we don't
need to authenticate we stop right there
then we get the the request and response
from the messaging for object
and here we will manage the
authentication and the exchange of
requests and responses between the
module and the client so here are three
cases so either the user is just sending
the its first first request without
authentication information so the module
needs to ask the user so asking the
client for the user information the
second case is the user is sending his
information so we need to read it and
perform authentication and a third case
is to avoid authenticated the user each
time we store the result of the
authentication in the session here so if
we have the token already stored in the
session we simply use this token to to
cause the authentication service so here
we have a mock service that does nearly
nothing and then we send the the success
we return success if the token is okay
so if we have not yet authenticated the
user here we have two cases so if the
authorization header is in the request
we use it to perform a stand occasion if
it's not we ask the client to give the
authentication header so it's a standard
HTTP header that I'm using here it's
good authorization actually it's used
for authentication so if the request
contains the ADA I read it I call the
the authentication service with with the
token I read and if authentication
succeeded I commit the authentication
commit here
I show you actually cause the the
callback handler with color principal
called backing group principal called
back so these are standard callbacks
that every every Java EE 6 or 7 server
supports so the first is to to tell the
server which user has been as negated
and the second is to send the groups of
this user and we store the token yeah
in the session for the next requests ok
so I go back yeah so when we have
authenticated the user and committed
authentication we simply redirect the
user through the the URL you wanted to
access in the last case yeah is there's
no no authentication information in the
request so we ask the client to get to
give it so yeah we saw the URL that the
user wanted to access and we we send a
response we with the status unauthorized
so it's HTTP 401 and we add header which
is
WWWF antiquate which tells the browser
it's a standard header it tells the
browser ok send me your token to finish
the secure response we do nothing here
but we could sign the response for the
client to authenticate s and in the
clean subject we clear the principal
sorry what we added so I
the same application as before but
configured to use my custom just pick
provider okay so when I run it
so in Oregon the pubic page and when I
go to a private page okay we didn't see
it yeah but the module Center responds
asking for my token and Firefox sent the
token and here we have the beginning of
the token that was sent so I'm
authorized to run the private operation
so when you're coming to the end of this
presentation just a few words a few more
words about jazz peak so I told you just
peak you can work on the client side
so we've claimed us modules the purpose
is to secure the request so if if you if
you're calling a server that performs
authentication the client needs to
secure the request and it validates the
response from the server the use case
here of when you want mutual
authentication if you want the client to
authenticate the server as well as a
server to authenticate the client and
generally it you can use it when you use
container manage clients so if you
create a web service client you may want
the client to secure the request by
sitting you can use a name a certificate
just peek also defines bridge profile to
use the Jazz plug-in modules so the idea
is that the responsibilities are split
just peek Jesus with the request and
response just peek only knows the
message layer and jazz doesn't know the
message layer and you also have a set of
predefined options to standardize a bit
there is the use of jazz login modules
will just be
and finally a last word and the update
of of jazz peak just peak is in version
1.1 since Java EE 7 the main new stuff
is that the user and group are so many
cysts semi-auto registered in the
session you can just tell I'll just
speak ok my user is authenticated so
store this in the session so it
simplifies the writing of modules now it
also supports the servlet methods such
as authenticate and login which which
are supposed to to trigger understand
occasion so now it's supporting in just
pitch 1.1 okay so that's it for our
presentation thank you for attending
today</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>