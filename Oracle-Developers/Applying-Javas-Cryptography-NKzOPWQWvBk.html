<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Applying Java’s Cryptography | Coder Coacher - Coaching Coders</title><meta content="Applying Java’s Cryptography - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Applying Java’s Cryptography</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NKzOPWQWvBk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so to introduce myself my name is Eric
Koslow I'm a product manager or member
of Oracle's Java platform group I joined
Oracle just about a year and a half ago
and I do a lot of detailed write-ups and
publications on the Java product
management group blog so you can take
the URL down there or if you want to
search for Java platform product
management blog you can find that as
well so a lot of slides from the people
at Oracle have started with this safe
harbor statement and as I was sitting in
a speaker room showing some slides to a
friend of mine he commented that
everyone tends to make the same jokes
about legal disclaimers and things it's
not that we're planning on saying
anything about future product direction
it's just that these deal with a
particular policy called revenue
recognition that is a serious thing so
we do have to show this in some degree
but I'm not planning on making any
promises or statements like that so to
introduce myself a little further I'm a
member of the product management group I
follow typically the pragmatic marketing
framework for product management before
product management that came in from a
background of Java software architecture
development and deployment so focusing
on understanding java usage that's by
developers by system administrators and
by users so anymore I'm typically not
the guy who builds a lot of the systems
myself rather the goal that I have is to
act as an efficient broker of
information between all the different
teams that are necessary to make things
work to make things operate both from
building and deploying things I also
spend a lot of time doing technical
reading and writing so understanding a
lot of the information about Java that's
been written in the standard
documentation going over the last 19
years and I also follow quite a number
of information that goes on in the Java
community by just moving around and sort
of paying attention to different things
that people are saying because it isn't
necessarily important that I'm a major
voice to be heard but it is important
that I pay attention to a number of
things that go on and understand what
happens right so the reason that I chose
to do a talk
cryptography for this year's Java one is
to focus it more on introductory for
junior or mid-level developers who are
entering into the field and need to
understand how to protect a lot of the
information that's out there much of the
information that I saw about
cryptography was focused on very
advanced mathematics or all the details
of how all the algorithms and everything
fit together but instead what I wanted
to do is to sort of aggregate a lot of
the information that's out there in the
java community and publicized to
understand things like what exactly does
cryptography protect and what doesn't it
protect when it comes time for me to use
that cryptography where is it and how do
I know which particular piece that I
want what when I am have the option to
tune something what are the different
tuning adjustments that I would be
likely to do and where do I go to
configure those settings and I really
wanted to focus on favoring clarity over
complete accuracy because what I found
is there are many ways to rathole into
discussions or what I said in groups
full of experts there are frequent
Corrections that are issued so at some
point in this you'll see me referring to
public keys technically in a matter of
speaking I'm referring to public keys
and certificates but it's simpler to
simplify things or at least that's the
thing that I like to do so again
why cryptography one of the reasons is
there's right now assent and I Triple E
Center for secure design that's
promoting a number of ways to design
software securely and one of the
statements that they make is use
cryptography correctly well that's a
very good guidance but what exactly do
you mean by use it correctly and what I
found when I dealt with different teams
that were developing and deploying Java
software is that it's frequently easy to
do it very incorrect so I was on a
conversation with a number of people and
in JDK 8 we introduced support for
pkcs12 now this particular user was
having an issue with their pkcs 11
stores and I just sort of after a moment
observed and said well have you tried
upgrading to because this is a new
application have you tried upgrading to
JDK 8 which added support for pkcs12
very quickly someone corrected me behind
the scenes and said did you know that
pkcs
twelve is not actually the next version
of pkcs 11 they don't actually relate to
each other so the naming tends not to
fit particularly well or for example in
the browser world right now one of the
things that you're seeing is the
deprecation
of the sha-1 algorithm for server
certificates so sha-1 relates to an
algorithm called sha and sha 256 is
related to shot - but sha 384 is also
shot - as is sha-512 so i noticed a
number of nuances like this that made it
rather difficult for a number of people
to figure out which of these do I
actually want and how do I make sure
that I don't use the wrong one so the
agenda that I'm going to talk about is
just a quick background of which
particular pieces of cryptography that
you want how to encrypt things as they
go over a network let's say SSL and TLS
talk a little bit about code signing or
that encryption of data that's going to
be stored for a period of time and also
where a lot of this information is in
the Java cryptography architecture the
main purpose of cryptography exists for
the communication of Secrets verifying
that information is correct and also
it's not always communication we
regularly want to store a lot of things
so that they can be recalled later
without having someone who accesses the
database or the file storage be able to
read that information so I used to
regularly see information about like you
know a laptop that contained millions of
health records left in the backseat of a
car that somebody broke the window and
stole the laptop full of health records
if you encrypt the data it's at rest and
whoever steals the laptop can't actually
read that information but there are a
couple things that cryptography does not
do I see a number of systems that refer
to themselves as secure because math or
well how do you deal with security and
they say will we use encryption
encryption doesn't really work if you do
things like leaving the private key
around or say we encrypted using this
algorithm and by the way here's our
password I have seen that on a number of
occasions with different systems
cryptography isn't also not necessarily
easy to use it doesn't say
here is the correct way to do this and
it's always a question of when we go to
secure something what are we securing
and what are we securing it from so for
example to defend something against
let's say command injection or sequel
injection cryptography does not really
relate to that particular piece so the
answer of well we use cryptography
doesn't apply to the question of what do
you do about security of this
application now there are a couple
different types of cryptography that the
Java cryptography architecture deals
with and most of the systems that are
available today are actually mixes of
all these three types so the secret key
or the symmetric key down at the bottom
is technically the fastest or encryption
of secrets but a lot of the information
that goes over the wire of things that
uses like public key cryptography uses
public keys to validate that the right
people are talking to each other and
then switches to that secret key shortly
afterwards so HTTPS is an example of
what does that and then there are a
number of different algorithms with this
so RSA an elliptical curve are examples
of public key architecture you can use
sha-256 sha-1 or don't use md5 for new
things anymore because that has some
collision attacks in it but that's how
you can hash information and a ES and
Triple DES are good examples of
symmetric now the cryptography
architecture was introduced in JDK 1.1
back in 1997 for everyone who remembers
that far back there are two major
packages where a lot of this information
appears one of them is Java dot security
the other is in Java dot or java X dot
crypto and we do publish something
called the Java cryptographic
specification if you would like to read
it and see exactly all the raw meat
details of everything that's in it
you certainly can another way that this
information is surfaced is through
something called the Java secure socket
extension that was migrated from a
specific separate jss e to the core java
implementation java SE so that people
couldn't make use of secure sockets and
really customize their SSL and TLS
implementations you can certainly swap
your implementation if you say I don't
want to use this particular
implementation from the Oracle JDK or
the open JDK you can use your own a
number of people do that to integrate
with their own custom chips and things
your average person does not swap the
implementation but some people they need
it for a business benefit or they just
really have major trust issues and they
go ahead and do that now one of the ways
that certificates and public key works
is it takes advantage of something in
the java dot security dot cert package
called certificate there is a former one
that was in there back when j sse or the
java secure socket extension was a
separate thing in the java X dot
security dot cert so if you go in your
IDE and you start doing your
autocomplete and you say certificate
it'll offer you to one of them in the
documentation is for more older
compatibility things and it's not that
you should avoid it for any sort of
security issue it really just calls the
regular one it's more a matter of making
sure that you do your static indications
of the correct thing deprecation is a
long long road and I know dr. deprecated
er had a different presentation at
another time there's really only one
implementation of this certificate
interface that is widely used in the
world their standard x.509 certificates
and when people go to say what how do I
use that as that x.509 certificate or
when we introduced the requirement for
code signing of rich internet
applications one question that we
regularly received was can I use my SSL
certificate to sign code the answer to
that is no simply because there are a
way to tell what your x.509 certificate
can and cannot do one of those and I'm
not going to move around too much
because this mic is wired is the x.509
certificate got get key usage that's a
boolean of constant eight values so it
will always be eight in length the
interesting ones in there are zero for
digital signatures and five for signing
other certificates there's a special
thing called ASN which is just a giant
series of numbers in the get extended
key usage so SSL certificates of
authenticating a domain has a very long
number of
three dots 6.1.7600.16385
that make sure that they follow industry
best practices by like Ernst &amp;amp; Young see
a browser forum see a Security Council
and they validate things so the way that
your certificate works is you follow a
chain from your roots or your
certificate that you've generated up so
your certificate gets signed by someone
else gets signed by someone else gets
signed by someone else finally gets
signed by that core trusted root for
those of you who are here and have a
background in compiler design it looks
sort of like a directed acyclic graph
where you start down at the bottom of
your certificate and you chain all the
way back to a root and the way that you
can figure out if a certificate is still
valid is that you can walk up the chain
and nobody has pretended to be someone
that they're not it changed to something
that you've identified that you've
trusted and no one along the way has
been revoked or had the community agree
and say this
certificate is no longer valid please
don't trust that person anymore alright
so now we're going to talk about
encryption in motion at rest by way of
HTTP and TLS and SSL so the main thing
that everyone works with to incur
encryption in motion is with secure
socket layer or transport layer security
typically configured in web servers or
different other systems that you need
there are two major implementations so a
lot of the times if you go to search
around about how do i do or configure
web server with this you'll get a lot of
information about configuring open SSL
or now Libre SSL although the technology
under the scenes of the way that
certificates are exchanged is fully
compatible a lot of the commands that
you might look to copy from open SSL
don't apply to Java because it has a
separate configuration so although the
commit although the algorithms and keys
and certain things are compatible there
are other things that are not and one
item or one book that I particularly
like in this area is a new book that was
just published a couple weeks ago called
bulletproof SSL and TLS by a guy named
Ivan ristic who runs Qualis SSL labs if
you need a number of tools to
investigate the way that your TLS and
SSL systems are set up SSL labs has
quite a few of them and chapter 14 has a
lot of work just about Java so if you
need if you don't want to read the
entire crypto spec and figure things out
just pick up a copy of this book and
check out chapter 14 right now popular
things to tune in SSL and tos are people
adjust things like the protocol version
so which version of TLS are transport
level security am I going to use what I
want to enable forward secrecy a typical
thing that became popular back in the
major spying scandals where industries
were breaking into each other and just
monitoring networks you can also add
something called the unlimited
cryptography extension that really gives
you stronger stronger versions of
existing algorithms that's a separate
piece and as I was talking to someone
else there is some work going on in JDK
9
make it easier to swap to the unlimited
cryptography extension you don't have to
do this but you certainly can now the
main thing one of the things that people
do primarily is to switch the TLS
protocol and the thing that they do with
that is to disable the older protocols
or set the newer protocols as the
default so as the Java platform has
evolved I put the dates of when each one
was released on here so JDK 6 was
released in 2006 JDK 7 was released in
2007 JDK 8 in 2014 including the default
version so JDK 6 only spoke TLS version
1 JDK 7 added support for TLS 1.1 and
TLS 1.2 but the default one was still
1.0 for compatibility in JDK 8 we raised
the default TLS version to 1.2 because
that's starting to become the industry
standard and what I will do if I
typically configure a web server like a
tomcat or a WebLogic or something is I
may choose to go in there and let's say
disable SSL v3 or disable TLS version 1
and there's a benefit and a drawback of
doing that that if I disable TLS version
1 I don't have to deal with any variety
of attacks that occur in that protocol
but I simultaneously remove
compatibility of individual clients that
only speak that older version another
thing that people do with this is to
enable forward secrecy so the death the
way that forward secrecy works is that
if someone hijacks the network and
starts capturing all the information and
they somehow discover your secret key or
find their way into it they can collect
information from that point forward it's
not a case where stealing something now
will reveal everything that went on in
the past so your past communication is
safer and a number of people started to
enable this after there was that major
spying you know all those major spying
scandals I think they occurred last year
everyone probably remembers seeing those
in the news and there's a whole lot of
different algorithms in the in the way
that that is they are these things
called cipher Suites
right here and you can configure your
web server to actually use them there is
a good listing of them so you don't have
to come up with the entire list yourself
in that bulletproof SSL and TLS book
that I mentioned specifically on page
439 but the way that you would choose
these and let's say limit the
availability of those older cipher
suites is through a JDK startup system
parameter called HTTP cipher suites and
that's just a comma separated list of
which ones do you want now those how the
rhythm names are somewhat hard to read
or at least the average person is not
able to read them so they're broken up
into several different capabilities the
first one all the way to the left is TLS
or SSL which they really mean the same
thing it's just an industry term versus
specific company's term there's no
difference the following one is the
exchange so the one right here on the
right there says exchange DHE stands for
diffie-hellman ephemeral aka
that's forward secrecy so if you're
looking at the list of names in the
cipher Suites feel free to go down and
say I want to choose the ones that have
DHE the following ones are symmetric
speed up or what do we choose after we
initiate the public key negotiation it
just makes things a little faster the
simplified way that I look at it is AES
is better than DES RSA and DSA both of
those are okay by me on the cipher mode
there's a couple different versions of
these there's GCM ECB CBC GCM is the
newest one so if you want the newer one
feel free to use GCM I don't really have
a preference there and then there's the
hashing algorithm which sha and then I
go with the higher number and I just
kind of consider that as you know
allegedly better in terms of more secure
MDS are the old message digest or md5
and no more md twos but they represent
that there are certainly ways in which
people can disagree with my definition
of this is better than that there are a
lot of situations but as a general like
I want to deal with this problem and
move on that's my simplified
set now why there's one question of if
those are more secure then why don't we
just make those the default and one of
the reasons is that it's the client who
gets to choose the protocol and which
cipher Suites to use not the server so
the client walks in and says you know
says something to the web server says
something to the communication system
and that's how conversation is initiated
so the client gets to choose that but
the server can respond and say well I
don't speak TLS one do you you know
speak TLS one one and then the client
will say why yes I do so my the trick
that I use to just engage with these
systems is I just limit the things that
my server will respond to so I don't
want to respond to things that are SSL
v3 anymore just because I don't want to
and more secure typically in certain
cases will mean more access of CPU may
be a little more memory may be a higher
drain on the battery but the main reason
why you wouldn't want to just choose and
say well let's upgrade all the defaults
to the absolute highest level is that
forcing things that a client can't speak
is essentially a denial of service
attack against that client so they come
in and you are denying them service and
if you're okay saying I don't want those
older clients to be able to talk to me
then that's great and please go ahead
and do that but there are reasons as to
why you or would not now the unlimited
cryptographic contention is a separate
download and the reason it's you know
there are a number of reasons why it's a
separate download and we can't include
it in the default for Oracle or open
trade okay you can just go download it
though and what it gives you is really
stronger versions of existing algorithms
and one of the ways in which I've used
this recently is I had someone and we
encountered a situation where someone
was trying to use a JDK 7 to connect to
a particular service that used a bit
strength that was considered very
unreasonable in 2011 when JDK 7 was
released so we tested when we tested the
system with JDK 8 everything worked
perfectly fine but at JDK 7 client was
unable to talk to this particular
service the error message to it was it
had a lot of good
tails in it but it mentions specific
information about the TLS key exchange
that goes on and the way that we fixed
the problem was by launching it through
SSL labs it told us well it uses this
algorithm that wasn't available in JDK
seven used unlimited crypto pack so we
put that in place and then automatically
the thing fixed
so the actual message or the exception
that was thrown was this SSL handshake
exception repeat received fatal alert
handshake failure and there are a number
of messages or the way that the
stacktrace works there were some
messages below that that we could key
off of but if you look and you say well
why can't my older java application from
back in you know 2010 connect to this
service of today that's for very
paranoid security folks it there is a
likely chance that the unlimited
cryptography extension can help and
there is a separate post down here at
the bottom of Java platform group
diagnosing tls/ssl and HTTPS where I
posted a lot of the debug flags or
capabilities in which you would use to
investigate why can't my client connect
to that server over this SSL connection
code signatures are another very
important piece so the way that they
differentiate from SSL vs. code
signatures is that SSL works very much
to answer the question of who sent this
the code very much addresses the idea of
who provided this so yeah a number of
guys from a company called Whitehead
security are doing quite a bit of
investigations on something that they
refer to as browser botnets and what
they're doing is they're taking custom
JavaScript code injecting it into a lot
of advertising networks and seeing what
happens so one of the things that you
can do with that is get those clients
out there to instead of show ads they
mined bitcoins for you and the way that
the reason that that works is the SSL
actually validates the advertising
network of who sent that JavaScript but
you as the end user you really have no
idea who actually wrote it it turns out
it's a couple guys Matt Johansson and
Eric
Sheridan or two very good researchers
that do this
they're some of the guys writing a lot
of this code to figure out who actually
wrote that JavaScript now in terms of
Java code signing there's a question of
who's who signed this information or if
my code uses dependencies because most
applications anymore are made up of a
significant number of open source or
external dependencies that we didn't
write ourselves should we actually sign
that so code signing does not actually
mean authorship code signing means more
assembled in this particular area so the
end user of a lot of your applications
if you're shipping it and deploying it
to someone else
they don't likely care if your
particular project if a particular piece
was assembled in Apache or if it's
something that you wrote what they're
more interested in is is this the
version of Apache that you gave me or
has someone else gone to modify it now I
see a lot of talks here about JRuby
jython
Scala groovy and those things and jar
signing or code signing works very well
for those languages because unlike if
you were to just distribute a series of
Ruby files or Python files
how would you validate those by putting
them inside of signed jar files you can
actually validate and say yes these are
the files that I gave you to be executed
by that JRuby system because those jar
files contain a series of check sums
without using the jar files there's a
whole series of files like maybe you
have quite a number of different files
that the person would have to check and
validate and even if they were to check
and validate them the typical way that
they do that is they say well here's my
sheet of hashes for the files well
there's no actual hash of the sheet so
how do you verify the information that
you're using for verification it becomes
a bit of a problem so sign jars by using
those public key certificates make it
much easier because you have that level
of validation that says yes this was
actually signed by that person and
here's the hash of when I signed it in
Java 7 update 51 of January of just this
year we started requiring that
internet applications by which I mean
applet and Web Start applications be
signed you don't have to do that if it's
a server-side application so if you're
writing something that is a web
application or a back-end piece if
you're writing something that goes into
Hadoop if you're writing something for
something else you don't need to sign
those applications you only need to sign
applet and web start applications and
what that does is for the end user who's
going to run it on their system they
open it in their browser it gives them
the ability to say do I actually want to
run this code now there are some
applications that people can't
necessarily sign or maybe it was
deployed several years ago and you just
can't go in and update that environment
we do have a way of letting people deal
with those there's something called the
exception sight list for an individual
user who can go and just say you know I
know we can't sign this application but
I want this application to run even
though it isn't signed similarly there's
a thing called deployment rule set that
works well in a larger enterprise where
there's more centralized management on
those systems but if you can't sign your
code or you really really don't want to
you do have some capabilities that you
can have for those rich internet
applications in a known community
there's always questions of well what do
I do if I don't want to pay for a code
signing certificate if you have an own
community of people who you know who you
are you're certainly welcome to
distribute your public key in advance
and have people import that into their T
stores and say yes I trust this person
at a larger scale of like internet
global scale with people that you don't
know we run into that prior knowledge
problem of when they go to import that
public key how do they know that it's
actually your key or how do they know
that it isn't someone who's running
around claiming to be you and saying hey
trust these things that were written by
me you want to be able to validate that
and not necessarily run into a problem
of people claiming that they are your
public key now in terms of signature or
no signature when do you want to sign
things or when do you not want to sign
things my simplified rule is just that I
sign all of the jars unless I have a
particular reason not to and one of the
reasons is I like
to practice my own advice and I don't
want to say well I tell other people to
sign their code but I don't actually do
it myself
so that the way that you would have it
if you had no signature is when it came
time to say is this the correct file
that I should be running the way that
people would answer that question is
typically to validate it against a
checksum so frequently when you download
a file from a website they might say
check this particular checksum and if it
looks like this then it's right but
after something gets stored for a long
time where did that go do you still have
it oftentimes the answer is no or if
that's stored in like a flat file you
have a text file right next to the thing
if somebody wants to go and tamper with
the artifact they're going to tamper
with that file too and they'll say well
here's the new checksum and of course
you'll validate it against the tamper
checksum and lo and behold bad things
will happen another interesting thing
that I found is as an independent
software vendor actually before I joined
the Oracle group one of the things that
I saw was there was a particular
customer that had let's just say
upgraded some of the dependencies in our
system and then they decided to report a
number of bugs there were bugs that they
had caused but of course nobody would
admit or acknowledge that so they were
actually patching our software and
because we had some signed binaries we
were able to say well these signatures
don't validate and without that level of
signature the support team would have
had to say well why is this a problem
what's going on here and what it really
would have done is to set both our
support team and our development team on
a non reproducible bug hunt because that
individual customer had actually changed
something in our code and they'd
overridden this series of behavior so by
having a sign jar file we could look and
say you customer that thing that you're
running is not actually what we provided
you what happened to the thing that we
gave you and when we did that they said
oh yeah we changed that thing so it
really decreased some of our support
costs now when you go to time stamp
things time stamps and public
certificates by design of the public key
infrastructure they're built to expire
so time stamping
feature that was introduced back in JDK
1 5 whereby by default without a
timestamp code SiC code signing
certificates typically expire the
audited time is about two years but if
you timestamp something when you go to
create it what you do is you extend that
lifetime to match the timestamp
Authority so one of the timestamp
authorities that I use that's public is
run by GoDaddy its TSA dot star field
tech comm and what it does is it acts
like a notary so just like a notary you
go in and the notary will sign and say I
saw this artifact being signed on this
particular debate or on this particular
date similarly like a notary they don't
actually know what the artifact is they
can't interpret a contract they can just
say you prove to me who you were and I
saw you do it on this particular day so
assuming that certificate is not revoked
at a time before that happened or not
revoked you can actually say yeah we
should still trust that I know that
their certificate expired a year ago but
you time-stamped it so we're gonna let
that continue operating and another
update that we did in JDK 7 was when we
started to require timestamp are when we
started to require code signing for
those rich internet applications the
applet and web start we didn't want
people's coats we didn't want people's
certificates to expire and applications
to stop working simply because that
happened so Jar signer now will actually
output a warning and say you signed this
jar file but you didn't timestamp it as
a result it's going to expire at this
particular time and the reason that we
do that is we want to encourage people
as they sign artifacts to extend that
lifetime so that nobody gets caught off
guard by certificate expiration that's
in the design of the public key
infrastructure like I mentioned there's
a number of these code sign time
stamping authorities TSA dot star field
tech comm happens to be the one that I
have used Symantec has some as well and
the difference is rather than expiring
in two years you will expire in their
industry practice is about ten years
right so now I want to go into using the
exact cryptography of different AP is or
where things are in the Java
cryptography architecture there are
different ways like we said that people
use crypto get guidance of use
cryptography correctly well what does it
mean for things to be correct generally
speaking a good idea is to use the
existing providers and algorithms the
versions that we provide the versions
that are provided in the Java platform
are typically well vetted algorithms
that are widely supported by a number of
people in the industry all of whom
evaluate each other and just monitor and
make sure that things work generally
speaking I would not go in and create my
own new encryption algorithm that's
secure because nobody else knows it I've
seen a lot of those they're actually not
that hard to figure out and lo and
behold people say well there's no
possible way that you could figure out
my encryption algorithm nuts and you do
there's also two different capabilities
in there there's a class called random
and a class called secure random and
what we don't want to do for things like
online gambling or if you're running any
of those types of sites to use a random
rather you should probably use the
secure random implementation simply
because it leads to a higher level of
predictability yes random is called
random but for people who evaluate
randomness all the time they're really
good at figuring out what random things
are there's another technique that
people can use of using different things
called a salt and there's a question of
when do we use that now if you find that
you do need to salt a hashing algorithm
you probably don't want to use that salt
over and over in a lot of different ways
there's three core things like we
mentioned of figuring out which type of
cryptography you want to use so
generally speaking if you want to do a
particular thing use the version that
relates to that if you want to verify
that something hasn't been corrupted or
modified or figure out that it's correct
without having to look at its entire
piece
what you want is something called
hashing or method or message digest now
if you want to be able to share
something in an uncontrolled environment
kind of like the Internet is what you
want is a public key encryption which is
why HTTP uses public key encryption and
if you have a very controlled
environment you can use a secret key or
a symmetric key whereby there's only one
known password for this and boy I hope
nobody ever gets ahold of that password
who shouldn't have it because there's
only one of them the way that hashing
works is there's actually two definition
or there's two ways to refer to hashing
and they're just sort of colloquial
terms there's the the way that I use it
is you hashing they're actually under
something called message digests because
that's what they used to be called kind
of like you talk to people in the
Midwest I forget if they use the term
pop or soda or who uses which term but
there's quite a number of those
so hashing and message digests are the
same thing as TLS and SSL or potato and
potato because I don't know anyone who
says potato hash the way the hashing
functions work is they go in one
direction so they are one directional
you typically can traverse in a
well-designed one you can traverse it
that's again why you shouldn't design
your own they go by way of something
called modular arithmetic so we all know
that game of you know I thinking of a
number between 1 and 10 essentially the
way that these work is I'm thinking of a
number between 1 and 7 billion when you
divide my number by 7 it has a remainder
of 6 and when you divide it by something
else it has 2 left over what number am I
thinking of well I don't know that could
be any large number of numbers but the
way that people actually attack these
hashing functions or message digests or
when you see those things of our
passwords were encrypted but somebody
got ahold of the database well were they
actually secure one of the techniques
that people use in these cases is
something called a rainbow table I
forget why exactly they call it a
rainbow table the names in this area are
always a lot of fun but what they do is
they pre compute a lot of values and
they just say the letter A is this the
number 1 2 3 4 5 6
is that and a lot of people still try to
use one two three four five six as
password anyone who likes the movie
Spaceballs remembers that scene of
that's the password to my luggage when I
go to choose a hashing function the
typical way you know I always want to
choose the best one that I can the
easiest way to do that is I go with shot
256 or higher you can go 512 you can go
384 or 256 if you have to you can still
use a sha-1 if you see that it's still
okay
md5 people try not to use that anymore
so if you're doing anything new try not
to use md5 you still can that's okay if
you're wondering where we get the names
for these or how I know that it's - 256
in the crypto spec are in the standard
names documentation there's a file you
can just open it up type hit ctrl F and
type the word message digest and you'll
see a series of names below there and
you can just look at those names and
that's where they are an example of
using these is I included that right
there and also to talk about the way
that salts work what salt is is a little
bit of an unpredictable bite I think
they called it a salt because it changes
the flavor other companies have tried
also adding salt as ways of changing the
flavor and calling it a secret times at
which you would want a salt is if you
have something like a password or if you
have something like social security
numbers which be careful with those you
want to make sure that somebody who gets
it hasn't precomputed a whole series of
values to be able to just look them up
going backwards so you add that hash and
update with a series of bytes but if
you're just gonna validate something
like give me the check sum of this file
I just downloaded is it correct you
don't want to salt that because the
contents of it are not a secret so if
the contents of what you're hashing is a
secret like a password credit card
number or something sensitive then you
want to add a random salt per whatever
you need if it's not a secret like yeah
I did a file download okay well it's
checksum is this
you don't need to salt that because
you'll add randomness and you'll start
getting random hashes of like what's my
you know what's the checksum of this
file well I don't know because you keep
changing it I think I got that code from
the crypto spec so it should be pretty
good now in terms of public key in
cryptography that's typically used for
if you have a very wide environment you
don't have direct control over all the
clients so you need to be able to pass
information around between different
people those in those information the
certificates the public key the private
key they go into something called a key
store and the default command that we
use to interact with those is something
called key tool it's in your standard
Java installations that you can use if
you're writing code to directly interact
with these feel free to use Java dot
security that key store key pair public
key private key but again be careful
about where that private key goes don't
share your private keys if you need to
email something don't email your key
store that contains the private keys and
if you want to know the names of
algorithms that you can use with these
key pair generators they are also in the
standard names documentation under the
phrase key pair generator algorithms so
if you're wondering why I have RSA or I
have elliptical curve just look for the
phrase key pair generator algorithms and
you will find them the ones that I use
most often are RSA and EC for elliptical
curve oh and the default key store that
we have in Java is Jerry libbed security
CRH CA certs and if you do command and
you don't provide a key store you'll
probably be working on a file in your
home directory called dot key store now
when you go to make these keys there are
a couple commands that you use
predominantly it's this command called
key tool where do I get these names or
when we have key Algar si I got that
name from the key pair generator spec
that one that I said before where you
just hit ctrl F and you type it how do I
know which numbers that I want well the
number is increment differently based on
the type of key algorithm that you want
so the ones that I use are for RSA I
typically use 2048 37
to 4096 you guys probably all recognized
the way that that's incrementing for
elliptical curve I generally go with 256
384 and 571 you'll notice those
increment in different counters it is
possible for you to give different
numbers to that but you'll get
interesting results if you do in this
case I specify my key store as Java key
store underscores keep secret and that's
just a reminder of if I ever go to do
anything with it keep secret is my like
oops I should keep that secret yes so
the way that those how do how do these
commands deal with something that comes
from a certificate authority the way
that you interact with a certificate
authority is that first you generate
your own certificate and what that does
is it actually creates a level of
protection of you from the certificate
authority because they don't know your
private key so what you do is you create
the the key using that first key pair
jar that key tool gen key pair command
that's up in the on the top and then you
provide them your public certificate the
certificate authority validates you they
validate that you are who you said you
are that you're not you know somebody
dot-com when you're not and then they
they sign it and they say yes this
certificate belongs to that particular
person so you start out as this sort of
certificate selfie and then you give it
to them yes
yep
sure so how does keytool
relate to keys to buy something like
OpenSSH the typically the that's why we
have the x.509 standard so that
different keys can interoperate what you
do is if you have your SSH and you've
generated a key for yourself to do that
what you can do is probably export that
and import it into yeah you would import
it like that bottom command of this is
the command that I use for SSH now if
you want to use like the jssh library
and have a Java system or Java client
automatically MSH into a system for you
your client will be able to communicate
so that's that's why you would do that
is essentially to move key stores around
between different people who should
trust each other and the nice thing
about x.509 certificates is that they
make things compatible as a general rule
when I go to create these certificates
or when I go to interact with them I try
to have as few keys and certificates as
possible so I don't just go off and make
a zillion and one public keys or
certificates for a number of reasons if
you want an example of how to interact
with those keys there's a couple right
here essentially you use key store you
get it and you pass a password to it and
if you need to encrypt or decrypt
something you essentially use a cipher
you specify which cipher that you want
in this case that constant that value of
RSA that I got there is what I grabbed
from the key pair generator names if you
want to write this as a unit test what
you can do is just go through encrypt
something and decrypt it and then verify
that it is equal to the same thing that
you put in with your standard assert
equals a very helpful way just because
you want to make sure that when you
encrypt something that you can decrypt
it if you want to otherwise I have seen
a lot of cases where people are like
yeah this is secure I encrypted it only
to realize that they didn't encrypt it
right so they can never decrypt it those
systems are fun when they've started
popping a lot of day
into it and they're like no where'd my
stuff go how do I get it back
well you can't and the reason that I
don't generate a whole series of public
and private keys for myself is that key
management is actually the very hard
part about this so you can very easily
run key tool and be like I'm gonna make
a new key per person I'm gonna make a
new keeper thing but then who should get
those private keys so how many people
are there on your team that would need
to interact with this thing because if
you give it if only one person has the
private key and that person gets hit by
a bus or something what do you do so
more than one person has to have it who
gets those private keys who does do you
sign it with how do you pass it around
to others how many different people need
to get how many different keys well when
they get those keys how do you verify
that those keys came from that person
it just becomes a series of
complications so I try to make things
easier for myself and deal with as few
of these as possible certainly you may
need some but you don't need a million
of them randomness is another key
important of cryptography so if you look
at the Javadoc for a lot of things in
that cryptographic architecture you'll
notice they specify by static typing
that they require a secure random and
way that they do that is there there's a
difference between random and secure
random so random is the very fast
performant one that's generated for you
know I just need a random number because
I want to operate on something or
because I want to do something that's
kind of neat secure random is I have
something that's very important and
matters to me quite a bit I want to make
sure that I am using that correctly and
that other people cannot predict it
there's a serious there are a number of
mathematicians or hackers who figure out
how to control different environments or
how to monitor everything that goes on
some fun things happen in older game
shows back before people realize that
you could do this in that if they have
the ability to control an environment or
monitor a lot of the outputs they can
actually control some of it and say
things like I guess that your next
number is going to be
this and they can be right so if you're
basing strong decisions like if you're
an online gambling site you know dealing
hands of pokers and you don't randomize
securely it is possible that someone can
say I bet that the next card you're
going to deal is this so you can't do
that you can also get things of Hardware
generators there's a series of random
Hardware generators where you just you
specify in your security dot properties
file that it takes input from this new
device or the hardware randomizer just
populates that particular device with a
new level of entropy some of the secure
random implementations will block when
they use when they generate secure
randoms others may not block but the
reason is that they will run out of
entropy because if there's no one
sitting there typing if there's not
really much information going on on the
system it doesn't have random events
with which it can rebuild its entropy
pool so it has to wait while that
entropy picks up right so a recap
because we are coming up on time and
then we can have some series of
questions for cryptography if you go to
interact with certificates ssl
certificates and code signing
certificates are not the same thing by
design the get extended key usage
specifies which can do which if you go
to encrypt different things choose from
the series of existing algorithms you
can get them from the key pair generator
names when it comes time to validate
information you might want to salt it if
it's information that is secret if it's
not information that's secret like
you're just doing a checksum for a file
then you don't need to salt it there are
a number of areas everybody likes to go
and copy code off the internet we all do
it if you load a copy cryptographic code
or things that are going to deal with
the security of your business try to
copy from the crypto spec because a lot
of the code that's on there has been
vetted I've seen a lot of very
interesting things that people have done
to design around well I don't know why
this works oh that works well it's wrong
one thing that I've seen a number of
different projects do is they say like
why need to be able to make a connection
hey if I just make this certificate
validation method return true my
connection works well yes it does you're
having a secure communication with an
anonymous person that happens
unfortunately often so just make sure
that you're copying it from a reputable
place and if somebody's just the the
post is kind of limited to hey I got
this thing to work and now I don't have
that problem anymore chances are they
have other problems that they don't know
about when it comes time to tuning your
web applications you can tune it either
at the JVM level or at the application
server level the things that people
typically do with these is changing the
protocol version of updating the version
of TLS that comes with a caveat of it
also removes compatibility with older
clients that don't speak your newer
versions if you are concerned about the
security of someone snooping on your
network or monitoring information that's
sent to clients you may want to use this
perfect forward secrecy by which you
configure it through HTTPS cipher suites
and look for algorithm names that have
DHE in them for diffie-hellman ephemeral
if you really want to go an extra mile
and update cryptography you can go grab
something called the unlimited
cryptography extension that gives you a
lot of stronger alder stronger versions
of existing algorithms or if you have an
older client that can't is having
trouble connecting to some newer
paranoid security service feel free to
drop the unlimited cryptography
extensions and what that does is it
upgrades the number of or the versions
of algorithms that that client can speak
it's just a jar file all you do is you
replace a particular file in your jail
gerri installation and it is enabled
automatically and with that does anyone
have any extra questions I hope this was
intended for a more junior to mid-level
audience yes what
yes so there are there sha there shall
one there is shot three is supported
algorithm so there shot there sha-1
there shot to the main one that I tend
to use is shot ooze simply because that
seems to be what everyone is using it
Bradford do you have something okay so
the answer is sha-3
was approved after JDK 8 was released
and will likely be in JDK 9 hopefully be
in JDK 9 I shouldn't say likely a lot of
people jump on we're in the process of
negotiating that at the moment
I repeat very well yes on what sure
what's my opinion on bouncy castle I
don't really have one
I think it's very nice that people
implement differ have different
implementations of different things
because sometimes people want to switch
them if you want to use it
things were designed to be instanced
extensible have fun yes they have a lot
of nice documents online
sure so how does the implementation of
elliptical curve deal with the past
let's just say information and the news
that occurred about elliptical curve
from what I refer to as the world's
worst negotiators yeah now all the stuff
that was in the news was about more
about the randomness that went in to it
I believe we have a different randomizer
or at least we don't use a lot of the
bad stuff that I saw in the news do we
edit this later right yes sure so is the
Java there is the Java version capable
of doing PGP encryption
PHP or PGP encryption I believe is not
using x.509 certificates I think it uses
something else so I don't know
I don't believe the default version uses
is able to do those there is likely to
be some library by which you can
interact with all those PGP systems but
I don't think there yes it is not
supported good so they are not x.509
certificates yes PGP is not supported by
a particular and therefore something
sometimes I'm not as good at repeating
yes
is there a benefit to having a larger
salt or is any sufficient any is
probably better than none
in certain cases there there are
different ways that people attack
different things so just choose a salt
that is ideally unpredictable and of a
sufficient size there are all kinds of
regulatory groups that say you know you
need to do this or prove to me that
you've done that so the way that you
should choose which thing to salt with
or how to define what your salt is is
probably going to be governed by some
industry vertical guidance so I don't
know what that is but if you want to say
things like my secret salt is the number
seven probably want to choose a better
thing all right yes that's great
hmm yep
well you know okay so are there ways to
improve the debugging capability of
ssl/tls
outside of just the - deed Java SSL
debug normally people don't say give me
larger stack traces although I'm very
happy to hear from somebody that they
want more chances are yes bradford would
probably know a little more of that okay
that was a long answer I'm gonna have
trouble repeating it so I hope that mic
picked it up short answer maybe alright
any other questions or anything people
are doing with encryption good and I
believe we are coming up to time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>