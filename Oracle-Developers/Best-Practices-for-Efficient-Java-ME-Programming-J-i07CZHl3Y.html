<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Best Practices for Efficient Java ME Programming | Coder Coacher - Coaching Coders</title><meta content="Best Practices for Efficient Java ME Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Best Practices for Efficient Java ME Programming</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/J-i07CZHl3Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you and my name is Enrico and I'm
an architect of the implementation of
Java in Beltran time at Oracle and today
I'll you know in a wine that I see that
a lot of people in the states are
already been prepared to hello and I'll
talk to you a little bit of scary things
about John and scary
mostly when they are applied to small
platforms like those which are addressed
by Java embedded well indeed they can be
scary in the big job as well but to know
that extent
so yeah I'll be talking about Java me
and Joey me today is not for mobile as
you know is for embedded and
specifically for small and better
targets for like hardcore embedded
things and for for microcontrollers as
well so that that brings some some
things to care about and that's what is
their theme of this presentation so when
you do for when you implement your kind
of products or applications for the
small embedded devices you have to care
about a number of characteristics of
these devices like the footprint you
target CPU power and the chameleon
incompatibilities because capabilities
because not not CPU is not not every CPU
is equal and of course been able to run
on battery to be your to be always
turned on without taking a user who's
always can you know do something and fix
if anything has been broken and the
devices have to be connected and you
know them somehow that the base for this
presentation is there isn't work we have
been done in order to release Joe in
Iran time for the Canadian 64 board so
that was
kind of the smallest weld smallest
platform to the moment supported by Java
if you don't count Java cart and 36 of
this platform I like this so it's a 256
K of Rome one leg of flesh 125 s CPU and
no no both dedication execution
instruction cache limited memory bus and
of course and you know all the important
characteristics that you have to address
with you
coding for the embedded so that's well
indeed for there think like Joe it's
it's a kind of a challenge but at the
same time you know if you consider a
Java by itself it's kind of well indeed
to say it's a directive think for for
for the loads of the people and 9
million of developers which is posted
all around city gives the picture that
it's not that there is something you
know white white hat has has happened
and that is mostly because Java brings
you a lot of interesting things a lot of
power so there's some of the concepts
for some of the features that quite
important and which base this the this
power and basically like the things
built into the concept of Java itself is
the managed memory model with a garbage
collector the fact that multi-threading
is supported by all levels of Java
concepts and as well as support for
multi VM which allows to run multiple
applications in isolation on the cilium
of course the java language itself which
is object oriented so you get entities
like classes interfaces objects of those
of course there isn't a dishes like
other lambdas of Arc's and that water
boxing
the reset of the API is of course both
like the core API and well as optional
j-stars which could be added by the
manufacturers or or or it by the user
some more powerful platforms things this
API is do for you like buffering the
date iterating over the collections and
various kinds of data and the execution
of your code in parallel modularity as a
concept which applies both to the system
libraries and your applications so that
there might be multiple profiles of the
Java Runtime which is currently somewhat
limited on Java C side but no on Java ME
typically it's kind of a very flexible
platform which allows to be it to be
built in you know millions of different
configurations depending on the
particular use case with somewhat the
ability to download the components on
demand which is enjoying any Muslim Maps
to the to the applications so that with
Java I need there is a shared library
concept for application molarity so of
course the the the skill sets so that
this nine million of Java developers
they are kind of you know like Java and
no Joey is so well that's that's a
strength of the Java and now my class
but at least thing is the security which
is built on all levels of Java concept
like the the permissions checking of the
applications so that the applications
can only do things which they are
allowed to the chicken of the bounds of
the although the operations starting
from accessing their elements and going
up to the various API constructs and the
chicken of their own time types you know
on all levels of the program execution
so as
you know when my notes that the power
doesn't you know is not given for free
and in this case it's as well like that
so what's wrong with all of this
concepts I've been showing you so for
example garbage collection it's very
handy however it incurs possess during
the execution and on the things like
embedded microcontrollers and I'll
Jeremy specifically typically the
garbage collection is of the type of
stop the world because there is no other
CPU core which could execute it in
parallel
of course as well as the memory amount
is limited so that the number of
optimizations which could be made to the
code of the VM itself is limited as well
so that's that's how it is and in order
to cope with that you have to be careful
in tuition the way you are using the
memory the way that the frequency and
the amount of objects you are allocating
the more you allocate the mobile GC
pauses you have there is a way to
alleviate that somehow by forcing the
garbage collection this of course you
know if you have the some points in time
where you know that you can allow
yourself this pose well let's just do
that and not you know to to just
minimize the risk of garbage collection
being shooting at the time when you
least expect it there is a way to
estimate the amount of free memory you
have on the platform but that's only an
estimate it's likely the lower bound so
that there is likely more memory
available but in order to gain access to
that additional memory which is not
counted here the garbage collection
should shoot so that you know there is a
figure you can base some some logic or
some magic of your program you've been
designing
and of course there is a kind of a
number of tools support to tools
existing and supported by Oracle which
allow you to better understand what you
brought for what your program does so to
see what's in the Java heap for example
how much objects take in the Java heap
and to optimize your program I noted -
you know a lot better execution or maybe
execution on smaller platforms or just
you know not to shoot garbage collection
- too frequently
that's about memory moving on to the
parallel execution so as I said there
are threads and the processes that Yahoo
processes on a multi VM configuration
which allowed to execute things in
parallel of course your sugar parallel
as we have one core but still so we have
a powerful synchronization we can easily
built into into the Java so that's cool
but at the same time you have to
understand that synchronization always
brings penalty so enjoy me in a contrast
to Java see the synchronization is much
more lightweight because typically well
at least all cause of limitation has
green threads in the VM so that Java
threads are not mapped to the native
threads
well that's inevitable given the
constraints of the embedded platforms we
run on and with this sense it's easier
to implement the synchronization between
threads because all of that done in VM
scheduler and not going down to the
operating system well even with that of
course each and every synchronization
can bring the pause to execution of your
application because the resource might
be just busy so that be careful with
these things let's cap priorities as
well so don't don't be blind in that and
use it wisely I never think is that
execution of the native code the native
code is not allowed to be part of the
application in Java me but at the same
time of course the system libraries the
drivers are in corrects accuse of the
native code and the knee
God always stops the execution of the
virtual machine as well so that if you
kind of execute some operation which you
think or you know might you know might
cause some heavy weight processing for
example on the level of operating system
that's inevitably incur pausing of your
Java execution just because you know
that single course I said however that
depends on the platform because some
things could be hardware accelerated
like for example the the security thinks
the the calculation of the hashes and
encrypting and decrypting the data and
some of the platforms could be
accelerated on some note that depends on
that well it's not not something
specific about Java is more like an
better thing so that you should more
like design your application and think
it through for particular use cases or
for for target devices that you are
addressing and that's more about memory
that each thread of course it has a
technique you should stack so all those
threads themselves if there is a
reasonable amount of them they are not
not a critical resource in Java me
however at the same time the more
threats you create the more execution
stacks you allocate in Java heap not to
forget about this next thing is object
oriented paradigm then go good of course
it allows the job to have dynamic
linking allows to access some of the
entities by just using their names
because there's limited reflection in
Jeremy well and about the shared
libraries which of course requires
dynamic linking however that's not free
as well so we each and every entity you
are creating a new program and caress my
metadata I know that to be able to do
this dynamic linking or loading over
your application and just as an example
in our virtual machine
it's
roughly that each and every class incurs
200 bytes of VM heap that's of course
for the foot application class just
empty one and methods is roughly 50
bytes that's not counting the lengths of
their names because of course the longer
you name your methods and your classes
just the more bytes this names taken
Java heap and of course they they shall
be in the Java chip to allow for the
other parts of the application to access
them lambda thinks they are not yet part
of Joannie but we are working to add in
them and although well and even despite
the fact that it's claimed that Java
language is well it structured in a way
to clearly express the witness that the
defeat of the operations you are doing
so the more you code the more you know
more process in it it requires a lambda
is it is an exception that's you can
easily write it but down below it's
implemented in quite heavyweight manner
and in particular you know that the
lambda is 4 so the lambda is at least
one class generated at run time when you
execute the particular portion of the
code so that well indeed it sometimes
may be more efficient to use anonymous
classes instead of a lambda but that
really depends on what are you doing
anyway like so more as I said I'm
telling you some scary things but it
doesn't necessarily mean it's bad it
just to think you have to be aware about
and as with all the optimizations or the
trade-offs between the efforts and the
footprint and the performance you don't
need to be you know doing this from the
first hand but you rather have to
understand whether it's at all needed
for you so just something to keep in
mind
and what arcs what arcs quite handy but
you can see that quarks is actually
implemented as an implicit array
allocation so here we have just simple
example dit bus in a three strings two
overarch string methods in course
creation of array then a few byte codes
to fill up this array with this
constants as well as finally execution
of methods not that lightweight actually
auto boxing is as well creation or a
wrapper object out of your primitive or
extract and the primitive from the
object and yeah so and with of course we
have to mention to you likely understand
that the objects themselves as they are
in heap the ink or not only the you know
the penalty of heap space being
allocated but as well as some complexity
caused to the garbage collection in
order to to collect them so that not
both the footprint and the performance
penalty may be later on with Java 9 with
this value types objects it would be
able to put would be possible to
somewhat help to pass the well used by
the types and allocate them on the stack
and make like the person of the complex
data entities to the functions and to
the handlers in more efficient way but
as we are not there we are not Java Java
9 sorry we are not Java 9 yet then there
is nothing to do we have to allocate the
complex data structures on the heap
yeah as even above the ope as I said the
literals the the names of the entities
of your application they end up in jail
heap and if you have some like for
example initialize the race that's not
only the object being placed to the
jockey but as well as the bytecode which
initialize
this race that's so that the code itself
takes the place into the heap as well
and that the CPU you know is executing
this code so there is both like 12 twice
penalty to the heap as well as 2
performance sure our names are better
yeah
and for example the the ways you
initialize the race for example is
important as well because like for
example you can have like longer a with
each of the element to be an object or
in turn you could have like more arrays
like a few more arrays but of primitives
and the second way is more optimal
because there are less arrays and less
objects created absolutely well there is
a you know closing up sections of this
presentation with some hints but of
course yes the application very well
helps with the name of thing so you
don't get to you know name your
variables ABC like that yeah so the
blocks and the branches which is maybe
not that obvious from the kind of casual
programmer but the more your code that
the more complex your code is the more
like branches it helps the more blocks
with various local variables you have
for Java that means that the more
internal constructs are actually
generated by the compiler and then used
by the VM that is because Java has
bytecode verification mechanism which is
you know mandatory by the Java spec
which which is there for security and
stability reasons which is there to
check that you always access so as you
probably know that Java bytecode
is built around the stack not around
kind of arbitrary memory allocation so
all your variables go to the stack so
that Java have verification which
verifies that particular particular
point in time the particular place in
the stack has its proper type so that
you cannot for example you know write an
integer to the to this stack point which
is actually meant to be an pointer to
the object things like that and the more
complex code you have the more local
variables or like the more the the more
configurations of your local variables
like you create a blog and you declare a
local variable and that inevitably
brings a different thing called stack
map so that the map of the entities on
the stack the most most egg maps you
have the bigger your code in the heap
and the more time is spent for
verification so there well we as
developers of the virtual machine as the
developers of the Java Runtime can do
something with the time spent for
verification for example we can verify
like the installation time and then just
you know ensure that the code hasn't
been changed but at the same time the
you know the the footprint penalty is
always there and one more thing so the
switch statement which originally was
for integer kind of types it's very easy
so there is a bytecode to you know to
jump to the proper place to execute so
simple case with for for switch with us
for case statements so in this
particular thing it takes like 73 bytes
to implement this kind of maybe even
less return doesn't belong to this one
of course but recently there was an
addition to the Java language to be able
to do switch strings and switch on
strings takes much more byte codes
because it's really
there is no such bytecode and it's all
of that implemented on top of existing
byte codes so the codes are generated
sent but you know there is a slight
about genomes as well just will be there
shortly
so okay you know of course they are
allowed but they are classes and there
are not one class there are two classes
actually that's not there so there are
two classes because it's also required
to generate a class of the array class
array of the enemies and that's a
different class in terms of virtual
machine has different name it's a
different class and with in order to you
know to store the values of your animal
of course there is required and yeah and
there might be you know what anyway I
should have yeah yeah so we nanyem
things like that as well allowed so you
can basically extend the annum with
arbitrary methods and overwrite them and
in this case another anonymous class has
created for particular you know
particular fields of this annum so let's
and as I said the classes are quite
expensive there although it's well it's
handy and hey I can and I don't want to
say it's prohibited but it's as well
just something to to mind and if you
switch animals annals that as well yet
more method another one to map to
actually to create an array which maps I
believe there are no variables to the
integers which is the danger the
integers are subsequently used in the
stable switch bytecode well here for
each one so like the for with an
iterator
it's expensive in a way that using this
for each statement in course typically
creation of an iterator which is an
object but its internal state so that's
just keep announcing however Java
compiler sometimes is a bit of
intelligence so for the simple cases
like for example for each on the
terminals over a to just compile it into
the just plain for statement is with the
integer variable which just goes through
the elements one by one and debug
conditions you know if your applications
how and typically they are have some
debug statements which have been
switched at runtime depending on the
value of some variable of course this
debug thing is they are there the code
which is in your hip and as well at the
runtime the chicken of this variable
which controls whether to you know do
something for for debugging of for their
positive we have said well incur the
penalty about multi VM so that's not
that found in Java C world to the moment
however the the guys in a CI working or
being working on that doughnuts not yet
released but in a way me
this concept is they're both supported
both on a spec level as implementation
level so that you can not a single VM
run multiplications kind of currently
and these applications are isolated so
that they look like being executed on
their own and have no have no way for
example to share the objects or
interfere with each other in order to
although they are executed as part of
one one virtual machine to implement
this
with isolation it's required to do some
things which as well incur some problems
and some some overhead so if there are
resources we have to be carefully
somewhat so either that the access
control should be should be implemented
on top of the resources if your
applications communicate with each other
because they are I API is for the
applications of course to communicate in
such kind of environments but this
communication mechanisms typically
implemented by using copying of the data
because as I said it's not possible to
share Java objects between the
applications so it's possible
technically but that's so strictly
controlled because it's very unsafe so
that mostly it's copying and the Java
Runtime state of course the more
applications here were run
simultaneously the more copies of Java
Runtime State you have the more memory
you spend for that application security
you know there is no class loaders API
so that each Java me application is
running in a single security context
which is indeed encouraged chicken of
the permissions for all the API schools
as well as the installation times so
that is that is something done as well
and if your security requires some
certificate manipulation for example at
the installation time or during the
communication by using SSL or HTTPS
technologies like that the certificate
verification is rather or encryption you
know is rather expensive operation so
although in modern world it's kind of a
must to do things like that because you
know everybody's trying to to watch us
but indeed this is an expensive
operation
some more things the intelligence built
into the Java Runtime into the virtual
machine and the libraries so there are
some sometimes these things do useful
useful things for you for example in the
VM there is an adapter adaptive compiler
or just-in-time compiler and these
things this thing compiles your code
into the native code so that it executes
faster however it doesn't have you know
superpowers to understand what what part
of your applications are really needed
and what parts are not so that for
example if you have like at the startup
for example you a few times and woke
some some big method with our own code
and VM can think that is this method is
Horton is trying to compile it but later
on if this method is not cold anymore
then this method is takes a lots of heap
space and well it's likely garbage
collected but still you spent a lot of
time compiling it while it's not
required
so it takes some you know some time to
understand what the particular structure
of the code is optimal with this sense
and this really depends on the device as
well because you know like the the one
we did for this key need is key 64 it
doesn't have the compiler at all because
the space is so limited so it would be
in optional to have the compiler there
so then it's not a problem and for
libraries DP is there are a lot of
buffering however in order to you know
not to make your life harder
I in Java me typically this buffers are
not that big or sometimes there is no
buffering at all because otherwise we
can quickly eat up all the heap on the
behalf of the application why maybe it's
not required at all and then you know
all the bad consequences could go so
that you don't you know you don't just
don't think that there is a lot of in
Bufferin done by the api's and if you
need optimizations with regard to this
operations like for example writing some
small chunks of data but being able to
send them somewhere as a as a as a
packet for example then you better do
this button yourselves and cross loading
you know yeah there is something so once
you refer to some class of your
application which was not used this
class get loaded from the applications
jar and then initialized and is not
unloaded because there is no place for
loading features so that it always stays
in the heap yeah there is no class
loader API but of course the class
loader by itself is there it's just yeah
it's well it's yeah it's done
automatically when you refer to some
class which is not yet loaded of course
sorry
yep
exactly well at some point we might
consider having it but it's really some
more work to be done too you know
and at this point we see no well unit
because typically that would just you
know just decrease the performance
because it will always compile and then
you know garbage collector will we throw
away there is also the compilation
because of too tight hip budget
no dynamic
well so perfectly understand you well
indeed to the current state of Jeremy we
consider things like k64 to be like the
minimum reasonable platforms so in order
to go even smaller we have to cut down
the features in a way that the result
would would no longer look like yeah so
we don't want to go there there are
techniques which might allow us and
maybe it might not happen that we all
kind of use them but that that is very
tricky thing and requires much more
investigation
they got down to 190 Hey or specifically
yes
hmm that's the meaning with like six
weeks
yes she's cool man somebody
yeah on the I know if you have been
there on the keynote they was mentioned
the number 128 key this is actually the
number the specification the vm
specification refers to for for the COTC
because we are based on COTC GSR and
that need reasonable number but that's
for see all these years itself and here
we want to provide more api is from key
64 of course their IP eyes to access the
on-board peripheral buses the low level
stuff and as as i said you know the
classes the objects and the api is of
course our java classes in Java you know
Java methods and and interfaces and
objects all this e top of the heap so
the more it guys you add the more you
know the more useful footprint is know
not only to be counted towards the
implementations of the API is but as
well to the overhead of the API is
themselves so that's the general
please give me
so well yeah then I'm talking about the
millions of developers they're
developers that that was developed
developer and community is good however
that's you know that's not that easy
because the embedded development is a
bit different compared to like several
development those kind of things so yeah
but I don't want to say that the Java
and the ballot are not something is
something unreasonable no this is
perfectly fine and we see quite good
adoption of new technologies on the
embedded market and quite a good and it
of kind of good use in it however that
requires some some more some more
efforts I would say from our side we
optimizing the joenie api's and the
virtual machine themselves we provide
tooling to help the developers and of
course there should be you know the
education for the developers that's what
I'm doing right now in order to you know
really understand how Java works in the
embedded space and with that so as I
said that there are tools and hints for
example if you use our any SDK to
develop your any applications and you
integrate it with the ID and compiled
some suboptimal code and here we have
autoboxing in this particular example we
get a warning it's no subtle bad but it
just brings your attention to the fact
that you incur implicit allocation of
the object and that is fullfil for the
old suboptimal structures doesn't
necessarily mean you have to fix it but
and of course you have to observe all
the all the constructions which which
take more have more resources more
more footprint and more performance
penalty the structure of your
applications the you can do you know you
can reduce the number of entities you
can you know which for your variables if
you have like rebo's which control
depart login or stuff like that you can
make it final it's at least at some
point and jealousy can inline the values
for you as well as the eliminate code
which is know which doesn't have any
chance to be executed so if you put the
statement like if fools and something
inside it will not get compiled at all
create less objects to help garbage
collector of course obfuscation very
important because it eliminates unused
code I and it shortens new names and
sometimes optimizes the byte code if you
won't have some performance critical
sections of course write the code that
that performance is you know the most
you can achieve however at the other
places of your application where you are
not performance critical then you are
free to write less code the less code
you write you know the better of print
you have also as this kind of things or
embedded in modern times are mostly
connected then you might consider to our
flawed process and all of your
intelligence somewhere to the cloud or
whatever more more powerful devices you
have and always mind your target devices
and the goal your applications are
achieving not just do things which are
not you know not something you have to
do and was that I'm actually concluding
my presentation so here you have a few
references to our original releases and
the documentation on the product well
any more questions
well we focus on these kind of
environments the first most important
thing is that typically there are very
limited amount of them available to be
used simultaneously because typically a
embedded operating system systems each
open circuits socket requires its own
buffer and the buffers are quite large
to accommodate like TCP frames for
example so well we met some rated
systems which require like about 4
kilobytes of RAM per socket it's not not
even that one and half for TCP frame but
even more so that just minimize the the
number of circuits you you keep open so
if you have for example multiple
multiple different functional blocks in
your application but your server is just
the same server try to use one socket to
communicate with it and then do some
kind of dispatcher between different
kind of logic things on our side for
example in our tooling so that this
didn't see it here but if you see so
another sessions or you know our any is
the key it's it's well it contains the
part which allows to manipulate the
device simply so that you can download
the code debug it profile it's not a
real device so that we on our site use a
single socket for all those kind of
operations and we multiplex data all
right other than that well it might be
again go to buffering cuz we do minimal
buffering there so you might see that if
you write you know like data to socket
character by character or byte by byte
in your application maybe that's because
you know that's caused by the nature of
your application but that might incur
more load to the TCP stack so you might
want to put the buffering in your
application for this
data before you sell it
Oh
well it is expensive but as I said it
doesn't necessarily mean you don't have
to use it it's just think to which over
if if you see that your traffic is quite
high and you have big lion legs
communication lags because of that fact
you might want to optimize that and if
we talk about communication that of
course is you have to have the same
protocol both sides so like if you have
this JSON on the server you have to use
it in your client we know we on
ourselves likely do not provide any
compressed like structural formats for
ourselves but would likely add them in
some near future so like binary Jason
things like that
yeah but our internal JSON files not the
user sedated yeah it might make sense of
course
so this is more like to give you an idea
of of the you know of the pitfalls you
might might meet and when you do an
embedded application you can just say
you use used tool in which is you know
we have lots of tools for for jelly me
and there you get you know the picture
the real picture for your application
and you can match with was this
information with your understanding of
what should be you know what should be
inside of the think of your your
application or inside the virtual
machine which is when it is executed and
and understand what's happening once you
understood you you like you know what to
do
ok thank you everybody</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>