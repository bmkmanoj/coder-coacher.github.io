<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Modular JavaScript | Coder Coacher - Coaching Coders</title><meta content="Modular JavaScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Modular JavaScript</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rblOJD7nfSQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so first of all I'm quite happy that
apparently we are not the only Java
developers who are carrying and
developing with JavaScript because it's
a bit weird to talk on yahoo one like
deep biggest java conference about
JavaScript's it's also new for me
normally we're talking about Java and
modularity on the Java size it is really
something quite special for us so I'm
Paul this is summer be both voluminous
work for luminous technologies and we
are based in the netherlands and
luminous technologies it's quite in 15
well a lot of things related to
modularity most of the time we talk
about osgi and how we can use hacia in
the cloud etc we have been doing several
talks about that the last few days but
today we're going to talk about
javascript and that's because well we're
actually using quite a lot of JavaScript
these days so let's get started about
that so I'm going to go a little bit in
through into modularity in general why
do we need modularity and why do we care
about a modular in JavaScript then I'm
going to do a little bit of synth syntax
introduction more or less with some
JavaScript pitfalls as well some best
practices just to get you warmed up a
little bit for some more advanced topics
about modularity after that we're going
to look into some module systems
available for 44 modularity and we're
going to look specifically at some
examples in require JS because that's
the solution that we use we'll look at
some other solutions as well and at the
end devil also demos from real codes and
see how this all fits in with modular
java application as well so that we can
have modularity boats and java sites and
JavaScript site and let us work together
in a nice way but first of all why
should we even care about modularity
well in general and that is because
modularity to our belief is the key to
maintain maintainable code this is not a
new concept we've been talking about
more celebrity 44 40 or 50 years old I
didn't put other people did and everyone
knows that if your code base is growing
and you start to attitude to have a lot
of
lot of code and that code depends on
each other it so should be a nightmare
to roll maintain internet new
functionality make some code changes to
it because well it should just put
everything together it ended up ends up
like spaghetti codes codes you will
never find your way through it anymore
so what you want to do is just separate
it into smaller pieces think about
separation of concerns and make sure you
can make changes on small pieces of your
code without destroying the rest of your
code base that gives you a lot safer
feeling as well so besides the fact that
we think this is the key to maintain
maintainable code we also often say that
modularity is the ultimate a gel tool
because you want to make changes to your
codebase you want to move fast for new
market demands or just dancing
implementations quickly modularity is
the way to do so because it gives you
the power to just make changes to your
code base without being afraid of
breaking too much stuff at least and a
few key words if you talk about
modularity are well first for
encapsulation you want to make sure that
you're you're not sharing everything
publicly between classes so that
everyone is using implementations from
other implementations because that that
just ends up like a big big mess you
want to make sure that you have more
well-defined small pieces that belong
together you have some encapsulation or
some coupling within a module but that
module should be encapsulated and should
have a well-defined interface that gives
you a lot more maintainability it gives
you a lot more freedom when changing the
codes because you can make changes
within that module without being afraid
too much that it will break the rest of
your codebase if you have well-defined
components well defined modules has also
much much easier to just put them
together in different ways to get
different functionality from those
modules which is also very powerful
concepts and probably most important
we're already all a little bit crazy
it's quite important to just keep your
sanity by having modularity so that
you're nuts well going all the way
through your code every time you make
single line of code chance this is just
the basic things that you should think
about when talking about modularity so
let's dive in at a little bit deeper um
what are we talking about if we talk
about modularity well remember
University remember about learning about
object orientation one of the most
important concepts there such one has
low coupling and you want to have high
cohesion if you have those two blocks
here and you see that within those
blocks within those modules this
representation of a module of course
there are some coupling there is no
coupling at all between classes well
it's pretty difficult to actually build
something there's always some coupling
going on somewhere but a coupling that
you require should be should be bundled
up in a module and that should be well
hidden behind the veil to find the
interface and you only are coupling
between modules should be by that
interface and with that we already see
something wrong quite interesting
because you don't have interfaces in the
JavaScript language so we already see
some problems here so this will be a
little bit different in the Java world
compared to the JavaScript rules going a
little bit further with modularity on
how we do this in Java at least if you
talk about more diversity in Java a lot
of people think about oh yeah at least
that's what I think about because I talk
about it all the time energy if's
construct bundles and in bundles you can
define some public parts of a module and
some private parts of a module all your
implementation code should be private
and with that just completely infeasible
to other bundles and you just want to
share some AP ice with the rest of the
world those AP ice can be loaded by our
bundles can be used that's the place
where you get some coupling between
bundles but all your implementation code
should completely be hidden and that way
you can just swap out implementations
without your clients after knowing that
again this is all based if you look at
our CIA are false we don't really have
that concept in JavaScript so again this
is kind of a challenge how are we should
solve this kind of things in JavaScript
and because I do need a shameless plug
in the stalkers well for my book that
was just published I just want to
mention that if you're going to do
modularity in Java of course well oh she
is probably the only mature solution
today we've all heard about jigsaw
that's not happening anytime soon and if
it's going to happen it's probably just
going to happen at the JDK levels going
to split up the JDK it's not about
helping us creating modular applications
especially not in JavaScript so the book
that we just published it's about how to
build applications a video SGI in a
modular way y'all's touch about the
client side I you should deal with
javascript in an OCR world so that that
might be quite interesting ok so I think
we are pretty clear on the fact that
they do once or modularity because
what's written an easy concept to say
well they of course you want modularity
who doesn't but why should we care about
modularity specifically in JavaScript
well if I look at myself a few years
back i've been doing JavaScript for a
very long time already but if you look
at myself a few years back it was still
well those little extra things in the
browser you know if your your your pages
generated by some web framework on the
server sides and you just added a little
bit extra on the client side in
JavaScript and you didn't really care
too much about the code quality there
because of us well not as much gold
anyway you especially didn't really care
about modularity that's just not not an
issue yet because there was not much
code if I compare that to my code bases
at this moment well that's quite
different because know about fifty
percent of my code base now is
JavaScript maybe that's not another case
for everyone yet but if you start
building well modern kind of web
applications a lot of that code is just
going to the client sites you can start
using some frameworks there they're like
angularjs for example but that means
there's a lot of JavaScript codes in
your complete code page
that means that we run into the same
maintainability problems that we would
have in Java if you have a large code
base and we kind of solved those
problems in Java by using solutions like
osgi but he didn't quite figure out how
to relate them JavaScript sites but the
problems are there because well we have
the same amount of code and maybe in
javascript is even worse because well
compare those two books apparently there
there's not that much good about the
language of JavaScript so that's not
that that's not completely fair to say
because there's a lot of good stuff in
JavaScript and actually the way you can
work as function functions and
everything is it's really convenient
it's quite nice and well it's actually
but we will be getting with with lambda
expressions to some extent that it's
actually quite nice but we're also
missing some concepts the fact that it's
not statically compiled can make life a
little bit more difficult in this in
this aspect the fact that you don't live
in the faces makes life a little bit
more difficult to define modules so well
maybe we do need some real modularity
solutions even more in the JavaScript
roles so because this is a Jap sword I'm
now getting computers not the job for
conferences java conference and we're
talking about javascript so because i'm
not sure how many how often are you all
developing javascript on a daily base go
to just to get you a little bit familiar
with with the syntax as we will see
later on I want to help you through a
few concepts so first about some bad
practices and what you should avoid it
at any cost is global states and in
javascript is quite easy to use Global's
because well the language is kind of
based on that whole concept of Global's
which is a mistake if you create a
variable without just anywhere in your
on your page not in a function if you
use of our keyword its global so
anywhere else new reference is variable
you can read it if you declare a
function that function is in a global
sculpture you can reference it from
anywhere again even if you have a
function defined
a varietal in there without using a fire
keyboard that is actually also on a
global scope because we don't have to
block scope in JavaScript like you would
expect if you're familiar with Java for
example so don't do these kind of things
instead use something like this because
in that case check bulletproof bitch
I'll makes is happy this is an enormous
an ominous function if you never seen
this before it looks kind of
intimidating because they're a lot of
breakfast in here so what happens here
this is a function that executes itself
but it's never getting a name so it
never ends up in global scope we define
a function and execute it immediately he
use jQuery for example you'll probably
have seen this kind of syntax before I'm
so this is good but doesn't really help
us much yet because well this just
execute but besides that we can't use it
let's take it a little bit further based
on that syntax a lot of library
developers start writing libraries like
this so they define their own ominous
function and within that anomalous
function they define some variables they
define some from methods and then
register the library itself or the
object as they created here they
register that with a specific name on
the window this is a lot better than
using global global scope for everything
but still you kind of enforce in this
case in my library name on the on a
global scope so it's easy to get name
clashes if someone else also register my
library well you're probably out of luck
so this is better but still not not
great another mistake that a lot of
people make including library developers
is making everything public so we're
doing Java so we know about your stuff
in Java most people don't write public
or make their fur eyeballs and their
their methods public most of the time of
course you want to have some private
stuff as well so for example the my
helper method here should we not be a
supposed to the outside world this is
just a helper method that should be used
internally and it should be private I
don't want anyone using this because if
anyone start to use it well I can't
really change it anymore I as a library
developer I must keep on supporting this
which is not so convenient but we can
easily fix this because instead of
defining this function as we did just
now now we have a function my helper
which is accessible within this
anomalous function within my library but
it's not a publish to the outside world
it's only the my library dot add methods
will be visible to the outside world and
my helper will not be and this is an
important concept because this is also
the concept and the syntax that we use
to do some more modular approaches still
it's not perfect as you can see because
you still enforced my library name on to
the global scope which is still bad so
now we have some basic sense of what we
can do with with the syntax and now look
at some real module systems in
JavaScript which are available ok well
so we saw what primitives JavaScript
provides for us to get some basic
isolation and granted it's not much it's
just the the anonymous function wrapping
an execution but it helps to keep in
your privates your private details and
to build out the library and only expose
what you want to expose but still that's
just a small part of modularity another
large part is the fact that no code
works on its own we all have modules
that depend on other modules so there is
a notion of dependencies between modules
which we haven't really touched on yet
in the primitive examples because it
will get really hairy you would have to
pass in your other modules by hands to
your anonymous functions and use them
inside these modules that he defined and
then you will be responsible for
ordering all these blocks exactly in the
right order and all the script tags in
your HTML page must be exactly right
because otherwise it will resolve
am so you could do that but it's a lot
of work and frankly I don't want to do
this stuff I just want something to
handle that for me fortunately there are
many module systems available currently
unfortunately there are many module
systems available currently in
JavaScript so we're going to compare
some of them and then we're going to
dive into required yes because that's
what we use and what we know and what we
love at least so far now before we start
looking at implementations that are
currently in vogue what do we want out
of a module system in JavaScript we
prefer it to be something that is really
specified so not just a single
implementation some enthusiasts who
created a great module system put it on
github and ran with it that's nice but
if it's specified then it has a better
chance of survival being available in
competing implementations so we can pick
the best so that's really something that
we wanted also because in the Java world
well we work this way we work with
specifications and we like to do this in
JavaScript world as well now another
thing is that the JavaScript world is
not really one world in a sense that a
lot of people work in a browser with
javascript and that's the current focus
of this session and our focus but
there's also the whole nodejs in the
whole javascript on the server-side
world that's all nice and all that's all
very good but that's not what we're
using we're interested in bringing
JavaScript modularity to our web
applications so for browsers next if
it's somewhat stable that would be nice
so that also ties in with having a
specification for a module system and
preferably it should be usable today and
as we will see there's a large effort
going on for the next version of
JavaScript which tries to address lots
of the issues that we currently have
today but let's not there yet so that's
nice but it's still something for the
future and like i said i want this
module
system not just to allow me to define
divine modules but I also want to have
it handled appendices for me so with
that being said what are the current
options I we believe these are the three
major options at this moment the first
one being the so-called acing from this
module definition spec there's also a
common jas and common Jas is not just a
module system it is a larger effort and
it brings lots of goodies to the
JavaScript worlds but it also has a sip
project so to say that focuses on
modules and modularity and then there's
acma scripts s6 es6 also called called
harmony the next version of Java Script
that's currently being specified and it
also addresses explicitly the problem of
modularity in JavaScript both at the
language level so that's nice but it's
the future so if we look at these three
specifications you three types of module
systems then we can compare them on some
attributes for example are they actually
specifies well in a sense all three of
them are specs HP asynchronous model
definitions is created by James Burke
and he has a specification put up and on
github and are several implementations
for this asynchronous mode of
definitions back for example requirejs
is one and there's also other
implementations that adhere to the same
specification it's not really an
official spec in a sense that it's being
done by a standards body but it's good
enough for us and a nice thing about AMD
is that it was really created with the
browser environments in mind first now
come on Jas is sort of in the same
situation as AMD is also a specification
not just a single implementation but
again not by a a standards body so if
that's important for you that might be
something to consider for now I would
say it's it's really stable in a sense
that there are multiple invitations
following the same common J's back but
common Jas is kind of on the opposite
side of the spectrum in the sense that
it's created with server-side javascript
in mind first that's not to say that you
cannot use it in a browser but this is
where it comes from es6 so the harmony
module system is actually expect by a
standards body by the ACMA standards
organization but the problem there is
yet the spec is really not final yet and
there are some sort of experimental
implementations but nothing that i would
recommend currently to use in production
so because the Equestria chest six
modules are being implemented at the
language level it really doesn't matter
whether you're in a browser in a server
environment because they all use a es6
runtime JavaScript runtime that will
implement this back so that's nice but
again not available today not a big
difference for example between AMD and
gum and GS is the fact that AMD can load
modules asynchronously whereas common j
as loads its dependencies in a
synchronous fashion and again and the
sort of sort of has to do with the the
heritage of the specs on the server side
you're loading from the file system and
it doesn't really matter in the browser
we have script X and and you really want
to asynchronously love with concurrent
connections from the browser to your
server all the scripts that you need now
in the primitive examples that poll
shows we have modules in a sense that we
exposed objects and on these objects you
put some functions in AMD it doesn't
really matter what the value of your
module is it can be just even a single
value it can be a single function it can
be objects containing many functions
completely free in that on the other
hand common J's forces you to expose and
objects as your module and that will be
injected into other modules as
dependency
if you look at my script six then the
again you have the same freedom as an
AMD to just publish anything value
function or an object as your module now
let's look up some code first AMD as you
can see here I assume that this piece of
code resides in a single source file
called webshop Jas and I start with a
defined call and define as a function
that is specified by AMD to allow you to
define modules now the first thing that
you have to specify is the dependencies
of your module and here you can give an
array of dependency names and those are
just logical names of the modules that
you depend on we'll see later how
required yes and am the separate logical
modulus to actual physical physical
files but for now you just have to know
that you can specify a logical module
name and AMD will make sure that the
right physical dependency will be
injected there now you can already see
why am these really asynchronous because
you have to provide a callback function
here and this callback function is
actually called by the module system
when both of the dependencies that you
specified are available and then these
dependencies are provided to you as to
as to function parameters in this case
we get a user service in a shopping cart
parameter which are filled by MD with
the dependencies that we defined so now
you can just create any functionality
that you want in the body there in this
case I make a variable called webshop
module with a function place order and
obviously that function will use the
user service in the shopping cart
parameters to do its work and then we
can return a value in this case the
webshop module and that is actually the
value that is associated with the module
that we defined here so if anyone is
going to depend on web shop because
we're in web shop
webshop yes then I will get the value of
this return statement so actually you
see sort of the same pattern here as in
the primitive example in the sense that
everything that you do is encapsulated
in a function in a function and so that
helps with the hiding of variables and
only what you return will be exposed by
AMD to other modules now if we look at
common J's modules the pattern is sort
of the same the syntax is different what
we do here is we actually have a require
function that is provided by the common
GS implementation to us and you say ok I
require a module called user surface and
here you already see why common Jas has
to be asynchronous implemented a
synchronous implementation because it's
a function call and JavaScript
single-threaded you can go on until this
this dependency has been set of
satisfied so common jas will actually go
out and load this module for you and
give you the return value of this module
there's a question
so the question is can we have a
synchronous injection of dependencies in
an AMD yes you can and i'll show a bit
later how you can do this there's a
trick where you can inject the module
system API into yourself and then
request something and then only work
when this request has been fulfilled so
that's the that's sort of workarounds
but they try to make everything a
synchronous I'll show an example later
in the deck so not a question yeah what
happens with circular dependencies in
the sense in a sense I don't think
common J's allows circular dependencies
so that's this fairly easy because it
wouldn't really work in a synchronous
model with AMD I believe it's possible
but you have to use a sort of a
two-level require statements I don't
have any examples of that but there you
can make work now to not just I'm sorry
well let's go back we have the two
dependencies injected into the variables
we can just use the variables in our
function place order again to create our
functionality and then to exposure
module we have to use the predefined
exports objects and that's pretty fine
by common J's and that we can say okay
exports the place order and that will be
the name of the function that is exposed
of the object that is exposed we assign
the function place order there and that
will be the actual value of this module
that will be injected if we require your
web shop in a different module now all
this seems a bit like a workaround and
it is because the proper java script
language doesn't support any kind of
module system and like we said es6 tries
to fix fix this by introducing modules
as a language level so we can see that
we get a module keyword and i have to
say
I took the syntax from the current
version of the spec it may change any
time it's really in flux still so don't
pin me down in this but it will look
like something like this so we can
create a module called web shop and we
can do both local inputs like the first
import user surface which will look in
the current source file for a definition
of this module or we can use the require
function to find an external module and
load it into a module variable so here
we have two modules available again and
we can use use them in the function that
we want to implement place order and
there's an actual keywords to do exports
instead of a some sort of implicit
variable now like I says the nice thing
is that there are multiple module
systems and the worst thing is that
there are multiple modules systems so
can we get but and best of all worlds in
the sense that I want to be compatible
with every module system every popular
model system well the answer is yes and
no in the sense that you can write code
like this and I won't go through this
blind the line but the idea is that it
tries to detect the current module
system that you're using and it tries to
register itself as a module with the
correct syntax in the correct course so
you see a define or a module to exports
depending on whether you're in a MV or
common Jewish world or just even in the
world where there's no modularity and
doing everything on the on their roots
on the window objects but the problem is
that your actual own code will end up
somewhere down there and this is of
course not very nice and I wouldn't
recommend to do this if you're just
building your own application and you
want to define a modules for your
application actually the only time that
you would have to consider this
Universal module definition is when
you're a library author so if you create
a next jquery then really try and figure
out to get it right so that everybody
who currently uses an AMD or common j
synchronization
I can benefit but for your own
applications just just pick one pick one
implementation once back and stick to it
because because otherwise your coat will
drown in boiler place now we chose
required yes for our systems mainly
because well we're creating web
applications not doing any server side
JavaScript so we wanted the robust
implementation that is really a
browser-based what's also nice is that
require Jas doesn't really introduce a
JavaScript build step it's all being
done inside the browser and i'll show
you shall we show you later how it
supports lazy loading of modules which
is kind of nice and possible because of
the whole asynchronous nature of AMD and
or the nice thing about AMD is that it
also provides an alternative project
called rjs that you can use to optimize
your javascript because if you create
lots of modules in lots of different
source files that's very nice for
development because you can have small
units of work and you can debug easily
etc etc but you really don't want the
browser to download hundreds of these
small modules because yeah the loading
play time of your page will really go up
so what you can do is use rjs to pick up
other modules and to put them into a
single javascript file in the right
order of course because AMD knows about
all the dependencies regardless knows
about all the dependencies between the
modules and then minify them so we have
one single source file and you don't
even need to change your HTML page to
get it to work in the same way that did
with all the single modules it also has
some nice features to be backwards
compatible with libraries that are not
modular modularized so that are just
global services and not one nice bonus
is that jQuery knows how to register
itself as an AMD AMD module so you get
us for free and lots of applications we
use jQuery
currently so a little ant event example
of the question why didn't we pick the
curl DOJ's implementation because
honestly I just started reading about
common GS versus required f-first AMD I
was convinced any AMD and I went through
the implementation made by the spec
author and I didn't benchmark or use a
grill DJ s I might do it in the future
but I haven't uses are they any
advantage that you ascribe to cool okay
yeah no no this is just the fact that we
pick something and it worked well for us
and then you stop looking at least we do
okay so gentlemen here says that corolla
jess is smaller and faster
implementation has some extra bonus
features so something to look into I
guess so if we require yes all your
script tags are really condensed into a
single line where you include required
Jess and you give an additional property
the data desh mein that points to your
main point of entry of your application
and that's where the configuration of
your whole application and your modules
happens so what is in this main GS well
there's a configuration for your require
environment with the required of config
goal and there you can see that you have
the ability to map logical module names
to actual physical names and this is
something that we also use to highest
version numbers for example what we have
in our JavaScript directory in web
application is just some module with a
version and what we use in our
application is a logical name without
the version and then if we upgrade
version numbers we do not have to
upgrade all the dependency statements in
all of our
modules and here you can do the mapping
in a configuration now after this
configuration you start with your first
require statement and we already saw
define to create modules and require is
the so so to say the inverse of death
where you can actually request a certain
module so you in this in this case we
require a single module called my module
and again we have to provide a callback
function that is invoked when this
module has been noticed by required j/s
and in this case well very simple we do
a document the right to show that it has
loads and the message that's being put
in the page comes from the my module
implementation that has been injected
now just to make it complete of course
we have to define our module in this
case we again use the define call that
we already saw here there are no
dependencies so just an empty empty
array as the first first parameter and
we return a very simple object
containing only the message function and
that's it here we have it end to end and
HTML page that bootstraps require yes
request a single module and defines a
single module and all these three source
source files are tied together by
require JS just going back this is also
the reason why it's very easy to switch
to the whole concatenated and minified
version of your application because what
rjs does is it traces the configuration
of your application it traces all
dependencies and it has all the modules
together it benefits them in a single
file and and this floor file will just
be a be in place of the main DOJ's that
i just shows so in this case you don't
do not have to change anything in your
HTML page and you will get just a single
download instead of all individual
downloads of your JavaScript modules
now there are some more advanced use
cases so to say and in this case the
first one is that you can also require
the required GS implementation itself so
you're creating module and you say ok I
depends on the required implementation
and in the body of the callback you can
then use again a required call and you
can request an additional an additional
a dependency additional module so that's
sort of to illustrate the lazy loading
and it's also a way to it's not really a
distinct runs version but this will be
how I would model the commonjs approach
so in line in your calls you can now
require some module and do some work and
again it's not really synchronous but
it's it's a way to do to require this
format at least after you've required
you require your other dependencies in
the first require call a divine call sir
no yeah
no no so I guess the answer is yeah you
can simulate at least an ordering but
it's not physically possible to really
block and wait for your dependency like
it is in command Jas
okay so yeah then you can use it for
window on those two block on that but
there's a desert plugin actually that
you can really abuse for this and it's
called the dome ready plugin for replies
yes I don't know if you've heard about
it but you can use it to trigger the
events that would otherwise be the dome
unload but it goes a bit bit deep for
now I guess so why don't we take this
offline otherwise and yeah I'll continue
using a second bit more advanced one you
can also directly name your module using
requires yes and this is actually
discouraged because it makes your module
less flexible you really as a library
author you tie a certain name to it and
you deprive your users of mapping this
name themselves but the only way of the
only time that this really is necessary
is when you are creating multimodal
multiple modules in a single source file
because then of course you need to be
able to distinguish between the
different models and you can do that by
the file name anymore which was what
normally happens when you just define
without name yeah yeah
I think you can still map it in the
config afterwards but then it will be a
mapping from a source file name and no
actually I don't think you can override
it because if you have these multiple
modules in a single source file they
will all be loaded at once we require
yes and there will be registered under
the name that you put up here another
question
so come get me at all
yes actually if you configure it right
then it will concatenate also your third
party dependencies and your own modules
into a single file and admit if item yes
I'm sorry I didn't catch the last part
yes if you debug with this whole
concatenated file you'll debug in all
the codes all the local combines this
also requires yes also all the third
party dependencies I think there's some
interesting things around caching I'll
be happy to talk about it later but I
like to continue now with the talk so
yeah another thing that you can do by
using the trick of requiring require is
to lately and conditionally load
dependencies for example I have here
some condition and I define that either
my list of dependencies a and B or a and
C and I use this list that depends on
the condition to load the actual
dependencies so you can use this for
example to do conditional loading based
on what browser you're in for example to
patch some shortcomings of the browser
that you currently in so not something
you would do in your day daily routine
but it's it can be very useful now I
already mentioned the support for legacy
libraries so that's a notion of shimming
and they call it in requires yes and
they can actually say okay I have this
library for example here we have the
angular library and it seems to export
it sells itself as a global object on
the window ruth objects under the name
angular and that's in the exports so
capture death as requires yes and from
now on I want to be able to just inject
it as a dependency rather than grab and
grab it from the global window and you
can even specify dependencies for this
non-modular rice libraries so in this
case you can specify that jQuery should
really be loaded before angular is lowes
because it behaves differently if you do
the other way around and in this case at
the bottom you can see that you now can
just say okay give me the angular and it
will be injected in this case in the ng
parameter and you can just use it to
create create your angular application
now I don't know how many people here
know angularjs and you are use it okay
let's say about twenty percent actually
if you start using angular you see that
it has a also concept of modules and a
concept of services and dependency
injection so in that sense it really
does have some of the notions that we
talked about with required yes and it
helps you structure your application
your angular applications but it doesn't
go all the way in a sense that angular
modules are really defines in your
source file and you're really
responsible yourself for doing the
actual script loading and making sure
that they're loaded in the right order
etc etc so in our opinion it does make
sense to use requirejs with angular as
well and the added bonus is that you can
also integrate dependencies on
third-party libraries not just on
angular modules themselves so that is
the justification for what we do it's
not really really nice in the sense that
we have a double level of module systems
actually if you are creating an angular
application using require GS so at the
top here we have the define in which we
request anglers dependency this is all
required yes now we create the SRV
module and that's again an angular
module so and there you can give you the
name you can give the dependencies in
this case the dependencies are empty for
this angular module and then we
the factory function from angular to
return the actual implementation that we
want to expose as an angular module so
you can see that the lots of JS
frameworks and ya have the need for
modular ization but don't quite go all
the way and in this case if you want to
really module as your application you
have to compose these modules systems
I'm not saying it's very nice but it
works very well and once you know the
pattern of this this yeah nested users
of module systems it can really help you
create effective applications so in this
case in another module you would inject
an angular dependency and you would also
have to at the top level inject the
actual source file in which this angle
is and dependency was created so don't
mind and don't worry if you don't know
angular and this doesn't make any sense
it's just if you are going to use
angular that and you see that it has
modules that doesn't mean that you
shouldn't look at a real module system
for JavaScript instead because you can
effectively use them together ok back to
ball
okay so let's zoom out a little bit
again and look a little bit of a bigger
picture how does this all fit in into
well a java application which is
moralize using osgi and how does the job
shirt fit in there how do we take a
and how do we let it work together so I
want to just look at a typical
verification if you have typical web
application nowadays we probably have
well jaspreet front ends and we have
just seen how we can more or less more
utilize that a little bit so we are
different different JavaScript modules
which are creating our our user
interface in most cases those Josh crib
modules will talk to some restful
webservice backends and from there we
are in the java roots preferably in orgy
I world so that you can create those
into nice separated modules as well so
they give you just an example of an
application that you can look at this
application is actually part of the
motto project is a showcase and that
shows how you can create multiple
application using osgi but it also shows
how you can do the josh website in a
modular way they'll use the web shops
you can click around in a little bit I
can put stuff in a basket order stuff
etc and then there is an admin part very
can login if I can remember the
passwords
sure it counts okay so there are some
different screens very can minister
products that are from a webshop and it
can manage orders and do all kind of
stuff with it quite simple application
minutes on the architectural level
representative of what to do in in real
projects as well later on I work if you
the link to get up very can find this so
let's look at some some code so
everything we're just that we were just
running in browser is just an banditos
project that is running in Eclipse we
have to be need tools plug-in installed
which makes it easy to work with ogi and
there we come back combine our GI
bundles with our JavaScript so how do we
actually package that so let's first
look at the front end so I said there
are two different parts of of the front
NPF like the customer facing front end
if you have to up mean part of the web
application we both did a modulation of
those a little bit different just to
show you different options for that this
first look at the customer facing front
ends the first thing I look at is that
this whole project is packaged in a
single do i project so this whole
customer-facing webshop is peckers in a
single oh sure i bundle within a single
Eclipse project and the first thing I
want to look at this is an angular
application using requirejs so the first
thing that we should look at this domain
AS VAL so this look familiar by now
because someone just showed so true this
and here we just bootstrap our our
webshop that is the dome ready library
that we're using and by that we just
bootstrap to angular library by
bootstrapping that and by requiring our
our application we actually load the web
show that the virtual dot app require
module and within their we define our
angular application so we have the setup
for the route provider for example a CV
the final the dependency
is on the different modules that we have
for this front end which are all their
different files and a lot of files are
actually created by using a define for
require jas an assembler also just told
you just now within a within the defined
for required jjs we create a module
within angular so we have those two
module systems working together why do
you want them together well one of the
very good reasons for that is that
angular does have this module system but
it doesn't really help you with loading
those files the all the loading of as
you just use angular by itself loading
of the modules and just dancing or
destiny from from the HTML files and if
you add required to that you can do it
in a more asynchronous way you can do
all the tricks with the optimizer and a
concatenation so letting them work
together is actually quite quite good if
you look at this controller definition
which is something from angular you can
see we have ever dependency on the
basket so this is the pain injection
within angular and the basket is a
surface that we have to find so we just
inject it into the controller very
similar to dependency injection in Jaffa
with one of the solutions that you might
they might be using if you look at those
if you look at that surface this surface
is also again a require model and we
create another angular module which
contains all our surfaces angular
surfaces and in there we have to basket
and if you're new to angular it is
probably a lot of syntax to cope it
don't really have to go through all of
that just more about the structure of
this but here you see we just let
angular and require work together in a
nice way so how do we actually package
that how do we make sure that you can
actually serve this in a web server
because we are running in osha a
framework the only the only thing that I
just started is a Felix frameworks is
just an osgi container and in there we
deploy this JavaScript code as well so
as I said we're using B&amp;amp;D tools and if
you look at being little
we just include this whole static folder
and make that available in the generated
bundle file the other thing that we do
this part of em dau too we have some
extra headers that you can use to
automatically register a servlet or all
those web resources become available of
course it's quite specific to I using
osgi if you're not doing osgi you will
probably do something completely
different but if you are doing obviously
itÃ­s actually quite convenience so
we're having this setup we can look at
the generators folder and look at the
actual jar file which is generators and
of course this happens completely
automatic if you're using a UCI your jar
files have an extra manifest file the
manifesto MF enters the metadata for
this furnish bundle any you see once
again those extra headers to expose the
user interface to the web server this is
all we have to do this is all we have to
do to make this run in the context of an
osgi container so it's really quite the
same as just doing plain JavaScript
developments switch back to the browser
just for a sec if you look at this up
main screen you can see there are quite
different parts of this application so
the customer facing front end we just
put in one big angular application
because angular has his own module
system you can actually do it in a quite
nice way it's easy to cope with a large
code base in angular so that's that's
good but you can take that a step
further because in this case I decided
that all those different screens and
maybe also other screens that I might
create in the future i also want to
package in a completely different
Eclipse project development time so even
develop and time I want to have more
separation and you can actually do that
quite easily by looking looking at this
we have a general part and general
project this general project has enough
bar and there's enough bars only place
will be more or less coupled with the
screens together so just the navigation
between the
different parts of the of the user
interface you can actually make this
even more dynamic you can create those
links automatically if you want to do so
but in a lot of applications is actually
ok to have it in a static way and all
the other parts of the applications are
just separate bundles separate Eclipse
projects in their videos have to our our
angular applications they don't even
have to be angular applications they
could be created with completely
different technology maybe one part one
screen in angular and another one in a
completely different JavaScript library
that would still work nice together so
this way you can take too much
devastation even a little bit further
this is to show you how you can do this
in a bigger picture in a modular java
application so talk a little bit about
the future but are going to do an X
because we have seen about there some
other solutions in JavaScript that's
very still very far away from well the
things we do in Java with OC I'd you
don't we have the concept of bundles and
we'll private parts of a module we
certainly don't have any dynamic
services which is an important concept
for modular versation in jaffa so
probably not quite there yet so of
course we are going to get at some point
es6 at least that's a standard I'm so
that we can get get rid of all the
different module systems in JavaScript
outer right now when it's released
probably you want to get rid of required
j/s etc and start using that and there
are some tricks to actually make that
transition a lot easier the other really
interesting thing that's happening right
now is set in our GI specification space
there's actually a standard started we
are currently in our fish stage for that
very try to bring Jack's very try to
bring oci microservices or the concept
of dynamic services to the JavaScript
worlds because it is the most important
concept from 44 for creating real
modules in oci so if we could bring it
to javascript as well that will bring us
alive step forward this specification is
far from
finish this is still in the control more
or less collecting ID space I'm still
not even sure it is actually a good idea
or it or that it is feasible but it is
at least a very interesting ID and well
you can contribute to this rfp give
comments to thats because all the
specifications are public now for our CI
alliance so this this could be a big
step into the modular future but we are
not quite there yet so this all we have
to show you i hope to us it will be
helpful to you the link here is to the
to the vex replication i just showed you
and if you have any questions we have
about two minutes left to answer those
in otherwise you can just ask us offline
thanks a lot</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>