<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Combining the Power of SQL and NoSQL Databases with MySQL | Coder Coacher - Coaching Coders</title><meta content="Combining the Power of SQL and NoSQL Databases with MySQL - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Combining the Power of SQL and NoSQL Databases with MySQL</b></h2><h5 class="post__date">2017-08-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ZcyqU53OVnM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone thank you for coming
little bit of last-minute shuffle there
my name is Magan chakra I'm the product
manager for the MySQL server today I'm
presenting one of our newest features
available in my it's go 5.7 which is
this ability to use MySQL like a
relational database store and also use
it like it's a no SQL store and it's
just one of our features in 5:7 but this
is definitely one of the most exciting
before I get started just for my own
benefit who in the audience self
identifies with the Oracle database you
could just raise your hands and who
identifies more with the MySQL database
just a couple ok I compared myself I
thought more people might come from the
Oracle side so I'll give you a little
bit of introduction on what MySQL is and
who uses it as well I will mention some
upcoming features there's the standard
safe harbor statement applies here's our
agenda today we're going to talk about
that introduction to MySQL who uses
Weiss QL this new feature in in MySQL
5.7 what what sort of core features
together create this experience of this
usability of our Jason functionality no
SQL functionality and I'll talk a little
bit before I get to there what's the
difference between no SQL and Jason as
well
and then lastly after I've described
these features I'll talk about how you
can use them or when you should use them
because now we have the ability to store
things in a relational way or the
ability to store things in a not-so
relational way so what is MySQL MySQL is
the world's second most popular
relational database or actually just the
world's second most popular database
coming just behind the Oracle database
it's very popular we're very proud of
this ubiquity who uses MySQL a lot of
people and there's a lot of growing
demand so if you're looking to add
another feather to your cap please
consider MySQL this is a survey from
Stack Overflow the popular developer
website it's one of the most growing
trends in technologies behind cloud
behind Android and RS
i OS it's the next one there so who's
using my school we like to say that
MySQL Powers the web and that a lot of
our deployments are around web-based
technologies web and mobile if you look
at the the 20 most popular websites on
the planet almost all of them use MySQL
that's part of their core data
infrastructure there's only a few
exceptions to this and the exceptions
happen to be Microsoft properties
everyone else pretty much is using MySQL
if you look at our representation behind
which sort of products a lot of social
websites are powered by MySQL as part of
their core storage Facebook Twitter
Linkedin some of these companies who
work with quite closely it's not just
social where transactional database so
ecommerce uber booking every time you do
a hotel booking with booking you're
interacting with MySQL and same with
Airbnb and a lot of next-generation
software technology is web-based
software as a service many of these are
using MySQL so we're quite well are
represented in in SAS in FinTech and
overall in the set of next-generation
companies the unicorns those were the
valuation greater than a billion dollars
less than ten years old so that's the
intro to MySQL the only other sort of
thing to mention besides - Cole being
one of the main database technologies in
a lot of clouds it is to say that our
latest version is - 205 seven as I
mentioned we had many features released
in five seven I'm zooming in very
specifically - today - this one called
native JSON support but as you can
imagine with that sort of overview that
I gave you many of your users are using
MySQL and some quite high demanding
scenarios they put a lot of pressure on
us to improve the performance which each
subsequent request and improve things
like which queries we can optimize and
so forth and I won't be covering that
today but certainly if you're asking
questions afterwards I'd be happy to get
to that we're going to be talking
not Jason and Jason if you're familiar
with XML is the technology
Jason is kind of the easiest way to
describe it is the 2010 version of XML a
lot of systems when they interchange
information and they have to have a
format to be able to do that they use
Jason it's a it's a markup for data that
comes from JavaScript JavaScript object
notation but you don't have to be using
javascript you can just be using Jason
and so we have the ability to store
jason inside of mysql we have the
ability to search manipulate index jason
it's a combination of these four
features are there added in mysql 5.7 in
2015 that allow you to really power up
your application so we use Jason as a
native type inside of MySQL where I'll
get to each of the specifics but similar
to how you could store things as like an
integer or you could store things as a
bar chart text now you can store things
is this native JSON format and then you
can index it on top of that so I'll have
I won't describe too much about the
format of JSON but I just want to say
that it's the thing to change format and
it's very it's very useful okay so each
of these four points so here is a really
simple example where I have a table I
say that the table is employees table
and I say I have a column it's called
data and the type is Jason so it's not
an integer it's not a text inside of
there in this one column it's got all
sorts of data all out of there the data
doesn't have a schema that's one of the
things that makes it this no SQL piece
it just has any any valid JSON format
that I will insert into this it will
save that for me so here even you can
see the next two lines I specify some
valid jason this is the structure of
this format where i've got two objects
one is the object code ID and i say for
the first row it's ID 1 and for the
second one i say the name
is Jane that's most of the specification
for Jason you have objects you have
arrays and then for each of those types
you can have you know integers or you
can have strings and so forth but I
insert into this datatype valid Jason as
I've formatted it correctly in this
structure I retrieved back from this
valid Jason but inside of MySQL we're
storing this in a more optimized form so
we can search this we can retrieve this
and we can index this in in a much more
efficient way than storing this freeform
text so if you're upgrading from
previous versions of MySQL you could
very easily do this by using a text or a
voucher to be able to store your Jason
and many of that users off but there are
some advantages to be able to use our
native type and just the quickest set of
these advantages of it is that it
follows the Jason specification so it's
guaranteed that it's in the correct
format which Jason is always in the
utf-8 character set we're optimizing
this to read intensive workloads where
we do a small part of your Jason when
you do an insert or update and then we
can destruct it into this type that we
store natively internally and we have
sort of like in a binary format a header
that says all of the the columns in the
JSON document and then we have fixed
pointers to be able to access each of
the cells so if your JSON documents are
quite large and they have a lot of
repetition in the keys or they're very
wide in sort of a traversal down to some
specific key that you're after using our
native JSON data type is a very
efficient way to be able to represent
that some other tech specs getting a
little bit into the details if you're
familiar with other Jason likes
databases like MongoDB as a sort of said
Jason doesn't support that many types
itself it supports numbers strings are
boolean but it doesn't support things
like the difference between an integer
or a floating point integer or floating
point with greater precision and so we
extend the Jason type in our native
Jason format this for all of JavaScript
types and all of my skills types
as well and when I get to that fourth
feature when I sort of showed a few
slides back that it's the combination of
four features you really see how this
extension of functionality works inside
of MySQL okay so what are the advantages
well if you try and insert invalid Jason
into this Jason
column you get an error that's certainly
one advantage that you have some sort of
domain constraint on your data
the other advantage is that it's very
efficient if you have to do a lot of
traversal by having things in a native
format rather than a free-form text in
future versions of MySQL we'll add other
advantages for this type when you have
something that's freeform text and you
make a small modification in the middle
naturally when you write that back to
the database you have to sort of rewrite
that whole column or that whole object
we have the ability by using a binary
format and adding a little bit of
padding at various places to be able to
do a more efficient insert update we
don't do that currently that we plan to
in future extend this in many ways so I
you know that let's not go to high level
that's use examples because that
certainly makes it easier to digest I've
downloaded some sample data from the
city of San Francisco they have this
great project called open data where you
as the citizen can get involved in the
running of your government by them
exposing public datasets about how the
city runs and then maybe you can find
efficiencies or mash up data in a really
useful way I like this data because it
was all in Jason when I downloaded it
and it was very easy commit it import it
into MySQL and it's very no SQL way
where I created just a primary key and
then a column code feature which was the
type of Jason this is one of the nice
things about this JSON data type that a
lot of AP is they send your data and
Jason you can just flip that data up and
insert it straight into MySQL then you
can save in this native format which is
very efficient and you can add indexes
on top of that so there's not like this
impedance mismatch between the database
system and your application in the way
that you're speaking the same format
first for storage
so I imported this data into MySQL it's
very easy the steps can be reproduced to
have a link at the bottom of slide that
you can reproduce this yourself later
these are geographic features so a
feature is basically like a possible and
they all follow the same structure here
where land has a set of coordinates
which describes you know where it is
exactly for coordinates and it has a
street number of street address maybe a
roll number I one thing about no SQL and
about schema list is that not everything
follows exactly the same structure or
needs to but with this specific data set
they actually all do look exactly like
this where they all have you know a set
of coordinates it's not optional it's
all specified but I want to sort of
define that difference for your
applications this is one of the really
nice advantages of using schemas Jason
over using relational storage where you
have columns that you have to always
specify ok so I feature one with the the
native JSON data type let me expand in
to show you the first about Jason
functions to allow you to manipulate
this Jason on the server side with
something called Jason extract so here
I'm not even using tables yet I'm
showing the simplest of examples which
is just to create an array a JSON array
and assign it to a variable called
document and it's an array of three
items the third item is an array as well
and I want to extract out the second
item so I can say Jason extract that we
start counting from zero I want to
extract out the second item and then
just return this here so this funny
syntax where I say dollar and then in
brackets one this is something cool we
call a Jason pop it's fairly easy to
learn all of the syntax of Jason path I
won't show that the manual that
describes the full specification of it
I'll show you by examples but Jason
extract is one of the common functions
that you'll be using here because when
you insert this into the database and
then you index
you have to specify things like paths to
be able to do indexing and as you're
doing modifications of your daughter if
you're making big updates it's nice to
be able to do them within the database
without having to extract them back to
your application modify them and then
send it back
so Jason extract is one of the really
frequent functions that you'll be using
so how does this passing work I like to
describe it as being easy to use and
very similar to if you're from a
JavaScript background something like a
CSS selector where I you know in this
jQuery example I might say hash type and
this is where I grab an element called
type in the the MySQL Jason pop syntax I
would say dollar type there's a little
bit of confusion that I now want to add
which is frequently you'll see in my
examples I don't say the function name
Jason extract I use this shorthand
operator which is - greater than and
then in quotation marks adjacent pop I
use this function so frequently or we
intend for you to use this function so
frequently that we added to shorthand
operators for JSON extract and I'll just
explain how they work on this slide so
here I'm saying in the the top corner
here JSON extracts from the column
feature at this path but then just below
that I can use the shorthand operator
instead I think this is really nice this
is a real sort of marrying between the
relational world and the no SQL world
where I have this shorthand syntax to be
able to take inside a column code
feature and just extract out a past
without having to use this longer syntax
as saying Jason extract so when I
extract out from this column code
feature at this value code type it
returns me something of type jason
itself which is donating by two noting
by putting these quotes on feature
frequently with strings though you want
to cost them two strings and so we use a
different shorthand operator which is -
greater than greater than and then we'll
see things is just a string value cool
feature
and if you go back to my examples later
on you'll see that this is based on that
sample document that I showed you
everything says that it's a type of
feature for a geographic featuring in
San Francisco ok so let me show you how
you would use this on this sample data
and probably one of the most common
scenarios that you would use you want to
search inside the features table in the
featured column for something where the
property is dog Street is Market Street
Market Street is is one of the most
popular streets in San Francisco there's
certainly going to be many rows that
match this let's just find the first row
and limit one just to see that you know
in this natural syntax we can select
from our stimulus Jason and we can
return results to my client and it's
returning this just with that I said
select star so it'll just return that
Jason looking like texturing your
application has no idea that we're
showing this in a native format in
totally inside MySQL how would you find
where row does not exist or where
properties dog Street has not been
specified well again in a very natural
sql-like way you can say is now and then
I'll return you all rows where there's
no essential schema for this particular
part in my sample data set so everything
has the properties dot Street specified
so it returns nerve rows there's 200,000
documents here that I've imported from
this sample data set so far I'm just
table scanning I haven't added indexes
taking 0.4 seconds I'll build up to that
I want to show you an example first by
saying how efficient this native JSON
data type is so if I scan as I am on the
left hand side with a very deliberately
written naive query where I have to do
an operation each one of these 200,000
rows it takes zero point two five
seconds
the Jayson extract function and actually
all of the Jason functions we offer they
will work on the native JSON data type
and they'll work on user variables or
any other minus QL type like a texture
of Aceh so here I'm repeating the same
example after converting my sample data
to use the text data type and we can see
that it takes 12 seconds to be able to
do this operation so one of the
assertions that I made about this this
type was that it was very fast and it
provided this sort of constraint in the
guarantee that the data was in a
consistently safe format of valid Jason
we can see that this is true question
yeah they are identical
I've just got a comment in the top that
says as Jason type and as text type off
slide I've actually multi-model I'd the
schema to change it to be the text type
ok so just one more comment on this
slide this is a naive example where I've
intentionally scanned 200,000 entries
you don't have to do this in production
systems this is just to show the the
depth of my assertion was true
frequently in production what you're
going to be doing is using indexes let's
explain how that works with Jason and
I'll explain it with the simplest
example again to start with of a
generated column where I create a table
called t1 it has a primary key it has an
integer called my integer and it has
another column called my integer plus 1
this is what we call a virtual generated
column it's an expression that tells us
how to generate this column but this
column it's like a macro generated on
demand it doesn't really exist and what
this allows us to do is extract part of
our JSON document and then index that
and then we have an efficient query so
I'll just repeat that my integer plus 1
does not exist in real life
it's just generated on demand like a
macro for your applications if we try to
update it
it doesn't work it fails the three only
so you can think of this is kind of like
a view it's like if you mixed in with
the table at the same time and we're
using this inside of MySQL Jason to work
very similar to a functional index so
let's go back to our sample data set and
let's add a virtual column to speed up
that naive query where I'm going to call
it feature type and now I have to
actually choose a type for it previously
in this no SQL world I just said Jason I
inserted a new Jason now I have this
mapping where to have a virtual call my
map between the no SQL world and the
MySQL world and I say that this is going
to be a bar chart 30 and then I specify
that expression for my virtual generated
column using this JSON extract shorthand
functionality to say I will extract out
that feature dollar type and then after
I've created that virtual column I can
put an index on it so adding a virtual
column it just modifies metadata it's
very fast to be able to run this query
adding an index though indexes they do
exist that they're not virtual there
they're real and so this will take the
amount of time based on the size of your
table then if I repeat that query or
here I'm repeating a variation of that
query using the the virtual column it'll
now be efficient as it's able to use
that index in many scenarios we rewrite
queries internally where we detect it
there's a virtual column with an index
that matches the expression that you
used for Jason and then we use that
index we have some optimizer support for
this but when I said the previous
example is a naive example where it was
10 times slower to use texture of a
Jason I think this is a very real
example where we have an index now we
have love rhythmic search so these are
kind of typical results where we've gone
down from one point to five seconds to
0.06 seconds being able to index this
jason is it's very useful okay so I said
this is a functional index what I didn't
tell you yet is there's actually two
varieties of of generated columns
the default is the one that I showed you
it's called virtual there's also a
variety called stored where you can make
these columns actually exist and
maintain the data to be in the row so
this stored variety does take memory it
does take disk space in most cases you
want virtual but for completeness let me
describe you that there's just a couple
of limitations with virtual generated
columns you can't use them for primary
keys you can only use them for secondary
keys and you can't create a virtual
column on a full text or a GIS index gif
column and then index it with that index
type for that case you need the stored
variety of generated column some of
these are limitations that we hope to
lift in future but this is how it stands
in MySQL five seven for the default case
it's fine to use this virtual keyword
few generated columns okay so I said
that there was there was four features
there was the JSON data type the
function the indexing I'll show you that
fourth feature in just a second before
we get there I want to show you a few
more functions this is about 20 in total
and some of them are really useful to be
able to allow you to do something server
side without pulling it into your
application this is a function called
JSON search it here in the first example
is saying search this column called
feature match the first one for the word
Market Street and return this to me as a
JSON path this is kind of handy this
teaches you how to learn that Jason path
context and it's just returning the path
for the first match of that word market
and it says the market was found at
dollar properties dot street and then I
can plug in in the reverse in the
corresponding query jason extract
feature properties dog street and then
I'll return the word market so as I said
that syntax is fairly easy to learn but
that's the Jason pop syntax with Jason
search here's an example of creating a
JSON document using the JSON object
function a JSON object is a set of key
value pairs so here I'm saying with the
the text value of ID that's going to be
my key use the column called ID and then
with the key of street use this
expression where I'm extracting out of
some JSON document and then for type I'm
doing an adjacent extract so very
quickly you can see as I'm constructing
this JSON object that you could use this
in spite of an update statement and you
could modify a large amounts of data
very simply on the server-side JSON
object is is one example JSON array is
kind of the corresponding function for
just a set of values that is not key
values and this function accepts any
number of arguments and here you can see
how at the type jason pops i'm replacing
whatever was there with the word feature
or bug basically adjacent array to
replace it okay so yeah i said it's
about 20 server-side to be able to
modify search create return jason values
the ones in bold on my slide are the
ones that i've showed you there examples
the only extra one that i might point
out that kind of useful is this one
called jason valid where you can
actually check if the data is valid JSON
or not if you're migrating from an only
version of MySQL you were storing jason
the JSON data type requires all data be
valid you can first say flex star where
jason valid is false on that column and
then you can modify those things to be
correct and then do your large migration
to convert that data type so how this is
the fourth feature this is called the
jason comparator and this really shows
how our integration is working between
the the jason world and the mysql world
where if you try and compare the jason
value of one here I'm saying costs 1 to
Jason to MySQL 1 it'll actually return
true and if you try and compare to Jason
objects it will return true and there's
something quirky about these these two J
Kanaka documents that I'm mentioning
here and I'm comparing the keys are in a
different order you see in the first one
I say a is 20 and then num is 1.1 and in
the next one I say num is 1.1 and then a
is 20 well part of the Jason
specification says that keys can be in
any order and then things will match is
the same so we follow the exact jason
rules and we have this nice type
integration with mysql to build up on
that let me show you a simple example
where i can join between the mysql type
of an integer and the jason type of an
integer where in the first table I've
created a primary key and then I've
created another column and it's an
integer and the second table have
created a primary key and then another
column which is Jason which just has
incited an integer and you can see after
insert samples out of here I can join
these two together and this is useful
because this provides your valid
migration strategy or you can move
things from top level columns to Jason
and you can move things from Jason to
top level columns through some sets of
migrations in your application it's
quite a lot of combinations that are
possible okay
so that's that's the core functionality
as I said there's four things working
together let's talk about some use cases
where we might want to use Jason or we
might want to use relational top level
columns there are strong advantages to
both and I'll try to give a fair
representation of of the pros and cons
of each to start with storing things in
a column applies schema to your
application we don't talk about this
enough I feel a schema is very useful
because it applies some sort of
controlled restriction over the
variations that your application will
see I've seen in some jason schemas
already that you know somebody inserts
Dadar they specify the key name with a
spelling error and then they have two
variations of the same data and they
have to figure out how to reconcile that
over time or they have to carry that
baggage in their application that now
they have to sort of like do a repairing
read
or as they see something incorrectly you
know updating it to be accurate so
schema is kind of a way of simplifying
your applications you just know that
this is how it is and it'll never be any
different from that and that constraint
can really enforce some consistency on
the flip side the advantage of Jason is
that it's more flexible and there are
some problems that are hard to model to
data model in a relational way and as I
said in our introduction a lot of our
customers are SAS applications and fast
what happens frequently as they get one
customer that asks for a specific
customization and then they sort of
figure out oh god how we're going to
implement this in a relational way where
we have one column extra for this one
customer how do we have custom fields
just for like a subset of users and what
frequently happens prior to Jason is is
that they'll use a design pattern like
EAV but they'll have a set of auxiliary
tables sort of name value keypads for a
particular user and Jason is almost a
complete replacement for EAV it often
performs a lot better
eav it's hard to generate good great
plans the the data you often have to
retrieve from multiple rows at once and
they might not be physically located
together Jason is really much better why
it's much better is that it naturally D
normalizes the data and keeps everything
together and it doesn't force that
restriction on the schema another thing
over regular columns is that as your
data model is changing a lot there's no
painful schema changes with with Jason
you just start sending data in a
different format and then it
automatically starts working we've got a
lot of feedback on this in the MySQL
team that schema changes are difficult
we've made it better
starting with with - q56 it's online but
it still has to do a little bit of work
if you add columns and Jason it does
absolutely zero work so for rapidly
moving targets this is very useful to be
able to store things in Jason and
rapidly moving targets an example of
that is things like rapid prototyping
Jason is very useful for that you can
just start modifying things in the
application never have to change the
scheme or no sort of flipping back to
that example where I said there's that
SAS application where you've got one
customer and they ask for customizations
a variant of this is some another
problem that's hard to model say that I
was trying to model my laptop and store
all of the components in it inside of
the table there's some commonality with
some components they all have the serial
number they all have a vendor that
manufactured it but my CPU has a number
of cores and my ex SC it has a size and
gigabytes there's a use case where you
might want to put the the compulsory
attributes as top-level columns and the
variable ones are the changing ones
inside of adjacent document and then if
you need to index it you can use those
virtual columns and so forth but this is
a fairly nice way of modeling things and
that sort of combination of the mapping
of the two worlds there's many other you
know iterations similar this you know
imagine that your eBay and you wanted to
have a number of listings well some of
the categories they have custom
attributes and you could easily store
that in adjacent column but the core
stuff things like a description and a
price I mean that's pretty stable so
that's where it where we're at for MySQL
5.7 where are we headed I'm very happy
with the functionality that we managed
to add for from is Co 5 7 there's just a
few feature requests that we've gotten
so far being able to do a a more
efficient in place update from a partial
modification of adjacent column and also
extend this for our blob data type is
quite requested and currently when you
make a modification over replication we
send the full Jason type we'd love to
just be able to send that Delta so we
plan to do this in future
there's some restrictions on the on the
virtual generated columns that we'd love
to lift and there's some extra Jason
functions that are very popular that
we'd love to be able to add as well but
as it is it's quite useful in it and
provides a lot of relief for
applications that have had this really
hard modeling problem so I think in my
last slide I just have a set of links to
follow up and my slides already online
but if you have any questions we have to
answer yeah yeah so on the first
question is the Oracle database can add
just say where you have something like
it I don't speak for them might speak
for the MySQL team that there's a draft
specification for adjacent in databases
and it's going to be in the sequel
standard so every database will
inevitably have something like that it
is in the standard did it go in 2016 ok
good good stuff I have not read the 2016
standard it did ok so I've got an excuse
for maybe a couple of months yeah but
our implementations are fairly similar I
think one thing that I'm a little bit
jealous of is they have adjacent table
function but every major database vendor
is adding this over time not everyone's
chosen to have the native data type but
most have some set of the functions and
like the virtual columns for indexing
and then you had a second question
XML versus Jason yeah so I don't really
have any religious attachments to either
but I think that Jason is pretty much
one from market share a lot of API is
seem to be Jason based in returning now
and restful so we added XML
functionality not a native XML type that
we add an XML functionality about 10
years ago in MySQL and it's not seen the
same uptake that this stuff has had I'm
really quite surprised at the difference
is that kind of
answer I mean application developers
have their reason for having api's be
Jason based or XML but I've seen exit uh
XML not get the same traction as Jason
last few years yes
yeah that's true yeah I've seen a drop
like specification that has some
validation of Jason where you can have
some partial schema but I don't know how
much traction that's got in the industry
either you're quite corrected they're
not an apples to apples you can have a
DTD with with XML other questions
yes yeah great great question so
internally our Jason type has very
similar storage rules to blob the
maximum size is 1 gigabyte the practical
size is probably smaller because each
individual Jason document still uses row
level locking so if you start modeling
things where you're putting too much
inside of each individual Jason document
you may have concurrency problems so I'd
say as the yardstick measure keep them
under a megabyte but doesn't there's not
a fixed size up until the one gigabyte
size generally Jason tends to be a
little bit larger than an individual
rope so it's not quite like the same as
saying keep it the size of a row because
things tend to be more denormalized but
I like to say keep it maybe under a Meg
not a fixed size to 1 gigabyte there
yeah so Almain cash is the energy D
buffer pool and you have you set that to
about 50 70 percent of system memory and
it uses the same buffer pool for this
storage so it will used basically an LRU
algorithm to figure out how much of this
should be loaded in the cache but it
doesn't have any special rules for JSON
over normal pages yeah so we we break it
down into the native type and we stir it
in pages using the same page structure
as other pages we're not storing these
is like external references to files is
that was your question that they are
stored inside of database tables
okay no other questions
Thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>