<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ready for Java 10 - Bridging the Gap Between Database and Stream | Coder Coacher - Coaching Coders</title><meta content="Ready for Java 10 - Bridging the Gap Between Database and Stream - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ready for Java 10 - Bridging the Gap Between Database and Stream</b></h2><h5 class="post__date">2018-04-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/c0Idx7Ekho4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hi everybody and welcome to this
presentation called Java 10 bridging the
gap between database and stream and even
the child says Java 9 it doesn't it says
yahveh tell you can run it to Java 8 or
Java 9 my name is pearl and I'm CTO of
Speedman from from Silicon Valley and
most of the examples I'm going to show
here today Springs from this article I
wrote in Oracle Java magazine last
summer about using streams instead of
sequel so every time you mix languages
to such Java and sequel you're going to
get bugs because the languages they work
in fundamentally different ways so
wouldn't it be nice to be able to use
Java as you will like and use the things
like streams and predicates and
functions instead of using sequel and
there are a lot of hurdles as you can
see on the left-hand side so why not
clear the stream and go with the flow as
in the right hand side I have a lot of
slides but I'm going to start with
showing you some examples and then you
might understand it much better than if
I just tell you what it's all about
anything examples I'm going to show
today I'm using an open source film
database called su Kela that you can
download directly from Oracle and you
see that you are all here so I'm gonna
use the GAE shell to show you this how
many of you guys have used J shell not
that many okay so read evaluate them
print loop so you can write an
expression and then it prints and they
can write stuff again it's it's nice
because you don't have to launch your
IDE to test things so here I have my
test project and there is a special file
called nsj which starts my J shell so
I'm going to start it right now
today we go I'm running a Java 10 in
this example and jelly is very cool in
the way that you can just write an
expression here for example 1 plus y 1
and that is unsurprisingly two and you
also notice if you can see that you can
notice it's called dollar one which is
an anonymous variable because I didn't
assign this expression to any variable
so I can use this dollar one now in
further computations I can also create
objects like this list of 1 2 3 4 5 this
will create of course a list this is a
new feature since Java 9 so there I got
my list and it's stored in a variable
called dollar too
so now I can use dollar 2 for examples
and right size which will of course
return five because there are five
elements in my list one two three four
five there's also another way I can
instead of executing this size directly
can use stream so and then I can use
count and then I have counted all
elements in the stream and of course
this is still fine because otherwise it
would be very peculiar and if you look
at the first example with size that will
go directly to the list and retrieve the
size whereas in the second example we'll
actually materialize and iterate over
every element and then counter so the
complexity of the first example is one
and the complexity of the second is
called to be order M which means that
the more elements you have the more time
it will take so why would we ever want
to use streams if it's not as good size
yeah that brings me if of course that a
stream is much more useful so for
example if I want to count every element
that is even I can filter out those
elements elements like this filter and I
write an expression here which holds
true and then all the those element will
pass the filter so I have an integer I
and then that integer divided modernly
two should be equal to zero
so that is all my email elements and it
gives me back to and that's correct
because you can see it at two and four
is even so and of course I don't want
only want to count and I can collect
them in another list like this I can ski
right holding doors to list
there we go so now we have a sublease
basically oh there and this is nothing
new this has been around since Java 8
but the new thing here is that I want to
use the streams to work with database
content so that is new and that is why
we created statement so I'm going to
import let me just open some imports
that I need to run this as a stream so
what this does is it adds some classes
the classes are added now or generated
automatically by Speedman and there is
one class for each table and some other
classes so this allows me to do
streaming and now I'm going to use let
me use Java channel so I can use it for
have you have used the local variable
type inference anyone here know and Java
10 is already out okay instead of
writing the particular type Java can
know in fear you type for you so I'm
gonna use that and I create an
application like this this is just a
method with a few commands within it a
convenient method so now I will start at
speed mint and spearmint allows me to
stream towards a database instead of
just regular Java collections so and
speed networks is something called
managers so now I can create a very
manager called fields which of course
represents all the fields in the
database and I will treat that now film
manager yes
that's my manager so now I have films
and now I can use films just as I used
my list before it's for four examples I
can create a stream overall the film in
amounts and then count them like this
okay so let's stop that what happens
well I create the stream I count all the
elements in the stream all the films and
apparently there are thousand films in
this particular database and there's
something in the middle and that is
actually how the manager compiled this
to a sequel query under the hood so I
never write sequel Speedman is capable
of automatically with deriving what the
sequel commands should be and when it
looks at the stream so it selects count
all the elements from the film table
there and this is very cool because this
is not an order and operation the system
or the one operation because the stream
all the retrieves a single value from
the database so it doesn't have to
iterate over all the films that's cool
but I can do cooler things than that so
we want to we might wanna count maybe
films that just has that are short for
example and what is short let's try and
see what that can be I want to filter
out just a couple of films and then I
can type feelings film dot and then I
can use completion here to see what what
columns I have so maybe a duration looks
good not really
length length less
than 60 minutes so now count all the
things that are less than 60 minutes for
the length of less than 60 minutes so
now you can see it's a more complicated
sequel query there and you can see at
the end that the 60 is there let me try
this can't see this but there is a 60
there so the entire stream is collapse
to sequel query and sent to the database
and then all those films are counted
again in the single operation and that
is cool and you instead of counting the
different films you might want to
categorize them so you can do that using
standard streams and then you use
collected grouping by and then I tell
Java what I want to group on and that is
also feeling maybe rating maybe you're
familiar with the rating system here in
the US narrate films if a kid should see
it or if a grown option can't even see
it and so on so I want to apply the
rating getter and then I want to count
those elements so what it does now is
that it retrieves all the fields that
are short and then they categorize them
depending on depending on the rating so
you can see there the category g21 films
PG 22 and c7 21 so this shows that you
can use all the semantics that are built
into streams seamlessly with Speedman so
what this does what it was able to
compile all the way up to the collector
but the collection actually collection
was done in Java
engine JVM but you don't see that so
that's cool
well what if the database is huge what
if you have millions or billions or even
trillions objects in
then of course it gets slow so then
there is another solution instead of
using in database you can use an
in-memory store and retrieve your data
in even faster way I'm going to just
show you this briefly so then you have
to build your application a little bit
different but that semantics is exactly
the same so let me do this so I'm
building a new kind of speed mat and
this in this case it's an enterprise
version this is not open source and then
I have to create the snapshot so I'm
going to do that now so I'm going to
retrieve a component called datastore
and then I'm gonna call load on that
component which didn't work
okay let me start from the beginning
so I import my import
storm application and let's see if the
works this time it or through the store
component and this time it works so now
we're creating a complete snapshot of
the database in memory and off heap that
means that I can have a lot of objects
there if you're using on heap then you
limited by coverage collection issues
and then it can do exactly as I did
before
so film manager Oh feelings feel manager
yes so here I have my films in stream
count example and now this is much
faster and you didn't see any sequel
query so now it goes into a feed memory
and retrieves all the elements from
there and this makes it perhaps ten or
thousands or hundreds of thousand times
quickly depending on your application
okay so let us Exeter
so everything now is built into into my
profile and do you use maven for your
projects
anyone uses maven that's that's the
record in hand rate raised hands for
today so you just add basically two
sections to your pom file and you need a
plug-in to generate the code and then in
the wrong time I'm going to show you
more about that later
you can also of course get speed mint
very easily let me show that
you're going to get tab and then you
have a lot of resources there you can
read exactly all the examples basically
I show today there is a basic tutorial
and a lot of stuff resources how you
configure your palm file and on the home
page there is something called a
configurator an initializer initializer
that allows you to automatically do your
pom file so maybe I need Oracle database
and I want to use the spring plug-in and
then I can see my pom file exactly and
just cut and paste into my application
and also see an exemplary main file here
to start your application so it's very
easy to use okay so let's get back so
that was the demo so of course if you
compare sequel and stream operation
there are kind of similar so in the
first example it's a sequel query saying
that you want all things to the rating
pg-13 and in a second we say the same
basically in the stream saying that we
have a stream where we filter out all
the rows having a rating equal to pg-13
so it's very similar in that case and of
course if you look at all the sequel
commands or almost all signals math
there is a corresponding stream
operation to that too and they are very
similar so for example count is count
limit is limit distinct is distinct and
there are some others like where it's
called filter instead it's basically the
same thing so it's very easy if you know
C equal to to write a stream so why did
you develop spearmint we realized that
it takes a long time to write an
application with the database it was a
lot of boilerplate coding and you have
to mix sequel and Java and even though
it's just maybe not exactly seek well
it's something similar to sequel and it
was slow so we created speed net and we
use pure Java from the entire
application and everything is typesafe
and the streams are lazy
meaning that you only read
the elements you need industry not all
of them and everything is licensed
apache2
so you can create your own variants of
Speedman use it in your products or
change it and do whatever you like with
it and we become in 2017 the third most
popular or among each other
spirit is used everywhere in the world
in particularly the US Germany and China
but pretty much everywhere and how does
it work it connects seamlessly to the
database it pulls in data as streams are
consumed and streams they introspect
their own pipeline before they start and
that is how operators like filter and
sort it can be moved into the stream
spiked up and merged into the sequel
query so let us take a closer look at at
the sequel versus streams they have
another similarity they are both
decorative and what would do we mean
with decorative well decorative is means
that we are showing what we want and not
how we want it and that is most easily
understood if you look at the sequel
query there it's a select star from film
we're rating equals pg-13 but it doesn't
say how the database shall do this it
doesn't say the database is free to do
this in any way it wants for example by
iterating over all films and and
evaluating the filter or more likely
using an index so it can retrieve all
those fields directly from minutes
without iterating over unnecessary items
and the same is true for for streams
actually because if you look at it the
first row says film touch stream says I
want a stream that when it's consumed
contains all fields and the next row
says I want to modify this stream so
when it's consumed it only contains
those fields and matching this predicate
with all the ratings is pg-13 it doesn't
say that it shall iterate over all the
films and this is a mistake many people
do so we can replace
a stream with a new spin into
implementation that only produces that
particular set of films another thing is
that when you're using sequel you have
to worry a lot about how things are
coded in Java
this is crystal clear the field regime
should be exactly equal to pg-13 not PG
with a small G or P with a small P new
or something like that and if we want to
emulate that in sequel you have to add
stuff because by default it's case
insensitive in most cases so and of
course you only want to retrieve those
columns that is a part of your domain
model so you need to write even more
code and if you just add something
sorted in this case we apply a
comparator then you your secret code is
going to be even bigger and you have to
worry about
it's the ordinal sensitive you want to
have or nulls first or not as lost or
things like that in Java that's clear
and this is only the stream but then you
have to you know write all the
boilerplate code around and you
recognize this code snippet here how
many you have written that before or
something similar well that's a lot of
people so you don't want to do this over
and over again okay so let's talk about
lazy evaluation in this case we only
want to see ten films so we put a limit
of ten and then when this is executed
only ten films are retrieved from the
database and that is good because in
some other solution everything is pulled
into your list and then you consume the
list but that doesn't help you so much
because then you have populated you
entire list maybe have thousand items in
the list but only need ten so that's a
waste of resources another cool thing
with Speedman is that it supports
parallel execution out of the box so
there is a notion in streams that you
write the doc pal around and then
everything is executed in parallel and
depending on how many threads you have
on your server
you receive that money - one or in some
cases that money threads that consumes
your stream entities and this works
automatically and gives you a way to
consume things from a database in
parallel which previously was very
difficult to do if not impossible and
it's very easy so of course you can
write your own parallel execute to be
any BC I do that but I can tell you it's
not easy okay so let's check another
example this is similar to the example
we had before we have two filters one
rating it was pg-13 and another now film
length greater than 75 so how does
Beeman treat this film this stream well
first of all the stream is an interface
which is a standard interface in Java so
we haven't invented this API it's the
standard Java stream that but the
implementation of the interface is
different than for example forest now we
have full type safety so you couldn't
write another enum type here and only
one value is loaded from the DB as I
told you before so that that's cool so
and also they are rendered differently
depending on what kind of database you
have so for example in the right hand
side here you have my sequel whereas
here we have Postgres and if you have
many oracle or some other database
that's quite a bit around and depending
on that database type and you don't have
to worry about that you can just switch
database it's going to be rendered to
that database type so let's check the
database pipeline or the stream pipeline
sorry so from the beginning we have the
source which is default to everything we
have a filter and we have another filter
and then we have a terminating operator
so before the stream starts it checks
its own pipeline and and in this case it
will see that if I replace the source
with this I can actually remove this
filter so that is actually what is
happening and it's continuous and see
wow if I replace the source I can
also replace this other filter and then
it checks the terminating operator and
see I can update my source and make it
even simpler so now we have collapsed
the entire program to a single operation
is this really an idiot can we do this
can we manipulate streams like this the
answer is yes this is something that was
predicted by the designers of the stream
interface from the beginning so if you
look at the Java Doc's for example
forepeak which just looks at the element
in in the stream says in case where a
stream invitation is able to optimize
away the production of some or all
elements such as first fine first or
count the action will not be invoked for
those element elements so this is really
anticipated cometary code generation
prematurely unread Java interfaces for
all entities so you can overload and
override those with your own
implementation or can use a default one
also the managers are interfaces so you
can modify the behavior if you want to
do that or you can use the standard once
initiate experiment was something I
didn't show in my example but basically
this build application was these free
lines they cause payment yeah
retains all the metadata in the in the
sofa : application builder which is
generated automatically and but it
doesn't store for obvious reason the
password because that is sensitive so
you have to do that himself and then you
build your application and then you can
retrieve the managers which are in turn
used as for retrieving data as streets
so the classes are generated
automatically and the builders are
configured automatically and generated
automatically and the managers are
absurd you also generated for every
database table so many people use brings
these days so if you want to configure
statement on the spring it's very easy
you can create just a configuration and
maybe you will have variables for
username password and schema which
schema you're using
just been annotated and then you will be
able to pick up this being within the
spring very easy so the same goes for
the individual managers for example you
have a field manager and you receive
that from the application and once you
have done this all your logic is a
single row yeah you ought to wire just
your your manager in your code and then
they can work with them so this is a
complete example of a rest endpoint
service where you can retrieve feelings
with a certain rating and you can select
which page you want to be on Rick's on
for page 3 and because in spring you can
return a stream from him from from a
method you can just return a stream of
Austria or films filter the rating you
have said sorted in the default in this
case a length of course you can send it
as a parameter to if you want to have a
variable sorting criteria skipped page
times the paint shines and then just
limit to the pages and then the rest api
is ready so it's very easy to write best
ApS and this will be compiled to
something like this select from film
where the condition is set and order by
and actually there is a plugin that you
can use there is also open source with
spring so so this plugin will generate
all boilerplate annotation and beans for
you automatically so let's start with
sweet mint just go there and download it
use the initializer that I showed before
here you can select the database you
have what JDBC driver you want whatever
and you have your pom file and main file
generated for you so basically this is
what you need you need a plug-in
Speedman plug-in in maven and you need
yeah and that is generate source file
based on database and also you need a
runtime which is a comparatively small
and your file and it doesn't have any
dependencies so you will not run into
the URL so it doesn't depend on guava
for example or a JSON or something JSON
or something father you can just use it
without interfering with your other
project components this is how it looks
first time you start you get this kind
of dialog that you can point to you
database select which type you have port
and give credentials just click connect
and then on the right hand side you see
your database metadata and you can click
there maybe you want to disable some
tables and columns that you don't want
in your in your model and then just hit
generate at the top and generate all
code for you so the way you use it is
you generate code to write you logic you
run your application and if you update
the database and go back again and of
course there are maven targets that can
do this automatically if you don't want
to use arguing
so in summary spin and convert streams
to sequel automatically it is typesafe
as opposed to sequel and it created AC
streams so that you only have to pull in
what you need and it allows you to use
parallel streams in a very easy way of
course you can use it with almost a data
source all the common database types
that are out there you can use it with
binary or CSV files
Avro files where you can plug in your
own readers one guy did Google sheets so
he can use Google sheets as a data
source you can deploy anywhere
especially with Java 10 it's very good
to use docker and communities or you can
deploy in any HR service out there it
integrates well with all the three big
he's most people use IntelliJ these days
but you can use it if you have like like
I do use NetBeans or eclipse you can use
an EE server or spring server yeah
doesn't prevent you from using other
more rare service either and you can run
it on any Java version from Java 8 to
Java 10 in fact a bit faster on Java 10
for some reason maybe it has to do with
string handling so an enterprise version
it has the same API as the open source
but it's faster and you will have a
correlate and see sometimes in in the
nanoseconds well below 1 microseconds so
it's perfect for low latency application
and application with very high demands
and usually it's 100 mm or maybe 10,000
times faster than using a regular
database and the good thing is that you
can keep your databases you don't have
to migrate you can still have the
database as the source of truth but you
still get this speed-up in your
application so that was my talk I'm
going to have a talk back to back to
this talk about the acceleration and
ultra-low latency so I'm going to show
you a little bit the same streams but
I'm going to show a demo when we use
this low latency ultra-low like to say
application in practice and if you want
to try licensed for for enterprise you
can contact me or if you want to try the
open source just go to github and I hope
you find it's interesting and by that I
open up for for questions yep yeah
I think I get your question how the
question is when you have all your data
in memory it's actually on the machine
you're running your application on is
that correct and the answer is yes that
is the only way and I'm going to explain
why in my next talk very carefully so
you're welcome there but that is the
only way to get ultra-low latency and by
ultra-low latency I mean 200 nanoseconds
or 300 nanoseconds so an answer is yes
and of course you need a lot of RAM but
there are some ways to mitigate that
amount which I'm not sure want to tell
you in the next talk that's a great
questions for racing games just for my
next talk
yeah so question is how do we convert
things like strings for example which
might differ it from different database
types into Java is that correct
okay question is when we store
everything in memory do we do that
conversion a priori or do we do it when
we use it and the question is that we do
it when we pull in data so we convert it
and actually you have the ability to
apply something called a type mapper on
all the columns so you can you know use
one of them maybe 25 building converters
so we can write your own so you can for
example convert a string to an enum or
something type you have written yourself
if you have maybe low cardinality call
them or something or if you have a very
particular type of column you can write
that the map that is something more
efficient so the answer is that good
karinna do we have like traits for
people who stand who ask questions yeah
so everyone has a reasonable question
get this trait from Corina treat more
questions yeah
question is is this a one-time operation
loading everything into memory or how is
that handle is that correct
so the thing is that suitemate is
working with something called snapshots
so first time you start the first
snapshot and then after a while you can
take another snapshot maybe after five
minutes or after one day or whatever and
then you can continue work with that
snapshot so you can have several
snapshots in memory simultaneously and
you can and there's also reusability
between the snapshots so if you do not
change so much then of course you don't
have to create a completely new snapshot
but this is also something I'm going to
talk about in the next talk yeah okay
more questions yeah I don't see the hand
oh there okay question is how do we do
with updates and the answer is yes you
can update as any over em there are of
course methods to do updated database
and cool thing is that you can do that
in streams too so you can create a
stream that updates a lot of elements
and then applies an update er for each
element applies an updater and that will
update all the entities in that stream
for example so yes we can do that more
questions
no question no okay yeah good
mmm good questions can we combine
multiple entities into one stream is
that correct I have to say yes and no
you know equal so you can do that
because the new version will have joints
so you can actually set up a relation
between one or several columns and then
you can create a stream that contains
entities kind of tuples with entities
and then you can work with them and you
can do that today also by applying a
mapper we can apply a flat map which is
basically equivalent to to a join but
the join file feature will be much more
efficient so that will come in the next
version called 3.1 ok ok thank you very
much thanks for interest</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>