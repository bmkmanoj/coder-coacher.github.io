<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Modern JavaScript Server Stack | Coder Coacher - Coaching Coders</title><meta content="Modern JavaScript Server Stack - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Modern JavaScript Server Stack</b></h2><h5 class="post__date">2017-08-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TDpbLrA7_oc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">before we get to that just a few words
about me um none of this is really
important get on to the presentation
before we get to that though I have a
couple of pet peeves well my biggest
ones is when people say your instead of
your or they say loose instead of lose
my biggest one however is when
developers start to get into the a
religious war on languages right it's
like all JavaScript sucks or you know
Python is great or whatever it's like
use the right tool for the job right so
at least for me I started programming in
something called turtle and on one of
these little lunch box Macs
I use a programming language called
Turing to write a 10,000 line program
for whatever the final project for this
class and you can imagine writing that
much code on a five-inch black and white
low resolution screen not a lot of fun I
didn't have to wear glasses before I
actually took this class believe it or
not so I perfect eyesight but after
spending a hundred hours in front of
that small screen I had to get
spectacles anyways at my startup which
is based in Atlanta Georgia in southeast
we use a number of different things we
use JavaScript use Java we have groovy
Ruby native Android iOS etc etc so we
use a multitude of different programming
platforms but we do use quite a bit of
JavaScript both on the server and on the
front end so you end up wearing a lot of
hats and can be very confusing
unfortunately because when you contact
switch from Java into JavaScript or from
iOS Swift into whatever it takes a
little while to really make a mental
switch and kind of fit into the
programming model that you're working on
at that point in time so it can be a
little cumbersome it can be trying at
times but for us we always try to use
the right tool for the right job right
so we use a hammer on a nail instead of
using a pipe to be a hammer and nail or
something like that right so what I want
to do in this session is talk about how
JavaScript fits into say for example
using Java stack we don't actually use
the jb's
our java stack we just use pojos no of
course we run everything in the cloud
sometimes we use micro-services to do
this in containers by the way every time
I use the word microservices or
containers or Oracle pays me 10 bucks so
you know you may hear it a lot in this
session I'm just kidding like every when
every vendor is talking about
microservices nowadays so we have some
infrastructure that we've written in
Java that runs a lot of our business
logic and I'll talk about in a few
minutes about how that fits into an
overall architecture but one thing that
I want to focus on in this session is
talk a compare and contrast how the Java
thread based model for doing work is
different than the Java Script process
based model and how Java Script is a
sink and event-driven etc etcetera right
but I'm sure pretty much everyone in
here who's a Java developer at least is
familiar with the thread based model in
this example were specifically it's a
tangible example here is that it's
around servlets how many people are Java
developers just out of curiosity in here
let me let me ask that question how many
people are not Java developers oh wow ok
so for those of you just raise their
hands what do you program in just shout
it out c-sharp Python anybody else so
alright anyone using F sharp or elm or
anything like that to start a curiosity
No ok so but anyways all those platforms
look like this slide that was just up
there and that is a thread based model
rather than a process a based model
which is what javascript is so first
we'll talk about why we're interested in
running JavaScript on the server we'll
get into the ecosystem a little bit and
talk about the tools and then discuss
architecture and some depth alright and
when we typically think of yesterday's
JavaScript especially if you've come
from like a strong Java background or if
you're Python developer or something
like that you think of Java Script is a
little bit of a toy language or even a
baby language that's what we used to
think right to be more specific that's
what I used to think but after working
in for a while and coming up with some
good practices right JavaScript today is
like the cool hip and trendy language
it's not actually hard to find pictures
of hipsters believe it or not online I
know we're just down the road from
shortage but anyways so it's like the
cool and trendy language but there is
some muscle behind it or some real-world
applicability and number of different
scenarios in terms of what's actually
changed in the
javascript ecosystem is that the
language itself actually is very much
the same as it has been for the twenty
at last twenty years since its inception
in 1996 but of course they're the newer
versions of JavaScript es6 and es 2017
have added a lot more useful stuff into
the language so that it's not quite so
painful in certain ways but we don't
want to get too much into the minutia of
that right now what's really changed is
how we as developers approach javascript
alright we have much better best
practices that we can follow
we have great tooling for writing
large-scale JavaScript code that is
manageable and maintainable over time
and of course the runtimes have gotten
much better right so javascript in of
itself runs on a number of different
runtimes when we talk about nodejs
specifically javascript runs on v8 which
has been adapted to run outside of the
web browser right and we'll talk about
the runtimes in just a few minutes and
see what they kind of look like what
hasn't changed unfortunately in the
JavaScript world is that JavaScript
still has bad parts just like any other
programming languages right but the key
thing is that javascript is async and
event driven at it's very core which is
very different than most other
programming platforms which use blocking
or non blocking threaded models for
development and of course every browser
still supports JavaScript but we're
going to be talking about JavaScript on
the server in this session all right so
when we talk about JavaScript outside
the browser the first thing that we need
to know is that it uses something called
v8 which is the JavaScript runtime from
the folks over at Google is it extremely
fast modern engine that applies the same
kinds of optimizations that you see on
the java virtual machine or if you're
doing c sharp on the CLR etc etc in fact
and don't tweet this out just being
recorded I think it is okay maybe I
shouldn't say that's next sentence but
what I was going to say say it anyways
is if you compare the performance of
JavaScript on v8 it rivals the Java
Virtual Machine in terms of pure raw
performance okay so in terms of where
we've been and where we are now
javascript is extremely fast writes not
quite as fast as
the JVM for a number of different
reasons but again is a super-fast
runtime and let's do the next slide all
right and essentially node J s is v8
running on the command line or on the
server or whatever right and we can
actually also run JavaScript on the JVM
if we want to the current generation is
when I say current JDK 6 and below have
had something called Rhino inside of it
which allow you to run JavaScript and
the next generation engine which has
been in Java 7 and above I believe is
called Nash horn right and unfortunately
there both of them are pretty good in a
pretty fast but they don't come close to
v8 or nodejs in terms of raw performance
ok so you can run JavaScript on the
server inside of the VM but it is not
recommended because you're very limited
in terms of both performance and access
to NPM modules which we'll talk about in
a few minutes but first before we get to
those technical details why do we want
to run JavaScript on the server so one
thing that when I talk to folks about
this is that having a single language
providing client-side JavaScript in the
browser and writing JavaScript on the
server gives the team a lot of
flexibility so you don't have to have
two separate quote unquote teams that
are programming in two different
languages you can just use one language
across your entire team whether they're
writing server-side code or client-side
code and it allows a little bit more
flexibility in the management of a team
and you know all your developers can get
very good at javascript and they can be
interchangeable on different projects or
you know whatever for what what you're
doing in terms of where they actually
work and of course
javascript is very fast I talk about how
v8 is a fast engine and we'll get into
why javascript is scalable shortly right
another reason why javascript is
interesting is that the next generation
of web applications use something called
isomorphic architectures and what this
means is that code can run either on the
browser or on the server so if you're
building a react and anger or knockout
or any one of these different
applications in these frameworks you can
actually take your code instead of
having it run all in the browser which
is what a traditional web application
does when so if we think of a
traditional web app our code runs
essentially in the server right the
server can be Ruby or Python or Java or
PHP or whatever you have and your server
emits HTML which then is read by the
browser and then as users click through
your website you make a new request you
generate some HTML on the server etc etc
so this is known as a traditional web
application which I'm certain all of you
are familiar with in an isomorphic app
the line between the server and the
browser where the code is actually
running is a little bit more blurry ok
this is a diagram that kind of shows
that there's a bit of overlap here so
what this means is that as a developer
if you're using the framework which
support isomorphic style architecture
right that would be something like a
react today angular 2 also supports this
and newer versions of ember also support
this what it allows you to do is say
well you know what I want to just run
everything on the server and emit the
HTML that will then be consumed by the
browser or hey this app isn't too heavy
so let's just ship the entire app as
JavaScript up to the browser and
everything will run on the browser or
you can go somewhere in between you can
say all right what we want is we want
the user to have the best possible
startup experience or boot up experience
and there's a technique called
bootstrapping which you initialize what
the initial view of the web application
will look like on the server you send up
the library like react and then you send
up a pre bundled thing that is generated
by react on the server specifically
doing react render to string for example
and so when the library react wakes up
in the browser it already has what the
initial view should look like so it
doesn't have to do that extra step of
constructing the view inside of the
browser itself because it's already been
done on the server so this is a
technique known as bootstrapping and so
this is something that can greatly speed
up the launch time of your application
when user first comes to your single
page web app ok another common technique
with this isomorphic style architecture
is say you have a very complex widget of
some kind right
could be a good example is like an
Amazon search widget you know you go to
amazon.com or something or hands down
coat you kick here I guess and you punch
in that you're looking for something and
you get 20 results or 25 results but
each one of those results has
approximately 30 to 35 individual
elements right bus the price is a prime
shipping etc et cetera right the images
exhibition you take those 30 with those
30 components inside of each search item
you most of them buy multiply them by 20
you have 600 individual things that you
have to render so what you may want to
consider in that case is well this will
probably take a long time to run the
browser and especially after you do some
testing you find that that the
performance in the browser especially on
smaller devices like a phone is not so
great so you can actually in an
framework like react or Ember
you can actually say well let's actually
do an isomorphic transform of that
specific widget on the server and send
up the pre-rendered stuff that can be
directly plugged in without the browser
having to do all the construction of
those widgets okay so a couple reasons
why we're interested in javascript in
this case all right in terms of
isomorphic we get flexibility in terms
of where we render our components and we
can also do the low-level formance
tuning using isomorphic style
development so this is those are some of
the reasons why we care about JavaScript
on the server side right specifically
nodejs isomorphic applications and even
if you're not interested in running
JavaScript on the server still kind of
need to get up to speed on notice
because there are a large number of
tools for doing front-end web
development
everything from linting testing
packaging etc etc but we're going to
focus on the last bullet for a while now
which is building scalable server-side
applications and why note is great for
that
right there's lots of other things that
we can do talk about bundling and
development service ideas etc right
there ton of different modules that we
can use to help us build web
applications as well all right so let's
get into for a few minutes
why no js' is so scalable so
the basis of the nodejs or the
JavaScript engine is something called an
event loop and what happens is there's
this event loop you can think of it like
a spinning wheel as a request comes in
the wheel has to stop and do something
to service that request and typically
that will be something like let's go
look up some data in database or let's
read this file off the file system like
an HTML file or something and send that
back to the response all right so what
happens is a request comes in the event
loop stops and says oh this is what you
want me to do it then takes that and
moves let me get my pointer real quick
it takes that request so say it's for
pulling up something from the file
system or doing a database query all
right so what happens in this case is
that we go and get my pointer up sorry
about that
what we do is one of this not working
all right what we do in this case is the
nodejs engine will take that request and
move it over into the right side of this
diagram where it says posit async
threads so it essentially offloads the
work off of the main event loop for
reading off the file system or making a
network call to read from a database etc
etc so the event loop is freed up to
service more requests so you can have
multiple requests all coming at the same
time to serve up files read from a
database get some data whatever it may
be and those things get moved over onto
the right side so that the main event
loop can continue the service request
and not block while it's waiting for
those other things to finish ok so again
the goal of an asynchronous event rivet
environment is you don't spend it too
much time in the main event loop that
can service more requests and this is
the main reason why no js' is so fast
right we look at this from a slightly
different angle here right if we think
about something running on c-sharp CLR
or the Java Virtual Machine or the Ruby
interpreter or whatever environment
you're using this is how requests are
generally handled a request comes in to
read off the file system or we need to
go and grab something from a database we
have a sequel query and while those
things are happening while
that vowel oil is happening to grab the
file and send it as a response or while
we're making a network call to go and
grab something from our database that
thread basically is not doing anything
right we're just waiting for something
to happen so you see there's a lot of
red in this diagram while we're waiting
for those results to come back for that
specific request on a specific threat
alright so this is what happens again in
the JVM or on CLR you know PHP take your
pick whatever you're programming it when
we look at the same diagram in a nodejs
server this is what it looks like so you
have your request come in and because
we're offloading the work that takes a
long time quote-unquote takes a long
time read from the file says to make a
network call to grab something from a
database etc there's a lot more green
here you see the event loop is not
blocked waiting for doing stuff because
stuff is happening over here on the side
and not on the main event loop and this
is the reason why no js' is so scalable
it doesn't block on the main event loop
so it can serve thousands of concurrent
requests on a single process okay you do
obviously need to have some memory to be
able to have all these threads and you
know they go and do stuff and so there's
some memory needs to be allocated for
the the asynchronous nodes which are on
the right side of this diagram but again
we don't block the main event loop so
that's what makes no js' so scalable now
what happens is so if we just complete
this discussion quickly what happens
here is that when a thread on the right
side here reads that file or gets that
information off a network call to a
database it rejoins the event loop by it
by essentially calling the callback that
this call was originally set up with or
the function was originally set up with
and it reactors the event loop from the
right side back in and because the
context is already in the callback it
says oh this is a response for this
specific request that came in so it will
go pump the response up to the client
that made the request and then the
connection is closed right at standard
HTTP if the connection will be closed
okay so we have things coming into the
event loop from the left side which are
the requests and as things get serviced
the right side they also rejoined the
event loop so that it can be piped back
or the response can be set back to
whatever is making the request okay any
quick questions here before we move on
hopefully that's a relatively clear yes
sir yeah so the question was is it
possible to have more than one thread in
the event loop and the short answer is
no the event loop is only a single
thread okay so you can get into trouble
if you try to do too much on the main
event loop or to be more specific if you
use a non-blocking library right so
typically all the libraries that you
have in the node world for example
reading up file system or doing Network
i/o on the at the very very kind of low
level all those libraries will be
asynchronous in nature however you can
make a synchronous file call in nodejs
by specifying that that call should be
synchronous rather than asynchronous
okay or if you're doing like some heavy
computation or a better real-world
example would be say you need to
generate an image right like and use
something like image magic to generate
an image that you need to send up as a
response generating that image on the
main loop or in the basically your main
kind of event loop will cause a huge
slowdown so what you have to do is you
have to go and do some architectural
adjustments here where you have separate
processes that are meant specifically
for generating those images so you make
a network call even if it's running
locally right it'll be just on the local
pipe rather than it like a network call
and you offload that stuff onto another
set of processes behind your main entry
point where your requests are coming in
okay
what happens when you run out of a sink
Pollock threads that means your servers
run out of memory so what's that well
it's not it's not quite that it's not
quite that straightforward so so
typically you can configure your nodejs
to have a certain amount of memory but
but to get extra scaling on top of a
single process what you do is you scale
it out with multiple processes okay and
then you have something in the front
which is delegating it could be it could
be something as simple as a little
bouncer or you use a reverse proxy in
the middle of Britain and know that will
pump down to multiple processes so you
scale just like you would in the JVM by
having multiple JVM instances similarly
for nodejs you can have multiple node.js
processes and then just load balanced or
something at the top to get extra extra
scale okay it's a good question all
right so that said let's move on and
talk about some tangible performance
numbers now all right so on a single
nodejs process running on modern
hardware you can get approximately
10,000 requests a second which is quite
a bit actually on a single process
running on modern hardware ok this is a
fair amount of a fair amount of scale
that you get here what about if you're
running your same application on Java or
the CLR or Ruby or whatever right let's
just use Java for example because there
are a number Java developers here so you
say you configured a tomcat or WebLogic
or whatever on the same hardware and you
use servlet about how many concurrent
requests you think that would support
take a guess anybody how many four
thousand it's on a bad guess it's on the
high side anybody else all right so if
you go look at published benchmarks
around this a properly configured and
tuned JVM using the standard servlets or
something can support somewhere around
800 to a thousand concurrent requests ok
so you can see that there's a factor of
about 10x
in terms of pure scalability and again
this is all things being equal in terms
of the hardware and the memory and CPU
and stuff like that you get about a 10x
number of 10 X number of extra requests
that you could support on no js' yes sir
well I mean it is sink rest'
right I mean it's a thread based model
but but you know what I love it when
people ask questions about the next
slide right and you're right so you can
get some of the same scale on the JVM or
in other programming languages but
specifically in Java using something
like vertex ok or using something like
rx Java and you know properly following
their asynchronous pattern right but if
we just talk about vertex for a second
or even if we talk about rx Java it's
not like you put in your vertex library
into your project you sprinkle some
magic dust on it and boom you're done
right it's not it's not that
straightforward because what you have to
do is you have to wrap every single call
that you make in terms of whatever that
logic is doing or whatever that
processing you're doing you have to wrap
every single call in a vertex vertex
asynchronous object right so it doesn't
come for free at all you basically have
to rewrite your whole application to be
able to get that scale if even one thing
on the chain of different things that
you're doing as part of whatever that
processing is right whatever that HTTP
endpoint or or what you're doing is if
even one thing is making a synchronous
call it breaks down the whole kind of
scalability around that ok so you can do
this on the JVM and if you look at the
numbers that are put out by the vertex
people you'll see that it approaches
somewhere around seven eight nine
thousand concurrent requests but again
everything has to be wrapped in vertex
objects async objects and everything has
to be done asynchronously so you can't
approach that if you want ok
jax-rs okay does jax-rs now support
asynchronous style callbacks okay yeah
okay i didn't know that i don't use
jax-rs so so many so many libraries in
so little time right so okay this time
would that answer your question sir
okay great right so let's talk about an
overall architecture now right this is
kind of what our architecture looks like
we have stuff I don't wanna call it
legacy because we're still building them
right we have business layer and API is
written in Java and Ruby we're working
on some stuff in Python in terms of
machine learning when you have if you
have a startup today if you say two
words you get a lot of extra money if
you say BOTS or AI and machine learning
people will just throw money at you
which is great so anyways so in our
architecture we use quite a bit of Java
and quite a bit of Ruby but we fought
that stuff with nodejs
that box that says javascript there we
front it with nodejs so that our
presentation layer goes first to our
nodejs layer and it will intern you
directly go to a data store and grab the
data if that's the right thing to do
or it will go down to our business logic
slash API layer and go get the stuff and
maybe convert it to JSON or do some
small transformations across whatever
data needs to be sent back and then send
it back up and also allows us to do
isomorphic transforms directly in that
javascript player and go fetch data
underneath whether from the data store
from an api business logic layer and if
we need to we can do an isomorphic
transform in that JavaScript layer and
then send back to whichever platform is
calling the data or a transformed
isomorphic lis transformed widget so all
right so this is our kind of overall
architecture it's simplified a little
bit but this is more or less what it
looks like okay and one of the other
great things we get around this is we
get this layer of protection between the
client itself and our business logic and
API layer because if there's a huge
amount of traffic that comes in
simultaneously from some whether it's
web or mobile those requests can
you up now in that JavaScript of nodejs
layer on top rather than going and
hammering our Java or Ruby
infrastructure right so it provides a
little bit of firewall if you will
between our actual kind of where we keep
our business logic and sensitive data
and the layer on the bottom right and
concrete example this actually is we had
somebody try to do a password cracker
tac against our infrastructure and what
we were able to do is detect that there
was way too much traffic coming in to
that JavaScript layer so we're able to
go in and without touching the stuff
here at the bottom on the business logic
and API layer we're able to go in and
add a large group of IP addresses to the
black list directly in the node layer
and not have to touch anything
underneath right so wait it gave us a
lot more flexibility in being able to
deal with a large scale or a heavy
concurrent attack on trying to crack
passwords were able to do it right at
the top and not have to worry about the
stuff that was at the bottom which
actually had the real sensitive
information okay all right so any
questions on this architecture we'll
talk a bit more about this but any quick
questions before we move on nope yes sir
yeah okay so the question was is when we
talked about this queueing how does that
compare what streaming well these are
just requests queueing on the the
network stack basically and I obviously
request it we don't wanna get too much
into the nitty-gritty of this but
network requests queue up in the network
stack and then as the the event loop is
able to it picks up those requests and
turns it into you know a memory request
objects etc etc right which is standard
across all platforms more or less but it
in terms of streaming are you asking
about like if just help me clarify the
question okay yeah so I think queuing
and streaming are two totally different
concepts in my opinion right so the
streaming I would think of just as
requests coming in but those but I also
think of streaming I think of a stateful
connection
rather than a stateless connection
because HTTP is stateless as you know
and if you have a message bus or if
you're using WebSockets that is a
persistent connection that is using that
basically know the connection doesn't
get destroyed but I'll talk about that a
little bit more detail in a few minutes
okay so we'll talk about that shortly
assuming I don't run on time all right
so I don't want to go into too much
detail on this I'm going to skip over
this or go through this very quickly but
for those of you who aren't familiar
what it'll be at least a starting point
so the ecosystem when you get nodejs
comes with NPM which is the node package
manager and that's where all the
libraries or what are known as modules
in the node world live all right we
already talked about how nodejs is a
JavaScript runtime based on v8 NPM is
the node package manager that's what you
use to manage dependencies and those
modules can be things like Express which
is a very lightweight server-side web
framework and grunt and gulp are used to
build out a build system or run tasks
and things like that web pack is used to
do a packaging of assets for the
front-end and Jasmine is used for
testing etc etc lots and lots of modules
in the no js' ecosystem sorry so you
just install node.js using brew or just
download the binary directly you can run
nodejs
pretty easily if you have a file called
test KS and it says console dot log
hello you just do node test KS and it
will go run it right well the great
things actually about development in the
node world is that because javascript is
a dynamic language that doesn't have a
compilation step like other languages do
you can just do hot code injection
directly into a running system so it's
great for development because you never
have to restart a server you can
literally change some code have some
tooling setup that will hot inject or do
what's called HMR or hot module
replacement directly into running code
right so when you're doing development
it's really nice because you just write
some code you hit save and that thing
will get replaced in the running system
and you can run a test or you know see
what happened with your new code as
you're building out a system
and to describe a server-side JavaScript
project you created a package JSON and
most interesting thing on this specific
slide is the dependency section this is
where you specify where and this pointer
is a little weak so you can't see it but
the dependency section is where you
specify the dependency that you're going
to use for this project and there's also
another section called dev dependencies
for things which you just use during
development but it's not necessarily
used at one time if you will all right
so let's talk about NPM for a few
minutes this is what is the basic
package manager nodejs it comes with
nodejs you don't have to install this
separately and when I first gave this
talk about a year ago there are about a
hundred twenty thousand packages in the
NPM repo when I last looked this past
weekend there are about 300,000 packages
or libraries in the NPM depository and
you might think it's at this point and
of course my internet is not working
here so I can't actually show you the
NPM repo but that's ok
now how many packages do you think are
in the central maven repository for Java
anyone know let's take a guess everyone
wants to guess everyone loves maven so
much so if you look last time I checked
I think they were approximately
somewhere between fifteen and seventeen
thousand things in the central maven
repository right these are open source
projects like you know you'll have jetty
in there and log4j and all those all
those things that use probably on a
daily basis or on certain projects or
whatever right vertex we talked about
that so why are there so many packages
in the npm repository the reason is
because it is super easy to create a
project in github and publish it to the
npm essential npm repository if we have
internet connection if we had time it
would take me approximately 60 seconds
to create a
package.json push it up to github and
publish it to the npm repository right
it's so easy and that's great because
that means lots of people can contribute
projects that they're working on but the
flip side of that is people are like
whoa I've got this great CSV library
I'll go add it to the thousand that are
already available in the NPM repository
right so it's kind of a double-edged
sword it's great that people can
contribute what they're working on right
it's um maybe someone created a nice CSV
library of some kind or whatever right
so there's lots and lots of packages and
this is one of the main challenges in my
opinion in the node world is that
there's so many different packages for
doing the same stuff like how do you
pick something right we've if we were to
go search the NPM j/s org site for CSV
we would literally get around 1,300
results back all right and to be honest
with you I don't think we need more than
one or two CSV parsing libraries right
it could be wrong I blacked on my check
CSV wasn't that complicated so one of
the challenges is how do you figure out
what to use right so what we do and what
most people do is if you go to their
site and you just do a search it will
sort it by something called best best
results the best results incorporates
popularity quality etc etc so you can go
there and usually the top couple of hits
will be what you want to use because the
most people use them they have a CI for
it that runs unit tests and have a large
number of contributors so it's not going
to be a project that's dead in case
someone gets hit by bus or something
okay so that's one of the challenges we
face is that there's a lot of
overlapping tools and NPM from the
command line is pretty easy to use you
can go into a project and do NPM LS
which will show you all the dependencies
which are in the package dot JSON and
then you can install things as you wish
NPM install lodash by in this case I
have a - G flag which means it installs
it globally rather than inside of that
project itself and if I did - - save it
would actually add it to my package dot
JSON so that when a teammate pull down
the repository or pull down that
specific project and they did
an NPM install it would get added to
their project as well or it would get
hydrated in their project right so it's
simple framework to give you an idea of
the the kind of motif in the node wall
and this is very important I think to
understand like what the community is
like and what the the development motif
is in a specific programming platform so
if we look at something like Express
it's a very basic server-side web
framework and when you say basic how
basic is basic well when you go get
expressed say one typical thing that you
want to do in a web application again
this is server-side is you might want to
do section management right you probably
want to do session management well guess
what Express doesn't come with session
management you have to go get an NPM
library to add session management okay
something is basically session
management cookie management etc etc is
not included there are other options
like sales KOA Getty etc happy is
another one that are more full-featured
frameworks that already pulled together
a number of different modules to have a
more complete solution but it's very
different than say in the Java world
where you have Java EE and if you're
using a Java EE server like web logic or
WebSphere or whatever it may be you get
everything in the kitchen sink that you
would possibly need to build an app
right in the JavaScript world you can
get this but the motif is you build the
most simple slender solution possible
you say okay I need session management
let's add that in I need course
protection let's go get a library that
helps us with course protection ok I
need to access a database ok let's go
get a specific tool like sequel eyes
which goes in it's kind of like or I'm
light if you will for Java Script all
right so there's all these different
things that you can add in but you go
and you say this I want this I want this
and you build exactly what you need and
have nothing extra in it that's the kind
of motif or the mentality in the node
world is you build something that's
super fast and a slender as possible and
doesn't have a lot of extra baggage
inside of it ok so
express also follows the event loop
model and is asynchronous and
event-driven because of that it's super
scalable so it builds on top of the core
kind of JavaScript node runtime and
being async and event driven and so when
you write a express solution it will be
very very scalable right out of the box
and of course you have to be careful
that you don't throw in synchronous code
or do much too much processing on the
main event loop and you'll be fine okay
so this is a quick example you add in to
a project and then you fire NPM app and
again nodejs is a different universe
than what you may be used to for coming
from the jungle world or from c-sharp or
if you do jangle and python whatever it
may be Ruby on Rails okay it's very much
a assemble your own framework type of
mentality you don't get you can't go get
a framework that has everything inside
of it but most people don't go down that
route most people will do what I said in
terms of build exactly what they need by
starting very simple with express and
adding stuff on top as they need it
adding these small modules on top as
they need them alright and again it's
also frustrating because there's a lot
of overlapping tools with all the
packages or NPM modules which are
available and there's no one way to do
things and this can be usually the
biggest challenge up front you get that
whole analysis paralysis and well what
framework should we use and now I need
to do this you know so it can be a
little challenging but again hopefully
you understand what the motif is so
let's quickly look at some tools to give
you an idea and the one I primarily want
to talk about is socket IO oh and we'll
get to why I think this is important in
just a minute
socket IO is essentially a web socket
implementation so you're probably
familiar with HTTP being a stateless
protocol right web browser makes a
request to a server server does it stuff
sends the response the connection is
broken web browser needs more stuff it
will make another open another network
connection etc etc it's a stateless
protocol what socket IO allows you to do
is allows you to implement a stateful
connection from the browser down to the
server so that
the browser can get more stuff without
having to have the overhead of creating
a new connection and the server can push
stuff up to the client that's connected
over a WebSocket connection which you
cannot do on a stateless connection
because obviously stateless means that
the connection goes away as soon as the
request is finished so a WebSocket is a
persistent connection from the browser
down into the server and those jeaious
handles the scalability around this
really really well because of the event
loop model okay so someone was asking
about streaming a few minutes ago
so we could have all these instantiated
network connections on the server and if
nothing's happening on them the event
loop will just continue to spin but when
something does come in a request comes
in on that stateful connection it will
rejoin the event loop and the server
will say oh it looks like you want slash
users so JSON or something right or
whatever some data and it will go and
grab that stuff send it and take that
connection off of the main event loop
and just keep it basically on the
network queue if you will
waiting for connections and because
node.js handles a large number of
concurrent connections very well it's
well-suited for running WebSockets okay
and the implementation of it is actually
very simple you socket dot IO and on the
server you can just say IO dot emit on
this channel so you can have multiple
clients connected at one time and you
can set them up in their own unique
channel or have them subscribe to very
specific channels and you can broadcast
to multiple clients if you want or you
can just send a message to a single
client it's up to you as the developer
so in here I'm saying from the server
send on the announce Channel this
specific data write that block of JSON
and then on the browser you say socket
when I when something comes in on this
announce Channel go fire this callback
with the data and do some stuff okay so
the reason why I think this is important
is that run the long march to http two
right now and one of the key things in
HTTP 2 is that when you the developers
set
stuff in the browser right you send your
single page application or even if it's
just a normal non single page
application you can give a hint to the
browser to say upgrade this connection
from a standard stateless HTTP to
connection to a stateful HTTP to
connection which essentially looks like
a WebSocket so web socket is included in
the HTTP 2 specification ok so in the
future when browsers support HTTP 2 and
of course you have to have servers
support HTTP 2 as well you you as a
developer can opt to create a stateful
connection upgrade from a stateless
connection to a stateful connection if
you want for whatever business problem
you're trying to solve ok so that's why
I think it's important to talk about
socket IO and again note supports at
scale very well and again we'll come
back to this architecture diagram right
so in this case if you already have this
architecture what we can do is if if we
decide that we're ready to use HTTP 2
and not for our users are using HTTP 2
based browsers we could just in the
JavaScript and node layer there on the
top right we can just say all right
we can handle this scale we don't need
to do anything special we may need to
add a few more processes to support
those extra concurrent connections right
because if you think of the reason why
HTTP 1 or 1 dot X let's say is so
scalable is because say you have a
thousand requests come in in a hundred
seconds right I'll just do this to make
the math easy on myself so you have a
thousand connections come in on a
hundred and within a hundred seconds and
let's say they're just averaged out that
means you have the requirement is that
you need to be able to support 10
connections a second right 100,000
divided by 100 is 10 so the least you
have some baseline in terms of like what
your peak performance requirements are
and the reason why we can do that in
HTTP
1x and think of it like that because
again the browser makes a stateless
connection server processes it send the
response connection is broken now say
you
have you're using WebSockets or using
stateful connections in HTTP - all of a
sudden instead of being able to support
ten connections a second you have to
support a thousand connections for the
entire 100 seconds so you no longer have
the ability to just toss it away right
at the end once the request is done you
have to have that extra scale again this
is our contextual choice that you the
developer has to make right do we need a
stateful connection most applications in
my opinion don't need a stateful
connection but you might say hey for
this new version the app we want to have
some streaming data always coming from
the back end or whatever it may be or
we're getting a lot of data so we have
that need for a stateful connection so
we don't have to create a you know a
news network connection an HTTP
connection every blah blah blah right so
you may decide that you need that and
that's when HTTP 2 will be important to
you all right
quick time check all right so two
closing thoughts you have to remember
that this is still JavaScript so when
you write JavaScript on the server it is
still asynchronous and event driven so
that means that it is not for every kind
of application and if I go back to this
diagram we have no intent of changing
our business logic and API layer and
moving it into JavaScript and the reason
for that is we have complex business
logic just like you do we have certain
things which are simple business logic a
lot of things which are moderate
business logic and then some things
which are high complexity business logic
right processing getting data massaging
gait all sorts of different things
whatever your business problem you're
trying to solve now the issue in my
opinion with doing this in nodejs is
that because everything is async and
event driven you have to have everything
wrapped in callbacks or everything is
wrapped in callbacks by default and what
quickly happens is if you need to do a
chain of three different things let's go
grab all the items from a database we
need to go get pricing data from the
server over here and then we'll need to
make another database call to go and get
some additional data based on those
first two calls so you have to string
those three asynchronous calls together
and that leads into one
donuts callback hell right so it's
actually a technical term called
callback hell and the toad is not very
apparent right so if you're looking at
it it's like okay we do this and then
because we're going and you know things
happening over here but our main code is
all written over here
if something happens along the way you
get error --air troubleshooting is an
issue and just kind of thinking through
an application can get cumbersome if you
have complex business logic there okay
so it's not for every kind of
application it's great for things with
their simple business logic but things
which require a lot more kind of
complexity to model and properly
implement you know we still keep down in
the Java or the Ruby layer because it
works much better for that and keeps us
sane in terms of being able to build
these things and not have to work it had
this added complexity on top of the
actual business complexity that we're
doing okay all right so another kind of
real problem and I hinted at this
already is that there's a lot of Turner
there's you can do Google JavaScript
fatigue and you'll find lots and lots of
blog articles where people are talking
about this and the issue is that there's
quite a bit of movement in the
JavaScript space right now it's on the
client-side or even on the server side
so if you're those you peer those
developers who built a big single page
web application using angular one well
guess what angular 2 doesn't look very
much like angular 1 so you may have to
do a partial rewrite all right you can
still they have a migration path forward
but there's some code that needs to be
written right if you're using other
frameworks like react react is also
changing very quickly nowadays so and
similarly for lots of different things
in the JavaScript world there are things
which are changing very rapidly so this
can lead to what's called JavaScript
fatigue in terms of figuring out what's
a good medium to long term set of
libraries and architecture to base your
stuff on all right
so as I shown in the diagram we tied
into a we entire stuff into existing
infrastructure underneath that has our
data stores and business logic and api's
and one of the things that we do is in
this diagram the the nodejs layer here
is actually just runs as a micro service
right remember I said I get 10 bucks
every time I say micro service so so so
we actually just run that as a micro
service the other stuff we don't
necessarily want as a micro service but
the JavaScript layer we do because it's
a little bit easier for us to scale that
out and that's where we need the scaling
so it's easier for us to manage and
scale that rather than doing a straight
deployment onto a raw metal or something
like that okay all right I think I've
been through all the closing thoughts
and we have a few minutes for questions
I believe okay there are some references
and we have four minutes for questions
so let's take some questions for a
couple minutes
the next speaker here I'm going and
unplug I think you suppose started to
1225 but anyway
questions comments thoughts everyone's
just ready for lunch no yes yes sir
so you said that you have your API on a
separate layer and then you have your
your know layer except not requests so
what would be the difference between
that which is got to pass through to the
API anyway and just scale now to your
API and load balance and amongst that
okay so the question is what was the
difference between kind of load
balancing at the top layer versus down
at the API layer is that right so so for
us it's more about being able to manage
the the kind of capacity that we have
down in that layer rather than having to
manage it like at the top or is
basically we offload the the raw
capacity we need down at the bottom and
move that capacity up to the top yes you
still need capacity at the bottom but it
just allows us to do a little bit better
kind of management of that right you
don't have to do that to be honest with
you all right and the other thing is
that if we do want to do isomorphic
transforms of of data coming from that
API or datastore layer it allows us to
do that isomorphic transform as well
alright so that's the other kind of
keeping
and as I mentioned in the future if we
decide that we want to use WebSockets or
HTTP staple connections HTTP to stateful
connections we already have that
infrastructure in place so it's not as
major of a change because we already
have kind of multiple layers and stuff
like that so okay four questions well
here you talked about state state point
stateless if using a stateful connection
can you then in that same browser such
as I'm done with State forward go back
to stateless okay so the question was is
say you want to get rid of a stateful
connection absolutely there's no reason
why you can't you just kill the
connection basically right because when
you go from stateful to stateless you're
basically just terminating the
connection okay yeah more questions
right right over there
how are you going to mitigate the
maturity of JavaScript you say how am I
going to mitigate the the maturity or
the kind of flux in the JavaScript
environment it did show it may not be as
bad as I made it out to be it all
depends on like kind of what your what
tools you're using and and like kind of
what level of JavaScript proficiency you
have so one thing that we do is we tend
to do things which are not exciting all
right so you may think you work at a
startup you're not on the bleeding edge
nope we still run rails 3.2 we haven't
even considered moving to rails 5 right
we're still running Java 7 right so at
the end of the day for me my main goal
is to deliver stuff to our customers I
don't care about using the latest and
greatest stuff I prefer to be safe you
stuff which is stable that lots of other
people use right so that's how we
mitigate that kind of maturity thing is
we use things that lots and lots of
other people use right so we try to stay
away from things which are less used or
esoteric right we let the people who are
a little bit more a little bit what a
little bit more excitement in their life
do that kind of stuff because I prefer
and the reason for that it's not that I
don't like the cool stuff the reason for
that is that my startup there exactly
three people including me who write code
and I don't like to be on call all the
time when when stuff breaks right none
of us do so and plus we want to get
stuff done we have to develop our value
to our investors and to our customers so
that our investors don't give us a hard
time so anyways so stay with the herd is
basically the mentality that we use and
that's super helpful
inglis all right I think we're at the
end thanks for coming y'all I hope you
enjoyed the presentation</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>