<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Keep It Simple with Scala | Coder Coacher - Coaching Coders</title><meta content="Keep It Simple with Scala - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Keep It Simple with Scala</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/A7_Fk2X3C60" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hello my name is Alan Barsky and I
would like to talk about how to keep it
simple with Scala so I'm going to do
three short live demos of libraries
through which you can express sometimes
complex concepts and con and complex
business logic in a very elegant way and
simple way so you know simple doesn't
mean that it's easy but it's going to be
easy to read at least in my opinion and
hopefully easy to understand for
somebody for ease at the code as well
and of course we will be using Scala and
so I have a couple of slides just as an
introduction and then we will start the
live coding sorry I will have three
three examples if any one of them is
boring you can always hope that the next
one will be more interesting and if you
have any questions throughout the talk
you know if you don't understand
something please let me know okay so and
the general plan is to first take a look
at Scala async it's colorizing because
it lets you write a synchronous code as
if it was synchronous and then I'm going
to take a look at my choir it's a very
nice library and I'm saying that because
I wrote it which lets you implement
dependency injection without the
framework mainly using Scala constructs
and finally we take a look at spray
unfortunately I didn't write spray but
it's still a great library and and we
will be writing a simple rest server
with that so just to take a look at
these three libraries that we are going
to talk about so first it's colorizing
Scala icing transforms blocking like
code so called a routine a traditional
blocking like way into a non-blocking
version it is based on macros so the
transformation is done at compile time
there is no runtime overhead it is as
column oh you it
it is a Scala module and so that means
that it is maintained by the Scala
people by typesafe and there was also a
similar project a couple of years ago
like four years ago or something like
that
called a cadete flow however like the
functionality was very similar however
if used continuations instead of macros
so continence is the old way and it's
not fashionable so now we are using
Microsoft that's better and but apart
from the fashion argument and Scalia I
think also provides better error
reporting which is very important when
we have to deal with with the generated
code so that's the first library and the
second my choir and my choir generates
wiring code for classes instantiation
and what that means exactly we'll see on
an example shortly
it is a micro based as well apart from
the core di concepts that it helps you
with it also contains implementations
for interceptors and scopes which can
help you write web applications or
implement AOP also using almost
exclusively Scala constructs instead of
using a dependency injection container
or framework and and finally spray IO
has a very nice center this describing
it is an open-source toolkit for
building rest HTTP based integration
layers on top of skyline dhaka so what
it means so I took I took it from the I
website and so what it means is that it
provides a DSL and the HTTP server
implementation will be tooken in a very
elegant way right high-performance
servers it is based on on ARCA and in
fact it was acquired by akka some time
ago so as spray will become an archives
ttp in the next release or so okay and
finally a bit about me so that you know
who's talking to you and I'm the
co-founder and
engineered subdermal software Mel is a
great software house in Poland we have
clients mainly in the US but also in
Australia and South Africa we are a
typeset consulting partner so we do we
do a lot of Scala and I am also involved
in a couple of open source projects some
time ago I wrote hibernate anniversa
library form and auditing entities and
you know I wrote my query as I mentioned
and a couple of others I wrote a
technical blog I invite you to visit it
hope I in my opinion there are some
interesting things there of course and
yeah and I have a Twitter account
which is probably not very surprising ok
so let's start with the first example so
first Scala Isaac and I have some code
here so that's just going to print
time-stamped the back messages and as a
running example and we will be using a
cooking restaurant themed so in the
first demo we will be cooking dishes ok
so we will need them this class which we
will be creating and the dish class will
have a method which will allow its to be
combined with another dish ok so it has
a pass method and it takes another dish
and it returns a dish which has a
combined name ok so that's it and now we
have a cook method so the cook method
takes the description of what should be
cooked and returns a dish right so
ideally we would have some asynchronous
i/o with the stove or the oven but we
don't have that here so we will just to
do a thread sleep to sing to simulate a
actual cooking process so you know you
can do such things in a demo and we just
print that it's cooked
as what cooked and we will return the
cooked dish okay and finally we will
have a method for actually serving the
dish to the customer and it would has to
info
here's your dish okay so that's like our
infrastructure that we are going to work
we have a dish we have a method to cook
dishes okay so now a client comes to our
restaurant and orders steak with
potatoes okay so how so what do we do it
we cook the dishes right so first we
cook the steak and then we cook the
potatoes and we serve the steak and
potatoes okay we can now run our code to
see if scale actually works still you
never know with demos okay yeah it's the
works so as you can see like at the
first first we can we cook the steak
then we cook the potatoes and then we
serve the dish right and that's all very
good however you know we live in a world
where cooking takes one second so before
we actually cook the potatoes the steak
code code right so the customer is
unhappy so we have to somehow paralyze
cooking of the steak and potatoes okay
so there is a thing in Scala called
futures which lets you wrap a block of
code and it's going to be executed in
the background and then eventually when
that code finishes you you you can get
the result right and that's going to be
our first approach to the problem and
okay so let's now wrap this into a
future blocks right so we wrap these in
two futures
and we wrap that in the future as well
okay so now we have two futures right
and so actually the type of of this
variable is going to be a future dish
right so in the future we'll have a dish
right it's going to be cooked in the
background and however you know to
combine the dishes in to actually serve
them we have to somehow unwrap the
futures right so SCARA has very nice
syntax for that for comprehension which
lets you unwrap such kind of things so
we can unwrap the future steak we can
unwrap future potatoes and finally we
can serve the dish right so when we are
when we unwrap things right they from a
future they become the dish itself right
so this here is going to be an unwrapped
so this here unwrap the dish that we
have cooked and now the whole the type
of this has this expression is also
going to be a future okay so it's like
our future serving let's say and can see
that that's a future that's a future you
want to try it because our server
transiti your returns unit so what we
have now is we have the combined dishes
but in the future as well right so if we
run this the main program will terminate
before anything is cooked so we have to
wait until the future actually completes
and so we have to wait for example for
10 seconds
and we have to do some imports so and we
have to import the nice it's kind of
concurrent direction okay so the away
dot result method it takes a future and
it waits until the future is ratified
most ten seconds right so here we will
it will take like one or two seconds
right so we are safe and so yeah let's
try running this and let's see if it
helped to prevent our steak from getting
cold and I didn't import an execution
context right so so the futures run is
some code in the background so they eats
an executor on which the code actually
run well run so we can either provide a
custom executor or we can import a
global so we will import the default
global executor scholar concurrent
execution context its global if I don't
have to worry about that just import it
and it works okay so we run it and we
see that it didn't help right stir the
steak is cold right so we cook the steak
and then the but we only start cooking
the potatoes after the steak is ready so
why is that well what we have written
here is that we cook the steak in the
background and we unwrap it and only
then we start cooking the potatoes in
the background and we are not and we
unwrap it so the solution here is to
actually first kick off you know the
background computation and then do the
under then do the unwrapping so that's a
simple transformation so we first future
steak is going to be future
it's alright we're going to be future
cook steak right and that's a hardware
or the tops
yeah it's rocks right future
okay and now here we unwrap
right so let's run this and hopefully it
right now it will help yeah it did help
right we can see that the potatoes and
steak already at the same time so they
don't get cold and our customer is happy
okay so the crucial point here was that
we have first to create the futures and
only then do the unwrapping okay so now
so far we have seen only sky
now let's use Scala acing actually to
make our code a bit more about old
fashioned let's say so what we have to
do is we have to import Scala ASIC first
sync
do I have to import the object but I
don't have so it's got optimized and
just a second then so let's remove that
and we will just write it in them
I wrote it here well write it in and I
think from this way okay so when using
Scala I think instead of the future
keyword or the Future methods we use the
async method you think you think okay so
now so now like the beginning is very
similar so we take this code here and
instead of wrapping it in the future we
wrap it in an async right and like the
the async the basic functionality what
it does is it takes the code and the
transit in the background so that's very
similar to a future right so far and we
have also wrapped the whole thing in an
async because then we want to transform
the whole code into a non-blocking
version so so far it's it's it's is it
the same however now instead of doing a
for comprehension we can do something
else so we can use a wait
to unwrap the future wait if we take a
look at the at the signature
it takes the future of tea and returns a
tea okay so it is kind of similar to the
big 808 that we have seen here
however this a weight doesn't block okay
it's a non-blocking await and then we
wait for the potatoes and we serve it
okay so now we are using no for
comprehension and let's see if it works
I just have to assign this their future
as well because like the whole result of
the async block is also a future right
okay it work we can see that the steak
and the potatoes are cooked at the same
time and they are served a both hot
right so what we have done here is we
have wrapped our computation inside an
async block okay and then we have kicked
off future computations again here we
have used a sink we could have your
future it would work as well but does
you know so that we are we use uniform
the same keywords we can use async here
and finally the main point is that we're
able to a use a weight to actually
unwrap the future right and you know we
don't have to write any pro
comprehensions
we just write the code as we would have
written it if it was a synchronous code
right so what actually happens is I
think as a macro so it takes the code
that is passed to it and it transforms
it at compile time into a non-blocking
version so actually actually the code
that you will this will end up as a kind
of for comprehension so the compiler
will transform it to a series of core
for comprehension and so on so like the
end result would be similar to what we
have seen initially and but in
with the nicest simplex okay so and when
did when this gets really useful is
let's say we have a method if the
clients want rice instead of instead of
potatoes so we can wrap it in a future
and yeah we will wait for let's say 500
milliseconds and we will return a random
food okay okay so the client sometimes
wants fry sometimes does right so now
what we want to do here is we want to
say if the client wants rice all right
then we will serve him rice in a second
otherwise we said we serve the client
the steaks and potatoes right and if he
wants rice we first first have to cover
the rice so we know kind of optimistic
locking we assume that everybody wants
potatoes but that ones it's always and
it's like our restaurant strategy so we
cook the rice and now we wait for the
rice over here right so this doesn't yet
exactly right so we want to do it in the
background as well so this won't compile
just yet because the once rice returns a
future
bunyan right in the future like we send
the waiter go ask the customer if you
want some rice and it takes half a
second it's a very fast waiter and he
goes back with an answer right but said
it's a it's a future boring so you can
just write a wait here to unwrap the
future and we also can use it in a
conditional right so now we can run it
and hopefully we run it a couple of
times so this time the we got potatoes
and yeah oh and that we got rice see so
there's like a slight delay so this take
is a bit cold but it's it's variable
hopefully okay so now writing such a
conditional if we have conditional
future logic where we have some futures
that we ought to unwrap in one branch
and some other filters in another branch
writing that with the for comprehension
would be very complicated and it would
look ugly so it was it wouldn't pretty
be very readable and if we are using
await and the transformation and now
this is a in my opinion that's very easy
to read right you just you know we you
can you can read it as if it was
synchronous code right all the
transformation into the for
comprehensions and unwrapping the
futures and so on this happens in the
back this is done at compile time by the
compiler
okay so let's that's the first example
let's continue to the second exam
require that okay as you can probably
guess from the name it's going to be a
demo of a coil okay we're going to
extend app so it's going to be runnable
application so we will continue our
restaurant theme so what we will be
doing here so we will be looking at
dependency injection okay so if you
think about dependency injection right
probably is a known concept it's a like
a very well-known pattern so the idea is
that if you have a class which contains
some business logic and if it calls some
other classes it shouldn't a however it
should have an abstract dependency on
the classic it it uses so that for
example we can substitute dependencies
for testing or stuff like that right so
there's a lot of dependency injection
containers which actually help you to
implement that pattern but if you think
about dependency injection
you know especially if we look at the
case where we have constructor where we
express dependencies using a constructor
in fact it's just passing parameters
around right so like the essence of the
dependency injection pattern is using
constructor parameters and that's what
we are that's what we are going to do
here okay so first we need some example
classes which will contain like we have
a business classes let's say we want
them to wire and and do something with
yeah so we will have so now we will take
care of actually preparing the products
for for a restaurant so we have that
field and on the field we grow potatoes
we will have a digger extracting out the
potatoes we would have a potato farm and
the potato from has two dependencies
right field and a dagger and then we
will have cow pasture and you can X I
think you can I know what you can expect
next we have a material which actually
turns the cows into me
and finally we have a restaurant which
takes a potato farm and the bittern and
there's a single method order steak with
it was and and then it's going to us to
that friendly welcome yes okay so like
we can imagine that when we actually
involve that method
our other example with the cooking isn't
working but we won't do that here okay
so our goal now is to invoke the order
steak with potato metal on an instance
of a restaurant right but first we need
an instance of the restaurant and to
have an instance of a restaurant we
actually need to satisfy the
dependencies right so we need to pry the
potato meter and so on so like normally
you can imagine that all these classes
would live in a in the different
packages right so you know in a normal
application you have a lot of classes
among is spread among packages here for
demo purposes it's all going to be like
inside one class but that's only for the
demo and also just for the demo I will
make these case classes so that I have
nice to string and implementations out
of the box okay so now we will start
with a very simple thing which is called
manual dependency injection and we are
going to create the instances manually
okay so we are going to have few which
is a field bigger potato farm so now we
create the potato farm right and we have
to find provided dependencies so we do
just that and then we have the cow
pasture
and we have the meat meter it depends on
the cows and we have the rest potato
farm and okay and now we can invoke the
method order steak with potatoes we can
run it and see again scholarworks
and that's not the right one it's the
computer okay now okay we got it so it
works so in an application where you do
manual dependency injection you would
have the wiring code so the place where
you actually create all the instances
and satisfy the dependencies somewhere
you know at the end as far as possible
so for example like here we have the
entry point for the application we have
the main method right and that's a good
place to actually do all the wire right
so we specify the concrete dependencies
as late as possible okay so now we can
improve that in a couple of ways so
first of all Escala thing what if we
swap this tool right and if we now try
to run it we will see that and we get a
null here and that's because we have
used the digger right we have used the
digger here before actually creating it
so it was not at that point
so Scala has a simple mechanism which
can help us with that it's lazy virus so
if we do all these were lazy there will
be only computed on-demand and now Scala
will automatically figure out the right
order in which to create dependencies
right so now and so now we can define
the dependencies in an order and and
Scala will figure that out okay so the
second thing second thing is actually
writing the new class instantiation code
like here it can be a big it can be a
bit tedious right so you have you know
you have to write the new we have to
write all the dependence
is dumb and so on so my choir is there
to help you with that so we can extend
them a choir trade and now we can
replace all the news with a wire and I
will explain a second what exactly to us
we get rid of all the dependencies yeah
wants to keep the rest off okay so let's
just see if it still works hopefully we
will get the same result we do we have
like the restaurant with all the
dependencies why okay so what wire does
wire again is a macro so it runs at
compile time right so it takes a class
for example the potato farm and as it is
a market for us at compile time so it
has access to the whole ast of of the
code so it can inspect the steal of for
example the potato farm okay so what it
does it looks at the primary constructor
it sees what kind of dependencies it has
so the potato farm has a dependency of
fields right so it's tries to look up an
instance of field and then in the
enclosing context right so in in that
case it will look up an instance of
field in the object M acquire them okay
on an any parent class and so on and and
actually and then we'll then what to
generate is the new potato farm with the
correct dependencies so if you take a
look if you de compile the code that's
created by by this and and the previous
one you will get the exact same results
right so at the bytecode level and now
it's it's it's the same as writing it
manually here it saves you a bit of
typing right also for example now if we
add the dependency so let's say that our
cows like potatoes so now the cow
pressure has a dependence on a potato
farm right so we can just run the code
we don't have to actually change our
wiring code and you can now see that the
cows have the potato farm provided
okay so it's a very easy way to do
dependency injection right you don't
need any kind of containers like if you
if we have used for example juice or
spring or any other dependency container
what we would have to do is we would
have to write the add inject annotations
here right then we will have to package
it up in a draw
would have to put it in an application
server or such and then when the
application startup the container would
actually scan the jar it would scan the
jar for classes which have 18 checked it
would then by reflection look at each
class and check its constructor and then
it would it was try to to actually
create the graph here we have a very
much simple thing a very simple thing
right we use only Scala and what would
the help help of wire but that's like
result at compile time and it's also
entirely optional and it's it's a type
safe so at the moment of compilation we
know if the code compiles of course we
know that each class has all of its
required dependencies right and yeah and
we don't need any kind of containers so
it's it's a much less magic it's much
simpler to understand and I actually use
that approach in let's say medium-sized
projects and it works pretty well
in a session now everybody's doing micro
services so there are no large products
anyway and ok so going a big a bit
further and so now what happens if ah
one more thing about scopes okay so so
far what we had here is that each of
these objects is essentially a singleton
right in the scope of this application
here every of our every dependency it's
a Val so it's a single phone right
there's only one instance of that
dependency now we don't always so we
don't always need that right sometimes
we need for example a new dependency
each time it's being used so there's a
very simple and cure for that so let's
say that we want to have potato farm
created and we want to have a new potato
from created each time it's being used
okay so let's let's let's add a print
line here which you saw earlier already
potato farm right so now if we run it it
will be invoked once even though it's
used twice right because the potato farm
is used both for the cows and for the
restaurant right but it's it's it's the
same potato farm and we can see that we
have only a single print line right this
prin tine is a run when the class is
actually constructed so now if you want
to change the scope of our potato farm
from singleton to provide it or however
you call it or no scope we can just do a
death and that means that each time is
being involved each time is being used a
new instance will be created right you
can run the code and we have to we have
two potato puns okay so that's like very
basic scoping which we can do with Scala
own okay finally and one last thing
about a Mac wire is so as your
application grows might have more and
more classes that I like spread among
packages but then you know the wiring
code which you have like at the end of
the world right it grows as well and it
has like 50 lines 100 lines
that's not nice right we don't like
methods which are long so how can we
split this so one way is what I call the
Tim cake pattern so we can split the
wiring code into smaller chunks called
let's call them modules right so example
we can have a crop module
and we can have a vehicle is that
livestock volume right for the cows
and we can have the rest okay so we have
three modules we have divided our and
wiring cold into three pieces
and now we will create the modules so we
can no longer just use the restaurant
because it's inside the trade with
livestock move your with restaurant
module and we can now walk around okay
so like the idea is that for example you
know these three classes they filled the
potato famine in the digger they they
are related right they will probably be
in a single package and next to that
package we can have a trade which
defines like the default way in which we
should use these classes so it's like
the default wiring of these classes
right so we have like three packages
here and in these three packages each of
them provides a default way to wire the
object okay finally we combine all these
three modules and and we can actually
run our code right so however it says
this won't compile because yeah so the
error message is that here the cow
pasture needs the potato farm right but
now is it it it the wiring code lives in
a module which has no idea about potato
farms right so we somehow needs to say
that the livestock module actually
depends on the potato farm right and
that ways to do that the first way is to
just add an abstract member alright so
we add an abstract potato farm so we are
saying that the livestock module
requires a potato farm right and we
don't say like what's the specific
implementation it can be any subclass
coming from anywhere right it just says
it needs a potato farm okay and it can
be implemented as a def it can be
implemented as a lace Vardar no
constraints here the second way
the restaurant needs a both Adam eatery
and the potatoman right so it needs to
dependencies so what we can do if you
can simply extend extend we can assign
the livestock module and the crop mode
okay
we cannot that and yes we get the same
result as before right we have our
object graph wired so this way of
actually creating dependencies of
expressing dependencies is a bit of a
yawn I think because it creates like
very stiff connections between the
modules but sometimes it's simply
continued and finally one more thing
that such modules allow you to do is
it's very now easy it's very easy now to
create an integration test for whole
modules right so you can extend that
module and you can override any member
so for example we can override the field
with a mock with the mahkum
implementation and we have everything
wired automatic right so that's how you
can do integration testing of all
classes inside the package okay so
that's the second demo and now let's
move to spray which will be our final
demo okay
spray demo
okay
again we have an application so now we
will create the rest interface for our
rester
okay so and first of all we need to
actually start an HTTP server so we will
extend a simple routing hub which is a
trade coming from spray and it enables
us to write HTTP servers it's called
simple however it's like your usual all
that we need you can use it in
production I use it including the
production perks right so first of all
spray is akka based so we need an actor
system which will be used to actually
create all the actors involved so we
create an implicit ball actor system so
we create an actor system a that's like
all that we need to know about actors to
work with spray it just means to have an
implicit actor system somewhere okay so
now we can start the server we will
start it on the local host and the port
will be a ket okay so now we have
started the server and now we have to
define the behavior of the server okay
so so far we will read to get requests
only with the path of take away slash
hello
and when that path is invoked we want to
respond to we want to respond with the
message welcome to the potato and
steak takeaway okay so now we have
defined a server we had defined behavior
and let's actually run it and see if it
works
freedom okay and binds to localhost
failed it's because I have another thing
here running and some something had to
fire yeah okay so now we can actually go
here and we can do our localhost 8080
okay the request addresses cannot be
found because I didn't provide the
correct path which is take away hello
and it didn't know what to do with my
request Hey okay so we got it right so
we have a very simple server so and
that's like all you need right you can
now package it up in a feta jar and you
can deploy it and it will run as a as an
HTTP server right but again we don't
need any kind of containers all that we
need you know an HTTP service is in fact
a very simple thing right it just
listens on the port it parses the
headers and then you just have to define
the behavior and send some bites back so
it's a simple thing right we have a
method where we specify word to bind we
define some behavior over here in a very
like compact yes sir that's it right
again you don't need any kind of
annotations you don't need any
containers okay so now it does a bit of
detail on how that works so the start
server method actually starts a bunch of
actors which will listen on the
specified interface and forth they will
accept they will accept connections for
each connection a new actor will be
created that will be dedicated to that
connection it will receive data from the
connection parse the HTTP headers create
a request context a request context is
an immutable data structure which
describes the whole request so it has
all the headers the path the parameters
but the and so on okay and finally when
that request is ready it will pass it to
the behavior so the behavior is a root
okay so what we have provided here so
the type of what I have highlighted is a
root okay a root root is an alias for a
request context request context by a
function which takes a request context
and does anything with it right we can
drop the request we can complete the
request you can transform it and pass it
somewhere else and so on so so that's a
route so now this code over here it is
run in a single actor so it's like
single threaded it's a bit similar to
what node.js is this okay so the
important thing here is that we can't do
any blocking operations if we wants to
do any blocking operations we have to
pass the request context to n to another
thread or to another actor okay so that
we don't block the main loop so the main
loops of the just be used like to
differentiate how we want to handle the
request right and then the actual
handling which can be blocking should be
done in another actor or in another
thread this completely normal to like
create an actor per request I chose a
very lightweight nanaka so it's like you
can create millions of them and without
any problems okay so let's continue with
our example so let's say that we want to
now to actually accept some orders okay
so m we will handle another path so now
we we have to create another route okay
so these combinators here so to get the
path and the complete these are
directives right the directives take an
inner route and optionally some
parameters and provide and and and
create a route right so for example the
power it is a directive it takes an
inner route in this case it's the
complete take some parameters right so
what it does it's filters the request so
it only passes control to the inner
route when the path matches what it
specified similarly to get it doesn't
have any parameters and it takes an
inner road so that's the inner road
right
and at the end again it filters requests
so it only passes the request of the
inner route if the request method is
again ok so now we will create another
handler so I will explain what the two
days in a second I will be ordering
potatoes ok so now here we have we have
not yet fully defined what we will in a
second we have two routes right so
that's one route and that's another
right and now we want to combine them
right
so we want to say if the request doesn't
match the first route we want to try the
second one that's exactly what - till
the does okay it's takes two routes and
it combines them into one so now we have
the second so if the path is order
potatoes we now wants to look at the
parameters the sprite has a very nice
feature for parameter handling it's
completely typesafe so we can write
parameters and we want to accept
parameters as followed we also see if
the potatoes should be mashed or not and
that's going to be a boolean okay we
want to accept the number of potatoes
and it's going to be an int and we want
to accept optional special orders
special okay so now we have we have a
new directive for extracting parameters
from the request okay and the directive
says that you want to extract three
parameters must number and special and
they should be of some specific types
okay so now what we have to provide we
have to provide an inner route right but
that inner route is going to be
parametrized by three values by the
value of the mashed a parameter number
and special so I'm going to break line
here so that you can see
okay and we have to somehow react so
that we can just complete the request
and we can say you have ordered mashed
those and just print out the number plus
one let's say one is free free and we
can say that special wishes and special
good
think about something is quite slow No
okay so what we have done here is we
have a directive which extracts
parameters from the request right and we
specify that they show view of some
specific type right so what we have to
provide here is we have to provide a
road parameterized by the same number
parameters that we have specified
moreover the type of this parameter
would be a boolean the type of this
parameter will be an int and type of
special is going to be an option of
string because we have said that that's
an optional parameter okay and at
compile time spray check is a checks
that we have actually provided a
function taking three parameters and the
types will be fixed here right so that's
going to be of type of boolean right so
we can only do you know we can win if
and so on that's going to be a number so
we can add one to it right and that's
going to be an optional so we can
actually call get or okay so let's see
if it actually works okay and bound
bound that's great so order potatoes
right allow endpoint so we are now going
to order potatoes and the parameters
were mashed
let's see false and number is the nose
and nose perturbations right I didn't
write this so yeah I orders post
potatoes anyway and eleven of them and I
don't I don't have any special wishes
right and if I do here special
is let's say baked yeah so I get what I
want
right okay so that's like the types a
partner handling of spray and finally a
another nice thing is that all that you
see here like the rules that we have
that we have written down like all of
these these are simple values it's a
it's not some special thing that must be
nested inside the start server it's just
a simple value and the value is of type
root you know it's a simple method which
takes a request complex and returns a
unit for example if we wanted to we can
remove the complete the directive and
just provide a route here serves okay so
what we have now done is we have written
down a wrote by hand right we take a
context right so it's a function which
takes a context and we call sorry cut
the context complete so let me actually
send something back okay and we send the
result back so now we have written down
I wrote by hand nothing easier and
another nice thing is that it's very
easy to actually write your own they own
your own directives so directives are
things that transform words so let's say
that wants to write a secure they a
secure directive right so we want to be
able to say that for example they take
away hello is going to be secure and
it's going to be secured by a username
and password and who wants to have a
syntax like this right so like other
directive want to wrap this block we
want to wrap this route in a secure
invocation we wants to have this
resource protected so let's now write
down how we can implement secure I'm
going to use my notes just
so that it works so we are taking an
inner road and we are returning a route
we can go and see what the routes
definition and as I say it request
context unit right so we are taking an
inner route and returning a route and
here so like the the implementation okay
so we are going it's going to be a very
basic security model so we are going to
take some parameters username and
password okay and here we will have a
method which takes a user name and a
password okay
and now another nice thing is that we
can just write scala inside the route
okay so we can say that if username is
admin and password is one two three four
then we execute the inner route
otherwise we complete the request with a
four or one bad user okay and that's our
route okay so what we have done is we
take an inner route right and we return
a route right so like here we take an
inner route right so what we do is we
look at the value of the username and
password parameters and now we can just
write any Scala code that we want right
we are not constrained by anything so we
can just say if the username is admin
and password one two three four then we
should run the inner route otherwise we
reject the request with a 4-1 okay let's
see if it actually works hopefully it
does okay bound maybe so yeah so if we
now try to get takeaway hello we should
get a four one and we get because we
don't have the factor I didn't make them
optional but let's make a fake user
until three five yeah Betty wasn't right
and you can see that actually you get
there for over okay and now we can try
to fix our request if the it was admin
right yeah and now we get the security
resource okay so that's that's for the
spray demo and I have two more slides so
the first slide kind of is yeah so the
sources for the presentation are
available on the github and all of these
three projects that I talked about open
source Apache 2 license so they are
quite easy to use and and this one and I
also have some stickers and I have two
kinds of this of stickers if you would
like that I will go over here for you to
take after the presentation so the first
one says I'm proud of my code so I guess
who isn't right and and it's like a
motto follow a code review tool which we
have written for ourselves and now we
try to see if others like it as well I
also have done some half-year filters if
you'd like to try and the second is a
skeleton sticker scholar x is our weekly
scala newsletter where we collect a
bunch of interesting scholar links from
last week and like two weeks ago we had
a skull a comic and so yeah so you can
take this as well and I guess that's it
now maybe you have any questions yeah
it's only for compile-time Matson is an
injection now if you have some like
configurable dependencies so if wants to
sometimes inject one sometimes another
depending on some configuration of
variable for example you can just write
an if in the color I'd have the config
object you say let's value my dependency
like Val potato farm equals if config I
don't know some with fertilizers
something then you then you create one
otherwise create the other so it's quite
simple to actually write it in Scala if
you just do anything yeah it was paid to
so there is a preview version available
like two weeks ago so you can start
coding against it like in the DSL is
identical there are small differences in
like the surrounding so in how we
actually start the server but it's like
a couple of lights of course is
different but like when it's going to be
released I think by the end of the year
is the plan but I'm not on the akka team
so I cannot make any promises
sure it could be that's life
right if that's it thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>