<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Project Jigsaw Hack Session | Coder Coacher - Coaching Coders</title><meta content="Project Jigsaw Hack Session - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Project Jigsaw Hack Session</b></h2><h5 class="post__date">2016-09-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/w4lLd-JOyRU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning welcome to the spacious
project jigsaw hack
and there are plenty of seats down front
just to warn you but this will be QA
and if you want to ask a question we
will ask you to use the microphone here
so that everyone can hear and so all the
people lovely people on the Internet can
hear so if you plan to ask questions
sitting in the front could be to our
advantage on the other hand if you want
the exercise you can sit in the back so
hi I'm mark Reinhold this is Alan
Bateman and Mandy Chung we all work on
project jigsaw along with a few other
people like Alex Buckley who couldn't be
here this morning a quick reminder of
the multitude of sessions we have sadly
a few of these are in the past and at
this point you can catch them on video
other than in person however the
introduction to modular development will
be repeated today at 3 advanced at 4:30
and modules and services tomorrow
afternoon at 2 p.m.
just a quick survey how many people have
been to intro already good how many
people have been to advanced good how
many people have been to modules and
services guys it's sort of diminishing
returns here ok well that's good you you
you have more chances let's see what
else do we got information if you've
seen slides like this already since
you've been to the the earlier talks we
have extensive documentation although a
lot of it is fairly dense in in one two
three four five different jep's jdk
enhancement proposals you can find links
to those on the jigsaw project page
there's also jsr 376 which is also
linked to from the jigsaw project page
in particular there's a document called
state of the module system which is a a
summary of all of the essential features
of the module system one more joke I'm
reminded 282 right okay there did the J
link JEP 282 should've added that sorry
okay uh we work for Oracle questions
please you can come to the mic if you're
shy you can tweet at me if you're but
you know I mean we're all we're all
friends here right there aren't that
many people everything everything that
happens in the room stays in the room
okay we're done
that mic please
so I worked in a security engineering
team and one of the problems we run into
is that some api's are for general use
and some are prone to misuse so putting
if you you can export the packages that
are prone to misuse as which allows you
to kind of whitelist who consumes them
nicely but a lot of times if the export
as declarations are being maintained by
the library authors they may not have an
exhaustive list especially if this is
kind of part of some kind of open source
security product so is there a way to
kind of be right at when you're bundling
an application the exports as oh and
they may be based on some so basically
you you you you you and that you imagine
having a module that somebody else made
and you want to change his exports
because you know better than they do
would you mind
sure I've come to come before the mic
please so I have a class called
unchecked conversions which is provides
factory methods for a type that
encapsulates a security property so it's
it's if you think if you know
trademarking in the security context and
so uncheck conversions is prone to
misuse if somebody just you know follows
their autocomplete sorry so this is this
is a this is a class that you created
yes
what can you just not export it I know
can I just pick up one thing you you you
you use you said in your question
auto-corrected so I'm assuming you
actually mean the IDE which probably
doesn't know about modules yet has gone
and auto-completed and putting the
method name i yeah i'm using
autocomplete as a way to refer to kind
of a naive user finds this API okay so
this is an API that you created in a
model that you maintain yeah and you
need to export it to some other modules
but not yeah so for example I might have
a type safe HTML which is a fragment of
HTML that is safe to embedded in
applications domain run I have a
template system that might produce this
that's a third party I have an sanitizer
which was script tags and element stats
and so a project lead might say I trust
the people who wrote the template system
I trust the people who maintain the
sanitizer
I want my developers to use safe HTML I
don't want the large group of
application developers right right so so
right so a qualified expert not I'm
sorry I'm horribly ignorant it's
qualified experts different from exports
as
there well no sorry there's no exports
out so you can export a export to
the ISA note that you started sorry
export to that is qualified expose so
you can say exports Fuu when that
exports package food to anybody who any
other module that requires your module
yeah or you can say exports food to bar
comma baz whatever and only modules
named bar and baz can can access that
alright and and so my question was the
safe HTML i want to export this
unchecked conversions the package
containing unchecked conversions to the
sanitizer to the template system right
all three of these the safe HTML
definition these are all open source
projects and i want to do that exports
to without you know if i have to i'll
rewrite the safe HTML bundle said that
the definition okay but yeah got it
so our our general philosophy is is
though is that it's best to respect the
original intent of the module author
right where we're putting a lot more
power into the hands of someone who
maintains a component so that they can
say i want to export this and not that
and that's that's that's kind of primary
however yes there are times when you
when you need to break that when one
crude way is on the command line if
you're in a scenario where you're you're
you're writing you're you're in some
kind of container or you're writing
writing some kind of kind of container
and you have the opportunity you can
certainly you can rewrite module input
class files as you load them you know
it's a class file and sm already already
an already understands them so if you
really want to you could intercept them
you know if you if you if you write the
code that that creates the class letters
it loads of those then you can intercept
them on the on the way in and go change
their exports if you want to or if
you're comfortable editing binary
artifacts which
I mean I'd rather not do in a production
environment but some people like to like
to do that you can you can certainly you
know get the jar file off central or
wear it wherever you're getting it and
go modify modify that and then put that
in your archive and and deploy that but
there's there's no there's intentionally
no API that makes it trivial to go and
basically violate the wishes of the
module author because we think that's
important too we think it's important
for there to be sort of a threshold that
you know a barrier of resistance there
because it ought to be discouraged no
there's no there's no level of
indirection we're we're a sufficiently
forward-thinking module author could
could think oh well maybe you know some
of my users will want to do this and put
in a placeholder and then have it there
there's a navigate filled in by the
module system later that's a level of
configurability that you know I think it
is interesting to think about but we
need to get one zero out and you know
after after some years of experience
maybe we have we would add something
like that maybe but it's it it
definitely feels like the sort of thing
that we would need a lot more experience
to justify so you know it's it's always
a bit harrowing designing something like
this no matter how hard you try to think
forward you're gonna miss miss stuff and
so we try to keep you know try to keep
it simple to start see what people's
experiences are refine it over you know
the next few major releases
no more questions
Liat please come come up to the mic
so I was actually in the introductory
buy one of the people working on the
project but in the pre conf so that
might have been discussing it would
actually but if you can give a bit of
detail about how how it's going to work
that you can use two different versions
of the same module so let's say you know
we have who said you could do that sorry
wait III I'm not familiar what would
what is pre comps like the day before
Java one story so there was I was giving
the presentation I can take it up I'm
just curious because none of us were
there yeah there's like day before it
was on Sunday and there it was mentioned
that so right now we have the problem
right that you for example nettie okay I
have three different libraries that use
different versions of nettie and they
collide so I have elasticsearch I have a
zookeeper client and I have a CH DP
client all of them used in unity in
different versions and okay so and how
do you handle this today currently a jar
jar and with a lot of pain I repackage
them it's it's awful it's it's it's
often you need to upload those binaries
repackage with you know so it's often
but I'm so so so in your final
application you have three different
copies of Nettie yes at least two of
which have been haven't had all their
packages renamed yes I'm so sorry yes so
and this works yeah at the end and then
it works but it's painful and it's
error-prone because people can use you
know different because it's because we
don't have the multi system quality then
everything is exposed people can use
this version of a C and that musician so
so it works so the so the easy answer
for me to give is pick one no but I
can't I can't because they're binary
incompatible and I need that feature
from elasticsearch and in that feature
from zookeeper and that feature from a
sexy big light right sir
so jigsaw is not going to solve that
that that isn't that is not the design
center for for the platform module
system
there there are facilities that allow
you to have multiple versions of a
module of the same name in the system
but they're fairly advanced and they're
they're designed for for people who are
writing containers you know app servers
or test harnesses or things that things
that have the the have at least enough
sophistication that they're doing their
own doing their own class loaders we
made an intentional design decision not
to try to handle the multiple version
problem because doing that in in
generality brings a ton of complexity
and you wind up you end up with those GI
yeah so oh so that was actually
discussed at that session I asked him it
sounds like like OSGi done right and he
said it's different but it can give you
like a lot of the same value series
saying not not easily so I need to write
so so they're there there's a there's a
concept called called layers and if
you've been to the advanced talk or you
could still go to the invented I might
go yeah you can learn about layers and
if you if you're you know in a situation
like yours where you really had to do
this one approach would be for you to
load each version of nettie you know
along with the particular thing
elasticsearch or whatever that needed to
use it into its own layer with its own
class motor right you know we we
actually we have api's that make me that
if you if you just need fairly
garden-variety
class loaders then you can very easily
make a layer and and be that it feed
that ISM be as input into the resolver
so it's not hard to do it's not like it
takes thousand a thousand lines of code
you can probably do it in a few doesn't
but it is sort of a more sophisticated
approach okay thank you actually I
should actually think that that might
like you said also for test harnesses
because one of the problems that we have
is that we've had several times where
applications deploy we embed jet in our
own runnable jars and applications went
to production without having the my
sequel connector because during testing
people had my signature in scope test
and maven
and everything worked because the the
the classpath is shared but then when
they came to a production it failed so I
might be able to use layers also yeah
layers could also also be useful there
and wait yeah we already we use layers
in in the JT reg test harness and open
JDK we use the you know Java C uses if
you have an annotation processor the
Java C and JDK 9 loads those into into a
layer it's not particularly difficult
okay so you can you you can certainly do
that as a little bit a bit of backstory
in that and to fill in some of the
philosophical picture in the you know
we've been through many rounds of
prototypes on drink so the first big
prototype we actually we had we had
version constraints in the language and
you know complicated heuristics for for
finding the optimal you know version
given a set of constraints from from a
set of modules in in a perspective model
graph and it gets it gets really hairy
pretty quickly and a sigh and aside from
not wanting to replicate that that kind
of complexity in the module system you
know we it was all it also created
tension with one of our other goals
which is to work well with existing
build tools so you know maven Gradle all
these things idea IV or whatever they
all have their own way of dealing with
version conflicts I III understand they
are not optimal but but they are what
they are and you know millions and
millions of developers use them and
hopefully they'll get better over time
whatever we you know if if we did full
full version solving in jigsaw that
whatever we do wouldn't match what your
build system does or we could make it
match one of them but not the other you
know two or five or whatever and so we
at one point a few years back we just
have this inside wait a minute let's not
do versions and it simplifies so much
stuff so that's that's why we want a
we're where we are today
I'd like to verify the understand
reflection and how this all works in so
if I'm a Jackson developer obviously I
can't know who's going to send me their
classes so I can't require them but it
run time so sorry you're working on
Jackson I'm I work on Jax oh yeah oh you
actually didn't know I'm just making
this up okay that's fine whatever we
make this opportunity develop the
advance talk as well this afternoon
Jackson has been it has been a very very
useful example for us well I do
something like Jackson okay so at
runtime if somebody passes me a class or
a class name then they would have to
export I mean yeah they'd have to recall
well export to me yes and if well or
just export to everybody right and if
they wanted to lock that I mean if they
wanted to open themselves up entirely
they could say private so that I could
reflect and get into private fields and
things yes so that in that case required
isn't really even possible or necessary
for Jackson right so sorry so the
reflect wreath the way reflection works
it didn't originally work like this but
the way reflection works is it it
implicitly adds a reads edge if needed
so if you're if you're writing if you're
writing Jackson code and you go use you
know stuff in Java line reflect and and
you try to access something in some
other module if the module you're in
doesn't already have a read edge to that
module the reflection machinery adds it
for free okay you know I don't know
maybe a year and a half ago we actually
we actually didn't have that and so you
had to add the read edge manually and
lots of people pointed out that's just
cumbersome so we made it kind of
automatic right then so what this
requires do for me then is it's like
when you're in your case you don't and
in your case you don't need it right
you're doing you're doing reflection
it's all it's it's it's all at runtime
and you're
what your and you're not you're you're
also not using just static references
from compiled bytecodes
right right so you don't need it so but
for things I do require statically you
know do you have to require for static
if you want to compile it yep and if you
want to if you want to if you want to
run it and have the modules properly
resolved for you yes you need to require
it that's okay so the required is for
static references it will give me a nice
compiler I don't have to wait for
runtime but if it's by reflection I mean
I can't get away with compiling unless I
use required I mean I can't correct okay
all right unless you want to write all
of your code reflectively just too
painful I understand okay by the way we
just quit since you picked on the
Jackson library in the indie advance
talk which we repeat later on today we
actually look at the for example the
Jackson data bind which is heavy use a
core reflection but it also has a number
of dependencies itself because Jackson
data bind it comes with those parts the
annotations are parts of Jackson core it
requires actually it requires XML it
requires sequel there's a bunch of
things that actually require so we
actually use J tips to even look at its
dependencies we will actually produce a
a module info declaration just to show
what it would actually look like so and
you'll actually get to see all of that
if anybody's watching live on the stream
feel free to send questions in via
Twitter we'll do our best to answer them
there is something that I don't
understand from the advanced understood
that the model system is is agnostic to
the class loaders right so if I have for
example two versions of Jackson each one
of them is loaded with different class
holders and for one of them it trick
export something and for another it
exports another thing then it seems like
it needs to be aware of the fact that it
is okay so let me make sure I've got the
scenario right yet you have two versions
of Jackson yeah they're both they're
both they both have the same module name
yeah okay so you could you could load
each one into a separate class loader
and you can make each class loader be in
its own layer this is what I was trying
to explain in the Nettie scenario
earlier has two different layers with
different applications running in the
same same fee and they're hosted by some
container app and they're using
different version exports right the mob
system it will be will implicitly be
aware of that because they're in
different layers so the so that the
constraint is within a let within a
layer you can only have one module of
any given name so even if the packages
conflict that's okay
that the unit the unit of export is
packaged if we made it if we made the
unit of export be a single class we
would all be very unhappy with
performance its it also just doesn't you
know in practical terms doesn't seem to
be necessary most of the components
we've looked at and we've looked at a
lot maven maintains in an internal clone
of maven central that we that we survey
to ask these kinds of questions you know
generally a package is meant to have an
API that's used by your a comfo
component will have it packages that are
meant to use by be used by other
components and others that are internal
and it's it's fairly uncommon to find a
package that has both internal and
external stuff it does happen but yeah
move move move move move the internal
stuff to a different package that you
don't export yep one other point to make
on that is there's there's no
requirement that the
the classes in your module are version
53 or older you may actually have
classes that works you compile for an
older version and there's nothing in the
class file that actually tell is that
what module it's in so when you start
thinking through that you'll actually
realize that the the the unit of export
being or the granularity of exporting
package kind of really does make sense
in those scenarios
anybody has maven questions Robert
Salty's here
well he's your many years Stephen good
morning hello good morning oh you have a
list I have woken up yes I was thinking
about things overnight I've only got two
things on the list so it's quite sure if
we have module a module a that is
requiring module B hmm can module B see
code in module a is that actually
prevented by the module system or just
because typically you can't compile
module B so so sometimes so if a
requires B then B cannot require a sure
but you could have code in B that uses
reflection to read things in a ok
assuming the de exports the short and
that's fine I understand that part but
could be have been compiled in some
other way the web I previously got a
reference to a class E oh sure yeah if
you have some if yeah if you have some
broken your broken tool train or some
weird provenance of the classes and B
then you you could certainly have having
a weird situation that you would expect
to work at runtime but it wouldn't okay
so would block it the Martin if you may
if you managed to create a a and B and
their module descriptors had each
requiring the other which you know you
could do at runtime the module system
would refuse to load it would it would
stop and and tell you that you have a
cycle in your module graph okay but the
question why I had was if a requires B
and B does not require a but B does
contain some code that refers to a will
that work no you will get an illegal
access or okay remember accessibility is
a two-way street yeah and in that
scenario where it requires B and then B
somehow has been compiled in some funny
way it's got a static reference to
something in a but it doesn't read it so
that so readability is part of the
access
okay so in order for that access check
to work is is we would have to read a
and a wouldn't need to export whatever
the the packages with that type to at
least be now it may be there at runtime
be uses the reflective API to read a and
in that case that will work here but in
this in this mismatch between
compile-time and run-time environments
then that that access check will
actually fail okay now what if a is a
week module as opposed to a strong
module does that change it no no that
only changes what B can get out of our
reflection it gives it more it does not
change what B reads at the get-go yeah
I'll have to think about that because my
impression was the eye is affected
exporting all packages yes it is it is
but it's but it's not making the read a
right we a week module is just one that
exports private every one of its
packages so B would still need to read
it which
just give me a second to
it's an intro
here we go
this is our two-way street
in the indian trajectory have a couple
of Statistics modules there's a there's
a stat score which has exports a bunch
of AP is for things like regression and
clustering and so on and then we have a
CLI which is a command line interface
that requires stat score so and so so
CLS that's Eli requires stat score in
other words it actually will read it and
therefore that gives it access to the
public types in the packages that are
exported by bikes by stat score so this
is this is a two-way street
now suppose that I'm sorry one other
thing about the stat score is is in the
example is there's a bunch of internal
packages as well and no types in those
packages are accessible to anybody
outside of stat score let us suppose
that stats Eli did not read stat score
that would mean that nothing is
accessible to just to start score
sorry just know that nothing is
accessible to stats Eli because it does
not read stat score so I think in your
scenario is is if I put a and B labels
to replace what I have here then I think
you're saying that stat score is a week
module stats Eli does not read it so
therefore any the static references will
actually fail at runtime because it
doesn't read it
now I think I know you've put wood week
on either of these this axis will still
fail because there's there's no
dependency declare it in your module
declaration therefore there's no
readability at one time what as Mark
said core reflection will work just fine
since nobody else is diving into ask
another question right a second I'll ask
my second questions so we have automatic
modules and the name of the automatic
module is derived from the file name yes
Bart's in standard maven approach the
file name the maven file name does not
correspond to the name to which you
would normally wish to declare the
module ie the reverse domain name list
so guava would be typically should be
released as Condor Google guava if you
actually declared a module name
joda-time is actually the maiden name
has a dash in it but you really wanted
to be all cocky adore time now it seems
to me that if you're an open source
project that publishes dependency on an
automatic module which is derived from
the short name that's given to the jar
file when that module is actually
released in the future by its owner your
open source project will now no longer
be acceptable to the world so it seems
to me that it would be a very bad idea
for any open source project to publish a
project based on an automatic mortal eye
so there is several things here but upon
which to comment one can turn that
around and say that well if if if since
guava today is guava - you know version
number jar as an automatic module its
name will be simply guava one could say
alternatively that the maintainer of
guava if and when they turn that into a
proper explicit module if they care
about their users they should call that
module guava rather than kombu GLE dot
collections that way whatever using
because it requires whoever gets there
first to win and be able to do well
effectively effectively they are
effectively they already all are are
their first because you know guava -
version whatever it is jar is is what
goes on the class path yeah but I mean
the module name is something you should
be picky
dependently of that yeah well my name is
I mean II think that it the specs are
defining that motor names are meant to
be with the soleus so so so we so we
could we could just we could just take
out automatic modules I think what would
be nice it would be have to have
something written up on recommendations
for module names module names are really
important they're going to be part of
what you require and what you do and
what you depend on I think that our
position on this side of the table would
be not to use the Google bla bla bla bla
as the name of your module we would
actually call that guava so it actually
closer to the artifact name not the
package name yeah and and this has
actually been a gradual shift in our in
our own view if you look if you look at
for example the current state of the
module system which is a few months out
of date it recommends reverse DNS as
time has gone on as we and as we've got
more experience we've realized you know
you know for one thing there's that
there's this whole additional question
which you and others have raised of how
do you distinguish a module name from a
package name in a module declaration it
it can it can look a bit it can be kind
of confusing to be reading a module
declaration and see the module name is
calm dog food bar and then it exports a
package called calm dog food bar and
there's no visual distinction now
there's all syntax bike shed about well
we could have a completely different
syntax for module names and we've been
we painted that bike shed a bunch of
different colors and nothing better than
dots have shown up so if you if you
accept that if you accept that it's
going to be dots then hat and not using
reverse dns for module names becomes a
bit more attractive because then you can
just say well it that the module name is
foo because well after all this is
winding up and you know food - 1 2 3 jar
and the packet the package names still
you you use reverse DNS or a similar
convention if nothing else to minimize
conflicts in class loaders so I I mean I
I understand the appeal of using reverse
DNS for module names
I have to say it doesn't appeal to me
not to usually this well you are
certainly free to use reverse DNS model
names for a model a lot more companies
have internal projects which will have a
name and that name a sudden these future
clash with some big open source project
because obviously the team there's no
connection between the two yeah there's
a timeline issue and projects like
joda-time which have a - in the name or
maven will obviously have - can't have a
- in the name it's well there's the
automatic module naming our algorithm
that converts the - into attacks easy
that's certainly at the very least you
said he would need to write up a module
naming documentation about what your
name is strategy is I'm surprised that
you're considering not reverse domain
name I'll leave it that you so surprised
noted well yeah maybe were to be honest
we're a little bit nervous about it -
cuz I was going to suggest but maybe the
naming subsidy should look at what the
route package is within the jar file so
determining about how people can
interpreting that automatically and you
had used confusing to a route package as
the name yeah the the the beauty of the
current convention is it makes automatic
modules pretty easy to reason about and
automatic modules are of significant
benefit to the whole migration story
right if we if we didn't have automatic
modules then we'd be forcing everybody
into bottom-up migration and it'll and
that would take 20 years to be adopted
or having a text file that Maps module
name to Java makes sure you can solve
any problem with yet another level of
indirection
questions anyway okay thank you
I have an open-source project which uses
tools good job I'm sorry yeah Jeff 220
yeah so two tools jars gone it's
actually been gone for a long time if
you if you need to get to the compiler
that then you should use the compiler
API which has actually been around for
multiple releases at this point we're
using two is that what you were using
tools about the board oh you're you're
you're you're out you're you're using an
internal API in tools about jar
well tools are no longer exists that
class exists somewhere it is almost
certainly encapsulated if you want to go
you know play you know played by violate
encapsulation and do reflection magic
you can you can still use it but it's a
completely unsupported API
which API are you using actually hotspot
dynasty mxb nor their there are
different api's to dump threats the
latest in gdk9 which you might not want
to use yet is step walk step walker it's
a new API allow you to walk the entire
stat and filter out its just returning
your stream of step frame so you could
flexibly filter anything and you allow
you to access the class object as well
so this is the latest one if you just
want to stack trace strings there our
thread gets that trace gets that traces
it has been there since JDK five I
believe Locke yes yes well no sorry it
it the Locke information if you depends
what you're looking for is in javelin
management which is it's a public API
you don't need to use to start off but
it's not in the Java based that what I
mean is in Java dot management module
but it's a public support API is Java SE
API
look at Java Lane management threat MX
been there is a lock info returned to
you so you can inspect who yeah the
owner who locked who is holding the lock
yeah it has been there since JDK 5 + j
TK 6 enhancing it yeah for Java you to
conquer locks that stack Walker API that
Mandy mentioned it's actually really
nice but to your point about whether
that class is still that intern class is
still there yesterday yes it is there
you don't actually tools that jar may be
gone but that class is actually still
that type is actually still visible I
don't know how you're accessing it as a
class for name or you've got a static
reference but you will get an illegal
access error legal access exception if
you use it yes senator what you internal
API you are using so I will at it in the
Jade apps wiki and tell you the
replacement yeah my questions this app
that it's not working under JDK 9 I just
figured out why
so it's runs under security manager
because it's run by students and and you
don't trust your student no I don't know
yeah every once in a while I get a
report from someone else who managed to
crack something and so it it compiles
Java code and the way it's done right
now is that tools jar is given all
permission in the policy file now with
tools touch never having gone away who
do I give all permission JDK compiler so
there's so which a decaying age and
older my guess is is that you would have
granted and you would have given a a
code base that is the file path to to
write the equivalent with JDK 9 and
modules is you grant the permission to
Jay arty :
slash and then the module name in this
case probably it's JDK compiler is the
name of the module
it's actually really nice it's really
really nice because you can do it on per
module basis all the details of this are
written up in chapter 20 okay and if you
look at the JDK 9 download look at the
comp security policy file is moved to
the configuration directory look at that
existing file you will see their
examples because we are granting a
number of JDK modules with fine-grained
permissions already
in little one man is exactly right there
are examples in the indicator case
default policy where were granting
permissions to specific modules yeah
okay syntax is really really easy to
work
now Twitter questions too early we had
quite a few last year that was it this
time
everybody wake up there
if you have a web application closer to
the mic please if you have web
application how would the automatic
modules work and is there a standard
about how I think that's a question
probably for the Java EE 9 expert group
so that we can actually start migrating
when server 9 comes out so we can build
modules still just right so so so so the
hope the hope and expectation is that
Java EE 9 will leverage this module
system exactly how it does so is not for
any of us here you're here to say
obviously we you know we've been working
with a number of the you know experts
and spec leads to get feedback but I you
know I I have no idea what a modular
year will look like you know III can
certainly you know I would if I had to
guess I would hope among a modular wor a
modular year would look a lot like it
does today except that the jar files
would be modular jars and the the e op
server machinery that loads them would
would use the the modulus as the system
resolver to build a module graph and a
layer and just have all that work so you
know the easy easy answer is well sure
go ahead and make modules but for a
while yet when when those are loaded
into into an EE container or a servlet
container they're just gonna be on the
class path like they thought they've
always been but if you use those same
modules in other contexts then they can
actually be used as modules make sense
yeah
if in my application I have very small
container and that's creates two layers
that both load up lots of different
classifiers let's do some Java files
presumably those two layers and those
classifiers are completely independent
one other that there is no sharing
whatsoever between them there is no
sharing between them that is directly
enabled by the module system but
remember there's always reflection so at
at runtime code yeah no no no it's not
true that all bets are off
but at runtime code in a module in the
first layer could add add a runtime
reads edge from that module to a module
in the other layer and if that module
exports stuff then the first module will
be able to access it how would I even
know about the other bias if it leaks
through an API or or you you can you can
you can if it's somehow somehow gets old
of the hold of the layer it's it's
certainly you know it's possible yeah I
guess I was trying to work out so what's
the what's the degree of isolation
between these two layers because
obviously there's isolation which is
good in that you can't sort the other
thing I mess it up but there's also I
imagine it's bad as in you end up with
two copies of audio day tree and static
sorts right so so isolation is a
different thing than encapsulation right
we're trying to provide strong
encapsulation that's that's that's
fairly hard although not although not
impossible to break we are not trying to
provide isolation I think it says some
some sort of you know hard boundary
that's him that's impenetrable between
different layers if you need that kind
of hard boundary than operating system
processes or your friend
work on a very heavily configuration
driven project where much of our code
knows not about other resources that
it's going to need to load so we have
many configuration files that are loaded
by their location on the class path
which live in jars that are much much
higher than the classes that need to see
them
I'm sorry higher along what dimension so
if we were to draw a graph we have
configuration level jars which depend on
code level jars okay but they all wind
up on the linear class power they do
okay will our code that's in the lower
level modules be able to see the
resources that are in the higher level
module so the configuration modules only
contain resource files yes it to pay it
depends on how it depends on how things
are named so in in in the in the current
system resources are encapsulated but
only when they're effective package name
is actually alleged legitimate Java
package name so if you're putting if
you're part of putting configuration
files in you know meta - infor you know
so some long string that that that can't
be converted into a Java package name
then that will always be exported and if
you you have code in the same class
loader org or code that could that's in
a module that reads that module you'll
you'll be able to load the resource no
problem
can you explain one more times the
difference between the JDK nine regular
early-access release and the one with
jigsaw the one with jigsaw is bleeding
edge so what the way the the the JDK 9
one is is is somewhat less bleeding edge
what's bleeding well you know when it
hurts what difference is might I expect
well it it varies over time right they
we as we as we evolved the the model
system all the stuff around it in
response to feedback and further
thinking we do that fairly quickly in
the jigsaw forest in open JDK we do it
with with less rigorous code review and
less QA so that you know there's
certainly some testing on it but
basically what you're seeing in the
jigsaw ei is our continuous integration
build of the very latest jigsaw bits
what you see in the JDK 9 EA is a a more
carefully evolved code base where
everything is code reviewed there has
been more testing on it you know
certainly not complete but you more it
more than you'll find on jigsaw and it
could be you know it could be at times
quite a bit behind what's in the jigsaw
EA and that's that's the case right now
often they're in sync and there been a
couple of times during nine where we've
stopped publishing the jigsaw EA is
because we've been doing all of our work
in JDK 9 and we'll probably get to
another phase like that this fall
difference between them is a Corbett
it's completely broken bills nobody has
noticed we will fix it of course before
it goes into JDK 9 but it's exactly as
Mark said is this anything proposals
that mark is put out there we tried to
keep the implementation in sync with
that so many of the changes that are in
the jukes EA bails our prototype quality
and refine things we tweak models for
example are not in the JDK 9 EA but they
are in the jigsaw one
don't be shy nobody else is asking
questions right so that is a requirement
as as yet unfulfilled but we realize
there that there is is a need to be able
to scan modules for for classes that
have certain annotations and so forth we
have an idea of how to do that
it's not particularly hard we just
haven't gotten to it yet but basically
you know imagine a way to to introspect
on a module and ask it you know what
what annotations are present and what
and which classes have them and then you
yeah well or even even the non exported
ones because we know lots of CDI
frameworks operate on annotations that
are on you know completely private
elements so that has to work too and
it's primarily a performance thing
anything that work any you're scanning
of classes on the class spot today
that'll all just work exactly as before
Robert let's try a hard one okay so this
is probably a question about Java
so suppose we are all convinced that
multipath is the way to go and we want
to get rid of the classpath because
right now we have during the compile
phase we can use multipath during just
compile we have to use right now both
class path and module path because of
the package collision you cannot add a
module info inside the source main test
directory and then we have the third
point where we need a multi-part and
that's during the running of the J unit
tests and then we right now I have to
fetch it and that's again when we have
to use the class path is there somewhere
in the future probably a way to get rid
of the class path or else will there
always be the class path will be with us
until the heat death of the universe i I
just don't I don't see it ever going
away i I would like to think there will
be a day where it's used
you know rarely or only in situations
like this where you have a good reason
for it and the standard practice is to
ship models and put them on the model
path but yeah I do not think the class
path will ever disappear
I I do hope I do hope that future
platforms learn from the mistake of the
classpath and don't repeat it but you
know here we are
no one else is asking and I'm trying to
debug my thing here please exception
somewhere in comm dots under tools some
class that I've never heard of how do I
find out which module engine it should
be in the stack trace
so we've enhanced stack traces to
include module names and and if
appropriate even the names of class
loaders did you know class loaders can
have names now this is I guess is a
security manager access control
exception which doesn't have the module
name in it yet all right so we have in
terms of improving hers and exceptions I
guess we can focus on more things like
an illegal access xxx class cast
exception another sort of but we should
fix this one we should fix this back but
if you so Java Java compiler is actually
a standard module it exports the the
standard Java X tools and Lulu but it
doesn't contain a compiler which were
confusing but oh it works very good so
many other bugs we can fix for any but
so well when you title this session mark
hack session yeah okay we did some
hacking excellent well it is sure how
many people have have a have a jigsaw a
build on their laptops okay close the
rest of you can go can go melt the why
fine get it now
yeah the Wi-Fi is is not bad this year
yeah the mornings pretty good I'm
curious actually how many people have
actually tried out j-league do some
runtimes jail in jail incur one person
okay they work they work good
will there be any kind of JVM options
that would allow you to continue during
a reflection inside the contacts and
some packages there are out there
already are all right so there are
command-line options you can read about
them in JEP 261 that allow you to break
encapsulation good luck thank you rely
on an internal API and report a bug
against it it will be closed will not
fix there's also some examples in the
prepare for JDK 9 talk that we did on
Monday and ok great
and then on the topic of having
dedicated on your laptop would it be
possible maybe for you to communicate
with Symantec and have them execute it
from their antivirus reputation
something something I have tried to
install it and it just disappears over
and over so I can't use it on my
corporate laptop um III have a Linux
image on a flash drive if you want to
borrow it
sorry dad I don't even know if we do
communicate with Symantec regularly but
yeah I suppose we could look into it
I'll I'll ask one of our product
managers if we have a channel there but
isn't there there's no way to adjust the
antivirus thing yourself you're in a
lockdown environment yeah I'm sorry I'm
so sorry
Stephen is gonna ask the same question
about McAfee hoping for a different
answer I'm just going to note the Avast
security rejected the java and javac
executables when I tried to run them
when I donate the thing so this virus
check a thing it is common with early
access products fortunately with Avast
you just uploaded the jar back to them
and 19 minutes later they said yes it's
safe so ok it wasn't the end of all yeah
that was a question sort of curiosity is
is is that for every single build it was
only what I tried I downloaded the early
access build and it didn't object I
downloaded the jigsaw early access build
and it did oh yeah must it must be nicer
who knows why that rip there things are
but yeah yeah thought Java
although Java was a virus and put it in
the chest Thanks I'll ask I'll ask our
product management team if they have a
channel too
yeah my question was could you just go
through j-mods verses jars I think
you're allowed to put J mods on the
module path why would you you just go
through that so J mods
n jars so jar files are what are what
every developer and every build tool
already understands so it's a great
trick of modular jars is they're just
jar files that have this little extra
file in them and if you compile things
correctly you could even use that to our
file in the class path and eight or
earlier J mods are or are a different
format which we created because for the
JDK itself we need we need an artifact
type that can contain not just class
files but configuration files and native
libraries and launchers and license
files and man pages all this other sort
of stuff and there's no there's no
natural way to fit that into a jar that
wouldn't be very confusing
so j-mods at present they are there are
they are just zip files
mandis working on on cleaning them up
and and eventually will actually put a
put a magic number at the front so that
it's possible to distinguish them from
other other things that are actually a
zip files going forward we might we
might change that format it's the the J
mod format I think will will will not be
part of the Java SE 9 spec but it will
be documented you know it's certainly
thought of people we want to use it that
that'll be totally fine there's there's
a supported tool called J mod for
creating and manipulating J mod files
it's what we used to make all the j-mods
the chip with the jdk at present J mods
are only you can put them on the module
path but only a link time or yeah and
compile time they're there they're not
they're not useful for runtime so if
you're gonna play if you're gonna play
the linking game then then they're handy
but if your ship if you want to ship
things that can just go on the mod
module path at runtime then they're not
what you want well they will they sip be
supported at runtime in some future
release possibly but bullet bullet we'll
see how it goes so I guess if we were to
sort of summarize J mods as being then
mostly for Oracle's internal purposes
would that be a terrible summary of them
I
we shouldn't be worried about well
though that III would quibble without
summary on two counts what one is it is
it's not Oracle internal write this is
open JDK I would expect any open JDK
derived distribution you know to support
j-mods unless they rip it out which
would be a dumb move III do think yeah
it's roughly correct that in in nine J
mods are for the modules that comprised
the JDK I I won't be surprised to see
some number of other J mod show up in
particular for libraries that include a
bunch of native code
there will be a convenient way to ship
but I you know certainly that I none of
us have any expect expectation the
j-mods will replace jars at least not in
the next couple years
no please please come to the mic we it's
actually hard for us to hear you if
you're standing no please the mics right
there yesterday could you please give us
the link because I couldn't find a
decision right so yeah so it's the
slides for all of the jigsaw sessions I
will create a page linked to from the
jigsaw page probably later today with
all the PDFs and links to the video
streams and all about if you if you I'll
tweet that out if nothing else you can
find it there or just go to the jigsaw
page in a couple of days you'll find it
another question we we work in two JVMs
so we start our IDE then called another
JVM for the user code to where well the
changes in JDK 9 affected in any way the
tcp/ip conversation between the two JVMs
or no ok thank you for watching
our multi release jars in scope for this
chat multi release jars are and they are
in JDK nine
yeah but are you taking questions oh
it's oh sure we can try and yeah and and
by the way they're really hairy edge
cases between multi release jars and
modular jars that we're still trying to
work out well I mean I really appreciate
you guys doing multi police jars because
well have a happy customer we've
actually been we actually been wondering
is anybody gonna use these I'm up well I
talked about them into prepare for JDK 9
talked yesterday and repeating there's a
lot of questions ok so I've got a
library with an installed base that's
you know still on 5:00 and looking to
6:00 and so I'm wrapping you know a
parser event stream and I want it to be
auto closable when the underlying thing
that I'm wrapping is auto close but I
wanted to reclosable and so auto
closable isn't available on five
produces back in in seven years
yeah so I do horrible things for five
and six with reflection and so I'm
looking forward to that
and so my question is do you recommend
building everything online with the
release flag or what kind of machinery
around there is if I have to put our
releases for I believe I have to put our
releases four five six seven eight and
nine book is putting out a five
alright are you trying to create one
artifact that works on 5 6 7 8 &amp;amp; 9
yes and so what I think I can do is I
think I can put out compile down to
source 5 and then I think I can 4 7 8 9
I think I have to put out individuals or
I can put out one that so so - we 3 I'm
sorry - 3 and my yeah and and and and -
3 week
so hey we have no plans to back port
multi release jars t29 have in 6a not
not even to 8 ok so multi release jars
are useful for dealing with differences
from 8 to 9 and then later on 9 to 10
and so forth so we're we don't have
plans to back port them to 8 7 so
they'll solve similar problems in the
future but yeah sorry
getting two really minor questions so
now with these policy files then I'm
gonna have to have two sets of policy
files because the jrt syntax is not
accepted by jdk age that's true I have
argued in the past that it should be
fatal but I'm pretty sure it's not and
so like I have things like j-unit in in
my build because this tool runs j-unit
on student code and so should I now go
back and make that into a module just
wait for them to do it so just ignore it
and just leave it as as an automatic
module what do people do I mean I could
go in there and put in a module
declaration I didn't have it right and
wrongly depend on hamcrest and all that
but I wrote well I I assume you don't
really want to go in and change someone
else's jar file not particularly
that's sort of what what's a good
practice the good practice on until the
maintainer zuv je-yoon is release a
version of Jane it as a module then in
the interim you can you can actually
push a unit and hamcrest on the module
path as automatic module so we've
actually tried this out and it works
pretty well ok I will try that
Thanks
mr. Kolb or anybody else would have
given you or got this maven central
thing you can actually go and figure out
lots of stuff about maven central jar
files do you have a figure for what
percentage of jar files on maven central
for sensitive products projects have
package name clashes between them
I know Commons beans utils the version
before the latest version contained a
package from Commons collections yes I
talked about that example and you say
you know obviously this thing has
happened and that still happens I just
wondered if you've done any analysis or
to figure out how big a problem it was
we done package conflict analyses I
didn't do it formally but the conflict
of package the volume i I did try many
years ago but the volume is pretty high
because I have so many number of
artifacts and there are some old
versions as well so it is pretty high
but but not if you are asking about s
yeah API I don't have the number we have
to by now yeah yeah and it's and it's
hard because if you if you what you know
if you if you explore maven central you
can find you know there probably you can
probably find hibernate under six
different group IDs which is extremely
confusing because anybody can you know
upload it under some other group ID it's
our own pack version of it or whatever
and so doing you know knowing what's
authoritative so that you could actually
do a package conflict analysis is pretty
tough
I think it would be very useful if we
can find out what a really active
artifacts being used by projects and
then from there those statistics are
more um yeah representative anything
yeah
in the module info file be compiled
separately yes a module info file can be
compiled separately so modules from JDK
I can strip out the module info and
insert my own modeling for there so that
I get wider access you you could do that
you'd have to rerun the linker put yes
you could if you really want to do that
you could do that you cannot innovate
the SEC accessible to true on reflection
that can be sure you you you you you
could take all the J mods that that ship
in in in JDK 9 rewrite all of their
module and fit class files to export
everything you could you could J link
that into your own image and you could
access everything all the time and is it
a good practice to well in in fact we we
do have some integrity checks in the J
in the J mods for the JDK that we record
a strong hash of each one in the J mod
for the base module so the so that is a
it's actually very difficult to spoof
the built in modules if you if you're if
you're going to link them we're but
we're not doing any public key
cryptography or signing or any of that
stuff it's it's it's you know it gets
very cumbersome and the and it doesn't
seem worth the trouble
that isn't that is an interesting thing
that we we haven't considered we could
we could bake into the VM the hash of
the base model itself and that and that
would prevent this sort of thing it
wouldn't Britain sorry it wouldn't
prevent it you can always get the source
code and build it all yourself but it
would it would discourage people from
rampantly rewriting the module infos</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>