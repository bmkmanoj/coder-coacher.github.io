<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java ME 8 Versus Java SE 8: What Developers Need to Know | Coder Coacher - Coaching Coders</title><meta content="Java ME 8 Versus Java SE 8: What Developers Need to Know - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java ME 8 Versus Java SE 8: What Developers Need to Know</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PoJGpWkzorc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">um good morning welcome to Java 1 2014
we have a small but dedicated crowd
which is good because I actually think
you know em java me8 is is a bit under
appreciated and I believe where that's
where actually the bulk of the action of
Java is going to be over the next couple
years it's a very very interesting space
who you're on the leading edge so to
speak it's good so my name is turns far
I'm a technologist and product manager
at Oracle specifically responsible for
the Java ME product line I apologize for
violating the the Java one dress code
this morning I have a bunch of customer
readings so but I used to be a developer
so I hope that doesn't affect my
credibility here so job in the eighth of
course was released ah together with
java SE 8 in march april this year and
we're seeing a lot of interest in the
community people are starting to pick it
up instead of rediscovering javanese so
i thought it would be good to just give
you a sense of the differences between
the two platforms are to help you come
up to speed to write portable code so
let's let's keep this interactive or
just interrupt me if you have a question
who has any experiences with Java ME
already if you would raise your hands
okay thirty forty percent which is good
because that means that the SE folks are
coming to learn about any all right so
we'll talk about the differences between
the two platforms and sort of the space
they were designed for which is
important to understand then because a
number of people are new to java in the
eighth i will give you like a five
minute run through what it is and high
level features to set the context the
bulk of the presentation will be topic 3
so i'll give you a high-level flyover of
the differences we can't go into too
many details but i'll highlight the
different points then you can go off
into the API documentation
figure it out I'll talk a little bit
about the different approaches that the
two platforms have to configure ability
and footprint give you a few tips on
what you can do to address both
platforms at the same time or when
you're moving for one to another
unfortunate I don't have any actual code
to show that's something I would like to
do for the next version of this talk so
what we're going to stay fairly high
level and then just talk about what's
potentially coming in the future all
right so you've probably seen this
picture before in some way or another we
can disregard Java card on the left
canal because that's really a
specialized solution that is quite
different from from Java ME and java SE
but starting at you know sort of
microcontrollers with about 256
kilobytes of RAM and upward we can
really do Java embedded either any
embedded or SC embedded so any embedded
of course is the more compact version
that scales down to very small devices
but still has a lot of the Java 8
platform features API features is one
and then once you go to yeah maybe I
don't know 32 64 megabytes of memory you
have a fairly powerful processor at that
point you can consider using java SE
embedded but there are also other points
of distinction between the two platforms
which will go into later all right but
the point being is that basically from
low end Java ME embedded upwards all the
way to the top you can use the same
programming model the same paradigm
meaning of the same API is the same
language features right which is really
unique to Java in the embedded space
other embedded platforms don't offer
this so we with Java 8 we really took
this big step of unifying our the Java
ME and the java SE platforms together to
give you this this you know more or less
uniform java 8 platform java any
sort of a little sibling of SE and we're
not it's not perfect yet I'll show you
some of the Deltans on where there are
still gaps but it's a big step forward
compared to what we had in the past and
essentially you'll just make trade-offs
based on footprint and functionality you
can ideally right a lot of your code
especially business logic and libraries
and things like that to work on Java in
Java ME NSE at the same time in fact
their binary compatible so you can you
don't even have to recompile you can use
the same jar files all right and we're
we're not completely aligned where
there's still a delta in terms of api's
for example the goal is that ne and SE
share a lot of the same concepts so you
don't have to rethink your application
entirely you might have to swap out one
API against another but fundamentally
your application logic still stays the
same right so we really just want to
make it easy for people to address a
very broad range of platforms all right
so you've probably seen this before as
well alright so the history of Java was
kind of fragmented for historic reasons
we had these different profiles the
compact configuration compact device
configuration CDC and then the compact
limited device configuration cotc both
subsets of earlier versions of java SE
and both on the api on the language
level so it was kind of painful to to
write code that was portable and yeah a
rooster it was painful for the
developers but it was up also painful
for Oracle because we needed to maintain
multiple stacks of a very similar thing
right so and then with Java 8 of course
we moved to a much more unified view so
Java ME from a language perspective is
now a strict subset of java SE 8 and
from an api perspective it's also a
subset but there are additional api's to
Java ME 8 that are unique
to me8 for various purposes and we'll
talk about those so the picture is much
much nice enough all right so design
space is so fundamentally Emmy and se
who are designed for very different use
cases right the SE platform that the
traditionally se has been a very rich
platform at you the designers never
really had many limitations in terms of
processing in memory so basically se has
everything right and that includes a
very powerful virtual machine that just
is optimized for performance right not
from Emory not for size not for
resources it's optimized for performance
and for completeness but whereas Java
any age is really designed to optimize
memory space and work very well on
limited devices so fundamentally it's
not possible to cover those two extremes
with a single platform just technically
like the java SE vm when it starts up it
needs like you know 12 mega bites out of
the box just to even get started right
and as comparison Java ME you know needs
as little as 128 kilobytes because it's
just very different design under the
hood right so that's what we're going
after me8 is focused on simplicity on
resources on portability on support of a
right wide range of devices including
devices that don't even have an
operating system you can run on the bare
metal or you can have a very very simple
real-time operating system and then Java
any aid is also targeted for your
purpose built for the embedded space so
we have a number of features in there we
wanted to provide a platform that works
well for embedded solutions out of the
box so you have things like a 24-7
reliability you have the ability to
remotely monitor and manage the system
you can install and control applications
you have built-in access to device
peripheral hardware you can support
cellular connectivity and a number of
means that is really that are really
important in the embedded space that se
doesn't really have or need in general
right whereas se of course is is all
about compatibility you know you can
throw these big job applications at it
it's backward compatible to you know
some old versions of Java s5s you go
even se3 a lot of big customers still
long very old applications that haven't
been updated and se is all about
performance right it's fully multi-core
you can do you know power load streams
and things like that but you don't
typically need on small embedded devices
so that's just a set sort of the frame
of reference so for those who are not
familiar with Java ME eight this is the
high-level block diagram and it's really
designed to be a horizontal embedded
application platform that can easily be
specialized for different use cases so
if we start at the top and have
different types of use cases you know
depending on the platform wireless
modules you know industrial control
smart meters with vertical specific
business logic and applications running
and then the the developer or the OEM or
the system integrator could add
different api's on top of that for the
specific use cases so for example a
specific protocol that an industry uses
right could be implemented there so
that's basically all above above a sort
of on top as building blocks so down
here actually should should draw a line
here so this is what Java ME you as a
platform starts right there is an
application platform definition called
GSR 361 which is the embedded profile
which provides an application model a
provisioning model life cycle model
remote management model which sits on
top of the core platform cldc 8 which is
the core
m the core libraries the core language
features and Amy also includes device I
yo a TI so that's to talk directly to
device peripherals on the system to
another connection framework which is a
set of protocols to talk to you know
network protocols file and things like
that and then it's complemented by
security and Trust services which is a
set of api's to handle things like
certificates and encryption and so on so
it's it's structured very different from
se as as you can tell alright so i think
i went through most of these and we'll
talk about the right columns of
comparing the device components to se8
in some sense there is a relationship in
others as not so for Co dc-8 that's
really a strict subset of s EA so you
have the Java language the Java VM core
api's many of those and we'll talk about
the details have a reflection in SE
eight things like GC a generic
connection for markers really no no
equivalent on se8 se8 has a set of api's
your things like I owe you know dotnet
dot file and packages like that was GCF
a takes a slightly different approach at
the API level but you get the same
functionality essentially the MEP eight
of application platform there's really
no equivalent on se because se
traditionally is a generic platform so
you only get the main method of you know
public static main and you have to build
any sort of application model on top
like some people use osgi or you know
build their own frameworks on Java ne8
that's all built into the platform
because it's just something we felt you
need in every solution so we'll just put
it in the platform device I oh there's
really no equivalent on SE
but we're planning to actually make that
available se so that the ABI is designed
to be any and se compatible on both
platforms and then socks are secured in
trust services se8 up as other parts for
example soft some parts of sats are
actually a subset of java SE jca the
java cryptography api's other parts of
sacks i have no equivalent so again
because there's some specialized
functionality in SATs are like being
able to talk to smart cards that is he
never had any questions so far no I will
do it for time all right all right so
let's let's go into some of the details
um so yeah probably just step through
these one by one so a core goal of any
age is to be aligned right so that does
not necessarily mean one hundred percent
compatible but we try to be similar
wherever possible well as for some java
SE embedded eight we want to be on a
percent compatible with standard AC
platform all the time all right terms of
hardware ranges I already discussed that
one of the key differences is that s EE
fundamentally requires a full process
oriented operating system underneath
like Linux or Windows or whatever right
so that off the bat each up 32 or 64
megabytes of your memory and requires a
decent processor to even execute right
was on Amy we can run with a little
kernel that gives us a thread in some
memory management and everything else is
actually done at the Java VM level in
fact in the majority of the cases the
developer actually never sees the
operating system on any it just boots
right into Java and that's all the
developer ever sees startup time for
example typically a few hundred
milliseconds on any because it just
boots right into Java there's very
little code to execute of course on SE
they can take many seconds we have to
boot the OS as well right as I said
multitasking
same system application management is
all part of any built-in and it's a very
robust system and as I can do a whole
new talk a whole separate talk on that
topic se doesn't have that as I said
typically people use things like osgi or
the middleware to provide that
capability which adds more footprint
right another thing that we're seeing is
very popular as amy has a built-in
support for all sorts of connectivity
for example there's a cellular API that
an Emmy allows you to deal with the
different properties of cellular
communication like you can establish PDP
contexts and things like that directly
from the application which is something
se has no clue about right an SE you
open a socket somewhere and somebody
takes care of the details which is not
always what you want sometimes the
application actually needs to understand
how the connectivity is done um I think
I spoke about some of the dedicated
embedded functionality so for example we
have the ability to configure the
bootstrapping of Java ME so when the
system comes up you can define which
applications you want to run
automatically and in which order and if
an application terminates for some
reason then you get a notification and
you can try and fix it so we have a lot
of features in there that s e doesn't
know about the gem it se is just
generally optimized for you know maybe
power management and things like that
some size optimizations but it doesn't
have these dedicated and vetted features
we have dedicated tooling with emme so
we have the Emmy SDK which you don't
really need if you you know you could
just take your command line and just
compile the jar files and push that onto
the device but the Emmy SDK actually has
a number of nice features built in you
can deploy directly from to the device
from the IE you have tools
like a memory monitor a network monitor
and things like that that make embedded
development will be nice Emmy is very
portable as I said you can because the
device platforms in the small embedded
space are very fragmented right we need
to be able to port quickly there's no
uniform operating system everybody does
it differently they're different
architectures right different so we need
to be able to handle all that was on SE
e it's much simpler right you typically
have linux or you know q an ex or
something underneath and you know you
have x86 or or arm or you know maybe
mips and that's pretty much it so in
terms of coding s ii is there's less
porting typically required but if you
want to do it then it's fairly heavy
weight operation one big benefit of SES
of course a performance is is really
good as i don't know if you saw there
was a blog or a couple of months ago
when any sorry when java 8 came out my
colleague Jim Connors did a benchmark
where he was using parallel streams and
lambda expressions on and imx6 i think
and he was able to get 4x performance
just by changing a line of code because
lambdas and and parallel streams imply
you know paralyzation and SE e
immediately ran it on four cores sne
doesn't have that concept we run on one
core currently and performance is not
really a focus anyway on these systems
all right target use cases we're really
going after the smaller devices we see
these kinds of use cases in the industry
typically sort of edge nodes or or you
know gateways or concentrators was se is
for the bigger devices ATMs and you know
like high-end medical equipment and
things like that so where you can really
afford a processing and also the
hardware costs so
that should give you a background on why
Emmy and se are so different right they
were designed for different purposes and
you can't replace one body you know for
the other it depends in your use case
what you want to choose and i'll give
you some more pointers on how you can
make that decision alright so we can go
into some more depth but this is about
as deep as we get here because we're run
out of time so I have three or four
slides that step through features API
packages at a fairly high level but it
should give you an idea of what's there
what's not there and where to go look if
you need more information right so any 8
has oops sorry me8 has all java 8
language features right so that was a
big step forward annotations you know
try with resources generics organize
things except for lambdas and the lambda
infrastructure default methods and
invoke dynamic and stuff like that so
yes that's a bummer if you have code
with lambdas then you can't use them
right now we're thinking about adding
those in the future or we're pretty sure
we want to add lambdas in the future and
there are also ways around that like
there are tools that are process class
files that have lambda expressions and
turn them into class halls without
rhonda expressions so you can still love
them all so we're not actually at this
point we're not sure about the use cases
that people would actually use lambdas
for in small embedded devices right we
always have to look at the use case to
be optimizing for that and we're trying
to understand more from the developers
how they would actually use lambda is
its small embedded devices so it's
coming but for now no llamas we have
fine grained permissions so the SE
permission model so all those things are
exactly identical any age can digest se
class files so you know
to recompile anything in the past you
actually had to run it through a pre
verifier with a different class file
format so that's gone we have a service
loader API so you can use a simple
dependency injection by loading
different implementations of an
interface what we don't have is is
finalization reflection civilization and
a lot of people of course depend on
reflection in particular a lot of api's
depend on reflection but reflection is a
huge can of worms one of the problems we
have with reflection is reflection so
what we do with SE with any embedded to
keep the footprint small is we do
transitive closure analysis analysis of
all the code that can be run in a given
system and then we can remove everything
that's not needed alright once you have
reflection you can't do that analysis at
Build time anymore because reflection
could call anything at any time and so
that completely destroys your ability to
optimize footprint that's one of the key
reasons we actually left reflection out
and it turns out that actually you can
do a lot of things without reflection so
reflect you you don't have we don't have
civilization cuz that's another big can
of worms and mostly you don't need that
either so no reflection Ellis
organization no native application code
of course the Java Runtime itself has a
lot of native code but you can't load it
dynamically and the reason being is that
some of the operating systems we have to
support you can't even dynamically node
called period they don't allow it right
so we couldn't put it in the platform no
user defined class loaders so that's
something that osgi use is very heavily
we don't do that in Emmy for a number of
purposes or for a number of reasons one
of them being is that user-defined class
loaders are actually a really bad idea
if you want to use them to isolate
applications from each other because
they don't really isolate applications
that's one of the disadvantage
osgi you can note bundles and different
class loader namespaces but they can
still mess with each other's heap so in
Emmy we have a right every application
runs its own heap and they're isolated
and it's a much more reliable system
let's see the other things are fairly
small you know no runtime annotations
thread group we're thinking of adding
mass we have almost all of math but no
big decimates like so you know mostly if
you don't use any of these specialized
features it's actually fairly similar
from a core vm perspective more
interesting are the api's so we try to
pull in as many standard AP is from se
as possible but s API is always a
footprint problem right where do you
what do you stop right how much of the
API do you pull in so what we did was we
at every API we looked at it and said
what is sort of the minimum set of
functionality that somebody would need
down onto these small devices where can
we draw that line other any dependencies
and that small subset that's what we're
choosing so that's what we did with with
java.lang Java security java.util
java.util is actually one that that
people complain the most because they
want collections and stuff like that and
and so we'll talk about that some more
we don't have remote methods
implications collections we have a good
bit but we don't have sorted collections
we have no concurrency utilities because
we don't even have multiprocessing but
it turns out that a lot of code that
people write uses concurrency utilities
even if it's not going to be paralyzed
so we're actually thinking of adding a
subset of concurrency utilities we have
string format oh you know comparable
interfaces we have a subset of Java I oh
but most of it is actually supplied
through the generic connection interface
so you have equivalent functionality
we don't actually have much of java.net
again the connectivity is provided
through GCF so for java.net we actually
only have a few exceptions we have a
subset of ni all including some of the
newer stuff buffers and channels and so
on and a subset of JavaScript oh so if
basically if you're paying attention to
this it's pretty straightforward to
write code that runs on em en se but you
have to be aware of some of the
limitations and in almost all cases this
was done to just preserve footprint yes
was anything removed from prior versions
of any of the all ok so one of the goals
for me8 was that we were compatible with
previous versions of Java ME mostly
because we still want to run some of the
TC case for the optional ge'ez arts like
jsr 120 or 172 and things like that so
the only big thing that was really
removed was of LCD you I so the mid plz
UI is gone because any aid out of the
box doesn't really support bitmap
graphics we have a line you I but the
graphic story is a bit difficult because
the embed its face again is so
fragmented and people have such
radically different use cases so LCD UI
is pretty much the only thing that is
gone which was a hefty bit of code it's
a fairly big API so and why we were
adding all these new API on the
footprint increase over previous
versions of em EE is actually moderate
but what's more important is that the
any embedded profile
which contains some of these api's is
now has this optional API packaging
concept where you can actually save
footprints all I'll talk about that in a
minute okay so now here is where any
embedded pulls ahead from se because the
number of AP is that are these dedicated
embedded API is an Emmy that s he really
doesn't directly have so all of the me8
the Emmy ep8 packages which we'll talk
about you know amy has them as he has no
equivalent a bunch of the GCF stuff the
connectivity files networking and so on
se has sprinkled over different api's um
so there's typically you have a
equivalent but it's a different API
package so we have to wrap that things
that have to do with communication multi
multiple interfaces cellular
communication wireless networking amy
has SE doesn't really have an equivalent
some of the encryption and certificate
handling you'll find in the JC a package
talking to smart cards and secure
elements SE e has no concept and the
number of optional jsr s that are
available as any jsr s that have no
equivalent in SE as well and those come
on the next slide so we could do a whole
as I said let you do a whole talk just
on the Java ME embedded profile packages
these are all the new things that are
dedicated your embedded functionality in
Java ME eight in particular you know
things of interest or the cellular
packaged software management is for
provisioning and controlling
applications there's a power
interment package there's a line line
you I there's an application model
midlet that as he doesn't have so none
of this you know this is all any
specific okay and then finally there are
these optional GSR s that we've had in
the emmy space for a number of years
that are popular yes okay power
management yes so we're we're sort of in
this is an intermediate step so this is
not a complete power management solution
what this offers this API offers is
essentially a way for the system and the
application to talk to each other about
power management states so the system
can say well I'm you know going into
power set management mode it will say it
send a power management event to the
application then the application can do
something intelligent or the application
can say well over the next 20
milliseconds I'm not going to use this
particular I all device so i'll send the
i/o device a you can power yourself down
signal right so it's more about the
communication between the various parts
of the system to optimize power usage
now this needs to be tied into the
actual power management circuitry on the
system where is this is where our
partners are going to come in and do the
hard core engineering work to wiggle the
right bits to enable power management so
this is at an application level but not
all of the implementations currently
actually map that to power management
functionality on the hardware so that
will come probably over the next 12
months is people start implementing
these on various systems that's when
you'll see this actually becoming
effective yes
so I mean it so the the implementer so
this is just the API level right
somebody has to implement the java
runtime for a particular piece of
hardware and using this power management
API they can already start implementing
things like they can do clock clock
speed changes right so if the
application says well I'm going to go
into sleep mode anyway right then the
clock could be too down right so that's
a really possible another thing that we
haven't implemented yet that we're
looking at is to aggressively have the
job of yem itself optimized for power
state so for example if it detects that
certain applications only run in certain
time slices and the system at the Java
level doesn't do much else in between
then the vm can either coalesce those
cycles or aggressively tell the hard
work to sleep and wake up again right so
there's a lot of integration that eats
nap in between the vm and the underlying
system which we haven't done in all
cases yeah that's just additional
engineering work but we'll do that over
time right we'll definitely get better
and we have concrete use cases from
customers where they say well we want
this to run on a battery for four weeks
right and we need to do aggressive power
optimizations there but the API hooks
are in place so you start writing
applications today and eventually over
time they will get better and better
okay so back to the jsr s so a bunch of
j srs so things like location
information that's something that java
SE for example doesn't even have we have
some things that are equivalent to se
functionality like xml processing
we have a highlight all for example
wireless messaging is something you
don't have on SE right so you can use
text messaging for example on the device
directly and then we have a number of
new AP is that are also unique to any
where in some cases there is a direct
relationship so for example we have
adjacent processing API which is really
a strict subset of jsr 353 so as long as
you use that subset it's completely
portable we have off of API there's
probably an equivalent and se in the
open source community so there are a
bunch of different packages that really
make any a complete platform but there's
not always an equivalent to se and in
some cases se doesn't even have the
functionality right because it's so
specific to embedded okay so let's spend
a few minutes on on footprint and
configurability right so you're probably
familiar with the java SE compact
profiles that came out in march and
that's really a way to sort of remove
footprint you know you maintain the java
SE e model and the api's but you
basically cut away AP is that you don't
need for sure to conserve at least some
footprint and so the way it works is
they define these three configurations
compact profiles and you can also
exclude some additional optional
component and the idea is that it's this
concentric ring of API subsets I don't
know if you fall it's not a ring here
but you can see that they're included in
one another right so if you need and
that's one of the disadvantages if you
need just one class that's in compact to
you have to drag all of compact to and
act one with with you an implementation
right and they had to do that for
compatibility purposes so if you can
limit your application to come back one
or compact two and you don't need
anything in compact see you can fairly
effectively strip out some stuff but
fundamentally it's designed to be fully
compatible with the standard Jays a java
SE model all right and in in the best
case it does allow you to strip you know
30 35 37 megabytes of a footprint from
the java runtime from actually from the
library's specifically right I'm talking
about se right okay right so so yeah why
why does se have this feature so okay
yeah and hardware is cheap and memories
cheap yes and no um so first of all I'm
listing this here to contrast with Emmy
which I'll talk about in a minute the
reason we actually did this so
specifically because we have a lot of
customers saying we want to run se but
we don't want to spend the hardware
costs and more importantly the power to
maintain all that memory on the system
right so if I can build a system that
gets away with 32 megs of ram vs 64
makes or 128 megs of ram i see if a
dollar or two off my bom cost plus it
needs less power and that was the reason
we built this because there are actually
a lot of embedded use cases where you
want to run a see but you want to make
it as small as possible you have to step
back from the pc thinking here memory
and power is still expensive and you
don't you don't always have a big system
that you can run this on okay so
yes so how's jinx are going to play into
this good point so this is was actually
intermediate step to address some
short-term needs because jigsaw is still
you know two years out jigsaw to a large
degree will actually replace this
mechanism so this is just a simple
straightforward you know we can do this
today jigsaw addresses much of this but
in a more flexible manner alright this
is fairly strict you only have these
three profiles plus the full profile and
but it helps a lot of customers today
all right and the nice thing is you can
basically build your own vm using the j
create tool right so once you know which
api's you need you run the the JRE
through the j create tool and out pops a
different set of libraries that you can
then use that uses less footprint okay
so anyway that's that's how as he does
it Emmy e is quite different amy has
this concept of profile sets which in is
really built around optional API
packages so instead of having concentric
rings actually we do this instead of
having concentric rings that depend on
each other we've actually defined each
of the API packages in the spec to be
optional and to eliminate or reduce
dependencies between the packages as
much as possible so you can actually
take one package but not the other and
then the third package but not the
fourth one and put them on the system to
really strip down as much as possible
and you could say well doesn't that
increase fragmentation right what does
that do to the predictability of the
platform but it's filled into the spec
and the tck is actually check that all
the dependencies and the api's are
complete so the developer actually
always knows exactly what they get so
it's it's it's a simple system that we
can run on these really small devices
that often can't even load code
dynamically that everything has to be
built statically but it's still very
predictable for the
upper and so it's it's a well-defined
model and so you can basically take you
have to take the minimal profile set
which which is that the one there's one
mandatory package that you need and then
depending on your use case you can throw
in other optional packages you bundle it
together to a runtime and that's what
you deploy on your device and the
developer knows exactly what they get
and here are some some different
footprints so we can start at a minimum
at about 128 k of ram and one makes a
flash and then it sort of goes up and
its really driven by the use case at
that point what you need and you'll see
an app you'll see an example of such a
device in a minute when I when I get to
the end and by the way all this
information is is already there's I have
a big slide deck called the Java ME tech
any a tick overview I think it's called
that has all this in more detail so okay
so the idea is that you pick and choose
API packages to really right size the
platform but it's still predictable from
a developer perspective you know exactly
what you get and the tck when you
actually run the TC K's on this platform
it knows which api's depend on which
api's and it tests all of that in one go
so it's a pretty nice design and allows
us to do this right so I don't know if
you saw the announcement yesterday in
the keynote and I blogged about it so
this is kind of a milestone we are now
releasing so any eight was always
targeted for very small devices and now
we got to do all the optimizations and
were able to release any eight on one of
these platforms so this is a single-chip
solution with a cortex-m with 256
kilobytes of on-chip ram that's all it
has so the SOC is here the rest is just
you know pins and resistors and stuff
like that and ethernet interface
but the entire system runs on the single
chip it's very cheap and the entire java
me eight runtime only needs about 190
kilobytes of RAM and so you have 60
kilobytes left for your application so
you can actually do pretty decent things
with it and it has a complete Java 8
language has corey api's you have
networking you can talk to devices you
can hook it up to the tooling you know
right applications and netbeans and it's
it's arduino compatible so you can plug
in arduino shields um and you off to go
so it's a great great little platform
and of course if you wanted to deploy
this you would take the actual slc and
then put it on your specialized
customized hardware but this I think
this is this is really a big step
because you can take your Java 8
programming skills in your tools and you
can now you know within hours you can
write embedded applications that run on
these really tiny devices this is the
week we released this yesterday it's on
OT n so yeah you can download the binary
on otm ya know you can buy this from
distributors today you can go to mouse
or one of those guys and you just order
online no yeah oh hot yeah I mean they
might be out of stock temporarily but
that's how I got mine you just order
them they've been this has been around
for three or four months now so right so
basically when the vm starts off and
when you're ready to run sort of hello
world right that takes about 190
kilobytes of RAM and then anything
beyond hello world is your application
you have 60 kilobytes left which is you
know not bad considering that it only
has two
56k to start with and then you know 60
60 k of space if you write your code
mindful leave you can actually do a lot
of stuff so though sorry there was a
question back there so is this
appropriate for like health care devices
and wearables absolutely I mean that's
one of the target use cases in fact
we're working with a company right now
that's building a patient monitoring
sort of looks like a watch but it's a
patient monitor um and they actually
have exactly this kind of setup they
have an arm cortex m4 with on-chip
memory they have a simple 2g modem to
communicate just a little bit of data
and basically all their healthcare
business logic runs on on the chip
that's exactly what they want to do and
they want to run for I think one week of
battery life is their lower limit so
yeah like son yeah okay so sunspots if
anybody remembers them this is very
similar to sunspots yes but the problem
with sunspots was always that it was a
custom-built platform that was not
really aligned to the rest of Java and
not really aligned to the rest of the
ecosystem it was an interesting
demonstration platform and we took many
of the sunspot concepts in fact we
worked with some of the sunspot team in
defining some of the features here and
this is yes you can look at this as a
replacement for sun spots but this is
fully Java 8 it's a mainstream product
by Oracle it'll be also delivered
through partners on a variety of
different platforms so it's it's a fully
supported product
squawk yeah and that that was the other
problem with sunspot squat was a
custom-built vm this is a standard vm
yes Donnie was a Christian embed ok so
what where's embed in this embed is
essentially just the underlying native
operating system so we just use we use
the embed Colonel we use some embed
device drivers on reported it on in bed
just like we could port so the job at
any eight virtual machine has been
ported to RT RT x + mq x and a number of
different real-time operating systems
embed is just another one essentially so
ideally and that's one of the reasons
we're using embed that's arms go with
embed is to be a unifying native layer
so anytime a platform calls itself in
bed you have a well-defined set of
features and ideally the java vm should
just run right it's like I don't know
you know linux for these small device
it's it's just a well-defined layer of
functionality because that's one of the
things the embedded space suffers from
like every system is different so we're
working with armaan that embed is
currently more of a another what you
call it of an enabling platform but
that's where they want to go and in fact
I have another talk tomorrow afternoon
yeah 10 minutes tomorrow afternoon where
I actually show some code and how you
can run on these devices so if you
interested in come to my talk tomorrow
so in the interest of time let's
continue because we still have a couple
of slides to go anyway so tips for the
Bell
so okay so now you you've seen from I
level how m en su are different and why
so if you want to write code that ports
between a mean SE or that in reuse it's
not perfect I agree it's not perfect we
still have some ways to go but it's much
much better than it used to be and
basically if you know what you're doing
and you know the limitations you can
actually we've done it ourselves we've
written libraries and business logic
that is one hundred percent portable
between em en SE right especially things
like algorithms right they don't depend
on the platform you just need the
language features and some core api's
those work fine right so basically stick
to the Emmy the CDC a subset you know
don't allocate five megabytes of heap
because you're not going to get it most
likely so just be mindful and then it's
actually pretty straightforward um in
some cases you want to leverage tuning
so I mentioned we don't support lambdas
in me8 yet but you can if you have a
piece of se code that uses lambdas you
compile that you get class files you can
run that through a tool it takes the
class calls with places the lambda
expressions spits out binary is on the
other side class files and then you can
run those on Amy alright so that's
possible and it you can even do that
vice versa so you can go back and forth
and now I don't know how good the tools
are but I've told they work pretty well
know if third-party tools yeah but
ideally if you write code then you don't
even add lambdas at this point and
you're fine then of course there's
platform specific functionality like the
application model and Emmy you don't
have that in SE so you have to wrap that
into a separate class you can build you
know the application model is always
very simple it's like instantiate
start/stop right you can wrap that into
whatever your SE application model is if
you're using osgi or something else
right and then of course there are a
couple of oops Emmie and SE AAP is that
you can't find any other platforms then
you actually have to rewrite some code
and encapsulated right but
libraries that just encapsulate business
logic or functionality typically don't
need those right you can so in a typical
application that needs to be portable
you would probably have you know eighty
or ninety percent of the code you can
write in a completely portable manner
and then the other twenty percent are a
mere SE specific which still saves you a
lot of work right why we are when do you
want to use which platforms so that's
actually a good question sorry so if
you're if you have a use case and you're
not sure should I use Emmy or se it's
not always a straightforward decision it
depends basically if you have less than
32 megabytes of memory you have to use
any because se won't run because you
need the operating your Linux or
whatever to boot as well so under 32
megabytes is very difficult if you need
deeply embedded functionality if you
need cellular connectivity i/o
connectivity stuff like that then amy is
probably the way to go if you need one
hundred percent java SE compatibility
you have a bunch of existing code that
you need to run unmodified or you want
to do heavy duty processing you need
lots of memory then se is probably the
way to go right okay I think we're
almost done if you're designing for
these small systems you have to take you
know the usual precautions and we
actually created a embedded software
developers optimization guide i think
it's called on the Emmy documentation
website which goes into a little bit
more detail basically you know just be
aware of what you're doing you might
only have 60 k of heap to play with
don't try to do anything fancy don't
don't write extra code that you probably
already have in the platform somewhere
try to use what you have don't create a
large number of objects
classes of one really easy thing that
helps a lot is turn debug info off and
enable obfuscation that's kind of
obvious but the pre the preset default
is I think debugging on so just turn
that off and that's easy to do in the
Emmy SDK and so I've written some demo
code that I'll show tomorrow that you
know fiddles with some I oh and dissing
communication is a business logic and
that means about thirty five kilobytes
of RAM um so you still have twenty five
kilobytes left to do other stuff okay
future so we want to make the alignment
between Emmy and SE better going forward
so these are some plans lambdas are
pretty high on the list we actually
think we have a way of doing that
conserving the Emmy footprint but the
the focus will be on code compatibility
so we want to be able to just be able to
run SE code but it's not going to give
you performance gains right if you do
lambda is because you're doing parallel
streams are probably not but at least
you can run your code without modifying
it right we're definitely looking into
adding some additional API subsets
especially around security and utilities
that's what a lot of people want so
that'll make some of those pain points
go away and this is again just a matter
of footprint trade-off so it's probably
just going to be an additional optional
API that you can add or without
depending on your use case and we're
looking into a number of other API so
that's one thing the market is going to
tell us now that Amy eight is is finding
its way into actual production
environments people are coming back to
us and say hey you know can we had this
can be at that so and we're adding some
more additional you know some features
around the services model that I think
will actually be unique and beneficial
to any that se doesn't have um by the
way if you want to get involved in this
please again
often the jsr expert groups for me8 this
is exactly where we're discussing these
kinds of features all right and these
are some pointers so there's a bunch of
if you want to start playing with Emmy
eight then you know look at my blog I
actually keep listing all the various
resources on my blog there is a good
amount of documentation as I said the
the freedom k 64 releases out yesterday
the Developer Preview premium so you can
go start play with that it's a neat
platform you can get it you know it's
like $25 and you can get started gives
you a feel for how it works Raspberry Pi
of course is another nice platform that
you can use so that's pretty much it i
think we already did a lot of questions
but we might have time for one or two
more yep
right so graphics he has good point so
yes our core focus initially is
definitely headless we have this line
base UI which allows you to do your
fairly interesting things there's touch
support you can have multiple screens
but it's not the bitmap graphics it's
it's really lie you I so it's more like
you know operator interfaces and things
like that for industrial control web
sort of the use case for bitmap graphics
things are difficult because they're so
dramatically different use cases right
you could have one customer says I've
this tiny micro controller platform and
I need this really simple you know
bitmap graphic things with 128 x 128
black and white pixels and i just want
to display you know i don't know
something simple and then you have
somebody else on a high-end device who
wants touchscreen you know 16 bit color
you know animations multi-touch whatever
right and it's just we can't cover that
range with a single you know platform so
we need to come up with an API and
graphics model that actually scales from
load app too high and that's been proven
difficult we've been talking to a number
of customers and we're working on some
ideas but we haven't quite found sort of
the ideal way forward so i can say that
we're working on it i can tell you when
there will be a product but it's
definitely something we're looking into
you know it's a good thing right because
people are saying oh we love me8 we'd
like to build something we're missing
graphics what can we do here right size
right but but it's it's a gray area
right because then the next customer
says oh yeah I like this but I'd like to
do some animations on top and then I
want more colors and then I want I have
different screen sizes and had to
auto-resize depending on the different
screens right and it's really difficult
to come up with an API that covers all
those use cases but I I know what you
lightweight you I to hit yes yes right I
yes s/m and we were definitely looking
at the lightweight you I took it it has
a number of technical limitations that
we don't think make it appropriate for
this space but yeah we're we're
evaluating different options but we
haven't come up with the if I mean if
you have a specific use case today you
can always build a proprietary API right
and hook up some display you can always
do that so it shouldn't keep you from
product housing a solution finding a
standardized API is much more difficult
all right I think we're out of time so
again tomorrow afternoon and I have
another talk on this topic thank you for
coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>