<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON4286   Frege: Purely Functional Programming for the JVM | Coder Coacher - Coaching Coders</title><meta content="CON4286   Frege: Purely Functional Programming for the JVM - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON4286   Frege: Purely Functional Programming for the JVM</b></h2><h5 class="post__date">2015-12-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Svz-_ujrSX4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good evening everybody thanks for coming
I know it's been a long day of Java one
and you're possibly tired the more I
appreciate that you come to this talk so
late in the evening I'm absolutely happy
to make this as lively and interactive
as possible to make it easier for you
and for me so any time that you have
questions please just shot into the room
will try to impress them right away the
the group is manageable enough that we
can have a discussion I would be glad to
do so who has been in the Vega tutorial
this morning a few hands okay you don't
have to leave but
we are going to adjust the very same
topic in the condensed form because
there's less time but it may be awesome
under different perspective so it's not
only useless to hear it a second time I
hope my name is Dirk onek I work for
canoe in Basel Switzerland why do we
care about functional programming and
I'll give you a short exercise this is a
program five lines of code three
variables in it what is it doing
this kind of which I always this is kind
of zoo those Java if you want right okay
or JavaScript or whatever so it is an
assignment that we have here we have
assignments it's imperative code
imperative style of coding a equals one
k equals 1 okay p equals 2 so we have 1
and 2 C equals B a and B says same C
equals B so that would be value moves
over into the place where we have to see
I'm deliberately used with place in
value so and now we are assigning be too
when you value the old value that a had
before so antsy stays the same but the
old value at the place of a moves over
to the place of B and here comes a
equals C so P and Steve stays the same
but the old value of C moves over into
the place of a this is what we do all
the time right as programmers in an
imperative language that's kind of what
we do for a living so what's the code
doing it is swapping a and B thank you
and it's introducing c4 no it's no
reason from the requirements right we
need to have it otherwise we cannot swap
things over so the
and suddenly we are we as engineers have
no problem with doing this in our head
even though we not only have three
different states we have three different
states at three different points in time
that we need to distinguish and the
reason that we have three different
points in time to consider is because of
the green stuff here let's the
assignment the other ones were kind of
like definitions the equal sign but
initialization if you want thank you
good yeah interactive and correct me if
I'm if you have a better word but the
point is that hmm now what is the right
value of a and B that depends on the
time well yesterday you said it is one
into and today you say to an one are you
lying to me or what and even worse the
intermediate state that we have one and
one is an inconsistent state so if we
have multiple people looking at these
places at different points in time they
have totally different world view and
one can easily interfere with the other
if they change in place it's not
thread-safe its kind of do it
hmm and if we try to reason about this
we have to reason by the operations that
we put put this value over here these
our operations sequence of operations
therefore the reasoning of that is
called operational reasoning and this
kind of operational reasoning is the
main reason that we need a debugger
right this is what a debugger does
specifically the single stepper we have
our watches and then for every
assignment that we have on the code
there's a new time separation everything
before the assignment everything after
the assignment and we need to deal with
thousands of points of time when we look
at code so that is not so easy the the
test that we are achieving here is
absolutely simple but the way we do it
is not so simple I would say we need to
keep in our mind nine different slots
nine different places and the normal
short-term memory can capture seven plus
minus two minus 5 i'm pretty sure about
that
so here's the second way of going about
the business with the idea that we are
pursuing here is we'd like to use a
fundamentally different way of
programming and the new way is like so
we have an egg a equals 1 i'd be equals
to and we leave it like so we do not
ever change
a is 1 and B is to this never changes
that's effect
case closed no inconsistent States it's
easy to reason about a is 1 and b is two
nothing changes
well when I explained this once to my
parents they said well bit but at some
point you would like to see these
swapped values right I said yes exactly
and we just put on glasses for doing so
it's like prison glasses where you go to
this other thing hmm swap over and
that's it it's very simple and different
people can wear different glasses like
and this does not interfere whatsoever
it is absolutely safe you can do it
concurrently you can do eagerly you can
do it lazily one it's nice
so the key idea about this new way of
programming is we don't want to have
these assignments and while we are added
no statements whatsoever let's just
program without them that is functional
programming only using functions like
these glasses those are functions this
is the sole mechanism that we have the
only mechanism there is no other
mechanism for doing for doing anything
we cannot possibly change things they're
all immutable so this is the only way
the video and now we can say well you
know what how do you do this and how we
go about this business can we make this
practical and the idea is well you have
the choice you can take the blue pill
you can take the red pill if you take
the blue pill everything will stay the
same as you know it and you stay in the
metrics rent so the blue pill is well
you can do this kind of programming that
style of programming the functional
style in every language you can do it in
assembler you can do it in Java all
those languages if you have the
discipline to not use assignments at any
point in time
well as came back says any methodology I
need any approach that is based on
developer discipline is bound to fail at
some point this is his vision of a more
people have different degrees of
discipline bit you know this is one way
of doing it you can and languages help
you somewhat i mean the the event
lambdas in java help you somewhat of
making it easier to follow that
discipline but language itself does not
really force you into this functional
style so the red pill is a pure
functional language where there is not
there is no assignment in the language
it's that even you cannot do it the
syntax even doesn't allow it compiler
fails early even the parser really if
you try to do this so the red pill is
lena will try to show in this in this
event this evening how the world looks
like this new world outside the metrics
when you do the red pill how that looks
like and you have the choice later go
back to the old world and hopefully have
learned something
or you may you may want to stay in the
after you have taken the red pill so
that's the point if you want to follow
along there is an online ripple where
you can type in the berries called
pieces that I'm going to show try it
free and minus length of work this
morning it kind of crushed under the
load or so okay I should be up again now
here's I'll show you a little bit of
code and this is hostile code right but
frigate does is it takes has the code in
emits java code it's actually java
source code and then compiles it java
see who has ever done any kind of
haskell or if you once okay like half of
you okay so you can write you can now
write haskell on the JVM that's the
point
is that literally is source-level
compila from hospital to java yes the
vega c compiler compiles has the code to
java and when we say haskell code it is
we talk about not gh3 which is kind of
the most popular compiler for hesco but
thousands of additions to esco it is
like what's called the data standard is
called the Haskell report 2010 so with
that's the standard that we based upon
ok and here is how you define a function
in Haskell of hagun you say it will make
a very simple one time times a B is
defined as a times B and then we can
just call it we can apply the function
to arguments with nose appears like no
syntax whatsoever no no parentheses no
commas it is a very silent notation says
x 3 and 4 gives you 12 and you can ask
for the type of times what type is it
and it says well
for any numerical type alpha I'll take
an alpha and I'll check another alpha in
a returning alpha and these alphas are
the same alphas you know if it's an
integer it needs to be a second integer
enable return an integer and there's
going to be no mixture of integers and
doubles and so on so that's what it says
why this notation well when we wrote the
first line there was no types declared
at all because fagan it as a hostile
type in furs the type signature of that
function from the implementation it de
uses what are valid parameter types in
what are valid return types it gives you
the least upper bound of types that put
comply to your implementation it's
called global type and friends and free
gay is the only language on the JVM that
is capable of doing this it's true type
inference
and what does it mean when we have these
blanks when you apply times three and
four why is there no comma because it's
not like two arguments to one function
call it is actually function application
associates to the left so it is as if we
had these parentheses and say and its
first ring times three times three is an
expression and it returns again
obviously a faction that we apply to for
that's something that we can do and
gives you 12 so when we asked our
reliever printing what is the type it is
telling us well there is an alpha the
only one the only parameter on the on
the left in what it returns is in here's
because the arrow is right associative
it returns if faction the result of
times 3 is a function as we have seen
it is a function that we can again give
a parameter a alpha and it returns an
alpha so when you when we read through
this code like the rule of thumb for
beginners in high school is well the
last type of that thing is the return
type and everything on the front of it
is parameters to the function whereas in
reality it is it is little more complex
yet other questions
okay yeah there's fat arrow and small
errors the fat arrow on the light which
can write out is a constraint as a call
there is a constraint on the alphas the
alphas must be of a type the Alpha must
be a type that complete complies to the
num constraint it must be numerical
otherwise I cannot do multiplication
with it in Java terms that's an
interface it must have an interface
where we can do arithmetic with it
where does it take the operator and that
bit of risk
the there's only but this this is
actually answer real maybe repeat the
question for the recording so question
is how is the mapping between the times
operator in the num type class sorry
it's called type class anyway how is
that how does it know there could be
different ones where i could have
thousands of interfaces that define the
star operator for multiplication the has
been report to ten demands that there's
only one globally for your program there
can only be one we can actually look it
up by num num underscore Matthews it
gets in my friends co-star there can
only be one and the the mechanism that
we use is kind of the the uniqueness of
class names in your class loader that's
kind of the mechanism that underlies it
in the freaking implementation so it's
an interesting implementation
now we can play with it like
functionally in interesting style for
example i can define a new function to x
as x 2 hmm we have seen that the
expression x 2 evaluates like x 3 over
here evaluates to a new function that
takes something and return something so
x 2 and obviously is as when the
expression is evaluated or it refers to
a function that takes an integer returns
an integer we call that two times and we
can apply it we can apply it to the
argument 3 2 times 3 gives six if we ask
for the type of two times it's no longer
num alpha 2 alpha 2 alpha it is now in
to end because x to the two itself is an
integer in the literature with an
integer therefore the second argument
that comes must be an integer because
they need to be of the same type global
type inference you know
the least upper bound of types for this
is into it that's pretty cool
no other language that on the JVM that I
know of is capable of doing things for
doing this so remember there was no
second argument and when our humans are
missing when Yuri and you have a
function that returns a function like so
but I partially applied as they call it
sometimes this is kind of like one of
the cornerstones of functional
programming sometimes God currying
because Hester curry was the one who
kind of made that popular it was
invented even even earlier from a
logician called Moses ring finger and
some people call sheriff inkling son
called partial function application
actually this candid this kind of
concept was first published by God la
Vega which happens to be the name of
language not by chance so and then we
have more specific types
it's all very regular now we can play
with this again functional programming
is programming with functions functions
are things that we work with that scan
unfamiliar to the Java programmer where
methods are not usually something that
you deal with like data they are
distinct from data in functional
programming and functions are things
that you pass as parameters you have as
return values and so on you can even
compose them and here is how you can
compulsion on what it means so let's say
we'd like to have two times three times
two so we could we could interpret this
as we let me first evaluate three times
to giving six and then with this six
call two times six giving 12 it's not
quite what happens but it gives you the
right intuition right these can actually
be written differently if you have
something like f of G of X right so two
times or three times of two it's like if
you remember school times F of G of X
and then high school they say well you
can factor this out we can make a new
function call it six times which is the
composition of two times than three
times in mathematics denoted with this
small circle and in vague and hostile
with the dot
two times compostable three times is our
new six times note there is no parameter
and declared left or right because it is
independent of the parameters we can
apply it again to uncertainty X so 6
times 2 again gives you 12 and if we ask
for the type 6 times isn't into it it's
kind of working with functions it's can
natural and functional programming it's
kind of function composition is more
difficult to express in other languages
and we can even go further let's say we
can specialize our functions and here's
one here's one way of dealing with it
the x function we could say well x 0 of
anything gives 0 like time 0 of B we
don't use to be any way it gives 0 such
that we don't need to evaluate the
second parameter is second argument if
that was given because such a second
argument may be expensive
to calculate and we don't even use it it
may even be so expensive that it takes
forever to calculate in here's an exam
well don't have an example here so the
example is lunch something like free
calculating the length of an infinite
list right is something that doesn't
even hold but once we use this kind of
pattern matching we still can provide
the you still know that the x 0 whatever
is 0 so why do we why is so important
for us to have pure functions that is
this is now the important part of
functional programming why do we have
want to have pure functions because we
would like to when we see a function
call or function definition that we'd
like to make the best guess not only a
guess but knowing you java you make a
guess in fig you know what could
possibly happen when you're looking when
you execute that operation so let's say
in Java you have a method foo it takes a
pair
of types T and you and returns T returns
the type T what could possibly do well
it's kind of obvious it gives back the
first entry of pair could it return null
yes of course could a throw knife on the
exceptional yes of course could it print
to assist them out yes of course
couldn't lock yes of course good go I
can't go to the database yes of course
cated launch launch the missiles yes of
course all possible things could happen
like everything can happen you have no
idea the type system don't give you any
clue what happens in Vegas you have a
method like through a function like foo
taking a tuple a pair of a and B
returning the a type there is no other
way of implementing this function as
returning the first element of the pair
this is so ingrained in the language
that each you can even have a generator
that you give the the the function
differently function type and it will
create the only possible implementation
of that there's if you on the on the
Haskell mailing list there's there's a
bot that then such that when you paste
code like this due to the on the mailing
list it will create the the only
implementation right that that is
possible for that because it cannot
return null there is no null invega it
cannot rely upon the exception because
it known unknown I upon the exception it
cannot create new values of type a
because you don't know anything about a
you don't know any constructor you have
no clue
that is you cannot possibly do a side
effect because any kind of effect would
be visible in the type system and the
the type inference now if we if be
beaten let's say we try
system.out.println I'll go to database
and launch the missiles if you would
like to implement it like so if that
would be if food would be implemented
like so then the type in forenza would
say well you know what the type that I
have inferred for your code contains
some side effects and should be like I
or something right but you didn't
declare any so that programmer I don't
compile right so you have the choice you
have the choice of not declaring any
types for your functions and then they
will be inferred or you declare it
yourself and then the type inference
anyway in first the type and sees
whether the whether your type is a
specialization of is more special than
what he has insured right that would be
possible but it cannot be more general
take is the only language on the JVM
that can do that so now once we once we
have convinced ourselves that we have a
pure function actually the there isn't
there's nothing to convince us there is
no personal thing in here right there is
no we don't have to trust anybody the
compiler intuitive runtime can do it an
IDE can do it automatically say well
this is it d it sees that it is a pure
function and once you have a pure
function you can catch the values this
is an old trick from programming like
say the cosine function right you have
to implement the cosine function how you
do it well there is this kind of Newton
thing that you lose you make a med look
up you calculate so many values put it
in a map make a map look up and give
back the value maybe it was an
interpolation between the two that's how
you do it you have cashed the values for
all possible arguments that come into
cosine you have a cash value in what all
you make it lazy leader you create it
calculated once but then for any second
call you have it already and with a pure
function you can do it with an impure
function you cannot you can do it lazily
so only when it really is demanded you
can speculative in advance compile in
computers idle all I calculate some
stuff that I may need later and then
when you need it it's already there you
can do it in parallel and when you have
multiple its expressions of the same
type you can eliminate those and put
them in one place safely this is on I
guess I des have this kind of effect
that do it for you copy paste detection
right put it in one place or extract
variable this is not a safe refactoring
in general because this expression that
you have if you cannot assure that it's
pure may have a side effect it may it
may count how often you called it right
it may lock something once you log it
makes a difference whether the locks
data appears once or three times so this
is a kind of refractory that you can
only do safely with pure functions so
many ways of optimizing pure functions
mm-hmm okay now if the purity of a
function is not in the type system is
not enforced by the type system then you
have to find out yourself for example
you have some code you would like to
execute it in parallel you need to know
whether it's red safe if your function
is thread-safe if you cannot see it what
do you do okay I look inside the
function it calls a B and C okay let's
go to a a again called AAA and AP and AC
ok let's go there so lets you get a call
tree this is one of the koala trees
right in profile that often gives you
back the koala trees here is one
lots of work but you've done it you
waded through it and you develop a
discipline you made it right okay you
convinced yourself whole call tree is
all thread safe I can call it in
parallel over here okay you commit it to
the database next morning you come back
and a colleague made it changed
somewhere down in the country well
everything again from the beginning you
have to do the very same thing again now
if the purity is visible in the type
system in any break of purity down here
would make the caller in view in this
corner imp you in this court I am pure
on this column here you would see the
impurity over here right as long as it
compiles and the type system says it's
pure you can be one hundred percent sure
that is pure so you don't do it yourself
you let the type system do it that's the
idea and there's pure functions you can
I'm trying to convince you that you want
to have pure functions
and yes I'm jumping over the magic
wanted to do some magic with you know I
don't I actually
go right here for the for the special
purpose of having Barry in the audience
did you prefer your preferred topic I
guess so hmm we have many JVM languages
and every language on the JVM has
something new it many of them have new
guarantees but either compile-time
guarantees like Scala or they have like
new runtime guarantees like closure
there's new guarantees but being on the
JVM only makes sense if you interoperate
with Java or mixed with job or integrate
with Java calling into Java libraries
using those and the question is these
guarantees that you have do they still
hold when you call into Java and every
language that i know of except Frager
this says well we just read it should be
as easy as possible of calling it to
Java and therefore if you call it to
Java all bets are off right you're back
to Java so that is kind of undermining
the purpose of everything of all of
those languages because how often do you
call into Java like this it's every
second line you're using print Lenore
current 10 million everything right so
the approach of Vega is not mixing the
two but in making interoperation waits
to put the clear demarcation such that
we know that like a break of purity even
if it happens down in the country by
calling into Java
follows the same mechanism of May of
making the Koala in here then you can
call from Java into Vega this is a no
issue and then here it this is the more
difficult issue this is the more
advanced issue which is unique it's a
unique thing that we get is you can have
Java methods that up here but you have
to declare it on the Vegas I'd if we
want to use it or somebody else has
declared it for you we declared it for
you in many for most of the JDK already
so let's say there's a class
java.net.url encode and encode within
code function it takes a string of
returns a string URL encoded Prime this
is pure if you want to use it from the
Vegas I'd you can declare it as being
pure and it works it will call this
function it could be your function that
you named encode will use the encode
method and it will apply the very same
considerations regarding robust
regarding caching and parallel execution
and purity whatever as if it was written
in friggin purely right that's pure
gives us gets a string returns will
strain no state change whatsoever no
side effect
apologies it is very different for a
method like javelin
system.currenttimemillis if i have three
calls to java.lang
system.currenttimemillis in my code can
i extract it into one call and cash it
it's probably not what you want right
you don't want this one startup time
thing and then use it everywhere you'd
like to have start times top times
whatever right get the point so let's
impure and this is visible in the type
system so it is not current time
Millie's is not returning just a long
value it's returning a value that is
encapsulated in the type of the Indy io
context as i call it so it's an i or
long sorry with the with such a value
you can get those values whose I along
values multiple times and it will not be
cashed it will not be memorized and so
on but if you want to calculate with
this long let's say subtract one
thousand from it you cannot because then
the compiler says well you know what
you're trying to do arithmetic with an
IO type that doesn't work you can do
arithmetic with long but not with I
along you first have to extract this
long from the aisle and for that reason
you have to enter the IO context and
then you're in the i/o context yourself
right then you're also tainted with IO
and your caller will as well in your
corner as well to calculate up the call
chain and it's visible on from the very
outside they vague and Haskell there
they wear their types on their sleeve
you see it immediately what happens
explicit types yes please
I'm curious about the
unit argument
zoo
while the the type here says like like
parents and then arrow I along that
greets as unit unit is a type and the
value and here is kind of maps to
there's no arguments for
system.currenttimemillis when you say
you call current time Millie's you get
more if you have no parameters on it
that's the way of expressing it
a function without arguments is constant
current time Millie's is not a constant
therefore if you have the unit I that
stands in for that yes but very good
observation here good so long story
short they get a last calling java and
reusing all of java your personal java
code that you have written but never
unprotected you can never use it
unprotected you have to declare how the
java methods and types would have needed
to be declared in free terms if they
were implemented in friggin so will be
become very explicit about the effects
exactly like Hester because it is
helpful in this global type inference
that get from this is so immensely
useful and I guess I'm unable to explain
how useful that is in this 60 minutes I
hope you give the language to try and
then you will find out how immensely
useful that is it is type safety
it's not only one order of magnitude
more type safety than in Java it's like
I don't know how many right three orders
of magnitude wrestle this pervasive a
way so how do we program with it so if
something has as IO type is kind of
tainted with with an effect then the
koala must be in the corner so it means
the ultimate caller your main method is
also of an IO type something let's say
okay but still somewhere down in the
quadtree we can have pure computations
we often say it's kind of islands of
purity in the sea of imperative code
and the interesting part is you can have
pieces of code that you can really
reason about the other ones you have
these operational reasoning but here you
can have really scientific reasoning in
the green ones yep that's a pure
computations else for example thread
saved by design the other ones that make
these contacts they are called monads be
brave they don't bite is just a name for
it and I'd like to make in a short thing
here with erotic example how do i
program with this M it is it practical
to program with it and on we are going
to use as an example something that's
often used in interview questions and
interviews with developers as an example
for how would you write this fist bears
isn't like a children's game some people
say drinking game where you count
numbers 1 2 3 4 5 and so on and for
every third number you say fees and for
every fifth number you say buzz and when
they come together they use a fizzbuzz
its capital one to fizz
purrs 4 and so on hey I'm not so good in
this in the evening good so that's the
thing and then in imperative programming
the typical solution that you find when
you google for word is this one yeah for
loop 1 2 100 changing state and then you
first have to have the 15 case covered
and after that maybe the three or four
three or five you can there the the
sequence is not important and then the
very last you have your number look who
would fight that kind of problem like
this and that style nobody okay and the
right players here you'll find lots of
solutions for that and it is Java code
but even in Java of course they're
better solutions than this one anyway
few years ago I would have written that
code let's let's tackle the problem with
pagan yeah I'm going to use the Vega
console the command is in javafx console
actually written in figure with javafx
and make this little bit higher for you
then
bigger so we need the numbers in getting
all numbers has a special little
annotation for it it's an infinite list
of numbers but the repple is clever
enough to only show you the first 80
characters of that so it doesn't take
forever for calling it we'd like to have
these numbers as strings right for
putting out both printin so if we have
the numbers we are mapping a function
over these numbers like with lambdas in
Java right mapping then what is the
function that we met over we will
totally say the two string function due
to string method that would be the job
way of doing things in in Heslin frigate
squad show so we have a list of that
let's give it a name numbers
this is a function that has no arguments
there for constant it's an example of
what you have so we have numbers we need
something like every third thing is fizz
right so while we could do one way of
doing this is we say make an empty
string in another industry and if is
right evaluates to that while we can
make an endless repetition of this with
a cycle function and we can give it a
name fizzes because that and we need
buzzes I'm pretty sure you
guess what we are doing now
make the same
buzz
so what how do the buzzes look like
so hmm now we'd like to combine fizzles
and buzzes into a pattern that we can
superimpose on the numbers mm-hmm so
here comes a pattern equals we have the
fizzes and we have the buzzes in value
yeah okay is that really okay so there's
some special function that you typically
have in the functional programming it's
called a zip you have a zipper like to
endless list in your element wise put
them together getting a new list right
and you can even provide a function and
what you do how do you combine things
and this is called zip with and you give
the function so what function is that
it's concatenation that's the string
concatenation function is the plus +
operator could write concat here but
into this one so what is the pattern
let's say fierce buzz fields fields
fields pearls fizzbuzz is good at number
15 hopefully okay we have it now we have
to impose this pattern onto the numbers
hmm so the fizzbuzz
equals the numbers and the pattern and
we like to combine those again we have a
zipper just a second live with now
clever engineering choice it is so when
you have as strings have an ordering but
there's an ordering of strings you can
small end in larger strings and it
happens to be so that strings that only
contains of contained digits are always
smaller than once that do also contain
other characters non digits so if we
take the maximum of the bowl Kemp tricky
you know a way some fun in the evening
fizzbuzz well how does it look like we
have one two phases 13 or 15 is movement
missing when it went out of scope you so
let's say we would like to we would like
to print all those maybe 100 ones and we
take 100 of 100 entries from the fizz
bus and we fall over this it's actually
an iterated not a list is an iterator
for every entry of this we do print line
move and here it tells come spring
looks pretty good and we're very
flexible and what we print out so that's
that's the tip of what I wanted to show
you is there's it's kind of a different
way of doing things it's different way
of approaching the same problem that you
can learn in functional programming and
the pure functional language forces you
into this new kind of thinking so more
learning opportunities for you no way of
cheating why that's the point you'll
better learn if there's no way of
cheating and it's also so that coo coo
not only is it practical yes please
to mapping the first argument over to
result of zipping
just for that
at the at the risk of giving the wrong
answer I would say no I'm not quite sure
whether I understood your point but no
no no we can put this up upwards but I
don't think it's actually what you what
you mean anyway
good so when we combine these when we
when we look at these solutions we have
met we have lots of herbs we have lots
of conditionals in here we have lots of
operators in here we have lots of
occurrences of print line in here hmm
now imagine maintainability here comes
your C or he says your new rule every
seventh number should be foo
okay now I have to think about the
multiples of 3 &amp;amp; 5 &amp;amp; 3 &amp;amp; 7 &amp;amp; 5 &amp;amp; 7 &amp;amp; 3 &amp;amp;
5 &amp;amp; 7 in the correct ordering you know
get the point it's really difficult to
do here fifth something cycle zipping
done right it's like the the
requirements actually stand out in your
solution so if you combine those lots of
conditionals apparatus nesting levels
and so on in the imperative solution and
the in the logical solution it's much
easier to work with and to keep
consistent over time so in comparison
the it turns out that with these pure
functions you are much more robust right
the practical thing is concerned with
the practical languages on Monty mostly
concerned with we have this engine here
right this Hardware thing how can we
make it work and make a distractions
over it whereas the the functional world
is more here are my thoughts how they
make the Machine execute my thoughts its
general machine executing my thoughts
that's the point
mm-hmm what is unique in Vega that no
other jbm no other of the popular jbm
languages has explicit effects in the
type system
with the advantage that if there is no
declared in fact we know it's pure and
we can apply all these optimizations
that are talked about you choose the
lazy evaluation this purity is enforced
in the language we cannot cheat and we
need to work with immutable values
because otherwise that whole laziness
wouldn't work the global type inference
can only be achieved in a language that
has no statements but only expressions
because only then now imagine this your
favorite language you have a method and
there is some type inference best local
type inference in many languages but can
I in between any kind of calculation
flow in system out print line which
makes it you know the statement but
there should give it a different type
because by the way system out print line
should actually throw I or exception
right because of this I oh could write
into a file so why is it not throwing
either exception that would be the real
thing that would be visible in the type
system
it turns out that's all broken a drama
anyway so here you see it in the type
system if you want to come a good thing
to contemplate for one week is why is
system.out.print and not throwing io
exception and then looking into the
source code of the jdk what stands there
have fun with it good so the point is
with these unique things and this is
every single one not only the
combination every single one of these
characteristics is unique for Vega on
the JVM if we want to have this well why
do we want to have this and that so
because it makes code so much more so
much more robust and a parallel
execution composition composition is my
is the most important one for um let's
say you have a library method that you
call it takes a string return something
you don't even spend the affection of a
second considering whether it is safe to
put a string in there you have a string
you pass it in why don't you spend any
kind of time doing this because you know
this kind of method cannot possibly mess
with my string it will not change my
string but for any method that takes a
list or a person object or whatever you
don't know you need to consider well
could it could do something to it right
better pacity copy of whatever
composition if you have fewer values you
can always call safely and with this
kind of setup that we have inflated
let's say it's the best way to learn
functional programming and if you're
then later in your old language in your
other preferred language you apply
functional programming you're in a much
better position knowledgebase and yes
it's just a pleasure to work with but
everybody says it was its language so so
I say it as well difference is he is
true how to learn about Vega it is go to
pagal I nautic work follow frig lang on
Twitter fragrance Stack Overflow tag and
i really recommend i cannot recommend
enough if you really like to learn
functional programming subscribe to the
edx massive open online course that is
currently running you can still join the
first homework is due by November
twelfth so we should do it before that
time and it's held by Eric Meyer who is
extremely knowledgeable about functional
programming this this he is crazy right
and he takes pride in being crazy anyway
his knowledge is unimpaired and you will
learn functional programming in this
course it's not an easy course it's
rather challenging and it's more than
101 I would say but it is worth it if
you want to learn you will learn
functional programming most of the
examples are originally in Haskell that
means you can do them in friggin right
there's even specialized frigate
solution that I have provided here
so use it you can stay on your favorite
platform to jb m and still do this kind
of purely functional programming
shall be closed with some questions some
more yes please
yes please sorry yeah practically I
imagined that there's a story for
calling free from job
I would imagine the
creative or even
implementing some of their entry gate
yep want to be yes
they compared to java source code you
call the java source code it's you have
a class with an method in it typically
it's a class with the aesthetic method
in there so if function is is backed by
static method you call the static method
give the parameters
names well when you have lots of inner
functions they usually go like inner
classes this is format with the dollar
sign and so on that's how that's how
Java does it right it compiles to java
source code you get the very same effect
as if you would use lots of index dances
in java source code
performance so asshole through GC GC is
relative you hide
not known to be slowly
yep yep so question is performance
I've been in this kind of situation
since many years because of my heritage
with groovy and over this year's I came
to the conclusion that doesn't help you
it is there's no such thing as the
performance of language anyway so I can
give you an answer that is equally
unsatisfying and that is it compiles to
JavaScript so it has by definition the
same performance characteristics as Java
doesn't have you either because
solutions are different right so give me
a sec now from the now i give you the
real thing which is only anecdotal
evidence in our measurements in in the
average when you do when you write in
application like the the repple that we
have seen is using javafx it's written
in vega the Vega compiler is written in
fragrant the Eclipse plugin is written
in Flay again right you will not see any
performance difference as compared to
when it was written in Java even for an
application you don't see it in a micro
benchmark you may see differences so
overall same performance we have some
specialized data points for performance
you can actually read that up also on
reddit and so on asking the Haskell and
Java and so also community because we
were very surprised with the numbers
with the performance numbers we have
especially when it comes to parallel ISM
we have data points where Vega is
considerably slower they can watch can
sue Dooku's thing and it was slower
and we have other data points where it
is considerably faster outperforming
heskel by effect over for outperforming
java highly optimized tenth optimized
java by a factor of two but those are
exceptional data points right and you
cannot use anything from it so in single
data points that overall my point is
performance wise over all this you don't
need to expect any kind of performance
hit if you go there and if that is
that's the best answer that I can yes
yes please
two
us
do we have any optimization for
primitive types
and
of
always do we still have this thing up
himself but but what but what's your
name and Eugene like so Alexander Eugene
equals one plus one right I'll do this
you and we have the Eugene function okay
and now we say what Java does it compile
to and we see somewhere down here we
will see a do gene function static
Eugene function here where the fizzbuzz
functions some somewhere is the youth
here it is you know this is the Java
that will get composite addresses your
question how do I call it what you call
the static method Eugene and here is
your primitive optimization you know
what the Java compiler does with that it
optimizes the way it gives you to write
the Java compiler just the optimization
already it's one reason why we use the
Java compiler because going from Java
AST to java bytecode there is no tool in
the world that is a better than Java Sea
moulding
collection likes
well before the collection like stuff it
is interesting how different it is right
how different you think about
collections me mostly because of
laziness a collection like a very long
list is really more something like an
iterator over things we have seen in
this buzz example I can go to possession
100,000 and it doesn't materialize a
list of 100 thousand entries you know
it's kind of iterative t creating things
I think so arraylist necklace view you
get onto specialized data types because
of their performance we since yesterday
we have we we have a very good
implementation for native race if you
want if you need to have them right you
can very highly optimized the flagger
compiler compiles itself right when when
we built the vaguer compiler free
compiler compiles itself this is I would
say the biggest real-world application
that's also written in pagan and it's
reasonably fast i would say i would
assume written in plain java would not
be faster you can I've written enough
compilers didn't know that and that's
really interesting at the point there is
we can make use of parallel ism very
aggressively because we know what pure
was not pure so it can go with
distributing over the course rather
aggressively today so the the point is
is that I take your questionnaires in
for real applications for real stuff
that we do working with collections and
so on is that does it still hold that we
have the same performance and say in the
average i'd say yes
in average yes and that is as good as it
gets but i can say yes i'll save the
last question yes please
leo
is that how our project
of all these discussions
other than 18
what is the preferred integration into a
java project
here for example here says here's a
simple one it's a game by so let's thank
you we have to close them but I give you
this one playing the game but in what
kind of forecast and so on and
optimizing this happens the minimax
algorithm so you can play tic-tac-toe
could be chess right in working with
this so this is a web application it's
and it is actually it's like any kind of
java web application but for calculating
the next best move it uses fagan right
and it's actually it's linked from the
blog and linked from the website so
here's the game tree written in bega
uses mini max and this is the typical
minimax algorithm that you get
functional by so it's functional code
pure functional code but then there is
some kind of it's actually written in
groovy then immigrates application that
calls that how does it call it it has
the minimax is a class it has a function
next board we call it we give it a look
ahead in the current board so given this
board what's the next thought that we
would would be the would consider would
be the best move right the positions in
it so this is this is how you can
integrate it this is like the Java thing
and then calling calling it like a
service right my preferred way of
integration is within service API good
items gala
there is for the special case of a curse
you mention it there's there's some
there is an new native declaration for a
car you're using the native declarations
and you can use a car from Frager if you
want you so thanks a lot i guess we have
to close it and I'm available to sex
thanks a lot and enjoy the conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>