<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java EE 7: What’s New in the Java EE Platform | Coder Coacher - Coaching Coders</title><meta content="Java EE 7: What’s New in the Java EE Platform - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Java EE 7: What’s New in the Java EE Platform</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wQP0LgNneOQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone i'm linda de mikkel I'm one
of the specification leaves for the java
ee 7 platform which was just released
only a couple of months ago and in this
talk I'm going to give an overview of
some of the new features in java ee 7
this is a standard Oracle disclaimer
which I'm obliged to show you it
basically says don't bet any money on
anything i'm going to say here and
that's our agenda there are there's a
lot that's new to java ee 7 so what i'm
going to do is give you some of the
highlights i encourage you to go to some
of the other sessions on the various
platform technologies many of our
specification leads are here presenting
so it's early in the conference the
overview will help orient you to what's
new so there are three main themes to
java ee 7 support for html5 scalable
dynamic applications increasing
developer productivity through
simplification and additional container
services and meeting demands of the
enterprise with new and improved
enterprise technologies these are the
jsr s the asrs that underwent
significant revisions in this release of
the platform there are also four new jsr
s and i'm going to be speaking about all
of the new ones in the course of this
talk in addition we had nine maintenance
releases some of these are more
significant in introducing features that
are used primarily for integration with
a number of the other technologies and
we'll be reviewing a number of these as
well so let's get started on which with
the html5 area one of the key
technologies for html5 applications for
data transfer is of course JSON so we've
introduced a new API Jason processing 1
dot 0 for the ability to parse and to
generate JS
on text this API takes two forms
corresponding to the two packages
there's a lower level streaming API
which is a highly efficient event-driven
way of parsing JSON and generating JSON
you can think of this as analogous to
stocks in the XML world and there's a
somewhat higher level object level
object model API that's built on top of
the streaming API it's a bit simpler and
easier to use again if we make the
analogy of this we would consider
similar to DOM so let's start with the
streaming API the JSON class is a
factory class that we use here to create
parsers you can create a parser factory
rather than creating the parser directly
this gives you the ability to put in
finer grain configuration options if you
so desire so the way this works is it's
event-driven when you call parser next
you get an event that basically tells
you what you're looking at and depending
on what that event is you can then pull
out the value that corresponds to the
event so for key name we could we could
do a get string and look at the specific
key that's generated with the key value
the key that is corresponds to the key
value pair so to be more concrete here
if we start out with this little JSON
snippet then our first event would be a
start object event as we go down in the
text then there's a key name and we
could get the first name string if we
want it to do that and then when you go
to the value string the corresponds to
the first name some of the types are
numeric so here we would get a value
number embedded in this object is a JSON
array so we have a start array event and
similarly when we pop out of the array
we get in our end array event so using
the streaming API to generate JSON again
you use your factory
class to get a JSON generator and you
the the methods here correspond to the
event names that you're seeing you start
with a start object and then within your
object you write the key value pairs and
notice that as we go to the phones we're
doing the start or a method which will
give us which will give us phones and
embedding within that and other object
with key value pairs I've elide it the
actually brought a laser pointer this
time I've allied at the second of these
in the code on the left just because I
didn't have a room but it looks similar
so the object model API is built on top
of this you're working with JSON objects
and Jason arrays builders and readers
it's a little more user-friendly this is
how we'd use the object level API to
generate the json text on the right the
same example so we create an object
builder from the factory class and then
using this object builder we add the key
value pairs to the object we then pop
down use an array builder to open up the
array building process and then that's
the object builder calls again within
that and the way we're popping out is
just popping the stack is these calls
these calls nests so there's no end
object and array as there was in the
previous API so it's a very nice fluent
api okay um another new technology
another new API in this release that's
important again for html5 applications
is a WebSocket WebSocket 190 is the new
java api for WebSocket processing what
the WebSocket protocol does is that
gives you bi-directional full duplex
messaging over a single TCP connection
so there's the in the TCP is using the
TC
p connection last for the duration of
the client-server communication session
so there's no repeated setup and
teardown of connections it's much more
efficient than other protocols like like
HTTP so the way this works is this in is
integrated with the Java EE web
container the web container responds to
an HTTP upgrade request and then you cut
over to the use of the WebSocket
protocol the programming model is
twofold you can either use a very easy
to use at at a station based programming
model that lets you basically program
with pojos or if you want finer
configuration options you can also use
an interface based programming model and
i'll give you a little snippet of how
these work with the annotations you
would simply add rotate your POJO with a
server endpoint or client endpoint
annotation as is appropriate with the
interface based model of the API
provides an abstract endpoint class you
would subclass that class and fill in
the appropriate and required methods so
it's highly flexible it's highly
configurable the apps that you produce
are very straightforward to package and
deploy you'd use the same familiar Java
EE packaging mechanisms and in Wars or
in jars so to be a bit more specific the
main API classes end point is the class
that models your server and client
endpoint it's the one that intercepts
the WebSocket lifecycle events for
example the opening of a WebSocket
connection the message handler is what
you write to handle on the incoming
messages for the endpoint and an
endpoint can have multiple message
handlers depending on the message type
you're expecting for example text versus
binary session represents the
conversation between the client and
server endpoints and the remote endpoint
interface represents to you the other
end of the Congress
sation so if you're programming the
server end point the remote endpoint is
going to be the client and vice versa
okay so let's look at a snippet for the
programmatic API I'm assuming here we're
programming a client endpoint although
the server endpoint looks quite similar
so we're extending the endpoint class we
have to implement the on open method so
passing into the on open method the
session which gives you information
about the session between client and
server endpoints and configuration
information so in this on open method
were adding the message handler that's
going to be the method that's invoked
when a new message arrives for this
endpoint and in the code here for this
message handler I'm just simply logging
printing out the message that that came
in to me the other part of this on open
method here is getting hold of basic
remote is our view of the the remote
endpoint the other side of the
conversation so we're sending to the the
server end point that corresponds to us
just a holo back and then on clothes
this is don't even really need to
implement this method we're just calling
the super method for close this is how
it would look for the annotated version
we're just annotating our pojo with a
client endpoint annotation and then
we're annotating the methods on open I
could have named this on open anything
what's significant here is the
annotation so this could have been foo
or bar and again given the session we're
just echoing back and hello to to the
server on message is what will get
invoked when a message arrives for this
client endpoint that is a text message
there could be other message types in
which case you would have multiple on
message methods and in this we're just
we're just printing out the the message
that has arrived
so again we could have named this method
anything so that's a very simple and
clean way to program your endpoints this
is what a server endpoint might look
like if we're using annotations on here
we're specifying the partial URL that's
a pendant to the root URL for this
endpoint so this is this is a simple
little chat server what we're doing on
the on open when a session is open with
one of the peers it's engaged in the
chat we're going to add it to the set
that we're tracking and then when a
message comes in we're going to go
through all our peers and for each one
of those we're going to broadcast out
the message that came in to us and when
appear drops out of the conversation
then we're going to remove that that
that peer from the list of endpoints
that were keeping track of another
significant web tier technology that's
undergone considerable new feature
enhancements in this release is jax-rs
this is a 2 point 0 release of the
jax-rs back some of the significant
features that were added in this release
are a very nice and easy to use client
API support for filters and interceptors
support for a sink processing hypermedia
support in the form of links and
integration with the bean validation API
so in the old days in 1 dot 1 we didn't
have a built-in jax-rs client api so you
had to program somewhat along the
following lines with HTTP URL
connections unless you are using a
proprietary client api that one of the
jax-rs vendors supplied so there's a lot
of boilerplate code here it's basically
user unfriendly the method names
themselves are confusing and what can I
say so this is what it looks like using
the jax-rs 20 client API
I use the client factory to create a
client and then from that client we're
specifying the target URI I'm using a
template in here just as we have
templating on the on the resource side
to to allow us to specify different
order IDs I'll show you a better way of
programming this shortly here we're
supplying the value that we want for
this order ID we're putting together the
requests and we're getting the result so
that's very simple and straightforward
perhaps it would have been better to
have written it like this where I break
out the target so that I can reuse this
target for different values that I can
plug into the template and this is
illustrating how we might add a filter
for the invocations that are addressed
to this target from the client another
new feature that I want to highlight
with jax-rs is the use of being
validation so here for our post method
the register user method takes these
bean validation annotations that are
applied to the form parameters so the
effect here is that the validation
that's triggered automatically will
ensure that first name is not null that
the last name is not going to be null
email is assumed here to be an
application defined validation
constraint so checking that the email
address that supplied is well-formed so
this is all nicely integrated as part of
the jax-rs runtime as far as I recall
the bean validation spec itself does not
predefined an email constraint but it is
something that you would obviously want
to define and reuse that would be really
common
okay so let's switch over to our
simplification ease-of-use enhancements
of developer productivity one of the
major efforts that we try to make it the
platform spec level is to provide better
alignment among our managed bean types
so in Java EE we have a spectrum of what
are called managed beans all the way
from simple pojos up to ejbs but the
model was not very well integrated or
particularly cohesive the functionality
that was available across the board
differ depending on what managed bean
you were looking at so this was one of
the things that we wanted to align
better in this release CDI is it has is
clear that CDI is now one of the core
component models of the java eat
platform one of the things we did in
this release was to enable CDI by
default where you don't necessarily you
don't have to use a beans XML in your
module to enable CDI I'll talk about
that on the next slide I think context
and dependency injection API yeah I hope
I got that right always refer to it a
CDI so we've expanded the use and
applicability of CDI interceptors and
we've introduced at the platform level
two new interceptor types I'll be
talking about both of these
transactional interceptors and Method
level validation interceptors and we've
added two new CD I scopes a transaction
scope which was defined for the use of
JMS this came from the JMS work
initially but obviously it has broader
applicability for applications and flow
scope which was introduced in in jsf so
in expanding the use of CDI CDI
injection and interceptors now apply to
all java ee components and their related
managed classes like the callback
classes are the listener classes when
CDI is an a
and now CDI is enabled by default in
what are referred to as implicit being
archives in the CD i spec so what's an
implicit being archived and how do I get
one well the use of a CDI being defining
annotation results in an implicit being
archived so if you have in our a jar a
library jar an EJB jar or a web in
classes that contains a CDI beam with
session scoped or dependent that results
in that jar file being an implicit being
archived likewise with the use of
session beans and in these cases it's
not required that you supply a bean sex
ml so the combination of these being
defining annotations and these specific
locations provide an ease of use
facility for you where you don't need a
bean stud XML if you wouldn't otherwise
need one and we removed other reasons
that you might need a bean XML which I
have coming up okay transactional
interceptors container managed
transactions were one of the ease of use
facilities that the the ejb has provided
for yes since the beginning of ejb but
and when we simplified this further in
ejb 30 by the simple use of an
annotation or a default you could have
JTA transactions applied to your
component well we wanted to make this
kind of functionality available to all
managed beans as an ease of use
capability this we defined through we
started the discussion in the platform
spec but the annotations and the
semantics are obviously part of the
purview of the JTA spec so JTA underwent
a maintenance release JTA 12 to
incorporate this new functionality so
what this annotation the first
annotation here is an interceptor
binding annotation and when you use this
and apply it to one of your beans it has
the effect of
applying a transactional interceptor to
that being so here by default the
transaction type is required so this is
what ejb had as a default transaction
type which worked quite well what that
means is is that if there is a
transaction JTA transaction already in
progress you just simply run within that
JTA transaction if there isn't then the
runtime the Interceptor starts a new JTA
transaction for you on the roll back and
don't roll back elements allow you to
more carefully control the exception
behavior and the roll back the roll back
on exceptions for the Interceptor this
provides more flexibility than than what
ejb provides I think it's an improvement
on what the ejb spec has always had so
by default a transactions marked if an
exception hits the Interceptor that the
transaction is marked for roll back if
the exception was a runtime exception if
the exception was an application
exception a checked exception and
presumably you're going to handle that
exception so the default is not to mark
the transaction for roll back now this
isn't always the behavior that you want
so these elements are there to allow you
to customize that behavior so in the
example down here I specified sequel
exception is a checked exception so
normally if this hit the Interceptor you
wouldn't mark the transaction for roll
back but often sequel exceptions
correspond to fatal exceptions with
regard to what's happening at the
database so we do want that transaction
to be marked for roll back on the other
hand for the subclass of sequel
exception sequel warning we don't so
we're using the don't roll back to
override the behavior we would get for
the superclass
there's another use of CDI interceptors
that's introduced in this release and
that's for method level validation I
already showed you a little bit of this
with regard to jax-rs and the resource
method that we looked at so here's
another example this is in a stateless
session bean we're specifying that the
names here the product name and the
customer name should not be null we're
putting a constraint on the maximum
quantity you can order at a time again
address is a an application to find
constraint in this example validating
that an address is well-formed and
notice also that we can apply a
constraint this constraint applies to
the result that comes back from this
method so when we're returning the
result this is another application to
find constraint we want to verify that
that the order that comes back is is
well-formed so okay so we've added two
new interceptor types they're obviously
application to find interceptors that
would enter into this mix how do we
order them so we could drop down to a
bean sex ml but that seems quite user
unfriendly after we've just eliminated
it we need to establish priority
orderings what we did was we added a new
priority annotation to the common
annotation specification so obviously
something called priority is really
generic which was the intent other other
specs could use priority for other
purposes but in the Interceptor specs
interceptor spec again in mr we defined
values for priority namely these so that
these values could be used for the
purpose of interceptor ordering so you
have a declarative means of specifying
where in an interceptor chain your
interceptor should be invoked so for
example here the intercept
priority for transactional interceptors
comes at the beginning of your
interceptor chain we left a little bit
of room between zero and 200 for future
expansion but we want these to come
relatively early because presumably you
want your other interceptors to be
invoked within the transaction that
you've started again for the purposes of
the exception handling behavior and
similar on the other hand we've defined
fairly late in this stack we're being
validation interceptor should come they
come they come in the platform after
they're fairly closely wrapped to the
actual method invocation that's going to
be invoked and the reason for this is
that other interceptors can change the
values that are passed as parameters to
your method invocation so we want to be
sure that we have a chance of actually
validating that the parameters the VAT
the argument values that that method
gets or indeed the valid ones and
likewise that the result of that method
is passing back is the right result okay
um another area of simplification ease
of use was with resource definition
metadata so this is a declarative way
that you can specify the resources that
you expect to be available to your
application at runtime so it's advice to
the deployer or to the the administrator
or in the case that your your Java EE
provider is doing provisioning like you
might have in cloud environments you
could use this potentially for automatic
provisioning of resources if that's
supported in java ee 6 w 6 introduced
the data source definition metadata both
annotation in XML and this is an example
of of how you would use data source
definition I specified the name
game under which I want to reference
this data source in the jinda namespace
the specific class for the data source
that I expect to be provided in this
case I insist on having an Oracle data
source information about isolation level
which again needs to be observed when
this for the data source that's provided
to me and then something that's a piece
of advice this is a suggestion or a hint
the pool size that the container has
some discretion there so in my session
being when I do this lookup
corresponding to this name I'm
guaranteed that I get a data source that
has those properties now in this release
we've added we've expanded the use of
this idea so now we have the same
facility for JMS connection factories
for cues and topics namely the
destination definition for mail session
definition and more generically in the
connector API for connection factories
and administered objects now to
complement or to add to this area we've
now defined a notion of default
resources these are pre-configured
resources that need to be available to
you it's specific locations so the
platform has required I believe has
always required that the platform
provider provided a database in your
environment so this is a pre-configured
resource that lets you access the
default the default so the default data
source for that database likewise it's
required that there be a JMS provider
that's available to you in the
environment and in a full Java EE
environment so the default JMS
connection factory gives you access to
the connection factory for that provider
and for the new concurrency utilities
for java ee api we've added default
resources for the managed executor
services on the manage thread factory
and the managed context service
another area of simplification is is
pruiting that is making optional certain
technologies that have previously been
part of required part of the platform
making them an optional part and the way
this process works it was defined in by
Java sc6 is that one version of a
platform in the platform expert group
will define a feature as being in the
proposed optional state so what this
means is it's advice to the community
and it's a warning it's a heads up for
feedback as to whether this feature
should in fact really be made optional
and then we wait a cycle and then the
next expert group for the platform
decides whether or not this feature
should in fact be made optional so and
if it's made optional than a vendor is
no longer required to implement the
feature so if the feature is implemented
or provide it to you in your vendor
platform implementation then it has to
be done in a way that's fully compliant
with the specification for that feature
you can't halfway implement it for
example if you are doing ejb entity
means you'd have to do CMP and BMP and
the query language you couldn't pick and
choose so Java EE 6 decided that these
four technology should be proposed
optional in java ee 7 our expert group
decided unanimously if I recall
correctly that they should all be made
optional now the reference
implementation in our glass fish
supplies all of these as the reference
implementation but so that's something
to check if you're using one of these
technologies as to whether or not it
actually in the implementation that
you're using for java ee 7
alright so shifting over to the
enterprise area I listen to this one
first because it's both a major
enhancement to one of our key Enterprise
technologies as well as a technology
that's undergone a huge amount of
simplification in this release JMS has
added a new simplified API which makes
heavy use of annotations and injection
there's a lot less code a whole lot less
boilerplate fewer levels of API calls
it's a really nice job on the part of
the JMS expert group in addition to that
there have been a number of improvements
to what the JMS spec think the spec at
least the spec lead refers to as a quote
and classic API that is the API that's
been available until now there are a few
simplifications that it underwent as
well and of course in doing this we
provide the continuity with the existing
API nothing has been removed we've just
added new options for you that are
simpler and easier to use so some of
these simplifications a new JMS context
interface this combines the
functionality of the JMS connection and
the JMS session in a single interface it
really cuts down the amount of
boilerplate code you have to write JMS
now makes use of CDI injection that
wasn't except for you know things like
resource and so on the injection wasn't
used in the previous API there was a new
transaction scope that was added and
this is used to manage the lifecycle of
the context objects there's use of auto
closable for context connection session
I think it's a message producer and
consumer again cutting down on
boilerplate code the simplified API uses
runtime exceptions instead of checked
exceptions this is something that that
we introduced as a simplification back
in Java EE five but JMS hadn't been
lived in a significant way
since that time heavier use of method
chaining and simplified message sending
so let's look at an example this is what
sending a message in JMS 11 looks like
okay so this is pretty standard we're
injecting the connection factory that
we're going to need to use and the queue
that's going to be the target of our
message send so in the send message
method here we need to use the
connection factory to create the
connection from the connection we need
to create a session and in managed
environments the container is often
overriding these values anyway so this
is boilerplate here this this false from
the session we're creating a message
producer from the session we also have
to create the message and then we're
finally going to send it and oh yeah we
need to clean up and JMS exceptions a
checked exception okay so here's how we
can simplify this in 20 we still have
our resource and our cue our connection
factory in our queue being injected but
here notice how the Conte dms context is
allowing us to eliminate some of this
boilerplate code with a connection and
the session objects we just grabbed a
JMS context from the connection factory
from it we create the producer and we
can use the producer to simply send the
message that we're passing into the Sun
method here and we have a runtime
exception there's no closing here
because we're using Auto closeable
context but it gets even simpler so we
can simply inject the JMS context rather
than creating it from the connection
factory here the connection factory
annotation is specifying the connection
factory the corresponds to this context
object the one of the context object is
referencing and embedding so here our
send message is very simple we're just
simply creating the producer from the
context and sending the message to the
queue it gets even better if you're
going to use the default JMS connection
factory as I showed you earlier with
those default resources so here we don't
even need to specify the connection
factory for using the default we just
inject the context and off we go so
aside from this injection here we're
down to one line of code okay um
concurrency utilities for Java EE is
another new API that was added to the
platform in this release so it gives you
a synchronous capabilities in your Java
EE programming model as an extension of
the java SE concurrency utilities api so
you use the same patterns that you do if
you are programming with the SE
concurrency utilities api but you have
the advantage that in doing so you're
operating in a managed container context
so that container context is being
propagated as you use these services so
think of the naming context the ability
to reference the jindie context the
security context the classloader context
and so on these contexts are propagated
to you was it going to say so this gives
you an asynchronous capability at a
lower level than the async that's
provided as built into a number of the
higher-level api's like ejb offers the
ability for async method invocation
servlet gives you a sink jax-rs gives
you a sink so this is a lower level it
one that mirrors that of java SE so the
code snippet to illustrate this so i
have here a task that implements
callable
all method and some task logic and then
in the calling component I'm injecting a
managed executor service so this is
going to give me the context propagation
in the container environment and I just
simply submit my task and then wait for
the results to come back so the API is
on a parallel with se another new API
and this release is batch applications
for the Java platform or simply batch 10
batch processing is designed for
typically non-interactive bulk oriented
and long running tasks so this API is
very flexible it's quite configurable
you can have sequential parallel
decision based execution you can do
checkpointing so that if there's a
problem in your job you can resume from
the checkpoint and some of this
checkpoint is automatic the check last
checkpoint there are two basic
processing styles the most common or
expected one is a chunked processing
style a reader processor writer pattern
is used for that task oriented or
Bachelet is more a roll your own style
your urine full control at a more
nitty-gritty level so key concepts here
the notion of a job which is your entire
batch process and the structure of a job
is defined by an xml job specification
language a job has steps each step is
the steps can be run in parallel but
each step itself is a sequential phase
of processing the job operator is the
interface for managing job processing
and the job repository is what gives you
information about past or present jobs
and you interact with this repository
through the job operator so the
repository for example may be storing
information that you need for
checkpointing so the two types of jobs
steps the chunked with an item
reader right and processor item writer
the step is run within a transaction so
your chunk execute within a JTA
transaction and your chunk is check
pointed so when a chunk completes
successfully you have a check point for
the chunk Bachelet is more roll your own
and you can interleave you can include
both types of steps in your job so
here's an example which for people in
the back of the room probably can't see
but what it's showing you is we have
three steps in this job the first step
notice that each step except the last
indicates what the next step should be
when that step completes this chunk the
item count says how many items are going
to be red and processed before being
written but your chunk will execute
until your chunk reader determines that
it's out of data for that chunk so so
notice that this has a reference here to
a mai tai and reader my item processor
on my eye and I'm writer the item reader
implements the item reader interface
likewise the item processor implements
the item processor interface and so on
now you can use CD and make use of CDI
injection in these are readers
processors and writers and these can be
CDI named so if we attach the the named
annotation to a class called my item
reader that gives us the binding between
this reference to my item reader and so
the reference will be automatically
bound for you for that named that named
in class that named class so after
completing the first step then we go to
step 2 which is a Bachelet this is just
going to run to completion to finish
step 2 and then step three is another
another chunked step so this is a very
simple job I haven't shown you the
parallel processing or the decision
based processing but
the structure of a job is highly
configurable through this API I believe
there's a means to do scheduling but I
don't recall you could certainly
schedule by other means quite easily
yeah so you can fire up your job through
a timer okay um jpa I just want to talk
a few minutes about schema generation
this is one of them the major features
that we added in the JPA two one release
so this provides for the automatic
generation of database tables
constraints such as foreign key
constraints indexes and so on the API is
designed for a wide a wide range of
applications all the way from simple
prototyping where you want to start with
a bunch of entity classes and then
simply have those entity classes mapped
into a schema that's generated for you
in the database to a production
environment where you may have carefully
tuned the database schema you produce
sequel ddl scripts and you don't want
anybody messing with them you want to
use those ddl scripts whenever you run
your JPA application for provisioning
environments where you would also want
to make use of ddl scripts so you can
generate from the object relational
mapping metadata from your annotations
or XML or you can generate from scripts
that you bundle also use sequel load
scripts you can generate directly into
the database which you'd probably want
to do for prototyping or you can
generate directly into sequel ddl
scripts and then tune those scripts
later on but that might be a first phase
or you could do both at the same time
the process is very flexible it's
controlled by metadata and runtime
properties so this is how you might do
it with metadata in your persistence XML
file you could also do this dynamically
this isn't the only way you can you can
do schema generation so here I want to
generate into scripts I specified the
the action I one on the database is none
this is the default anyway but i'm just
showing it here for illustration and
then i'm saying that i want to generate
both drop and create scripts to do so i
need to specify where those scripts are
going to be so this is a string
corresponding to a file URL for the
create target likewise for the drop
target so when if your environment setup
correctly when you process this
persistence unit those scripts will be
generated I'm almost done so I'll take
your questions afterwards this is how
you could generate from scripts so here
i'm specifying the action on the
database to the drop and create so if
there is existing data i'm going to run
i'm going to run i'm going to well i
will in any case run the drop script and
then the create script i'm specifying
that the source that i'm going to use in
both cases for the database action is a
script rather than the metadata and I'm
giving the location of those scripts
they're bundled in the persistence unit
and the root of the persistence unit and
I've also included a load script I
should mention that if you want even you
can do a combination of generation from
metadata and then scripts or scripts
then metadata why might you want to do
that well if your metadata is good
enough but you want to do something with
foreign keys or constraints that you
have in scripts you can generate from
the metadata and then run the scripts or
run a load script okay so to sum up and
I've kind of scratched the surface we've
addressed three main themes in this
release support for html5 applications
with new technologies particularly the
new web socket and Jason AP is a number
of our web-based api's have also
undergone significant improvements I
didn't even talk about servlets here
jax-rs in simplifying simplifying api's
through better integration with see
I more container managed services like
the Interceptor services I showed you
metadata to help make your life easier
for the resources that you need and new
and simplified ap is for enterprise
processing as i said we completed this
release a few months ago you can go look
at all this work we let all our jsr ease
with a high degree of transparency so
for all of our Oracle lead jsr s there
are java.net projects the this is the
URL for the platform jsr it gives you a
pointer to the other jsr as you can look
at the email archives for the expert
groups their public download areas that
typically have a history of the spec
drafts that were circulated to the
expert groups some of these have code
code repositories as well their issue
trackers that you can use to report bugs
that the API levels or new feature
requests so that's a good place to put
your feature requests or the users
observer list you can join and again
send feature requests there I'm going to
plug the Boff that bill Shannon and I
are holding tomorrow afternoon this is
an image from last year's Boff the
people feed it there are all
specification leads if you'd like to ask
individual questions to them or to us as
a whole please feel free to come we're
also going to solicit input for java ee
8 so if you have input you like to give
us for new features or directions you
think are important for the platform
please do come and and of course
download the sdk and to celebrate the
release of this including glassfish 40
which is our reference implementation we
have t-shirts at the back of the room
and there is giving out java ee 7
glassfish t-shirts so please get one on
your way out and if anyone has any
questions I'll hang out here for another
five or ten minutes thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>