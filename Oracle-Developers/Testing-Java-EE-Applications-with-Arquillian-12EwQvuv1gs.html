<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Testing Java EE Applications with Arquillian | Coder Coacher - Coaching Coders</title><meta content="Testing Java EE Applications with Arquillian - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Testing Java EE Applications with Arquillian</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/12EwQvuv1gs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay first and foremost I have links for
the slides themselves this is not a very
terribly slide heavy talk anyway but the
slides are up there on SlideShare along
with all of my other talks I think the
most important part of this session
really is the code that I have to share
with you most of the time I will be
walking through that and doing demos of
that code but the code is up there on
github and I actually have I've tried to
keep make it relatively self-contained
and I'll show you what is on github so
here we have github there's all the code
and it's as I said it's intended to be
self-contained so you can go on to the
log runner to the github website there
will be setup instructions on how to set
up the code yourself in off Jager
hopefully that's that's a good enough
template for you to get started using
you know doing what what we're going to
talk about for this session okay so
leave the links up there just for
another few seconds then I will take
them down and we will get started with
the slide deck in the code it goes and
here we go alright so the title of this
talk is a testing Java EE applications
using arquillian don't know who I am my
name is Reza Rahman I'm a Java a
glassfish evangelist at Oracle
Corporation I also happen to be the
tracks chair for the server-side or Java
EE track my information is up there my
email address and Twitter handle you
know feel feel free to come up here and
grab a card if you if you so wish one of
the reasons I'm up here and I guess I I
hope I hope all of the sneakers are up
here is to help you out so whatever you
need help on weather didn't this talk or
pretty much any other Java you related
to talk feel free to reach out to me and
I'll try to do the best that I can
this rocky talk is basically all about
how you can effectively test Java EE
components all Java EE components
starting from the JSF stack all the way
down to plain CDI components okay using
this very interesting tool that I've
used for a quite a few years now I've
used for about three years
it's called arquillian hopefully some of
you have
heard about it and are actually only
here to see how you go about applying
this effectively using Java EE
components if you don't know what this
tool is I will do a very brief intro to
it as well so don't worry too much if
you haven't heard of it before all right
testing j2ee and java ee a bit of
historical perspective testing was
actually one of the biggest pain points
for JT and I was a j2e developer it you
had to basically go through a whole
bunch of a whole bunch of gymnastics to
get to test things like hav two
components and the like they really
weren't a large amount of things to help
you out with that at all so as a result
as a sort of historical legacy of that a
lot of people think that java ee is a
equally painful or perhaps impossible to
test but the reality is that was JT and
now we're in Java EE I would say that
Java EE is actually a very very testable
technology there's a number of things
that have happened both in terms of the
features in the standard as well as in
the tooling ecosystem Arcadian being one
of the prime prime ones that actually
make this sort of a no-brainer in my
opinion our Killian is by no means the
only solution that is out there for
testing Java EE components but honestly
it is the Best of Breed if you were
later it is a de facto standard I
certainly recommend it and the nice
thing about arquillian is it's not
absolutely specific at all you can use
it with pretty much any apps or any Java
app server I'll show you the supported
app servers and sort of the modes that
you can use those those app servers in
and honestly our Killian is beyond j2ee
Java EE as well I'll be focusing on how
to test Java EE components but by and
large you can use our community tester
pretty much anything that runs on on a
container of sorts even if it's
something as perhaps as obscure as an
OSGi container and arquillian does have
explicit support for those as well
because we are talking about Java ie
generally I'll be focusing on developer
testing so in my mind that is you
integration testing you can basically
use arquillian the same techniques that
we'll talk about today to do a whole
bunch of other sort of so testing as
well so performance testing stress
testing even even to a degree system
testing you can do using our Killian
it's a perfectly suited tool to do to do
all of this but in reality our Killian
really excels at integration and
regression testing this is the problem
you're after and I hope that it is ok
because it's extremely if there's one
type of testing you should do developer
testing you should do it really is
integration testing in our Killian is by
far the best tool that is available to
you at this moment I will also be
focusing on j-unit ok you know I've used
a unit throughout to be honest with you
I haven't had many reasons to look
outside j-unit however our Killian does
support a whole bunch of other test
frameworks like Destin G and J behave
and there's a bunch of other ones out
there that I honestly I've never heard
of myself beyond looking at them and the
arquillian documentation there oh
there's another supported testing
framework all right so what is it that
fundamentally makes Java EE testable
there's a whole bunch of factors that
make Java EE components testable it's
not just one thing and really depends
upon what layer you are attempting to
test so there's both things in the
standard things inherent to the to the
particular java ee standard and and also
in the tooling ecosystem that makes java
particular Java EE components testable
first and foremost servlets the recent
servlets are are inherently testable via
via integration test is because they
talk a well-understood laugh well one
less well understood protocol namely
HTTP okay so basically any tool that you
can use to exercise an HTTP component
you can use to to effectively test
service to various degrees in particular
i will be using i will be showing you
how to use a jax-rs client api something
that was added in Java EE 7 to test
server let's believe it or not this is a
very good
effective tool to test servlets although
it is intended to be a rest ap in
primarily intended to be a rest api JSF
is similarly guessable because of HTTP
and because it's servlet based a however
there's some particular characteristics
of JSF that make it is relatively test
friendly ok and if you look into the
specific features that are Killian has
built built-in for testing JSF you'll
realize that these fundamental
characteristics that make JSF in
particular testable so these are first
and foremost the fact that MV and JSF
really is a very very strong serious and
MVC framework ok so essentially you're
decoupled from all of the framework
concerns all of the concerns related to
HTTP processing and web processing when
you are writing a JSF backing beam so
that makes it inherently testable bikini
because you can think about those
components in isolation without sort of
necessarily being bogged down by the
mechanics of the fact that it is a web
framework and and sim same thing with
the component architecture because of
its a highly focused on components you
can test those components also in
isolation there's some specific tooling
again again to do JSF testing I'll be
showing you a few of those not all of
them on so I will be showing you drone
in particular I will be talking about
graphene and warp but I won't won't demo
them for you I will describe what what
they are CDI and EJB three general ER
testable because of the fact that they
are poor geo based components ok so they
do not have any dependencies on the
container per se it's just your business
logic annotated with some poachers and
anything of that nature is inherently
testable on its own right and also CDI
in particular has some specific features
geared towards making testing easier
okay and lastly I you know one of the
big advantages in terms of testing
easier b3 and CDI is that they tend to
have standardized embedded containers
okay which makes it makes them mix
testing just those
it's very very easy so if you just want
to write some unit test just that
focuses on testing CDI components that's
easy to do because there is available
containers that will just run CDI and
nothing nothing much else and arquillian
actually this is was our community
arquillians
initial focus is just to test being able
to test CDI in EJB 3 so it continues to
excel at doing that as well
similarly JPA is testable again because
there's this SE contract there's a java
SE bootstrap contract built into the JPA
standard that makes it possible to
bootstrap JPA providers in isolation ok
and again our Kilian will take advantage
of those there's actually a large set of
testing tools available to persistence
and JPA specifically so the the two key
ones is in our embedded with embedded
databases that can you can bootstrap in
inside of your test ok and not touch
have to test have to touch your
production and database or you have to
spin up a separate database so that's
incredibly useful in terms of unit
testing and JPA applications as well as
a thing called DB unit ok which actually
arquillian has specific integration with
DB unit and what is DB unit well it's a
way to make sure that your your pre and
post conditions for a given unit test is
deterministic so you can say ok before
my test executes this is what my
database state should be
please enforce this this state and at
the end of the test to say hey this is
offer up my test execute please make
sure that my test is in such and such a
state again incredibly useful just
testing technique things like web socket
and jax-rs and soap actually also have a
rich set of AP eyes and that make
testing testing them very easy but again
fundamentally they're easy to test
because and then there is such a strong
tooling is ecosystem for them because
they speak well known a well understood
protocols namely web circuit which is
standardized as as part of html5 as well
as rest
specifically the two tools that I will
be showing you to do testing of web
socket and jax-rs
is actually part of again part of the
Java EE 7 standard namely in the jax-rs
client API and the web socket client API
that's what I'll be using okay
so let's start at the lowest level so my
approach is all basically take the
lowest level Java EE API is and go sort
of go up the stack and show you how
testing those various components look
like so no better place to start than
servlet so we'll go ahead and and start
there as I said the jax-rs to client API
comes in incredibly handy so Jax if you
look at the Jax first client API it's
really intended for to be the client
side of the over of res development in
Java however at the heart of it rest is
nothing much more than a specific way of
of using HTTP so as a result a nice side
effect of that fact is you can use the
standard Jax risk to client API to test
where servlets as well because at the
end of the day servlet says nothing much
more than a Java based mechanism to
serve up HTTP requests some other tools
that are also in this space if you
didn't want to use the jax-rs to client
API for some reason are things like HTTP
unit and HTML unit and these are
actually have been around for a long
time
they're basically equivalent to the
jax-rs to client api in my mind HTTP
unit has some specific syntactic sugar
for dealing with HTTP requests HTML unit
similarly has some syntactic sugar to
deal with the HTML in particular in fact
perhaps there is a case where it makes
sense to use a HTML unit even on top of
the jax-rs client api i won't be digging
too much into that but basically you can
take in an input that you receive from
Ajax first client API and push it
through HTML unit and that will give you
a nicely parse Dom that you could you
can manipulate the traditional problem
with testing servlets and actually Java
EE components in general is the
lifecycle contain your life cycles
because you're you're testing your D
here having to deal with
trainer services you somehow to make
sure that that container is up and
running
okay and deployable you can you can take
the the things that you want to test and
deploy onto the container and vice versa
you know consumed from the container
those deployed components okay so this
is really what what and at the end of
the day our calendars for you it is
simply a mechanism whereby you can
specify on the arbitrary bits of code
that you want to test make sure that
there is a container running that will
that is able to test that you're able to
use to test those components deploy
those components onto that container and
be able to run them within the container
and also again inject you know sort of
consume those services that are deployed
onto the container from your Jenner test
okay I in this case code really does
show code is the most effective
mechanism to explain to you how this
happens I'll just explain what our
Killian does once and then pretty much
will the rest of the time will focus on
talking about the specific API is that
are needed in the j-unit side and the
and the components that you are testing
all right without further ado I will
start demoing stuff so the idea is I'll
demo one thing all exponent I'll explain
what that thing is move on to the next
API and we'll just rinse and repeat I'll
be using on basically the same code base
and that you already know about
it's basically various tests within
within that within that application
okay so hopefully my mic is still
working and I will go ahead and deploy
this application so there here's my
example application it's just a maven
based application I will show you the
the servlet that I have there is as part
of this all exercise a servlet outside
the unit test and then we'll go ahead
and run a unit test that exercises this
servlet from j-unit so here we go we'll
run the application
okay we'll take a look at this JSF
component later well I'll also show you
how that what that exactly is doing so
I'll invoke this little URL it says
action Bazaar slash alerts I'm passing
in a numeric user ID if I access that we
get requests missing basically getting a
JSON payload back and it's basically the
JSON payload is describing a set of
alerts that are currently available
under the that this Bank is currently
issuing if you're one of the people that
wants to receive alerts these are the
currently available and alerts for you
that's the basic idea here so how is
this a servlet implemented well it's
actually fairly trivial so here it is so
source packages I've tried to structure
this code so that he can easily get to
the thing that you're interested in so
the alert servlet is actually under the
web package web package so if you go
down here if you've never seen a servlet
three servlet before this is how it
looks like the web server lit is
defining a servlet it's it has a name of
alerts on it and it is bound to the
slash alerts URL pattern as you saw in
here I just have defining a service
method and in my service method all I
really do is I produce sort of this
dummy response body and I'm using
actually the Java API for JSON
processing something a JSON processing
library built into the Java yz7 standard
to produce this JSON so fairly
straightforward stuff you know getting
the user ID from the request parameter
getting the out variable of mice of my
servlet and producing the some JSON
against that so this is all essentially
JSON generation code it's an iterating
through and writing stuff to a servlet
and finally I close the stream when I'm
done fairly straightforward stuff but
basically gives you the building blocks
of what you need to write a servlet so
now we can exercise the servlet
from AJ unittest so that's what we will
do next I'll run the jana test next at
first and then i'll explain to you what
this unit is actually does and how it
does
so here's my j-unit test and I will go
ahead and run it okay so the other
interesting thing you should note here
is while this test is running I have my
GlassFish console up and running here as
well
and what you will notice is that stuff
is actually being deployed to GlassFish
as this test is running okay as you can
see new log entry is being created my
application is being loaded
initializing my application and some
more output and I believe my test is
probably done or is it not quite done
yet not quite done if you're just doing
some final cleanup okay
I'm not sure if our killing is trying to
phone home and the network is slow
usually this just is a bit faster but
this is still still fine probably
okay there we go so my test is a success
I just have one test in there it's
called test get alerts
it's basically exercising that end point
and receiving all of my tests back so
what exactly is in this test so let's
take a look at that here's my ad test
method okay it's called test get alerts
and what i'm doing here is i'm using on
the jax-rs client api to connect to that
endpoint in a programmatic fashion okay
so the client builder that you see here
and the client API that you see here is
actually part of jax-rs 2.0 and what I'm
doing is I'm hitting that target so it's
localhost port 8080 i.t is where I
assumed that container is going to be
running when this test is executing and
this is the name of my test it's called
action Bazaar servlet test and the URL
I'm I know that I'm hitting is alerts
and then on I specify a query parameter
user ID 1 1 1 just as I was doing
through the browser I make a a request
and I'm expecting a ssin JSON output
back and then when I received that it is
also automatically parsed for me and
it's retrieved back as a JSON object in
this case I'm doing something really
pretty simple I'm just checking to see
that that response has a JSON array in
it called alerts and there are five
elements inside inside of that inside of
the JSON API so how is all this actually
happening well there's a few magic bits
going on as you can see this isn't quite
a a plain plain old a.j unit test per se
so I have this magic little run with
annotation and it says run with
arquillian so what this means is that
before this tests execute it the test is
actually executed through our Kalyan so
our Killian is built into the J unit
lifecycle the other interesting thing
that you will note in this code is this
other method called create deployment
and it is annotated with the ad
deployment annotation so this bears a
little bit of explanation there's a
couple of things that are Killian does
sort of a unique
characteristics that are unique
characteristics of our Chilean one thing
is that it it controls the lifecycle of
the container so because I'm running
this unit tests in in our Chilean
arquillian we'll make sure that a
container is up and running if it's not
up and running it will go ahead and
start that container the container can
be either remote meaning running out of
process from the JUnit test or it can
actually be started in an embedded
container within within this unit test
so you can choose to do any one of those
things the second thing is arquillian
actually doesn't you know doesn't deploy
everything in your class path or or
everything in the in your application
there's two reasons why this is not the
case so one case is that your
application could be potentially much
larger than the individual little unit
test that you are running so if you are
to try to deploy your entire application
just to run a single component well
that's a lot of overhead and you'll have
to wait for the deploy and deploy cycle
to happen within the container number
two is creating allowing you to create a
much smaller targeted deployment
actually allows you to change things in
that deployment and make sure that only
what you are testing is is is exactly
what is deployed and nothing more okay
so in this particular case the purpose
of this ad deployment method is actually
to specify what are you deploying to the
container that you are going to test
okay so arquillian uses this little API
under the hood called shrink wrap that
all it does is it describes components
in a programmatic fashion in this case
you are creating a web archive or a war
file the name of the war file is action
bizarre servlet - test and lo and behold
of course there's a URL I'm using in my
unit test and the only thing the only
thing I deploy as part of this test is
just my alert servlet loss okay my so
it's a bar consisting of just one class
and that's the exact loss that is that
is under test if I click here this is my
essentially my alert so that okay so
that is essentially how the fundamental
building block of how
you can test anything that is web-based
using our Killion and also basically
what fundamentally arquillian does for
you as a framework similarly we can hire
we can test much more higher level
abstractions on in the web tier as well
so we can go ahead and test a JSF two
components similarly right so in terms
of JSF there's a bunch of different
tools that are Killian provides you so
in in order of succession they're sort
of in order of succession they are drone
graphene and warp okay the most basic
tool is drone and drone is nothing much
more than if you will an embedded
browser okay so it is a it'll load up
the same type of bra basically your
default browser let's say well that's ie
or Firefox or what have you or even a
small simulated browser and run that
browser in within within browser session
within your j-unit test and that's
basically what what drone does and drone
is what I will show you in my unit test
one level up is called graphene and in
graphene gives you a bit more control
over over a bit few more better
abstractions over just plain a browser
and graphene is more useful if you have
say quantum you two tests that are
testing entire life cycles to test so
test this page first and then go to this
page and then go to that other page and
then this conditional navigation perhaps
you know all of these things can be done
using graphene our warp is actually the
highest level JSF testing that you can
do so warp is interesting in the sense
that warp is both a API for the
client-side as well as the server-side
so when you're booting up warp
essentially what it does is it drives a
browser session just like a graph drawn
and graphene does but in the also what
it does is it has a hook onto the server
side that allows you to check server
side state so you can do things like you
know
exercise agsf page and then on the
server side check what the state of your
management is using warp okay so I won't
show you warp in this particular case
but you know that that's another thing
you should take a look at if you're
testing js7 really when you're using
warp it becomes very obvious you know
how easy to test
JSF really is because of its fundamental
architecture all right I will deploy an
application again show you quickly what
my little JSF page does here
nothing too fancy it's basically I'm
adding a bid okay so I'll go ahead and
add some sample item that I am bidding
on a sample bidder name and then some
amount let's say $100 I say add your bid
and this takes us to another JSF page
that's echoing back what was added and
all of this is actually doing a database
roundtrip okay so there's a EJB
components a JSF components JPA
components CDI components all being
exercised through this code path and
I'll show you how to isolate each of
those components later but at this stage
we are just pretending that we are
testing just the JSF layer it's
basically just the actions that I'm the
the manual actions that I took I want to
automate those so I've just such a chest
it's called add bit test so we'll go
ahead and run this guy and again you'll
see that there's the the application as
a as actually being deployed and
exercised on the glassware side so here
we go blosser is starting
loading the application
loading my my data beta base connection
oh and is it already done oh yeah it's
already done okay
all right so hey there's there's my test
ad bid method I'll show you how that
looks like I'll show you the GSR
component real quick I mean it's it's
really nothing too complicated at all
here's the ad bit page it basically has
a couple of fields each of these fields
is bound to a backing bean called bid it
has an item bidder and amount have
little action handle called con called
an ad we can take a look at this guy
here okay so as you can see it's just a
JSF managed bean called ad bid I'm
injecting him back in service that's an
EJB that talks to JP a I'm producing a a
bean that I have in my instance variable
called bid just for convenience that is
basically how I'm referring to this bid
bean here bid beam is actually nested
within the ad bit controller and here's
my own ad function I simply do the ad
bed service call and then I take to take
it to another page called confirm at bid
JSF confirmed a tad bit does GSF does
really nothing much more than look into
my bid managed bean and publish out
exactly what I what I entered before and
what was portioned into the database so
here's how my test actually looks like
so I'll start with that what the
deployment this time so here's my
deployment method in this case I'm again
creating a war I'm naming the war action
Bazaar JSF tests I'm deploying and
deploying a bunch of components in this
case I'm deploying the bit service the
default bit service which is an EJB
there as you can see it's a stateless
EJB deploying a repository the
repository is nothing much more than a
plain CD I beam with the persistence
context entitymanager injected into it
and just some crud methods to do ad get
an update operations and delete
operations I'm also deploying the bid
domain object itself as well as the add
bit controller that you saw before
that's J I'm backing B and JSF I'm
deploying the
my two artifacts facebooked artifacts ad
bid and confirm ad bid adding a web dot
Exim oh by the way this is this web dot
XML is actually custom to this test okay
so that's why what I what I'm really
doing here is I'm saying I'm telling our
Killian look in my in your resources or
look for a file called test web dot XML
and then copy it over into this into
there's a deployed war calling it web
dot XML and I'll show you what what's
inside of des web.xml are real quick as
well similarly I have a custom be in
statics mo specific to this particular
test and again overriding that and
putting in a be putting it in as the
means directional for this deployment
unit and similarly for a persistence
persistence of XML file for my Jade we
have provided and what I do here is
basically a very similar if you can
think of this as a programmatic way of
doing what I what you would be doing on
on a browser so I'm navigating to a page
called add bit JSF looking for a couple
of fields and I've assigned proper IDs
to my JSF fields so it's all they're all
under bit form and you know the the
respective fields are called item text
beta text or an amount text field and
then I'm sending in keys just like I
would be typing things on the browser so
test item ar-rahman and fifty dollars
and twenty five cents is what I added
then I am simulating a click on my
action handler and remember that's going
to execute my backing bean and we're
going to go transition to that to
confirm beta decay confirm bit dot XHTML
page and assuming that I'm assuming in
my test that that confirm bid dot XHTML
page was loaded and then I'm simply
looking up my IDs you know all the
output fields there and making sure that
they that they match the values that I
entered on in my previous step before
before I hit click OK
so that all is working just to show you
the those a custom files
deployment files that I created they are
all here it's as you can see this is
test beans dot X
you know this is specific to this
particular test if you look at just
persistence dot XML and that I'm also
deploying as part of this you'll see
that I'm actually using an embedded
database okay so if you look at my
persistent dot XML here it is sorry this
is referring to the different referring
to my jndi database gen DNA memory
database which is our global JDBC action
was our dB
but the database itself is actually
defined in test web dot XML and if you
look at inside of test web dot XML there
is this data source fragment okay and
it's actually using a derby embedded
driver so the database is actually
starting up and stopping as I am as
within my test rather than connecting up
to a necessarily a production database
so again arquillian gives you sort of
the niceties of being able to do that
okay
so I've covered a little bit of ground
so let me stop and have you ask any
questions that you may have at this
stage yeah this is very much an
integration test you can do unit tests I
will show you how to do that in just a
second it's just as in as you can as you
can see the fundamental building blocks
are or are all there right so you can
they just want to write a unit test well
you deploy that the unit that the thing
that you want to test override any wire
any wiring Mike markup that you may need
and perhaps use J unit or mojito and you
know deploy that onto a container and
run it that way and you can just run a
CD I embedded container you don't
actually have to run GlassFish or
wildfire what-have-you right so and
similarly you can if you're testing JPA
you can just bootstrap your JPA provider
and nothing much else right okay yes sir
this is a bit of a religious debate
personally what I found is I I guess I
went to the the gentleman's a talk here
previously in terribly sensitive Mike I
think this is good enough okay so one of
the things he was commenting on is is
how tedious it was to write out all of
those all of those deployment files so
in my personal experience I do agree
with that statement it can get quite
tedious you know if you have a lot of
tests so this couple of ways that you
can get around that one is actually
there's a a new arquillian or
shrink-wrap plugin that just a la that
takes whatever you are building in your
in your maven test or maven build or and
bill or whatever and deployed that to
your to arquillian you know again it
sort of goes against what arc what the
arquillian guys want to do but you can
do that and that's honestly perfectly
fine there's there's nothing wrong with
doing that as long as you're basically
taking on the responsibility of saying
ok if you accidentally deploy something
that you don't want to test your
deploying on that as well I have seen it
in the other work in the other way as
well so the big benefit to doing it the
other way is the person that's doing
that remember this is this will
potentially be a large application with
multiple people working on it and you
don't know what necessarily what all the
side effects are and having those tests
defined on a unit basis the benefit to
that is it really forces the developer
to think what are all of my integration
points what exactly are the are the
components that that I am testing at
that point in time right so
that it's a bit of a you know trade-off
as to which way you really want to go I
don't know if this really gives you a
clear answer to this or not actually
that the the deployment is surprisingly
fast in in observers like glass fashion
wildfly and and even in something like
WebLogic the deployment really doesn't
take as long as you might think the the
big hit is actually the container
start/stop lifecycle I'm using a managed
unit test in in in my case the way to
cut down on that is to use a they use
the container in remote mode so you just
have a container dedicated testing
container up and running and all you do
is deploy and apply on that and that's
surprisingly surprisingly quick actually
right and I could have chosen to demo
that instead of using the manage mode
the only difference between remote and
manage mode is I don't assume that the
container is up and running so I
manually start the container whenever I
want to run the test the one other nice
thing you can do is because it's just
Java code in your in your deployment
application you can use inheritance so
you can define you know for example the
common parts of your your deployment in
in one bit of code and then reference
that code in inside of a specific test
right so that's another way of sort of
managing managing the entire work
necessary to define these micro
deployments okay any other questions yes
excellent question so in my particular
case I am actually author-it
auto-generating the schema so if you
look at my test versus persistence dot
XML here's the source for it and as you
can see I've specify I'm using the JPA
2.1 a schema generation feature okay so
what I'm actually having JPI do is
automatically create my schema on the
flying ok so you don't necessarily need
to do that you can use DB unit to
predefined your schema or preload your
schema or you can have a dedicated test
database that already has your
schema properly defined or you can use
something like liquor base to manage
your schema so there's many different
ways of handling this yes so I have I've
specified drop and create so the data
will go away right up from the test is
done in this particular case it doesn't
have to be that way yes I can do that so
the palm file is here some I have a
bunch of dependencies upon arquillian
okay so our Kellyanne as a tool is
getting loaded on onto my application
and the test phase but all of them are
basically scoped to test right so you'll
see those these are my dependencies bomb
files but they're all essentially none
of it as actually getting deployed onto
my application itself so it's all
specified essentially at test time so I
have j-unit I have a arquillian j-unit
container which is basically arquillian
core again scope to test
I have arquillian resolver scope to test
you know so there's a bunch of other
webdriver which is the drone plug-in
that I'm using for JSF again that's all
scope to test really the only dependency
that I have other than tests test
dependencies is a dependency on java api
the java api jsr and even that is
provided so when i as you saw when i'm
deploying I'm really just deploying just
the Java artifacts yes sir
mm-hmm so I have two different
strategies to handle that number one is
you could have a number one you could
use to do what I'm doing it's just using
an embedded database and have the
emitted database start up and auto
regenerate your schema for you or have
some DML script that just basically just
dedicated to testing number one number
two is the other way is a very classic
way of having just having you know
development a development database the
problem you run into that is concurrent
usage right so you have to write your
test very very carefully to make sure
that you know users aren't stepping on
each other when they're doing testing so
in general I would honestly just
recommend all the local database
approach for testing yes sir yes that's
possible yeah there's a couple of
different ways of automating that number
one is using just Java EE features so
Java EE actually has in in JP a 2.1 Java
EE 7 there's actually a feature that
will allow you to take a DEA DDL script
and execute that when you deploy the the
persistence context okay or you can use
the other tool that I mentioned before
Divi unit that and that does exactly the
same thing in DB unit you say please
load up this data and if it doesn't
exist please
or rather ensure that that bit this bit
update this exact bit of data is in the
database and if it's not please put it
there you call that a using other
additional annotations inside of our
inside of your arquillian test so you
say DB unit you know precondition
execute this in this yamo file is how DB
unit is usually written
all right moving on to ez b3 CDI testing
I think I've talked about a majority of
this some of the specific things that I
wanted to call out is things like
embedded containers we already discussed
that point so basically if you just want
to test a CDI there's no reason to
invoke the entire container you can just
invoke the wealth container or whatever
CDI container that you're using from
from arquillian there's also some
specific things in in CDI in the CDI
Center that you should look at that's
very very helpful for testing so these
are things like alternatives portable
extensions producer methods you can use
basically the B's or XML to override
certain things for example what
alternatives are activated or what
interceptors are activated at deployment
time and you can basically use the
technique that I that I mentioned before
so B's not xml's specific to the unit
test that you that you're that you're
writing and include just that B's or XML
as part of your micro deployment okay
you can use you know mock testing
frameworks with this as well it's
entirely possible to use a unit or
mojito with with our Kilian I've
generally not have not have to do that
because the type of test that I do is
usually in integration tests anyway but
you can do you know that type of testing
just pure integration to pure unit
testing with arquillian as well usually
when you're doing that you're in the
realm of just starting your CDI embedded
container okay all right so I'll show
you a brief example of that I will run
my application layer test which has a
bit service test I'll show you how the
test looks like first so here's my
deployment again I'm creating a war
deploying the bit service default bit
service EJB I'm actually in this case
profile deploying an interceptor as well
okay so I want to do some intercept in
intercepting specific to this particular
class and of course the repository
classes the persistence dot XML and the
bean
or XML that in the test itself I
actually inject the HIV that I want to
test so this is pretty interesting
because this is the actual EJB that's
deployed to the container and you're
taking that deployed EJB and and
injecting it in into your unit test okay
and then you can do things like invoke
that invoke those eGov methods in your
unit tests to test out whatever specific
functionality that you are testing in
this case I test out my ad bid method my
update bid method as well as my delete
method I'll go ahead and quickly run
this
okay same same type of container
lifecycle that we're going to go through
here
okay so there's my easier B being
deployed by the way this is in case I
didn't mention that this is basically
the the log of the server that I'm
deploying all of my tests to so there's
my insert statement just that just
scroll by there's my add bit method
okay there's my under ployment happening
so the test is hopefully done at this
point or or almost done yeah it's done
okay so green bars again as you can see
all of the all of the tests were
executed I do have a plane unit test
here as well I won't actually run that
but you can take a look at it okay so if
you wanted to do just isolated unit
testing of the bit service EJB and
nothing much else you can do that you
can do that as well nothing stopping you
from doing that okay I want to move on
into a bit about testing other types of
endpoints besides just just servlets and
and JSF so similarly you can basically
use the same principles to test things
like web socket or jax-rs as well okay
so if you have a jax-rs endpoint
all you need to do is define that jax-rs
end point you know deploy it onto the
container and then assume that it's it's
up and running and write tests against a
ten point okay so I have a couple of end
points define defined here as part of my
application I have a rest endpoint as
well a WebSocket endpoint okay I'll free
the rest endpoint here's the rest
endpoint here oh sorry no this is the
rest you know endpoint test
I'll let me show you the actual rest
endpoint so here here is that guy he has
published out two paths both bids his
application scoped he is injecting our
handy old bit service as well and he's
injecting he is implementing essentially
post get put handily so basically rest
versions of what my underlying is jbjb
service provides right so and here's my
test I'll show you the test and for this
and in the test again I'm using in the
in this case again using the jax-rs
client API to do my testing as well
right so here's I'm building my client
connecting up to localhost action was
arrested my interest and my rest in
point bits okay and then are just using
requests and responses to simulate what
you would do otherwise on a client right
alright so I have several one of these
tests again so I have a test for update
bed I have a test for delete and the
like I think they're the websocket
endpoint is maybe a bit more interesting
so here's I have a chat server running
so the chat server is deployed to deploy
it as an easy singleton deployed to a
URL called slash at right and it has
various other mechanics like encoders
and decoders going on it's a got a
couple of callbacks on open on closed
and an on-message haulback as well so in
the on message callback what i do is i
receive a chat message and i broadcast
out that chat message as echo to all of
my connected connected WebSocket
endpoints the test is a bit more
involved in in this case I'll show you
the test in in the test I I'm using the
client API for the Java API for
WebSocket okay so this is how that looks
like I'm creating a URI I'm creating a
WebSocket container okay this is an
container that's available in in Java SE
environments like my unit test I can
then deploy programmatic endpoints and I
have a couple of them so I have one
endpoint here that on open assets a
message handler so this is receiving the
message back from an WebSocket endpoint
receiving an expecting a chat message
and on message basically it tests it
saves that message that it is receiving
from that endpoint as a test reply and
the test reply is an instance variable
of this test similarly when the
on the first thing that this end point
actually does is that it gets a handle
to the server and sends it as chat
message with a user ar-rahman and the
message chat message so what's happening
here is we're sending the message the
message is being received by the
WebSocket endpoint it's going to echo
back that response to all of its all of
its connected sessions okay and when we
receive that reply we're just saving off
that that reply here as an instance
variable a second endpoint is also
involved so this is a second endpoint
that will receive that initial message
that that we sent out and send another
chat back to say you know this I'm
receiving the there is the reply from
the first guy and issuing a reply back
and then finally when all said and done
I connect up both of these client
endpoints wait for some milliseconds -
for this for this conversation to take
place and then finally asserting my life
cycle right so I'm saying I'm saying for
the first test message the user name is
ar-rahman the message is just messages
and therefore the response I get back
and the user name is in Rahman and and
the value of the message is test reply
so I'll go ahead and run actually both
of these I'll run the entire suite for
you another nice thing is because this
is all J unit tests okay and and
arquillian is just hooked in via j unit
what that means is when those tests are
part of my maven artifact and I do a
clean and build on that maven artifact
it's actually going to automatically
execute all of those tests as part of my
delt okay so I'm actually all of my
tests including my rest endpoint test
and my WebSocket endpoint test is
defined as part of my bill so if I go
ahead and start this you'll see all of
those scroll by
okay so I have about five minutes more
we'll watch this desk roll by and in the
meanwhile I'll answer any questions that
you may have show you any bits of code
that you might be interested in and so
and so on any questions absolutely so
this is what you as you can see all I
did is a clean and build so again
because you know maven by default will
come with the Surefire plug-in and the
Surefire plugin wouldn't basically see
okay is there any GI unit test defined
as part of this build and it's so it's
going to automatically pick those up and
execute them right and in your case
because you're using arquillian they're
all going to be run all of these tests
are going to be run in container for you
I saw another Henry's from this side yes
ok yes
so actually I have an example of this as
well in my rest you will see that I I've
included a specific GlassFish API that I
need ok so you can absolutely take bring
in anything in your inside of your micro
micro development that's you know in for
example in maven central or even your
local maven repository or any other any
other place in maven similarly for ivy
and the like yes sir
that's what's happening here
yeah yeah it's actually starting up the
observer that's what's what's what
managed mode is right and you can do a
remote mode in which case our key line
will just check to see if that
containers are up and running right but
it'll assume that they it's up and
running if not in managed mode it'll
it'll start up and ultimately again in
an embedded mode for for example for app
servers that have embedded containers
like lost fish and I think wild fly you
can start the container right inside of
your like literally in the same J game
as a unit test so lots of choices
yes sir yes yeah this this arcanine is
actually very very flexible so you can
do things like you know specify entire
package names in in wildcards you know
specified various things in your class
pass yes yep same thing yeah so that's
what you use the Mason mavin resolver
plugin for you you say okay look in this
entry in my declared in my maven pom
file and pull that into my micro macro
deployment okay yes sir you'll get a
deployment error generally no it will be
the same kind of error you would you you
would get if you try to if you miss
something you know in your production
deployment yeah more than likely
something I'll get a plus not found
expection exception or or some kind of
deployment error if it's something
related to your container startup but
more than likely yeah a class path
exception yes it's also supports Anton
grade oh if that's what your build
system is it's best suited to maven but
it's not limited to may even necessarily
okay so while this is going on let me
just finish up the few additional slides
that I have and then since we're almost
out of time here how frequently should
you run arquillian tests it depends on
it depends on your general development
strategy I would say definitely you're
in you should hook it up in your
continuous deployment environment and
run all of your entire test suite when
you're prior to deployment right so to
make sure that you have a good
well we'll and well tested deployment
but in terms of development you know
you'll be running those individual tests
as you're developing them not the entire
suite just like I was right-clicking and
saying test file and that depends on
your main development methodology
honestly if you're using test-driven
development then the answer is all the
time if you're not you know just depends
on when when it is that here then your
that you want to test ok so this is a
brief sort of rundown of all of the
containers that our client supports I
won't spend too much time on this I'll
just briefly describe it to you
GlassFish wildfly and JBoss are all all
three modes are supported embedded
managed and remote there is weld SE and
weld EE okay well the NC is just a CDI
container well de is the CDI container
plus the EJB container basically
similarly this other embedded containers
like open EJB and open web beans that
you can also use you can definitely use
Apache Tommy and obviously you can also
test against web logic in websphere as
well both WebSphere classic and
WebSphere Liberty so that basically
gives you you know all of the container
covers that you may need yes ma'am
plaintiff um cat is also supported as a
runtime okay so these are all of the
resources that you may need for
arquillian and this is again the slide
deck is is on my SlideShare repository
so there's a java ee tutorial on for
Java EE 7 and of course are keenly for
our clear nor gets basically sorry for
our killing it's a JBoss dot org slash
herculean it's a tool from JBoss if i
hadn't mentioned that before although it
that really doesn't matter because it's
a basically cross platform across
platform 2 let's see if my build is done
I am out of time ok so I built success
so all of my tests have succeeded and
we're good to go and we have a ready to
deploy build if you have any questions
I'll take some more questions if not
thank you for attending session and
hopefully hopefully work for it worth
your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>