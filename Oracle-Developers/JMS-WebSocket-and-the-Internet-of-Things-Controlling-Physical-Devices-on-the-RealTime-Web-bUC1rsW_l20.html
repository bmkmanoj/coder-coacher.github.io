<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JMS, WebSocket, and the Internet of Things: Controlling Physical Devices on the Real-Time Web | Coder Coacher - Coaching Coders</title><meta content="JMS, WebSocket, and the Internet of Things: Controlling Physical Devices on the Real-Time Web - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JMS, WebSocket, and the Internet of Things: Controlling Physical Devices on the Real-Time Web</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bUC1rsW_l20" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is David Witherspoon I'm a
software engineer at cuisine this is my
colleague Prashant canal he's also a
software engineer at cuisine I'm so
we're going to start off today just with
a real quick demo and we're gonna have a
lot of demos hopefully everything goes
alright for this one we're actually
going to need a colleague of ours elbows
out he's on skype right now so we'll see
if this is going to work you want to
switch over hey Peter are you there
hello can you get there me yeah so uh
Peter you're on the Internet I guess we
are on skype here so i'm pretty sure i
am great so we're going to have you help
us out control something actually it's
not a very good time i'm watching larry
ellison on the America's Cup can we do
it another time um I think we got a
quite a few people here so let's try and
do it now that's all right oh okay so
you get have the drone ready how does
grasses drone we want to let us fly it
inside but we do have a truck here are
we controlling a truck we're controlling
a truck okay do you have the controls
for a truck yeah I have my smartphone
here and i have a browser-based at I
weather loaded on my phone and I'm going
to interact with this browser based app
and now attempt to control this truck
that you guys have their in Texas okay
are you day uh-huh where what's that
what do you want what do you want me to
do um can you turn on the lights of the
truck did you hit it
can you guys see it's not turning on are
you sure you're on that I don't I was
can you try moving the wheels for us all
right so we had some internet
connectivity issues maybe we'll get
Peter back in here and try and control
it locally sure but uh so truck was
supposed to drive around and peter is
connected to the web and so we're going
to drive it around and just to show you
a demo of him controlling something from
the webbing in real time and this and
that's sort of what we're going to be
talking about today a sort of
architecture to support that and go
through that so that's what we're going
to show so the rough agenda is we're
going to talk about the requirements of
a base and devices in m2m space of
connecting devices and we're going to
sort of create this reference
architecture for controlling devices
over the real-time web we're going to do
a lot of source code a lot of demos
hopefully giving you the building blocks
on how to build something up just for
fun and I'm going to start off sort of
making a dumb device smart by adding a
microprocessor onto it with the
Raspberry Pi for Shawn's going to then
show you how to connect over will
utilize messaging a well-known messaging
system to control the devices and have
them speak to each other and then we're
going to I'm going to take you back over
and talk about how to extend that over
the real-time web so what is the
Internet of Things I think we are all
probably familiar with this term but
it's really two things it's the internet
and things internet implying IP
connectivity and things implying you
know everyday items that are sort of
smart they have a microprocessor on them
they're able to communicate over the
Internet do do special things and we
have the bunch of examples up here we
have the car you know they smart car
it's got a tablet in it we've got the
thermostat you can control it from your
phone if you want to turn up the
temperature as you go home
etc and we listed a bunch of
requirements for the internet of things
but i think it's just cool to think
about if you think of the number of
processors in a house 10 years ago we're
looking at three to six if you're
looking at a house today 10 to 20 you
look in the future it's going to be 20
30 100 who knows and three billion
devices running java it's going to only
going to go up from there and the
marketing person snuck it into this it's
going to be a 14 trillion dollar market
over the next 10 years so you just stay
through this too and so the first part
is how do you make your dumb device sort
of smart and a raspberry pi is a great
platform for that there's a bunch of
talks on them throughout this week but
so what is the Raspberry Pi it's a
credit card sized computer it costs
about $35 it runs like a full desktop
computer has everything you need if you
wanted to run it how's the desktop it's
got USB Ethernet HDMI for your display
you can plug in your keyboard and mouse
get going it runs a hard drive on SD
card and again it's tiny and two very
inexpensive but what separates it from
your like traditional computer is that
it's really cool gpio and input and
output general purpose input and output
you can control your embedded devices
and connect through your embedded
sensors or your through that um it
speaks all your traditional embedded
communications protocol igc to wire etc
if you're familiar with that you can
also just do simple high and low
voltages or read high and low so that's
what we're going to demonstrate today so
we listed a few Raspberry Pi resources
there's links at the end of the
presentation for these but Raspberry Pi
org if you want to get all the
information on the Raspberry Pi it's all
open source so you can prototype with
the Raspberry Pi take their architecture
and then figure out how to reduce it for
your specific application if you're
going to deploy this and then weezy is
operating system we're using there's a
couple different flavors of operating
systems that you can run on the
Raspberry Pi Weezy's just linux-based
you ruined the full Oracle jvm on it
it's great you can run the embedded JVM
on it
and then the piper J library they're
giving a talk on it I think it's
tomorrow I'm not exactly sure but Robert
Savage is given a talk it's a great
library and basically the gpio as these
native calls to to the native operating
system to control the gpio and the pie
for j is a java developers toolkit to
unlock the input and output gpio for the
pie I'm Peter do you want try so here we
have the car moving around it's running
in real time as you can see reacting to
a browser running and Peter's phone and
it's running over the web so think he
had a Wi-Fi issues on this phone outside
so so talking about controlling making a
sort of dumb device smart we're going to
demo that and show you some source code
pretty symbol source code on how we did
that and we have some items up here that
we're going to show and we're going to
use this example throughout our
presentation so the first one is the
light and raspberry pi you have it up
here um the light is connected into the
GPIO and we're just basically sending
the signal onto it on and off and it's
also plugged into the ethernet so we can
get it connect into it so i'll go ahead
and go over to light so I'm SSH onto the
Raspberry Pi yer and from a simple Java
run a simple Java command
and it's initialize it's just going to
blink on and off a few times so it's
pretty simple and we're all developers
here I think so if we want to run that
see what the source code is it's just a
light class we're using the PI forge a
library so we're getting it from the
piper J library we're getting an
instance of the GPIO controller and
we're getting an output pin because
we're sending the output signal to the
light in this case not through the GPIO
and that we started off in the low state
and if you want to change the state of
the light whether it's on or off we just
change you know if it's a high or low
and then the main application just
cycled through it a couple of times
simply get it on and off and we're going
to use this same class in the same
source code it along again later so
that's why we're introducing it now and
we also have if you have a light gotta
have a toggle switch so again it's the
Raspberry Pi plugged into the GPIO and
this time we're just going to read in
simple states of whether the switches on
or off and so I'll demo that quickly so
here I'm SSH on do a second Raspberry Pi
and we'll just read it up
so it's toggle for a toggle switch and
so if / Shawn goes ahead and switches
the switch on and off few times you can
see we're just printing to the console
on and off so fairly simplistic but it's
nice because it shows you in a few lines
of code at you make these dumb devices
smart so here's the toggle switch code
in the constructor we do the same thing
getting the pipe forge a factory and
creating GPIO and this time we're
reading that getting an input pin
because we're reading the input of the
switch and then the input pin implements
a listener interface so we're listening
to the input pin and also there likewise
the toggle clasp implements a listener
interface so there's a toggle listener
interface then any toggle listener as
well that is registered with the toggles
class will get the on/off States so
that's down here so when the state
changes we print off whether it's on or
off and any listeners using that class
we just tell them whether they're on and
off so to recap this is what we have up
here we're going to use the demos
throughout the slides and it's great
it's me it's the first part of the IOT
it's the other things part of sort of
adding a little microprocessor onto your
you know everyday items household items
again it's two different raspberry PI's
both running java it's running a linux
operating system utilizing the piper j
library to connect to the switch and the
light so of course now we want to figure
out how to connect the two you're not
going to have them stand alone so you
got to take a step back and think about
the messaging requirements for the
Internet of Things space the style of
all these devices communicating to each
other when you're talking millions or
billions devices out in the field is
somewhat they're all going to have
different requirements so they're going
to be highly interconnected they might
be talking to back-end systems there
might be receiving information so the
messages are going to be bi-directional
coming or going it's going to be a very
dynamic
you're going to be deploying these
devices into the field it's not set it
up and it's going to work forever things
are going to go down things are going to
do it wrong you're going to want to add
to them over time so it's going to be an
unpredictable state of where your
systems at any time and then so you want
a messaging protocol that can really map
on to whatever your specific use cases
there's not one this light and switch
use case is going to work for everything
or it's not going to be necessarily the
same use as driving a car around and so
there it's totally dependent on what
application you're creating on what the
requirements of your messaging protocol
are going to be it might have to
identify a device it might have
different data formats that it supports
it might be talking to it back-end data
center so might need to initiate
transactions it might need to
acknowledge messages you might not care
whether it gets messages etc so you want
a generic messaging system that can
support all these different use cases
and poor sean is going to go ahead and
step in and talk about that thanks David
we just saw how we were able to use the
Java and raspberry pi to turn this junk
devices into the so-called smart devices
now let's see how we can really enable
the interactivity between the light in
the switch what we really want who is
when someone turns on the light we want
the moments when someone turns on the
switch we want the light to turn on as
well so here's an example of the
messaging service that's been around for
over a decade that decade that will help
us to solve all the requirements that
David just listed earlier java messaging
service is basically a de facto Vendrell
neutral standard messaging API that
provides us a common set of programming
interfaces to create send receive and
the messages in a distributed fat
environment so it's from the application
perspective it just provides us a set of
programming interfaces to enable
distributed messaging by default it does
not provide any implementations so that
means it allows us the implementation
portability among the multiple
applications and it also provides it
also supports the public subscribe
messaging model in a loosely coupled
fashion and it also provides us a
synchronous messaging as well as the
reliable messaging so basically it will
help us to achieve the reliable
messaging over an unreliable network so
to visualize how we can use the GMs
publish-subscribe mrs. model to to
enable the interaction between the light
and the switch we can see on the picture
over here the the the switch and the
light are not directly connected to each
other rather they are connected to it
each other via our mrs. broker mrs.
broker is a heart of the java message
service which is also called a
middleware that orchestrate the
messaging between the producer in the
consumer or we can say publisher in the
subscriber over here so the way they
talk to each other is they they talk to
each other on us on a single common
destination which can be at a topic or
queue so whenever the switch is turned
on and off the java application running
on the Raspberry Pi connected to the
switch relations for the state changes
of this search and based on the changes
on the state of the switch it sends the
message on and off to the message broker
and meanwhile the light since it's
interested on the state of the switch it
will try to establish a connection to
the message broker and it's subscribed
to a destinations that is interested on
and the switch basically sends the
message on that destination we're in the
midst when the switch sensed messes on
that destination to the message broker
mrs. Brooker looks for all the consumers
that is being that are interested to
listen for the messes on that
destination it routes the messes that
comes from the switch to the java
application running on the Raspberry Pi
connected to the light so when the
switch is turned on that my own messes
goes to the broker and the on message is
routed to the java application running
on the Raspberry Pi connect to the light
and that's how the light is turned on
and off so we didn't really try to
reinvent the wheel over here we just
used an existing messaging standard to
enable the interactivity between the
devices in the IOT free over here the
devices are basically the light and the
switch let's go through the demo and see
how this all works together I am logged
into the log into the Raspberry Pi that
is connected to the light and i'll just
run an application to establish a
connection to the message broker
so so the light is already initialized
which means it has the application has
established a connection to the message
broker and now it is ready to receive
the missus let's go to the terminal that
is connected to the Raspberry Pi
connected to the switch
so both the light and switch are already
initialized and they are ready to
interact with each other so whenever the
day returns to switch on you can see
okay okay I didn't stately turn execute
the exit the application so now it's
ready to receive the message so as you
can see when the red switch is turned on
the on message is sent to the message
broker and the which say missus is
routed to the java application running
on the Raspberry Pi connected to the
light and the light is turned on and off
so let's take a look at the code snippet
regarding what it takes to really enable
the messaging between the light and the
switch so this is basically the the the
meat of the code necessary to establish
the messaging on the on the light so as
the this is basically a class as shown
on the on the title of the slide it
initializes the light which i'm using
the same class that david so pissed
earlier it has all the logic to interact
with the light via gpio by a GPIO pin
the the difference over here is like I'm
using a standard jmes messaging
interface to establish the connection to
the message broker so I'm just basically
style just establishing a connection if
you can see over here the scheme i'm
using it TCPS are establishing tcp
connection to the message broker and it
is creating a topic and it's basically
subscribing to that topic the light over
here acts as a consumer in this case
that's why it's creating a consumer and
and like I said earlier the messaging
publish-subscribe messaging model is
asynchronous as well so the switch the
light does not the application does not
need to constantly ping the broker
regarding whether there is a new messes
are not it just listens for the messes
and whenever the new missus comes into
the message broker mrs. broker will push
the message to the to this to the light
to this application by this message
listener and based on the missus whether
it's on and off it
turns the light on and off so that's
basically what it takes to to establish
the interactivity from the light part so
let's see what it takes to send the
Javas what it takes for the java
application running on the Raspberry Pi
to send the message to the message
broker it has it uses the same set of
codes JMS interfaces to establish the
TCP connection to the broker only
difference over here is switch over here
is acting as a producer it since it
produces the message that is the state
of the switch and sends the message to
the message broker so as you can see
whenever the switch is turned on and off
it just used the basic Jameson messaging
API that is sent on the message producer
to send the message so over here with
the basically sending simple text
message that is on or off depending on
this state of the switch so to recap
what we did so far is from the first
demo we were able to turn the Dom
devices into the smart devices and from
the second dimmer we were able to enable
the interactivity between the those
devices through java and JMS and using
using the message broker jim mrs. jameis
was a natural choice for us because of
because of this because of its all this
asynchronous loosely coupled mechanism
and it also it's been around for years
there are there are many vendors to
choose from that supports GMS
specification but if we take a look at
the topology of the network where all
these devices and the messaging system
are laid out they all are laid out on a
single isolated network ideally in an
IOT space these these devices won't be
on the same isolated Network light
switch and the system may well be
located on different isolated networks
and transferring the data over TCP
between multiple isolated networks has a
lot of challenges for example those data
data data has to travel through a lot of
intermediaries or firewalls and these
firewalls may well be
be configured to filter filter out all
the other protocols or custom protocols
accept the basic standard application
level protocol and all it also it may
also be configured to filter out
non-standard ports that if we want to
communicate to likewise if we want to
extend the interactivity from the
browser-based application it may not be
the right choice because it's it's not
possible to establish a TCP connection
from the browser-based application so we
need to right solution we needs we need
a we need we need a standard but we
don't want to reinvent the web in such a
way that we can extend this messaging
over the web rather than in an isolated
network and to to unravel the solution
for all this TC the challenges posed by
tcp are like tin by david and talk
further on it thanks for trying so the
infrastructure launch Prashant presented
is this messaging broker with which is
you know utilizing the JMS messaging
space that we've been experienced with
for you know 20 years and building out
these enterprise applications and now we
want to go to an IOT space where we're
extending this from a local network
across the web you have the same end to
end points but in the center you want
the web oops and so you want the web and
you want to speak into your back-end
message broker and so what you can do is
you can throw a WebSocket gateway in
between and it's going to be speaking
tcp to your message broker and then out
in front it's going to be speaking
WebSocket to all the other devices and
so this gets around the challenges
presented by TCP and so let's refresh
what web socket is it's a relatively new
network protocol was standardized both
as an API and as by the IETF thing going
through december of last year or so or
at 2011 so it's almost two years old
there's a standard API for javascript is
by the w3c this is
client-side API there's also a JSR
standard 356 this is more like a
back-end servlet standard on how you'd
want to use web sockets on the back end
so it doesn't really reflect what the
JavaScript client API is based on it's
more of a Java EE so there's talk about
doing another jsr for the client-side
web socket but so what is web sockets is
a single socket full-duplex
communication channel it's very much
like TCP in that sense you can send
messages it runs over the your standard
protocols that the web does so you
actually establish your connection over
HTTP and then your upgraded to a
WebSocket connection and it's very low
overhead compared with HTTP I mean HP
you can have 800 to 1500 bytes and is a
request-response model and WebSocket
you're looking at tens of bytes for your
wrapping of the packets it's very low
latency and it provides us as they'll
support um just like TCP I mean not very
many people program in TCP you don't
program directly to it you use some sort
of wrap around that for your high level
higher level protocols like JMS so you
can do the exact same thing with
WebSockets so you can run web socket and
you can run Jim as X and P P and Q P
whatever I choose your protocol and then
you can use that application programming
interface leverage your protocol friend
use it from a browser your native
applications or in this case your
internet of things like devices so this
is really cool it's what we're going to
demonstrate on how to provide the same
connectivity to the raspberry PI's
except for this time rather than having
the raspberry pi is running on your
local network we could take one to nepal
will take one to spokane washington and
connect the two and have a reliable
channel that tcp doesn't you know offer
you and you're still running in the same
application level protocol of j and
that's on top of it so i'm going to
quickly demo that and
so it's going to look very similar to
Prashant's demo except this time we're
going to switch out yet this time we're
going to switch out the ws for tcp and
we're also going to change the light up
a little bit um we had an orange orange
WebSocket gateway so I think orange is
good for this color it's a little bit
more efficient so I'll go ahead and turn
on the light and the toggle switch
so the lights initially did the toggle
switch is turning on so you can see the
light turned on its received an initial
message of whatever state we left the
switch in and then if prashant goes
ahead and switches a switch we can see
the orange light turns on the messages
are being sent coming back across so
this is running over your standard web
ports and running over the web so and it
gives you the advantage of not only
solving the challenges prashant stated
but we can also connect to it from a
browser so I've got a simple JMS demo
app that's running web sockets and JMS
on top of it it's using the same API
that the Java clients are using on the
Raspberry Pi so you're programming
against JMS directly the code is almost
identical except for it's written in a
java script so i'll go ahead and connect
here so here we are connected this is
the destination or the topic though
they're communicating on so i can go
ahead and change this out to light and
subscribe to it so if prashant goes
ahead and hits a switch again we can see
the messages come across over here so
it's on/off messages this is just the
JMS what comes along with JMS so you get
special things like the destination the
message ID the timestamp of when the JMS
message is sent we're sending both text
messages like we said JMS supports all
your transacted messages all your
different messaging use cases that we
stated before hand so not only can i
subscribe it can send the same message
on or off so the lights off right now so
i'll go ahead and turn it on from here
so just going to send a simple text
message saying on and the light turns on
likewise i can turn it off so
I didn't think the car demo would break
but maybe this phone demo might but if i
can get connected to the internet here
i'll go ahead and try and get connected
from my phone
do you know pair play
so I changing network real quick
so connecting now to airplay so fillet
it will pop up here
so sorry some reason the screens off
pulling up on the screen maybe I can go
ahead and send the message from my
browser anyways and describe what i'm
going to do says it's showing i don't
know it's not popping up on the display
anyways so I'm connected to the same
demo app running from the browser up
there we go so let me turn this sideways
a little bit slow here so I'm just going
to connect this is the same demo app you
can see I'm connected over here um go
down subscribe to the topic too far
subscribe to it prashant hits the switch
we should see the message come over so
there's the on message map it's a couple
second delayed just go into my computer
but I saw it right away on my phone and
we can go ahead and send messages like
before us all turn it off
there we go so there's a light went off
on likewise you said you this was
bi-directional so in this case we
actually have both the light in the
switch listening on the same topic so
the switch is well sending messages and
receiving messages so if I go ahead and
pop well before I do that I'll show I'm
going to go ahead and change the message
i'm going to send and i'm going to say
we're going to change the message to
shut down
and if you take a look at the terminals
here when I send it there you can see
the applications actually access so the
switch is both listening and receiving
it's bi-directional it's all in the same
topic it's using the JMS API so fairly
cool showing that and so that's just a
you know leveraging the JMS messaging
system double you've used for years and
extending over the web take a look at
the source code so this is the code
Prashant presented earlier it's just
connecting over tcp and doing the first
second demo and so what does it take to
make this web socket so like we said
it's a vendor-neutral api and so if you
pay attention here we're going to switch
out the factory that we're going to use
with a different factory for the actual
WebSocket gateway and we're also going
to change from tcp to web socket and
voila you've made it so you can run your
same applications that you ran over tcp
over the web again just to re-emphasize
you can have them on different sides of
the planet now it's going to traverse
over the web from standard ports not
have all the TCP problems that we were
talking about earlier so if you think
about what this sort of means is our
view of the world is we have this
connected world we have all our devices
that speak a bunch of different
communication protocols they might speak
over IP but they might also speak RF
infrared etc and then a subset of that
is you have the internet it's a little
bit hard to read up here so the inner
circle second to inner circle is the
Internet this implies IP connectivity
and we have all these protocols that
we've run on top of them when we
leverage for years that are great on
your local network connections and then
you have the web which is HTTP it's the
one that's used most by most people it's
your browser based communication it's
we've built on it we've had great
success with that but with the
introduction introduction of going from
like a web being HTTP centric to having
HTTP POST WebSocket you can think of as
the Webster will expand Dean to fill the
internet space and you can run all these
same protocols on top of the web so it's
awesome how this is sort of shaped what
we can do with the web
and so to get back to the demo that we
showed originally it's the exact same
architecture we're running JMS message
broker on our back end we have the
WebSocket gateway in between and it's
communicating over the web or we have
that the browser set up in peter's phone
and it's sending the controls and almost
in real time across the web the it might
have looked like we had connectivity
problems but the gate label is actually
launched in New Jersey on ec2 so the
messages are going all the way across to
New Jersey and then bouncing back and
going over to the car and real-time
millisecond delay you can drive it no
problems and then if you sort of look
like it's awesome to because we're using
the java application here programming
against JMS we're using that same api in
the browser and then lastly if you were
to look at it as how you traditionally
build web applications you'd have the
application server sitting somewhere
here in the middle that is converting
you know your JMS requests into ajax
sort of doing a REST API and here using
that again that same API JMS API that
Europe can write all your client center
so what we wanted was the space where
you could communicate to all these
different devices across the web fairly
seamlessly seamlessly under in real time
and WebSocket allows you to do that and
then we also want to write the right
against right to those clients with the
standard messaging API is that we're
used to so we use JMS for this demo you
can use you know whatever you want
choose your flavor to communicate over
the web and with WebSockets in real time
to all your different devices whether
their browser mobile your raspberry PI's
your embedded devices at cedra so here's
the links to the raspberry pi resources
um if you want to check them out and if
you want to learn more about web socket
in general we have the definitive guide
to WebSocket there's a discount code
on this page for that and then also all
the source code for everything we
presented is online at github at this
count and so are there any questions or
answers what's that yeah so you can use
servlets there's this jsr written for
that oh yeah so the question is why
don't we use servlet 3x it supports
WebSocket in there that actually brings
up a great point I said what's that Oh
instead of using JMS yeah so you can use
any protocol you want one thing i forgot
to say about this diagram is we showed
you all the coder go it's all on the
client you don't have to write a single
line of server code here you just are
leveraging the JMS WebSocket back end so
all you had to write was client code you
can use web socket to get the same
connectivity across the web but it's
great to also leverage your you know
standard protocols so you don't have to
reinvent the wheel every time for your
application specific needs when you're
using WebSocket inside a servlet
container but you can do that of course
yeah there's a lot of libraries out
there there's see libraries are doing
for web sockets JavaScript node there
it's going to be in all your client
platform sooner or later and they're
mostly already there I think I saw one
in Haskell free cently do they all
support your standard ap is not
necessarily knock JMS but maybe there's
some flavor that you want to use for
your design so with HTTP we have a
pattern there's massive clients
connecting to this to proxy laps of many
servers behind
what's the best practice with WebSockets
a similar approach so the question was
how do you scale websockets out with
HTTP we proxy to back end connections
sort of doing your load balancing so
there are solutions out there we work at
causing this is a problem we have we
each solved by a having fan out so you
have gateways thread throughout and you
we have a custom load balancing approach
to that so you look load balance it out
just like TCP for that case so it's the
same solutions over TCP extending them
to the web and fan out is the idea of
you know having four gateways that get
the initial request and then you gather
your backing gateways I take it in from
there yes the question is how easy is it
for you to do what we just did so with
no electronics programming experience so
it shouldn't be too hard we have a blog
article that will be coming out all our
source code is online the resources we
showed here we're extremely useful it's
familiarizing yourself with the
Raspberry Pi in general for taking it
and getting onto your devices I mean
we're pretty simplistic we're just
sending a high voltage or reading
 edges in from your embedded
devices there's great tutorials on
oracle on how to install the JVM and get
up running with the raspberry pi the
piper j library is very simple easy to
use it took us about an hour to figure
out on the car demo the hardest part was
waiting for all the hardware to come
together once we got it we wrote this we
ought to working in a day actually an
afternoon and we we were drinking beers
at the time to
so it shouldn't be too difficult yep
yeah so the source code is on my github
account so DPW spoon / cuisine by David
Peter Witherspoon you want to repeat the
question oh sorry the question is who
sets out the cubes and topic over here
without using the server right so we're
using basically all the existing
messaging system mrs. drukker out here
for example for this application we use
activemq so we were basically we were
connecting to FP mq and activemq is
responsible for orchestrating the
message between the between the clients
when you really have to write a single
line of code to make it work I mean yeah
we can show that in the client code yes
so you can see is doing the connection
is creating the session is creating the
topic consumer
the question is how we can go straight
the number of connections between the
multiple clients and the broker well
we're using if I understand your
question correctly how we can handle
multiple clients through the broker so
back to the an out point if you go back
to that diagram we are going to include
this cipher reference we ended up not
having it so you think about your
connections on the back end versus your
connections that are going out so you
really want to and that out so you can
have a few connections going to your
back end to just communicate with the
server as long as you enter up those and
combine over earlier on in your approach
so then you can have gateways with again
with fewer connections out that have
your front and gateways that are
receiving your thousands of connections
so it's scalable in that sense
to announce service attack is there a
way put a dedication layer yeah great
question the question as it seems SS
susceptible to a denial of service pack
can you put an authentication layer or
in front of it or on top of it and the
it runs with HP you do your HP handshake
beforehand so you can have your
authentication do HP its you can do the
same authentication that you do is sort
of with a TCP connection so yes what
what software is running on the gate
over here we've been using the cuisine
WebSocket the question is what software
we're using on the Gateway it's
basically we using over here causing
WebSocket gateway everything will work
on so it's it turns out it basically it
translates the GMs message from the
broker to the to all the web clients so
it's a it's a breeze between the wave
wall and the enterprise messaging system
so it translates all the JMS answers to
the word socket messes on top of it
it wasn't your isn't running on the
client
that's a good question the question is
what do we use to write the JMS client
running on the child script as well as
the java application so the idea is what
we real what we want to be reason for
the JMS mincing system is like whenever
the vendor whatever vendor implements
the JMS messaging system they will also
provide the native support for all the
client platforms that for the cuisine
WebSocket does over here it it provides
us the JMS gateway and on top of it it
also provides all the client libraries
for iOS Android JavaScript Java and.net
so basically we used those client
platforms to to write a JMS application
on the JavaScript pencil so in this case
cuisine is community using the active
and q's message library to communicate
on this half and then as own libraries
written out for all your specific
clients
simple resume service
yes
yeah absolutely um again you're writing
server-side code there and it's not
writing to the same interface if you're
not running a web application so you can
mix up your web socket verse TCP in this
case and then rest is delayed it's not
as real-time as web socket is oh sorry
to review the question it the question
was can you run a rep you know rest
service in between your client and your
back-end server that sort of translates
your drama so yes that that's sort of
the traditional approach people have
taken to running web applications and to
add to that we identified that load
there's a lot of overhead on HTTP
request response compared to web socket
so basically we're trying to minimize
the bit latency or bandwidth using
WebSocket compared to HTTP requests in
the back
remote sensors in the field there how
mobile payment scale for
40 and if they
usually
web service call
um so Janice is used a great scale on
back in systems today it's been around
oh sorry question is uh if I had
hundreds of thousands or thousands of
sensors out in the field how would the
JMS broker in that case handle your
back-end system so there's a bunch of
different JMS brokers so the kazini
approaches we offer the WebSocket
solution you know to extending that over
the web your back-end brokers are going
to really decide how it skills up in the
JMS nice is eating terms and there's a
bunch of different solutions out there
enterprise based open source space etc
and those I've been used for 20 years a
great scale for different platform
different companies back-end purposes so
it would be a question of choosing the
right message broker for the skill the
you know routing the messages around and
there's citizens out there that have
millions of clients um yes
up in what what is over
as opposed to me
so the question is what is the overhead
compared to the pure HTTP connection and
what is the are there any other web
socket gateways out there somewhere to
this um so in terms of overhead for HP
connection every request response has
eight under to 1500 bytes 800 zone low
end for your HTTP connection you don't
have that on web sockets it's you know
about ten bites and for the second
question other web socket gateways yeah
we've done the benchmarking and compared
against light streamer and other web
socket gateways out there we don't have
the concrete answer to that but yeah
it's a wrap around the message it that's
right yeah about that it's yeah in
addition to the payload based the
wrapper over here you just a 10 bytes or
less than that Jared it's got a few
control fields that are a couple bites
as Cara length yeah just wanted to add
one thing to the scalability there's a
white paper on a kissing website that
you can download that describes a
benchmarking test case where we had 1
million concurrent clients we had a
message size of 512 bytes plus some
protocol overhead so the actual physical
message size was around 600-700 bites we
were sending 10 messages per second to
each and every one of these clients
there was no single connection draft
there was no single message lost and the
average latency to these 1 million
concurrent clients was three-and-a-half
milliseconds that the WebSocket gateway
and the stack was adding on top of giora
to your latency obviously your physical
network latency comes on top of this and
to put that in perspective the server
running in New Jersey i think is 16 or
17 milliseconds away from here just on
the speed of light
he does it's a web socket
so it runs on top of TCP so you should
be receiving it that's guaranteed
connection HTTP just to establish the
connection once our connection is
established it's so on the web socket
that's true i mean two for the
reliability GMS provides a lot of
opportunity to like it said before to to
have achieve the reliable messaging over
the unreliable network right JMS
provides us acknowledgments and
everything over the messages that you
can use to make sure the missus is being
received by the destination party so
these are all I think the custom
protocol approach that can this can be
sold by custom protocols that you use to
maintain the reliable in the messaging
for example jameis provides us that's
what we used over here thank you that's
a great question and a great point is
how do you have reliable messages and
across in a environment where your
network or you to go down at any point
and JMS provides an API to provide that
like reliability
interested in the question that you've
already talked about about how scalable
the gateway is pursued I'm not aware
that Janice providers do lots of things
to support scalability clustered
clustering
stop also public service about extra
service if you want
is the gateway similarly schedule was
this one process yeah as Peter was
saying we've done the benchmarks we
explore the idea of fan-out there's a
couple other scalability things we
support the idea of the fan out that has
talking beforehand so that's the idea
where you can just add another gateway
and you so the fostering yes
when it's not the application so once
you open it on
so the question is what's the overhead
of reestablishing the connection and
also do you recommend always having it
open so few interesting points about
having always having it open there's a
lot of time on your devices especially
for cell phones is we I think we have a
white paper on this too it's the initial
established like creation of the
networking stack that takes the most
battery life out having it open dates
almost nothing so for some devices it's
all right just a bit open and that's not
just because it's WebSocket that's
you're building up your entire network
connection to your soul your sillier
silly uhler towers and rebuilding your
TCP connection on top of that the
overhead on creating the initial
WebSocket connection is a
request-response over HTTP it's a
upgrade header so I'm send a request to
you to upgrade to web sockets you send
it back so it's just two round-trip HP I
think it also depends on the type of
nature of the application you develop
right if the application is constantly
receiving the message and the phone it
makes sense to open up the connections
and if then if the application is idle
for a while or it goes to the background
from the perspective of mobile
application yeah it may make sense to
close the connection reestablish the
connections but like David said there's
not a lot of overhead involved just to
establish the connection
if the connections try call back
preview yeah the question is how robots
the client API is in for the case when
the connection drops and to retry is it
we're able to retry the connection to
try to reach tablish the connection so
yeah I think it depends on the the API
that the vendor provides the kissing a
client API that we use JMS API it does
that for us so whenever the application
drops it retries to establish the
connections and once the connection
established it starts the normal process
of receiving or sending the message and
it is perfectly configurable you can
waltz tablet while writing an
application you can configure that how
many times you want to retry well when
the connection gets dropped until you
want to close the applications or say
that it's purely client base we thought
that is a client base because different
client at different nature different
expectations regarding the retry and and
so we usually have a client-based
configuration for that and with that
respect it's JMS compliant
honorary session so happy
day &amp;amp; Order
single subscription
the question is does this for binary I'm
for hub tapping I'm not familiar with
that over over there tapping so if you
want to remotely send firmware updates
to the device so do you need a single
subscript I think that's more what you'd
write as the application developer for
you know controlling your client this is
a communication platform for it you
could configure it however you want it
if you want a single subscription for
device JMS supports topic so you can
send out general like broadcasting
messages a sort of 1 to N or cues which
is point-to-point so I can say this
specific device needs to turn on does
that answer your question so that is
sort of this point pushing oh yeah the
question is how does this fit into the
MDM space and more on a personalized
local area network so this solves the
challenges with your IP connectivity so
in that sense you sort of need another
gateway at the end there's a demo we're
working on I'm going to pull out the bag
i guess but uh it's to use the zigbee
with the raspberry pi and sort of have
another gateway here oh yeah or
something like that or the client acting
as a gateway we haven't fully thought it
out yet but yeah we can touch our that's
already is you know you bring IP
connectivity as far as you can and then
you go to your local network from there
which support question is what messaging
burgers do you support and yeah right
now we support activemq we haven't
support some enterprise messaging system
such as EMS I think any an amazing
system data jam is compliant should be
easily interval to this kit way rabbitmq
it said religious RabbitMQ amqp we
should we do different protocols amqp
XMPP the short answer is any broker that
supports Jamie specifications should be
easily integrated with this gateway some
brokers are also now adding web sockets
for it directly so we have to add the
scalability in front of that and you
don't want to have necessary your broker
outside of your secure zone that
anything else
this back from the gateway to the you
mean the question is from the gateway to
the jamis broker is it part of this big
yeah the API is the client API is is
part of this pic but the underlying wide
level protocol can be anything so for
now we're using stomp vertical as a wire
level protocol but on top of your the
the the interfaces that application
developer sees is purely JMS spec pissed
yes the question is is there a payload
size limitation there is not but there's
an easy you can easily configure in the
gate where maximum payload size or
anything based on your needs armed force
so the question is does it supports
streaming you you could we could you
could write it like you know write a
streaming application level on top of
your web sockets so you think about
WebSockets bi-directional you can do
your streaming layer on top of that so
using a WebSocket gateway I think you
can support writer on streaming protocol
on top so I think we're running out of
time here thanks for the all your
questions will be around if you want to
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>