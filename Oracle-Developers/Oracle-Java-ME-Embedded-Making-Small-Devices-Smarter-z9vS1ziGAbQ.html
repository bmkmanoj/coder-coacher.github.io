<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Oracle Java ME Embedded: Making Small Devices Smarter | Coder Coacher - Coaching Coders</title><meta content="Oracle Java ME Embedded: Making Small Devices Smarter - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Oracle Java ME Embedded: Making Small Devices Smarter</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/z9vS1ziGAbQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone thank you for taking the
time to sit here and discuss with us I'm
saying discuss because I would really
want it to be a lively discussion
discuss with us on the subject of how
Oracle Java ME embedded is making small
devices more intelligent and smarter and
to that and I really have a smart device
here which I'll demo which was enabled
by Java ME embedded and you will witness
yourself how cool things and how
intelligent applications are making this
device even more useful
so with that I'll get started first
introducing myself and my co-speaker I'm
Reina Milani
I'm a part of the Oracle Java ME
embedded sorry about that press number
one there okay
can you go back to the previous the
title style
thank chica
sorry about the glitch again I'm random
atrani I'm a part of the Oracle Java
product management team responsible for
driving Java embedded product strategy
and here with me I have Shekar
Srinivasan who's the part of the Java
sales consultant team so essentially the
brains behind making Java useful and
valuable before it hits the market so
with that let's dive straight into what
Oracle Java ME embedded is and then as I
mentioned earlier let's walk through one
of the smart devices use cases that we
have here to demo and discuss brainstorm
on what additional value-added
applications we can write to make this
small device that we have which is smart
pen life scribes sky Wi-Fi pen and how
we can make it smarter with these
value-added applications and that's just
one way of showing that this is a smart
device which can be made more
intelligent with some value-added
applications but towards the end what
you want to walk out what we want you to
walk away from this session is with some
thoughts on that next small intelligent
device that you would be enabling and
making smarter so talking about Java ME
embedded which is specifically targeted
for small devices I want to set some
context in general for why Java is
valuable for embedded devices maybe a
lot of you've already heard this you sat
through other sessions where you talked
about it but one thing I want to hold on
and emphasize on is whatever we are
talking about is not new you might have
heard about the value of Java as write
once run anytime platform a virtualized
environment for various platforms and
devices but via emphasizing all of this
is even more important now is because of
the additional value that these features
provide for embedded devices so look at
all these
were highlighted in blue which is a
highly productive environment for
developers or a virtualization
environment which enables writing
applications on different types of
platforms and devices without having to
modify them any market any device any
size which means you have a solution for
any type of device the whole range from
small less than 32 Meg 32 KB memory
devices and very low processing power to
high-end 100 Meg of embedded flash and
very high processing power devices we
have a solution for all of those in the
form of a flavor of Java and a vast
system of the Java developers of which
you and I are all a part of think about
it 9 million people it's like a small
planet in itself it's a small country in
itself so all of this becomes important
look at this picture here for the range
of embedded devices that we have
starting from small sensors to the high
end servers here at the back end enabled
by higher end Intel processors all of
these they can be powered by Java they
can avail of these benefits that we
talked about and with a different
solution a different flavor for these
different categories what I'm going to
be talking specifically about and which
will be the foundation for the sky Wi-Fi
pen is Java ME embedded here in the blue
circle which is our solution for small
to medium embedded devices which
typically have an embedded flash in the
range of 1 Meg to 10 Meg and these are
the kinds of devices which are either
powered by ARM Cortex and three and four
kind of processors or towards the higher
end by 911 based processors as well so
the
commonality across all of these devices
for the most part is their basis on
architecture and that is one of the key
themes around all the reference
implementations and the standards
support that we have through Java ME
embedded so what really is Java ME
embedded and you might have heard
different definitions but one key
message that I would want to drive in
the context in which we are talking is
it's essentially the glue for a
developer between the hardware and his
or her application so look at it as a
gateway for making you're making a
device more intelligent through your
application and how do we enable that
first by providing an application
runtime which actually runs on the
device second by having some reference
implementations or standard binaries
that you can use for your development
environment and if you look at Oracle
technology Network website today you'll
find these reference implementations for
raspberry pi platform for Qualcomm 60 to
70 T chipset for stm32 based development
environment which is on a Kyle f200
board and very soon you'll also see an
implementation for free scale kinetise
70 in other words if you look at the
devices the small devices which are
powered by some popular microcontrollers
or architectures based on arm then you
would see that a broad range of these
could be covered by the reference
implementations that are already
available on our website or would be
available shortly and then we have a set
of free tools in the form of mes DK and
NetBeans
which is what developers could use to
get exactly the same behavior from their
applications on the actual commercial
devices powered by Java ME embedded as
they would see in the development
environment in a nutshell with the tools
the reference binaries and with an
application
one time you are essentially getting a
full platform for writing applications
for small devices and what makes us
think that Java ME embedded is what
should be your target application
platform for small devices and this is
my thinking that I'm trying to give to
you not just to be taken because that's
what Oracle believes in or that's the
message that we are trying to drive but
for you to see the value of what is
being offered in the form of this
runtime environment or the set of tools
or the standards that Java ME embedded
implements so first and foremost in
addition to having a high performance
runtime there is some additional
functionality in the product which is
available to access a wide set of
peripherals and we'll talk about these
peripherals at great lengths you'll also
see some code examples a shaker walks us
through them and this is to say that all
that capability that Hardware has up
until now had inherently in it but we
haven't been able to access because
those devices have not been open can now
be opened up through the Java ME
embedded environment second it offers
you protection against fragmentation you
are not going to be logged in with to a
vendor or if you are a vendor yourselves
look at it as a way for you to enable
developers for a wider set of devices
that you will be offering through an
open standard based implementation and
lastly the tools that I mentioned
earlier Java ME SDK and NetBeans they
enable you to have a complete
environment and make it easy for you to
deploy and debug those applications in a
real production environment here is an
inside out look at Java ME embedded it's
the architecture diagram at a high level
instead of going through each of these
boxes and details which I will have in
the next two slides I want to drive one
message here through the color coding on
this diagram and which is the fact that
the blue boxes here are standard java
api s-- aspect in Java ME which is what
this product implements and the green
boxes here are the unique functionality
such as the device access API or the
access point API we'll talk about each
of these at a greater length but the
idea here is the functionality which the
hardware can leverage through the
surrounding network or for accessing the
peripherals which are connected to it
can be now exposed to developers through
these api's plus interesting thing for
the device manufacturers to note is the
OEM extension API switch is our
framework for plugging in any additional
API is that the OEMs might have to
enable their device specific
functionality or enable their ecosystem
in a specific way then you also need to
pay attention here to the porting layer
that we have which highlights the
modular architecture for the port for
the product and at the same time makes
it possible for us to provide a specific
implementation for one device different
from the other device or platform
without having to make any changes to
the upper stack so while on one hand we
make it easy for developers not to have
to worry about this specific hardware
details on the other hand the develop
the device manufacturers can be assured
that there will be some specific
customization and optimization for their
Hardware environments but at the same
time it will not change the experience
that the developers would be getting one
other thing to keep in mind here what
completes this Java ME embedded
environment is the additional tools and
services which we provide and expect the
OEMs and service providers to complement
by providing any specific functionality
that they would like to expose in their
ecosystems here is a list of the blue
boxes on the previous diagram which is
the
standard Java MEAP ice and this is a way
of saying how we can enable additional
functionality such as messaging or
location or XML processing through
standard API is that the Java ME
developers are used to and that's a way
of saying by listing these different
GSRs here against the functionality that
these api's offer that these are all
based on standard GSRs
next is the list of the oracle unique
functionality that we provide over and
beyond the standard Java ME
implementation and this is unique to
enabling embedded behavior in your
applications and what I mean by saying
that is let me take try to explain it by
an example when embedded devices leave
the factory and hit the market it's very
difficult to control them or to know
where those devices are then we already
know the fact that typical shelf shelf
life for this device could be five to
ten years or it could be even more so
for this longer period of time not
knowing where the device is how it is
being used or having control over the
software and the applications on that
device is essentially saying leaving the
device in the vial and not having any
way of leveraging the data or the
information that that device is capable
of processing Java ME enables that by
providing a complete application
management system through AMS api's that
we saw on the previous diagram and that
is what is available in the form of
lifecycle notifications or application
auto start and restart so this is one of
the key functionalities for Java ME
embedded by allowing remote update
ability and configurability for those
applications one other thing I would
highlight here is the capabilities for
developers which is made available in
the form of memory monitoring Network
monitoring and on-device debugging and
this is particularly important because
when
is writing applications you not really
want to enable a certain type of use
case or a service on the device but you
also want to have an efficient
environment or a way of controlling the
resources such as memory or the
capabilities of the network in that
environment that's what is enabled by
this functionality and with that I would
want us to take a deeper dive into the
device success API so look through each
of those device access API is that I
highlighted look through the code and
provide a foundation for our sky Wi-Fi
pen here so I would have Baker walk
through the various API
thank you are you able to hear me
alright
all right before I get into device
access API I just want to do a quick
count so how many of you have done
anything with device drivers or all the
time okay so I will probably go a little
bit I'll talk a little bit about some of
these devices the I will introduce some
of the hardware aspects before I go into
the api's because in embedded
programming if you don't know what's
going on under the handle the hardware
you can't do much with the software so
they are deeply related to each other so
to start with when we say device access
so what we really mean is what is it
device for the CPU it devices just a
bunch of registers right so there are
three category of registers one is the
control register which the CPU uses to
control the device right to say
something to the device it uses the
control register usually it's a right
one Lee but but sometimes it can also be
read right and then there's the status
register which the status registers are
used by the device to tell to the
external world okay this is my current
status I am sleeping or I am NOT awake
all right you know I'm I'm going to shut
down or whatever right and and then
there's of course the data registers
which is the whole point right you want
to send data back and forth with the
device so you need the data registers so
in order to be able to do anything with
those devices you need some logic to
control the devices the logic that that
controls all these different registers
is the you know the device controller
right and the software that makes all
this possible is really the device
driver so if you want to
built a device driver so you have to be
able to first know the api's that are
actually used to access those registers
so here in the device access API
architecture so we are in going forward
we are going to be here we have this CL
dc-8 based platform so on top of that
that there is this device x-axis API and
the interesting thing here is that we
have introduced this new peripheral
manager API which allows you to develop
code without knowing what kind of device
is going to be opened like for example
if you want to open a device you can do
peripheral manage little dot open and
then at runtime you can actually give
the device the type of the device as a
parameter so when you are developing the
code you are at least a little bit freed
from the hardware decisions so in the
spirit of decoupling hardware and
software decisions right and then so
like you know I'll just move on here
okay
so the device access API so we have I
have listed here all the different types
of access methods that we are supporting
right now but I won't be going through
all of those devices will probably be
going over like general purpose input
output GPIO I to see SPI a to D D to a
and memory mapped and if time permits
I'll do a T command and finally I'll
show a small demo all right so first to
start with the general purpose input
output device as the name suggests it
does not do anything specific to the you
know and it does not have it you know it
the advantage is that you can actually
program it to do anything you want to do
but the disadvantage is that you can't
take advantage of anything that is
specific to what you want to do because
it's general-purpose by definition and
and you can actually group a set of pins
and and and handle it as a port so we
have support for that as well
so it's used in varied applications like
it's it's like in the there's this chip
in your laptop which controls you know
you can use that to amplify your speaker
and you know in programmable logical
device that devices that you would have
guess because it's in anything
programmable logic when you see you
you'll probably see a lot of the
general-purpose GPIO devices being used
there and audio codecs video cards and
in this particular right here okay in
this in this board Raspberry Pi here you
can see that
okay
yes so thank you devices right so here
here we are connecting this pin number
12 to an LED and you can see here there
is there are these three GPIO pins and
there of this these I to see pins we
will be talking about i2c as well and
then these are the SPI pins master out
slave in and master in slave out pins
and then the clock so Raspberry Pi has
support for various different device
access methods and we will be talking in
this example I am showing how to turn on
an LED turning on an LED in embedded
systems is the equivalent of writing a
hello world in in in a in the Java SE
Hall right so so here first you will see
this being repeated throughout the way
you act in order to write anything to do
with embedded devices is first you open
the device and you do something with it
and you close the device right so when
you open the device there are two ways
to open the device you can there are
many more ways but we are going to talk
about two ways which is one is based on
the device ID and then there's the other
way which is the you can use the
interface or the or the type of the
device that you are going to open so the
one that's based on device ID the the
advantage of that is because you
assigned an ID to it and remember this
device ID is is not the hardware ID that
you know like for example here if you
see here the hardware ID here is 12
right 12 and 6 here but the device ID is
independent of the hardware number and
the purpose of that device ID is that
when you do an open again using that ID
you get the access to the same device
especially when you are multiple devices
you want to to target a specific one the
ID will be very useful and the other
thing is that like I said you know the
other one is the the other method is to
use the interface itself which which
tells you like peripheral manager does
not know at when you're developing what
kind of device you are going to be
requiring to open so you can actually
pass the device type as the parameter
like I said earlier and then once you've
opened it so here I want to first tell
you about one characteristics of device
devices are like my son actually the
other day he you know he broke a dish a
chinaware and then I asked him how did
you do it so he ran to the kitchen and
he took another dish and then he put it
down on the floor and then I should have
expected so I should have so when I ask
him a question I know he's going to do
something so I should have been ready
for how he's going to react to it right
so I should have had some kind of
handler I should have maybe walked him
to another room with with has which has
the carpeted floor or you know maybe I
should have told him use words but I
didn't so but unlike my son devices are
more predictable so if you have device
handlers you know the if you have event
handlers or listeners if you have
defined them and you are ready for all
kinds of different responses that the
device is going to give to you then you
have written your driver so that's
really what is the core of writing you
know accessing the device IO ports so
here what I am doing here is we have
written here an input listener so it
listens it's basically it's looking for
any status change remember the status
registers that I was talking about
earlier so it looks for status changes
and in this case the status changes the
switch has been turned on
and then what we do is we get the value
whether it's on or off what what is the
value and then we then get the
peripheral so what do you want to turn
on do you want to turn on the LED okay
it's a LED there's only one lady here
and then you turn it on so and the other
thing here is that in case you try to do
this without opening the device right
then you get peripheral not available
exception or if you do it after closing
the device then you get peripheral or
not available exception or if there is a
loose contact the LED is not connected
properly or the properties that you have
used to open the LED don't match with
the specific LED like ID or whatever
then you get peripheral not found
exception so okay once you have done
your thing you have written your you
know handler then you can close the the
device and then I remember here there
are two devices one is the switch and
there's the LED and then you close the
device so this is really the if you look
at the big picture this is really going
to be repeated in all the devices axis
ApS the one that I will be talking about
next is the memory mapped i/o so memory
mapped i/o and port map IO there are two
types of iOS that you know a little bit
of computer science here you know the
CPU can either you know that you know
there are some CPUs which have to
address spaces one address space for the
memory and then one address space for
the device IO devices and then there are
other CPUs like this one which have
which has you know at one address space
this is a very old CPU but for the
illustration purposes it's much easier
this way so if you look at this there is
a shared address space there is only one
address space and that address space is
used for accessing the device as well as
memory so in this case you know eight
thousand eight zero zero zero two eight
zero ffs is assigned to general purpose
i/o it could be a real-time clock
it could be a timer right and then there
is this 9 0 0 0 2 9 0 F F which which
controls the sound controller and then
when you know the device finds the video
buffered sees that the address bus is
having is pointing to a 0 0 something
between a 0 0 0 and a 7 F F then the
video buffer knows that it's you know
this is the data that's being written is
going to be returned to the video buffer
instead of the memory so the advantage
of you know I will not go into the
advantage of mm IO here but so here what
we are doing is the same thing first we
open the device and then so here I'm
opening in this case I am using the
device type so now the peripheral
manager knows at one time that okay it's
a it's a mm IO device and once we have
done that so we look at the user manual
for the real-time clock and find the
registers like what are the registers
like seconds register there is a second
registers there's a minute register and
there is hours registers so basically
time and current time as well as there
is also this register for alarm
straightforward right and then from the
user manual we also know that the
register has the the length of the
buffer the register is one byte and and
we so we use the raw byte interface to
store that we create a robot object to
store those the values in those
registers and once we get the values in
the registers and then guess what you I
mean you do all the different
calculations and then you set the values
in the alarm register in your real-time
clock right so in this case we are you
know using this set method for the sake
alarm min alarm and then the power alarm
so the rest of it is not seem important
but once you have done that you have
still not turn on turned on the alarm
because you have just said that those
registers
you need to first set the register B
again the user manual says that register
B is responsible for you know alarm
interrupt enabled flag so we have to do
that but before that what we have to do
we have to build this listener and in
this case we are building an M mio event
listener and in that we are looking for
whenever the the the two the two
registers the alarm register and then
the current time register match up then
alarm is going to go off how because we
are going to check the interrupt alarm
flag and then notify the application and
you can either make a sound or you can
send an email do whatever
right so you can implement your own java
application which uses the internal
clock and do interesting things by
actually accessing the the registers in
the in the clock and finally you close
the device so the next access method
that I am going to talk about here is
the i2c or I Squared's the Philips
invented this technology and they used
to call it I squared C but since we
cannot write I squared C in an API so
I'm going to call it i2c and I - C is
it's a synchronized serial communication
method so whenever you see these
synchronized methods you will see this
clock there is this oops
you will see this clock so I - C is the
simplest form of synchronized
communication because it has these two
wires so the more number of wires the
costly is the CPU is so you see in this
case this is like the easiest and the
smallest possible and it's but it's a
little slow because this data wire is
going to handle not only data but also
the address because it can handle
multiple say it slaves so it needs to
know the address of the slave so that
the you know we know which where the
next data bits that are going to be
coming where those
belong where it's going to write it so
and it has some interesting applications
you know it you it's used in eproms and
and digital to analog controllers all
low speed low end stuff and speakers in
this particular case you know here in
this application this master is
controlling this slaves and there is one
slave that's a DAC and there's one ADC
and then one Arduino which is
controlling an LCD display so there are
two types of I to see messages one is
the single message and then the combined
message in some cases most cases single
message should be good enough but if you
have lots of messages they make sense
together or they don't make sense at all
like like transactions if you have then
JDBC programming like any database
programming you are familiar with
transactions right you you know you
either one all the data all the time in
the entire transaction to go through or
you want to rollback something similar
to that
atomic yes so you if you want atomicity
of all the different messages then you
can actually use transactional ApS that
we have introduced in in Java ma for I
to see so how we do that this is the
here's the example
as usual we wait a minute we do the
peripheral manager dot open here and
then here this example shows no it's a
it's a little little is the next step to
hello world right so here you are going
to have an LED that will blink for 1.5
seconds and then you're going to and
then it's going to turn off and then
again turn on this is going to happen
for 10 10 times right so simple slightly
complicated than the what we showed in
GPIO but so first we initialize the LEDs
first we you know after after we open
the device and once we do that then we
right you know we get the you know we do
a slave dot right and then because it is
synchronous we want it to keep it off or
on four thousand five hundred
milliseconds right so the slave both you
know the slave has to be in sync with
the master so if we send this this clock
and then we said we tell what how much
time you know it needs to be on or off
so we do a trade sleep and then the
that's how you know so because it has to
be a synchronous synchronous we want to
we want it to be behave certain way all
the time that thousand five hundred
milliseconds and i2c is a very good
solution because it's a synchronous
method so that's why depending on your
the need of your application you will
need different mechanisms different
access methods so the other thing I was
mentioned the other way of the other
type of messages that I to say hundreds
is combined messages so here in this
case we have this slave dot begin and
then we in this case we are actually I
am showing writing to an EEPROM so how
you are doing that is you first write
the address where you want to write your
data are you or actually you are reading
from an EEPROM so here first we are
writing the address in the register and
then now you want to read the data so
from then the EEPROM knows that I want
to send data from this address and you
know into the data buffer and then once
you have read all the data so in this
case we want it to be transactional like
for example if you are reading a file
you don't want half a file or quarter a
file you want actually to read the
complete file and then you want this
whole thing to happen fully and so you
put it inside the inside the transaction
to make it out of atomic and then you
call slave door 10
and finally you close the device so here
you know we have this transactional we
have introduced this transactional
interface which allows you to do this
begin and end so what happens is that if
you try to do something before doing a
begin then you know it's going to give
you integral state x exception similarly
if you do try to do something after and
it's going to say illegal state
exception so it has to be you know if
you you know if it is an ongoing
transaction so accordingly you have to
handle it
so speaking of spi we have this vid
that's a good segue to move into spi
here spi is another synchronous
communication mechanism but the
difference here is that it is full
duplex mode that and the other big
difference is that you have this clock
this is the snap clock I mean the slave
select pin there's a hardware way to
select the slave what that means is that
because it's full duplex and because the
you're you don't have to be sending any
address in the data you know in the data
pin you don't have to be sending the
address so it makes it much much faster
so this is much faster than the i2c so
here because it is synchronous there
needs to be a clock pin and then mo si
which is the master out slave in pin and
then we have this ISO which is master in
and slave out that that's reading from
the slave and and master out slave in is
writing it into the slave right so this
is implemented as a circularbuffer so
whenever there is a write happening
there is a read happening so that's why
it makes it so fast but then why does it
what does it mean in terms of
programming for that so what we do here
is you know we have this slave dot write
and read and so that you can read and
write at the same
time and then we do the send buffer and
then the receive buffer we give the send
buffer the receive buffer there are also
write only methods and read only methods
but in those cases the you know it
writes dummy in in a read if you just
call slave dot read then it writes dummy
data into the into the send buffer and
vice versa similarly for the read
alright
okay okay so we are almost done here so
analog to digital converters are
actually pretty popular in music records
and you know it basically converts the
continuous signal into a discrete set of
numbers but you as you can guess the way
we handle it is we create an acquisition
listener again and we set the sampling
interval and then we start acquiring the
output from the from the analog to
digital converter the output buffer
whenever it is ready it's going to
trigger an event the event handler is
going to take that take read all the
samples and do an and process it and
what's the length of the buffer what's
the length of the sampling interval
everything is encapsulated in the
acquisition event object and d2 and here
in this case there is another listener
which actually is just listening for
whether a given sample has crossed a
threshold whether you can give it a
minimum and maximum and see whether the
the given sample is within the range so
that's that's the purpose of this
listener so there are two different
types of listeners that can be used and
d2 is the just the opposite of analog
instead of the output buffer we are
going to look at the input buffer and
then we are going to write to the input
buffer and as soon as the input buffer
is empty it triggers an event and you
have already defined your listener here
just like all the previous cases and
then finally the 8e commands 80 commands
are issued to devices data calm data
communication devices that are actually
used
you know those data communication
devices always just keep sending the
data whatever you send it they send them
to the outer world if you want to tell
them to stop okay now I'm not sending
any data for outer world I want you to
do something the way to switch from data
communication mode to command mode is
the eighty command so if so some devices
respond like like I said you know we
have to first
define a response handler command
response handler and and and and and
these devices actually give different
types of responses right some of them
are intermediate code and some of them
are final result code so depending on if
in this case I am sending an SMS so
first I am getting a prompt for the text
and then I am returning the text if the
prompt is okay then that means I am just
you know calling it okay yeah I am done
my job like sent is setting setting the
status to send and if it failed then I
am setting the status to error and
finally I am sending so using the send
command eighty and I have no idea what
this means this is you know if you for a
data communication equipment expert then
you would know very easily but so you
send command using the eighty commands
and do your thing once you have defined
your handlers and with that so how much
time do we have now highlighted the
sense of what shaker was trying to show
through the various Java classes and the
API is that we have have available in
the form of device access API is the
fact that typically embedded devices
have these interfaces which are either
embedded as a part of the device or are
externally attachable and externally
controllable and by having this
functionality exposed as java api s-- we
make it easier for application
developers to access that low-level
functionality bring in applications that
can control external peripherals and by
means of that make a device more
intelligent or have value-added
applications on top of those devices so
here we have an example of sky phi a sky
Wi-Fi pen which is a pen from Livescribe
consider that as just a normal pen
and we added Java ME on top of it
created some application which a shaker
would be demonstrating now and made that
Penn smart so it's essentially a smart
pen which helps you write something read
that information will actually read out
that information to you and will also
store it at the back end in some cloud
so let's take a look at that pen its
specifications what Java ME has enabled
on that and then we will brainstorm a
little on what other things could be
done to make that application more
useful or make that device more
intelligent thank you are you able to
hear me here okay so yeah basically this
pen here is the pen here this is from
Livescribe and it is based on I don't
know if you are able to see this but
it's based on arm9 processor and it has
this cool little LED here but I am sure
you can't see that but I have to be
honest here Java is not being used for
that led it's too simple for Java to be
doing anything here it's just a
text-based LED and but what Java is
being used for in this case is actually
it it's used to for the mobile media API
so that you listen to audio and then the
content handler API as well as the
generic connection framework so the
reason this generic connection framework
has been introduced in this latest
version of this spend you I don't know
how many of you have seen this this pen
before in a prior Java one yeah so a few
of you so the difference here is this it
was you know you can actually in a
secure way you will be able to send all
the whatever notes you are writing you
will be able to send it to the server in
a secure way and the way we are doing it
is using a generic connection framework
so here is your device to the
the centre-right it's basically you have
this internet of things here you have
this thing here and then you can
actually send it to the cloud so it is
we are this is not like we are not just
talking about is you know it's not some
saying this from thin air this is real
and this plane is $200 and you can
actually buy it from Livescribe or you
know from Fry's or anywhere so it's real
so it is it is already in existence and
the idea is here is that I want you to I
want I'm hoping to inspire you to build
the next small thing right just like
Samsung says what's the next big thing
I'm asking you what's the next small
thing wait a minute you want Isaac to
switch to the ELMO alright so let me
first enable recording and then I write
here what's the next small thing right
so you'd see here whatever shaker is
writing it's getting stored in the cloud
real time and this pen is able to read
it back to you
essentially that logic that intelligence
this built in the pen to read that
information store it and make it
available for additional processing
through your applications later on so
I'm going to connect the audio cable to
this so that you can see the mmm API the
Java mmm API in action and then I write
here what's the next small thing right
okay so basically it records whatever we
are talking so the big advantage of this
is that if you are attending like for
example at JavaOne meeting and if you
are meeting like like this session and
if you want to take notes and then you
go home and then you want to see what I
was talking about right at that time in
you know when you are writing that
specific specific word then you just
touch on that word and it's going to say
like like if I say here next the next
click on that that particular portion
and then it takes you there so yeah so
now what what this pen has done is that
once I finished writing once I finished
writing its it has automatically synced
it up to my Evernote account way of
showing that here is this one sentence
of course that could be loads and loads
of data all your meeting notes whatever
you might be processing based on your
team discussion all of that gets logged
somewhere for you not requiring an
external secretary to take that
information down for you so what checker
is trying to do while I'm talking here
is he's trying to pull up his Evernote
account and he had configured for this
data to get stored in that account so
whatever he wrote here you'd be able to
see that being stored in his account
there so that's just a simple way of
showing what all we could do and I'll
talk in a bit about what all our other
possible applications that you can write
on top of this simple functionality
available and make this device more
useful more valuable so not only that
you can actually see a pin cast so it's
not just about your notes
but also it's also about like a pen cast
on the let me say it's to switch back to
the
so let me refresh this so two minutes
ago
and now I can actually see what you know
then I write here
what's the next small thing right
anyway so the bottom line is that I
wrote it I don't need this book anymore
I have it in the cloud so wherever I go
I can if I when were not Evernote
account in my iPad or my iPhone or
Android phone I can actually access it
so that's and and all the data transfer
is secure so that's the cool thing about
this and and we and we are using the
slides this functionality to capture the
data to transfer it securely over the
network and store it in the backend
cloud was what was enabled by Java ME
running on this device the small version
of Java that we've been talking about
which makes small devices more
intelligent so here for this transfer of
data in a secure way we are using HTTP
which is basically using there can
generate connection framework which is
part of Java I mean this is an older
version of Java ME but but genuine
connection framework still exists in you
know it's the same like you can look at
it like like device access API this is
like a network access API or connection
I know
API so you have all the this connection
interface and depending on the type of
connection we have all this different
data gram connection input connection
output connection and and then this
stream connection which is both for
input as well as output because both are
streamed and then this content
connection which can do something
intelligent with the content which can
look at like for example in HTTP
connection you look at the header file
and then you do interesting things right
something intelligent you instead of
just reading the input stream so here we
are just opening HTTP connection and we
are opening the data input stream so and
because it is HTTP so it expects a
certificate a valid certificate
otherwise otherwise it's going to throw
in a certificate exception like for
example if you did not pay your bills to
thought or very
then you probably you know you have an
expired certificate and/or an expired
route C then you will get that
certificate exception and assuming you
didn't get certificate exception then
you actually are okay
supposed to be slideshow okay all right
but anyway so here we are looking at
reading the header file and then we are
actually doing a gate length of the
length and then using the length we are
reading the entire file if you don't
have the header information like in an
input stream then you can actually read
character by character and then you
finally close the connection so this is
a very simple example of using the
connection generate connection framework
but Livescribe does something more than
that of course and we are not actually
showing the actual Livescribe code
because of because it's proprietary
software from Livescribe so thanks
shaker and I want to leave you with some
thoughts here as what other applications
you can build on top of what we just
demoed and this is just feeding in some
thoughts so that when you walk out of
the room you already start thinking
about other small devices and what other
kinds of applications you can write to
make them more valuable we talked about
all the functionality which is available
at your disposal today you have the
binaries and you have the
implementations available on OTN you are
just read get ready to get started it's
about you feeling from inside what's
that next small thing and here is just
one possible scenario if you're looking
of looking at enabling real-time team
collaboration consider an environment
where people may be just like we are
here in the room trying to collaborate
on the same project and with the
convenience of actually having a pen in
your hand you want to write all of that
information get whatever information you
are writing be stored somewhere
in a collaboration document or a set of
documents you have somebody to resolve
the conflicts and merge the information
that different people are contributing
to this application that I'm proposing
call it a team collaboration up
application which can actually read
information from all these different
sources or your data which your
Livescribe pens are gathering and be
able to present all of that merged and
conflict resolved data for further
consuming and processing by this team
that's one example and let's take a look
at another example if you can relate to
this picture here it's a picture of
filters so what I'm trying to say here
is if you already have some data and you
want to do filtering on that data let's
say you want to eliminate some text or
eliminate some code from a piece of code
which is already there in your back-end
server and without having to actually
open that set of code you want to
eliminate that information you can
provide an application with the logic to
read the information that you write
strike it out so the application that
you write it has the semantics
associated that strike-out data has to
be removed from the information that has
to be processed so suppose you write
Java 2003 2013 next year you can use
remove erase the 2013 and 2014 yeah so
right now in 2013 strike it out whatever
information you might have stored it
will remove all Java 1 2013 related
information from there and if you write
another statement there say Java 1 2013
arrow 2014 which is kind of an
indication to this application that 2013
has to be replaced by 2014 it will get
your documents ready for you to start
working on when you collect information
from Java 2014 so in other words similar
to the functionality that you have
available in word processor
you can have that available in the form
of this application which enables this
application this data processing through
the data written through your Wi-Fi pen
rather than from reading it from some
document or some piece of code that you
might have stored on your laptop or you
might have had to key-in so in other
words in a nutshell this is having the
convenience of a pen and at the same
time having in all the intelligence from
the word processors and additional
software which makes your life easy on a
computer so best of both worlds as I see
it and with that I would end here with
what all is possible what all
functionality is available at your
disposal I want you to get started get
thinking about how you could do and
revolutionize this small embedded
devices space and we are out of time but
I'm happy to stay back and answer any
questions that anybody might have any
questions space yes
yes we yes yes that's that's a very good
question
yeah so we have a solution for that I
don't know if Evernote is using their
solution or not the we have databases
right we have this advanced security
option in an Oracle database so if you
store your information in Oracle
database we have complete encryption
option enable
so when you are when you are reading
from the database if you have when you
are when you are giving your user ID and
password and and and it's based on your
credentials you are going to be able to
decrypt it it's going to do it for you
the database is available for you to
access but rest of the world will not be
able to make any sense out of it because
it's all encrypted so that on the server
side we have much much very very robust
and very well established encryption
technologies on the on the what's new
here is on the embedded side we have
this we have ways to send data in in an
encrypted way in a secure way so that's
what is new on the server side it has
been there for some time now
but I don't know if Evernote is using
their technology that's that's you know
that's that's an Evernote question but
yeah but but the technology does exist
Evernote Java ME Java ME comes with
generic connection framework which
enables the secure transfer of data UT
yes yes it's HTTP I assume that that's
what makes it encrypted so
yes it is no longer encrypted if that
database is not encrypted it does not
have any encryption but if the database
has that that encryption enabled then it
is an encrypted if I could answer it
differently the problem that you're
talking about the information securing
in the back end or in the cloud that
problem has existed and that's not the
problem that we are really trying to
address by enabling communication of
data via Java as far as communication
from the device to the backend is
concerned we can ensure through the
functionality that we have in Java ME
embedded that it's transferred secure
securely however at the backend whatever
solutions exist today we would still
have to rely on those thank you any
other questions on Java ME or we have
the this is your chance because we have
the developers of Java I mean the
architects and engineers everybody is
here so this is it good yeah
the question is why is blu-ray all
blu-rays away why are all blu-ray
devices running Java that the reason is
that the blu-ray spec mandates that the
the blu-ray implementations be based on
Java the reason its mandates the blu-ray
implementation be based on Java there
are many reasons one of them is that you
get you know it makes it device agnostic
so the competition is it's even playing
field for all the vendors Java is a big
big equalizer right so you want to and
we are set out to do the same thing in
Java ME also now with the device access
api's all the devices will be accessed
in the same way you know using or using
java so and that's the reason why we got
into the that's one of the big reason
there are other reasons too but so this
was a modest answer that blu-ray
specification requires Java to be
present on the devices a less modest
answer is because Java offers the the
value for blu-ray players it makes open
standards available on the blu-ray
players and essentially provides that
common environment for developers to
write applications which can run
seamlessly on those devices it's all the
benefits that Java offers for embedded
devices is what requires or what has
gotten the blu-ray Association to
mandate Java on those devices yeah you
have a question there
the reason why it's 100% Java is not
because they just mandated they they
mandated it for a reason because of all
the benefits that Java brings it makes
the industry much more even and you know
and yeah we can talk about it offline
you had a question
Aimee API is for Apple devices so when
you are saying Apple devices you are
referring to iPad or Apple TV or iPod we
don't but if we have Java any
implementation available for iOS then it
would essentially be the same API is
that we talked about that are available
on other platforms and currently we
don't have making Java ME available on
iOS there could be a Java SE
implementation for iOS but there is no
public record yet for that and and and
when you ask the question API is
available API so are the same API is
right so it's not dependent on the
platform the api's are going to be the
same it's the underlying implementation
that that we are talking about so yeah
and then Reno answered that question so
anything else yes go ahead
okay the question is is there a way any
means to protect the bytecode when it's
the device from being reverse engineered
that's a good question no I would look
at the architects here to confirm sign
the bundle that's the answer yeah it's I
would say equally applicable to any
other executable as to bytecode it's not
unique to bytecode even say if it's a
normal dot exe for a C program it would
still run into the same issues
yeah that so that's always this question
of security by obscurity right so see
you know you get the security by
obscurity we don't believe in that we
believe in security by security I mean
we provide ways to digitally sign your
your byte code and keep it secure but
good question I don't know if we have an
answer to you I mean you are you I'm
sorry we have special technique to
convert your application together with
all the libraries in JVM into one binary
bundle so there will be no explicit byte
codes or references will be resolved and
there were no symbolic names of any kind
whatsoever no it's it's clear it's a
call authorization
correct and they have session today
later yan good good I think good
questions okay so with that I would hope
that we were successful in fueling some
thoughts around what applications you
can build for small devices going
forward thank you very much
we look what Singh</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>