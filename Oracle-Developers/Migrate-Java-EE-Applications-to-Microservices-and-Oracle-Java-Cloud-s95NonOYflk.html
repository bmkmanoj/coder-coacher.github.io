<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Migrate Java EE Applications to Microservices and Oracle Java Cloud | Coder Coacher - Coaching Coders</title><meta content="Migrate Java EE Applications to Microservices and Oracle Java Cloud - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Migrate Java EE Applications to Microservices and Oracle Java Cloud</b></h2><h5 class="post__date">2016-09-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/s95NonOYflk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay hello can we hear each other okay
so hi good day welcome to today's
session here the title is my great Java
EE applications - microservices and of
course the Oracle Java cloud
my name is stealin fog and I'll I'll be
your speaker today for this session my
colleague Matthias Jewish is sadly
absent he was not feeling too well today
so I will be alone for today okay I
think we all seen that this year
microservices is a big topic although
Java 1 there'll be many session on it
this is also one of them so let's see
what we will cover today our goals for
today what I want to tell you and what I
want you to learn with me is basically
the first thing is how to decompose
partially or not partially existing
applications into micro-services the
focus here is basically on existing
applications that either your company
your enterprise or some other company
has and not so much on creating new
applications because in today's world
more or less we have a lot of
applications and perhaps want to bring
them into the future to modernize them
to make them into java micro services of
course one of the side effects of doing
that is that we can improve scalability
of such applications right sometimes
monolithic and older applications are
hard to scale hard to deploy and such so
we we want to improve that and we want
to see how all of that applies to
existing Java EE technologies
applications we will see technology by
technology how we can decompose them
split them up and then put them back
together into a cohesive microservices
that you can then deploy alongside or
completely replace your existing apps
and at the end we will show how to
package the applications the micro
services using the community framework
of which I am one of the developers as
well as deploy them to the Oracle cloud
both specifically new Oracle Java a
container cloud that they've
okay so today's agenda first I will go
over some common architecture
microservice patterns so we can see what
we are going to talk about you're gonna
repeat some basic stuff that you
probably heard but they are important to
to know then I'm going to continue with
guidelines for decomposing and
refactoring existing Java applications
we will see through an example how we
can how we can do that how we can start
and of course continue later on and I'm
gonna talk a little bit about
interpretive interoperability what that
means is that we can it's highly
unlikely that we'll be able to it will
be able to decompose an entire existing
application into microservices and
deploy it at once we will see how we can
use something in between we can use
partially with an application partial
application server and partially put
these micro services and see how in the
Java world both of them can play
together of course with the help of
cumulus EE and as well as other
technologies and at the end we will look
at the deployment with the darker into
the Oracle cloud mostly we will just
talk about docker and we'll show on a
practical example how we can deploy for
the Oracle cloud okay so what are micro
services in a sentence or two we can
just say the marker services are small
apps that comprise a bigger app and are
communicating via uniform defined
interfaces so we have a big app with
split into smaller apps each smaller app
has a data control dedicated
functionalities and either expose some
sort of services we are a unified
interface let's arrest or soap and then
they communicate and do work together
what does this mean exactly using micro
services we can decomposition decompose
applications into smaller parts so they
can easily be that can be more easily
managed we can develop them
independently we have we grade the
independent building blocks that can be
developed by different teams and it can
be deployed updated and managed
separately without each dependent on
each other they are narrowly focused
that means that the functionality that
they provide is basically just one
narrowly focused functionality they
don't comprise everything so for
instance you'll see an example later it
could be just maybe a booking service or
a maybe a catalog service something like
that and of course with a communicate
via well-defined interfaces that are
easily manageable for instance rest or
soap are both protocols that work over
HTTP that we can easily manage with load
balancers and all the other technologies
exist today and either said we have
independent life cycles for all of the
service for all of the services which
means that we are not if you want to
update one part of the app we're not
dependent on the rest of the app to
update it we can just do it basically
right and we can then faster and
gradually improve our applications as we
go so why would we use micro services I
already mentioned this so we can then
have independent and automated
deployment of the services they are not
depending on each other because the
owner they all run in their independent
runtime and are not tightly coupled
together this enables us to have simpler
and faster updates which means that we
can improve one part of the app without
waiting for another part of the app to
complete this is especially important if
our applications are bigger if you have
bigger development teams and so on
perhaps the third one is more most
important is that there's less of a
dependency hell maybe what this means is
that each app or rather each micro
service has their own dependencies that
sometimes might collide with other parts
of the application because these apps
are independent and separate we may not
have such a problem where we if we
update one put one dependency from one
part of the app it will interfere with
another part of the app and start
working that means that maybe we have to
delay everything and fix everything it
could take a lot of time and effort to
fix
of course simplified scalability you
probably already know this this means
that you can when you separate your app
into certain micro services each app can
be deployed and scaled independently
which means if one particular part of
our app is under more pressure under
more stress we can just scale that one
easily with today's cloud even with
Oracle cloud you will see today we can
do that quite easily we just increase
the instance count update the load
balancer and we have many more instances
for our micro service to work on and
thus improving our responsiveness and
and performance of our application where
it's needed it's not with raise
resources for for instance if we want to
if we don't need to scale a particular
part of the app which has very little
traffic and of course they are ready for
the cloud they were built for the cloud
the cloud is very flexible scalable and
many small services are much more fit
than one big one that we need to handle
carefully ok and I want to point out one
particular important one is that we have
no using micro services we are not
committed long term to any single stack
what this means is that we can perhaps
use I've put some examples up here for
instance we can use one part of it the
app can be built in Java v6 for instance
we have a little dab that pin the Java
a6 and when we start to build a new part
we can build it in Java 7
independently of what our other part
uses the same can be said for man Java
it will arrive and if for instance our
he is not the right perhaps the right
frame up for a job for the job we can
use for instance Spring Framework or any
other Java framework or basically any
other framework on any other language
that you can find because all the micro
services communicate we are well defined
higher-level interfaces for instance
arrests so which means HTTP interfaces
it doesn't matter what the underlying
technology is they all understand the
same language of course that also means
for perhaps lower-level technologies one
micro service can use Java version 6
maybe one can use Java version 8 and one
can be on the beta of Java version
because they need a particular feature
and as well we have a choice with
different perhaps different romantic
implementations of I put some examples
for instance Eclipse Lync or hibernate
maybe one works better than the other
for us or for instance rest is your
Jersey maybe one has a feature the other
dozen that we would like to use we can
pick and choose basically what we need
at one particular point in our
application
all right so let me give you a short
example so let's assume that we are
building an online store this is perhaps
a most common example but it's also the
easiest one to understand everything
typically a Java EE application would
look like this we would have an
application server this isn't
particularly matter which one and we
will deploy wer or ER app which would
look something like this it would have a
perhaps a three main parts let's say we
have a catalog part that we can browser
articles we have our cart and payment
part that we can add our products cart
and then of course paid them the payment
processor and we have the delivery part
which can as a delivery these parts are
using various Java EE technologies and
are communicating via database and a
messaging queue this is all deployed on
a single on a single application server
so perhaps here we can see immediately
what could be the problem like most of
the time our catalog part would be under
much more stress and much more traffic
than our payment or even delivery path
since it's normal that all people browse
not many people buy so if you want to
scale that part because it doesn't meet
our meet the demand we have to scale the
entire application and because we are
using an application server sometimes it
can be a hassle to do it quickly or
dynamically depending on your needs and
also we're going to waste resources
because we have to scale the cart and
payment part and the deliver part also
we have to take care of the messaging
queue system and the database so make
sure we don't introduce any problems
there so if I recap
one of application is they're called
they are easier to manage and deploy but
if the app is big enough it can become
intermittent to developers it can be
hard to developer hull for new
developers to to get into the to the
project scaling can be difficult like I
managed it's hard to partially scale an
application and of course continuous
deployment can be also difficult it's
hard to update for instance the catalog
part of the app when perhaps something
is worked on the the other parts of the
payment parts and the delivery part we
have to perhaps way to synchronize
everything up and there are of course
other drawbacks and also features of
this approach so if you switch to the
micro service approach we can decompose
application make it look something like
this so we removed we split the app into
four parts for micro services let's say
we split up the catalog the carton
payment in the delivery and the UI you
can see here how and then all of them
will expose some sort of services where
the rest are soap and will communicate
with each other like this so we will
like and also you can see that the
message queue is now outside the
application server because we can expect
that each micro service can be scaled up
so there can be many instances and all
need to access the same messaging server
and the users would then access the UI
through the catalog card payment
delivery and will access the app this a
lot so we've seen what would look like
with micro services what the features
will bring us there also of course some
drawbacks the complexity of our system
will increase we have two energies each
service separately well that is a good
thing most of the time it can be more it
can take a lot more effort to do if we
have multiple databases we need to
manage that we need to correctly
management States the caches of our
local over micro services the
transaction boundaries are reduced we
can no longer run a single transaction
between all the between all our micro
service or rather it's much harder to do
so we will see a later in example how
maybe address that and of course we need
a lot more donations we have separate
micro services maybe separate teams a
lot more coordination is needed for
everything to work as expected and this
is somehow and this is a image of what
it could look like for instance our
catalog is under heavy traffic we can
increase the instance count by three
four five instances got impaired
mentally less only less instances and a
delivery is the least at least traffic
and we can keep it at a single instance
this is especially important when we
deploy application for instance in the
cloud because we pay for every resource
that we use so smart management of
instances and resources is a crucial
thing in today's application so the
micro service up architecture is
basically it's perfect
or rather it's easy to build new modern
java application so your company and we
start to build a new application we can
take the micro service architecture we
can become start to think about it
before we start building it we can
decompose it ahead separate it as needed
to create the teams as needed and then
start building and then we have we got a
basically single picture like it like we
should show there you get an
architecture look something like that
and it will work maybe a little bit more
complex it complex but it will work and
that's ok but the main problem in today
is application there's a lot of legacy
or rather a lot of existing application
that exists in enterprises or companies
and so on and that is kind of the
problem that needs to be addressed or
how we don't know maybe how to tackle
that problem so how about existing Java
applications how do we do how do we
apply the micro service patterns there
do we start all over again do we
complete or do we completely throw away
everything we have usually that's hard
to do so we would like some sort of
gradual you know migration slow
migration to be able to move our java ee
existing application monolith
applications
service into a micro service
architecture or perhaps we could do
further development of the application
with the macro micro service
architecture and make sure they coexist
between each other
they play well with each other they work
well with each other so the question
becomes how can we migrate
yeah
okay so if I understand correctly a
question for a period you have one part
of an application that is weights yeah
okay
in that case probably would put that
part in a in that case it's hard to if
you feel if all the other microservice
are dependent from another microservice
right to do it to do its job I guess in
that case it would be you could separate
that right so you could put that that
Microsoft is separate so whatever that
thing does does not affect does not
affect what others what other part of
system does if that micro service has
the job it has to do some time before
it's available unless you can you know
change how it works so it works faster I
guess their architecture itself maybe
can help as much what it can help is
with if you have a lot of parallel
parallel requests or perhaps if the job
that is working can be done in parallel
or if you have many multiple jobs like
that then you can easily use it you can
package it in a micro service scale it
up it will work more of it at the same
time so the earth so the other parts can
be also faster let's say that's an
example right hopefully okay so how can
we migrate the monoliths into micro
service and most of the time I would
like to do it step by step by that I
mean we don't want to you know let's see
now we're gonna start migrating
application and do an Margaret our
entire application at once first of all
that would take a lot of time a lot of
effort a lot of opportunity for new bugs
and problems to arise so we would like
to do it step by step
so let's look at how we would do it I'm
gonna go through one of the most common
technologies that are using the a wave
java application and i'm gonna look at
the consumer technology how and how a
micro-service would affect existing
applications how they work so these are
these are usually one of the more common
up common technologies that you can find
today in a full-blown java applications
for instance you have GPA JDBC for
database access and then on top of that
you have eg bees that have the contained
business logic see the eyes see the eyes
that may contain a logic on the front
end and then you have of course JSP and
JSF that will show or views the front
end and of course for services we might
have a ji x RS and you xws technology to
use soap and rest web web services as
well as for background jobs or you know
all running or long-running operations
we usually use JMS together with message
driven beans so we're going to discuss
these technologies and how each of them
will be affected so if I put this in a
picture how would the typical typical
application look so we can see that this
is for instance an application server
and usually you have something like this
you have of course a database which is
usually the core with all the data
resides and usually the core and then
you have a GPA model through the GPA
model you access the database and then
and do all the operation on it if you go
further we have a lot of eg B's that
continually are business logic in the
container transaction logic and all the
important stuff that needs to happen
that our application is doing usually
most of the time this eg B's contain
perhaps a little bit low level or low
level operations so we wrapped the eg
B's ugb low-level operations into more
eg beasts which are usually called us
facade eg B's all they do is they call
the relevant low-level agb's to complete
the task correctly manage a transaction
between them and so on
this is about the business logic of
course some operations are long-running
or you want to do the math synchronously
we can use JMS and here we have m DB so
message even bins to handle to handle
them which are then run in the
background that duplication server takes
care of that and for a front-end if you
use our java technologies either is GSB
or JSF together with CDI that then call
our eg B's either locally or remotely
depends how I have it configured and of
course some functionalities may or may
not be exposed via web services where
are there soap or rest using the
technologies the ws or Aris technologies
so this is what this is what the common
common stack would look like so let's go
through one technology one by one
so for GPA what would require to do to
make it micro services well actually for
the GPA concretely not much really
the components can remain more or less
untouched each micro service will
contain a copy of the GPA classes of the
GPA logic that will connect to the
database that means that each micro
service will connect to the database
separately or maintain its own pool it's
all data source it's all connection pool
and will manage its connections in
crates and all of that separately from
the asset this means we can we can make
sure that the micro service is in
complete control of its outside
connections but we have to be careful
for certain things for instance we may
we may rely on a cache an application
server that is shared among all or more
among all bins we have to be careful
here because micro service is more or
less will not share cache unless you of
course take care of that for instance by
introducing an external cache for
instance red this is a popular external
cache that is used today either way
generally speaking whatever persistence
services that are available in either an
application server or somewhere else we
have to put it somewhere outside
external and then all our micro services
which are more or less stateless will
connect to them and use them so for the
GPA is not so much of a problem we have
it we just include it to have a micro
service
and that's more or less okay then we
have JMS or messaging beats here it
becomes a little bit of problem because
usually that our application server will
include a JMS server which will then
hold our message and distribute into our
message even beam
the problem here is that we no longer
have one application server that
contains everything we have micro
servers that are spread out and can be
in X number of instances 5 10 100 even
if needed so what needs to happen is we
need to connect we need to add an
external messaging queue whether it be
rabbiting q horn Tim Q or any of the
other that are either supported through
JMS or maybe not it's so completely
optional we put it outside and then we
make sure our MVPs connect to our
external to our external messaging queue
instead of our internal the an
application server will provide so
basically this is the difference this is
the work we have to do on this concrete
technology to make sure they are ready
for micro services and of course usually
what happens is MDBs they contain our
background jobs are a lot longer than
operation they run separate micro
services which can then be scaled on
demand which means they are not together
packaged and run with our for instance
our logic that contains our web app web
app that does something on the website
but it runs in the background where
where they listen on the queue and if we
have a background running job for
instance a simple example sending emails
we can easily scale them once we see
that our messaging queue is starting to
there are a lot of messages we can just
make more the instances and the old tech
message is faster and process no faster
and once the queue gets empty we can
that just scale back down this is one of
the benefits or for instance
externalizing our our background jobs
using MD MD bees and of course on
external messaging queue a more
interesting topic would be what to do
with eg bees now
ugb is usually regarded it has big
dependencies with big overhead a lot of
people use them and it's cool
basically corrected they use them but
perhaps in some cases in the micro
service in a micro service they are not
needed usually we will have CDI beam or
CDI technology included in a micro
service one way or another so perhaps
most of the time I would say that both
the egb and the CDI implementations and
dependencies are not needed to run I
both can be available but they basically
make them they bloat up your micro
services makes it results slower and it
has a larger footprint on our system
resources so what can we do well we can
look at what CDI contains we can find it
most of the functionalities that we use
with the juice can be replicated with
CDI not all of them of course and if we
have such use case where we need a
specific technology functionality from
eg B's we of course use them and
continue to use them but for most of the
cases we don't need to we don't need to
so our business logic looks something
like this we have a lot of eg B's we try
like we set at the beginning try to
split them up into narrow it into narrow
functionalities so it would look
something like this let's say we
indentified we can speed application in
two separate functionalities it would
look something like this our eg B's in
this case I would say that I've turned
them in to see the eyes we can of course
keep them into a GB so if you want to
this is just an example we separated
them so what happens in this case if we
separate it if we separate at the agb's
the we didn't want micro-services all
communication between the different bins
remains local of course if you either
use CDI or agb's both remain local using
local interfaces like like they did
before transaction transactions are
still container managed Java is seven
introduced container mentions action for
CDI and so we can use that as well if we
need to any fusion egb
so we already have that by default
however what has changed is that our
transaction boundaries are reduced they
are reduced to a single microservices
which means we can no longer or rather
at least not simply have a transaction
that will span basically all of the
functionality it is usually contained
within one micro service so you can run
one transaction rollback commit and so
on but once we go out of it which means
want to make a call or a request to a
different micro service it is no longer
the same transaction and we have to
account for that
this may mean some change in code it may
not mean some change of code it
completely depends on the case but this
is something we have to make take into
account when we are refactoring our app
that the transactions are affected by
this but for most of the time because we
are if we split this correctly into you
know narrowly focused functionalities
such problem big problems around this
should not arise but of course it's
possible and what we do is we replace
our remote calls that were perhaps
present with with promoted you because
we want to replace it with the
higher-level technology for instance
Jack JX w s or s so we use HTTP soap or
s to communicate between between all of
them there of course some technologists
that Cydia does not have for instances
one is the synchronous execution of
functions and methods we can replace
that with with messaging queue which
means we put we put a synchronous task
into a message in queue and then a
background micro service will pick it up
and complete it so we don't rely because
we may have many instances of a
particular micro service we don't want
to rely on that since it may die at any
time that if it's running something
important in itself and also scheduling
is also one of them it also should be
done scheduling is a particularly
problematic thing because if you have
many instances it's hard to keep a
single source of a schedule this is
usually done by putting all the
schedules outside introducing
on microservice it takes care of the
schedules and then dispatches on on
whatever we have scheduled dispatches
tasks to the message include through
which other micro services pick up the
work and do their work
oh and I forgot about a synchronous
communication should be coming to CDI in
Java 8 if I remember correctly right now
they have the interfaces but it's not a
synchronous yet so this is about agb's
they are perhaps the most complex things
to work around sometimes it's smart to
maybe keep them sometimes it'll be
better to move them to see the eyes to
simplify to simplify our work ok if you
continue we will get to the gix SS and
RS they are continuing the same is the
word they continue to expose the
business logic we may need to add some
because depends how much we had before
ideally all business logic or most of it
that we need is exposed through one of
these two services depends what you need
both both are ok and both work well and
of course the idea is to replace all
remote calls with with this with this -
for better interval interoperability
between you know Java apps or maybe some
external third-party apps or any kind of
help basically and of course flexibility
because HTTP is easily routable
load-balanced and managed instead of
just a pure TCP connection that I
perhaps remote eg because relies on so
increase the number of restaurants web
services to expose all our all our
business logic as for Jay Jay SP and JSF
I will have to show two examples of how
to migrate one example is to take the UI
JSF views and the CDI beans into its own
micro service packaging together they
are kept together and work together as
well we package into its own micro
service and basically just serves the
views we replace all the local or remote
calls that we had from the CDI the eg
B's with either soap or rest calls
because we've now separated our
microservices and they're exposed they
are exposing HTTP services so we want to
we want to change that into soap and
into into one of these two if you are
using remote calls more or less the
migration to soap calls is pretty simple
especially in code you just need to
replace basically derp you inject a
remote interface where you inject a
basically a soap interface it should be
basically run the same another way would
be to take away the CDI the logic in CDI
bins away and expose them via more or
less red services we use Jack's a JX RS
for that we expose our logic we
packaging together with our business
logic because perhaps there is no need
for this to live in a separate
microservices and then we use either we
use html5 in JavaScript to build perhaps
one of the single page applications a
more modern application that are now
popular and growing to build a new UI
that will then call our rest services to
get the data it needs this is perhaps a
more harder migration to do but it's
there and it's available and can be done
as well so if we put all that Hodges
together but to mention them right now
we get a picture like this
so we have our database on the right and
our external messaging you on the right
that we had before to that we connect
our two micro services that we
identified below each of them contain
the same GPA model each of them contain
Dissidia means that you transform the
relevancy that means that they need they
have of course and all of that is
exposed with jax-ws or eros services
which are which is then consumed by a
front-end which is either in JSP or JSF
using Cydia beans to connect to the web
services or in the other case APIs that
we showed we can use an html5 or
JavaScript application to connect to the
same to the same web services that we
developed right so how about people in
yeah yeah when we switch from for
instance remote calls we don't have
anything on the same server right again
right yeah the latency mostly and for
instance the latency and the overhead
with it or the rest or soap will
increase but that is basically the trade
we take for so we gain the other
abilities and features for micro
services for instance the main one is
the ability to easily scale we might be
okay with a little bit longer latencies
but at least so that way we can ensure
that our application will keep working
if we get to a certain stress or traffic
or so on perhaps a second perhaps so
perhaps it wouldn't be perhaps a couple
of milliseconds of added latency won't
be noticeable but if our app starts
working because of our added traffic it
could become a problem so that is a
trade-off that we take in this
particular case but yes as I said we
have to take make sure that our network
is not slow in this case
yeah
yeah
yeah yeah basically that's also also the
tools that you use to deploy them you
should you should be updated because if
you do everything by hand it can become
quite problematic as we will see this is
what the cloud platforms complain
yes this is what a good question we do I
will not show today but definitely for
service discovery and for URLs and where
everything is okay that you should use
the service registry because otherwise
okay if we have to Microsoft it's not
that much of a problem you have to arise
but if you have many it can become
chiropractic to manage them all so yes
we can use zookeeper is a popular one
that is used and that is a good one
where you can publish all the micro
services and all the element micro
services can get the data they need or
the locations they need from the service
registry without even restarting
application etc
yes about the database I guess it would
completely depend on the data and hand
if it makes sense and if you can clearly
separate the data you should separate it
into separate database especially the
data is a different kind of types
perhaps one one type of data would
require no it's no secret database one
card with record relational database if
the data is very intertwined and very
connected like in religion relational
database maybe it doesn't make sense to
separate it all that much that
completely depends on the use case the
database is independent in the sense
that it scaled that you manage it
independently and scale it appropriately
you need to also make sure the database
is scaled appropriately so that that is
not your point of failure
yeah this is also one of the points I
wanted to address this is deemed
interoperability between micro services
and also application service I will talk
about that education specifically right
after this okay no question I will
continue so this is my next topic that
was mentioned is how do these things
work together how do these micro
services end as well as normal
applications work together so what are
the common problems that we face I can
list four of them which are perhaps the
most important the first one is cost
authentication and authorization so how
do we share how do we share our
dedication with the micro services how
is that involve how does this work and
how that ideally work also we're going
to this is specifically geared toward if
we have an observer in micro services
what happens to JMS how can they both
work together and as well as data
sources some how would we connect to the
database if I address authentication
authorization specifically the cleanest
solution for this would be to move our
dedication one layer up into one of
these one of these technologies either
use sa ml of to or Open ID connect this
authentication protocols work together
with an authentication server which is
our trusted server that handles all our
users and then any issues either xml
requests or tokens and such that our
micro services trust and are then and
these tokens are then passed alongside
requests on our micro services verify
this allows us to perhaps log in once to
the dedication server and then carry our
session which is our token basically
between all micro services and all
applications on our application server
and all of them will basically have the
same authentication data the user will
be logged in and we can do security
based on that now of course sometimes we
don't we are not using one of these new
technologies we are just using plain
maybe LDAP or
some SQL a sequel education in that case
we can then of course plug each micro
service into an LDAP server or a sequel
server what and it will work more or
less what we lose there is basically the
ability to do basically single sign-on
we'd have to make sure we are signed on
or we have to pass credential around all
our services so they can authenticate
we're choosing one of these we can
eliminate that and make sure that we we
use a single set of single session let's
say between all or our micro services
and of course all our applications on
the app server as well this is basically
the end goal that we would like to get
which one use it's up up to preference
perhaps or to our open idea more geared
toward rest services and saml is more
geared toward sub services where we have
extensions for okay and as far as JMS
and data sources go we can either do one
or two things we can either continue to
use the applications built in queue and
data source and then we make sure all
our micro services connected to it that
could work
alternatively and perhaps a little bit
more future proof an efficient be to use
an external cue provider also a little
bit more work make sure queue is outside
and make sure our applications either an
application server or in Microsoft's all
both connect to the to the external
queue as well as all contain their own
data data sources and connection pools
and so on this is just an example what
kind of problems and solutions we are
looking for for interpret
interoperability okay so let me continue
so okay we have our micro services and
of course we want to package them
configure them deploy them energy and
scale them this will show an example
with using our cumulative framework as
well as the Oracle Java cloud a brief
description of what human is e is it's
basically microphone use the standard GV
a PS in standard Java EE
implementations to run all the Java
applications it is completely model
which means you can pick and choose what
you want to include this is where the
point I was making where we can either
include both the CDI or a GP
implementations comes in hand you can
include both you can include neither of
them you can load each one the lighter
the microservice the smallest is smaller
footprint will have the more resource
the less resources will use and the
better will run and of course waste less
resources it can support these
immigration of exists implications and
they are packed into independent jars so
they all in India is see to run which is
what will show on the Oracle cloud we
will just run it as a normal job
application this is basically the
standard of micro service frameworks
right now we just we just run a jar this
is for an example of sizes these are
just basically if you just need servlet
it's very small on put five megabytes
because it's the implementation so small
and when we add implementations we'd see
the I being validation GPS so on we
start to increase our size but still
it's not smaller than perhaps in our
full-blown application server or all the
entire Java stack because in most cases
in most cases we only the few
technologies for instance if we have
rest services maybe see the eyes maybe
GPA we don't need all the other the
other stuff for that particular task as
I said the framework is completely
dependency driven you include the
dependencies you want you use the
standard Java API and basically you just
run it this is how it looks like you use
maven or let's say maybe in this case
you clean packages when you add
dependencies you clean it you package it
and then you can either do one or two
things you can either run it directly
like this basically run the main class
of the of the frame of the frame could
then automatically detect what
dependencies are present configure them
set them up find the application and run
it as well this is how basically the
work for grows and of course it's fast
first-class support for docker
containers
basically it's adopted it's a standard
Java ser app that you can use that you
can package into basically package and
run anywhere which means on docker or on
any cloud platform that you can find
today from Google to Oracle to Amazon as
well as private clouds OpenStack VMware
basically can deploy it anywhere and
this is basically one of the the goals
that you want to achieve with Microsoft
with Java micro services okay I will now
show specifically we will see how this
looks on the Oracle cloud platform how
easily basically you can deploy an app
like this and I will basically show this
right now okay
all right so this is how it looks like
this is the this is the basically the
Oracle the Oracle cloud platform what we
will use is will we use the Oracle
application container cloud this is the
service that allows us to upload our app
basically either a source code or our
compiled code and it will automatically
run basically like a platform as a
service like perhaps your Roku or some
similar services the cloud has many has
many features we can of coke we could
use the any other but I think this is
the appropriate method and this is how
we will deploy micro services in the in
the Oracle cloud I have prepared three
micro services here that we will deploy
just to see how the thing works I will
switch briefly to the code to show you
how this looks like basically the micro
services like this similar to the
shopping cart we have a website that we
can book train tickets we like this we
split up basically on a micro service
right here that that will show and
display the routes that are available
and then a micro services that will be
that we use for booking the routes that
are available here as well as a UI micro
service that will display your idea is
very simple just it'll just show
basically what is in the database but
this is just for an example this is for
instance also how we would an example of
how it would look like to develop and
maintain a few micro services you would
have them in separate modules each
separate modules would have for instance
if you go to the routes will have its
own will have its own application for
the in discrete instance we have a Jo x
RS application that is a simple crew
that accrued resource that will return
save and delete the routes that we have
I will not go through the coded detail
because we also have time thread but
just so you know this is standard Java
EE that you that you used you can deploy
an application server audit you can
deploy in a micro service like this
if you go to the bookings the same thing
basically just for the for the other
resource and of course and the UI
contains a JSF basically a JSF app that
will that will call this micro services
through through the rest through a rest
client to this any straight data okay so
this is how it looks like we will now I
will now deploy this into the Oracle
cloud how we do this very simply these
are the micro service up here are just
for now are just examples so for
instance if I open this one it will show
a it will show an example web page that
deploys when you create a micro service
so we will now override this okay I will
switch here basically so if you remember
correctly which community all we have to
do is basically clean and package this
is all it takes to become partisan
application builds it if you want to run
it locally we could we could run
basically the Java command and then run
our application like we said for
instance like this and you see how fast
it basically ran it took maybe a less
than a second okay I will stop this and
I will now basically deploy to the
Oracle cloud how does this look for
instance we will first deploy the routes
micro service if you click on it we can
see under deployments we can upload a
new deployment so we will do this for
every micro have all the few micro
services that we have what will do is we
will upload an application archive we
have many many choices on how to update
but we will use this one since maybe it
is the simplest simplest one we use
every micro services will have a
manifest or JSON file that will show
Intel Oracle cloud how to deploy how to
run and deploy this application so for
instance it says which version of Java
we need for instance 8 and then the
command that needs to run when we deploy
our application and some other for
instance metadata that can be shown ok
so right now what we have to do
it's create a zip archive off of all our
basically all our micro-services right
now we're in the routes so we create a
zip archive for our routes
I will also create the zip zip archive
of our bookings
like this and then so we zip out our
entire application and of course our UI
like this so I created a Pakistan
entirely of all the micro servicing I'll
just deploy one by one so now we're at
roots if I go one back into roots I can
just upload the zip basically and this
is all it takes
we could automate this via the REST API
that New Yorker cloud provides but this
is just to show we take a nap we zip it
up
and we then upload it to the Oracle
cloud once it will upload it will
process it and it will be it will deploy
it immediately you can see it's all the
processing they upload it may take a
while because internet I don't know how
the Internet is I hope it is go ok there
is this concrete example is not using
application server it's using the human
loose-leaf framework which runs from
which is which runs the required
technologists from with java SE this is
the this is what this service is all
about you could use it for instance to
deploy wildfly swarm you can use well
transform to deploy it or you could
deploy it with the drop wizard or other
similar framework like this on on this
service if you want to use an
application service the Oracle cloud
provides web logic manage their logic
service that you can use to deploy
typical ER or w AR applications okay so
this is miss it uploaded I need to apply
it and it will deploy
I will take the URL and basically I will
put it into it I will just call the rest
service so into wait a second it's
deploying the release basically what it
does is that it just runs the it runs
the command that we specified we can
then see of course our memory usage our
CPU such N if needed we can of course
scale the application accordingly or the
cloud support scaling you can then
increase distance cut you can see here
you have a number of instances how much
memory since have and so on you could
automate this as well but for the
purpose of this were just a little
oculus ok
yep
yeah as well you can you can yeah you
can see now the memory usage increased a
little bit because of it was redeployed
you can monitor everything and you can
also set up notifications yes I believe
so so if an instance dies one way or
another it will then restart it
somewhere started so if we specify three
instances it'll try to keep three
instances running as well alternative we
could automate it so if we monitor our
memory usage and then increase our
instance can dynamically between let's
say our memory such as CPU usage or some
other metric that we want to you want to
use okay so I think this is deployed and
we can see basically the before it was a
nap now I have already insert into
database it also runs in the Oracle
cloud two entries and so basically this
is it this is how simple and easy it is
and fast basically to deploy it to
deploy a micro service we could do this
for the rest of it too but I think we're
running a little bit out of time it is
the same process basically we zip it up
upload it up it will deploy it and that
is that basically and of course we could
automate this using the REST API that
the Oracle cloud provides okay
thank you for listening if you have any
questions please ask now</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>