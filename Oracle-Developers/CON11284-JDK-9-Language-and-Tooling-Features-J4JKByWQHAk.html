<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON11284   JDK 9 Language and Tooling Features | Coder Coacher - Coaching Coders</title><meta content="CON11284   JDK 9 Language and Tooling Features - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON11284   JDK 9 Language and Tooling Features</b></h2><h5 class="post__date">2015-12-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/J4JKByWQHAk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello thank you for coming here today my
name is Joe Darcy i'll be speaking with
my colleague vicente romero about JT
canine language and tooling features but
first an important but first an
important words from Oracle's lawyers to
let you know how to calibrate how
seriously to take what we say here today
quick survey of the audience first which
jdk train are you using in production
ginny canine early access with jigsaw no
one ok how about JD canine early access
itself has anyone downloaded the early
access bits oh good maybe a few hands
maybe fuel fuel download it later in the
week jdk 8 good to see strong adoption
there people still on seven ok six few
hands five something earlier than five
you'll admit to all right a few hands
there ok maybe you'll be inspired to
upgrade to the later releases after this
talk so quick overview of JD k9j decade
nine is currently scheduled to ship next
fall there are early access builds and
docks available weekly currently there's
a separate set of builds available for
early access a quick note i forgot to
mention on the last slide there'll be a
URL to download the PDF and also be
tweeting and link to that jdk nine is
being developed under the auspices of
OpenJDK so if you're interested in
following along along the way there are
mailing lists issue trackers and the
like you can refer to there's also a
adoption group to encourage people and
share experiences using the new release
finally I'll be mentioning the word JEP
several times during the rest of the
talk JEP is a jdk enhancement proposal
and it's a set of documents were using
to manage developing ichigen JDK and
dupe needs you to help us deliver the
best jdk nine we can and one way to do
that is to download these early access
binaries try them out in your
environment and give us feedback how
they're going what works well and what
doesn't work
as you've probably seen already else
we're here at javaone either at the
keynote or some of the modularity talks
have been going on modularity is the
main feature in jdk 9 that does affect
the language area as well there is a new
module info file to declare modules and
what a module is is a bundling of
packages together in a unit that has
stronger encapsulation than jar files
and this is true both at compile time
with java sea as well as a runtime with
the java command itself so there are
changes to the language to support this
there's a new kind of source file module
info to support declaring those
dependencies and that gets fed into
going to compile Java C and Java Sea has
new command line options to support
modularity as well as finding types from
modules as well as from jars so for much
more information about that there's
already been a number of modularity
talks at javaone yesterday some of those
are being repeated and I encourage you
to consider tending them as for the rest
of this talk I'll be covering a number
of user facing changes that are coming
in jdk 9 and Vicente will cover some
deep engineering done in the Java C
compiler called tiered attribution and
finally if we have time off some Q&amp;amp;A at
the end so the first feature i'll be
talking about is j shell in the list
world for many decades the primary way
you interacted with this system is
through repple a read evaluate print
loop you'd have a command prompt where
you typed in your programs or fractions
of your programs and then they'd run and
you get feedback from them now this is a
common feature in languages it's also
seen in environments like Ruby and
Python as well as on JVM languages like
closure Scala and in groovy so what
about Java Java didn't really have a rep
whoa until recently but this is
something we're adding now in jdk nine
with the j shell command this will be in
the next build after java one so this
this friday or early next week and there
are a few advantages here if you're a
new student and you're coming new to
java there's a lot less ceremony you
don't have to start out with public
static void main
to print out hello world but it's not
just for beginners it offers a lot of
convenience to experienced developers to
it's a more informal way you can explore
a new API or new language changes and
we've been very happy with experiences
we've had using it on the jdk team so
far terms in the implementation it
leverages a lot of existing work in the
line tool space from things like the
compiler API as well as debugging api's
already in the platform and if you're
interested in this robert field the lead
engineer for jay shell is giving a talk
on this topic tomorrow morning in a much
more depth but in the meantime we'll do
a quick teaser demo here of jay she'll
just swapping the video cable
this is a new command in the bit so just
start that up and you can start out
getting some help it won't print very
well here with the font size this big
but you can get going that way so we can
do something simple like type a low
world and it evaluates that so we don't
have to go through all that public
static void main there's also ways to
declare new variables for your
environment so let's say we want a cow
variable that's equal to
and then we have autocomplete so we can
j shell can analyze what fields and
types are available and you guys
autocomplete for them there so this is
just a quick sampling what j shell can
do and if you're interested in a sign
courage you to attend Roberts talk
tomorrow morning
next up is a set of changes were making
in Java doc first is supporting html5
javadoc for many years has been
outputting HTML for dot one last year
html5 with standardized as a new version
of the HTML standard has a various
improvements new semantic structure new
attributes you can opt into this today
using the bash html5 output to Java doc
it's still out the output still looks
the same the main displays still the
three panels but it's done in html5
appropriate way how many people have run
into dockland and JDK 8 okay that's good
yes much stricter checking than before
if you haven't seen it dockland provides
various kinds of structural and semantic
checks on javadoc ranging from
syntactical problems in the javadoc
itself to semantic errors such as having
an Etsy or at link to a member that
doesn't exist you can configure the set
of checks dockland does in your behalf
and the checks it does of HTML are
appropriate to the HTML output version
you're using dockland works in both Java
doc in Java Sea and we use a mixture of
both in the JDK build to get it kind of
extra coverage is with Java doc output
where you can specify you on the public
protected or private you can have the
same for the document checking so you
can say only check the public types or
only check the public and protected
types and so forth the checks can be
enabled or disabled per category using
command line options as shown here and
finally something new we added in jdk 9
was packaged filtering so for instance
for the jdk build we essentially only
check that the dockland properties for
the java and java x packages and that's
now supported on command line for both
commands are there any doclet writers in
the audience this is a very old plug-in
technology used to write plugins for the
Javadoc command
the doclet API is not up to what we
would call current best practices in
particular the language model uses is a
bit inaccurate and hard to evolve with
the benefit of hindsight we've been able
to create a more accurate in easier to
evolve language models such as in Java X
line model done for annotation
processing so we're reimplemented the
center doclet to use this new foundation
that takes advantage of these other AP
is we've added to the platform so
overall the API is simpler and more
compact if you're using doclets Javadoc
search this is a feature coming soon to
a jetty canine build perhaps later this
year by default there will be a search
box in the Javadoc output and this will
index over packages types as well as
members and let you find things you'll
also be able to have index tags if you
want to declare separate terms to show
up in the index and we'll have a quick
demo of that as well ok this is the
search box so if we type math see that
finds the math package as well as types
like Java like math and members with
math in their name and a quick example
if you've done some floating-point work
you may have heard of Alps unit in the
last place this is a technical term
there's a method and there's also a null
term defined and if we scroll up a
little bit we can see it's highlighted
there in red so you can you can create
those kind of search terms and this is a
client client site only you don't need a
server to do this
because up is a cross compiling with the
dash release flag so Java sea's long
been a cross compiler you could use it
to compile two older versions of the
platform and it's long been documented
in the Java Sea man page and various
plugs that there were three things you
needed to do when you cross compiled you
have to set the source version you
wanted the target version and finally
the boot classpath information say the
RT dr. jar from the early release the
policy we have now for supporting
releases is one plus three back so in
jdk nine for instance that means we're
supporting nine as well as eight and
seven we also support six but if you use
six it's a warning because it's going to
be removed in 10 and so 10 will support
7 through 10 and so forth so why does
the boot classpath need to be set well
let's say in jdk n we had a library that
had a foo method it took a double and in
jdk n plus 1 we add another method foo
an overload that took an integer and
let's stipulate that the food method
takes an engine is just an optimization
it semantically equivalent just goes a
little faster so this is a perfectly
compatible evolution of the library from
jdk n to n plus 1 so let's look at a
client library some client code that
would use this library and it has a foo
method that has an integer argument so
if you compile this on jdk n plus 1
which foo method is going to choose it's
going to choose the foo method that
takes an integer because that's the more
specific of the two foo methods so let's
say we take that class file that's been
resolved to use the food take an integer
and we run it against JDK n what's going
to happen well it's going to happen in
something like this we have this no such
method error which basically says that
it's looking for the food that takes an
integer and it's not there and because
it's not in that's correct because it is
in fact not there so this is the basic
reason why the boot class path has to be
set so we've gotten reports from
customers that they've run into the sort
of problem and we figure ok jdk 7 will
help them out in this case will audit
warning to remind them to set the boot
classpath when this occurs so that did
help a bit but we
still saw reports of people running into
this issue so for JT k9 we thought you
know what why we just solved the root
problem which is to allow people to
cross compile to the older release
including the library information and
that's exactly what the dash release
flag and JDK nine does semantically it's
equivalent to setting source target and
the boot class path to the older release
so the type information from the older
releases is now available to the
compiler so it's part of the JDK in a
compressed format and as another feature
this it only includes the api's you're
supposed to be calling so it includes
the java SE AAP eyes that are
standardized as well as the exported api
is that are part of the JDK and it
supports the same set of source and
target values as the other options so
there are a few Vantage's of this you
don't have to manage this own artifact
like where'd you download the RTR from
jdk 7 that's probably not in maven
central is anyone here using animal
sniffer animal sniffer is a few hands
and almost difference of make it maven
plugin that checks to make sure you're
not calling the api's from the older JJ
decays if you're doing this kind of
cross compiler situation you shouldn't
have to do that anymore because the
information is built right into Java Sea
finally running using JDK 9 say as a jdk
8 compiler you get advantages of the bug
fixes and potentially performance
improvements that have occurred in 9 as
compared to the other releases so the
next group of features we were talking
about is milling project coin the term
milling as applied to coins refers to
putting those little edges around the
outside of the coin and the reason those
edges are put there is to prevent
debasing the currency people shaving
down the edges save of silver coin and
and selling not separately so it's
something done to preserve the value of
the coin over time and that's also what
we're trying to do with milling project
coin to preserve the value of the coin
language changes we initially did in jdk
7 as a refresher these are the these are
the five features part of project we and
jdk 7 and three of them have little
amendments in milling project queen
jdk 9 these are the million project coin
features three of three of the five are
actually related to project coin two of
them are from a project lambda both
projects coin in project lambda and jdk
7 and 8 had a bit of a unfinished work
they wanted to didn't have time for in
the lease so we're taking care of both
of those with this one feature in 9 so
looking at these in turn the first
feature we talk about is safe our args
and private instance methods so if you
were very diligent about your warnings
in jdk 5 and 6 and you use code that
called arrays.aslist you may have run
across this sort of imposing error
warning unchecked unchecked generic
array creation for varargs so this
sounds all very ominous this morning is
mandated by the language and it is
appropriate in the sense that it's
possible something called heat pollution
could occur so you could end up getting
a classcastexception at runtime when you
have heat pollution now in this case
nothing bad actually happens this is
part of the core libraries it's safe
it's well-behaved so the error is
uninformative this is basically a false
positive so false positive warnings
aren't good so in project when jdk 7 we
added some work to get rid of them that
came in two pieces first we added a
java.lang safe varargs annotation to let
the compiler know that this for our
methods actually safe and well behaved
you shouldn't give warnings about it and
we add that annotation as appropriate to
the core libraries methods that use
varargs like a raised edge list and with
these two changes together it meant that
all the users of these core libraries
like arrays.aslist didn't get these
uninformative warnings anymore now
because of some details of the design of
annotations you can't apply safe our
args to any sort of method has to be a
varargs method for one of course but you
can only apply it to methods that can't
be overridden so what are some kinds of
methods that can't be overridden first
constructors from a vm point of view
constructors are a special sort of
static method and you can't override
static methods then we have regular
static methods
you can't override final methods and
lasted you can also cannot override
private message and we didn't include
private methods in the set of methods
you could put say varargs in seven but
now we're changing that in jdk nine this
was an extremely small language change
this was the extent of the specification
change we had to do so nice and small
but most of the other changes we have to
deal with are more complicated than this
the next change was effectively final
variables and try earth resources just
to give a little refresher on the tribe
earth resources statement you start with
try you have a parenthesis list of
resources you want to manage where
resource is something you can call
clothes on and the semantics are java
sea or your other compiler will take
care of causing clothes for you so you
write code like this on the left hand
side and internally the compiler
translates it into something like this
where there's a finally block with the
clothes method called now it's actually
a bit more complicated in this because
of exception handling in terms of full
disclosure this is actually what the
Java Sea generates on your behalf this
looks a little complicated but you don't
have to worry about this because the
compiler takes care of this for you so
what are the structures are the
resources you need to be managed at the
end of jdk 7 you had to declare a fresh
variable to manage the resources a new
variable associated with the tribe earth
resources statement originally you could
do that but we also let you pass in a
general expression of the right type
auto closable that would let you call
close however when we allow a general
expression to be passed in we ran into
this little problem let's say you have a
resource are and you allocate a new
object for it to point to resource one
you pass our into your try with
resources statement and it's a variable
and you decide you're going to change
what object two points to you allocate a
new resource object now you come to the
end of the try three sources block and
close has to be called so which object
or object has closed called on it well
we decided to not worry about this
problem like basically any answer you
have would be unfortunate in some way so
we just
we're going to avoid this problem and
not allow you to pass in an expression
in this case but we thought about Mitt
that was a little too strict let's say
you already have a final variable that's
pointing to resource why do you have to
declare a new final variable with the
tribe earth resources statement when you
already have a final variable so what
we're doing JT canine is loosening this
up a bit if you already have a final
variable or an effectively final
variable an effectively final variable
is one you could declare final and have
the program pilot would use haven't done
that yet so that's counts to basically a
programming on modifying then you could
pass that kind of variable into the
tribe earth resources statement and
since it's already final or effectively
final you're avoiding the problem of
changing which object the resource
points to so this is an example that
previously you'd have to write this code
on the top we allocate our 2 and 0 now
you don't have to do that you can just
reuse are initially so a little bit
cleaner in the code what is the language
specification change look for that we
are changing the grammar of the language
so there is an update there so this is
the grammar for the resources for the
five three sources statement and now
besides having to declare a variable you
can accept an existing expression of
various kinds this paragraph describes
the semantics of the change and the
syntax even is a little more complicated
than you might expect because it doesn't
just support passing an existing final
variable that say a local variable or a
parameter you can pass in any sort of
final variable so let's say you do
something like you allocate a new object
and that object happens have a final
field in it you can pass that in so the
feature operates or orthogonal e with
any sort of final variable you might
have next we'll be talking about diamond
and anonymous inner classes now diamonds
are created inside the earth under great
heat and high pressure and we do have to
go down a little bit down the rabbit
hole to see why this features needed how
it works but i think the payoff is worth
while so here's a little reminder with
diamond using a box type you could think
of box as a simplified collection class
so it's just a generic class that you
put things in and get things out we have
a little sample code with a list of ?
and we want to pass that in to the
constructor which takes a box and using
diamond we don't have to fill in the
type arguments ourselves so what's
happening here though is the compiler
Java Sea has to infer this type on your
behalf Java is still explicitly to is
still statically typed it's just not
always explicitly typed sometimes the
compiler can fill in type for you
implicitly through a process called type
inference so that's good so let's take a
more detailed look about what happens
here so the compiler cracks open the
diamond and in this case it infers the
type and that type is list of captures ?
so that sounds a little a little
imposing so what's going on here inside
the compiler something called captured
conversion goes on if you're interested
there is a JLS section that describes
this I will warn you though that it is
one of the parts of the JLS where it's
good to have a type theory book on the
side to help see what's going on but
bait the basic operations are pretty
straightforward to understand inside the
compiler the wild-card is converted into
a fresh type variable that then the
compiler can manage so it kind of
reduces it to something else now what we
see here is an example of something
that's fairly common in programming
languages where the type system inside
the compiler is richer than the type
system you can write out as a programmer
yourself and in those cases where the
compiler uses a type that you can't
write yourself that's called an onda
notable type okay so now we have a box
class the compiler seems to infer the
types for us even if they're complicated
things like wild cards and captures so
that seems great one of the other ways
we can use a class is to make an
anonymous subclasses of it if it's a a
protected if a public class so let's see
what happens when we do that here we go
to use an anonymous subclass and it
turns out this nonde notable type is
going to be problematic for us so what
happens when the compiler compiles the
anonymous class that turns into a full
class file on the side and as a class
file that
it has to have all the class file
attributes so if we look at say box
dollar one that would be generated for
this anonymous subclass in the
classifier representation it says it's a
subclass of box of and it has to fill
the box in and the right answer in this
case is list of capture of ? that nan de
notable type that Java Sea inferred now
the problem is there's a signature
attribute in the class file to store
this information and the signature
attribute does not cover nan de notable
types it only covers the types you can
write yourself so this is a problem now
for using dymond in anonymous classes so
just to overview what happened here way
back in jdk wanda when we had inner
classes JDK five we added generics and
in jdk 7 we went to add diamond and
diamond with inner classes works fine by
itself diamond with generics works fine
but then when we try to combine the
three together we have fangs show up now
if you haven't seen Fang before this is
Duke's evil twin brother so right here
he's a threatening to ruin project coin
with some battery acid and so as Brian
gets like likes to say this was a case
where today's problems with the jdk 7
problems were caused by solutions done
in the past RJC came j ck team actually
found this bad interaction and we were
we were not happy when they did this but
when we vented with this issue at the
point in the release we were at we felt
the only option we had was just forbid
using diamondden anonymous classes
because of the possibility of this bad
outcome but we were a little
disappointed with that and the expert
group for the jsr noted well you know if
the type that's inferred is actually de
notable if it's one of these ones you
can fit in the singer attribute maybe in
a future release will let you have
diamond in anonymous classes together
when this bad interaction doesn't
actually occur and that's exactly what
we're doing now in jdk nine when you
don't have this bad interaction you can
use diamond in anonymous classes
together to see what the specification
updates that looks like this is how you
say not you can only use the notable
types in the JLS so luckily we have
special
tation engineers who specialize in this
and there's a second slide here which
talks about some of the other semantics
changes one thing we were surprised by
when we added this feature is that for
better usability we actually have the
compiler implicitly put an override on
all the methods in the anonymous inner
class this is so you're not surprised
too that you're not overriding the
method you think you are and if you
don't want this behavior the workaround
is very simple you can just explicitly
add the type arguments to you're not
amiss in your class so back in jdk 5 we
did some measurements and we found that
diamonds let you get rid of about ninety
percent of the explicit type arguments
for constructors and we're hopeful that
these adjustments we're making jdk nine
will let you get cover most of that
remaining ten percent we've had good
experiences using this feature in the
jdk codebase we got rid of several
hundred more cases converted 700 more
cases to use diamond including many
using security libraries the next
feature we're talking about is one of
the pieces from project lambda that is
underscore is no longer a legal
identifier name this is something we
started in jdk 8 with lambdas you can't
have a parameter name of underscore to
one of the methods on a lambda this was
done for a number of reasons including
to avoid confusion with the wonder bar
feature of other languages like Scala
where it mean it means something else
you can still use underscores a
separator and in jdk 8 you got a warning
from the compiler to note that you can
use underscore today but you might not
be able to do with tomorrow and indeed
we followed through with this you can no
longer use a single underscore as an
identifier in jdk nine so why are we
doing this isn't what we usually do we
think we can make better use of
underscore for possible future language
changes some possibilities maybe you
could have partial dymond so you know
one type argument but you want the
compiler to infer the second one for you
another thing is possible is a partial
type witness or maybe we can use it as
some kind of name that specifies please
don't apply things like the you know
warnings about unused variables or
something something like that
we think that will be more useful than
just having used that single single
character named the final party million
project coin is private interface
methods this is something else starting
with lambda in eight one of the main
features of lambda Nate actually dealt
with interfaces where you could add
default methods to an interface a
default method is a more like a regular
method that it has code in it even
though it lives inside of an interface
and then it gets inherited in in a
sensible way now to implement this at a
vm level it was convenient and necessary
to allow interfaces to have private
methods however those private methods
weren't exposed at the language level
and now and jdk nine they are so you can
declare both static private methods in
interfaces as well as private instance
methods and the way you'd use them is
this helper methods for writing your
defaults the next language change i'll
describe talks about deprecation and
imports so the JDK is a large code base
that's been around for many years
several decades now and like many code
bases it has accumulated a bit of
technical debt so this is a graph of the
Java Sea lint warnings we've had in the
JDK code base at different points in
time so you can see it's a veritable
Technicolor layer cake of technical debt
now we have had some efforts to improve
this over time in turn some efforts
we've had an open JDK and toward the end
of JDK 8 once entire categories of
warnings were resolved we started
turning those warnings on in the build
category by category and so between JK 9
build 5 which is there where this graph
ends and jdk 9 build 47 Winship earlier
this year we went down from about 5,000
warnings to I'm happy to say zero we
have zero lint warnings today in the jdk
repository so this covers a open code
generated code you know all the code
that's in there and as I mentioned we
have this as a fatal build warning now
in terms of what modules this covers
this includes the base module so that
has fundamental packages like Java lying
util and
earth it also covers the desktop module
which houses a TBT in the swing we like
to set a good example on the Java Sea
team so we make sure that our modules
are free of the warnings on our own
compiler and as full disclosure this
effort has not yet expanded to a corba
ABT or and excuse me jack korba jax-ws
or jacks p so people often talk about
technical debt but i think you could
also view the results of a project like
this is earning technical dividends
because now there are whole categories
of problems we don't have to worry about
anymore as developers because Java sea's
already taking care of them for us and
some of these are fairly important if
you're interested I wrote a blog entry
describing our experiences here if you
want to try this sort of effort on your
own code base so down at the very bottom
of that that layer cake was several
hundred recalcitrant deprecation
warnings so we had to get rid of those
two as part of this effort and you get a
deprecation morning when you use a
deprecated class or type in another part
of the code and there's a few ways you
can resolve the deprecation warnings one
way is you can make the type using the
deprecated element deprecated itself now
this is in a very good solution because
you usually want to reduce the amount of
deprecated code rather than increase it
so that this was not the approach we
used in the JDK another thing you can do
is to stop using the deprecated item
this is a good option we did this as
well however in many cases because of
API compatibility you have to keep using
the deprecated type so you can't always
get just get rid of the deprecated items
so the final option is suppress the
warning this tells the compiler yes i
know it's deprecated i have to do it
please don't tell me about it and that
was part of the facilities added for
annotations in jdk 5 so let's see what
that might look like we have on one side
the deprecated library we have some code
which uses it we run the compiler the
compiler tells us yes you are using some
deprecated types so we want to suppress
the warning so we go off and apply the
annotation right at the top of the class
so it covers all the code we run the
compiler again and what happens we stall
deprecation warnings
hmm it seems a bit odd so if we ask the
compiler for more information it turns
out what's going on is it's giving a
warning for importing the deprecated
type now this is actually required by
the JLS so the compiler is is correct in
this case now you might say alright well
we'll just apply a suppress warnings
annotation in the import statement you
can't do that that's not valid
syntactically so you don't really have
many good options at this point you
could do something like change all uses
of the type to its fully qualified name
we wouldn't have to use the import but
that's kind of silly if you if you can
say it's okay to use the type why is
that why is it problematic to import it
it's a little little unnecessary so we
decided we should change the language
back in this taste to not require a
deprecation winning on an import
statement and that's what this extra
clause here looks like and with this
change is now traffic will to clear a
code base at deprecation warnings and
the JDK code bases the existence proof
of that and if you're interested more
about deprecation matters dr. deprecated
ER will be giving a entire talk about
that tomorrow and with that I'll now
turn the talk over to my colleague of a
Sunday well thank you very much for
introduction and for these the first
part of the of the presentation so sorry
so now we'll be talking about
retribution and what's the attribution
why we decided to do it and were they
the main abs be behind this change in
the compiler know so first let's see a
very simplified representation of the AC
compiler we have I mean they we can
divide it in three main areas or face is
not so the parson interface is the first
one then the they analyze face and
finally we have the generate phase now
type attribution is part of the analyze
phase as we can see here in more detail
we have the analyze phase have forming
areas which are type attribution name
resolution or lower solution and type
inference also they are interrelated
between them and well type attribution
what's type attribution the main
responsibility of tied up attribution is
to assign a type to which element of a
foreign language now so for example in
this case we have an example with my so
decoration we have binary expressions
and we have method goals it's eternal so
for example for the first pressure and
the compiler I mean how to deter mined
at i plus K is of type int and like it
can be assigned to 2k no and for the
second suppression for example is very
simple he has to the compare has flute
reminder is a boolean there is a common
thing about these expressions now I mean
they're the type can be determined but I
not know so if you see this pression you
can determine the type now but they are
more than that no I mean sometimes
languages and need to to introduce
operations that depend on day on the
context now on the targets and in Java 8
a lot of those operations were
introducing language and they were not
called Paul expressions now so this is a
I mean not all expressions are the same
so for first analog expressions as we
are saying you can see especially you
can determine the type no problem with
that that's pretty simple but
sorry so but in the case of pol
expressions you we can we can see that
for example a diamond creation
suppression depending on the target it
can be an array of strings or an array
of integers so the compiler has to
figure out exactly what you want to do
now okay so this is the list of four
expressions in in Java but in this
presentation will be focusing on diamond
creation inspiration and land
expressions so I type inference is
another very important part of the
rating with type checking now so dealing
with Paul expressions depend on having a
very strong type inference now so in
eight we made real changes I mean big
change to type inference before it was
like very aggressive and not considering
all constraints or possible constraints
from the context and from from the given
expressions and we realize that in order
to implement lambdas and another police
press we needed to to add more more
power to to type inference so type
inference can be somehow be mapped to
linear programming so linear programming
is one of the most complex algorithms of
the last century no so let's suppose we
have a system of variables and we have
constrained some X on Y and we want to
find the solution and we can even add a
lot more constraints ready to for
example that relates the both bios and
we want to find totem eyes a function
the suppose is 2 times 2 times 0
x + y know so is there only one solution
is there more than one if how can i
determine determine that why what is the
best solution so this is a kind of
problems that type inference absolutely
in with no and of course there is a
mapping between linear probing and type
inference because we have subtype
relations we have equal types and
relations somehow we create these set of
constraints and and the Language Center
mind that determines that there is only
one solution and this is sometimes there
is no solution that's also another
outcome of the of the problem so let's
start with a very simple our expression
this is the diamond creation expression
and here we have the very simple class
and we have these creations Persian and
we have to find out what type that we
have to instantiate you too in order for
this expression to be applicable so
initially we can get some constraints we
can get a constraint from the
Declaration of you as you has no
restrictions we can infer that you has
to be as any other reference type in
Java it has to be a subtype of objects
but also we can get other constraints
from from the context now so we are
seeing that this president is being
assigned to a sea of a string so it
means that sea of you has to be a
subtype of sea of string from this
information we can infer that you has to
be equal to string know that means that
we can instantiate you I mean the
sensation that the solve the that makes
the depression applicable is
instantiating you two to a string no but
I mean this sample seems very simple but
we shouldn't forget about the
inherent complexity of the example I
mean we had three constructors the
compare has to determine determine what
is the one the user want to took to call
and it has to discard the rest of them
and also exaggerate the variables and we
were saying so there is a lot of
complexity even if the example seems to
be simple so let's see what happens when
we start complicating it let's see the
compilation shine I mean what is
happening with the computation time this
is 48 this is getting bigger and bigger
and when we get to 16 nesting calls
nested calls I mean the time is 25
minutes okay this is a lot what's
happening here so but this is not only
for diamond I mean we create also an
example with lambda I mean nested
generic method calls plus in pc lambdas
we see also there is a an important
computation time so we've got this
diamond nesting example and with we
constructed a representation of its now
so here we have a compilation time
against diamond nesting level and
clearly it seems to this potential
correct and so we infer that we can
infer that the compiler is trying to
solve an exponential number of
subproblems now that is why it's getting
so big now if we represent the same data
using a logarithmic scale for for why we
can see that the starting from 10 around
10 it gets a linear not so that's a no
characteristic of of an exponential
function number 10 seems to be a magic
number here no I mean in several test
cases I probably not depending to motion
on the number of overloads once you have
ten method calls then you start seeing
the disp initial explosion so what the
causes of the of the exponential
explosion we can say that well because
initially the spec was very complex 448
and in order to to make lambdas so
powerful we were considering a lot of
cases now and overload was very very
complex and so the poll expression had
to to be discarded depending on the
number of targets we have to to check
what was the correct over log cetera and
so yeah I mean the compare I was trying
to find cheap tickets during
thanksgiving know so they are mitigating
factors of course I mean it occur in
limited settings I mean usually users
don't write this kind of code usually I
these are the one generating them but we
saw this with code generated by netbeans
so we got the report from our users and
so we started investigating
investigating the causes of it now even
when I mean building a the JDK or any
big project was fast enough we wanted to
to proactively solve the problem and
provide all our users a really fast
compiler no matter if it was I mean the
problem was attacked only four corner
cases so this was the reason we started
working on the 30 tuition project so
what we wanted for their tuition project
we had to ray engineer the compiler I
mean the mainly that the type
attribution part of the compiler and in
order to add performance and and also
the changes we had to do a compare her
to be compatible with the previous
version of it now in our case it
wouldn't be acceptable so who are the
main ideas behind tier tradition so many
ideas are that we gather as much
information as possible this information
I mean we call this information
structural information so with that
information we can decide if another
load is possible no without really using
the expression and that that was the
main the main thing behind this
attribution we can look at this as a
schedule in the Fibonacci numbers now if
you implement a natural way not the most
natural probably recursive
implementation its birth slow but if you
use memoization then you can get to
linear times now this I mean if we see
an example of calculating Fibonacci
number five we can see that Fibonacci
number two is calculated three times so
but if we store so power lines the
result of some son of the subproblems
then we can get to linear time so here
we can see three completion times now I
mean Indonesia one that for java 8 which
is the exponential function then we have
the times for java 9 which is the
fastest it's already has to your tuition
and also we have for JD canine using the
dust release release eight option we can
see that the time is very similar to
jelly canine so you can't use a daily
canine as a cross compiler and generate
a code very
very fast I mean with a very fast
compiler and if you if you are seeing
this this problem for any any of your
projects now so which is very good this
is very good actually and so in order to
to understand where these graphs we have
added how a linear and exponential and
quadratic function our campus I mean I
represented in a graph with logarithmic
scale you know so we can see that the
potential graph is a straight line then
the quadratic and and the linear
function are like logarithmic like
logarithmic functional so we can say
that what we got for for JD canine was
between linear and quadratic compilation
time it was spun ential before so so we
are talking about the results we got
four-forty attribution we can say that
we got the dramatic performance
improvement we were looking for we got
the car DVD with the previous approach
and it opened the door for for a lot of
more optimizations now optimization on
on TRT own type type inference probably
we will be talking about that on next
jawan know what we are doing a lot of
work trying to make the compiler even
faster now that we have solved the
bottleneck that that this potential
post-explosion imply yeah we'll take
questions at the end we'll take
questions at the end yeah Surya so
that's it my colleague will to the
summer
but we don't have a little bit more to
say we just wanted to do an overview of
what we had so there are some
fundamental development changes and Java
coming with modularity so at javaone
this is a good time to learn about them
at the other sessions that are going on
we do have smaller improvements in other
areas to finish out some of the plan
work with both projects coining project
lambda and we have some things that
increase developer convenience like the
dash release flag we hope you find that
useful as well as making the compiler
performance more robust and again if
you're interested in following things in
more detail you can always join the
OpenJDK mailing lists or the other parts
of the open jet community and those EA
builds are available for your usage we'd
also like to acknowledge that it's not
just Santa and I working online tools
there's a large team of people also hear
some of whom are at the conference we
have engineer specializing in
development writing tests at the
specification as well as developing
conforming suites and with that again
Duke wants your help getting JDK 9
feedback so please give it a whirl this
slide has URLs for the JDK 9 early
access bills as well as for the PDF for
the talk so thank you for coming today
and we'll be happy to take some
questions now
pardon yes yeah yes we're aware that
there yes we're looking at improving
that back to the level as it was before
for the smaller values go dink yeah any
other questions
so the question was about the dash
release flag when you're targeting older
platform versions so is Vicente showed
in his slides while the JDK 8 compiler
has this extra edge performance if you
use a java sea and JT canine as a jdk 8
compiler it has the JDK 9 performance
profile which is doesn't have the
exponential slow down that's what we
mean by that so it it depends what you
mean by the same so it's not guaranteed
to be bitwise equivalent meaning you
might not get the same bits of a Java C
dash release 8 as you would from going
to release 8 compilers but it should be
a valid compile on the release 8
sometimes we do change the idioms we use
to generate the class files and that
would be reflected possibly when using
release 8 we think so we're not going to
make it worse on purpose so there's
question about are we adding protected
default methods and the answer is no
there's be much more complicated but the
private ones are there for your
convenience
barrier
so the question is since we've added
private met you know first you know non
abstract methods and now private methods
interfaces why don't we add state what's
preventing us from doing that and the
the basic answer would be a good design
principles so we don't want to have
stateful interfaces and inherit all the
messy problems of multiple inheritance
LS C++ the main reason multiple
inheritance you know language like C++
is complicated is because of the state
so when we leave the state out we get a
relatively simpler solution as we've
seen with default method is innate so we
you know we are aware that the fault
methods are a trait like but not a full
trade solution and that's that's fine
for now
quite right a markdown drinker
so the question was let's say I don't
like HTML as much as I like markdown
could I write a markdown doclet
technically yes you could write that
people have previously written things
like a PDF doclet so it's a small matter
programming to do it but it's definitely
technically possible the question was
would that be included in line I guess
if it existed it would depend on how the
person who code it implemented it so but
it's not it's not something that exists
right now any other questions one more
question is why aren't waiting to
disallow the underscore until we have a
definitive plan to use it one is to give
us more time to think of things to do
for to kind of reserved it from use and
not have a as abrupt or transition so to
give people time to get used to not
using it and then that will open it up
for future things it's kind of a more
more gradual transition like light
defaults well the deep we cleverly reuse
an existing keyword since it's used for
switch statements so we did not use the
go-to keyword which has also been
reserved since the beginning so I guess
that's about it so again thank you for
coming today</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>