<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Programming with Streams in Java 8 | Coder Coacher - Coaching Coders</title><meta content="Programming with Streams in Java 8 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Programming with Streams in Java 8</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rVfRDLIw_Zw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright let's get started welcome to the
session on programming with streams in
Java 8 my name is Venkat Subramanyam
we're going to focus pretty much
entirely in the session on the ideas
behind streams in Java 8 best time to
ask question or make a comment is when
you have it so please don't wait to
learn anytime is a great time for
questions comments just draw me
attention and and begin to speak
definitely we like to hear what what you
have in mind so let's talk about what's
happening in Java 8
well Java 8 has probably one of the most
visible features which is lambda
expressions when I got excited about
Java 8 I was to be honest pretty
lukewarm because I said hey lambdas
every language has that today I mean
even C++ has lambda expressions for
crying out loud and so why should I
really care about it
I was actually mentioning this a couple
of weeks ago and I made a statement and
I quickly realized that's not a very
fair statement and I and I rephrased it
right after that man my spiritual
statement was that lambdas sure all the
languages have it but Java was pretty
late for the party and then I realized
that's not really a fair statement for
what debate has done so I rephrase that
quickly by saying Java is late to the
party but they came with really nice
nice desserts so the point really is
that while every language out there
today while most languages have lambdas
there is something really interesting in
Java the real charm in Java 8 is far
beyond lambda it is going to be streams
now I'm in another statement and I was
able to get away with making the
statement and and the statement I made
was that lambdas are gateway drug
but streams are the real addiction and
the reason I was able to get away from
it is because I hail from the state of
Colorado so we can perfectly say that
the basic idea really is that you really
get hooked on to the streams once you
get really beyond the lambdas and that's
where the real power is so what does it
really do for us why should we really
care about screams that's what we're
going to see pretty much through this
presentation as you can see here I don't
use any slides I'm going to just talk
about stuff write some code and have
some fun along the way but if you are
interested in downloading the code
examples you're most welcome to download
them
there's no rush it'll be there for a
long time but on that website agile
deliver calm and you can download it
from the downloads page so let's talk
about what can we do with streams the
very first thing that streams do for us
is they provide us this wonderful
ability to really separate what we do
from how we do it we don't have to focus
on how to do things that's what streams
do all that we have to tell the streams
is what we want and it takes care of it
for us and so this gives us a nice
functional programming style as it is in
nature streams are and it helps us to
focus on the whole instead of on the
part now what we have been doing for the
last you know several decades is we've
been focusing on the parts rather than
the whole we sit down and control and
specify every single detail where our
streams help us to go from the detail to
the big picture from the concrete stuff
to the abstraction so we can be more
expressive of course all of that sounds
exciting but we really have to see it
working so let's give it a try so what
I'm going to do here in this example is
I'm going to use a series of examples
most of them but not all of them but
most of them using people example so
let's quickly take a look at a person
class I have here a person has three
pieces of information here I've got a
name of a person a gender and an age all
of these are private variables
constructor allows us to set these
values the name gender and the age
and of course the regular getters that
are available for this and finally the
two string method does prints the
information about the name gender and
the age so a person simply has these
three a piece of information and of
course if you wonder what gender is
gender is nothing but a enum where we
have a male and female now let's get
back to the code to see what I'm doing
here I've got a function called create
people which simply returns a list of a
bunch of people so I've got a few people
that I've created some few things to
notice there are two people with the
name Sarah with two different age values
both female there is Bob and Paula which
are also two different people two
different gender two different age Paul
and Paula are of the same age so the
point is there are a few people with the
same age few people with the same name
and a mixture of other things in between
jack is two years old another jack is
seven degrees old so you can see the
range of ages as well great now that we
have the base data set up we go to pork
work with some of the ways we can
program with these things so the first
thing I want to do is let's get in
uppercase the names of all the females
that are older than 18 years old so
let's go ahead and say that's the one we
want to do now how do we normally
program this in Java we would start by
focusing on the individual at this
particular point so I want to get in
uppercase the names so names obviously
are string but names as plural so I
would start with a string over here
names equals new ArrayList and then I
would want to have an empty array list I
would start with the people so it's a
people person and that comes from the
list of people that we have on our hand
and then what would I do
names of all the people but they're
older than 18 so I would say a person
given to me of get age is greater than
18 and I'm going to then say if the
person is really greater than 18 then
I'm going to say names dart add well I
better get the person's name so get name
and then I would say to uppercase and
converted
the uppercase and then I would go ahead
and add it to this particular collection
at this point so when we are done with
that we can just print the names of this
person in the uppercase that we are we
have available so this should be person
obviously now if you look at this it did
produce a output there are fewer people
in this output then the number of people
I had because there were a few people
less than 18 years old but if you really
look at this code even though we have
done this for a very long time
this is involving a fairly low-level
detail in other words we have no respect
for the language at this point and we
are telling the language I don't trust
you to do stuff I've got to tell you
every single step of things to do now if
you do this to a fellow human being
you would probably rescuer life
eventually right because they go to go
postal on you and they're going to get
angry because there's only so much of
these people can take but the point is
that you want to really be expressive in
your code so rather than focusing on
single element values you can be very
decorative
at the collection level itself so let's
retry this one more time and see how
we're going to express this so what
we're going to do here is we're going to
say well I want all the names in
uppercase but only people who are older
than 18 years old so things that we
should get used to very quickly is
operations like filter and map because
if usually translates to filter and any
computation where we try to get some
results translates to a mapping let's
understand what this really means one
way to think about this is think of a
filter as a cone operation so you have a
bunch of input coming in what a filter
does is it takes those values and like a
cone it narrows it down to a fewer set
of values so potentially you will go
from several values to zero values then
the cone absolutely ice cream cone right
it just it sends in a tip or it could be
more like a cone which stops in the
middle you got a fewer values in other
words when you use a fill
for n number of input you may get
anywhere from 0 to n output 0 when
there's nothing that matches the filter
and air n when everything matches the
filter so for example I could say for
instance I could say every human in this
room well that's everybody in this room
and output equals and input on the other
end if I say every lady in this room
there are you know only a fewer number
of people then then a total number of
people in this room and likewise when I
say there are men in this room so we
could do filtering and on the other hand
I'm hoping if I say aliens in this room
I'm hoping that's a zero but you always
doubt it when you say that so the point
really is that we can always say it's
going to be a zero to n and depending on
what the filter is likewise a map
operation on the other hand think of it
not as a cone but as a cylinder meaning
the number of input is equal to the
number of output when it comes to a map
that's why it's like a pipe or a
cylinder so if you give pen input you're
going to get an output but the input and
output relationship is every single
element in the output is a
transformation of every single element
in the input so you can you know combine
these two in various different
combinations you could filter and then
map it or map and filter it or do
multiple filters multiple maps it's
really up to you
to produce a result you are interested
in so in this particular case I'm going
to go ahead and start out here and I
want to list after all so we'll do the
same thing here so I'm going to say list
of names too but in this case I'm going
to define the list that I want but
notice rather than creating a list to
begin with I'm only going to create a
variable called names - on the other
hand I'm going to assign it to in this
case people that we are starting with
and then I'm going to call a stream on
it so what is a stream at the offset a
stream is a very fancy iterator it can
do some really powerful iteration
operations on the values so in this case
I'm going to say filter and why am I
going to filter because I want the
person
where the person's age is going to be
greater than 18 so we said in other
words notice the if statement in this
code simply became a filter operation in
this particular case we are filtering
out everybody who is greater than 18
years old now that we have a perk all
the people greater than 18 years old I
want to perform a map operation where
given a person I take the person again
get the name of the person and I could
do one more with it if I wanted to but
or I could simply say given the name of
the person I could simply say named dart
to uppercase and I could have put this
in the same thing but by mating making
it a lot more modular it becomes easier
to understand easier to maintain as well
and so we basically said go from the
people that you have to all the people
greater than 18 years old and then once
you have the people who are greater than
18 years old go ahead and get their
names and then transform the names to
all uppercase well when you are done go
ahead and collect it back into a list
object and store it back into that names
collection so the dualist method
actually comes from yet another object
which you stream over here so stream
dark collectors and then it's going to
come from the collectors itself so we'll
talk about that a little bit later so
that's where it's coming from so if you
compare these two pieces of code at the
outset this may appear like there is a
lot more code here then it is over here
but the lines of number of lines of code
is a is a very troublesome index I
wanted to think of two different words
when it comes to quality and the size of
code the word ters and the word concise
the word concise means the code is short
and understandable the warders means the
code is shirt and ready to hurt you
right so the code above is actually
tirst because it is very deceivingly
very short but it takes a lot more
effort to really understand and maintain
it so I don't mind
having a few or more lines of code if it
is going to be really concise in that
regard so that is something we had to
keep in mind the goal is not to write
the fewest lines of code the goal is to
write more expressive code with other
benefits we would talk about so in this
case what we have done here is the
result is exactly the same in both cases
but on the other hand in the bottom we
did the filter and the map operations to
get the data now of course we could
apply certain other nice capabilities in
the language to minimize the Muraco to
make it more expressive we could say get
name over here rather than calling that
function and with the syntax we saw
earlier and similarly we could have
simply replaced this with a string and
to uppercase and these things are
provided by the language already to make
the code a lot more easier to understand
and more expressive as well there's
nothing that stops us from doing it but
the concept is essentially still is the
same that we are doing filter and map
operations on the content so we have to
start thinking more about how do we do
transformation with these rather than
writing the code in the good old
imperative code that we are used to so
we wrote it in the functional way but
what are we really doing very first
thing is we are really focusing on a
higher level of abstraction rather than
focusing on oh let me fiddle with these
individual elements and navigate through
them and work the mechanics of the
iteration we are treating this at a very
high level of abstraction so what is a
stream stream is an abstraction stream
is not a data structure stream is not a
collection like the way we are used to a
collection it's actually an abstraction
that we are working with we need to keep
that in mind
so it's an abstraction it is non
mutating so you are not modifying a
collection when you are within a stream
in fact you shouldn't modify a
collection when you're a stream that's a
very evil thing to do now I'm sure you
will always have a programmer at work
who will modify it and say see it works
right stay away from those people right
because that's not the real part
plus you don't prove anything by saying
it didn't fail because it just hasn't
failed yet so it's important to you know
have that hygiene and not mess with the
collection from within a stream and
change it we'll talk more about this as
we go through but it's really a view of
the data as it is being transformed so
in a sense we are taking a particular
data and applying a series of
transformations on the data to produce a
final representation now it's important
also to keep in mind the word
abstraction here so as we perform the
transformation we may feel that this
transformation is going from one
concrete representation to another
concrete representation but in reality
it doesn't it actually stays as an
abstraction so a lot of intermediate
results may never be realized or even if
they are realized it may realize to an
end result but the intermediate will not
take effect at all we'll see again these
a little bit more but it's also
important to keep in mind stream always
as a pipeline so if you think about an
electronic circuit or a pipeline as an
oil pipeline or just the water flowing
through in the pipes and a building it's
a transformation as things flow down and
we are really looking at this
composition or pipeline aspect of things
that's what we are really doing here
when it comes to building with this so
how do we go about using these streams
and what are some of the things we can
do with it
well the very first thing conceptually
what we need to get in our head is you
are in a concrete collection oftentimes
this could be what it could be a list a
linked list and ArrayList set a hashmap
there are so many collections available
in Java you could create your own
homegrown collection as well so these
are all called concrete collections why
are they concrete collections because
you normally instantiate objects of them
you populate objects a collection of
objects into them and you normally use
them so that is your concrete collection
that you are working with and so you
start with a concrete collection to
begin with and you raise from the
concrete collection into a stream
so the very first operation is that
elevation operation which is what you're
seeing on line 31 you go from the
concrete to the abstraction that is your
very first step so before you do any
work with the abstraction you would
raise it up you can think about this as
being in the local streets and then you
jump on a freeway the day that actually
it's free and you can go fast on the
freeway the highway so it's like you're
raising up to a higher level and that is
the Streamy of raising up to so you go
from the concrete to the abstraction
that's your very first step and once you
go to that abstraction you gain speed
you can do stuff with that level of
abstraction and your speed comes from
staying at that level of abstraction as
much as you can stay and when you no
longer can stay which is when you
eventually have to get back to the
concrete type so think of this like a
bridge you raise up you stay at the
abstraction level and then you raise
down to the concrete level that's a very
common pattern when it comes to
programming with streams and what
concrete you end up with really depends
on what you're trying to do so you write
the stream as so to say so you won't see
we elevate to the stream level you're
basically writing the stream with all
the operations sequence of things you
want to do and when you are really when
you're doing that you would compose
various operations it could be one
operation it could be several operations
it's really up to you and then once you
are done with it you finally land back
back on one of the concrete types it
doesn't have to be the same one you
started out with it could be completely
different depending on what you're
trying to do and we will look at some
examples of this as we go through but
that is essentially the pattern you
would follow please yes proceed sure
I don't speak generics I thought we were
having a good time here sorry do you
have another question worth answering
well the answer is yes so a Java does
quite a bit of type checking for you and
there are going to be times when I'm
really sorry if you hurt thinking more
about generics when Java really has
generates reunification happens we will
have a lot of good time with it
until then we're going to fight generics
with type-checking that's going to
happen somebody has had a question here
please yes it's a very good question so
the question is we can look at as a
pipeline does the JVM locaters pipeline
enormous Liso so the libraries really do
a lot of miracles behind we're going to
get to that part so you will see that
what you see is not what you get what
you get actually is a lot better than
what you see so we'll get to that
absolutely excellent so so we saw how we
go from this concrete type to the
elevated streams and then back down to
the concrete type that is generally the
the pattern so streams employ function
composition that is a very common
pattern like I said your pattern your
composition could be one function but
usually it's a series of function you're
gonna apply depending on what you're
trying to do another thing to keep in
mind is stateless behavior so if you're
going to load with the state it is going
to be pretty dangerous to work with them
this is going to require a little bit
more effort on our part because we are
all used to programming a lot with state
over the time what we should try to get
as much stateless as possible while we
work with it and also make sure the
functions you work with are pure
functions meaning you don't start
correcting some data or mod
buying other states we got to be very
careful about that also we'll look at
some of the examples of these along the
way but the beauty of streams is there
are very specialized functions now in
other words what happened what we have
been doing in Java is we've been abusing
and overusing the four loops right we
invoke the for loop for just about
everything we do and that I called the
jack of all four loops right but instead
of that we used very small precision
tools when it comes to scream oh you
want to do a selection use a filter oh
you want to do a particular
transformation use a map or you want to
get this to a particular per type user
reduce so there are so many methods
available and you would pick and choose
the one that makes the most sense based
on what you're trying to do so let's
look at an example here
I want to get all the mails and print
them in this collection so how would I
go about getting all the mails
now you know exactly how to do that in
the imperative style so I won't go into
it anymore because you would first
create a collection of people and then
you will check if somebody is a male and
you would start inserting them into that
particular collection and you don't want
to go through that instead you would
just use a nice filter operation so what
you could do here for example is we
could simply say people dot stream
notice the elevation up to the
abstraction then we do a filter given a
person over here I want person dot get
gender and in this case I want the
gender to be a gender dark male and then
now that we have all the males on hand
we could say for each and we could say
system dot out and then print line and
then we could simply print each of the
male objects in this particular context
so you can see again in this case we're
using a set of transformations on our
hand so we went from a stream to a
filter we picked each of the male
objects from the collection and then we
just printed it now remember one of the
things we learnt in structured
programming is the code has to be really
modular well I agree with that
completely but
your programming really didn't code make
the code modeler it was a visual
thinking right because if you really
look at our if loop what are we doing in
the if loop we are going across and
doing ifs and jumps and break and what
is that model are about it really is not
modular but over here notice we stack up
each of the operations very nicely
logical order true modularity is being
achieved in this case rather than the
perceived modularity that we claim in
structured programming as you can see in
this case so we are using the filter so
what is the filter again the cone
operation I talked about notice we got
four objects in this particular case as
against how many of our objects I had in
the original that's the cone that I was
talking about in terms of the filter map
on the other hand is the cylinder
operation I talked about I want to print
all the males but I want the names in
uppercase over here well notice in this
case when I ran this code all the names
are in mixed case as you can see Bob
with the be uppercase and OB and
lowercase but I want their name in
uppercase how do we do it now remember
they avoid the temptation to modify
objects you won't want to mutate stuff
you don't want to take a person and
change the person's name you want to
only print the name in uppercase right
so what do we do about it so notice what
I'm going to do once I filtered I'm
going to do a map where I take a person
but I create a person in this case the
person I'm creating is going to have a
name where the name is going to be to
uppercase of the old person's name and
what about the second parameter in here
the gender so person dot get gender of
this person and the third one is person
dot get age of the person that we're
going to use so you can see all of the
modern uppercase now clearly in this
particular case you might argue and you
are correct about it that you ended up
creating different person objects and so
you have duplicated the person objects
but there are some really good benefits
after all here the first benefit is if
you go to the people over here notice
the P
were unaffected there's Bob still with
the mixed case name as it was so you
preserve the original collection you
don't have to worry about modifying the
given list now in this particular
example you made a copy of the person
now is that really poor in performance
now remember what verdict brogues said
we here one of the things we normally do
is we worry about performance but
worrying about it too early is a
premature optimization so if performance
is not a problem and it is not in a lot
of situations we end up losing on to
friends we don't get the performance
because we didn't need it and we also
lose other things if performance is
really important if it's not delivering
then you can worry about how to improve
that performance
well there are other data structures you
can use where can make a very effective
copy and as a result it wouldn't be
really a overhead and we can devise ways
to get around it but the focus here is
to make sure we don't mutate the
collection but we are transforming it so
in this example you can see how we took
the value we took all the mails
and then we created new objects with a
different name but of course if you only
wanted the name and not their gender and
age you would have just extracted the
name and transformed it without having
to really create the person so we saw
the filter and map operation but the
next operation we're going to look at is
the reduce operation so what is the
reduce operation a reduce operation
often is going to result in a single
point but the single point may be a
single value or it could be a collection
itself depending on what you are trying
to do but think of a reduce a little bit
differently than whether it's a cylinder
or a cone think of a reduce as bringing
you back to the concrete representation
so what reduce often gives you a
concrete representation so stream takes
you up map and filter writes the stream
reduce comes you brings you back to the
concrete right so that is a very easy
way to relate that in your mind so you
go up map and filter crabbers and then
reduce brings you down to one or
different concrete representation so
let's say for a minute I want to talk
the age of everybody so I want to know
how what's the age of everybody in this
application right so we got different
people with different age so how would I
compute that well there are some really
easy way to perform these computations
one of them is we really want the total
of the age we really don't care about
the people at this point so we could
perform a map operation off the bat and
we can say person : : get age and that
gives us the age of everybody so we have
to have the will to really only focus on
what we care about and remove from our
context things we don't care about we
don't care about their gender we don't
care about their name we care about
their age so you map to their age and
you ignore the people might remember the
original collection is fully intact so
if you really need to go back to the
original collection you can always so
you can throw away that for now and work
with only what you care about in this
case the age of the person then I can
save reduce and what do I want to reduce
it to well starting with the value of
zero I want to take accumulated very
value will call it carry and I get an
age value and I want to perform a carry
plus age as the value that I want to
produce so how does this really work
let's understand how this works
in just a second so in other words what
we have done here is we are performing
an operation of the only the persons age
that we are interested in producing it
happens to be 212 let's understand how
this is actually working so in order to
understand let's imagine for a minute
that I'm going to total the age of
everybody in this room let's say
starting with him he's no longer smiling
at me no I'm not going to ask pretty
real age right so what are we going to
do well I'm going to remember we
couldn't honor immutability so I'm going
to take a post-it note put a zero on it
and that's the age of everybody I know
so far I give him a zero as a post-it
note and what does he do he takes his
own age totals with the value zero
creates a new post-it note and then
forwards the new post-it note with his
age at this point to the person next to
him the person
takes that post-it note as his own age -
it creates another post-it note and
sends it down so it progresses down
through the entire room and that's
exactly what we are doing here the zero
is the initial value that we pass to the
first element and the carry is the
partial result that's brewing and age is
the age of every single person and so
this iterator really is a full life
operation which simply Traverse us
through and perform this temporary
addition producing temporary results and
then shading it through please that's a
very good question what do you do if you
have to remove things from the
collection I don't want the age of
everybody I want the age of only female
do a filter before you do the map Oh
from the original collection that is a
mutable operation you don't want to do
that with a stream right because doing
mutation is like living in the slum and
that is fun doing it but bad things
happen from that as well
so streams are this Narnia where
everything is pure and and everybody
smiles at everybody all the time so you
kind of get out of this highway and do
the mutation locally but be quiet about
it
and then you can come back to the stream
so so mutations away from here and then
you are in this so when I think about
functional programming like I like to
call this a circle of purity and once
you enter the circle of purity you don't
do mutations but if you step out of the
purity do whatever you want to do and
then you come back quietly and be pure
again so so that is kind of the circle
of purity that we are talking about here
so if you want to remove from the
collection permanently then you want to
work with the collection the removal
operation stuff like that but streams
are not a good candidate for that yeah
I'm glad you asked that definitely we
want to remove that from here but on the
other hand we don't want to consider
ours object in a selection we could use
a filter for that purpose so we saw how
a full lift operation happens here but
there are some very specialized
operations notice here we did do this
reduce operation there are a couple of
different things you can do here
for example I could have said integer :
: some and I can reduce a little bit of
work in this code by removing a burden
on our shoulder but then implementing
our own sum operation here I can borrow
something that's already there so we
could have done that but we can go even
a step further than that we don't even
have to go through that to that length
we could simply use some directly and
think of a sum as a very specialized
reduce operation so think of this as oh
you got a few things that can do the job
but this one is extremely more precise
tool but there is one small problem
look at the word sum for a minute reduce
is simple to think about you can reduce
pretty much any given collection of
objects how because you tell me how to
reduce it but what about some well some
is totalling right um some is very more
specific can you some books no I don't
know how to some books can you some
people I don't know how to some people
right so some is not defined and the
gentleman who asked about generics
that's where we are running into trouble
now right because the problem here is
you are dealing with a base class which
you streams but your sum is only valid
in integer streams or long streams are
double streams but the problem is when
you deal with the base class you cannot
call the derived class methods on it
Java doesn't all of you to do that right
because job is statically typed you
cannot suddenly call a derived class
method that's not known in the base
class well to to so as a result you can
accomplish an error right here saying
that it doesn't have a clue what sum is
well you can do a little things like int
over here to say that you want to really
do the transformation and it's a little
bit unnatural but that really comes from
the fact that we are dealing with the
language that imposes a certain
constraint on us so you say map to end
then you can call the sum operation
because some obviously is defined on a
collection of integer but not a
collection of general objects yes please
so the question is is it converting it
to a in table ject sadly no because it
really knows it's an end it is actually
converting it to a collection of integer
streams and so the sum was valid on it
so in other words you can have a room
full of animals versus a room full of
dogs both the rooms may actually have
dogs but one room you know it's a room
of dogs the other one you know is a room
of animals right so to type a checking
that really interferes here the objects
are literally the same in both but it's
how you view the entire collection that
makes a difference unfortunately and and
so remember the sum is an operation on
the collection not on the individual
elements at this point and that's a
reason please right so the question is
is the iteration done twice that's a
really important question to ask when
you go into this abstraction of stream
you only perform one iteration so all
the operations are merged together very
efficiently we're going to see that a
little bit later on please
two separate operations you you can't so
the question is if I want really an
output where I want to get male and
female differently it's going to take a
little bit more effort to do that but
what you can do is you can start mapping
and when you perform a reduce operation
what you will do is you will check their
gender and you would add them into two
different buckets Java will make this a
lot easier if it had tuples but
unfortunately Java doesn't have tuples
so it's going to take a little bit more
effort to do but it would be really a
reduced operation so imagine I give you
a pair in your reduce operation and then
depending on the gender you would update
one or the other value and then produce
it yourself so absolutely you can do it
yeah so we saw a few examples of the
reduce operation this one was a more
specialized operation well I don't want
the sum I want the oldest person in the
collection how could I do that so if I
want the oldest person I still need the
person so I'm going to call the max
method over here but
what am i maxing on well given a person
I need to compare people to get the
maximum right so in this particular case
it's going to be a comparator so I'm
going to say person 1 , person to and
what am I going to return well person 1
dot get age is greater then I'm going to
put this on the second line is greater
than person person to dot get age so
then what do I do
well remember the comparator then I'm
going to return a 1 otherwise in order
to minus 1 so we can start providing
certain responses based on what we are
expecting so in this case it was Jack
male 70 was the oldest but it's optional
Jack no insert - Jack really but it's
optional Jack because it is quite
possible that the collection may be
empty so it's very defensive as you can
see it says well if you give me an empty
collection and ask for a maximum I can
give you a result so it could be a nun
but of course if there was a value I'm
going to give you that value so in this
case you can see that it gave the oldest
person which is Jack who's 8 is 72 if I
replace the max with the min on the
other hand the result is also Jack but
notice this jack is two years old and
not 72 years old so there's a
grandfather and grandson with the same
name apparently but of course - and 72
as you can see in this case so we can
get the max and the min but what are we
providing to it by providing a
comparator function as a parameter later
on I will show you some syntax which
would be a lot easier to read than this
so we can do quite a bit of work with it
but I want to count let's say I want to
count the non adults how do I do that
again keep in mind our the series of
filter operations so filter and given a
person I want a person dot get age and
it's a non adult so they are less than
18 years old dot count and that gives me
the number of people that I have
selected and there are only two people
in the given collection who are younger
than 18 years old and so we apply the
count operation after we filtered it
so you can do a lot of these different
operations so the first thing we got to
get into our mind is there are these
specialized tools like a little chisel a
little screwdriver little hammer and we
can use these to do certain things
rather than the jack of all for-loop
that we are used to so which means we
have to do a little bit of a hunting
around the JDK to find out what kind of
methods are available and until we get
familiarized and really get comfortable
with it it will be a bit of a discovery
to figure these out what long the way so
we certain characteristics we had to
keep in mind what are the
characteristics is that the collections
are sized
you know that a list is a pretty
different sized right it's a size for it
it's ordered we know what list is the
ordered collection set is an unordered
collection so it may preserve the list
as well or the elements distinct we know
that list is not distinct you can have
duplications in a list on the other hand
a sekhti is often an unordered but a
distinct collection a hash set on the
other hand he is ordered actually sorted
and then it's also distinct so in other
words how do we know what we are dealing
with there are two things that influence
it the first is what are what is your
concrete source you are starting with
that has properties of whether it is
sized whether it's ordered whether it's
distinct or whether it's sorted and then
what kind of operations you are
performing some operations may remove
one or more of these restrictions other
operations may add it one example if you
are have an unordered collection and I
do a sort on it the rustle becomes an
ordered collection assorted collection
for example right so you have to keep
this in mind you need to know what your
sources characteristics are and what
your operations characteristics are to
know what your implication is that is
something we have to keep in mind so the
general rule keep in mind
Rea's operate land that's the pattern
you are using right so let's write on
that be very careful where you land
right because when you land you got to
make sure you land on the right type
there are a very different ways to land
so let's look at
stuff all adult names in uppercase the
wrong way to do it now this is the
temptation we will have but a temptation
we should nevertheless avoid so list
string names equals new array list and
this is going to be an empty list we
created then I say for person person in
people and then once we create this
collection what are we going to do we're
saying list of all I don't names so how
do I know if it's an adult if person
dart get age is greater than 17 then I'm
going to say name start well actually
let's do it a little differently now
that we have looked at the functional
style the temptation may be to do this
which is even worse which is to say
people dart stream and then what would
we do with say filter person person dart
get age is greater than 17 dot map and
then we would say person dot get name in
this case so we got a person person dot
get name and then we would say dot to
uppercase whether you do it in one or
two and then what would you do you would
say for each and then you would in this
case names dot add and then you would
say the given name right so name so
whatever name you receive you could say
add it to this collection right here and
then when you are done with that you
would say names right here so if you
notice this Court seemed to have worked
but this is called a bad idea right and
the reason why this a bad idea is we're
doing something extremely unhygenic
right if you see somebody do this don't
walk away from them run right because
that is like polluting the village well
right there is no cure to it after this
why is this such a bad idea when we are
violating all the good norms of
functional programming we are causing
side effect we are mutating a variable
now in May
Jen you are going to perform this
operation concurrently what's going to
happen well your name's collection is
dead in the water right or even worse
somebody gets very creative and they put
a synchronized around it that is called
bang the head on the wall pattern right
because they gave you all this wonderful
feature and let me go back to
synchronize and suffer model so there is
no reason to do that so what is a better
way to write this code so rather than so
rule number one never sneak in and
perform a mutation of an existing shared
variable from within the for each method
that's really a bad practice definitely
you know so what do we do about this so
the better way to do this would be you
first say lists to string names to
equals and then you do the same thing up
to this point everything was good so
we'll just copy and paste that part
right up to here there's not a problem
if you really want to excuse me you
could break this into two in both places
right but the real thing is we say dot
collect and when we do a collect what
are we going to really do we'll come
back to that in just a second then I'm
going to output here names too now why
is this such a better idea if you look
at the collect the collect does
something really phenomenal the first
thing you say to the collect is you're
going to say new array well it's a
supplier so the very first thing you
provide to the collect is you return a
new array list now this one is called a
supplier why is it called a supplier
because notice the parentheses meaning
you don't give it anything what does it
give you back when you call it a new
object so in my definition of supplier
is it's like mother's love right you
don't give it anything but it always
gives you back you know it's so caringly
so that is the supplier right in this
case it serves as an initial value for
you to work with then the second thing
you do here is you got a list comma
element we'll call it name and what do I
want
do with this information I want to say
listed our ad name now you may look at
this and say aha
aren't you mutating here we'll come back
to that in just a second and then the
last thing you do is list 1 comma listed
2 and then you simply say list 1 dot add
all list 2 now clearly this looks
complicated so bear with me for a minute
don't worry about it right now
but notice that result is the same but
this is enormous ly powerful for a
number of reasons the very first thing
is the collect method says I will take
care of all the concurrency issues if
you go mess around in one of those
functions you are sneaking around on
changing state without them knowing what
you're doing right that is called evil
programming on the other hand who wrote
the collect they did and who gave all
these three constructs they did so they
managed this rather than we managing it
so what you have said in this case is
you have said I'm going to give you an
initial value the birth object I'm going
to show you how given a value how to add
it into a temporary value as it evolves
but if you decide to go concurrent given
two sub lists I will show you how to
create a bigger list from it think of
this for a minute right you got a
million objects on your hand
it applies multi-threading it will do in
chunks and we'll take goo collection and
create a bigger collection and who
manages thread safety that collect dust
so this is where it gives you fine
grained control in a very thread safe
manner how do you get the thread safety
there are two things here for thread
safety a the collect is done by them and
B did you notice one big difference
between what we just wrote and what we
did on line number 25 you may look at
these two and say AHA you're calling add
in both but there's a phenomenal
difference between the two on line 25 we
did add on object outside of this that
is pure evil right whereas if you
look at line 35 and 36 we did add on
what was handed over to us which means
it's a temporary object not shared by
other threads so it's fundamentally
different from the threading point of
view go ahead please
oh that's exactly it's a specialization
so you're saying I don't really care I
don't have anything fancy to do you can
replace this with the two lists right so
when you use a two lists
you are really doing that so now that
you know it's the auto shift versus you
know stick shift right so you're saying
okay this is great but this is too
verbose for me if this is what I really
want
I don't have anything special to do you
can blow that out and simply say two
lists over here and it does exactly the
same thing so guess what two lists is it
simply returns that three different
collections to you absolutely so so you
can minimize the effort so this is like
the 80/20 rule 80% of the time the tool
list is enough for you that 20% of the
time when you really need to do
something very special you can upgrade
and use that collect with a little bit
more parameters as well so that is an
example of how you are performing in a
very thread safe manner so what are the
benefits you have the benefit is thread
safety and the simplification is using
the two lists you basically mention that
that's what I was going to show you
there well that's great
but I don't want the list of object
before I go further though I want you to
look at this very very quickly I
filtered let's say all the mail over
here for a second so I'm going to say
filter and what I'm a filtering I want
to filter only the Mail's over here so
I'm going to say filter person dart over
here so person Dart get gender where the
gender is equal to male let's say oh I
want you to watch the result very
closely here what we are getting so we
are creating a list over here we'll call
it people right so we'll call it as
males and this is going to be a person
list and I'm going to just print the
males over here so if you notice in this
particular case we got Bob and then
we have Paul then we have Jack and Jack
and so on so there are two jacks in this
example as you can see but on the other
hand if I were to replace this with a
set over here and of course in this case
I'm going to say two set and now if I
print this out you can see there's only
one Jack and the reason is of course the
set will preserve distinctiveness right
did I make it wrong well Jack always
gives me trouble so this is going to be
the genders did I say person so to set
so the distinctiveness should come in
through the filter so we are saying get
me the gender and then of course the two
sets should say filter the operations
and give me the results let's see why
that's doing that so male and of course
in this case gender equals general dot
male so the set should have preserved
the person's gender oh you know what I
stand corrected let me get back so
pardon me I'm thinking ahead of myself
so step back I want to get all the male
names rather than males so because a
comparison as a person not the name so I
stand corrected
so male names how about that and this is
going to be male names and now what am I
going to look for so thanks for keeping
an eye on it so map and this is going to
be person and this is going to be a
person get name right now there we go so
if you look at this here we are getting
a list of male names so two lists is
going to give us all that person's names
at this point so a list of string
obviously because it's the names we are
interested in but notice in this case we
got two Jack's on the other hand now
that we have a name only the comparison
will be on the name so if I say two set
over here because I only want the names
as a set and not a list now we got rid
of the other jack right so you can see
how the distinctiveness is preserved
originally when I wrote the code where
the persons are still distinct because
they had the full-blown person with a
different age but now the set is really
a set of you know people so we can see
that the distinctive is a preserve if
we're going to ask for a set on the
other hand well we saw that that's great
similarly you could map to a good bring
to a map or a grouping by it let me
quickly show you an example of this so
you can say a map and I'm going to say
what do I want to map a string over here
and then I'm going to ask for let's say
a person that I'm going to hold well I'm
going to say this is going to be a map
but how do we derive a map from this
gotta be careful here so I'm going to
say dart and I'm going to say collect
and this is again a collectives again a
very specialized reduced method so to
map and you give two parameters here
given a person so the first parameter I
want to use here so given a person I'm
gonna say in this person dot get name
and then I'm also going to add to it
let's say the person dot get age so my
key is name and age so that is going to
be the first operation here the second
is given a person I returned the person
itself that's called an identity
operation normally but I'll just leave
it at that so now that we have a map on
our hand we can try to print the map out
here and you can see Paulo 32 is the key
and the Paulo object is the value of
this so we got a hashmap out of this as
you can see so the first one defines the
key and the second one defines the value
but you can also go a step further with
this really nicely I'm going to take a
map of the key being the name but the
value being a list of person itself so
in this case what I'm going to do is I'm
going to perform a collect but I'm going
to perform a grouping operation so in
this case what I'll do is I'll say
grouping by and what am i interested in
grouping based on well the person given
a person I want a group based on
person's name
so get name is the grouping operation so
in this case notice Bob is the key and
the value is Bob but if you really look
at the details that we'll get in this
case so for example let's go ahead and
say I want to map dot for each and I'm
going to say key comma value and I want
to print these details let's say here
I'm going to print the value of let's
say output
key and then plus the value let's say so
in this case if you notice we are asking
for a jack and notice there are two
jacks in that collection so the key is
the name but the result is a list itself
so you can do very powerful grouping
operations with it as well that reduces
a lot of ceremony in writing code
similarly we can do some nice sorting
operations also very effectively you can
call sorted you can do comparison on the
sorted and then you can do it then
comparing as well and nicely sort
through a collection of data very
effectively take a look at the code
example I provided if you like to see
how the sorting happens but the question
really is what about the efficiency what
are we going to do is it going to be
really slow well this brings up the
important point about streams is that we
have two kinds of operations the
intermediate operations and the terminal
operations the intermediate operation
are things like filter and map these
operations are fused together and they
only work when the terminal operation is
called so in other words the fusing and
lace evaluation is where the real charm
of streams come in to understand this
let's try this particular example real
quick so what I'm going to do here is
I'm going to say find the first person
whose name is four letters but is older
than 25 years old so how do I do this
so people over here people dot and I
want to find so stream and then what am
I looking for find the first person
whose name is four letters so filter
person and then I'm going to say over
here person dot get name dot length is
equal to four right and then filter one
more time person but this time I'm going
to say person over here dark get age is
greater than 25 and then what do I do
and then I'm going to say Dart
in this case I'm going to say find the
first and I want the first person from
this collection to be reported so if I
output this notice how this works I'm
going to get the first person from this
collection and print it so when I run
this it says Paul who is
mail and 32 years old is the first
person whose name is four letters long
but of course what is the efficiency of
this well to understand the efficiency
of this let's quickly look at an example
so I say public static let's say string
and well actually boolean let's say
boolean and ease you know four letters
and I'm going to provide for this a
string let's say a person person itself
so in this case I'm going to simply
return this particular result we see
here right the length is equal to four
I'm going to return it from here so if
you notice in this particular example
I'm just you know deafening that to a
separate method I want to use so I can
completely replace this now with sample
over here and then let's call it as ease
for letters that's what I want to use
right here same result however if I go
back here an output called for and I'm
going to say person now if you notice in
this case it called it for these
different people as you can see in the
output well if you look at the output it
called it for Sarah Paul a Bob Paulo but
on the other hand stopped at Paul why
because at the first person with four
letter older than 25 now on the other
hand this is all lazy what does that
really mean well you will notice really
because you've seen this app work if I
remove the find first and run this code
notice what happens none of this really
got you know exercised why this is like
some employees that work right they come
to work they look around and say hey
where's the boss well the boss is not at
work today
cool right so don't work gets done so
that is a lazy evaluation as you can see
until a terminal operation is called it
doesn't expend any effort at all well
this really leads us to a powerful
construct where we can have infinite
collections as well and parallel
optimizations too if you are interested
in let me go into a quick example of the
infinite collection we can do very very
powerful operation and this also builds
on the laziness we talked about so let
me show you an example of how you could
be building an infinite collection let's
say I want to build a series right here
so what is the series I want to build so
I could say stream dart eaten rate and
in this case I can say start with the
one and given an element I want to
produce an element plus one
your logic can be very different in this
case I've created an infinite series
meaning I can start with one and give
you as many values as you would like
now of course you would always say how
many you want well filter given an
element I only want even numbers so we
said I don't want all the numbers I only
want even how many do you want well we
could say dart limit I only want ten
values and then you could say for each
simply print that value out for me so
system dot out and then print line and
you are able to print only the even
numbers from the collection so the idea
really is you are able to build really
nicely on a very nice set of lazy
evaluation baked into an infinite
collection as well now look at the power
of this particular mechanism here you're
able to eat a rate through and produce
as many elements hinging on the fact
they will only ask for a select set of
values not only can you do this now
you can convert this to parallel and you
can have this run across multiple
threads so to summarize what we talked
about the essential idea really here is
that as long as we maintain the
functional hygiene look at the streams
as an ability to go from a concrete type
to an abstraction flow through a series
of function transformation the functions
themselves are evaluated lazily giving
you the efficiency and you get to
configure different combination of
parallel versus lazy evaluation and then
you are able to produce a result you are
interested please go ahead in the second
stream of objects per se not predict
particularly integers but then there are
in stream that can also be very
specialized so it depends on the
transformation you apply so the idea
really is that you can merge together
some of these operations so where do we
go from here
stream
are the real charm when it comes to
programming in Java 8 and that's where
the real learning is as well in terms of
how we can put together with dreams if
you are interested the codes are
available on the download page you're
most welcome download I really hope you
found this useful thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>