<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Leveraging AppCDS to Optimize Application Startup and Memory Footprint in the Cloud | Coder Coacher - Coaching Coders</title><meta content="Leveraging AppCDS to Optimize Application Startup and Memory Footprint in the Cloud - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Leveraging AppCDS to Optimize Application Startup and Memory Footprint in the Cloud</b></h2><h5 class="post__date">2016-09-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dRw77QDSL-A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everybody here first thank you for
coming here today for the talk really
appreciate looks like my co speaker
cannot make it today probably his stuck
in the traffic so just i'm here to
present the application class data
sharing in the recent and future jdk
releases and discuss how it can be used
for your cloud environments first just a
little bit about myself i'm jang leto
and I've been working on the Java VM
virtual machine for a little bit more
than 15 years I started working on JVM
technology for the specific for embedded
platforms for more than 10 years then I
switched to work on the java hotspot vm
in the recent few years especially
focused on the run time and my primary
focus for the currently the runtime
performance and memory reduction and
this is a safe harbor statement just
that everything we are talking here
today don't count that as a product
release plan so what is the class leader
sharing that I'm going to discuss
the costs of cloud solution are largely
determining them by computing networking
and storage costs when we look at the
computing costs the total amount of
virtual ram deployed in the cloud can be
a big factor of the total cost so the
main focus of our today's discussion is
how to reduce the total memory footprint
and in the meanwhile also improve the
startup time for your application often
times the memory and runtime performance
especially the style time they don't
come together you either have to
sacrifice the memory usage in order to
achieve better sub time or vice versa so
how do we achieve being able to reduce
the runtime foot foot printer and also
improved a stop time at the same time
the class data sharing technology in
hospet provides an answer to the
question the casa de shearing approach
allows the Year JVM to preload a set of
classes ahead of time the class is
loaded by the JVM past the 2d into the
JVM Z private internal representations
which we call the class metadata the
oppressed metadata is split into the
read-only and read/write regions or
rewrite parts and they are allocated in
separator memory regions when the vm
finishes loading all the classes and
process all the class stayed on the load
across metadata is saved into a file
which we call the shared archive file
once you generate the shared archive
file you can run in the
next time when the JVM is being reacts
acute in the shared archive can be
memory mapped into the JVM runtime
address space the map Torito na pages
can be shared among multiple JVM process
that are running at the same time and
the map to rewrite pages also shared a
copy on write which means the pages are
shared until there's a right happen to a
specific page than the pages becoming
private to the process than the sharing
stops the JVM can look up the classes
from the map the memory region without
searching reading and passing the year
crassius from the java at runtime the
map past data can be used by JVM
directly with very minimum processing so
that helps reducing the class loading
time for the archive the classes at
runtime and greatly improves the startup
time for your applications the share the
class data that you can be can help
reduce the overall total memory usage
for your environment the class leader
sharing technology has evolved in jdk
before GDK au 40 classes assuring only
supports the core library classes loaded
by the bootstrap class loader in jdk au
40 application classes can also be
archived and shared class is loaded by
all class loaders actually angelica au
40 and GD k 9 some of the features are
only editor in GD k 9 so class is loaded
by all class loaders can be
hyped and that includes the bootstrap
class loader the platform class loader
which is the extension class loader in
GD k 9 and the app class loader the
default class odor and the user-defined
class holders in GD clean i we also
support archiving and sharing javelin
objects and we also provided a further
reduction in storage for archive the
class data this is a picture that
showing the CD s and the evolution of
obsidian series was introduced in GD k
105 that was about 10 years ago as i
mentioned that at the time CD s can only
support caching the classes from the
high that's my colleague y so sorry
about that just can you come up here
yeah yeah y do you want to briefly
introduce introduce yourself yeah
she odd hi my name is your land I walk
on the JVM wrentham team and I was part
of the team members that implemented the
application class data sharing feature
ok let's continue so serious was only be
able to support the core library classes
I mentioned earlier it's a feature
that's available in jdk and support all
platforms and the GC flavors in EO 40 we
enhanced CD s and added the support for
application class voters for
applications classes this is why we are
calling it application class data
sharing the absa diaz and angelica night
it will support the user defined class
voters and also support sharing the
stream objects with additional memory
improvements in both jdk au 40 and jdk 9
the AB CD s is a experimental commercial
feature and not available in OpenJDK
the software industry has evolved a lot
in the last decade especially in the
recent few years cloud computing has
become in the promise of changing the
way how IT supports businesses new
research from Harvard Business Review
analytic service use that there is a
correlation between the usage of cloud
computing and the variety of new
business activities so a lot of
attention has been focused on cloud
computing technology in the recent years
cloud based platforms such as the Oracle
Java cloud service using the Oracle
WebLogic server off around services in
on clusters of JVM instances the shift
to micro services in software
development pushes this even one step
further the micro services allows rapid
development of complex systems using
micro sized functional subsystems often
these subsystem are run on individual
JVM processes so in a complex system
youth my see hundreds or even thousands
of Java VM instances running at the same
time so these are the perfect
environment where AB CD s can help this
is an abscess architecture view here we
are showing to GBM instances running at
the same time for each JVM instance we
are showing the Java heap space which
contains the runtime heap objects and
the meta space which contains the
runtime allocated class data for both
JVM instances these memory and I shared
the brown box in the middle represent
the memory mapped
share the archive file when both jvm map
of the string objects from the maplin
memory can be shared by the VMS and also
the class data from the map the memory
region can also be shared so that helps
reduce the total memory consumption so
before I dig deeper into the app cdss
indeed here's I'd like to share some of
the performance results that we have
collected on with our work during our
walk we use the oracle weblogic server
and also some of the real world
applications to do the measurement this
one here is showing a the sub time
comparison when running single jbm
instance using the oracle weblogic
server based domain the top blue one
represent the start time for the weblog
server framework without AB cities and
the library one is the stop time of the
framework with obsidian so we are seeing
about thirty percent improvements in
this style time when AB CD s is used
and we see similar style time
improvements when running applications
inside the oracle weblogic server we
took samples using different numbers of
applications running inside the
frameworks so we compared the 0 apps to
all the way to 20 apps compare the sub
time with and without applications the
top chart here is the percentage of the
stop time improvements when AB CD s is
used we are seeing about nineteen 237
improvements in the start time with
running 20 20 applications inside the
framework and the bottom track is the
detail the start time numbers compare
comparing with them and without
obsidians we also measure the memory
footprint using the Oracle WebLogic
server when you have only one jbm
instances when you have only one JVM
instance running applications obviously
you don't have any sharing in this case
AB CD s also helps reduce the memory
consumption with better layout and the
compaction of archive the class datum so
on the Left chart we are showing the
memory consumption consumption with and
without obsidia so we are showing some
we are seeing some improvements in the
memory usage when applications classes
are sharing is used even for single JVM
instance when you add a share me into
the picture absa discreetly improves the
overall memory usage so on the right
side we are showing the comparison when
can JVM instances running at
same time using the oracle weblogic
server based domain so I'm the we are
seeing more than eleven percent in the
total memory footprint reduction with AB
CD s and we also measured the memory
usage when running different
applications and the services inside the
weblogic server and the two tables here
were showing two different to configure
two different server configurations each
service and application was running on
separated JVM instances so I'm average
we saw about five percent reduction in
the for each JVM instance as I mentioned
earlier we also measured the app serious
benefit using real-world applications
for example we measured the apache spark
big data frame work with k-means walk
and we're in 20 slaves at the same time
each slave were running on one JVM
instance an average we saw the stop time
saving was eleven percent for each slave
and the memory saving was ten percent
her slave on average with obsidian so
now I have shown you all the great
benefits of obsidia and you probably
wonder want to know how to use it to get
the full benefit of obsidia it's very
important to do profiling of your
specific application so we recommend
before you archiving the data running
the your application with
as low tracing enable them and obtain
the oil crisis load used by your
applications from the chasing and create
a class list based on that from our
experiences we found that strings and
symbols often use a lot of runtime
membrane so we recommend you attached
your application using the JC md and
dumped out the all the string and simple
data is used by your application and you
can save the string and the symbols into
a cock I've configure file and the data
inside the archive configure file will
be added to the archive once you have
the class list and the archive configure
file you can run the JVM with dash X
sheer dump to dump out the shield
archive in order to use the apps TDS you
need to specify the dash X X use apps
EDS and also unlock commercial feature
because it's not in public openjdk
feature you can specify your class list
and your archive configure file with the
command line options and you can also
specify the name and the way you want to
save your archive with the sheer luck
have a command line option by default if
you don't specify the archive file name
location the default location for the
generator the archive file is the JDK
Lib directory after you create the
archive file you can launch the JVM with
the dash X share um in order to use
the archive the data and you also need
to specify the use apps EDS in order to
enable the Obsidian feature and also
unlock commercial features you can point
it to your generated an archive if you
get into specify a specific location
when you're generating the archive you
can use the default location here are
the two links to the Obsidian related
documentation that in jdk a you for the
release notes now let's dive deeper into
the app CBS as I mentioned earlier that
Angelica 840 AB CD s supports archiving
and sharing application classes classes
for the poor loader extension class
loader and uploader can be a placeholder
can be archived and share while are also
adhering to the java runtime semantics
so at one time we make sure that the
archive the classes are still being
loaded them by the correct class loader
so how do we do that at the archive
dumping time when we load the classes we
tag each class with the class prototype
so at one time when a class loader is
trying to load in archival across from
the map memory region the JVM compares
the requesting class loader with the
loader type of the archive the class and
the class can only be loaded if the
requesting class loader type is the same
as the archive the classloader type so
for example if the app class loader is
trying to load the
java.util.map class which actually has
the bootstrap class loader attacked as
the loader type so in this case the app
class loader cannot load the
java.util.map class so in this case the
app class loader has to delegate to its
parent class loader which is the
extension class loader and then
delegates to the bootstrap class soldier
and the poster of class early is able to
load the java.util.map class in this
case so that's how the class loader
delegation powder is being preserved
even when classes for different class
loader is also archived and shared and
around town also class inheritance in
the class hierarchy are now changed when
classes for different class loaders are
archived the JVM does various checks at
runtime to make sure that's the case for
example if there's any updates to the
Java it will invalidate the archive file
so I mean the aquifer will no longer be
mapped at runtime also the runtime pass
pass I required to be compatible with
the damn time has pass the class order
has to be the same for both the runtime
and damn time and the order are
validated by the JVM at runtime also the
runtime cast pass can only be extended
by appending additional class components
to the end
when application classes are being
archived and share we make sure that the
Java security are still being handled
the same way these security checks are
either done at some time or runtime
security checks that use the static
information are performed at the alki of
damn time for example we pre verifies
all the application classes at some time
so at one time when the JVM loads the
archive because from the memory map
memory region it does not need to do the
full verification of the application
classes security checks that use the
runtime contacts as still being
performed at runtime for example when
the JVM is trying to load an application
class from the map the region it is to
do the loader constraint check using the
runtime information and also security
checks that use the protection domain
and security managers are still being
done at run time with obsidia we are
able to create the protection domain
very efficiently using the archive the
class archive the data without having to
reprocess the Java files
in JD Kane I user-defined class loaders
will be able to work with AB CDs without
changing their existing code the class
loader delegation and class file look up
completely controlled by the
user-defined class voters and then they
will not change when classes for the
user-defined class stories are being
archived so user-defined class order may
change the class lookup order or look up
location from different executions that
means class is loaded in each different
execution might be different so when we
archive the classes we need to make sure
that at runtime the classes from the
archive actually the ones that we want
to load at runtime we do validations
using fingerprint match in order to make
sure that so at dump time for each
classism for the user-defined class
loaders we compute checksum using the
hot spots and we called you checks on
the fingerprint the fingerprint is saved
with the archive the class at runtime
the Javas on the class loaders paths are
still being searched and has bites are
really from the Jaffa so the JVM
recompute the checksum using the bike
whole read from the java at runtime and
compares the checksum with the archive
the fingerprint so the archive cast can
only be loaded if
the fingerprint matches for the current
class and all its super types so if for
any of the fingerprint does not match
the jvm will refuse to load the archive
the class so in that way we guarantee
that the class is loaded from the
archive example some time at runtime is
the right class archiving the class for
user-defined class voters can also help
improve the runtime class loading of the
class by pre passing in pre verification
pre layout of the class metadata at some
time and also it can help reduce your
the overall memory usage with shearing
Your Honor to support the user-defined
class voters we enhanced the class list
with additional informations the
information that we added it to the
class list include the supertype
information the class source information
so here we have an example of the new
class list format for example we have
the javelin object with the class ID
it's just a random number that doesn't
really have any meaning but for each
class the ID has to be unique and then
we have the interface 1 and interface to
with both the super type is the javelin
object and we also specify the source of
the interface 1 and interface to then we
have the parent class and the child
class also the supertype information and
the source information also specified
for those classes so the new class list
will be used in jdk 9 most of you
probably all of you here are already
aware that jigsaw is coming in GD k 9
with the jigsaw modular system it
provides modularity beyond the
traditional java and packaged concept
standard class loading facilities using
the classpath are now extended to
modules classes can be loaded from new
locations for example the modular
runtime image the module pass etc in GD
can I apps tedious will be able to
support archiving modular classes from
the modular runtime image and we may
support archiving class
is in modules from other locations in
the future for example the module pass
with the jigsaw modular system the
classloader visibility boundary is
determined by the modules defined within
the class loader the visibility boundary
at this site I decided by it decides
whether a class can be loaded at runtime
in JD Kane I obsidia swear AB CD s
archive and share classes from modules
from the modular runtime image it needs
to respect the visibility boundary when
loading archive the classes so at
downtime the consoler type for the
module cast from the runtime module
image is shear is also saved with the
archive the class at one time the loader
type is being checked and also we
checked the runtime visibility using the
modular information defined by the class
loaders in order to make sure that the
we are loading the correct class fra for
a specific class loader
so in JD Kane I strings in constraints
can be archived and I shared this
feature supports the g one g c and it
requires the compressed object and it
has pointers on 64-bit platforms at the
archive damn time java.lang.string
objects reference to from the string
table and the underlying value the
actually the character array objects
allocated them in a special hip region
which we call the archive region the
data in the archive region is also being
written into the archive file when the
JVM write create the archive file at one
time the string data in the from the
archive can be mapped at the runtime
Java heap it is not required to be
mapped at the exact same location as the
damn time but the archive the archive
the string data can be mapped at the
same offset from the runtime Java heap
base we require that the same compressed
objects and has codings used for both
year runtime and some time in order to
make sure that the pointers pointing to
the string data remain valid in at
runtime so we have the JVM does various
checks to in order to make sure that's
the case
we've done works to make sure to reduce
possible rights to the map the string
data at runtime these string objects in
the map archive hip region are
considered as pinged GC does not compact
or collect the string objects inside the
archive region at runtime so the GC does
not write into the archive region at
runtime at all we also precompute the
hip region other the hash values of all
the objects inside the archive region at
some time unit to prevent right to the
string data so the only possible rights
to the string a cheerless string data is
synchronization on stream object so if
synchronization is eliminated or you can
make sure that for al-qaeda crowd
strings you don't synchronize on them
then all the string data inside the
archive region can be completely shared
by multiple JVM instances running at the
same time by default only the strings
used by classes that are loaded at some
time are being archived on but you can
add additional strings based on your
profiling results you can add a string
to the archive configure file and these
strings will be added to the archive at
damn time
symbols jvm internal strings that
represent class names messe names and
field names symbols used by classes at
the damn time also archived in jdk au 40
we also support additional symbols being
archived them besides the ones that used
by the classes so you can add based on
your profiling result you can add
additional extra symbols to the archive
configure file and they will be included
in the archive this is an example of the
archive configure file in AB CD s in the
sample configure file we are showing
both the strings and symbols so here we
have two sections existed them the
string section starts with the ad
section stream and followed by the list
of the strings the numbers before each
string indicates the length of the
string and the simple section starts
with ad section symbol
in both jdk au 40 and JD Kane I we've
done various works to also help improve
the shareability and reduce the archive
the class metadata with compaction we've
made the shared a symbol table and
string table completely read only and we
use the compact format for the sheer the
string and symbol tables so comparing to
the runtime string and simple tables
these archive the string and symbol
table are much smaller we also use the
trampolines for interpreter and the
compiler invocation entries in archive
the method in order to avoid any rights
to the archived methods also we use
special no fast up code in the archive
the classes in order to avoid any rights
to the Java bytecode the archive the
back hold at run time if you want to
find out any of the details you can go
to the OpenJDK bug ids that i listed
here for each improvements
so that's pretty much wraps up for all
the today's discussion about at CES
here's the addy contact information so
if you have any questions related to
product obsidians you can contact on our
p.m. aurelio or if you have any
technical related questions you can
contact either you or myself I I have
the email address for bosses listed here
so now I'm open up for questions if you
have any questions please feel free to
ask yes please
can you repeat that question yeah yes so
AB CD s so the question is the Obsidian
is experimental and is there any plan
that it will be a product is that
correct yeah so yeah so currently the AB
CD s in both jdk au 40 and the coming up
jewdick and I release it is a
experimental commercial feature so for
any possible plan I think it's still
being determined by the product
marketing on the project manager so I
don't have any information and now so
but you can contact a relief for that
yeah so if you have any question you
want to find out plan or that you can
talk to him or email him yeah sure go
ahead
yes
so the question is currently we are
supporting loading the archive file from
a file system is it possible to you also
load the archive file from networking
locations yo do you want to answer them
well as long as you're your network file
system is reliable I don't see any
reason why you cannot do that we have
seen cases where if you have your NFS
set up incorrectly sometimes you have
issues but that's that's add a layer
lower than than the TV yeah yes
we haven't actually tested any for any
cases like that but if you specify a
networking look place that if that's
possible can be readin I think it's most
likely doable but we haven't done any
testing so don't take our word for the
head yeah
Oh
it depends on how you configure your
cluster so we have cases where we have a
bunch of docker containers running on
the same physical hardware and we can
share memory across the dock go ahead
so that's a very good question i
actually just integrated in my fix for
that yesterday I actually moved that the
weekend so when JVM TI modifies the
class we do support that so at the
archive down time we save the class
stream the class data with the archive
and at runtime if jbm agent transform or
redefines across the outcome the mapped
memory is being remapped as rewritable
and it is able to support transform the
class but if a class is being
transformed or redefined by the JVM
agent we do not we no longer use the
archive the data because the archive
data does not have the modifications we
will use we will create a new instance
class which contain which contains the
modifier class bytes so that's the case
only for the particular class that you
modifies it for the rest of the classes
that's not being modified they are still
be they still can be shared because you
are not writing into the shear the class
yeah oh go ahead piece we can so the
question is we can also define class in
Riccione data I'm not sure if I
completely understand your question so
you're saying that you want all the
classes that should be read only and not
rewrite is that your question currently
we still have to have some of the class
to be writable because at runtime we
need to write into the class for example
we don't create the Java mirror instance
for a class the instance is being
created at runtime so at runtime we need
to write the pointers inside the archive
the instance class to point into the
runtime-created a mirror instance so for
some of the data we still need to ready
right into that's the reason why we
separate the real ohne and rewrite paths
so that way we be able to share more
data instead of having the read-only and
a reader rewrite spa I mean mixed
together so does that answer your
question okay thank you
so let me try to repeat the question so
if a OT changes yeah I oh dear I know I
think you're asking about like their
runtime frameworks that will inject code
into loaded classes such as spring how
would the impact be so if if classes are
modified at runtime either by JVM TI or
by by other means then those classes
will not be shared across processes
right yes yes it's all handler
transparently for the whole base you
your framework will not modify every
class then most likely so can I ask a
question what is the aod the one that
you are mentioning okay
okay yeah I think in that case it's like
the question that I answered earlier
with Libyan TI modified the classes yeah
it's handled Oh transparently only the
class that's being modified we no longer
be shared for classes that are not being
touched the remaining shared so looks
like there is no more question I think
that wraps up our talk thank you
everybody</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>