<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Effective Foreign Function Interfaces: From JNI to JNR | Coder Coacher - Coaching Coders</title><meta content="Effective Foreign Function Interfaces: From JNI to JNR - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Effective Foreign Function Interfaces: From JNI to JNR</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DMkxu_v-9vA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">first of all thanks for coming my name
is Ryan shampoo Coney I'm from IBM this
is Tom and a bow from Red Hat and almost
got that wrong and we're going to talk a
little bit about Jay and I and a little
bit about jnr and hopefully at the end
be able to hold hands sing Kumbaya and
come to some sort of conclusion as to a
way forward so to start with I will say
that this is not you know a from the
beginning point Jay and I tutorial
hopefully you have that least some you
know experience I want to talk a little
bit about you know background why you
want it and some best practices and
common pitfalls that you want to avoid
and once i'm done with that will turn it
over to Tom and he'll hit it off with
jnr and give you the rundown on that and
again like I said hopefully we'll be
able to come to some sort of conclusion
I'm sure Tom will have a very similar
slide like this for lawyers this is me
if you don't know me that's fine I have
a fancy title that means nothing
actually makes it sound like I do less
than I fact I even do I've been doing
this for a while 18 years doesn't make
me an expert just makes me a
battle-hardened and tested garbage
collection interpretation all these
types of things I've been doing for like
I said about 18 years or so this is
where you can hit me up I've done a few
talks already here this week this is my
last one so I'm really looking forward
to 5 30 because it's beer time beer beer
o'clock yes and I know tom toms probably
yeah maybe probably all right ok so I'm
going to take hopefully you know at most
25 minutes of your time and then we'll
just turn it over to Tom so it's gonna
be like a 50-50 split what should you
get from this part of the talk so what I
really want to convey here is why a
foreign function interface is important
something like the Java native interface
Jay and I why is this something that you
know we actually want to care about and
why should you actually think about if
you're going to use it why is it just
not a simple matter of hey here's the
api's I'll just call things and you know
how about it and it's really easy and
everything it'll just go right you know
I've seen a lot of Jay and I code on a
customer code that actually just has
fundamental flaws and it very
experienced developers and so I just
wanted to cover a few things that I've
seen some of you might go yeah you know
of course I know that but I do see this
a fair amount just you know keep your
keep your eye on things you know make
sure things are happening properly
and it'll all go smoothly all right so
hopefully at the very least I mean this
is the end of the day it's wednesday i'm
actually really surprised with this many
people in the room as it is so let's
just try to be entertained right i mean
this is a fairly small room i don't want
to annoy too many people and like i said
i'll be done in 25 minutes turn over to
Tom so let's just relax sit back and
hopefully we can feel your brain with
with fun things all right so why is an
FFI important and you know we won't
spend too much time on this but if you
have you know if you don't have a
foreign function in the face this
actually makes a lot of you know what
you can do with the language fairly
limited and not very interesting right I
mean there's things like files did you
want to access sockets you know the
display being able to put nice little
pictures up accessing memory being able
to allocate it manipulate it so on you
need to be able to get outside of the
language and down to the native layer to
be able to do interesting things one
might argue that you could have you know
language libraries that are built and
they know how to get down to the native
layer to do all these types of things
but then you're kind of locked in so you
have a situation where if there's new
functionality your function I got missed
there's no way for you to actually get
out there so you know being able to have
a nice you know standardized
representation for how you actually
interface with the platform is hugely
important now that's really kind of the
major reason but there are other reasons
that exist out there and this is
certainly not a comprehensive list one
for example is legacy system support you
might be coming from an environment that
has lots of say native libraries written
in C right and there's no way for you to
actually port this bring it into job in
a timely fashion you want to be able to
use it as is you may not even have the
source we certainly encounter customer
scenarios with that customer scenarios
like that where they literally have to
go to the native interface go out to the
native platform in order to access that
functionality so you know being able to
support legacy systems it's important
and this includes things like
cross-language and crop or any really
cross functionality interop that exists
outside of the language right so I
really kind of covered these types of
things but one of the other major ones
that you might want to actually get out
to the native interface is for speed
now that isn't necessarily because you
can write your native code faster I mean
it might be a situation where you've got
a bunch of data coming in from some
other process it's in the native space
and you don't want to spend all this
time marshalling it back in you want to
do the processing out in the native area
there's things like that too right
you're not necessarily locked into
saying well I know how to write this
native code that's how you make it fast
it could also be just one of these
things where you want to bypass the
whole job you know millions of objects
problem be able to get the answer right
then and there so speed is another
mostly critical one that exists but you
know and I know I apologize for not
being able to read this but you know
really the one of the motivating
examples is really you know something
got missed or new things come up right
like in Java get your process ID right
it's not something that's actually
available you have if you want this you
have to go and write it now this
function exists on the platform but
getting to it is actually kind of
difficult right I mean you you know if
you can't have if you don't have a
foreign function interface how do you
actually now get this data it's it's
like really annoying you can think of
something else like if you've got some
hardware acceleration like some you know
bolt on device that you got to your
machine that you want to be able to
access if you can't get to this thing
hmm makes things a little bit hard so
you know the motivating example here
really is look I missed something or
something news come up how do I make the
call out now hopefully hopefully people
look at this and they recognize it i
mean this is a very simplified version
of what's a sub J and I call a Japanese
interface call example would look like
in Java you'd have a very simple class
it would load the library it would
actually say well here's the library
that I expect my native functions to
appear in you declare the function that
you're going to call as being native
doesn't necessarily have to be named the
same as what you're eventually going to
lead to calling because in see you you
have to actually have almost a rapper or
a shim between the Java side and of
course the native function that you're
trying to call you can't nest you can't
actually call things on say the C
library for example directly you've
actually got some naming symbol lookup
mechanisms that exists in Java that you
look up based on your class name and the
method name and so on and we prepend
Java underscore in the front
we find that and then from there you can
do the right thing so there's reasons
behind that we'll get to that in a
second but it can pose a little bit of a
problem and that's something that Tom
will start to talk about a little bit
later and it is something in the end
that I kind of complain about a little
bit I'm a complaining guy alright but
what are the benefits so I just I
started to talk about negative but let's
back off for a second second well what
are the benefits of the Java native
interface right the first thing is that
it's api-based you're not stuck in this
situation where you're saying okay well
I've got some H files or something like
that and I've got to run it through a
preprocessor and now their version
dependent and maybe their version
dependent on the vm and every time I
have a new version of the vm I've got to
recompile or regenerate on my coat it
basically uses a bunch of API in order
to accomplish the schools and this is
actually really important because I can
have a jni library that I compiled
against a job of five for example and
it'll still run against Java 7 ok this
is actually really nice now GC safety is
another one if out in the native space
you had to maintain the fact that I've
got all these different object pointers
you know I got called out with an object
I want to fetch a field as another
object that's got some data that I care
about and so on telling the GC both
these pointers everything can get really
complicated ok you don't want to be
managing that you want that to happen
for free for you and this is one of the
things that Jay and I provides you never
actually get direct or I won't say this
but you get effectively object handles
that the GC knows and understands can
say look you can pass these around and
do things with them there are certain
rules but if a GC happens underneath you
we move that object don't worry about it
it's completely invisible to you you
don't need to know that this is
happening based on that explanation
another interesting aspect is that from
Jay and I you do not block activity in
the JVM so when you call out to the
native interface and you go make a call
out to a native function you aren't
blocking any other Java activity from
occurring in particular GCS just because
you've got object handles out there
doesn't mean a GC can't happen that's
why they exist right to create this
opaque structure that you have need
api's to operate against so JC's can
happily occur while you're out in the
native space you're not blocking the JVM
and this is this is fantastic right i
mean those of us in some languages i
mean you call it to the native interface
that's the end of it right nothing else
is happening
and you gotta wait till you come back in
in this particular case no there's a
bunch of other things to pack but it's
mostly platform-agnostic more or less
right you can write J and I code on one
platform take it recompile it somewhere
else since you know probably going to
recompile cleanly depending on what
functions you're effectively getting to
makes nice clear lines once you're out
in the native interface there isn't this
blur about accessing data structures and
so on to get back into Jabba to really
again nice API and finally a very minor
one but important is that Jay and I does
form the foundation for some tooling
like JB MTI thanks for like the debugger
and profilers and so on all right there
will not be a quiz on this list later
and this isn't even complete it this is
is not even complete really what I want
to say here is that look here's a lot of
the functions that exist you get a lot
of the core building blocks to really
build any kind of Java functionality
that you normally could in the java
space you can do things like define
classes and look up classes and look up
like fine class the third one up there
will actually do a load right there's
other categories of operations you can
handle arrays you can take objects and
get fields right method dispatch all the
things exception handling all the things
that you know and love are there really
okay one thing to really notice here
though about all these functions and to
remember is that the first argument for
almost everything is JN I and J and I
and structure and this is important
because the jni end is basically your
lifeline back to the vm this is
basically the token that represents your
thread that has made it out into the
universe okay so that token is
responsible for getting you back into
the vm to say hi I'm a thread and I
would like back in and I can do
operations this is the basis that you
make API calls against as well it's a
level of indirection off of this
structure and based on all that the
thing to remember is that because all
this API is back into the vm right you
have to basically go back into the vm to
find a class you have to go back into
the vm to get a field and so on it's a
round trip so one of the things to
remember and I'll cover this a bit more
is that every time you make one of these
api calls it's a little bit of a
performance hit it's not as easy as just
making a quick function call one
instruction
coming back there's a lot of work to get
out of the vm to your function and a lot
of work to come back in to do
functionality right even if it's a call
another method or do some very simple
operation like finding a class not a
simple operation but maybe getting the
feet getting a field ID or something
like that or getting a field from an
object right every time you do that you
have to go back into the vm go ok I've
got an object here I need its field you
know stop whatever you're doing don't
move objects on me I'm coming back in
now I'm Java and you've got to do a
whole bunch of work so we'll cover that
a little bit more but remember every
time you make these api calls it can get
expensive so you want to minimize this
Tom sitting there losing his mind holy
god what's he saying can't believe it no
no not bad ok good so far good one of
them many famous JVM quotes right there
along with totally bogus never been
tested should probably work anybody ever
hear that around the office or something
similar all right performance pitfalls
I'm going to whip through these fairly
quickly because I do want to get Tom up
here to talk about Jana I think it's
really important the first thing that I
end up seeing a lot in terms of mistakes
being made is not caching classes method
IDs and field IDs these are things in
Jay and I that you can actually cash you
can look them up and say okay I've got
at once I don't need to look it up again
right these things are effectively
resolves right it's a lot like in Java
like the first time you look up a class
or the first time you actually go after
a field it's a little bit slower the VMS
got to do some work to figure out well
you here's the named field but you know
here's the offset that I need to get to
and once you do that once you're okay
don't bother looking it up again because
it can actually get extremely expensive
right fetching a field is like really
just an offset right one instruction
practically figuring out where the
offset of the field is can be very
expensive so you don't want to
repeatedly do that so cash them here's a
very basic example of what's a ID use
would look like so the first thing is is
that we go we find a class by name right
check for the exception and someone's a
lot of error handling here then from
that class we say ok fine I'd like up
static method i'd not setting a field
but rather running a method here i'd say
ok fine i need
find a static method called set info
it's got one parameter returns void and
then finally I can you take that ID and
make the method go the static method
call all right pretty standard J&amp;amp;I right
this is what it ends up looking like and
if you're just doing this this is a
once-off thing then how about it right
don't worry about having to catch
anything just go right ahead and do it
but a silly example to illustrate my
point okay is something like this where
we call it with an object and we say
okay I would need the class for that
object I need to get all the field IDs a
through f field names and then I'm going
to take each one and I'm going to fetch
that field and then finally going to add
up those values in return it okay a very
simple kind of almost silly example why
would you go to the native space for
this but for illustrative purposes
however this is hugely inefficient right
you aren't necessarily going to get the
same result every single time for get in
for the get infield things but you will
get the same result for get filled and
get object class all the time so why
would you do this over and over again in
particular of this method is called all
the time right so instead you should be
looking at cash yet and getting rid of
all those other calls and just saying
well just use the method of field IDs
that have already derived in some static
variables okay first thing remember to
cash if you're doing things over and
over again now taking this and running
it into some sort of crazy loop like
running like a million times or
something like that on my laptop there
was a 24 X performance difference just
by doing this right now you might say
hey look all you did was cut those calls
in half right there were like about 12
actually 13 calls and you cut half of
them to get field ID calls the important
thing to remember here is that getting a
field is far less expensive than getting
the field ID so 24 X is not a real
surprises a lot of work and doing those
types of things cash alright on that
note let's continue with that example
reaching back for parameters right we
all hate huge function prototypes right
typically what you want to do is you
don't you don't you know take an object
grab all the fields out of it and pass
them as parameters and then have some
functionality happen on those things you
usually pass the object and try to send
methods to it or get fields or someone
and then operate you pass the object
then get the data now you want to
this but you have to think of the round
trip cost for Jay and I in some cases
it's actually better to call directly
out with the values that you care about
and that you know are going to be used
so pass them out you have to use balance
it's not always the right answer design
versus actual performance always in play
but this can make a big difference so
let's take go back to this example again
I say get filled all the time on this
object well if I have that object why
not from a performance perspective just
actually go and get the fields directly
and pass them out as part of the native
function call right yeah you've got a
little bigger prototype needs a bit
uglier and we've always been taught geez
don't pass a lot of parameters you can
get really expensive but calling back in
with this Jay and I API all the time is
actually far more expensive as a result
okay so instead of doing this do this
again balance right design form function
you know put all these things in
perspective but ultimately right this is
going to run a lot faster in fact again
on my laptop running it like a bazillion
times and so on what you end up seeing
is about 6x performance difference right
not really a surprise i cut out six
function calls yes they're a bit more
expensive than just actually fetching a
field but it kind of gives you a sense
of you know what kind of benefits you're
getting again if it's a one-time call
hmm but if you're doing it all the time
definitely consider it alright
triggering array copies I'm only going
to really talk about the first to hear
get array elements in get array region
you really have to be aware of the cost
of copying some of these functions will
sometimes copy arrays and sometimes they
won't okay and those costs can get in
the way and sometimes you'll see people
say well you know I use it and it
normally doesn't copy but they're
dependent on the vm vendor they're also
sometimes dependent on the GC technology
being used this is very very important
when considering what you're trying to
do and what the resulting performance is
going to be so taking an example like
this where I want to get one element of
an array people typically go for the get
array elements call right there's two
things going on here one is that I just
want to fetch one element out of here
and they'll somebody will call get long
array elements right get the whole array
go fetch the individual element release
the elements and then return this is all
well and good if the array is not
actually copied but you can't always
guarantee that and sometimes it is and
this could be a huge performance loss
especially if the arrays got a thousand
a million elements in it okay don't take
the chance why are you doing this
instead there's a thing called get
longer a region that does copy all the
time but you can say specifically go get
me the location that I need so instead
of taking the chance of copying the
entire array I see this all the time go
get the specific element that you care
about and come back it's one API call
yes it's a copy which you were doing
anyways by fetching the element out of
the array right so you have to think
it's very easy to fall into the trap of
yeah I get array elements that's fine
you know it doesn't copy or the last
time I use I didn't think it copied and
you know whatever hey calling out the G
and I slow anyways who cares you know no
think about it there's the opportunity
here to actually you know keep things
fairly optimal now again this number is
pretty bogus because it really depends
on the size of the array and so on I
think this is about a thousand elements
I can't quite remember but still you
know you'll end up seeing these types of
differences if you're getting copying as
a result okay and free performance again
just just be smart about things alright
last one in the performance track here
or common performance pitfalls local
reference abuse right every time you
fetch a field from an object that's
pointing to another object you get a
local reference to that out for that
object it's the handle so you know get
feel that's an object you get another
local reference it's really easy to
ignore these things right you know when
you were any java code you don't worry
about only i fetched a field now I've
got something else I've got a you know
managed and so on so this is the one
area where you know you have GC but you
know I've said that this handles a lot
of the GC isms but in this particular
case you really have to watch out for it
so you know incriminating code that I
typically see is something like this
right we'll go through an object array
and we'll get each object array element
out and we'll end up doing something to
it right well do some processing maybe
send a message or something like that
but we don't clean up the resulting
handle so this J object element they see
here coming out of get object a tray
element needs to be managed all right
now you might think okay well this is
maybe a correctness problem sure but as
you increase as you keep allocating
these local references this does things
like punish the performance on the
garbage collector not only because
you've got more things for it to scan
but also you're keeping more things
alive you haven't cleaned it up so now
this object if that array is being
manipulated and other things are
happening there's no opportunity for
those things to actually be garbage
collected if there was a chance instead
remember you know clean up after
yourself right this is a bit more
involved in standard Java you want to
actually be making sure that you are
deleting references when you are done
with them and understand when you are
creating them this is something that
isn't really always well understood or
seen another common vm quote heard in
the hallways well I ran didn't it sure
okay just a couple here I'll whip
through these okay let's go back to the
race stuff for a second getting copies
is it's more than just understanding it
from a performance point of view it
actually can be a correctness issue as
well when you're using these api's they
do fill in a slot that says did you get
a copy or not now this is important
because in some cases you won't get a
copy it's a direct pointer on to the
heap to the data in other cases you will
now why would this matter if your live
updating the array and you're expecting
that to show up on the heap immediately
for say other threads to use you may or
may not have that be happening for you
okay again a very common error that we
see is not actually using the API
properly short-circuiting things and it
working in one case and so that must
mean it works in all cases right you
don't want to take shortcuts I've talked
repeatedly about making round trips and
so on that doesn't mean you can
short-circuit correctness okay or that
you should so you know looking at
something like this right getting your
right byte array elements again the
important thing here is is
copy right well tell you whether you got
a copy or not so that buffer at index
zero assignment of one I mean are we
really guaranteed that that's actually
going back to the byte array that we're
talking about maybe you don't want it to
go back maybe you do but in this
particular case I'm not necessarily
certain I could tell you without
checking that variable which just hasn't
happened here okay so be aware of this
aspect of the API you can potentially
get a copy act accordingly based on what
you're expecting to have happen that's
the important thing here right there's
different scenarios that you want that
you want to get that you could possibly
consider remember is it a copy so again
you want to do something a little bit
smarter release byte array elements does
not necessarily free the pointer in that
case it can actually do things like look
if I have a copy push the copy back okay
I but still keep a handle on things it's
completely valid if it is a direct
pointer don't do anything alright
critical sections this is one that
really bothers me because in fact the
thing I'm telling you don't do because
you can't you in fact can do sometimes
and it's just a mistake to do it okay
critical sections exist what what these
are as they say look I really want a
direct reference to the data of my array
on the heat because I want to manipulate
that directly and I'm signing up to say
look I'm very potentially going I want
to lock that onto the heap I want it not
to move and I can have serious
implications from garbage crushin can't
move the object may not even be allowed
to garbage collect at all at that point
okay so it's a huge implications one of
the rules with these critical sections
about get array critical and you know
release is that you cannot do any other
job of functionality or j anat you
cannot call any other J&amp;amp;I functionality
at that point remember that it turns out
you actually can succeed doing these
things but please for the love of
everything do not okay i really
recommend it do not do this so the
example here is get primitive array
critical right you go out and get a
bunch types of byte arrays or something
like that yep j bite here and this
process buffer helper should really stay
very far away from doing anything that
interacts back with the JVM again okay
until you call the release then you're
back to normal you've done things like
block potentially very important
garbage collection operations two quick
ones finally check your exceptions right
a lot of these api's call fire off
exceptions if you're not checking I
countless code that i see that does not
check exceptions yes it's a cost but
make sure you know it you know you have
to handle these things you have to be
prepared for the worst so checking your
exceptions are hugely important and how
many bugs and problems have we seen
where people were not checking
exceptions I have lost count okay it's
really hard because you're typing the C
code in and it's not like in Java right
where you typing it into an IDE and it
you know you know you're calling
something that says throws whatever and
it tells you hey look this thing says
throws you better either try catch or
you better you know propagate right we
don't have that situation here so you've
got to be you know more cognizant of
these things when you're doing it so
example here right we get the object
class of some object then there's like a
field ID that we're fetching we're not
actually checking the exception does
that field even exist are we doing
something to handle it that code instead
should look something like this okay
checking the exception make sure you
check following on that check your
return values right there's a problem
here double slash in the class name
right what's quick what oops no crash
undefined behavior check your return
values two more quick ones maintain your
global references global references are
different than local ones I just want to
put this in your heads if you're not
fully aware of them local references
typically get cleaned up when you leave
when you return from the scope of a
native call so a lot of people get
abusive with those things they don't
clean them up but then they return the
JVM happily does all the work for you
you can get away with that one global
reference is not the case the big
problem there of course is that if you
create a global reference to something
keeps it alive forever right forever
ever if you lose that global reference
and can't do anything about it okay
finally
the source of countless bugs use the
correct ji and please don't cash this
you're given one on call out that's
yours that represents your thread using
some other threads jni and can cause you
i host of problems okay so please don't
people are prone to cashing this you
know the example is when you're getting
a call back right and you're like oh
well I didn't have a Jane I am because I
got some call back to something and I
just want call back into the JVM I
cashed one no make sure the callback is
going to pass you back that data as part
of the onion the void star user data
alright i'm thirty seconds over what I
told Tom I was going to take and I just
saw that he's not climbing up behind me
ready to stab me so quick final thoughts
here J&amp;amp;I is good but it's certainly not
great okay and sometimes it really gets
in the way you can't do direct function
calls right and that we're going to you
know Tom's going to you know totally
dive into this but it's really annoying
look I got the sea the sea function I
want to be able to get to its in this
dynamic library I just want to call it
directly Jay and I doesn't let you do
that you've got to write some rapper to
get to it speed right Jay and I assumes
the worst in a lot of cases right it
actually says how I'm going to expect
you to go out and expect you to have
objects and you've got to you know do
all these smart things but I gotta make
sure the GC is going to be okay with you
and you might ask for fields and get
other objects and global references and
so on so it really it does a lot of work
to protect you but that work is a cost
from a performance perspective calling
out can really really get in the way
marshaling data is not great now i'm not
talking about int and float and so on
that's easy but when you're actually got
a bunch of data that you need to
reconstitute back as an object back in
your heap that can get really ugly okay
from a performance perspective so it's
just not great there's other aspects to
unsigned types you know how those things
really work again complex data where you
actually want to get back in and
optimizing the interface is tricky okay
there's little gotchas little you know
issues here there and everywhere they
can kind of creep up and get you and
you're really stuck deciding hmm is it
really going to be an exception thrown
here i really know this field is here
maybe I can just get away with it and
it's like you know your funeral by not
doing these types of things but then i'm
telling you you know your trading
performance for correctness right it's
like you you want to fat know you want
it fast and it's like well what do you
mean like fast complete
you're fast to crash depends how come
you know how much of a gambler are you
right so one thing I do want to do a
little advert I did a talk earlier this
morning I actually recognize some faces
here so thank you welcome back packed
objects this is one story from
marshaling data in and out of the heap
this is although it's an IBM special at
a moment there's more and more ongoing
discussion about how to do these types
of things every major vendor Oracle's
got kind of discussed discussing
solutions for these types of things as
well does as well we do you know
ultimately we need some sort of story
that that is common to everything so you
know although this is an IBM project
right now it's certainly not meant to be
you know forever blue kind of thing
right this is something that we want to
push out there some resources you can
get them on the slides later and on that
note Tom I will turn it over to you yeah
yeah sure get another way
let's see how well this works should tom
and i strangle each other
one thing I just realized is how much it
sucks to program and see I used to be a
sea program or many years ago and it's
just not a lot of fun to use jni a few a
few handclaps great I'm Tom in a bow I
work for red hat and I work on JRuby I'm
going to be talking about a project
today called jnr this is something that
came out of the JRuby project it's it's
written by someone named Wayne Meisner
and quite simply jnr is just a set of
Java libraries that allow you to load a
dll and just call a see methods on it
the important part here is that you
don't have to write any C C's painful we
just sell live for 25 minutes so let's
just jump into a simple example it's
going to look familiar to what you saw
earlier we're just going to call get PID
on Lib C so the first thing you have to
do is you have to go and define which
methods you want to call on the library
that you're going to load then you load
that DLL in this case we're loading Lib
C and and we're mapping that interface
we just define to that and then we call
it is it too easy it's it's pretty
awesome and it actually is just this
easy which if you've used jnr or another
popular library je na i think everyone
asks this question why doesn't Java
provide this already and with some
soul-searching I think it came down to
this acronym when Java first came out
this was literally in every other
sentence in a Java article and Java
wanted you to write everything in pure
Java now of course um you you can't do
that in all cases if you need to access
as Ryan was saying some special hardware
interface or need to access something at
the operating
system you have to have an escape hatch
of some kind and so they create a Jan I
and J and I is is fine i was just
knocking see but i don't really have a
problem with it but i think it was
somewhat intended to not be easy to call
out because they really wanted to
develop this java ecosystem
unfortunately it's been this way for 20
years nearly um maybe five years hell
maybe ten years it might have been okay
but this needs to change but at least
there's a library like jnr to make
things easier so let's just talk about a
few differences versus J&amp;amp;I the obvious
one is you don't have this extra compile
time activity you start up the JVM you
load the dll you try to call something
that either works or it doesn't and so
that's sort of an advantage to Jay and I
as you do have this this compile phase
this dev time activity where you
actually do shake out a lot of problems
so good on jan i and j NR it's not a
total gamble if you're going to go and
call see method you probably know what
the struct looks like you probably know
the parameters of the method you're
probably going to get it right but it
there's always that little randomness
that if you do it wrong you know set up
the JVM and it's going to crash although
a good thing in jrs favor is wayne
Meisner wrote it he's a jni expert if
you actually have to go and write your
own jni program odds are you're going to
make one or more of the mistakes that
Ryan was talking about in this talk so I
think you're better off going on a
higher level abstraction I think this is
is fairly huge benefit and jrs case most
see functions that we've been calling in
JRuby the signatures are identical
across every operating system you make
so you write one java program bind to it
and it just works everywhere if you need
to support multiple operating systems in
J&amp;amp;I you have to set up cross compilers
you have to compile it everywhere
if you find a bug oh now you have to
compile it everywhere again to go and
update even if the bug only affects one
system here's the platforms that we
support um if you actually see a
platform that's missing here you can
file a bug and will work with you to go
and expand our support oh and lastly
this is really really really hand wavy
jnr is probably a little bit slower than
Jay and I after all it's it's written in
terms of jni so you wouldn't expect it
to actually run faster than Jane I and I
stole Charlie's perf slide of calling
get PID this is kind of a okay I'll
start out by saying um in this
particular case jnr is running about
fifteen percent slower than Jay and I
for an incredibly simple method now it's
not really measuring a lot and it's not
as bad as it looks having a fifteen
percent difference because it's
essentially just grabbing this static
value and returning it so the only thing
is being timed is jumping from Java and
to see and back again it's really not
doing any work presumably if you're
calling it to see maybe you are doing
some coarse grained API that's actually
doing a substantial amount of work and
which case this is just noise then there
is a funny thing though there's an
ignore error annotation that you can add
on to the front of bindings and in this
case it's saying well I don't really
care why get PID failed don't try to
save any information associated with it
so it strips that out for whatever
reason with that stripped out the jnr
version actually runs faster than Jay
and I don't who knows so I guess the
takeaway here is don't worry about it
it's fast enough so jnr isn't just a
single jar it's a set of projects
I'm not going to talk about jmf I or lib
ffi because they're way too low level
and no one here is ever going to use
them I will talk about these packages at
the top towards the end of the talk but
the main the main meat and potatoes of
this talk is if you want to go and call
your own dll you're going to spend all
your time in jnr ffi so let's watch me
drink some water ok I'm going to do a
slightly more complicated example than
the first one I'm going to call q sort
so if we look at this this mapping I'm
just going to walk across the parameters
and see you normally see something like
void star data or maybe it's void star
store data in this case we actually have
a Java type called a pointer and as you
can guess that's actually a c pointer
that we can go and manipulate and do
stuff with that memory from Java after
that there's a count field this is a
generic sorting algorithm and c and need
to know how many elements are
represented in that pointer after that
it needs to know the width because and
see don't know know things like this and
then the final thing is a reference to a
type called compare this would normally
be a pointer to a c function but in this
case we're defining that callback in
Java itself it's defined as an interface
it takes two pointers these two pointers
get compared to figure out how to do
with sword there's a delegate annotation
here to mark that this is in fact the
callback but this is just an interface
and I said that Q sort is a generic
sorting function so we have to define
sorters depending on what type or trying
to sort so in this in compare you can
see in the highlighted range
we're asking the pointer to get an int
value at offset 0 so there's a lot of
convenience functions associated with
pointer to just get the stuff that you
want and then we have some nice c style
comparison there at the bottom and the
return statement how many people have
ternary operators for conditionals I
love it it's like twenty percent it
should be like 100 but whatever okay and
here's this an example of string compare
just thrown into to show that another
convenience mechanism on pointer we can
do get string at offset 0 and it will
search for everything up to backslash 0
or no buy it nowbuy yeah and then yeah I
think so oh it's good yeah you're right
SB a pointer to a pointer I i confess i
wrote this I was making slides the dirty
secrets that come out while you're
talking okay so then when we actually
want to call this the first line we're
essentially doing a Mallick of 8 bytes
because we want to basically store two
int's and hence there four bytes and the
next two lines we're storing the int 2
and 1 into that into that memory and
then we're calling Hugh sword and this
works to me this looks a little scary
because we're just screwing around with
memory from Java one really cool thing
about jnr though is when you actually
bind to a dll you can actually provide
overloads in this case we're providing
an overload to a primitive int which
conveniently works because primitive
insar contiguous regions of memory and
now if we look at this example again
this feels a lot more natural
so we're going to get into the probably
the most difficult part of using jnr
which is interacting with structures or
structs and see when you get time of day
as an example you know most see
functions usually return an int to
indicate whether things succeeded or not
because there's no exceptions so
frequently structure or out parameters
jnr provides a convenient annotation to
go and mark these fields to know that a
value is actually going to be coming
back this references a type time bail
which is supposed to represent the
struct time valency however we actually
have to define this using a Java syntax
the order of the fields and the size of
those fields are incredibly important if
you don't include the the right sizes of
the right order you're probably not
going to allocate enough memory and then
you're going to just start writing
random pieces of memory and see and
that's bad or so I've been told so these
two fields are using signed Long's we
actually have a lot of types most of the
types on the bottom are just aliases
towards types on the top then actually
complete the example we load lipsy again
at the top then we create a new time Val
struct the oddity here is that we
actually have to pass in jrs context
object runtime you can mostly just think
if this is just boilerplate that you
just have to do in fact this is the only
place I really remember seeing runtime
used but then after that you can just
call the method like you would any other
and you can get the values back from the
struct now this looks a little weird but
since trucks are just Java types in go
and add the getters that you want
and clean that up this is if there was
an Achilles heel to jnr it's that not
every struct in every operating system
is the same and so you have to figure
all that stuff out ahead of time and if
you are trying to bind and make a very
general purpose library where you're
calling across 32-bit or 64-bit
architectures you have to put some
thought into this and it's not to say
that you don't have to put the same
thought into it if you're doing it in
J&amp;amp;I but because you don't have that
compile time activity up front it's a
lot less obvious whether you're going to
get it right or not and i was i am going
to mention that that's correct kind of a
use case for us is supporting stat we do
this in another jnr project stat is
horrible because on every single
operating system there's always like
some extra vestigial field where it just
says undefined but you still have to
allocate space for it because if you
don't you'll have memory problems so I
just was going to informally walk
through what we did first thing we do is
we define an interface to represent a
common structure we need a consistent
interface where the Java consumer can
call this and get a sane result
regardless of what ho assets being
called from in particular we need to
make sure that we widen the size to the
largest possible size that it can ever
be because you can't return a 64-bit
value through a 32-bit field obviously
and so what ends up happening is you end
up generating a lot of Java classes it's
not so bad we do have a base class that
gets rid of most of the code from these
from these classes but for the actual
field layout and sizes we have to have
that in each thing
and then the final part of this is jnr
has a class called platform it allows
you to introspect the system that you're
running on and then you can use that
information to basically set up a
factory and get the right stat class
back I just want to point out that this
is a generic problem J&amp;amp;I has the same
issue in a way I think it's worse
because if i'll just go back a couple if
I find if I find a bug in Aix file
Staten jnr I just correct that class and
I'm done but if I have one jni program
that's see and I realized as a bug in
Aix I'm probably going to have to at
least recompile out on ax but if I'm a
good engineer I'm going to have to
recompile it everywhere because i'll
have like two versions of the program
deployed and that's not a good practice
so I think jnr is a little ahead of the
game and dealing with multiple
structures so now I'm just going to talk
about some of the stuff that we've built
on top edge in our FF I probably the
main package that you would probably use
as jnr POSIX it basically provides all
the POSIX methods that JRuby and Jai
thon need in trying to be completely
compatible with the sea versions of
these scripting languages because they
typically have like very very thin
veneers over these see methods and Java
usually when they do provide methods
like this they're way too abstract and
we just can't get the compatibility we
need another very nice thing about jnr
POSIX is if you run in a restricted
environment or for some reason the
native stuff doesn't load you can still
get a pure java version of these POSIX
methods now quite a few of them won't
work and if there's if they don't work
then they throw an error and i'll show
you how you can deal with that but
it gives you a nice a nice clean way of
accessing the methods that do work and
here I don't know if this is a complete
list or not it's pretty close I'll just
direct everyone's attention to the the
fifth one from the top which says fork
now this really doesn't work you don't
want to call fork from the JVM but it's
so funny we just can't get rid of it and
maybe that's not very professional of us
but I don't know it's just funny so
here's how you'd use it the first thing
you have to do is you have to set up a
handler and I'll go over handler on the
next slide and then you just ask for a
POSIX instance and that the second
parameter specifies if that was false
then you would just get the pure Java
version but now I can stab files and
actually get an inode from within the
JVM and this is really great here's what
the POSIX handler looks like at the top
we have methods like unimplemented error
so if you try to call a method that
doesn't exist then you have an
opportunity to decide you know what
exception you're going to throw the
highlighted methods towards the bottom
is because with Jai thon and JRuby and
in most software packages you can have
multiple instances running at the same
time in the same jvm each one of these
instances has to have its own concept of
these things they all have to have their
own current working directory of their
own in out an air stream next package
largely supports jnr POSIX but it's it's
a it's a general package we predefined
lots and lots of pound to find constants
that you'd want to use across different
systems it also contains a generation
tool so you can go and generate your own
set of constants and
we support an awful lot of constants so
at least from the basic operating system
standpoint you might not actually need
to generate any but you might need to do
it for your own own library now I don't
know if this is just really lazy of us
we're Ruby people so our generation
tools actually implemented in Ruby so
you can see there's a cg include sis
socket that age we're just going to read
through that and then look for these
pound defines and the result of that is
we're going to generate a file now
obviously you'll have to do this on
every platform that you want to support
but it gets rid of a lot of the pain and
we should actually make a java version
so that you don't have to you know
figure out how to call from Ruby
although Ruby is a really great language
I recommend it okay I don't even know I
mentioning this one it's cool though
wayne Meisner uses it to implement jnr
ffi it generates assembly on the fly so
cool native extended native
cross-platform I oh I can I always want
to pronounce it as a word and ink COI
doesn't doesn't come out right but
basically you can you can take any
descriptor like thing and add nao like
behavior and you can select on it for
the most part you'll indirectly use this
library you might decide that you want
to use unix domain sockets and it's just
layered on top of it and i really wish
java would have added unix domain
sockets I think it's crazy that they
don't have it so jnr supplies an awful
lot of the stuff that I think as Java
programmers we've all needed at one time
or another the idea of like busting out
to 2f of eyes just too painful of a pill
to swallow
it leads to our future there's been talk
that there could be a JSR to have some
fi based solution Charles nutter set up
google group which is that URL which
will be on the last slide so the balls
getting rolling we're looking at jnr and
figuring out what's good or maybe what's
not so good and it's a starting point
for a discussion there's a lot of
potential and moving it into the JVM
itself these native calls and get in
line right to the call site that's the
one I'd like but it doesn't also have to
be implemented in NJ and I could be
implemented some lower level API for the
from the vm best yet you won't actually
have to include this third-party jar out
off the internet that has a bunch of
compiled native code in it so you can
actually trust that you're getting it
from Java and you can trust that it's
not a Trojan horse it can probably
provide some level of segmentation
protection that that we can't so that if
you go and try to make a native call and
it fails it might be able to trap and
give a nice error message instead of
just going to hell and and obviously if
you're calling native code you might
need to have some enhanced security
policies for for dealing with that and
as as John mentioned we need to go and
make a struct generator to make that
process pretty much transparent there is
a ruby ffi generator Ruby's ffi is
essentially in jnr for Ruby they
actually use it to generate their own
stuff their own structs that they use
I'll just show you a code snippet
in this case it's going to go and look
at the header si lang c dash index
that's going to add a prefix to see lang
and then it's going to output these Ruby
ffi base trucks to see lang indexed at
RB and without actually having to
understand this I think you can get the
premise thanks and so this is kind of a
kind of a different style of talk
because I kind of feel like he was
belittling Jay and I and saying the
futures jnr and I do think the future is
jnr but just it feels little creepy to
come up and say okay now this is how
it's going to be so how many people how
many people originally came here to hear
about jnr okay so about half and and the
rest were for f of I ok it's cool um so
you had a question
oh yeah ten times okay yeah I got some
fingers came up in the behind you one
reason why that jnr was was written as
we were originally using Janee and Wayne
as he loved see and loves doing low
level stuff and when he wrote it it
ended up being ten times faster
John would you guys be interested in
collaborating on a tool and file format
that would standardize for Java the
format of whatever it is that the header
file compiler compiles the positive
thing that you have to find a good line
scraper and the structure scraper
there's a lot you can do inside of
applying scrape the whole thing right
yeah Metro goes on the.net side they
scraped all the inner file into these
modules that then they can use
dynamically Charlie you might want to
correct me if I'm wrong but I think this
actually will also oh it can't do
defines without specifying them though
right I mean I guess you could go and
search for pound defines and just pick
whatever values there and what and well
yeah but like I was just screwing around
with the sim float parsing thing and it
had like 15 pound defines with the with
the same value like it was like one of
these pangea see sources where no one
could figure out what actually compiled
yeah it would yes
right well the preprocessor has to run
because it might include fields and
stuff like that but I'm just not sure if
you can actually extract that name with
the value without saying i want this
name but yeah I think that's I think
that makes a lot of sense as everything
you say it always makes sense yes right
yeah sounds perfect let's let's get that
jsr going coast care
well that's a that's a clever idea Wow
yeah yeah that's that's an interesting
idea as long as it's not stripped it
could at least be an option that I could
try is there anything else we just
what I was wondering you provide exact
I'm very happy all the context that I
want to counter well that there is
there's a spawn function that we have in
general posix and I believe that just
Maps down to a POSIX pawn method that
basically allows you to go and execute
another program and it will it shouldn't
it has facilities or other see methods
that will allow you to go and do things
like doop doop I oh and stuff
basically does work an exec that has a
bunch of flags for honey want the
scriptures to go on Ilan change
directories and center did I steal my
program that's going to be the part that
I thought might be useful in
architecture
so so you want the original to keep
running and then the second the second
process to be able to inherit and do
stuff from the main
listen yeah I think you can do a spawn
oh sure yeah
there's no not the unique interaction
social and multiple actually not too bad
or C++
the header file and go and take
everything
to automatically course the header file
and create the reciprocal jump roxy
blast yeah right lightweight object in
Java
long
basically every single proxy class they
call
generates your media
class
interface file
so it makes you don't like move
so so my recommendation I join this
group you will join this group
that's a good be here with the 13 yard
line 310 thunder
give me that
right
you mean is it a cycle signups okay 50 I
kind of part of a push but you can take
gather
photographers
exactly what I don't do it silently I
wanted to college get scriptable I
wanted in exile actually exists niÃ±o
channels that are abstract
they would you give it a description you
get an i/o channel that does all that
stuff the native downtown so it is
actually kinda like if this is what your
job I exactly we have to do that for
some cases differently too
well thanks for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>