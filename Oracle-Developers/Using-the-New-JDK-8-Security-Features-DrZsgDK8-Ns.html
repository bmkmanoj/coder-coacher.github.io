<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Using the New JDK 8 Security Features | Coder Coacher - Coaching Coders</title><meta content="Using the New JDK 8 Security Features - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Using the New JDK 8 Security Features</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DrZsgDK8-Ns" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to my talk on using the new
JDK 8 security features my name is Sean
Mullan on the technical lead of the Java
security libraries team and Oracle so
the goal of my talk today is for you to
learn about the new JDK 8 security
features understand the benefits of each
and get started with code that you can
use in your applications so if you're if
you're particularly if you're working on
security and Java I think you're going
to really like this talk there's a lot
of practical examples on each of the new
features so specific agenda I'll start
off we'll just give you a flavor of what
the 11 new security features are I do
assume some knowledge of security for
this talk there's not enough time to go
through it a really in-depth overview of
Java security but i will take a you know
a few slides a few minutes just to go
over some of the highlights and then the
bulk of my talk will be just going over
the details and examples of each new
security feature i'll then have a slide
for more information and hopefully we'll
time at the end for Q&amp;amp;A
so the standard disclaimer so these are
the 11 new security features that are
coming in jdk each of them is defined by
a jdk enhancement proposal so you can go
to that website to find out more
information about them the latest status
and so forth the good news is that all
of these features are essentially
complete so you can go download the
developer preview today and try them out
and I encourage you to do so and help us
report bugs so that we can fix them
before eight is date is final with that
said there could be a few tweets to the
features along the way but for the most
part what I talked about today is what
you're going to see in the final release
I won't read through these in detail
right now because we'll be going through
them each and the remaining slides so
these are the first seven and then the
next four
okay so let's just do a real quick
high-level overview of Java security and
what it means for this talk so Java
security basically think you can think
of it of three different things this is
a security in the language and the
runtime and these are the things that
that help provide a safe environment for
running potentially untrusted code so
the java language was was designed with
security in mind has type safety
automatic memory management and it has
constructs or access modifiers in the
language that help you isolate and
restrict access to your code and then
before applications are wrong and run
through a bytecode verifier that ensures
that the byte codes are conforming to a
standard and not potentially malicious
we also offer a very large set of api's
and libraries to allow you to
incorporate security into your
applications the first is the
cryptography component otherwise known
as jca or jce and this contains
low-level api's for cryptographic
operations like signatures message
digests ciphers and so forth we have a
public key infrastructure component
which contains api's for certificates
cert paths and kpi's for validating
those those certificate chains for
authentication our main API is the Java
authentication and authorization service
and this is basically a pluggable API
allows you to plug in login modules for
different types of authentication
mechanisms so you can build things like
a single sign-on solution for your your
applications and then we also provide an
implementation of Kerberos which are
probably familiar with and that can be
plugged in as either an authentication
module under jazz or it can also be used
in the gssapi which I'll talk about next
so for secure communication we provide a
number of api's allow you to establish a
secure transport or secure session cross
potentially unsecure network first we
have AP is for SSL and TLS it's a Java
secure socket extension and then we have
an API for the gssapi this is a standard
API it's typically used with kerberos
and it allows you to create a secure
session using using something like
Kerberos and then finally we have a
component for the simple authentication
session layer and it's another one of
those type of generic api's and allows
you to establish a secure session using
things like ldap imap and several other
protocols for access control or
authorization we have the security
manager in the policy system and that
those contain a P is for allowing our
allowing you to define rules defining
what code is allowed to access sensitive
resources on your system and then jazz
brings user-based authorization so not
only can you define rules for where the
code is coming from but also who is
running the code and then finally we
have an XML signature component for
verifying and generating XML signatures
and a couple useful tools one for
creating and verifying sign jars and a
tool for managing keys of certificates
and keys that are used in your
applications
so here's a somewhat simplified diagram
of what I just talked about but what's
interesting let me see if this this
works yeah what's interesting here is
the the Jets the red ovals are other new
features in jdk 8 so you can kind of see
what what different functional areas
they fall into most of them fall into
the crypto area so we've spent a great
deal in jdk 8 improving the security of
our crypto algorithms bring in stronger
algorithms and also just increasing the
usability of AP is in this area and then
we have a few scattered other features
this isn't not working too well ok some
of the pki one of the pki one serkan
secured communication authentication and
access control what I found the best way
to talk about all these features is not
in the numerical order which is really
no note no special order to that but
actually in a bottom-up approach so I'm
going to talk about the crypto features
first work my way up to pki secure
communication authentication then finish
up with access control ok one area I
wanted to drill down just a little bit
more detail because most of our api's
are based on the security provider
architecture I thought this was useful
to go over so in the Java security API
there is a class called provider it's an
abstract class and security providers
implement this class and specify the
services that they support a service
consists of three different three
different types of things is the type of
cryptographic service which is the
message digest digital signature cipher
so forth the second thing a service is
an algorithm so you have md5 sha256 RSA
so forth and the third part of the
service is the actual class that
implements that algorithm now providers
can be plugged in to to the
jdk you can have as many as you want you
can go to third parties plug them in you
can implement your own the jdk comes
with a default set of providers
supporting you know the most commonly
used algorithms and they're configured
through the java dot security file and
basically there's just a preference
order there the the first one that is
listed in the Java security file is one
with the highest preference second one
third one I'll show you how this works
from an applications point of view you
don't have to know anything about the
underlying providers that are in the
system so application here wants to use
it in a sha 512 message digest calls the
get instance method of the message
digest class and then this kicks the
provider framework into action which is
part of the JRE implementation and then
it iterates over each of the providers
that are configured in this case we have
three providers and it basically first
checks provider a does it have a shot
512 message digest no it doesn't so it
goes to the next one provider be and it
does have a shot 512 so it returns that
to the application the applications
point of view it doesn't have to know
that it came from provider be if it
wants to it can depend on a specific
provider but we don't usually discourage
that because it decreases the
portability of your applications in that
case
okay so let's get to the meat of the
talk which is actually the new features
and the first one is pretty simple JEP
130 shot 224 message digests so for this
feature all we did was he we implemented
the shot 224 message digest and related
algorithms and as of jdk 7 we already
supported most of the shot two
algorithms shot 256 shot 384 sha-512 we
hadn't supported shot 224 it's a little
less commonly used than those other
algorithms but we got customer requests
for it it's been incorporated into other
ITF standards so we thought it was
important to it to support it it's
essentially a truncated version of
sha-256 you basically use the shot 256
algorithm you chop off the last 32 bits
of the computed hash and you return that
it does use a different initial hash
value than 256 for security reasons and
it overall provides 112 bits of security
which are important for some
applications it's the same as two key
Triple DES and so it could be a a good
sweet spot for the type of application
you're developing
and just some simple examples my laser
pointers keeps timing out but we'll see
how it goes this is just basically
creating a shot to 24 message digest and
these are creating shot to 24 based our
essay or ecdsa signatures and then
creating a shot to 24 Mac object so when
I show you examples on the slide if you
see something in blue it means it's new
so it's either a new algorithm in jdk 8
or it's a new API so keep that in mind
as we go through the examples okay the
next feature is one of my more favorite
ones stronger algorithms for password
based encryption so the goal here is
exactly what it says provides stronger
password based encryption
implementations PB is primarily
primarily based on the PK cs5 standard
and it includes three different things
key derivation functions so that's
taking your password and deriving a key
from it that can be used for encryption
and generating max it includes
encryption schemes so taking that
derived key and actually encrypting some
data with it and then message
authentication code schemes so
generating a message authentication code
from a key derived from that password
now the current support it for pv and
jdk 7 is lacking to put it mildly it's
it's still based on the less secure pbk
df1 key derivation and peep as one
encryption algorithms both of which are
not recommended for use in new
applications anymore it also uses the
the less secure md5 and sha-1 algorithms
when shot two is available and three key
Triple DES or rc2 encryption when
something like a es would be a better
alternative at this point and we don't
support any Mac algorithms so for JDK 8
we revamped this whole area as part of
Jeff 2121 and now we've added support
for
stronger pkc sv5 algorithms based on
version 2 dot 1 the latest version of
the PK cs5 standard we've added the PB
kdf to key derivation schemes using the
H Mac shot to pseudo random functions
the P bez to encryption schemes using
pbk tf2 and AES and we've added Mac
algorithms now using the PB Mac Mac one
schemes using pbk tf2 and shot two and
your cold algorithms are formed as
follows if you're driving a key from a
password use a secret key factory and
the algorithm would be pbk tf2 with the
pseudo-random function you want to use
and I'll show some examples of these for
cypher it would be PvE with the
pseudo-random function and the
encryption algorithm and for Mac it's
PvE with the pseudo-random function okay
so here's an example of how you would
derive a key from a password so the
first thing you have to do is create up
create something called a PVE key spec
object with the parameters that are
required to derive that key those
parameters are password the salt the
iteration count and the key length the
only required parameter is password if
you don't specify the salt iteration
count and key length the provider
implementation will generate reasonable
default values for you but I'm going to
show you how to specify all of them just
in case you want to so for this example
we're simply reading the password from
the console and then we're using a salt
and filling it with random random data
using a secure random object resetting
the iteration count to 1000 and the size
of the key we want produced from the
password is 128 bits assault in the
iteration count both help protect
against dictionary counts so the higher
the iteration count the more protection
you're going to get so we create all
those we pass on all those parameters
create through PBG spec objects
the next thing we do is use a secret key
factory call the get instance method of
the secret key factory and we're passing
it into this new algorithm the new
stronger algorithm pbk tf2 with H max
sha-256 we then call the generate secret
method passing it in the PBE key spec
and this then takes the password applies
the salt the iteration count and derives
a a key that we can then use for further
encryption operations long-term storage
so forth now there's a second way you
can actually use the new new PB
algorithms let's say you just had a
password you want to encrypt some data
and you're pretty much done you don't
need that in terms step of generating a
key so in this case you can do it a
different way in this case you specify
the the algorithm as PBE with your
pseudo random function H max sha256 and
then your encryption function we're
going to use AES with 128-bit key we
then create a PV key spec again using
the password and then we generate we
generate a PV key from this using a
secret key factory called again instant
method and then we call the generate
secret on the secret key factory now at
this point the PBE key is not strong
it's not in a derived key all that's
being stored in this PDE key is the
encoded bytes of the password so don't
pass this around don't store it anywhere
it's definitely subject to a dictionary
attack so now we're going to we're going
to encrypt some data with AES so AES
requires both the parameters for the key
derivation and it also requires an
initialization vector so we fill the
initialization vector with random data
using circular random we we put that in
an IV parameter spec object and then we
create a PB parameter spec containing
the salt the iteration count and the IV
parameters
and continued on the next slide is how
we encrypt some data with that so we
create a cipher we call the get instance
method of the cipher class passing in
the algorithm and then we set the cipher
for encryption mode we pass in the PVE
key which is just that encoded form of
the password and the p/b parameters for
this encryption operation and then we
encrypt some data we call do final we're
encrypting the classic hello world
message converted two bites and once
once this do final method is triggered
what happens is the password is is
derived using the strong pvb kdf to
method and then it uses the p beds2
encryption method to encrypt that with
AES and we get back to ciphertext
decryption we basically reverse the
process we initialize a four decryption
mode we pass in the PBE key and we need
to also specify the parameters that were
used when we encrypted it's very
important that you specify the same
initialization vector the same salt and
the same iteration count as those will
also be needed to decrypt the ciphertext
and we call do final with the ciphertext
and that returns the original clear text
message and i'm going to be posting
these slides on my blog later today so
if anything is going a little bit over
your head don't worry about it you'll be
able to download them and look at them
later
okay the next feature is another very
simple one it's called p kc s 11 crypto
provider for 64-bit windows the pkc 11
standard if some of you are familiar
with it's a it's a standard defines a
platform-independent api to
cryptographic tokens so things like
smart cards hardware security modules
and we already support a provider sun p
kc s 11 provider it's basically a native
bridge from java api to a native p kc s
11 library on the system it's currently
supported on solaris linux and windows
but only 32 bit as of jdk 7 solaris is
configured out of the box because it
already has a pkc s11 library as part
Solaris itself but others require
additional configuration the main thing
you have to tell us is where that native
p kc s 11 library is located on the
system all we're doing here is we're
adding official support for 64-bit
windows we've written interoperability
tests so we're able to guarantee that it
works and we're able to support it going
forward and then you can see the
reference guide for a lot more
information about how to use picus 11
okay the next feature also in the crypto
area is NSA suite b cryptographic
algorithms so the main goal here is to
provide implementations of NSA suite b
cryptographic algorithms this is a list
of required crypto algorithms approved
for use by the US government for secure
sharing of information and it's also
been picked up by other industries
financial industries so they look for
these requirements when they're when
they're purchasing products the good
news is that most algorithms are already
supported as of jdk 7 so jep 129 just
added a few too few missing pieces
support for 2048 diffie-hellman and DSA
keys and shot 224 with DSA and shot 256
with DSA signature algorithms and the
one last thing was the aes GCM mode but
that's completed as part of jep 115
which i'll talk about a little later so
i'll show one example here how to
generate a 2048-bit DSA key pair ok so
the first thing you do is create your
algorithm parameters for generating that
DSA key pair this case we use an
algorithm parameter generator we call
the get instance method and we pass in
DSA as the algorithm we then initialize
that generator using an object of a new
class in jdk 8 called DSA gen parameter
spec this takes two parameters the prime
P Ling and the subprime queue length
these are actually parameters used in
that DSA algorithm to generate that key
pair 2048 as you'll recognize is going
to be the size of the key pair we then
call a generate parameters method which
returns an algorithm parameters object
then we have to do this additional funky
step to convert that back to a DSA
parameter spec so we call the get prime
respect method pass in the class that we
want it cast too and that converts it
back to a DSA parameters back next we're
ready to generate our public key pair
and for that we use a key pair generator
call the get instance
method passing the algorithm that we're
going to use initialize it with the DSA
parameters and then call generate keep
air and that underneath the hood will
will generate a random 2048-bit DSA key
pair and from there we can use the shot
256 with DSA signature algorithm that's
new but I don't have an example for that
today ok the next feature is called JEP
123 configurable secure random number
generation so a little bit of background
here as anybody that note works and
security knows that random numbers are
essential to a lot of cryptographic
operations there is different types of
system random number generators
available for example on UNIX system
there's dev random which can produce
very high quality random numbers but
often has to block until there's
suitable randomness available in the
system to generate those random numbers
and then there's like less secure or
less yeah something like dev you random
which doesn't block but it's not going
to produce as strong secure random
numbers but it may be acceptable for
things like short lead session keys and
then finally there's pseudo-random
number generators that sort of try to
look at different system characteristics
and produce random data from that now up
until jdk 7 the secure random
implementations in jdk used mix of these
techniques and it was very hard for
users to configure it based on the risk
level or what type of use cases they
were trying to come up with so all sorts
of hacks were coming up and what we did
is it JDK 8 we sat down we look to the
api's who look the implementations and
try to clean them up so a few different
things we try to do here the first is we
added a new security property and secure
random method to obtain strong random
numbers this security property is set to
the most reasonable strongest default
implementation
for each platform so you now have a
method that is going to if it's
configured properly going to give you
the strongest secure random number
generator on the system we've also
corrected the Java security file and
corrected minor implementation details
there is a property in there you might
be familiar with called secure random
dot source and it's the the source for
Jenna this is seed see generation for
the random number generator as of jdk 7
that was set to file colon slash dad /
you random but for a long story would
take probably the rest of this talk our
implementations actually ignored that
and used / dev / random anyway so we had
customers that we were upset because of
the performance implications of that
their application blocked so they would
come up it with these hacks for it to
change it to use Devi you random they
would they would come up with funky
things file dev dot slash you random and
set or sedative / laughs dev / you
random to sort of trick it into using
dev you random instead of random we
cleaned out all that up in jdk 8 it's
now set by default to dev random if you
want to switch it to W random it just
works and then finally we've added new
native PRNG blocking and native PRNG
non-blocking implementations so if you
know you want to use a blocking or a
non-blocking implementation you can just
specify those as your algorithm name so
I have one example of using the new
method to generate a strong secure
random so there's a new method on the
secure random class called get strong
secure random that looks in the Java
security file looks for that new
security property instantiates a secure
random object of the strongest secure
random implementation on the system if
there's a problem reading that property
if it's not set it returns null so then
you might have fallback code to try the
old secure random constructor and maybe
it's good enough for your purposes maybe
or not
this is one API where we may make a
tweak before eight is finished we're
probably thinking of throwing an
exception here if something goes wrong
instead of swallowing that exception I
think the application would want to know
if there's a problem with the
configuration file and so it's better
than returning no there and so once you
have that secure random object you can
ishal eyes the key power generator using
that secure random and that's passed in
as a parameter here and there most of
our api's allow you to push in your own
secure random object to be used for
generating random numbers okay the next
feature is called a EAD cipher Suites
this stands for authenticated encryption
with associated data so a little
background on that many cryptographic
protocols require both encryption and
authentication so they require the use
of encryption plus a Mac so you can
think of for example a protocol that
uses a packet header and a mess the body
message needs to be encrypted but the
header itself just needs to be integrity
protected so previously applications
would use post a mac and encryption
potentially with different keys to get
into to protect that message ae ad is a
new concept allows you to do that all
with a single key single operation so
what we've done in which up 115 we've
implemented the aad AAS with GCM GCM is
a new mode that supports a EAD and you
might remember that in jdk 7 we actually
added api support for a ad we've added
methods in the cipher api but due to
time constraints we didn't provide an
implementation so you had to sort of
implement your own if you wanted to use
it so we fixed that in jdk we're now
delivering an implementation and we've
also implemented the aad GCM based TLS
cipher suites in jssc so you can use it
in your
to sell applications as well and this is
another one of those algorithms that's
required for NSA suite b compliance so
let's show an example of how it works
first thing we do is we need this is
we're going to be using AES with GCM
mode we need to create a new new object
GCM Prime respect and specify the
parameters we're going to be using
128-bit key and initialization vector
and then we call the get instance method
the cipher specify the algorithm that we
want to use and then we're going to
encrypt and authenticate some data we
initialize the cipher for encryption
mode we pass in the key that we want to
use to encrypt and the GCM parameters
that we just created for the data that
we want to authenticate but not encrypt
we call the new method update a ad with
the data that we're authenticating or
producing a mac for and then for the
data that we want to encrypt we call as
usual the do final method with the data
that that's to be encrypted once this
method is invoked it it both encrypts
this data and then produces a mac
message authentication code over this
data using the single key and returns
ciphertext the ciphertext actually
includes both the encrypted data and a
message authentication code oh no it's
like the beginning or the end of the
date I forget when we want to decrypt
and authenticate or validate that data
we just reverse the process we
initialize a very decryption mode
passing the key s and the parameters
call update a ad again with the message
that we want to authenticate so if this
was you know Duke to instead of Duke one
it's going to fail it's not the same
message and then we call the do final
method on the the ciphertext that that
was created here and the do final method
both decrypt the ciphertext and also
checks the message verifies the message
authentication code on Duke and
what we get back is the decrypted clear
text
ok
this is another one of my favorite
features of the 11 this is called
overhaul JK SJC eks and pkcs12 key
source so those of you familiar with key
stories you might know that pkcs12 key
store is not as fully functional as jks
and JC eks towards you can only store
private key and the certificate chain in
pkcs12 key stores so you couldn't store
secret key entries you couldn't store a
trusted certificate entries so what
we've done in jdk 8 we've added support
to the pkc s12 key store so that you can
also support you can also add trusted
certificate and secret key entries so
now if you want to migrate your data
completely from jks to a pkcs12 key
store you can do that today as of j
decade we've also enhanced the keystore
api to support new features such as
entry metadata and logical views
spanning several key stores so there's a
new dks keystore type and what this
basically allows you to do is take one
or more key stores and present them as a
single view so you use the existing
keystore API but underneath the hood
there's actually multiple key stores and
I'll show you an example of how this can
be useful and we've also added new
attribute ap is to allow you to
associate metadata with key store
entries both storing and retrieving and
this is pretty useful to because pkcs12
already supports this the standard so
now that we're allowing you to expose
that to your applications you can see
what additional data might be stored in
a pkcs12 t store and last but not least
we've enabled the strong PBE algorithms
i talked about earlier to be used to
protect key store entries so no longer
use subject to whatever the keystore
implementation supports you can now say
i want to use a really strong PvE
algorithm on the password used to
encrypt this secret key or private key
entry so it's extensible you can you can
decide what you want to use to incur
keystore entries that way okay so let's
show an example of the domain keystore
so the domain keystore takes a new
config file this is an example on my OSX
system so pretend i have two key stores
I have my java key store that I used to
you know stored things that I use key
tool for and and that that Java cut key
stories is stored in my home directory
and then I also have my standard OS X
keychain which contains all other
certificates and keys that I've
collected over the years using my OS X
system I'd like to use both of them in
my java application so what you do is
you create a domain keystore file it can
be called any with anything we're just
calling it dks config in this in this
place we specify a domain we can give
the domain any name we want we're
calling it Mac OS X and then we list the
key stores that are composed inside that
domain we give the key store any name we
choose so the first one is called Mikey
store minimally we have to specify the
keystore type which is jks for the java
key store and then optionally we specify
a URI some key stores don't take your
eyes they're actually just known by a
default location and that's the case for
the mac OSX keystore we give that a name
of my keychain the type here is the key
chain store I don't know if anyone knows
but we there is a new key store type
that allows you to read keys and
certificates from the LSX keychain and
that type is called key chain store i
believe it was added in jdk 7 i'm not
sure which one of the updates so once we
have that config file set up here's how
we can use it from the application we
can call get instance method of the
keystore passing it in the new dks
keystore type and then we need to open a
file to the dks config file that i just
showed we need to convert that to a URI
and then we call the load method of the
keystore passing it in
a new instance of a class called domain
load/store parameters those are the
parameters required for the domain
keystore and those are a URI of the
keystore config file and then a map of
key store names to the password needed
to unlock that key store in this case
there's only one password for the Java
key store and we as you can see I've map
it from the key store named Mikey store
to the password protection containing
that piece to a keystore the OS X key
store doesn't need a specific key sort
it's able to leverage your OS X
credentials that you've already logged
in on to the system and then here we're
just enumerated over the trusted
certificate entries so we're actually
looking through both key stores
returning all the trusted certificates
from which you can do further
information on that ok so now moving
into the pki area we have a new feature
called enhance the certificate
revocation checking API so in jdk we
significantly revamped our API our
certificate revocation checking API
there wasn't really a lot of ability for
the users to influence the revocation
checking mechanisms that were built into
the JRE and so that's the goal here is
to give you more control over that I'm
just going to mention some of the
features we've added support for best
effort checking and entities certificate
checking so you can just check the N
entity certificate instead of every
certificate in the chain and a bunch of
different options and parameters these
are all available in a single API called
the P kicks revocation checker API so
best-effort checking is also called soft
fail basically this means is that if if
it's checked for the revocation status
of certificate cannot be obtained due to
a network issue maybe you're offline the
ocsp server is down so overloaded it
won't be considered a fatal error and
this is something that most browsers
support that's usually the D
mode for for web browsers so we thought
it was important for Java to support it
as well the pickax revocation checker
supports both ocsp and crls those are
the two main mechanisms for checking
revocation status ocsp is preferred with
a fallback to crls but they can be
switched you can prefer crls over ocsp
and you can also disable the fallback so
if you only want to use OCS be there you
only want to use crls you can do that
and we've also added support for stapled
ocsp responses that's that's a new
feature it's gaining traction and
different protocols and for good reason
it really helps improve the performance
so in this case the server makes the
request to an ocsp server and then takes
the ocsp response staples it onto a
message for example an ssl would be one
of the handshake messages and then sends
them back to the client so the client
doesn't have to make this connection to
the ocsp server servers already done it
too for them and it also helps privacy
issues so there's some privacy issues
associated with ocsp it reveals what
server you're connecting to so the ocsp
server knows that in this case that
those concerns are also addressed so
here's how to use the new p kicks
revocation checker api we start off with
a surpass validator call the get
instance method and we specify the
algorithm we're using P kicks and for
this example we're going to set the soft
fail option to true first we obtain the
new P kicks revocation checker object
and then we can set options on that
returned object this contain takes a set
of enums which are different options you
can set this one we're setting just the
soft fail option and then we validate
the certificate chain we specify a
keystore containing our trusted anchors
or root certs that we trust and we add
the P kicks revocation checker as a cert
path checker
on the peak experimenters and then we
call the valet method passing in our
certificate chain or cert path and the
parameters and this returns acer path
validator result if it's successful now
underneath the hood each certificate in
that chain will be checked for
revocation status police any network
issues it won't throw an exceptional
it'll still pass now as an application
you might want to know whether there
were network issues you might be curious
you might want to throw a warning up to
the user saying well everything was okay
except I wasn't able to check these
certificates properly and there's a new
method that you can call on the
revocation checker after that which
returns that information to you it will
tell you if there were any issues
contacting the the revocation server
okay just checked I'm here right
the next feature is in the secure comms
area it's called JEP 114 the TLS server
name indication extension so here we
added support for the sni extension to
allow more flexible secure virtual
hosting and virtual machine
infrastructure based on the ssl/tls
protocols this extension specifically
indicates the hostname the client wants
to connect to and this allows JC to be
used by a server where multiple domains
share the same IP address that's
becoming quite common in cloud computing
environments and this allows the server
to know exactly what hosts that the
client wants to use and there's several
new jss CPA JCAP is that we've added and
support of that so how does it work well
there's there you can use it both on the
client and the server side on the client
side you just use the standard code to
create an SSL socket uses an ssl socket
factory you get default method and then
once you get the socket factory you call
create socket with the IP address that
you're trying to connect to and the port
and this returns an ssl socket from
there we can specifically specify the
host we want to connect to using the new
S&amp;amp;I hostname API and in this case we
want to connect to Wi-Fi com this
returns in sni host name is actually a
subclass of S&amp;amp;I server name that's
because the TLS standard was designed
with extensibility in mind they might
add new name types in the future so we
want to be able to accommodate that in
the future if that's the case once we
have this sni hostname we need to reset
it on the SSL parameters so the socket
is aware of it so we get the SSL
parameters we call a new method called
set server names passing in a list
containing that one SNI hostname and
then we reset the SSL parameters on the
ssl socket on the server side
we create our server socket factory from
there we create a server socket with the
port we're listening on ssl server
socket and for the server side it has to
specify the hostname matching rules that
it that it that it supports for that
particular IP address and we do that
through a new concept called an S on I
matcher we call a create sni matcher
method on s and I hostname specifying
the two the two hosts that we support in
this case wwan pool com or W example org
and then we need to do a similar thing
we get the SSL parameters set those s
and I'm atras on them and then reset
them on that the socket and then we can
accept our connection from the client
now underneath the hood we see what we
see the client is trying to connect to
example calm and the implementation now
is smart enough to pick the the specific
certificate that authenticates example
calm and use that to authenticate to the
client so it gets rid of those you know
warning messages where the host name
doesn't match the certificate now you
know it's it's it's specifically clear
which certificate it needs to
authenticate to the client
okay I've got two more features to go I
still got 15 minutes so that's okay this
one is in the authentication area and
it's Kerberos five extensions and this
adds support for the MS sfu service for
user extensions to the JDK Kerberos 5
implementation there's two extensions
collectively they allow a service to
obtain a Kerberos service ticket on
behalf of another user so if you're in a
firewall environment your clients don't
support Kerberos but inside the firewall
you need to access some some curb erised
services these two extensions can help
you and they consist of two extensions
service for user to self extension this
allows the service to obtain a service
ticket to its self on behalf of another
user and the service for user to proxy
extension allows the service to obtain a
service ticket to its second back-end
service on behalf of another user and
i'll just show an example of how to use
s for you to self so as i mentioned
before we use gssapi for kerberos
authentication so here we're creating a
GSS manager first we're calling a get
instance method and then we're obtaining
the credentials of the the server and we
do that by calling the crate credential
method on the GSS manager and that
returns the credentials for the server
we then want to impersonate as Mullin so
say Mullen has authenticated using some
other mechanism the server has checked
that and said that's okay but now we
need to authenticate them using Kerberos
taxes some additional services so we
create a name called Mullin this returns
a GSS name and then on our original self
credentials we cast that to a new class
extended GSS credential and we call the
impersonate method passing it the user
that we want to impersonate as and that
returns the
potentials for that for myself as as
Kerberos credentials now the extent GS
credential is not a standard API in the
JDK it's only in the it's a supported
API though but it's in the comm dots
undeath security Jes package it's in
OpenJDK it may be supported by other
vendors but we can't guarantee that what
we'd like to do is the gssapi is
standardized through the IETF so we
can't just add new methods to that
without breaking that standard so we
have to go through the IETF to add
something like this so we're hoping to
do that in jdk 9 time frame oh i should
say underneath the hood when you call
the impersonate method it then does the
request to get that s for you to self
service ticket for myself okay last but
not least is limited due privileged so
this is in the access control area and
basically here it enables code to assert
a subset of its granted permissions
without otherwise preventing the full
access control stack walk to check for
other permissions now this is very
useful when you need to enable some
permissions but you want to allow others
to continue the stack walk this was
designed as new overloaded access
controller do privileged methods that
take a list of limiting permissions so
there's basically two main benefits of
limited do privileged first is that it
allows your code to adhere more to the
principal least privilege if you're
familiar with the existing do privileged
methods they by default they assert all
permissions when you're performing an
operation so even if you need to you
know do one or two things you only need
one or two permissions by default
they're asserting all permissions which
you know makes your makes that code more
susceptible to attack if it's
compromised the other thing it does is
that it continues today they do
privileged stock
the stock walk at the color of do
privileged so it doesn't check any
further up the stack now you're able to
take those callers into permission to
take those callers into account which
may have additional permissions that
allow you to do useful things and it's
an example is the best way to show that
so let's get to that in the next slide
so what we have here is this is just
setting up for the example we have a
subclass of privileged action called get
property action and all this does is
return the value of assistant property
we actually have a utility class inside
the JRE that does this because is a
common thing that we do on behalf of
untrusted code okay
and here's the example of limited due
privilege let's say we had an API called
get properiy and it basically returns
the value of assistant property now this
could be part of the trusted library
could be part of the JRE but we may
decide okay there's some properties that
we would allow any code to retrieve and
we're okay with asserting our
permissions for those limited properties
so in this case we're saying so we were
okay with any code reading the app
version properties and the apt vendor
properties but any other property that
that's red well the code calling it all
the colors above me have to have that
permission so you can think of designing
api's like this you know other examples
where you might have certain directories
that you're okay with with with
applications reading from some temp
directories or local application tent
directories put any other files that are
read or write to the system that code
above you has to have permission to do
so so limited due privilege allows you
to do that allows you to to limit the
permissions for the particular operation
but also allow the code above you to if
it has its own permissions to do
operations to allow those those those to
be considered okay more information our
main security group we do everything in
the open nowadays so we have OpenJDK
security group at that page you can find
more information you can subscribe to
the mailing list you can review all the
code that we submit you can contribute
patches so it's a great way to get
involved please send feature requests
that were always really really really
want to hear from what you guys want and
what's important to you and this is a
real good timing for that as we're
ramping up for a jdk 9 planning the jets
are up there you can download the
download the early access preview
release of jdk 8 jdk 8 security guides
contain all sorts of information on the
different components not all of them
have been updated yet to include the new
features I talked about today but they
will open
next few months and definitely before
eight is released the javadocs however
are up to date as everything I went over
today is up to date in those javadocs i
periodically blog about new security
features and I also recently joined
Twitter so i'll be tweeting about java
security and other things as well if you
want to follow me so got about five
minutes for questions yes
so the question was JDK 8 deliver bouncy
castle features we don't deliver a
bouncy castle code in the JDK 8 you know
they're there are algorithms that both
bouncy castle and we support and our
providers if there's something specific
that you're looking for you know we can
consider adding it possibly it depends
what you what you're looking for any
other questions I'll be around
afterwards too if you want to you're too
shy to ask question here</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>