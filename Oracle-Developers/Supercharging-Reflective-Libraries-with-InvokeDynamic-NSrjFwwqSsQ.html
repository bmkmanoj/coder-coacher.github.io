<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Supercharging Reflective Libraries with InvokeDynamic | Coder Coacher - Coaching Coders</title><meta content="Supercharging Reflective Libraries with InvokeDynamic - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Supercharging Reflective Libraries with InvokeDynamic</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NSrjFwwqSsQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm going to be talking today about
how you can work with a reflective base
reflection based library and speed it up
using some bike hood generation then if
necessary a little bit of invokedynamic
just a few quick nope that's not what I
wanted a few quick words about me I'm an
application architect at Marion genetics
we do DNA testing for determining
predisposition towards certain types of
cancer been working in java for about
fourteen years worked on some open
source projects and one in particular
we'll be talking about in just a second
i do some other stuff that you probably
don't care about so moving on so one of
the open source projects I've worked on
along with a with Chris Hanson is a
project called POJO Matic and this is a
project which basically the idea is if
you have a being it can easily generate
your equals two string and hashcode
method for you and it does it at runtime
so that you don't need to do any special
build steps it's not like Lombok or
where you need a special compiler or
something so the in version one we
simply used reflection and it worked
well it was relatively fast but it was
slower than for example if you hand
coded the equals and hashcode and two
string methods we had considered using
byte code generation to speed it up and
initially thought well the problem with
that aside from byte code generation
being hard is that there's no way to
access private fields then Along Came
Java seven with invokedynamic and we
started looking at that and realized
there's actually something we can do
here so this talk is really a discussion
about how you can apply the lessons that
we learned to your projects if you so
choose so just a quick overview of what
we're gonna do today we're going to do a
quick review of reflection and then
we're gonna see how a reflection based
approach compares to just typing code in
yourself and you know compiling it and
running it and then we'll see another
approach for generating byte code using
the ASM framework we'll start looking at
invoke dynamic to overcome certain
access restrictions you might face and
then finally we'll I'll discuss a few
tips and tricks that I've
learned sometimes the hard way along the
road so the the somewhat contrived use
case for today is I'm going to be
building a just sauna fire something
that takes an instance of a beam and
comes up with a JSON representation of
it but Jason is a little bit complicated
for the purpose of this talk so in the
spirit of the recent get markdown Wars
I'm gonna i'm going to dumb down jason a
bit so in particular no quotes and so i
don't have to keep track of whether I
have already printed out one element I'm
going to allow for a trailing comma if
that helps so as an example here so
first of all you know we're gonna be
dealing with an interface JSON Oh fire
Jason Marshall ooh would be a better
name but that takes up more room on a
slides so JSON Oh fire it is it's got a
single method Marshall that and it's
generic and type T that's the type that
it's gonna be marshalling Marshall takes
in an instance of type T and spits out a
JSON string so for example if we have a
very simple class beam and note that
I've put some annotations I've annotated
a property I've annotated a field in Ty
and there's also a getter method get s
which has been annotated as well and
each of these property to these
annotations contains a value and that's
going to simply be the name of the field
in the json representation so what my
json afire should do if i ask it to
marshal and instance of being is prints
out something like this prop 1 maps to 3
prop 2 maps to maybe hello if that's the
value of the string s so a quick review
of how you would do this with reflection
so at a high level your your Marshall
method it needs to create a string
builder needs to figure out what class
it's looking at you know open up a curly
brace and then do some interesting work
close your curly brace and and invoke
two strings the string representation so
what's that that dot dot in the middle
there well for fields I can ask the
class for its declared fields
and then I can determine for each field
hey do you have adjacent annotation if
you do then the name of the field is the
value of the Jason annotation so I
append that out the field may or may not
be accessible it might be public but it
might be private so I'm gonna call set
is accessible or said accessible true on
it and then I'm going to append the
value that I get from that field attack
on a comma and I'm on my way and four
methods it's pretty much the same thing
except I'm asking for declared methods
here and I'm assuming if you've
annotated your method with Jason that
you don't take any arguments because if
you do then you're just bad and you
deserve to suffer here so there's a few
things we could do of course here one
thing we could do is instead of doing
all that reflection in the marshal er we
could on instantiation of a Jason
marshal or do some reflection of the
class you know call set accessible true
on all our fields and methods ahead of
time and keep them around that is going
to save us on reflection but we're still
going to have reflective invocation one
other thing that we could certainly do
would be if the fields were primitive
then instead of saying field get we
could use the more precise field get int
or get long or whatnot that would allow
us to save on auto boxing now oh that's
nice it's a certain amount of work and
you might think well gosh isn't it
easier just to write one of these and of
course if you only have one class that
you want to be able to marshal integer a
something yes it's much easier to hand
code it not only is it easier to hand
code it it turns out to be a wee bit
faster so these are nanoseconds per call
so shorter is better and and you can see
that the hand rolled code is a lot
shorter than the reflection based code
which raises the question why is
reflection so slow I mean you've
probably heard reflection is a lot
better than it used to be and it is but
it's still going to be slower especially
once your once your your program has
warmed up and the JIT has had a chance
to kick in reflection is going to be a
fair amount slower so to understand why
that is let's take a
a quick review of call site methods so
or of call sites I should say so a call
site is simply an invocation of a method
at a particular place in your code so
for example I might have an instance foo
and I'm calling bar on that instance foo
at some place in the code so there's
three kinds of call sites in them
there's one way of looking at call sites
that gives you three kinds of call sites
the simplest is a monomorphic call site
and what that would mean in this context
is that the bar method has exactly one
implementation that you'll ever find at
that call site so there may be multiple
implementations of your of your foo
class floating out there but at least at
that call site you're only ever going to
see one implementation of the bar method
the great thing about a monomorphic
method is when the compiler can can
prove to itself that it's only ever
going to be this one method it can say
you know I don't need to do the usual
thing where I look up in the dispatch
table where's the implementation of my
bar method and then call that I can say
hey I know exactly the implementation if
I want I can inline it and once you
inline you can then do other
optimizations as well you can start
doing escape analysis all sorts of great
things that it's just the goodness keeps
on coming the next best case is
biomorphic biomorphic
is instead of one implementation there's
two and here the compiler can take
another approach which it says okay I'm
going to do a quick instance of check to
figure out which one of the
implementations I'm looking at and based
on that I'm then going to potentially in
line one or the other implementation so
it still gives you a certain amount of
opportunity to speed things up but once
you hit three otherwise known as mega
morphic because three is a really really
big number the compiler says or the
hotspot compiler the JIT says you know
this is this is not worth trying to keep
track of at this point so we're just
going to do a standard virtual function
call which means we can't in line and
hence we can't do any of the
optimizations that can happen after
inlining
this is that's a really good question
this is information that I have heard
people like I think Brian gets has
talked about this other folks you know I
can't I can't remember an exact
reference if you want to come talk to me
after the talk I can try to reconstruct
something but if you search Meg amorphic
on Google you'll probably find a lot of
articles talking about this sort of
thing so the problem with reflection is
that as a rule it's going to end up
being kind of mega morphic so reflection
the the compiler tries to do their the
the hotspot compiler tries to do the
right thing if it notices that a
particular reflective say a field is
having get called on it a lot it's I
think a thousand times after a thousand
times the compiler is going to say all
right let's let's do an optimization
here I'm gonna generate a class yes sir
yeah the JVM I mean the hot spot
compiler when I'm talking about the
compiler I'm not talking about Java C
I'm talking about the hot spot the
just-in-time compiler that takes your
bike code and compiles it down to if
possible you know to machine code and so
it's gonna say you know at a certain
point I'm gonna just create a new class
that directly accesses this field and
call that instead of using my slower
reflective invocation techniques and the
way it does that is that internally a
field has an instance of a field
accessor and it delegates to that and
when you find that you've got too many
calls going through you replace your
reflection based revealed access or with
this this bytecode generated field
access sir but that field access er in
the field class there's going to be lots
of different implementations so that is
going to be mega morphic so in the end
you're pretty stuck you can't get
inlining you can't get optimization and
you just end up being well sad method
invoke very very analogous story so this
gets you to thinking okay so the problem
is that the you know when the JVM
generates its bytecode for doing this
field access to improve things that
still make a morphic what if I do the
bytecode generation so if you take your
class and you do the bytecode generation
then the nice thing is that now at again
spot encode you referencing a particular
field so not only is it inlinable it's
already in lined and so then the
compiler can start doing the next thing
if you're if you're accessing the method
it can choose to inline that method
because it knows exactly what it's
calling so there are some there's some
great tools out there ASM is is the one
that I tend to use for this sort of
thing the ASM framework generated the
object web folks do that and it's a it's
a good framework it'll generate bytecode
for you and if you can get that bytecode
into a class loader well I mean you
think about what class loaders do they
take class files from disk and a class
file is just bytecode so necessarily
your bike code is gonna run just as fast
as if you had hand coded that and that's
really great with one small hitch so how
many people in here can program Java
yeah that's what I thought how many
people can program bytecode a lot less
so so how do you learn to speak bytecode
well first of all it helps you know the
the very basics about JVM bytecode it's
it's a sort of a stack based language
it's not unlike assembly code if you've
ever looked at that but if you haven't
don't worry it has a notion of local
variables parameters in particular are
form of local variables you can do basic
arithmetic addition subtraction that
sort of thing you can do tests and then
do conditional jumps based on those
tests you can access fields and of
course you can call methods and with
methods there's actually well there's
there's more than these four but the
four most common or five most common
things you'll deal with our interface
methods virtual methods static methods
special methods which basically tend to
be static initializers or excuse me
class initializers so constructors and
then finally there's a dynamic method
invocation which we will definitely get
to and as I mentioned ASM is a great
framework for doing this it can both
read and write bytecode which can come
in handy it uses the visitor pattern
which is is not uncommon when you're
doing compilation and this is sort of a
form of compilation it doesn't make it
easy to write by
code Java cysts will make it easier
although you know I've never been quite
as comfortable with the Java system Pro
chai always like to actually be able to
see what's going on directly so it
doesn't make it easy to write bytecode
but it does make it feasible and one
thing that makes it a whole lot easier
to write by code with ASM is the fact
that well remember ASM can read bytecode
and it has a visitor pattern so it can
as it's reading bytecode it can call you
know it can have different visitors and
they've written one visitor called ASM
afire and what this does it's actually
this is a full class and you can just
invoke it from the command line and what
it does is it takes a class that you
hand to it that you specify and it looks
at the bytecode and then it generates
Java source code which if compiled and
run will generate the bytecode that it's
looking at so that's that's a little bit
convoluted when you first think about it
but basically what it does is it gives
you a roadmap for how to generate
bytecode on your own
there's the command line that I'm
showing here and you can read all about
this on the on the ASM site there's also
an eclipse plugin I'll just really
quickly show that so I have a well maybe
I won't show that because it's on the
wrong screen let me see if I get it over
here
okay so up here I have a very simple
class foo and down here I see the the
ASM code that goes with it so this is
this is a really handy tool to have if
you're if you're generating if you're
generating bytecode because it tells you
what to do and one philosophy that you
can take when approaching this stuff
especially initially is you don't have
to understand everything that's going on
you kind of look at what's your code
your bytecode you're generating and you
say alright now where is the stuff I
might want to tweak let me figure out
what's going on with that let me not
worry about the rest at least I don't
have to worry about it today eventually
it'll all start to make sense but
there's no point trying to absorb the
entire bytecode specification and the J
SMAT ASM API all in one sitting
the question was would Asma fire be
analogous to a decompiler and yes sort
of but it's not decompiling it is not
taking by code and showing you the Java
code that would generate it it's showing
you the ASM code that would generate it
which is a whole lot less friendly than
the Java code so if you have a
decompiler handy that goes to Java I'd
recommend using that when that's what
you want to see okay so let's take a
real simple example here's a basic you
know sort of hello world it's not even
hello world it's just hello and and this
is a simple class that has a method bar
that returns hello so let's see if we
run ASM fire on it what do we get well
we get this so that's that's almost as
simple so a couple things to note here
SM SM SM afire has generated a couple
blocks of code and these turn out to
correspond to the two methods by the way
you're not meant to read this so don't
panic it correspond to the two methods
and so in particular one thing we can do
is sort of prettify the whole thing up
by actually making the those blocks of
code into their own methods ones for
generating the constructor ones for
generating the method bar okay so now
let's go into this in a bit more detail
and and see some of the stuff that's
going on so at the top level what do I
need to do what does this method need to
do the method that it generates is
called dump because it's dumping out
some byte code and what dump needs to do
is generate an array of bytes because
that's what byte code essentially is so
it creates a class writer and then it
says tells this class writer
everything's going to be in terms of all
the verbs are going to be visit because
of the visitor pattern so you just kind
of ignore the visit for the most part
says okay I'm gonna be dealing with a
class I'm gonna compile Java 1.8 because
that's the fun one it's a public class
the name of the class is foods in the
JSON package that's what that third
argument is the fourth argument that's
null that would be the generic signature
of this class we're at a generic class
the fifth argument object that's our
superclass the sixth argument which is
null if it was not in all would be an
array of interfaces that this class is
implementing so the next thing we're
going to do is generate our constructor
generate our
method and then finally we say okay
we're done give me a byte array so at
the high level that's what's going on
now I'm not going to show you the
constructor because methods constructor
is a form of a method so instead I'll
just show you the the bar method because
that's a little bit more fun to look at
so what does this method do well it
first of all says okay and remember then
when I say what is this method do what
is our generate bar method do the first
thing it does is says okay I'm gonna now
visit a method so in other words give me
a method visitor and I'll work with that
and then you tell the method visitor I
actually want to visit you know start
start visiting the code if you had any
annotations you'd put them in before
that now here's the actual code you say
alright I'm gonna load a constant onto
the stack hello and then I'm gonna
return it and then finally I this visit
Max is is basically a way of saying here
was my maximum stack size and here's how
many local variables I had if you want
you can tell ASM to compute those for
you and then you don't have to worry
about those and then it says I'm done so
of all this stuff the stuff that really
matters is the stuff in the middle here
and and going forward that's what we're
gonna be focusing on I'm not going to
keep showing the the setup and teardown
that's involved for creating each method
okay so we've got this class how do we
or excuse me we had these bytes how do
we get a class out of them and the
answer is you need a class loader so the
default class loader in Java has a
protected method called define class
which you pass it a set of bytes and it
and the name of the class and it'll give
you back a class so we basically just
need a class loader that can expose that
out to out to two users and and so this
is the basic class I tend to use for
these sort of situations it's just very
simple and straightforward note the
constructor takes a parent class loader
you always need to provide one of those
in general it's good to make sure that
the parent class loader has visibility
to any of the classes that you're going
to need to interact with so with all
this how do we how do we actually get an
instance of this class and use it well I
can first call our dump method to get
the bytes I can pass that into the bike
class loader and then after that I
you know I've passed those in and get a
class I can ask for a new instance which
is easy since we have a default
constructor in our constructor then I
can use reflection to find the bar
method and I can invoke it and then I
can print out the result making this
what I hope is the worst hello world
example you've ever seen okay so let's
try to take all of this and use it for
something a little bit more interesting
so that it's maybe starting to be worth
the effort yes very good question so the
question is why did I have to use
reflection to find the bar method
because why didn't I just cast it to foo
well the problem is I'm generating this
class foo at runtime and at compile time
when the compilers generating the code
you're seeing on this screen there is no
class foo so I chop a see would would
look at me and say you know what are you
talking about I don't know anything
about foo so $0.10
you know we have to use reflection in
this context so that's a good question
though okay so let's just remember
quickly what we wanted to do we wanted
to take this hand-rolled class and and
and and see what it's going to look like
if we if we generate it with ASM so we
we run the SMI fire on it and we we take
a look at what we get so one thing here
is that now that we are actually
implementing an interface there's a
little bit more when we set up the class
you'll notice that first of all JSON Oh
fire is a generic interface so that
first parameter that was null before
that is to say the fourth parameter now
has some information saying here's the
generic signature of this class and then
finally there's also at the end we have
to give this array of interfaces that we
implement so remember when we wrote our
Marshall method we just had simple
string concatenation with pluses of
remember that the compiler Java C
compiler is going to first turn this D
sugar this into a
stringbuilder in this series of the pens
and I just mentioned that because that's
what you're gonna see coming up and
don't get too freaked out by it so the
Marshall method itself once we start
constructing that well the first thing
that we need to do is construct the
string builder now I could go line by
line on this and and tell you you know
and I'll just very quickly saying
basically you first of all say okay sort
of you know allocate the space then
visit the constructor and and you know
and and then eventually you've got a
string builder on your stack but the
simpler way to think about this is to
not think about it because you're not
going to need to modify this part of
code so just accept it yeah you can come
back later and look at it but don't try
to worry about it for the moment
especially since we got a lot to cover
here the other thing that I want to
mention here is that you'll notice that
the the ASM library naturally always
wants to have the full class name
whenever you refer to a class and slide
real estate being precious I'm gonna be
can contract you knows a bit so just
when you see dot dot just think okay the
the full class path if it was there and
and that of course then allows us to
actually make things a little bit more
compact so anyway getting onto something
more interesting
we actually have work to do we want to
grab the field I out of our class and
append it so the first thing that we do
so there's there's two local variables
in this context the first local variable
is our self the this instance the second
local variable otherwise known to
computer scientists as the first local
variable since we start counting at zero
is the beam that was passed in so I put
that beam on the stack with an a load
instruction the next thing that I do is
I as I run the get field opcode and the
get field opcode it takes it takes a few
different things at first of all you
need to tell it the class that you're
getting a field from and the name of the
field and then the type of the field
that you're expecting back so actually
there's separate op codes for the
different types but with ASM it just
says look there's just a single get
field and tell me the type and the type
here is simply I if the type of a class
would be the class name but primitive
types of the JVM are abbreviated by
letters like I for int
for long and so forth then the last
thing I do so I guess I sorry I should
say when this get filled opcode runs it
takes the instance that's on the stack
pops it off gets the field from it and
puts the resulting field value on the
stack so now what I have on the stack is
the actual value of I and remember from
the previous slide we already had a
stringbuilder on the stack so I'm in
perfect a perfect place to call the
append method on stringbuilder and
fortunately the append method returns a
string builder so I'll still have a
string builder on the stack which means
I can keep playing this game and in fact
the next thing that I'd want to do is
play this game with the method get s so
this is pretty similar to the excuse me
pretty similar to the the field case
except that I'm invoking a virtual
method and so I'm passing the the class
name the method name the signature of
the method and SM wants me to say it's
not an interface as if the invoke
virtual keyword wasn't a really good
hint on that okay
last thing I need to do eventually you
know I'm going to append the close curly
brace not showing that here but we we
finally invoke the two string method and
that now we have a string on our stack
we return that and that's the end of the
code for our Marshall method so this is
almost everything you need if you run a
centerfire you're gonna see one other
weird thing and the to understand where
that's going to come from
remember that JSON of fire of T has this
method Marshall and it's declared to
take an instance of type T but we have a
racer in Java which means that in some
sense as far as the JVM is concerned
it's taking something of type object so
the Marshall method on the interface is
declared to take an object if I try to
call Marshall if I try to call a method
with a sing that you're taking a type of
being on an interface that's expecting
type of Marshall that's not going to
work because the JVM wants to know
exactly when I make a method call
exactly what the correct type parameters
are but we wrote a Marshall method that
took beans so what we need to do is
create a bridge method that converts
from the one taking bean to the
one taking object if you if you Java see
a method like this the compiler will do
it for you and ASM is recognizing that
and putting it in here for us so
basically it it says I'm going to visit
a synthetic bridge method that's what
some of those flags up there in the top
are its public but it's also a synthetic
and bridge and in particular I'm taking
an object and then if you look down here
all I really do is call the other
marshal method that takes in a beam
alright so now we need to do is
construct an instance and this time it
gets a little bit earlier so remember
there was the question why did I need to
use reflection to get the the method to
invoke earlier and the answer was we
didn't know about the class but now that
we're implementing an interface it's a
little bit nicer because I can cast the
instance that I get when I call class to
an instance I can cast that to an
instance of the or I can cast it to the
JSON of fire in interface which means
now I can just use a standard interface
method I don't need to go through any
more connections so that's nice it makes
code a little bit easier to work with
okay so this is great
we now have generated bike code and it
necessarily will perform just as well as
our hand coded code I actually just
tested this and yeah it really does
so everything feels good it feels like
now we just ought to be able to sort of
you know take the patterns here maybe
put in a for loop around the part where
we're generating the field accessors and
the method accessors and we can be done
there is a problem though so this is the
beam class as we've been thinking of it
but this is the beam class that you
might actually have to deal with the
very good chance your fields are going
to be private it's possible even some of
the methods that you want to access are
going to be private and if you try to
run the byte code that we generated
against this kind of beam class you're
gonna get an illegal access error at
runtime the verifier the bytecode
verifier is gonna as it loads the byte
code check to make sure that you're not
accessing stuff you're not supposed to
and if it sees you are
gonna say sorry this is this is not a
legal action to be taking now back in
the old days the verifier would not run
on code that was byte code generated at
runtime the compiler just trusted you
and then more recently people started to
think you know that's maybe not such a
good idea so starting somewhere around
Java five they they took away the
ability to generate byte code the cheats
which meant that all you could really do
is you could if you wanted you could use
Sun dot misc it has a special class
loader
that skips the verifier and that's what
it uses when it's doing field and method
reflection speed-up but you know then
you're using sun misc and that's a pain
and it's not easy to do and besides it's
going away in Java 9 and so that's not
good so what can we do well I mean if we
use reflection we can call set
accessible but that doesn't help because
reflection is still slow well that meant
you know starting in Java 5 and in Java
6 things were kind of tough and then
came Java 7 and the dynamic language
people gave us a gift invokedynamic
so this was originally created as you've
probably heard this was created for
languages like J Ruby groovy and and so
forth as a way to support dynamic
languages and I'm not going to talk at
all about that today because that's not
why we care about it so the interesting
thing is that once it got added into the
language people started realizing
there's other uses for it as well Java
uses it for lambdas and that's is
interesting because invokedynamic is the
first opcode effectively in the JBN that
you can't really directly invoke from
java code so this is sort of the first
non java JVM opcode out there so anyway
what is invokedynamic do effectively the
first time it's called it replaces
itself with the call that you want and
and you and it finds the call that you
want via something called a bootstrap
method and that thing can then at least
potentially be inlined after that which
means that you've got the opportunity
for your code to run pretty quickly
which is why the dynamic language folks
of course really love it
the only problem is because we can't
call and voc dynamic from Java that
means that ASM afire is not going to
help us figure out how to do it so the
next few slides are a little more
important now by the way I'm gonna have
a URL at the end of this slide deck both
to the slide deck itself and also to a
github project that has all the code
sample in here so don't panic if you're
not catching everything and don't try to
scribble it all down okay so how does
invokedynamic work and at a high level
your class your bike code it's it's
going to call the invoke dynamic opcode
and it's gonna be passing it a bootstrap
method and possibly some bootstrap
method arguments and that bootstrap
methods job is to create a method handle
wrap it in a call site and that'll be
returned back to the JVM and the JVM is
then going forward is going to use that
call site in place of the invoke dynamic
code so invoke dynamic really only ever
gets invoked once in any particular
location so going into a bit more detail
what's the bootstrap method for starters
so this is the thing that's responsible
for saying what we actually want to do
and it takes in a few parameters it
needs a lookup instance and this is
basically something you can use to find
method handles it takes the method name
that you're calling this seems to be
sort of a shout out to the dynamic
language folks say you know you were
actually calling some method and what's
its name but you don't really need to
worry about it too much in particular
we're not really going to use it at all
today the method type is the type of
method that it should be creating so
it's basically saying look I'm expecting
you to give me some opcode or some
method handle in the end that has the
effect of taking in a string and
returning an INT or however you want to
however you want to do it and then
finally you can have zero or more
bootstrap method constant arguments I
think you can have up to 253 total of
those and those can be things that
basically a class can refer to at you
know it's statically so strings
primitives class constants things like
that and then finally it takes
method handle error sorry it creates a
method handle and and wraps it inside of
a call site so with the method handle
well method handles basically refer to
the sorts of things you can do you can
think of them sort of as stand-ins for
opcodes in your bike code so these can
be constructors method indications or
field access there's there's other
things as well but in particular these
you get them from the lookup method
that's passed in now this lookup method
has visibility rules associated with it
and it's only going to be able to see
whatever the class that called
invokedynamic can see which doesn't help
us because remember the whole point of
thinking about using this is to access
private fields but lookup can also take
java.lang reflect fields or methods that
you've gotten through reflection and
work with those unreflecting instance
and turn it into a method handle and
unreflecting eater can take a field and
turn it into a field access and the
great thing is that if when you do your
reflection to get the field or method
handle a method and you call set
accessible on it well then the lookup
instance is going to say oh yeah you can
access this that's great so as long as
the security manager let you call set
accessible then the checks are done and
lookups going to be fine with it ok so I
mentioned finally the last thing you do
is you wrap your method handle into a
call cite the the reason for this level
of indirection is that in dynamic
languages you might actually want to
change the method handle over time but
for our purposes we're going to have a
constant not a mutable call site but a
constant call site and the great thing
about constant call sites are they are
wonderful candidates for inlining ok so
that's the theory let's take a look at a
little bit of practice and I'm gonna
start with the bootstrap method and I'm
gonna start particularly with the
bootstrap method that we're going to use
to access a field so the idea here is
someone's going to call us and they're
gonna say hey when when you return
something to me I want it to be a way to
access a particular field and so this
method it's going to be a static method
it's got to be static and accessible to
the class and it's as I said it's taking
in the three standard parameter
to look up the name that we don't use
and the method type and then I'm adding
two additional parameters on the first
is the class that owns the field and the
second is the name of the field that we
wish to access so what do we do here
well the first thing that we do is we we
ask for the owner we asked the owner
class for the declared field that was
passed in and that's just standard
reflection and then as in standard
reflection before we're going to call
set accessible to true so that field is
now accessible we can now use our lookup
to turn that into a getter and return a
call constant call sight around the
resulting method handle if I wanted to
deal with a method it would be a very
similar situation there's only a few
things that would be different I'd be
passing at a method name instead of a
field name and I'd be asking for the
declared method instead of the the
declared field and then finally instead
of calling unreflecting I just call
unreflective methods the next step is to
call them so this is going to be a JVM
JVM opcode and it's going to take in the
name of the method that we don't really
care about and the descriptor for that
method in other words this method should
be you know the method handle that I get
back in the call site what what should
it be taking in off the stack what
should it be putting back on the stack
then it needs a reference to the
bootstrap method and then finally any
bootstrap method constant argument so
you wanted to pass along yes question
yes the boot stir the question is does
this imply the bootstrap method needs to
be static and yes it does and that can
be a bit of a pain I'll actually talk in
a while about some ways that you can
deal with that basically you need to
pass in anything you want through the
bootstrap method arguments and that's
why they're there okay so let's say that
I want to call invokedynamic on our
field I well what's the first thing I do
I need to Envisat the invokedynamic
instructions so I gave it the name for
our method I have to tell it the
signature so in this case remember we
start on our
stacked with an instance of being and we
want to end up with an eyes so this is
like a method that takes in a beam and
returns an int that's what this
signature means the parentheses surround
the parameters after that you have the
return type and then a method handle and
this method handle is the thing that is
referring to our bootstrap method so
it's a static method in the bootstraps
class I'm putting that method hand of
the bootstrap method in a class called
bootstraps and the method name is get
field and then there's the signature of
the bootstrap method which I'll show you
in a little bit and then finally any
bootstrap method constant arguments so
in ASM if you want to pass a class you
really just pass a string that is the
name of the class and with an L and a
semicolon don't worry about those too
much and and then the second thing is is
the name of the field and that's a
string and so when ASM looks at the
bootstrap signature it's gonna realize
which one of these needs to be a class
which one of these needs to be a string
and do the corresponding correct things
so all of this is going to effectively
replace the original visit field
instruction get field that we had
question yes the question is are you
writing the bootstrap method in Java and
yes you can generate your bootstrap
method via ASM but I don't recommend it
unless you've got a really compelling
reason to do so generally better to
generate the bootstrap method right the
bootstrap method in Java because those
are that's easier and question
mmm-hmm the question is why are we
passing in a method name and the answer
is I don't know honestly I I'm sure it
gets used someplace but it's you say
it's mainly for debugging ah so the
method that is used for debugging is the
answer from someone who knows more than
me in the audience so okay so this is
how we call our our get filled bootstrap
method for the method for the get method
it's a pretty similar story except that
we pass in the method name and that
replaces what we originally had which
was visiting the invoke virtual
instruction okay so the last thing I
need to show you because it's a required
parameter is the bootstrap signature
this is kind of hairy fortunately
there's a method type class in in in the
JDK that you can use to build up these
signatures and basically you pass it
first parameter is the return type and
then the subsequent parameters are the
types of the different parameters are
passing in and then you turn all that
into a method descriptor string down
below and the small print is the actual
thing that it returns and it's really
small because I had to make it small
font to fit on the slide even though
we've already concatenated things
together and and and you know dropped
off all the classpath in for me or
decide not class path package name
information so I generally recommend
using the method type approach it's
gonna make your code more readable and
less painful all right
so at this point we can take this
bytecode similar to how we did our hello
world example we can take this bytecode
and create a juice on a fire and and and
go to town with it there's still a few
things that we need to do and the most
obvious is that we actually need to make
this a little bit more dynamic so that
instead of just doing this for the beam
class that we have in our example we can
do it for any class and the basic idea
here is to take the code I showed you at
the beginning for reflection and do it
but do it inside your
generate marshal method inside the code
inside the method that is generating
calling ASM to generate the Marshall
method so we go through each of our
declared fields and if they have an
annotation we get the okay well we need
to do this well now it's time to
generate the bytecode for that
particular annotated field and then
we'll do the same thing for our methods
and then we'll done so I unfortunately I
can't go into all the detail because of
obviously limited time but I can share
some some good news so remember our
benchmarks reflection took 516
nanoseconds hand-rolled code took 88
nanoseconds a good deal faster so if we
run our benchmark and this is all using
the Java micro benchmark harness which
is a good benchmarking tool for running
micro benchmarks like this if I if
instead I use the ASM generated code and
I'm passing in a number of different
types of beans some of them have values
different values some of them have null
strings some of them have non null
strings if I do that it's actually a
little bit faster which I have to say I
don't know why that's really weird but
your mileage may vary on this and in
particular I mentioned I was passing in
a number of different types of beans
some had string values in them some had
nulls and so forth
if during the phase during the warm-up
phase when the JIT compiler is deciding
how it's going to optimize things none
of the beans contain null strings then I
get this performance I honestly don't
know why I've been spending the last few
days trying to figure out my theory is
that what's going on is that if there
are never nulls the compiler starts to
say you know I can maybe deoptimization
ulch ech in my string builder here
because that seems like it's going to be
a waste of time and maybe that then
allows the compiler to say oh now this
is small enough to be in line which
means that something else later is not a
candidate for inlining I honestly don't
know I've tried looking at it with JIT
watch but JIT watch doesn't seem to show
JIT on generating bytecode or at least I
haven't figured out how to do that yet
so the good news is it's
still faster than reflection by a decent
amount but it is not as fast as hand
rolled depending one can hope as the JVM
keeps evolving and especially around as
the JIT continues to mature around
invoke dynamic that this story will get
better hopefully if nothing else it
won't get worse all right so any
questions before moving on to some some
sometimes hard learned lessons yes
question
I could have generated the hand-rolled
code oh so in other words at compile
time I could have had yes so in other
words so the question is another option
is to to take the the beam class and
before I even run Java C or maybe
through an annotation processor that
runs early on in Java C generate another
class which is the juice on a fire for
that and that's true that's an option
one reason and that's not a bad option
at all but there's a few challenges with
that one is it's still going to have to
be able to access those private fields
which means it's still stuck using
reflection another challenge with that
is is that it may complicate your build
process a little bit and sometimes it's
a lot easier just to be able to plug
these things in as classes and just use
them straight out ok so the question is
why am i using Java if I care about
these nanoseconds and that's a good
question and there's there's a few
answers for that first of all Java is
pretty fast and we're trying to make it
as fast as we can in some context now
it's true that you often want to ask
yourself does it matter if these beans
that we're marshalling we're getting
from the database the answer is almost
certainly no because database access
time is going to dwarf any differences
that we have here if you're writing a
general-purpose library though you don't
know where it's going to be used and it
may be you
in certain places that are performance
sensitive and then there's another
factors as a social fact one resistance
that people for example the PO dramatic
library I was talking about at the
beginning one resistance that people had
to using it some people was well it's
using reflections so it's got to be
pretty slow I don't want to use slow
code and the fact that it won't likely
matter isn't something that really
necessarily is something people think
about they just see reflection and worry
about speed so it can also be something
that lowers barrier to adoption in some
cases but it is a legitimate question
and I think in general you always want
to ask yourself is all of this worth the
trouble and the answer is almost all the
time no but it's a great tool to have in
your chest if it ever is worth the
trouble okay
so a few tips and tricks I've learned
probably the most important one is the
check class adapter class in the ASN
package this is something that can you
can wrap around really any visitor
including class Rider which is a visitor
and what it does is it looks at your
bike code and says is this bike code
that the verifier is gonna have any
issues with that I can tell and so in
particular it looks for situations where
you on your stack have an int and then
you try calling the two string method
and it's a primitive that doesn't have
one of those so it can say this is gonna
be a problem if you don't use this it's
there's no problem it's just that if
there's an error in your generated bike
code you're gonna get the the verifier
is gonna throw an exception which is not
going to be particularly helpful whereas
if the check class adapter catches this
it'll give you a very informative error
message it'll say oh right here's what
the bike code has been so far and here's
at each stage what the stack has looked
like here's where your problem happens
and after this I'm not sure what's going
on because you've got a problem but it
takes a little while to understand its
error messages but a whole lot less time
than the alternative one caveat if your
ABing ASM compute your maxes for you
your stack size and your local variable
counts then the check class adapter
wrapped around the class Rider can't do
much for you because it doesn't really
get to see the information
needs about stack.size and so forth in
that case one thing that you can do is
after you've generated your byte array
pass it into a class reader that's
wrapped inside a check class adapter and
that will then give it give you the
opportunity to find out any problems
another trick line numbers so the byte
code that I showed you or excuse me the
ASM code that I showed you didn't have
any line number code if you pass the
dash debug flag to the ASM afire it will
generate a bunch of additional stuff
it'll start putting in labels and it
will use those labels to give line
numbers to your code and it will also
use those labels to indicate scope of
local variables and give those local
variables names which makes life easier
if you're in a debugger the line number
is even if you're not in a debugger of
course are nice because they give you a
you know something to work with in the
stacks trace now if you've got line
numbers you also want to say what your
source file is and you do that with the
visit source command normally you would
say you know you know JSON slash food
Java what I like to do in this context
is have something that doesn't look at
all like a file name and it says says
hey look at my JSON afire byte code
generator which is sort of a clue that
okay this isn't exactly a line number in
the traditional sense but here's where
you want to start looking to create a
line number you need to put a label in
your code and then say the you know
right after that give a line number you
can give any line number you want my
recommendation is that the line number
should be a combination of a unique
number that's a multiple of something
big like a hundred or a thousand and
then add the number of the field that
you're currently dealing with that way
if you run into an exception you can
look back at the classes and figure out
the order the fields were in and then
say all right so this looks like this
occurred when dealing with the field X
the stack trace may not be very useful
for your users but if they passed that
stack trace on to you it will be
invaluable and and as I mentioned you
can also with the debug flag on the SMF
I have it talked about the local
variables which is which is great for
debugging so
bootstrap method arguments there are a
lot of things that can't be passed that
you would think you could pass and and
one of them is you can't pass in and
constants that refer to classes or
methods that your class can't see due to
access restrictions this can be a
problem like for example it would have
been great if I could have just passed
in the method handle for the method I
wanted to invoke instead of the string
constant that I then had to do
reflection on but that that could have
been private hence inaccessible and so
the JVM wouldn't been happy with me in
some cases even the class that you want
to work on is private and so you can't
even pass that so the trick to use in
this context is to create a static class
it might be the class that you're
already creating in that static class
put one or more fields that hold static
fields which hold the information that
you want to pass in and that you can get
through reflection if you have the
appropriate security manager permissions
then you pass a reference to that class
which is public to your bootstrap method
it knows then to use reflection to go in
and find those fields and pull that
information out so a little bit tricky
but in the general case this is
unfortunately something you will need to
do question was asked earlier does the
bootstrap method need to be written and
in ASMR can it be written in Java and
the answer is either but I strongly
again recommend doing it in Java because
it's easier to write Java than to write
Java that generates Java these days most
of us don't run with the security
manager often but if you do run with one
you need to be aware of what this kind
of code will need and generally the way
to find out is to start running in a
security manager and see what you need
you're basically going to need to be
able to load new classes you're going to
need to be able to do reflection and
call set accessible and and a few other
things if you're if you are going to run
inside of a security manager you'll also
need to do certain code inside of an
Access Controller do privileged call
wrapping a privileged action if you run
fine bugs on your code it'll tell you
about this that's how I found about
this in fact and so then you can do this
in you're in good shape
testing this is a little bit tricky the
technique that I found to work was to
create a new policy and set that policy
and your new policy should override the
implies method that takes in a
protection domain and a permission and
it should look at the permission and say
alright if this is one of the things
that I think I need then I'm gonna let
it through otherwise I'm not and then
you can have a unit test which which
verifies that things work it can also
verify that it didn't that it actually
used all the permissions you think it
needed if you do this a couple quick
comments you'll also need to set an MP
security manager for the duration of the
test and your your policy that you
provide while only allowing the things
that your code needs it also needs to
allow anything to happen that your tests
framework needs to do because it's doing
reflection all over the place and you
don't want to get in your test
frameworks way or well then things
aren't good so speaking of testing yes
you need to do a lot of testing on this
testing security permissions the
different types of classes that you
might deal with are they public are they
private are they in inner classes
inherited classes those sorts of things
are the properties primitives or objects
are they arrays or arrays of arrays
arrays of primitives arrays of objects
all these different things you want to
test how you deal with synthetic methods
if you're dealing with a class that
might have some of those if you're
generating line numbers you want to
actually get something to throw an
exception and and look at the stack
trace and see that it kind of looks the
right way it's it's worth it because
trust me you will find bugs this way and
then the last piece of advice is I kind
of mentioned earlier is don't do this if
you don't need to I think that may at
this point kind of go without saying you
know definitely benchmark your code
before optimizing at all and do as much
of the code as you can in Java
not just the bootstrap method but if
your if your method was going to do some
interesting stuff along the way after
accessing the field if you can push that
out into a separate method that you
right in a regular old Java class call
out to that that'll be better and with a
little luck the the in liners will take
care of it for you so it'll be just as
good as before okay so that's the talk
here's the promised the location of the
slides and the location of the code and
I'll now ask for questions but before
that I'm just going to want to ask
please fill out the surveys I haven't
seen a way to do this on schedule
builder but if you've got the the
somewhat buggy mobile app and you can
stand to use it if you could fill out
surveys I would really appreciate that
it's very very helpful to me and with
that thank you and are there any
questions yeah question was I used ASM
for this and I familiar with CG lib and
could I do this with CG lid and the
answers are yes yes only a little bit
and I have no idea so I'm familiar with
CG lib I've never used it and and so I
don't know how easy it would be to do I
don't know if CG lib has invokedynamic
support yeah did I so the question is
that I publish the benchmark no I
haven't published it but the benchmark
code is included in the github project
so you're welcome to download it and run
the benchmarks yourself and and I
encourage you to do that you'll you'll
basically just need to after your run
package run Java Josh our target slash
the the jar that it creates for the
benchmarks and and you can play around
and see the different results so yeah
other questions yes
so how many other libraries are using
this kind of strategy I'm not exactly
sure I know that hibernate for example
under the covers uses ASM actually des
CG lid use ASM under the covers I'm
suddenly wondering if it does it does
OKC gmail abuses ASM under the covers so
you know so there's a lot of packages
that use byte code generation probably
not too many using invoke dynamic yet
but I'm I so short I guess I have no
idea but it's a good question I'll try
to find out yes oh and that's the point
is that that when hibernate does it it's
not for performance it's for class
functionality purposes so that's very
good point yes okay so that the
observation was unit test framework
might do this like mockito type of
things for for mocking but again that's
for not performance but just to be able
to do stuff at all so they're probably
not using invoke dynamic all right well
thank you everyone thank you very much
for attending</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>