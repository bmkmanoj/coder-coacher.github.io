<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Fault Tolerance Made Easy | Coder Coacher - Coaching Coders</title><meta content="Fault Tolerance Made Easy - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Fault Tolerance Made Easy</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1w4i7NxpbI4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everybody to my talk about four
tolerant patterns applied thanks a lot
for showing up first of all one question
first who attended the talk of Ben
Christensen about Netflix head and
histories yesterday a few of you so for
the ones of you some of the things he
talked about will sound familiar so
sometime going to talk about with sound
familiar to you already because he
talked about that yesterday a bit but I
will talk about all that stuff in a more
general base and also about things that
you can use if you're not responsible
for one-third of the internet traffic at
all so also for the for the normal ones
of us the average folk um actually about
that talk when I gave that talk the
first time I told the people I've got
two talks I've got a earlier talk I gave
before about a lot of basic concepts and
patterns about patterns of for torrent
software design which is more in breaths
talk without code and then I created
that talk which more in depth talks so I
selected a few patterns and just drew it
down into it and say how can you code
this stuff because these are a few
patterns that you can implement quite
easily and which give you a still a
great head start for building resilient
systems in production and weather or to
ask the people all as I asked them which
talk to you want to hear the first one
in Brett's talk or the in-depth talk or
a mixture of both of them and I always
got the answer a mixture of both of them
so eventually I didn't want to play
around with to slide decks anymore so I
put all of the stuff into one slide deck
and today you will get a two-for-one
talk so hope that's fine for you so I
will go a little bit through the it into
the breath still focusing on the stuff
that we usually care for which is
actually
web systems and enterprise systems so I
don't want to look into patterns which
you can only apply if you buy if you
build something like a Mars Lander or
something like that I mean that's a lot
of fun but we can't use that in our
daily business usually okay my name is
uber friedrichsen and if you're not a
German do not even try to associate what
you just hurt with the letters that you
see here just remember the hashtag
that's enough and I'm working for a
quite cool company called code centric
also got the t-shirt of course polo for
that and which you probably also never
heard about which also isn't very
surprising because we don't have any
locations right here so we're only based
in Germany and the Netherlands actually
and in somewhere in Serbia at the moment
but i'm still waiting until we start
over first our first office somewhere in
the Welle then I'm the first one to be
here anyway and about my background
don't want to talk too much about so I
forgot a lot of things I did in the last
20 or 30 years so 30 years ago I started
for selling my first commercial software
20 years ago I started to do that for a
living and yeah I'm still doing it for a
living and still a lot of fun which is
great actually and one of my focus areas
is building resilient distributed
systems which are scalable and that's
what I'm going to talk about today so
can we start best I think quite good
start is starting up with three case
studies how not to build resilient
systems first one is situation that most
of you probably have seen in your life
as a professional software developer or
also as user the web server simply
doesn't respond anymore web server is
down and production the operators just
give you the admins give you a big alarm
nothing's going out in anymore
or they're completely stuck and panic
modes switched on and you're looking for
the reason for that and what you figure
out eventually is that your web server
sorry your database server doesn't
respond anymore because there's some
kind of patch job some jerk just wrote
which occupied all resources and it just
doesn't respond anymore and when you
look into the thread pools the
application server threats all wait for
the database server and the web server
threads all wait for the application
server nothing's going to happen anymore
which isn't actually that good because
your customers which on the other side
of the screen are really unhappy about
that and that's the nice way of
describing it I mean it would have been
a lot better if you would have a
graceful degradation of service so that
you give a feedback to the customers I
can still offer you some information
which I've got in my caches but you
can't put any orders or something like
that at the moment or at least sorry
with a counter and problem please try
again later but not just waiting waiting
waiting which is the worst thing to
happen actually second one so most of
you probably been to treasure island
yesterday and hurt some cool music from
room five and from dear my name's Black
Keys right sorry but that's also this
other band you really like and they are
playing a gig this year only one close
to your hometown and you really want to
have tickets for that one gig and we
exactly know when the sales for the
tickets are going to start and you sit
there have your coffee there your finger
on the mouse waiting till the time comes
and five three four three two one click
and nothing waiting waiting waiting
eventually the web server response you
get to the next screen and then while
later again and it's just completely so
slow that you think that there are some
Fed Ex guys carrying around every single
bit from the web server to your browser
but it's unbelievable and just before
you get to the checkout sessions gone
you're out and you start to feel like
travis bickle and taxi driver because a
minute later you see on Twitter all
tickets have been sold out let's been it
also something you don't want to
experience actually and the third one is
a little bit different we're developers
and sometimes we have to build
connection to external systems to
integrate external systems into our
application and we've got that very
special one which is not too reliable
actually so we built that integration
everything's fine it goes down to it we
test it everything's fine we bring it
out deployed into the production and
then one day the admin comes comes back
to you and says doesn't work very well
because you create these strange
mistakes in your code because sometimes
this integration just does not respond
via and on other time but then a moment
later it responds again and but you your
code was not prepared for that so you
build some handling into it and if it
does not respond to restart the line
which also bad idea because it takes
about five minutes to restart the line
and set up the connection again and so
you have no idea how to handle that
because sometimes respond sometimes does
not on but if it does not respond very
often in a in a line then you probably
have to restart the line because
sometimes the lines also dead so
it's quite hard to implement these were
just three examples about situations
where it's hard to handle these faults
that can appear and can happen actually
and what do all of the three case
studies have in common now all only
happening in production you will never
see that on your development systems you
will never see that in QA even not in
low tests you will only see that in
production I know you might ask me yeah
that's quite neat but what does that
have to do with fault tolerant software
design I mean that's quite
straightforward in production we need
high availability for our systems only
systems which work can produce money can
make our customers happy systems which
does not work no money no customers and
available sister availability requires
resilient system design which breaks
down to four tolerance for torrent
software design is the basis for
building resilient systems so making our
help our customers happy requires
foreign software design actually so in a
jar we have learnt that it's very
they're very important that we deliver
business features that we deliver
business value and that's completely
right what is the next step so not only
building systems which deliver the right
things but which are still which are
available all the time so that's the
next thing which either quite often
forgets by the way and there's one more
thing I want to mention it's a scale-out
thing I mean there's a new paradigm of
infrastructure around that we start to
adopt more and more often it's based its
use very often in cloud systems and in
big data systems so when we need to
scale we are no longer going to buy
bigger bigger and bigger machines
also becoming expensive more expensive
and he'll expensive but instead we are
just get taken more machines simple
commodity hardware standard operating
systems and just more pizza boxes and we
try to scale out instead of scaling up
which has a great business case on your
infrastructure level but and that's the
butt in here you don't have this nice
high-availability features built-in
anymore you don't have this nice
clustering built-in anymore which makes
all machines synchronize automatically
and especially you don't have the acid
properties for your data or anymore
because you'll go down to base
consistency and all that stuff and all
that means that you don't have for
torrents on the infrastructure level
anymore and therefore you have to
implement it on your application level
so if you're working in the cloud or
wherever or building big data systems or
just have some CA o he who tells you we
are going to scale out right now we have
to deal with that stuff okay where
should we start with the patterns I mean
for torrent software design as a domain
is huge it starts with embedded systems
goes up to mighty computer centers
multiple computer centers it goes from
very trivial things up to Mars Landers
and everything bone-dry science to some
huge pattern collection so we just need
to focus what I try to cover today it's
just even though I go a little bit into
the breath just a small area and I try
to focus on things that we can use in
the area of web application design and
enterprise system design actually ok
let's go breadth-first a few basics I
mean if you say ask someone should we
design our applications for each other
and everybody would say yeah that's cool
that's that's great that's a great idea
but what what does it actually mean this
for torrent software design so I just
brought three slides with some very very
basic terms to explain a little bit more
what for torrent software design
actually is about its first one three
terms fault error failure the very most
basic and most important terms and for
torrent software design fault isn't is a
potential error it's somewhere in the
system but it didn't fire yet so it
could be a back that where it has not
been it has no better has not fired yet
or it could be some weakness in your
heart whatever so it's it's a fault
error is when this Ford starts and fires
so when it's triggered so it's visible
inside the system important thing inside
the system we still might have some time
before it becomes a failure which is
visible from the outside and
fault-tolerance software design the core
objective for for torrent software
design is and that's a little bit
strange if you think about from so core
objective photon software design is
figuring out detecting and handling
arrows before they become failures but
sought but anyway okay but whenever we
detect something like that we try to
handle it before it becomes a failure so
I don't know why it's called fault
tolerant software design but anyway just
a little anecdote but Sir if I give that
talk in Germany as a little bit harder
slide because all three terms in German
translates with the same work it's a
fella feel I'd feel like it's always
have a hard time with that anyway
okay the next one in the literature
there are five types of failures which
we distinguish the first one is the one
most of you know very well crash failure
the system works and then all of a
sudden it doesn't work anymore nothing
happens anymore the easiest one motion
failure is a little bit trickier so
mission failure means getting reply or
get a reply reply you don't get a reply
you get a reply or get a reply River no
reply no reply you get one again so most
of the things give you most of the
requests give you reply but some do not
next one is even be a little bit more
mean its timing failure it gives you
reply but it's too late so especially
when you have hard time boundaries time
constraints timing failures you get
quite often there in those situation
next one response failures is about you
get a reply but unfortunately it's wrong
so let's quite often that software back
but also in scale out system so if you
have eventual consistency then you quite
often have to deal with that because
your data might be an inconsistent state
in here so that happens more often in
scale out no sequel situations than you
might imagine in Byzantine failures are
the real mean bastards I mean those
situations just went berserk they reply
or do not reply the givers right answer
the wrong one or whatever you have no
idea is it's just as if a chaos monkey
runs around and gives you some answers
these are really mean ones actually and
what I want to tell you with it about
that is most people when they think
about for torrent software designed only
think about crash failures but there's a
lot more and a lot and very much harder
to handle kinds of failures we have to
handle with an eventual consistency
database with that also attribute
mission
and missing data or as a mission a lack
of response in your day question was if
eventual consistency debase if you yeah
yeah okay if if that's an admission
failure over the response failure so if
you don't get any answer at all it would
be a mission failure if you just get
stale data it would be a response
failure from that at least I didn't make
up those definitions those are just from
little chariots but yeah yeah so let's
see these kind these are connected to
each other I shouldn't break that down
first time because that's at the most
constrained type of failure and these
are different kinds of fruits
constraints but you could bring them all
down to timing failures I mean that's a
timing failure where use at the time to
infinity and crash failure is that the
time that the Commission failures are
just repeated anyway but again the
message is is about a lot more than just
crash fails in his last slide I want to
talk about a little bit the leash is
just stepping upon need to be cautious
maybe you have seen them those
abbreviations before mean time to
failure meantime to recovery in mean
time between failure mean time to
failure just means the time span from
start of operation until the first
failure becomes visible mean time to
recover is from the first failure
becomes visible back to normal
operations time spent and mean time
between failure is just some of the bows
we need the last one just to calculate
availability because availability which
is very important in our systems is mean
time to failure / mean time between
failure which you could also write as
mean time to failure / mean time to
failure plus mean time to recovery and
if you think a little bit about that
we often think that for tolerance
software design is always strives to
maximize the mean time to failure but
there are a lot of situations where you
can't influence mean time to failure at
all this failure will happen and you
have you can do nothing about it that
it's going to happen actually and
therefore another core objective which
you see quite often in 4 torrent of
software design is trying to minimize
mean time to recovery so that you can
recover very quickly very easily from a
failure whenever it happens just to keep
availability hi that's that is the three
things I just wanted to tell you just to
give you a little bit more understanding
what this for torrent software design
domain is about now there's a lot of
patterns around in here this domain and
what I want to do now is just to present
you a few patterns and breaths limited
by the domain talked before about so web
application design and enterprise
application design so just to give you a
little bit better feeling how those for
you I mean it's a really really
interesting domain and I could I would
like everyone to dive into that because
it's a lot of fun going into this domain
i hope to spark your curiosity a little
bit today with that talk to dive deeper
into that domain anyway so just let's
scan through a few patterns before we go
down to the code level all those
patterns you can somehow categorize into
a quite simple taxonomy the first part
of the texan ami is the core
error-handling flow first step is of
course detecting there's an arrow is
there and if you have detected an arrow
you have two options either you can try
to recover immediately from that error
or in cases where you don't have the
time or the information or the resources
to immediately recover from the air
are you try to mitigate the error that's
what you have quite often in overload
situations you often go for mitigation
because you can't heal your systems
immediately and the last step is a
little bit off line that's forged
treatments so later on you try to I
shouldn't do that p later on you try to
figure out what's the fault that caused
the arrow and try to resolve that get
rid of that and there are two more
categories which support all this this
flow is first or some just architectural
patterns which help you to build some
structure which make it easier to
implement this flow and then fall
prevention patterns so I mean if you
figure out a fault before it turns into
an error it's always a good idea and i
will show you just some patterns from
those two may from this domain that you
get a better feeling how these patterns
look like and what they're about let's
start with few architectural patterns ah
by the way don't try to read that stuff
because what what you will hear from me
and what's written down there is
completely different these are the
slides from the other talk I talked
about I were talking for an hour about
those about only those patterns and I
will talk about five to ten minutes
right now about the pattern so you will
get nothing if you try to read so just
read the first line and then look at me
or at the picture of whatever or to the
ground however you can get advantage not
to read that text anyway so first panel
is units of mitigation it's the single
core most important pattern of photo and
software design it's also known as
failure units or spike heads I mean it
just means if your system crash if yeah
there's a failure don't let the system
crash completely just let crash a part
of it so as an architect you have
another concern to separate your
building blocks into and which is now
also
building correct failure units or units
of mitigation or you call that and most
of the other patterns use that as a
basis a failure unit block which they're
with their are related to the other ones
quite well known so another pattern in
this domain is redundancy very Merry
many patterns rely on redundancy so that
you have redundant units of mitigation
or failure units around most of the
people think that you can only use
redundancy for credit for handling fresh
failures but actually you can use
redundancy for all kinds of failures i
showed you before it's a little bit more
complicated but you can do that at the
third one I won't just want to throw you
from the architectural domain level is
the escalation pattern which says you
need to build an escalation strategy for
anger failures I mean you probably also
had that situation before you build some
integration to a database or to a
different service so calling a different
application or something like that and
there's this mean thing called IO
exception that could come back and I
mean what are we doing if we get an IO
exception has developed us when we sit
on our idea Ethan what the heck should
we do about that and what we're doing is
of course you're wrapping into an
runtime exception restore that stuff and
hope that someone else is going to care
about that it's going to be okay of
course no one is going to care about
that and on the top level lupus will be
eventually written into the log file and
we try to go on and hope that everything
will work fine which it doesn't but
anyway and we're not doing that because
we're lazy or we mean or unwilling or
something like that we're just doing
that because we have no idea how to
handle it in this place this is
completely right quite often you have no
idea how to handle a failure an error at
the sit at the place where it happens so
what you need is to you have to build in
some escalation levels where you handle
different types of
arrows that are going to happen some
languages have that built in like along
with that work a supervisor concept Java
doesn't have something like that
actually so yeah we can mean why we can
use the Aqua library which gives us
basically the same concept as we have in
our line available or we can build
ourselves but we need that we'll see
that later okay let's see those where
some architecture a few error detection
patterns the first one is also again
obvious you all know that monitor so
yeah it makes sense to look from inside
an application if some errors happen but
also some errors you can't detect from
the inside so you have to look from the
outside for instance if your application
crashes and you better don't put the
monitor on the same node as your
application of course because if the
node goes down then also your monitor is
down and you haven't got anything okay
and just to show you a bit how broad
this domain is something very different
from the monitor data versioning which
you need quite often if you go to the
domain of eventual consistency because
sometimes you just need to figure out if
your data is stale if it's an
inconsistent and what you use then is
some kind of word animation is no matter
if you use something simple like
timestamp or more complicated like
vector clocks or whatever it just helps
you to figure out this data is not in
sync especially if you're not reading
just the same entity from different
nodes but if you read related entities
which do not match at the moment which
you also can have in those systems and
the last one here is again something
completely different it's routine
maintenance if you have a machine
running all the time what are you doing
to make sure that it's running all the
time you do some maintenance you have a
maintenance schedule and you can do the
same thing for systems which need to be
up all the time it's not about monitor
but you go through the data look if it's
consistent and stuff like that is also
you can also use this pattern for
prevention actually let the things we're
talking about here recovery first one is
the error handler which simply means
handle the arrow at the different place
oh don't handle the separate error
handling and your business logic where
the error happens is it's got two
reasons I've talked about it before a
little bit sometimes you just don't have
the information that you need to handle
the arrow at the place where it occurs
so you better have to escalate it a
little bit to a place where you have the
information and the second thing is
quite more trivial if you mix error
handling code and business logic code
it's some code which is usually quite
hard to maintain so therefore also from
our maintenance level a pointer
maintenance point of view it really
makes sense this pattern and then this
is a more of a meta pattern so just to
strive that one you have to decide if
you have a error and you want to recover
from it how to do that so do you just
want to apply retry which is one pattern
retry the action the operation or do you
need to roll back which is another
pattern then if you want to roll back
you need some checkpoint information to
roll back to which is another pattern
all you're going to just want to roll
forward skip that step it's quite often
an option but most people don't think
about that or if you do the winter
windows alternative reboot the system so
reboot the service here and or if you
have to reset the data or whatever so
that's these kind of patterns which are
usually used in the domain of error
recovery and the last one just for the
sake of completeness of course failover
we all know that one node goes nuts so
we use we fail over to another a note
just for minimizing time to recovery
actually from the outside it's
minimizing from of time to recovery
because
the one note goes into failure mode we
switch over to the other one we're back
to normal operation I mean that one note
is not back to operations but the system
as a whole is back to normal operation
needs redundancy of course mitigation
this is one very favorite pattern
shedload actually because it's very
simple to implement I've got the code
for that later on and I also so I will
dive more into detail of that the idea
of that is if your system gets under
heavy load don't process or requests
anymore just shed some of them filter
some out you can tune that pattern a
little bit by letting started setting
sessions going through not accepting new
sessions anymore however you're going to
do that we see a little bit more about
that later on and another one just again
to show the breads of this domain marked
data so you read some data and you
figure out its tail or it's corrupted or
whatever it's broken and it's not
necessary that every single axis which
is going to come later also has to
figure it out so we can just set a flag
there this one story this one's tail at
the moment so please don't use that and
we can update our all our read requests
to only read data which is not flagged
and then we can have some routine
maintenance job later on which is going
to look for marked records and trying to
repair them sometimes also you use that
when you even if you just don't have the
time to repair that okay and just one
last one so forth treatment it's
basically the domain of root cause
analysis and figuring out if it really
make sense to repair that back or if we
should just let that sleeping dog lie
because it doesn't make real sense
because of probability that if that's
happened again and what it costs
this error is just just doesn't make
sense but here's one I really like it's
small patches small patches just says
you've got a bug in your software you
fix that back and you roll it out and
the recommendation of the pattern is
roll out small patches don't make big
patches because the probability that by
fixing a dozen box you introduce five
new bucks into your system is way too
high so go with small patches and you
think about that for a little while to
say oh that means more deployments which
means you need automation for that
because otherwise it becomes error-prone
and very boring and which topped up to
the tip leads you to continuous delivery
I think that's interesting process it's
it's a driver from a complete different
domain so if you still try to convince
your boss to go into continuous delivery
and he still hesitates from there yeah
you've got another argument for doing
that and as I said before a large domain
so there's a lot more of stuff we could
talk about but actually we need to focus
and I promised you to show you some code
how to implement some of the patterns so
let's go down to the implementation
level to the code I promised in the very
beginning core question right now is how
hard is it to implement those patterns
and to be frank some of the patterns are
mean bastards they are really hard to
design properly and they're really hard
to implement properly so it's not for
free definitely not so something like a
good escalation strategy you probably do
it wrong at least three times before you
get it right and some other things but
there are some patterns in this domain
which are really easy to implement and
which give you a real great heat head
start when you try to build more
resilience into your systems and I
collected a few of them and I just want
to prevent them to you in the next
minutes let's start with a very basic
one timeouts whenever you want to start
build resilience into your systems
timeouts usually the pattern to start
with I talked about that case study
where Bay where your web server doesn't
respond anymore and because all threats
were waiting infinitely definitely on
the on the interface to the application
server and a timeout would have helped
actually how hard is it to implement a
timeout in some cases it's really easy
because a lot of functions in the Java
library already provide us with two
variants weather with two errors of the
cord so one which is blocking
indefinitely and one which we can
provide a timeout and whenever we have
the choice we should use the one with
the timeout actually now some people say
in but what should i do if i run into
that timeout I didn't do that before
because I had no idea but but actually
if you want to build a resilient system
that's not an option to hide behind that
because we have to think about what we
need to do maybe we have to think with
the whole team about how to handle that
situation when we run to in a time also
what could be a graceful degradation of
service or how should we handle all that
stuff so we need to ask that question
and do the tough job and if we have
something like this blocking action
which does not give us a timeout option
we build it ourselves quite
straightforward here just using stuff
from the standard libraries so
we're a bit into a callable actually and
we use an executor so I was a sailor
with a single thread and then we're just
submitting it and later on right here we
have that future get variant with the
time out again where we can wait for
this plot for this action to complete
auto time out it's just a few lines of
code and it's basically production-ready
this code and if that's just is still
too much boilerplate for you to write
you can go to library like guava for
instance where you have that simple time
limiter which internally basically does
the same thing if you've seen in the
slide before and have that nice little
call here this limiter call with timeout
and then you're back on the same level
so it's just a few lines of code to wrap
everything into a timeout action
whatever is critical for you not much of
magic straightforward and you've done
the biggest step you can do to go to
into more resilient software design okay
now we've got a lot about time odds
let's go one pat on the head your other
application is down you'll just hit the
timeout and you don't want to figure it
out over and over again and let every
single request to that interface run
into a timeout so what can we do about
that so we want to fail fast because we
know this interface is dead at the
moment so how can we implement that and
there's another nice pattern called
circuit breaker Michael Naga described
in this book release it so that's where
I've described it first and there are a
lot of errands around here out here what
is pattern about you have a client and
you have a resource you want to access
and you go and send out the request and
there's a circuit breaker before sitting
in front of the resource and if the
resource is available it just sends you
through and if the circuit breaker knows
it's not available it just fades
immediately it says you nothing to get
here
try it later again p and for
implementing that it uses a little state
machine actually and this state machine
again there are a lot of different
variants around there I use the original
one that Michael and I got described
here so it's it starts up actually when
the test circuit breaker starts up and
start in a closed mode so resources
available whenever a caller comes in it
just passes it through and then it
watches for the result and if it is if
the answer is successful it resets the
counter if the call fails it increases
the counter so and if we reach a certain
threshold so a lot of failures in a row
then probably the resource is gone for
at the moment and then we just trip the
breaker which is means we go to the open
state in the open state whenever we
receive a request we just say nope
nothing's not working at them at the
moment try again later and we wait for a
while and then we will of course because
we don't want to leave that open
eternally I mean the resource might have
recovered meanwhile so we have to watch
once in a while is the resource
available again how long this time out
here is depends on the type of resources
could be a few milliseconds could be
some seconds minutes back two hours
depends on the type of resource you have
you have to figure that out usually and
in this case we go to naff open state
and here when you get the next call you
try it once again and if it's okay if it
works again we go back to the closed
state and if it doesn't work you go back
to the open state and just wait for it
how to implement that so I just use the
simple variant non multithreading right
here just to show you first the base
principles you can make that or it's not
too hard to adopt that implementation to
concurrency so
it's you have to resource some of the
functions and you have to make some of
the variables atomic and stuff like that
but but it's not a to big deal but just
for the sake of simplicity are put it
like here it's just the standard stuff
here so the variables and the
constructor we don't need to goto into
that into detail here's the call
function so uh what I implements my
resource so I assume that the circuit
breaker is just a wrapper around my
resource I want to watch and here's that
excess function so let's skip the first
if at the moment and because I we start
with the closed state so if state is
open though we're not open so we're
closed so it goes down to the try and
here trying to access a resource and
everything's okay we're going to success
and otherwise if the excess fails I mean
this should use timeout and if we catch
a timeout exception then then we should
go to the fail method and those methods
are quite straightforward actually
success I was a little bit lazy goes
through the reset which resets the
counter and fail just increases the
counter and the to counter it's not on
the threshold I tripped the breaker
which just says I go to a state open and
I stall the time whenever I tripped the
breaker and now we go back to the other
slide here and in the open state next
excess goes here and what I do here is I
check the timeout and I throw new
resource unavailable cept again I was a
little bit lazy to keep the slides short
so you could also do that in a different
order and stuff like that so I optimized
it a bit further on for this just for
the presentation but but it's it's about
the principle so 10 lines of code more
wouldn't make a big difference and here
you dare you just check if you went
across the timeout in this case you go
to half open and again I was a little
bit lazy and put the counter to
threshold which means
that if I go the next time in here and
it fails i just bought go a I just would
go on top of threshold which means I
would flip the breaker again which is
actually what we wanted to have and
that's basically it sorry so the remark
was that you also have to use the
pattern and you have to also watch super
fast fail timeouts or where the system
just responded but it just gave you an
empty result set and stuff like that
yeah let's it's actually actually true
so it's just for non-responding this
opponent as I said there are a lot of
variants around out there and their
implementations around for instance in
the history x which men christian you
get yesterday talked about and if you
look into that it's a little bit more of
magic that doing in there actually but
as a core pattern for a start that's
okay again you really have to make that
work in a multithreading environment but
i just wanted to leave all the magis
reading Cody it's just another comment
the code you're showing doesn't have any
sense of time for the failures and
usually the service you have has a known
rate of failure like point point one
percent or something like that so
you don't want to time it out over three
hours when it's got less than that that
that's as another way of optimization if
you already know what kind of failure
rate you usually have and stuff like
that I mean it's a very basic pattern
and it's what I talk about is here to go
from nothing to something not for
nothing to optimal so when we start to
go into resilient system design I mean
it's better to have something in here
and start with that and then you
probably come up with this comments you
had late ahead about that so did
figuring out how the standard failure
rate is and all that stuff to get better
yes absolutely yeah again it's a sketch
just to show that the basic pattern is
quite straightforward you have
indefinitely indefinite space for
optimizations in here definitely but if
you start with that you will quite soon
figure out those things but but you have
the starting point and what I want to
talk about is get that starting point
get it started start working with those
patterns and your system will soon
become a lot more resilient next one
fail fast the idea is you have a quite
expensive action and what you would use
a lot of different resources and it
doesn't make a lot of sense to start
that action if one of those resources
isn't available at the moment so as I
said before one of the basic basic
principles or four tall and software
design is fail fast if you know you're
going to fail fail as fast as possible
don't wait to fail so what you're going
to do is you build in some kind of fail
fast God so you send out the request for
the day for the expense of action and
first a favor fast car checks if all of
all required resources available and if
yes it forwards to this expensive
actions and lets it lets it executes
let's execute in the other case it just
says no I won't execute at the moment
and since we have those nice circuit
breakers it's quite straightforward to
implement something like fail fast guard
I mean actually we have a set of
resources which are rapists are code
breakers and all we have to do right now
is to implement that God to check if
that set of resources are all closed at
the moment of also it also i could break
us a closed so again good starting point
and then if you have got my expensive
action here I just in the first line I
just have to go
for the fail fast check and if this
succeeds I can start executing the
action again makes your system a bit
more resilient again a little bit more
so in again lots of place for
optimizations as always let's go to the
second case study the this site which
when that terrible slow on the load so
let's go into the shed load pattern
which is one of several patterns how we
could handle that the idea is we just
get too many requests which hit our
server and we don't want to let the
server the service you go toast so what
we're doing here we build in some kind
of gatekeeper in between we have the
requests which are coming in we have a
monitor which one it was the load I mean
we should have a monitor any way to
monitor the load and what else is going
on on that server so we are people who
are doing good operations and we have
that monitor in place and what we are
going to do is we check how high the
load is and depending on the load we
either shed some requests or we let them
go through how can we implement that
stuff so again as usual i'm a lazy kind
of guy so I try to lazy implementation
first I try to implement that first
force web application as a filter it's
not the best place to implement that ad
because now we are already in the server
somehow but it's still a lot better to
return the requests quite in the
beginning then to let it go through
through all the layers of our
application star of our application code
down in the application server and mr.
down to the database and everything like
that so the gatekeeper is in our filter
this is just some initialization
staff what we knew use the random for we
will see soon that's just for the
shedding strategy but it's just one way
of handling it he has the core method so
the first thing is how we need to get
the load a million ways to do that so I
don't go into detail how we get the
current load number you will figure that
out jmx whatever or have it somewhere in
a cache which you update from the other
side use some hazel cast whatever you
will find a way to get that managed and
then you are the question should we
share the load and if yes we just sent
back what that it's it's the currently
service unavailable I think it's a 543
HTTP 503 service unavailable with some
recommendation headers so try after
whatever some minutes some seconds try
again usually you use some kind of error
page that you configure in your web.xml
or something like that for that but it's
it's good enough right here so we've got
it in here and whatever how is that show
Chet implemented I mean that's just one
way of implementing it so figure out
your own strategy I just use a very
simple one because it's better than
nothing again everything is better than
nothing first first of all so what I do
here is just if we are still below our
threshold no we shouldn't shed anything
so all requests go through if we go
about about that I just calculate some
simple number which says it's 0 just if
it's just the threshold and it's one if
it hits the maximum load so we calculate
some number between 0 and 1 and then I
get some random number right here and if
that's how is that yeah if it's smaller
than my shape boundary just calculated
before I shed request that's basically
it so random shedding of request but
depending on the load you can still
optimize that figuring out if that's
out of a session that you already
started or whatever and if you don't
want to have in the filter but as a
separate service go for no GS go forward
checks for whatever it's quite
straightforward to build your own proxy
server meanwhile it's not a it's not big
magic anymore and sometimes it's even
okay if you just like work with some
static limitation like static request
limitation which you can just use a
module for an engine XO something else I
mean it's not the core idea of that
pattern but sometimes even that's okay
let's try some next to the next one
quite quickly the fair overworked it's a
similar one I'm so I've got to some
request processing with using some
resources but I also have some routine
work going on in the background maybe
some routine maintenance or some veg
calculations which clear i calculated we
have data some MapReduce talk whatever
is going on in the background and
situation i can hit is here usually
everything is fine and if I get more
request processing still everything is
fine but i'll still get even more
request processing that routine work
which are maybe could defer just makes
me hit the overload area and my service
goes down for that so what the picture i
want to get is here we're still the same
but here i want to cut that down and
implementation could be quite straight
forward again here so i just sketched
some kind of batch loop here i mean the
real bad framework of your will cease
look differently so i start the batch
here and while i'm not done i do the
next step and calculate and loop on and
again here i get the load and the load
if the load is bigger and special a wait
for fixed time it's the easiest way to
go forward with that so i built
something into my batch job we just have
a look at my load and says oh load is
high so let's just delay a bit or i
cannot even implement it on an adaptive
way so let us say a pet
pending on my current load that I'm
having I'm waiting longer or shorter
period of time or whatever you figure
out but again quite straightforward to
build into your system and service
quality becomes better again leaky
bucket is so input is so simple that I
almost do not dare to show it to you
leaky bucket is the idea what I had with
that interface which quite often react
but not always and sometimes but
sometimes get to that situation that
it's really down the interface and then
I have to restart the service and I have
to figure out that situation and the
idea of leaky bucket is if I've got a
problem I fill some virtual bucket put
some water into it and on the other hand
periodically i leaked a bit of water out
of it so if I get an arrow once in a
while it never will completely fill up
an overflow it will always go down but
if I get a lot of errors it will fill up
quite quickly and then I see I probably
really have a problem not just a
transient one at the moment but a real
problem i have to take care about and in
this case i need to do some error
handling which by the way a nice way of
separating the place where error occurs
and the handling of the error and the
implementation again it's so simple we
also have that in our system just a
little bit more stuff around it but not
a lot it's terribly easy sorry so you
have your capacity and you fill it up
and yeah if it's well if it's higher
than capacity it it's overflow is true
and otherwise periodically it leaks and
however you're going maybe you have a
periodic job or whatever with every
single request you will get a bit or
however you're going to do that
differently straightforward last one is
limited reach fries
to overcome transient arrows again here
it's another alternative to deal with
that general pattern here is also quite
straightforward so you just try to do
your action and if it does fail you do
it unless you hit a certain number of
retries only important thing here your
action should be idempotent everything
else is not so good actually but it's
almost most of the time it's quite
straightforward to make that item potent
and since a rule of thumb says you
shouldn't try to retry too often because
if you really have a problem and you
retry retry retry it's like hitting the
refresh button of the browser again to
make reloading faster so better don't do
that just reach right ones and you can
even abbreviate that one if your service
gives you a boolean straightforward
stuff there are some more patterns that
you could implement quite easily like
complete parameter checking which the
pattern or dealing with the mark data
and so on yes s some more I just wanted
to give you some idea how
straightforward it is to go to start
building resilient systems and hope that
I sparked a little bit the curiosity and
then if you come back home and your boss
asked you what did you learn at javaone
you say I learned a lot of cool stuff
but don't leave me alone i have to make
my system a little bit more resilient
right now and if I got that true then my
mission is accomplished actually in the
slides you will some more reading the
book of Michael and I got a must-read if
you haven't read it before I hope
everyone read it before but if not get
it and read it a nice book from robot
hanmer about 4,000 software designed the
classic right down here from Andrew
Tenenbaum it's always important if you
go into the distributed system read that
one and it's a nice collection of some
scalability and for torrents patterns
from here from James Hamilton that's
just a paper which you can down on the
internet yeah and if you fell asleep for
the last 60 minutes
just one sentence you want to take away
with you it's it's all about for Jack
sure we do not develop for development
we do not develop for QA we develop for
production and that's basically it
thanks a lot for your time and patience</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>