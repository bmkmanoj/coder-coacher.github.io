<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON2577   Down to Earth Microservices with Java EE | Coder Coacher - Coaching Coders</title><meta content="CON2577   Down to Earth Microservices with Java EE - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON2577   Down to Earth Microservices with Java EE</b></h2><h5 class="post__date">2015-12-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bS6zKgMb8So" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone my name is Reza Roman
I'm a Java evangelist with the weblogic
glassfish java ee team I'm also leading
this track that you're currently on so
feel free to reach out to me if you have
any questions comments concerns not just
on this session but pretty much anything
on the gym certainly on in Java one and
certainly on the job I e-track do excuse
my voice this is my talk number Five's
having a little bit of time made a hard
time maintaining my voice I think this
is a number of such a number 44 Steve so
he's going to have similar difficulties
all right so with all that all aside the
first thing I want to tell you is we are
running the session in an open Q&amp;amp;A
format so what this means is that if you
have a question raise your hand right
away and we'll get that question
addressed because we'll be actually
going through in relatively quick
succession quite a few complex concepts
and this is this particular clock is
more broad than it is necessarily deep
so it's a it's a oaken Q&amp;amp;A format is
good for that ok so what is this talk
about what is it that you expect to get
out of it I hope that I've or rather way
then we have in this case named the
session well there is a reason why it's
called down-to-earth microservices and
there is a reason why it's called
down-to-earth microservices with Java EE
first and foremost if you have seen
other microservices sessions I think
this session will have a slightly
different tone to it so most early i'm
not here up here to do cheerleading for
microservices what I intend to do rather
is give you a practitioners viewpoint on
what microservices or to be and what its
value proposition is although I am an
evangelist in all reality I have spent
the better part of my career really
being a consultant in in blue collar
just vanilla I tea shops and a lot of
the perspectives in this talk come from
that and Steve also has a similar
pattern
let him explain his background in a
moment but we both share in very similar
backgrounds and I believe for that
reason relatively similar perspectives
on this topic as well the Java EE talk
part is obviously I think fairly obvious
of what we're going to do then is after
we establish what the down-to-earth view
of micro services are we are doing then
going to try to establish well how do
you go about doing those practical
microservices using the Java EE platform
okay so with that I'll let Steve also
introduced himself hi ok so I'm a
founder of pirate but I'm also spent
most of my career in field consulting so
I also run a middleware consultancy
company that focused purely on java
middleware and that includes everything
from basic web applications right
through to large-scale sour
infrastructure so what's what we're
bringing really is our experience of of
deploying these architectures and
previous generation in the field right
very good so I wouldn't have agendas
perhaps somewhat the wrong word for this
particular slide more appropriately what
we are attempting to do is these things
we're attempting to address these goals
in the session first and foremost what
are microservices both from a if you
will pura standpoint as well as from a
more pragmatic standpoint and answering
trying to answer the question you know
for a rather help you answer the
question of whether microservices are
right for you or not and then finally
you know what are what is sort of
synergy between microservices and java
how do you go about implementing
microservices using the Java EE platform
all right so let's start in from the
beginning what exactly are micro
services and sadly enough it's
incredibly vague at this stage and that
is a very big problem in terms of any
practical adoption and surly effective
at option of micro services so is
it's important to disable to try to
decipher someone some of the stuff
that's going on here and the unfortunate
truth that we need to start with is that
the naming the current naming in the
micro services sort of nomenclature is
absolutely terrible because in reality
as well as I'll explain micro services
are not necessarily micro and not
necessarily services so that tells you
you know kind of what is going on with
this entire situation and similarly you
hear words like monolith well in reality
one with is a very black-and-white term
you know nobody says monolith and means
and means a warm fuzzy feeling after
that and even that is is very deceptive
if you will because none of this as in
most things in computing really is that
black and white and I think we all
recognizes so there's definitely a quite
a bit of commercialization and quite a
bit of vendor agendas going on in the
micro services conversation at the
moment and those are agendas that you as
developers ought to start sifting
through and understanding what those are
unfortunately I think Steve and I are
not alone I think more and more when I
go to conferences I am seeing people you
know provide a more pragmatic view and
trying to sort of cut through short cut
some of the sort of not so great ideas
and commercial interests and getting to
the core of what is actually important
about this um the first thing that you
ought to know is that in reality none of
this is very new that that is the truth
of the matter we've web dealt with these
same concerns in many different
conditions in our industry starting from
all the way from unix to corbett jenny
to things like HIV 1 and 2 to comment
decom to SGI and finally to soap and an
ESB these are all of these are attempts
at solving a basic fundamental problem
which we'll get to in a second but
frankly a more intellectually honest
name of this you know that wouldn't
wouldn't be so marketing or
and hence wouldn't be so confusing to
you as developers which really should
have been something like so our to or or
son of saw okay that is I believe that
the real truth behind microservices I
think that will help you kind of orient
your thinking to the rest of our towards
the rest of our talk certainly so let's
try to arrive at a more sane more
reasonable definition of what
microservices really are and in fact
this goes down to the basic fundamental
problem that i mentioned that all of
these predecessors of microservices were
trying to solve so this is a definition
that I find fairly comfortable it's
simply taking a larger system not
necessarily a large system but a larger
system and decomposing it into smaller
independently deployable parts not
necessarily small but simply smaller by
comparison to the larger system that you
are that you are trying to address that
you're trying to apply this concepts to
now beyond my if you will pragmatic
definition that I I feel comfortable
with there are people that are that will
give you different definitions so it's
it's it bears there's some value to
exploring precisely what those
definitions are and sort of what the
idea is behind them actually are so by
and large are people that are the most
enthusiastic proponents of micro
services will most certainly distress
distance themselves from soap and yes be
so the idea here you shouldn't be using
soap you know for for doing
microservices you should definitely just
stick to rest and perhaps some
asynchronous messaging if you have
actually need to in case of java ee that
would be socially JMS messages they
definitely want you to get away from
centralized orchestration and
integration so sort of an indication
tier with ESP said and they definitely
think those are bad things and frankly I
tend to agree you know that these are in
fact not very helpful in solving the
fundamental problem or breaking
down a large system into smaller
independent independent parts purists
also take things for like testing DevOps
and continuous delivery for granted so
they will tell they will say signed up
kind of grandiose statements that oh if
you're doing microservices then you need
to do these things in addition to
microservices a moment of honesty here
who can hear can can say that they have
basically solved these problems okay
these three problems testing devops
continuous delivery continuous
integration anyone then I guess what I'm
not raising my hand either and i doubt
Stevie's i did so this tells you you
know that there's a fundamental problem
here with the religion versus the
pragmatism and also purists by and large
focus on extremely fine grain services
I've seen some rather ridiculous
statements like okay it should be 200
lines or or less you know it's like
Paris the building code of Paris if it's
a larger than so many stories you're not
doing a micro service this is all
religion this is very hard this kind of
thinking is very far removed from
practicalities of of vanilla real-world
applications and enterprises okay so you
might think I think this is all nonsense
okay and the answer is i I really don't
think so if I really thought this was
nonsense frankly I would altogether
ignore this topic and let it die its own
timely death but I do not think so I do
think there is a kernel of truth here
that we need to arrive at and a kernel
of value that we must arrive at so let's
get to that what is actually the problem
here that that is relevant to most
organizations the problem simply is
maintenance okay so if you think about
the big three big things that most
organizations deal with IT organizations
deal with these things are three things
okay first and foremost is understanding
requirement
and delivering business value the other
is resourcing and this is a big one okay
doing less with more and we're squeezed
more and more for doing less with us
more with less okay and finally a
stability ok so our operational
stability is a big concern and believe
it or not if you go too far down the
microservices route you will achieve
none of these ok but there is an
important one that goes to the kernel of
truth in terms of value and that is
maintainability ok so the reality is
that all large systems experience
entropy ok no matter how will you
architect it how will you maintain it it
experiences entropy and the larger the
system is the and the more people work
on that work on it the larger the in the
larger the rate of entropy so I think
you can look at various studies out
there and what the truth of the matter
is that if you have more than 10 or 12
roughly 10 or 12 or 10 to 15 folks on
the upper end actually working on a
system you will experience entropy ok so
that is the fundamental problem that
you're trying to solve if you have a
system that is not you know that
requires obviously more than 10 or 15
people that's a very clear indicator
that you really need to think about
microservices now the reality that I've
seen for a long time is actually we've
learned that lesson by ourselves by and
large most development teams are
actually do not approach that scale or
or 10 or 10 to 12 engineers already we
already naturally do do do subsystem and
we'll talk about in a second what
correlation between those things are yes
sir
great
you
the short answer to the problem is it
depends on what what your definition of
saw is if you mean service-oriented
architecture from it from a technology
at agnostic standpoint which is what I
interpret so to be then factly there is
nothing new here for you what's really
happening here in the long and short of
it is a technology refresh we're doing
the same thing with a slightly different
set of tools and perhaps some best
practices that will learn from the
sawara that's really the bottom line but
that's too simplistic of an answer we
need to dive in a bit deeper to
understand what what and why okay so um
correct so let's let's see it'll say you
have that problem let's say you have a
problem where you have a large enough
system that cannot be maintained by a
team of two and logically maintained by
a team of 10 to 12 people what do you
then do well in some cases it will
actually be quite simple and this is
actually happen more often than not is
that systems are actually naturally
organize themselves into subsystems that
correspond to largely business units or
business concerns okay this is why we
tend not to cross that 10 to 10 to 12
boundary we do have large logical
systems in the enterprise but they are
tend to naturally already segment
themselves into subsystems and there are
also cases where technology makes it a
rather obvious that you know a system
should be decoupled and you should
really have a separate distributed
distributed module for that and actually
the example that Steve will be showing
is more along those lines a little bit
later now the other question you should
ask yourself is well we can do all of
this we can simply do this via
modularity simple java packaging why are
we doing any of this there's a that
legitimate and valid argument to be made
that in reality while you can try to
modularize applications this way doing
it in a properly distributed
architecture in terms of having remote
systems okay remotely modular systems
actually is easier because it forces
some constraint
on on the development organization
itself okay it gives you sort of
discipline out of the box as opposed to
having to info try to enforce discipline
to get to better modularity another
argument that you will see is that micro
services are easier to scale and the
laws here is quite simple without going
to the great details of it you know
here's a here's a computing problem if
you have more if you can throw more
hardware at it you're going to get
better performance and one way to do
that is to assign more hardware two
distinct components in your application
there is some legitimacy to this
argument however the reality is you know
you can actually accomplish very
reasonable scalable T in a much easier
way without necessarily having to break
your system down into smaller subsystems
and the answer simply is horizontal
scalability you can throw more hardware
at an application simply by creating a
copy of it and load balancing it in
front of it simple HTTP proxy it's it's
as simple as an N it it will go an
incredibly long way before you actually
run into serious scalability problems
where that does that no longer works and
in fact when that when you approach that
okay your scalability problems will
start elsewhere not in the middle tier
but in the in the database okay that's
that's y will be your logical point into
thinking about modularizing okay it's
not going to be happening in the Middle
where tier anyway there is another sort
of chicken and egg sort of argument that
i don't find terribly convincing and
that's you know if you have
microservices this is you know it gives
you a new opportunity to do the quote
unquote right tool for the right job and
you can have microservices it developed
by various people this is all good and
good and theory and practice it doesn't
work there is a reason why most
enterprises tend to standardize their
true tool chain okay and no manager in
their right mind really wants to deal
with the situation where you know he has
a team of ten people that work in 10
different with 10 different tools it's
it's not a scalable situation and also
it's very
risk if you have any turnover suddenly
you're dealing with a skillset problem
so in reality I don't find this this
argument terribly convincing either now
the nicer thing about all of this is the
reason I can talk talk to these points
with the relative degree of comfort is
because I actually am quite familiar
with this and I have been quite familiar
with this concept for the better part of
10 years why is that because I am a
proponent of something called a DDD
bounded context okay and basically the
domain driven design folks have already
figured this problem out you know in
micro services are really nothing much
more than a technology implementation of
the architectural concept of bounded
context okay I won't talk too much about
that again the example that Steve will
be showing is actually an example rooted
in domain driven design okay so that's
how that system was in effect decoupled
in Korea and created as a micro service
okay so next thing we should talk about
is hype versus reality so to crystallize
a bit more our thinking around
microservices and what we should how we
should or should not be thinking about
this problem and again the reality is
most folks that have been you know in
computing very well now the downsides of
distributed computing nothing has
changed fundamentally in our industry to
alter those realities or those realities
still exist and they will exist for
micro services as well okay so let's
talk about those realities first and
foremost is that distributed systems are
significantly more complex operationally
okay it's harder to administer it's
harder to manage deployments is harder
to do monitoring because suddenly
instead of managing one server you're
managing 10 servers or a hundred servers
it doesn't take rocket scientist I don't
get scientist to figure out that that's
more complex similarly it has
development challenges you know
doing testing debugging Diagnostics
ensuring reliable to consistency these
are all difficulties okay in any kind of
distributors situation these these
problems will occur you will have to
deal with them you know think about just
testing and debugging for example let
alone let alone the rest of them which
are a bit more complicated to to come to
explain but you will if you think about
it you will understand why why I am
mentioning these testing okay so unit
testing fine no problem you stop out
your your remote components and you know
do local testing no problem well let's
talk about more serious resting in terms
of integration and system testing so
suddenly you have to make sure not just
the that the component that you are
functionality that you are testing on
that local machine is up and running you
have to make sure that every single
dependent machine okay it's also up and
running and is in a known reliable state
okay so significantly more complex than
simply testing a bit of local code
similarly debugging ok so if suddenly
you have a problem you know in your
application you don't know if you have
caused the problem the component that
you are invoking is causing the problem
or there's a component five layers down
the line that you don't even know about
that has caused you cause your error
okay and because you're dealing with
remote systems you have to do figure out
how to do remote debugging across these
machines to figure out what the actual
problem is in any kind of distributed
systems you will always have code
duplication Steve will speak to this
even in our very simplistic example you
will see code duplication occurring
there's no way of getting around this in
distributed systems if you especially if
you insist upon independent deployment
and the harder that the worse the
granularity is the harder the more the
code the more the problem of code
duplication occurs okay ma you know if
you define your mortal boundaries
extremely terribly you'll have a lot of
code duplication and I think we all can
recognize this the code duplication is
one of the biggest reasons for for bugs
okay so you make a change in one place
well if you
that simile if you need to make that
similar change to make your system
consistence in five different places
that likelihood of messing up is much
higher right okay and similarly all of
this requires higher skills and
automation requirements for development
and operations for organizations that
are already resource constrained this is
sort of a ludicrous proposition you have
to have a concrete value you know to
offset offset these call costs and
finally there's two other concepts that
I won't dig into an into too much detail
but basically all of this has it all of
these to all of these problems have a
name okay and there's theories behind it
so you should look up google things like
distributed big ball of mud or fallacies
of distributor campaign computing
whenever you have a distributed system
there are problems with consistency
performance go duplication and the like
in na n it's not a non-trivial system
distributed systems are about high-end
computing okay so you have to have a
good reason to do so what is the bottom
line the bottom line is that the reality
of the situation is that a vast majority
of systems actually do not need to look
at microservices at all they're
perfectly fine being monoliths in fact
there's a lot of benefits to having a
model at the model so called monolithic
system and you don't incur all of the
costs of distributed computing
furthermore the applications that
actually do need microservices in
reality do not need the micro services
in the form that the most ardent
proponents are going to argue for in
reality of what you actually can make
can get the most benefit out of is
hybrid systems in in particular two
forms of hybrids one is one that I've
already discussed with your butt and
that is simply subsystems okay equal
peers that constitute a larger system
okay these these these subsystems are
roughly equivalent in terms of their
size and complexity and the other hybrid
is what I would call the hub and spoke
model and generally this one occurs
as more of an artificial evolutionary
step so when you have a large
application that you've arrived at four
for some reason I first step to breaking
that down and getting to the point of of
creating subsystems is simply created
and breaking off small chunks okay and
having smaller services around largely a
monolith in reality few practical
systems can or need to achieve
microservices nirvana okay so what is
the actual sweet sweet spot why would
you want to do this is have very very
fine grain services who does it actually
make sense for really to two sets of
folks okay one is folks that actually
have a scalability problem that cannot
be addressed by horizontal scalability
number two folks for which things like
resources are a secondary priority okay
what is the primary priority for these
folks at the pro the primary priority
for these folks is agility okay they're
looking for time to market they can
throw resources at the problem to solve
them to get the problem moving faster
this is really where microservices
really make sense and where the sweet
spot is and the poster child actually
fits these definitions exactly correctly
this is a picture of a single system
okay from netflix right it makes sense
for them there they have a large enough
scalability problem they do not require
a high degree of reliability they have
abundant resources you know there they
have such a modern resources of the get
rid of mandatorily get rid of a certain
percentage of people and they have you
know a large flow of resumes coming in
every day if that's not your situation
you probably don't want this okay so
think about that long and hard before
you start exploring what these these
microservices a concepts okay all right
moving on to to java ee portion of this
if you come to the conclusion that
you're not going whole hog in so sort of
this with microservices java ee as is
most java implementations today
especially modular runs actually give
you quite a bit okay to get to get to
most certainly pragmatic microservices
so why is this the reason for this is
that historically speaking java ee has
always been geared towards distributed
systems from the get-go ok so we we have
always had pretty robust features geared
towards remote communication and we
continue to do so ok so we have a very
nice API for doing rest communication
named jax-rs we have a very nice
messaging API called Janus if you don't
want to do those we these days we have
WebSocket that you could also use as a
micro services communication mechanism
hopefully I've made it obvious that sub
systems do not equate to services
necessarily they are perhaps their own
applications that have their own device
well we have a nice UI framework called
jsf that is actually the most popular
one on the server side we have several
data binding serialization and
deserialization mechanisms and you need
those who do remote communication these
days we have very nice support for JSON
and we certainly have more very nice
support for XML that we've had for a
while through the jacks bapi and also we
have all of these nice back-end API is
that you need no matter what kind of
application that you're writing we have
dependency injection for CDI
transactions security so on with ej be
persistence for for JP a JTA for
transaction management jca for
connectivity and the like so all of
those problems actually fit perfectly in
micro services because in the end the
fundamental nature of applications that
you'll be double that you'll be
delivering here is really not terribly
different from what you've been doing in
the first place okay in fact you know if
if anything this makes it it makes these
some some parts of these api is even
more valuable particularly the part that
pertain to remote communication beyond
this
there are actually things that Java
runtimes commonly provide that are again
geared towards distributed systems okay
so these would be management and
monitoring okay again as we've talked
about management and monitoring is
already important in so-called
monolithic systems they become even more
important I with the distributed systems
and all of these things we have
best-of-breed features that were built
into for many many years almost every
single java runtime out there same thing
for high availability you need that in
this scenario as well if you're going to
scale up microservices again something
that has been built into java ee
platforms for many many years these are
this is battle-tested infrastructure
that has already worked through majority
of the problems that you need to solve
with with this is a complicated
complicated record set of requirements
and similar things can be said of
resource management in terms of pooling
resourceful linked data base connection
pooling same thing can be said of
running the your application in a secure
environment so on and so on and so on
okay all right so with that said I'm
going to give it over to Steve who will
be talking for a little while you know
the code that he will actually be
showing you as something you can take a
look at yourself okay it is available on
github in that is that that is a URL for
its relatively actually intuitive if you
think about it it's simply Steve millet
/ cargo tracker which is the name of the
application dash j1 Java 1 2015 okay so
you can you can take a look at that all
right with that I'm going to give it to
Steve but before I do that I'm a little
surprised that I've sin said whole bunch
of stuff that at least hope you should
disagree with so any questions on any
any of what I've said so far no all
right everyone agrees okay this is good
services the performance of dr. like
constantly utilizing these amazing as
you
very legitimate concern because again
we've seen this before you know we know
this is we know this to be an issue from
s away from all of the technologies that
have talked to you before that pertain
to distributed systems we've seen this
problem before this problem hasn't
suddenly gone away magically so yes this
problem also exists in micro services
yes the more fine-grained you get the
more of a performance penalty will pay
for sterilization be civilization and
network communication okay okay yes sir
in practice don't they have like the
same problem that rules engines would
have where your services could call
other services before you know you have
like a system that's not a turistic yep
there you go okay okay all right break
it so I'll let our litter Steve take it
away okay so my challenge for this for
this presentation was to look at a
situation that most people will be in
most of us don't have the luxury of
having a green field so i took an
application called cargo trackers his
sure hands of anyone know what cargo
tracker is okay so there's a few people
so target rack as a correctly forget
this wrong is a demonstration
application for both domaine dupage
domain driven design and java ee so what
I my challenge for this talk really was
to take that application and start
looking at turning that into micro
services okay this is the situation that
most of us will be in that we have
existing applications in Java EE or sour
or whatever our technology is and we
need to convert those or move them
slowly in in an evolutionary fashion
into new architectures new technologies
the new models so fundamentally in cargo
tracker it is what would be called a
monolith it's a java application that
does all the functionality it needs to
do it's not
occasion that is designed we'll see i'll
do a demonstration but it's designed to
basically mimic what someone would do in
a shipping company you you get packages
to ship you have to root them you have
to get them inspected as an events that
would occur in the lifetime of a
shipping container and that application
delivers that so architectural II and
the monolith is it has 33 user
interfaces okay so it has a public
interface where someone can go on and
take the tracking identifier check
whether their product is has an
administration interface where people go
in so power users can go in and see
enroute cargo and do things from the
shipping company and it has a mobile
interface which is used by people to who
are out in the field to sort of scan
cargo to say were to generate events to
say you know this has moved through this
port and those interfaces are supported
by a set of subsystems and those
subsystems many of which have a common
domain model in a single database so the
challenge with micro service is just
like the challenge was as a consultant
and slower is what granny large are your
service is where can you draw a split
from from a monolithic architecture into
what makes a good candidate service so
one of the candidates I looked at in
particular is something called a
pathfinder service okay this is a good
candidate service to split because what
path finder service does is it takes two
ports in the world and works out the
best route between them okay so does it
traveling salesman type problem that's a
fairly self-contained problem space it's
very algorithmic the rules may change
very rapidly and it's in fairly
decoupled from the rest of the
architecture of managing cargo I did
look at the other services for the
problem we have is that they share a
single domain model so we start
splitting them into microservices we're
going to have to duplicate all the
domain model code into each of the
services
I will have to do a lot of civilization
of the main model between different
microservices so there's no there's
probably not a huge benefit for too
quickly splitting those out into
microservices you'd have to react tech
to that great deal and there's probably
no huge in an architectural performance
or scalability benefit doing so because
you all hit the same database model so
what we're going to look at is really
what practically Israel is required to
split out the Pathfinder service and
what architecture that might look like
so the architecture I'm going to sort of
show is we split it into this this this
architecture essentially so we still
have like say I hope monolith as a new
term I've just learnt on the side and
we're going to take our Pathfinder
service and split it out into a very
small micro service and it's going to be
in a way that we can scale it out okay
we can add standard micro service type
way we can add multiple containers we
can we can scale and we'll play it
through an H a proxy and i'll if i have
time i will show you some that
configuration so i'll switch to to code
so this this is this is the cargo
tracker application very quickly it has
a public tracking interface you try you
put in your identifier it tells you the
events that have occurred to your
package very similar to anything you get
you know if you get from any delivery
company it also has an administration
interface where we can route cargo and
as a mobile event logo that would be
simulate someone in the field being able
to create very rapidly events for for
the system okay so how do we basically
approach this splitting out this this
code so the key bit really was to take
the path finder service what you say is
it is fault is solving a traveling
salesman type problem what is the
shortest route between two ports in the
world and we pulled that out into a
separate maven module ok so we
effectively have to maven modules the
original cargo truck and we pulled out a
second one this one here is just lists
your the two modules basically okay so
so pathfinder itself is just a standard
restful web service so it's a very good
candidate for splitting out okay so we
have I mean I won't go into this great
detail it's basically a stateless ejb it
has a has a path and it has a resource
on / shortest path and that will in this
case generate some dummy data but it
takes an origin there as a query
parameter and it takes a destination and
it returns back a json string which
represents the best route between two
different ports okay so it's quite a
very self-contained thing it doesn't
access a lot the domain model it doesn't
need to know about it what is the the
package it's particularly shipping in
this case so therefore be very good for
a separate team to work on they can
work on the algorithm the analysis very
self-contained away from the rest of the
cargo track of people who have developed
in the user interface and the main model
so this is the application that we
that's that's the portion of the
application we decide to split out as a
micro service so once you do that the
first problem you have is discovery of
services of an microservice is a
distributed system ever since the days
of korber one of the problems of
distributed systems is discovering where
your services live so we now have to the
one of the key changes we need to do now
is actually notify the service that's
going to call this service what URL it
needs to call it on so the actual client
of this service within the cargo tracker
application is another ejb called
external routing service this is one
that will invoke the pathfinder service
and the change that I needed to do to
that was to give it the URL okay of our
new restful web service so if I find the
client code ok so this external routing
service egb is basically jax-rs client
in its initializer we have it looks up
the URL and then it creates the jacks
are as client given that URL now
initially the first way to do that would
be to put that into the deployment
descriptor so we split it out into a
nagb jar environment entry ok we should
then get injected into this service
through this out resource ok that's fine
the problem is if you change what the
URL was you would need to rebuild the
code redeploy the whole application put
it through test through the continuous
delivery pipeline if you have one and
get that alley so what I then
did was to take that and externalize
that out into a separate J&amp;amp;G I entry
that koo modified with in glassfish so
architectural II we're going to run our
monolith in glassfish and the micro
service is in something called pyara
micro which we'll see in a second so
what we did is we took the wii
externalized the URL and put it into its
external jinda tree so that an
administrator if you'd move for your
micro services or your h a proxy
endpoint to be able to update the
application through an administration
console to actually tell you where the
new a new endpoint is okay so this is
the URL so an administrator could modify
that URL okay it's obviously my
localhost now we then look at deploying
the actual pathfinder web service so one
thing about java ee which people seem to
forget is that actually java ee is very
very lightweight so if we look at a
pathfinder service while file which is
here and we look at the properties of
that that while file on its own is only
9709 bites it's a very skinny war it's
very lightweight so it's perfect Micro
Micro service and to show now how more
complex we are we've on the architecture
we've shown that we needed to create a
proxy so now we've as well as we just
pulled out a micro service we have to
give it URL at URL as we're going to
extricate it out means we need to put it
to a load balancer so we have a load
balancer running on our machine and this
is basically a che proxy we can see that
we configured to backends 14 glassfish
and 14 pyara micro if you if you need to
see what that config looks like just
just come up at the end I can show you
the H a proxy configuration and we set H
a proxy up with maybe five
backend for our micro service so to show
availabilities if we work through the
application okay you can see at the
moment we have no micro servers back
ends up so the application itself if we
want to go in route cargo so here is it
a cargo identifier that needs to go
between Hong Kong and in Melbourne what
the pathfinder service does is is they
would give it that that route so if I
example at this point call that service
I'm going to get an error because my
micro services aren't available so this
is where you need to ensure that you
have good monitoring and availability
because obviously the lifetime the your
application can't work if your micro
services are unavailable so what the
administration interface what we're
going to do we're going to use something
called pyara micro which basically takes
it's been designed for running small
skinny bars it's basically a wraparound
glassfish 4.1 embedded but the key point
of this demonstration is it allows you
to run it a war file just on the command
line okay so we're going to run a Java
minus jar hire a MicroBot jar and we're
going to deploy Pathfinder war there's a
couple of extra parameters one is to
stop it clustering because it just takes
time in a demo and the other is to alter
by an HTTP well that does it means it
will if there's a something bound on
port 8080 it will just move on to port
8081 so it allows it to spawn multiple
ones on the fly as we as we start up so
if we run that you can see that boots
and deploys our Pathfinder microservice
and if we go back now into H a proxy you
can see that we have a up back end so we
can see we've got one of our
microservices up and we could run at one
or if our application got required more
scale we could just fire up a sec
and micro service so there are so there
are benefits the obviously the micro
services we can scale out this this part
portion of the application separately
from the cargo trucker that's running on
glassfish so you can see now we have two
microservices up so if I go back now to
cargo tracker if I now attempt to root
this cargo it'll basically call the
micro service and we'll get a set of
potential so important candidate
potential routes to route that piece of
cargo okay and that's what's happened
there is if we go not called that one
you can see that basically the
Pathfinder service was called by cargo
tracker to route between the two
destinations and if we go back to do it
again basically H a proxy will load
balance the two microservices go to h a
proxy it will say down here how many
invitations it's done so it's done one
on each basically it's just there okay
probably then switch back so that's a
very brief demo of how you can take an
application and split it out into micro
services so one but one the key thing
you need to do is work out what is the
service that you're going to split and
and that's always been the problem in
distributed systems what is the
granularity of the services how
decoupled are they how cohesive are they
as a single service and within the cargo
tracker for this demonstration the ideal
one is Pathfinder because it is very
cohesive service is perfect for a small
team it can be very self-contained it
doesn't depend on the domain model of
the rest of the cargo tracker
application yep
sorry the short answer is that you would
avoid doing it because the reality of
trying to decouple that service is that
you would have to essentially figure out
how to split your domain model okay and
in majority of cases what will won't
have wound up happening is that you copy
over the same parts of the domain model
okay unless you are very very like any
in fact in this case you wouldn't be
able to do it it's just so highly
decouple you're literally almost copy
over eighty percent of the domain model
over so it's really sort of a nod not
the thing to do practically speaking
in a Big Bang approach es mas early
incrementally perhaps on okay yes sir
these are in two separate bounded
context a Peugeot tracker is in one
bounded context and pathfinder is in
another boundary context is great
of course that would depend upon your
deployment architecture my personal
opinion would be that you would avoid
creating multiple deployments remember
the java application servers are
relatively efficient and relatively good
at multi hosting right they can they can
host more than one application so
frankly my personal opinion is to start
there and co-host applications and then
think about maybe putting them in a
separate physical separate physical
machine because in reality what you're
after is independent deployment I tell
you can you very well may achieve that
by simply creating a separate war file
but again it's it's a bit of religion
you know again the purists will tell you
oh that's you know horrible sin and
shame you shouldn't be doing that every
single service should be on its own
physical boundary within its own
physical boundary so again it just
really depends on you know what the
right decision for the individual
circumstances
do
typically through some kind of federated
security mechanism these days what's in
vogue is 0 auth okay any others right
moving on I think I'm not sure Steve
seven minutes okay you wanna I'm fine
you're done okay all right excellence
which it yes please yes sir uh-huh yes
yes I mean something the problems are
the same orchestration or choreography
but if you want to call it it's the same
problem that we've had since yeah
dolphin and distributed systems then if
you are in compensating transactions and
all the other horrible problems are get
swept under the carpet distributed
systems it's it had nothing changes in
my opinion from those those problems not
a going to microservices purists and
frankly me personally no you shouldn't
be doing that because again problem is
the costs do not justify the benefits in
most cases you don't actually need if
you look at actual ESB usage in my
persona in my personal experience most
people they have an esv system and they
don't you they hardly use perhaps five
percent of the features and that's a
very good indication that it's a piece
of infrastructure that you do not
actually need ok I see when you can go
and look you can you can use
choreography and user been driven
architecture so principles I mean I like
event-driven architecture obviously
scales the problem we have with a vent
driven architecture my opinion is that
human beings like a story and you know
like a narrative an event-driven
architecture doesn't give you as an
individual as a human and narrative so
it's very difficult to work out actually
in a reproduction ETA what the heck is
going on so but it will d couple and
removes the need for an ESB if you use
sort of pubs or band also event-driven
tight technologies but it's if we come
complex to debug in the
okay moving on so I'm actually going to
skip over this slide because i think i
have a bit more important things to talk
and talk about and actually I would like
to like to like to have some really open
Q&amp;amp;A as well so what is this slide deck
for this slide deck is sort of the
buzzword buzzed word and
commercialization compliance slide if
you want so these are some of the folks
that are really you'll mention these
you'll see these buzzwords most often in
the context of people that are trying to
push microservices as a
commercialization vehicle okay the truth
of the matter is each of these it's not
true that none of these things have any
merit they do have married but you have
to pick and choose what is it that you
actually need and whether you actually
need them again if I had about 10 more
minutes I would go through these and
explain to you what I believe the sweet
spot of each of these things are but let
me let let it suffice that in my view
you don't actually need any of these to
get started with with practical
down-to-earth microservices and most
blue-collar IT organizations however
these do have benefits but you have to
evaluate them carefully as to which
which of these actually makes sense and
neither none of these things are
actually prerequisites to being able to
do micro services in fact in some cases
they are hindrances because you're
you're suddenly dealing with tooling
concerns whether it whereas you should
really be focused on architectural and
implementation concerns and what is
right for your own business as opposed
to dealing with these dealing with
playing whipper play around with tools
for tool sec okay okay so the summary
again the reason for this is we've
covered quite a few ground so it's it's
a worthwhile to just take stock of
exactly what what we've traveled through
and how we got here so again
microservices are the latest incarnation
of ideas with a pretty long history the
latest one
so and in fact the differences between
soya and micro services are smaller than
the fundamental things that they have in
common with each other it's a valuable
architectural style there is there is a
true value proposition for it however
like all things in architecture is not
necessarily for every one it's not
necessarily for every situation and it
is not necessarily all at once okay java
ee is a very capable pragmatic my
capable platform for certainly more
coarse grained pragmatic microservices
that would be more likely to occur in
sort of blue-collar IT organizations
however the reality is that even in the
micro savin in the Java ecosystem
there's things like pyara micro and
while a JBoss wildfly and i believe the
chivas while a lead is actually in this
room and surprised he has and heckled me
on my talk yet but but there are other
things like snoop and and so on you know
that that will help you if you want to
go whole hog with micro services and you
really are you think you are the next
next netflix and you really need this
well java the java ecosystem has been
stepping up and will continue to step up
to even address those use cases all
right so let me finish up with a few
resources that i think will be valuable
first of all actually let me show you
how you can get to this slide deck and
i'm not on the web may I switch over to
a viable the way are you on the web
what is it it's a simply mice lecture
akan slideshare.net / Reza underscore
Rama the other day
okay so that's my SlideShare account you
will see this deck over there sense
sense Steve's a code and Steve Scott
hopefully you've noted the URL for that
also beyond this these are the resources
that really you should take a look at
the first one is rather interesting it's
a it's an article by Martin Fowler so
Martin Fowler interest to my own to my
disappointment frankly started out by
being quite preserve go quite pro what
microservices you know sort of the
typical microservices rah rah type of
tonality in the initial set of articles
that came out of martin fowler and this
is frankly to my dismay because i wasn't
expecting i was expecting better than
this from from martin but he didn't
disappoint completely it seems like he
wrote some letter R tickles that
corrects that tone and I think this one
is the best one so far essentially it
reiterates exactly what I said you know
what whoops what we've said in this talk
and it's it's a worthy read and I almost
would recommend starting with this one
and then backtracking back to sort of
the more rah-rah microservices type
articles the one thing that I'm still
disappointed with Martin Fowler is his
lack of acknowledgement that
microservices and so are actually quite
closely related luckily there's another
gentleman out there that I think has
stated exactly this and in fact in this
article is a critique of Martin Fowler I
think this is also a worthy read and it
will give you some perspective on really
why why these things are so similar so
anything that you've already know about
so uh he applies equally well in this
world as well the rest of these are
simply links for learning further about
java ee the java official tutorial the
first cup application for getting
started with java ee glassfish hands-on
lab for java ee 7 the carbon tracker
application which is what what Steve
forked on on github and I always like to
point out the aquarium blog it's a it's
a blog that I in a colleague of mine and
I try to
maintain it's a good way of staying up
to date with the Java ecosystem
generally we certainly do talk about
things like micro services and the
various tools that can help you if you
if you even went in the whole hog
microservices approach it can help you
there as well okay so we have just about
a minute and that's a I think a good
enough time to have open Q&amp;amp;A if you have
any outstanding questions that you
didn't ask it yes it will led to that
because now you have to document what
each of these ati's do for certainly for
your external consumers these they guys
do not simply document themselves in
fact it gets worse in rest because you
don't even have the wisdom facility that
you do and soap you know literally you
really have to write you don't have to
read somebody's API documentation to
understand how do you use their service
yes so it makes X Mason makes that
problem worse as well you know best
practices are now no different than
before you know you have to do what you
need to do the the problem is going to
get worse and worse the more
fine-grained the services are if you
have a coarse-grained set of services
you know you do the normal thing you
know your document the stuff you publish
it out make yourself make yourself
available for questions for from for
your users and so on okay any others yes
sir
yes you soonly good you yes sir
so the answer is there's no good answer
to that the only distributed system so
far that has been able to solve that
problem is Karva because they had a
concept of distributed transactions now
the problem is what is the microservices
answer to this the microservices answer
to this is you should make sure to try
to avoid those situations okay number
one which is not necessarily that simple
the second answer which is even more
horrid is use compensating compensating
transactions which is also not really
the right answer you know there's no
compensating transaction for not getting
paid for your product right so it's not
really terribly good answer okay yes sir
correct but even then you wouldn't be
able to do that in this world yeah hence
the only way you would be able to
accomplish that you know it is if you
had a nicely designed aggregate but if
you have aggregates that are if you have
domain your domain model is segmented
across two different distributed systems
well I'm just not going to work anymore
right okay yes sir oh yes ma'am
did you gather that question uh no so to
take down a piece of the application so
as a separate deployment other words so
you can add a new version II I mean it
helps that situation yes but you still
have to manage the fact that that
service is unavailable so there's client
of that service would need to be able to
handle the unavailability of it while
you do the deployment unless you do some
sort of rolling update but that's you
can do that with a monolithic
applications so okay so we are
officially out of actually five minutes
overdue so thank you very much we
appreciated</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>