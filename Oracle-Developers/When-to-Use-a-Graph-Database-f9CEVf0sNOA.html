<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>When to Use a Graph Database | Coder Coacher - Coaching Coders</title><meta content="When to Use a Graph Database - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>When to Use a Graph Database</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/f9CEVf0sNOA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I am to be Aslan docker I am a
software developer at neo technology the
company that builds and delivers near 4j
the graph database and I could have
probably chosen another title we get to
choose our own titles pretty much my
title used to be hacker until I got into
trouble in US Customs with that title
but I'm still keeping it real with with
the software developer title because I
am developing software although I could
probably call myself an architect if I
wanted to have a fancy title it's just
that it's not so pretentious
I'm here to talk about when to use a
graph database so sort of walk you guys
through a number of use cases for graph
databases that well mainly that we've
identified that we think is a good idea
to use a graph database in but also that
our customers seem to have understood
that that these are actually good use is
because we have a few people who
actually do these things and I'll
highlight that throughout the course of
this talk and yeah those are some
details if you want to contact me let's
get started so I want to start with sort
of making sure that we got a levelled
feel here by talking about okay what is
a graph database just some some simple
background so it's a database that the
stores data as a graph which consists of
nodes so those are the main entities of
of a graph it's stored in a graph
database I wonder if I look at that
notes and then we have optionally in our
model we can have labels on on the nodes
and labels are pretty sure I had
percentage notes for this slide good
thing I remember that I wanted what I
wanted to say
and these are a classification feature
so they are something it's kind of like
a type that you can use for saying what
what sort of entity this R is node
represents and we also use them in in
the database for for allowing you to
define indexes for looking up these
nodes quickly and then the thing that
makes it a graph and not just a document
database is the relationships in between
nodes and these are first-class entities
as well and they always relate to notes
so you can never have a relationship
that doesn't relate anything or that
relates just one node although you could
relate a one node with itself and that
node would then countess to for from the
point of view of the relationship and
relationships have types and these are a
navigational feature so you can when you
traverse the graph to find things you
traverse by by different types so if I'm
at at a person node and I want to find
things that that person owns I Traverse
owns relationships and if I want to find
other people that that person knows I've
traversed in those relationships and
finally in this model we have properties
and we have properties on both nodes and
relationships and properties are just
key value pairs and you can have an
arbitrary amount of these and they can
be indexed based on an index that that
is defined for a particular label if you
have a particular combination of a label
and property key on a certain node and
you define that to be indexed
it'll be indexed by the graph database
engine so that's the model and I've sort
of represented the model as a graph here
as well
I could have had a lot more detail but I
thought this was enough for a slide
already
the great thing about this model my
favorite aspects of this model is how
incredibly friendly it is - one of my
favorite activities and here's why I
could have called myself an architect I
love drawing on whiteboards in fact my
teammates one or my my teammates on the
development team want to have me in
their small sub teams because of my
whiteboarding skills because I do it a
lot and this is what's what excites me
so much and always has about graph
databases is that they are so incredibly
friendly for for whiteboards when I have
a model in my head of the data I wanna
represent I draw it in some butchered
form of UML or we are it's not even
close to the formal specification but it
serves the purpose of demonstrating the
idea and then when I've done that I
don't do translation of it I'm done I
just implement it
I represent these users as notes and
then I have relationships to these blogs
that they're members up and I've got
other relationships from the entries
that are written on those blog posts and
the blog to the blogs that they're
published in and the users that have
authored them and then I'll add comments
and I'll have relationships from the
comments to the users then post them and
to the posts that they are comments to
and it all just sort of it's the same
model in the implementation of the
domain as I drew on the whiteboard and
that gets me super excited about graph
databases
okay so we've leveled the field on what
a graph database is how do I query it
that's the next question I use this
picture in too many presentations by now
so I'm not going to read it you can read
it yourselves but the big question is
okay we have a database now how do I
query it
we've defined our own little Kray
language that we think is quite useful
purposely kept quite close to sequel
Chris sequel is really good at a few
things that it does really well and it's
familiar to many developers so that's
why we modeled it so closely to sequel
but in the sort of in the important in a
few very important areas it differs from
sequel mainly in that you declare
patterns that are to be matched and
that's the match keyword there so match
the match clause of a cipher query is
where you declare the pattern to match
in the graph and you do that through
ASCII art which is cute and then and
that's instead of that's what you have
in a cipher query instead of a join in a
sequel query and then in the main author
of this the guy who came up with cipher
originally is a big sequel guy but he
always always always hated that you
wrote select and the result at the
beginning so he put it at the end and
color pattern instead that's the other
big difference otherwise it's pretty
much like C so this cipher query
language then it's a declarative
language just like sequel where you
describe what data you want to get out
of the database rather than describing
how to get it which was a big step
forward from when I started talking
about in the everyday when all we had
was a programmatic API in Java where you
would very much describe how to get your
data and of course being the old and
grumpy guy which is my title internally
at the company
when we first declared the career
language I was like wow there's this new
 I don't
like it but I've come to grown to love
it
it really is for more assistance then
than the old clunky API that we have and
is really quite useful for just typing
something up and you can actually use
the database now as a standalone thing
and it's so nice I love it
so it's declarative you describe what
you want and it does pattern matching
over the graph see what you declare is
this pattern and then it finds
occurrences of that pattern in the graph
and we use ASCII art for declaring those
patterns and why is ASCII art useful
again because of the wiper friendliness
it comes back into the query language so
if I want let's do an example because
examples are super useful for getting
points across so if I want to find the
actors who have acted together at Lucy
Liu in any movie I will start with what
I know the actor Lucy now I find the
movies that she sucked it in and I'll
find the the other actors that I've
acted in that movie so you can sort of
see how we if we map this down from from
actor to movie you can kind of like
represent this patterning graph alright
that pattern graph on if you're on that
screen as an ask your art expression of
of what that pattern looks like so let's
compare that to to what it would look
like in sequel so we start with what we
know the actor Lucy in both cases we and
in sorry for we say match Lucy she's an
actor and this is wrong should I edit
this it's this person there it should
said I say actor copy/paste error sorry
just pretend that it says from actor
Lucy and the sequel part in the bottom
and then we're same thing in cipher as
it isn't sequel we say that well Lucy
has the name Lucy Liu
and then we define this pattern that
Lucy acts in a movie which in sequel
would be mmm a join on background to the
actor table where the person ID is the
same for the other actor as it is for
Lucy okay right it kind of works then we
want to find the other actors who have
acted in the same movie so the co actors
of Lucy and in cypher we just add this
this other part of the more ASCII art
patterns but in Psych sequel of course
it'll be more of these joints and also
we have to see yeah it's two more joints
because we have to join on the movie
this just gets complicated
and it's hard to not only does it get
complicated in that you have to think
really hard about what it is you want to
get but also when you look at this it's
not immediately obvious what it is you
you're trying to get so this is where
graph database is really shine because
in the query on the top it's just I see
in the sort of ASCII art pattern they're
exactly what it is I'm looking for and
then of course we have the final return
Clause or the Select
in sequel and that's just the same in
both cases
where I tell the Korean Jin what it is I
actually want to return from this so in
this case I want to return the distinct
names of the actors at the co actors
right so we've leveled the field with
what are they graph databases and how
queries look like for the graph database
near for Jane and based on that we
should be able to we should be equipped
now to go through a few examples
so these are the five examples out of
longer lists that I chose for this
presentation obviously social because
it's the first thing that comes to
people's mind I did contemplate that
maybe maybe I shouldn't talk about
social because it's so obvious but then
again let me start from there because
because it'll it'll sort of tie into
this leveling the field kind of thing
that I got going and then identity
access management recommendations parcel
delivery oh that's exciting
and network management so what a lot of
customers are doing is or customers to
us there are service providers to to
most people is that they have some
service that does something and they
want to get on the big trend of of being
social because everything is being is
becoming social these days or mobile or
both so they want to add a social
element to their to their service and
neo4j makes this really easy or a graph
database in general makes this really
easy consult because of course you can
keep your own system the same way as it
is and just I had the social aspect to
it in the same way you do in the and as
you do that in your storage solution you
just add graph database so it's purely
additive and then of course as your
system evolves you might find that all
some things really should be moving more
things meat really should be moving over
to the graph system but that can happen
gradually so really we see a lot of
customers doing this they take their
existing service anyone add social to it
so they take their existing system they
add neo4j to it and a bit of UI code and
maybe some other modeling code and they
got a and they're able to deliver a
system with social enhancements fairly
quickly so
Pikul typical social network typically
what your model is the connections
between people you model people and
their connections so for example
Jeremy's friends here's Jeremy and his
friends it's super simple and intuitive
in the picture and you draw that to
ASCII art and you got a query that gives
you the names of Jeremy's friends pretty
easy it could have done that way to join
now this is where it gets really
interesting is and now I want the
friends of friends of Jeremy I just add
that to my to my query and it's a single
line because it's a single thing I'm
adding I'm going from the friend to the
friend of friend in sequel that would be
horrible and I return different the
names of those friends of friends so we
get a bigger graph here if I'm getting
this data but let's say that what I'm
really interested in is some of these
people are my friends already what about
the things that the things they're
people come on what about the people
that are friends of my friends but are
not my friends already well that's again
just adding that where I don't know
these friend of when Jeremy doesn't know
these people already so I find the
friends of friends and then I find the I
look I filter out those that are not my
that are not my friends already this
gives me Frank and Amanda I've got no
idea who these people are but yera me
might want to get to know them and I can
go further I can find friends of friends
of friends and I wouldn't want to do
that in sequel at all I could go even
further of course but you get the idea
by now but the
it gets even more interesting when I
start adding other types of
relationships now why does it say
cooking at the bottom maybe so these
people are not cooking one another but
they are friends but what gets
interesting is that is when you start
adding I think other types of
relationships too to this graph for
example you might have an employee
relationship if it's a professional
network or you might have our here comes
you might have might monitor things that
people are interested in their hobbies
and maybe groups that they're part of so
we got a couple of customers that do
this this is just a small sample of
those I particularly like the one on the
bottom right they used to have an
awesome name that they got sued for they
used to be called bang with friends
which is essentially an application so
they replicate all of the connections
that you have in your Facebook Graph so
they have a lot of data in there near
frige a storage and then they allow you
to browse through your friends and
anonymously anonymously say I could
imagine getting down with that person
and then if they click I want to get
down with that person back to you only
then do you get a connection so it's
quite an interesting idea
and yeah that's that's one thing you can
do with me every day
we're powering love here what's also
interesting and that's another aspect of
social is the company in the middle here
that's way put them in the middle and
also because their logo logo was small
enough to fit there is 53 they make an
application called a paper for the iPad
which is a really popular drawing
application and they've recently
announced the social aspect of that and
recently rolled that out that is really
quite awesome where you can share you
share your your works of art with the
with the world on their website and this
service is called mixed and then other
people can take your works of art and do
remixes of them so evolve your art and
you get a whole collection of original
art and remixes and it's really quite
exciting I encourage you to look at
their website 53 calm and in
alphabetical letters so if I have 53 /
mix I think or mixed up 53 become one of
those or just 53 I come and click your
way through it
they got an exciting video they're
showing you the kind of remixes that the
people do so they do something like this
I don't exactly what they do because I
just built a database engine they build
a model let the dense store where you
have users who create works of art and
you can like other people's works of art
and you can follow people to find out
what what art they've created and then
of course this interesting thing of
remixes of pictures shake out thank you
it's cool okay so now that we have when
we have if we do social data is really
close we already have sort of user
information
so using that data that we have about
users it's not very far-fetched to start
think about doing identity management
and access management in the graph and
in fact access management was the very
reason we created this database in the
in the first place because we had this
system that was actually we were serving
up pictures as well from photographers
we had a platform where where
advertising agencies could buy pictures
from photographers and we had these
really complex rules about who could buy
pictures from whom and who could view
certain catalogues and whatnot and it
was crazy complicated and our forget
which sequel database we were using but
it was crumbling so we came up with this
idea of if we model this sort of crazy
axes rules as a graph it gets a whole
lot nicer to work with and originally we
did that as a just as an access layer on
top of the sequel database that we were
using like it's the model that we did on
top and it made our application a whole
lot nicer to work with but it was still
slow so one of our engineers built out a
native storage engine for this graph
graph API that we defined and then not
only did it perform super well but we
also thought this is probably more
generally applicable let's see if we can
start a company around that so we did
and these are some other companies that
have the very same issues so good that
we did these people and a few more that
are on our website and a few more that
are not on our website because they
don't want to be these people use near
4j for identity and access management so
it's kind of like a model like this
where you have users and we had in our
case we had pictures and pictures were
posted in catalogs and usable member of
groups
and group could read or write or
administrate a catalogue and we're even
Minister a group like tell who was a
member or not
and then in order to find out which
pictures I'm allowed to actually view in
this in all these catalogs I would match
from my from the node that represents my
user to the groups that I'm a member of
to the catalogs that I'm allowed to read
in and then find the pictures that are
posted in that catalogue and I'm
probably not interested in the pictures
that I've posted myself so I'll filter
those out another thing after we've done
socials we've we've augment we had our
application we augmented it with social
we done identity and access management
using the graph as well and now we might
like something we'd like to get
something else we'd like to get
recommendations see what I did there you
might also like recommendations yes bad
joke and it sort of got three giggles
that one got one as well so there are a
few different things that they can do
recommendations on and that people do do
recommendations on you can do of course
retail recommendation which is the space
that really started doing with this
first with I think Amazon being a
recommending recommendation Pioneer and
they're of course a big retail company
but also tying back to the social you
can you have dating sites and and stuff
like that do that's also a type of
recommendation and that they do
matchmaking
that's recommendation there's also a
career matchmaking like where who should
I hire
where should I work hard questions and a
recommendation logarithm Mike with that
there's also of course other popular
companies don't know if their customers
are not that do movie recommendations
like these like these large streaming
sites have lists of movies that they
think you should watch probably not a
customer kiss I never get good
recommendations or music what music
should listen to there I do get good
recommendations I love my Spotify don't
know if they're customary mats they're
not publicly so if they are but these
people are customers than they do the
recommendation so the entire is that
your right hand side are matchmaking
companies for dating we got I think a
year ago or something like that worth
maybe two years ago now
all of the sudden we had this huge
uptick from dating sites
it pretty much neo4j became almost the
sink-or-swim kind of technology for for
dating which I think was super exciting
and then we got some retail and career
and music recommendation services as
well using the averaging so what this
recommendation looked like let's say we
want to do some simple movie
recommendation based on what other
people have rated so I want to find
things so I've seen movies and I rated
the few movies so that can be used to
compute what kind of people I'm similar
to and based on what they have seen and
rated that I haven't rated we can find
out what movies I might like
so that is something that's one
algorithm you can use for that kind
recommendation is called cosine
similarity and the formula is at the top
there
it essentially computes the the cosine
so it treats the recommendations as two
vectors so the the movies that overlap
between two users it treats that as a
vector and then it computes the
multi-dimensional right vector and then
it computes the cosine of the angle
between those vectors and cosine is
interesting because a larger value means
that the angles are closer to one
another whereas if they're orthogonal I
think you get a stack when you get a
negative value whereas do you just get 0
0 you get on a final yeah so that's the
formula for computing the cosine of the
angle between two vectors of an
arbitrary but equal dimension and
translating that to two cipher it
becomes well it's sort of a kind of
resembles what the formula looks like
sure it's it's a bit hairier than the
than this simple pattern that we have on
top there where we just find two people
and the movies that they prated but you
can sort of but once you look at that
you'll see that it actually is that
formula we have on top they're not very
interesting so I won't go into the
detail of that and then what we do here
is we create a relationship between each
pairs of people where we say where we
store the this cosine similarity value
and what merge does is it creates a
relationship between two two notes
unless one already exists in which case
it updates that
so - based on these computed
similarities we can find the people that
are similar - to someone so if I find I
want to find that people that are
similar to me I follow these similarity
relationships and then I order them by
similarity - by the similarity value and
I only take say the top five and that
gives me the five people in this graph
of people who've recommended movies that
are the most similar to me and then I
can build on that query and create
another query there where I find movies
that they have seen and rated that I
haven't rated so again we find a person
a representing the person we're looking
for me or you a success in this query
and we find people that are similar to
that person and movies that I have rated
where I have not rated that movie and
then we again order these people by
similarity and then as a secondary
sorting we sort the know that's later we
get the I should be a sorting on we
should secondarily sort by by movie
rating that's missing from here or maybe
it's computed I don't remember anyhow
that's one way of computing
recommendations for movies that isn't
actually a very good idea because
imagine you have a really large number
of users here I'll have a critic number
of similarity relationships and that's a
lot of data and currently unfortunately
near Fiji is not very good at handling
if you have a very tightly connected
graph like this where pretty much every
node is connected to every other node
that is not burning of yay shines
working through this example I came up
with a great idea for how I would want
to solve that tough so so maybe someday
in the future this will actually be a
good idea to do now what near 4j is
better at is when you have these or
currently at least it might get better
at that is when you have when all your
data is local so say I want to recommend
recipes for example I have a model where
I have people who have a preference for
certain ingredients they can either love
them or hate them or they could be
allergic to them which is even worse
than hating them and then we have in
Greece ingredients are part of recipes
so I have recipes that contain certain
ingredients and I can make
recommendations on what recipes to cook
so if I if I have someone michael here
who has a few allergies and some things
he doesn't like and he's got tomatoes
and rice and his cupboard what kind of
recipes can he cook from that so ice one
way of doing that and this is there's a
longer article that describes this on on
our website is I will find the product
that he is he doesn't like or is
allergic to in order to use them as to
filter out bad recipes that I don't I
don't want to cook for Michael and then
I I find these recipes so I match
recipes that any recipes that were I
contain these food items that I can't
use so I go from a collection of bad
ingredients to a collection of a bad
recipes
and then I can use that to find recipes
that contain tomatoes and rice so I
match a recipe contains ingredients a
recipe has ingredient product you the
arrow is from right to left so you can
read that from right to left a recipe
has ingredient tomato and also the
recipe has an ingredient that is rice
and then I filter out that these recipe
should not be one of the bad ones and
then I have the ingredients that I can
the ingredients and the now I have the
recipes that I could cook for Michael
with tomatoes and rice and I create a
list of the ingredients for each recipe
and return that along with the name of
recipe and the instructions for her to
make them okay so we've built a social
system that has access management and
recommendations are recommending things
for my users I want to send it to them
now so that's another thing that we've
seen people do we're very successfully
with neo4j is logistics and parcel
delivery and the the basic things that
make up a logistic system or a parcel
delivery system is sort of route
planning of how to get some item from
point A to point B preferably users I
utilizing transportation that is already
headed in that direction so I don't have
to if I am sending packages I want to
send as many packages on the same truck
as I can but what we've also seen people
be able to do with me every day that I
haven't really been able to do with
previous systems is to do real-time
routing and enable same-day delivery or
even delivery within
an hour to 90 minutes and there are a
few customers who do this so I these are
all super cool
there's Belgian rail the national rail
services in Belgium and in New Zealand
those two both use an everyday for route
planning Accenture is a consulting
company but they are building logistics
systems for a few of our customers that
I couldn't put up here but it could put
Accenture up here and then eBay now and
shuttle are really the same company
shuttle shuttle is a British company
that came out of nowhere almost and were
able to do very quick deliveries usually
within an hour from one order you order
something from a shop online and you
have it delivered to you within an hour
it's super impressive so impressive that
eBay paid a lot of money for them they
still view that service in London and
they have also started under that old
name shuttle to do consumer to consumer
delivery so if I have things and want to
send them to you I can use shuttle dot
it to to find a courier that will do
that delivery for me and this is quote
by those guys that I absolutely love so
they started out building this system in
the air for Jay and no on my sequel and
then they tried in the everyday and he
was literally thousand times faster for
them with much less code to to maintain
I am and this was so we're a small
company and we can't really keep up with
everything all the time so this as a
customer we had not had time they'd
contacted us but we'd
time to get to them yet so I actually
met one of the founders of shuttle at a
bar in London and he told me hey I
really want to give you guys some money
because we use your product that's the
great thing about being open source
product is that people can actually use
your product and try it out and
prototype things without having to
contact our sales department first but
they wanted the support and so the
enterprise features that we offered but
our sales reps had not had time to to
contact them yet and the thing that he
said to me that that was that got me
really interested was that the core of
our business is implemented in just
seven lines of cypher I thought that was
I was such a powerful statement so of
course I had our sales guys contact them
immediately and they've just kept on
giving us these great quotes like this
one which continues with that today near
PJ provides them with functionality that
they couldn't even do with their
previous sequel solution and they rely
in this court that where they say they
realized that they needed to move away
from this sequel based system when the
slowest queries took longer time than
their fastest deliveries which was 15
minutes which is pretty good delivery
time and Whitney o4j they were able to
get those queries down to thousands of
times faster and were able to to perform
the queries faster than they could
deliver which is a good thing you want
to do that because otherwise you'll
spend a lot of time computing and then
very little time delivering it's
nonsensical so fortunately I don't have
a great example of routing and
deliveries but I came up with this
example it's sort of in the area of me
traveling here so I started in malmö in
Sweden where I live and I I wanted to
get to to San Francisco so what are the
what's the fastest way to get here there
are no direct flights from Alma because
that Airport is not very good but I
could take a fly from there to Amsterdam
or to London and London is a great
Airport I love front flying through
London um not so much for the airport
maybe a lot of people complain about
Heathrow but I like the airlines that
fly through there or I could take the
train over to Copenhagen and fly from
there either through London or Toronto
or directly to San Francisco and that
was what turned out to be the fastest
flight so if what I base my computation
on is sort of travel time then that's
the route that I would come up with and
if I were to base it on price I might
come up with a different route because
the airlines that fly through Amsterdam
are usually budget airlines so they are
especially KLM they're very cheap not in
a bad way although I don't like them but
that's personal yeah so that would be
the cheapest flight all right so we have
built a social system that does access
management and I'm starting to forget
what all these things we did worse we
did recommendations and then we did
delivery of our merchandise we have all
this in a data center somewhere and we
want to make sure that that we were safe
against the disaster if something were
to happen with that data center that's
another thing that you can use I graph
data these four
so modeling the dependencies between
services and components and data centers
and switches and routers in your network
and use that to diagnose where the
problem is if if a problem arises or to
do what if analysis so the problem
diagnosis is usually from the ballot
from the top down you have a customer
reporting an issue and you want to find
out okay what are the possible places
that if if this is the issue what are
the possible places that that the
underlying fault could be yet and
quickly get to a small subset of things
that you can look for or what-if
analysis which is bottoms up what
happens if this service goes down or if
this data center goes down if this
router goes down can I still maintain my
SLA s at the top level and you start to
find out what the weak spots are to that
you need to improve so again let's slide
with the few customers that do these
kinds of things and I think maybe a few
of them are familiar these are just a
few of the companies that do a network
management we also have why cannot put
any other of the telcos up here because
we got telcos to do this as well but you
will have a model something like this
where we have all of these relationships
they're not the types are not easy to
read but they all say depend on so we
got servers and we've got virtual
virtualization environments on these
servers
we've got services running in those
virtual environments we got routers and
sans
and a web servers running
mm-hmm database services servers so I
can use this the query for for example
one of the services that my my public
websites depend on so I'll find the
websites and all of the transitivity to
that star and the and the parent means
one or more levels of of this
relationship type so find all the
services that the way a website to find
depends on that's my pattern and these
websites I'm looking for our internet
connected systems this is just the way
that this model looks like I'm not super
happy with this model and it's not the
way I would design it but it's the way
it was the sign in this example anyhow
and then I returned those the host name
of those websites and the the list of
dependencies for each of those websites
I get a pleasant little less like this I
like this example because it's quite
short and simple it really expresses
what what those dependencies are and I
would never want to do that in sequel
that kind of arbitrary depth join is a
complete nightmare to do and in and this
is really is the real strong suit of of
a graph database is that you can go
arbitrarily deep with high performance
and it's really easy to express that
kind of that kind of query and that
really is on that note but really is
most of what I had if you want to find
out more I really recommend our websites
in particular
in relation to what we talked about here
the list of customers because if you go
to that list of customers you'll find a
few links to presentations that they've
done where they talk about what they've
done with me every day or even some case
studies that we've published together
with them and then you can find if you
wanna if you're really interested in in
a project you can find which I of course
you are
you can find online training meetups
that you can go to and other events that
we're hosting there's one here in San
Francisco on I think on Wednesday if
you're in a hurry to to get to any of
your day meet up and of course you can
download neo4j
and and try it yourself that really is
that's my favorite way of learning just
trying something out then the second
website is where you can find all of
those examples that I've used in this
presentation which is what we call graph
gist's because it's based on the
underlying storage system for that it is
super easy you write up
you see it's community contributions a
lot of it where you use github gist's to
to write a document containing queries
that we then pull in execute and
generate visualizations and queryable
graphs for you in a very nice nice way
so that is alive and well and we got a
lot of people contributing material of
that and then of course we got the
further case studies on our corporate
website near technology comm and we've
got a conference about graphs and graph
databases on October 22nd here in San
Francisco
it's called graph connect um if you want
to come go there I'm pretty sure I can
find out a discount code for you
I didn't have one at home when I made
this presentation material but I'm
pretty sure I can get one and there's
also more presentations here at JavaOne
my colleague Stefan plant akov will do a
presentation tomorrow at 8 p.m. about
our query engine where he will talk
about I don't know what makes what
things we do well and how it does those
things and all kind of exciting things
I'm hoping that I'm gonna go I'm hoping
that I'll find out some neat tricks for
how to how to make sure that my queries
run well so yeah if you were asleep
during the entire presentation here's
the very short summary should always use
graph database huh of course what else
would I say questions yes
yeah
like
yeah so the question is does new
everyday have any built-in features for
doing each other
shortest path searches and yes we do
down I should have had an example of
that is really easy you define a path
and you just say
sure just path around it and that's it
pretty much yes
how old is what how well does it
replicate so we've got a replication
master-slave replication system for
neo4j and that is what most if not all
of the customers i've mentioned use it
gives you so being master slave it gives
you read scalability and fault-tolerance
it doesn't give you right scalability so
all rights are still coordinated through
the master but yeah I'd say it works
really well of course it's I dunno
whether we had support cases with it
that's the main thing we have support
tickets for but not lately so it's
pretty stable right now
yes
Challenge is what this yeah yeah so
what the challenge is in administrating
in graph databases or neo4j in
particular Chris because that's the
product that I know it is of course not
as mature as many of the sequel
databases that you've used that are 20
30 40 years old
we're only we've only been working on
this system for 10 years and for most of
that time it's been an internal system
that's at another company where we just
didn't really need it to be
user-friendly for anyone but ourselves
so it's something we've started working
on recently and by recently I mean maybe
last five years it's improving there are
the main tools you have at your disposal
are log files for for monitoring and we
also integrate with with JMX monitoring
although not really the not really that
well-suited for monitoring yet the JMX
part but it does work for for
introspection like querying what the
current load is in those kind of things
and then configuration files where you
can tune some of the configuration
parameters of of the database and that's
pretty much it in terms of oh yeah and
backups we've got online backups
utilities I think that's the
administrational aspects of neeraj as it
stands now does that answer your
question or am I just babbling
okay
any more questions yes please for
spatial functions yes we do
so does me everyday you have support for
spatial functions and my answer is yes
we do
it is currently so we had we've run a
spatial project for a while but we
haven't had it very well staffed until
we're starting to ramp that up now we've
done some hiring recently and we're
ramping that up but we do have support
for spatial queries
although the integration is a bit crude
because it the spatial system predates
the query language so the integration is
clunky and that is what we're working on
improving right now so that you will
have nice nice way of asking those
spatial queries as well as as well as
said of performing query performance
spatial subsystem which we already have
I don't know who was first did I think
you've been waving before as well so
I'll take you first
the top databases on
so is a graph database more about
querying the data or is it a rewrite
yeah right so very good question because
obviously most of the queries I had were
read-only queries but yeah it's an OLTP
system so online transaction system
where you can write and and read at the
same time it's our proprietary
technology it's the main so yeah we have
key value pairs on us attributes on your
properties as we call them on each node
and relationships but the main part is
the structural part of the graphs of
nodes and the relationships between them
and we've got a proprietary storage
format for for that so all great graph
databases have that model I'd say and
for the most part they have their own
storage representations and storage
solutions although of course not all
have the exact same storage strategies
but mainly the they all tend to have
some notion about the local query should
only sort of act locally so the the
performance limiting factor should never
be in the the full size of the data set
but how connected each particular notice
that's the the limiting factor for the
performance of of your queries like how
connected each entity is rather than how
many entities you have but yeah that
said we since we do on back circling
back to the topic of writes since we do
do do all these connections and things
like that as as first-class entities
through relationships rather than
as joins as a relational database does
we sort of trade some rights performance
for we perform so we write more
information in order to have faster read
queries not that writing is slow omits
it's perfectly fine but yeah
some data
interfaces to read the databases and
then they can now
pretty much yes yeah and I really want
you have to go your question as well so
so if there are customers using a
relational database and in the process
of migrating yes definitely so there are
even customers using relational
databases in conjunction with me every
day and that currently have no intention
of migrating there have perfectly happy
with having the two systems running side
by side because they store different
data or we even have so the customers
who do migration are mainly the ones who
start out as with a relational database
that they have that doesn't doesn't
perform well enough because they got
joint problems so you do replication
over of that data over to near for J and
use near for J as a query accelerator
and those are the ones that would be in
the process of migrating are there any
technologies for doing migration we have
so the best thing we have for that is
our CSV import functionality so if you
can export to a CSV format that will be
somehow structured in some way what you
can do is say is based on import of that
where you will define a write query that
starts with load CSV from a CSV file and
defines a pattern for how to map that
each row of that data onto onto the
graph I would love to take more
questions but we are out of time so if
you want to ask me anything else
you can either buy me a beer or I'll buy
you a beer and we can talk about it
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>