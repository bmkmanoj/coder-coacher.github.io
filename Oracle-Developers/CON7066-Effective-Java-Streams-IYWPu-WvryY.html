<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON7066   Effective Java Streams | Coder Coacher - Coaching Coders</title><meta content="CON7066   Effective Java Streams - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON7066   Effective Java Streams</b></h2><h5 class="post__date">2015-12-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IYWPu-WvryY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to streams talk I called it
effective because that seems to get the
crowd into he put effective before stuff
that that helps so I'm pull a mostly
work on core libraries but occasionally
dip down into the hot spot and get
confused when it spits out assemble code
and stuff like that when I looked at the
schedule I saw myself as if you can see
I'm not sure you can quite see that on
the slides unfortunately this talk is at
238 Java streams and then I gotta talk
at five-thirty on some miss gun safe but
in between those asked the architects
and I thought I might be done between
the meat of the burger to get the good
stuff here and that's kind of a joke
because we always used to think of lists
dream as a bun before you get to the
good bit of than that Phil to reduce and
stuff like that but in the case of meet
the architects it will be Brian John and
Mark in alphabetical order of course no
preference here so I'd like to attend
that too that should be a fun talk in
between okay so if your gender I'd like
to talk about some patterns or idioms
but they're not they're not really
patterns or idioms they're just maybe
tips and tricks with interesting stuff
you might find interesting so I just
froze some stuff out there some
interesting examples and just explained
as I'm doing it and you might find this
thing's useful when you write your own
Java streams code I will talk a little
bit about effective parallel execution
not much I've done these talks before
you can watch on previous Java ones
there's other talks on parallel
execution and performance as well so
I'll let people talk about that I will
focus on enhancements that we've done in
Java 92 the streams api and api is that
you streams and then i'll talk a bit
about beyond java 9 and that would be
project valhalla stuff so i'm going to
get into the ide now and talk about some
stuff so i will make sure that this is
suitably scale so you can actually see
it can everyone see that or is it going
to be a bit difficult we will see that i
might scale it down a little bit so the
first 10 one thing you do in map filter
reduces you talk about count
that's what you're doing Hadoop that's
what you're doing apache spark so that's
what I'm gonna do in streams start very
simple examples and build up so if we
got a stream of strings and we just want
to count the number of strings in this
string so one of the things you might do
is type it in and then go well I got for
each here I like my for loops for each
seems kind of familiar ok let's start
using that so we got element here we
write little lambda in there and for
each doesn't return anything so Oh what
do I do here ok well let's do something
really hacky close your eyes don't don't
say I did this new long like so and then
I do this that is awful please don't do
that so we got a box essentially where
for eaching over it but if you but one
of the reasons not to do that is because
if you go parallel this is this this for
each Verlander in the for each is going
to be executed in parallel on multiple
threads and you got you got issues here
so you don't want to do that so someone
might say well okay let's uh okay I can
get around this keep pushing it Tomic
long that's uh you know what you know
where I'm going with that so we're gonna
get there so you can you can get it to
work you can even use long adder which
is much better in terms when you got
like intention and stuff like this but
there are occasions when you do need to
do this type of thing but not not not
mostly so another one we might look at
is well we got reduce here we're dealing
with strings but we want to count up
numbers so what we do is we give a juice
so we start off with initial value of
zero and we take an intermediate count
and an element and then we go IC plus
one okay so we want to add them up like
that but we also have to deal in the
parallel case when we want to add to two
counts together to merge them up so we
have to do another lambda 8 plus be like
so and we have a long count here like
that anything wrong with that does that
look good will that work well so we're
we're operating on the stream of string
here and if we look at the the the
signature of reduce its actually taking
in objects so we're actually we're
actually boxing here so that's not very
good thing to do I've we don't want a
box in this situation but let's look at
what we're doing here we we got a lambda
which is adding up numbers here so
that's kind of a summation let's just
give us a clue we're adding one here so
let's let's split this up and let's
think of it as a map too long so we
transform from a stream of strings into
a long stream we don't get actually any
boxing going on and then we map the we
essentially map each element 21 we're
transforming our domain which we kind of
did in the reduce but we're making it
much clearer here and then we can
actually concentrate on a reduce of
Long's like so that's looking better
that's the classic MapReduce I could put
a filter in there if I wanted to we
could always do a nice method reference
here it makes it look better but we can
actually change that to a sun rays the
abstraction a little bit because we have
a some method on on on long stream if we
sorry wrong just look here this this
method here is transforming a stream
into a long stream so we're transforming
the domain and we sum it up but we can
go even higher abstraction which we can
just do account and we're done so that's
a very long-winded way of saying this is
how you count streams but you can see
how it's built on top when you raise the
abstractions here we can actually monkey
around underneath the covers so if we
just go back to here and let's say we do
a peek out oh I can type properly
so peak is poor man's web debugging
streams with print statements so we can
actually run this and we should see some
output okay we got strings but happen
two letters of the alphabet nothing
important so we can actually see the
output yes question pardon yes use a
debugger yes you have to be the buggers
need to get a little bit smarter about
when to debug ins for Landers because if
it's all on one line it's it you really
need these to have better focus i think
improvement provide ease would be a good
thing for debugging lenders and they
will come about as but when you're
debugging in parallel that's even harder
for sure I agree it does introduce its
own problems so we you see the string
got executed and we saw the output but
if we if we actually change that back to
account like that and we run this do you
think we'll get output or do you think
we will not get output no output okay
you're absolutely correct no output and
the reason is because under the covers
we know that this stream of strings is
actually we know its size so you don't
actually need to have to calculate the
pipeline some people might find that
surprising because it might be actually
leveraging count to do some side effects
in other operations so you have to be
quite careful because we do say don't do
side effects and pipelines unless you
know what you're doing so be careful of
that we can up the abstraction and we
can do stuff underneath to optimize if
we need to so that's the lesson there
okay so that's the 101 we're counting
let's look at something slightly
different stream concatenation so I've
got some streams of characters nothing
terribly interesting here but say I want
to concatenate two streams together
so we'd use a stream and miss
measurement method already there
available stream a B concat like that
nothing particularly non-intuitive there
how if we just like so printed out so if
we if we wanted to concatenate free
streams together what would we do
okay you're jumping ahead there my
surprise that's all right I shouldn't
ask questions if we don't expect it so
we could do this stream concat B comma C
like so forth and we could do that again
again we layer it down and so forth like
that but sometimes you maybe don't want
to do it that way for certain reasons
and there's another thing you can do
instead if you just transform a little
bit the way you're thinking you can
create a stream of streams a comma B
come see and then we use flat map and we
map as the identity function so flat map
is something that takes an element and
maps it 20 or more other elements basie
substitutes an element 40 or more
substitute zero or more elements so
we're taking the streams and we're
substituting the streams for their
elements so it's essentially the same as
concat in terms of functionality but
stream concat has optimizations inside
it to better merge and split things
together whereas flat map won't have the
same optimization characteristic so you
have to be aware if you want to go
parallel concat my offer you better
splitting characteristics better
performance than flat map but sometimes
flat map might be the type of expression
you want here and it's a little trick
here of streams of streams flat maps and
stuff like that you can sort of using
your own in your own code as well so
that's an as a gentle introduction to
flat map and I'll get on to some more of
it in it in a little bit so here is
another one of processing optional
optional is pot is a really small class
doesn't have many lines of code in it
but it possibly created the most amount
of discussion in Java 8 and it seems to
create the most the trollek blog posts I
don't know if you've ever read about it
it's only a class and it's just a class
that says do I have a value or don't
have a value
and it has to work in a jar environment
where nulls exist so it's not like
Haskell or anything like that so people
get very worked up about it but it is a
very simple thing introduced into
streams when you're returning stuff for
streams empty or not empty you have to
indicate whether something is present or
not so when you're working with
optionals you might find yourself in a
situation where you're dealing with a
stream of optionals so we've got a
stream of optional strings here I've
actually forgot to delete my code so you
saw something so what we want to do is
take a stream we want to get a stream of
string from a stream of optionals like
so so one thing we could do is use
filter and map so we could do filter and
then we take our optional amigo optional
dot is present so the filter will say ok
I'll only let through optionals by the
present and I'll drop all the empty ones
and then we want to extract out the
value from the optional so we go get
like so and that will extract the value
out but that's okay you can use some
nice method references you can see the
the IDE is telling me no it's not you
can use a method reference like so and
makes it look nice and neat optional get
looks good better but get is kind of an
unsafe method and optional get has it
relies on the fact you've already
checked if something is present before
you go get because if you call get on an
empty optionally I'll throw an exception
so that's something you should use with
care because it could be easily there
might be code paths you're going through
where it suddenly pops out again without
checking if it is present so perhaps we
can look at an alternative way of doing
this who's phone flat map we use flat
map again so take our optional and we
want to check if its present or not to
go is present and we take a stream of
let me just press return here I don't
get or no like that that doesn't look
very good either does it well we got
flat maps good zero or more it's like
flat maps a bit like a combined map a
filter and map together so we're mapping
zero or one element here so we're saying
is present and flat map returns a stream
so we have to wrap the value we get from
the option in the stream and we're still
doing the if is present and get that's
not good either let's try and change
that a little bit and so we go we can
use some methods on optional to get the
nice fluent chaining yes you can use
novel flat map will actually accept the
null value rather than stream got empty
can't remember perhaps so we want to map
this to where am I in my I've lost my
train of thought now let me start again
so we want to get 0 dot map we want to
create a stream from it yes I got it now
so we element streamed of e similar to
before or we want to actually do or else
and stream dot empty so that's we're
using empty because it doesn't accept
null yeah so and for some reason the
idea is putting a type when this in
where we don't actually need and then we
can change that to a method reference to
make it look better okay that's getting
better we haven't got the get there so
it's kind of safer to use but this is a
very long-winded way of saying a new
method we added in in in 9 which you say
optional dot stream and that's that's
what you need to do if you find yourself
sort of contorting your way through in
java rate there are cleaner ways to do
it rather than the initial one i showed
you but in java 9 you can call optional
dot stream and then you can just turn
that into
a method ref I can type it in like so so
that's the cleaner if you're using flat
map with your own stuff and you find
yourself getting contorted right a
little method helper method that you can
use as a method reference and then it
becomes a lot cleaner and lot easier to
read in the code as well okay just check
the time it's probably the last one I'll
be able to do but i'll switch to some
slides so this is when you've anyone
ever written data providers in test mg
when you're writing data Combinator's
and you want to do a bunch of tests over
a range of stuff and what you do is you
tend to write combo tests will you do
four four four loops over a range of
parameters so here I want to create a
set Cartesian product / parameters
ranging from 12 to another parameter
ranging from ABC and another one ranging
from two floating point values and if
you I want to create a stream of object
to raise better then I can pass to the
test ng data praia de so there's a
simple way of doing that with four loops
but i just want to show this using flat
map because if you can understand how
this works you'll drop how flat maps
used in many many many scenarios so you
can see the output here is doing all
combinations of values but I really can
input to a test method so here is the
implementation of this using streams so
first of all just for explanation
purposes I'm going to create a little
function and what it does it takes a nod
to object arrays and it returns a stream
of object to raise and it sensually
takes in this example if I have an array
of 1 and 2 an array of a and B it
returns the stream where i append the
the second values to the first array so
I get one to a on one to be so that's
what my function does here so I
basically map my parameters and then I
take the array i have and append my
parameter onto it like so
so we can actually do use that little
function in combination with flat map
and we can use a for loop because for
loops aren't bad use for loops when you
want to but not bad and we can stream
over starting from a stream consisting
of an empty object array and we iterate
over the parameters and we flat map for
each one of the parameters essentially
we substitute the intermediate product
we have for the product plus all the
parameters so we substitute product for
product plus params one product plus
press pound 0.5 primes one and so forth
like that and so he's chaining flat maps
together one by one by one and iterating
over them if you can understand that
i'll put the source code online
afterwards it might be hard to grasp and
you can play with it and if you can
understand that you'll drop flat map
anywhere and what we actually really
want is something called a fold left if
you look at if you look at another one
over written which is called slightly
naughty because we don't have fob left
on stream yet and I'm emulating it but
if we had a fold left we could stream
over the set of parameters we have and
then fold into that stream the
parameters using exactly the same flat
map as as before so that you can
actually build very concise powerful
expressions using driver streams and
lambdas that just wouldn't be possible
before you can see this one's got lambda
and embedded lambda and I never embedded
lambda in there which is quite powerful
and expressive but it takes a while to
shift your thinking yeah ok I think I'm
running out of time there so I'm going
to switch to now I've got a bit more
time yes
I've having debates with Stewart marks
about adding fold left it doesn't it
doesn't parallel eyes so it's entirely
sequential so I was wondering whether we
should add it but just for expression I
think it's actually a useful thing to
have so I'm sort of he's persuading me
that it might be a good thing to have
and it was certainly clear up this type
of code i think more much more cleanly
okay I we can add abstraction for making
it easier for sequential because that's
probably where most of the cases will be
actually but we just have to be aware if
you use them in parallel scenarios that
might suck in terms of performance pun
I'm getting to that later yeah that's
that's something related to valhalla
i'll talk about in towards the end of
the end of the talk here's an example of
sort of thinking slightly outside of
what you'd normally do say we wanted to
fill the contents of an array what you
can do is you can stream over the
indexes of the array and then fill in
the values according to the index so
that's that's a shift in the way you
might be thinking so if you look at
parallel settle and arrays it does
exactly that it basically takes an array
and an inter function which says given
an index give me a value and does the
parallel for each and assigns a value
into the array at the right index so
that's if you want to manipulate arrays
that's you can you can use that little
trick and in fact we have API notes in
the Javadoc which say if you want to do
it over a subrange you do it explicitly
because we haven't added the sub range
type methods for arrays here so you can
actually did and there's a nice little
API notes for you there
so here's a more complex example I'm
going to code this up so say we got two
arrays here and we want to see if
they're equal but we want to use our own
comparator to see if they're equal so
obviously there's a very simple for loop
implementation here but let's just see
exercise whether we can do this in
streams so we've got to use our trip to
stream over the array indexes to go from
range to and it's going to be math dot
min over minimum of the two lengths like
so and then we need to what do we do now
well what we can do is we can map the
indexes into the results of the
comparator so we can take our index here
and when we can call comparator doc
compare like so now what do we do we
need to somehow gather all these results
together need to get an end results so
that we want say a boolean we
essentially want a boolean which says
whether we whether those two arrays are
equal according to the comparator if I
can spell billion that would be good
yeah there we go so one way we can do
this is we can reach for our reduce
again we're dealing with in streams so
we're not boxing here at all so we start
off with 0 0 is good because if the
array lamps are if the minimum of the
tier a lense is 0 we're going to get a
zero out so that's good and then we need
to do something like this so we got our
values we need to merge to that to
comparative values together and get one
out so if AC is not equal to 0 we can
return AC otherwise if BC not equal to 0
we turn bc otherwise 0 like so ? here
and then
okay that works is there any problems
with that if you notice these two arrays
here it's the the the second index
that's not equal here not one to hear
we've also got a third index here is
that is that efficient if I had an array
of a million elements and the third
element third third index was a mismatch
between the two arrays no it would go
through up a whole array checking
checking this is not good we need what
we need to do a short circuit the
computation so the right thing to do
here is to use something called all
match and it's simply an all match will
do it and will short-circuit the
computation for you and will do you
think all match will work when the
minimum of the array lamps is zero what
would it return true or false we'd like
it to return true because our arrays of
zero length should return to and this is
actually what it does if you read the
Javadoc in there we have a bit of a so
this is what's called a universal
quantification but if a stream is empty
a quantification said to be vacuously
satisfied so it always return true so
we'll always it will do the right thing
for us which is good
yeah if you want to do it efficiently
like that yes you would check check
those same slice
you could do that yeah yeah yeah yeah
yeah I'm just doing this to explain and
get you to think about the concepts here
in that in that sense but yeah if you're
doing this optimally and it's how it's
implemented in i have a new patch for
arrays comparators and equals and stuff
i'm adding two arrays at the moment
because they don't exist and it's
exactly what i'm doing internally i'm
not using streams so i have a more
complex example that i won't be i think
i'll skip and not go into i may come
back if I have some more time to some
further examples in there I'll put the
code online so that people can check it
out so let me switch back to slides so
some quick slides on effective parallel
execution so this is a very good
document written by Doug Lee here
explaining about how you can get good
paralyzation from streams and one thing
they mention in this doc one thing Doug
mentioned this document is on most
modern hardware you need to Proxima bout
a hundred microseconds of sequential
work across to actually break even it
always costs more to go parallel and
sequential so there has to be you have
to get up number of work before you can
actually get any benefits from it so if
I if it takes one nanosecond to add two
integers how many integers are needed to
break even on a parallel summation so if
it's 10 to the 9 times n proxima equals
10 2-4 we need about 10 to the 5
elements now dog says add add another
zero to that I don't have a magnitude to
that if you're feeling brave or
something like that but that's
approximately true if you measure this
you'll get in with in that type of
boundary so if you've got very simple
pipelines and you know you know what the
Landers do and you know proxima how much
land does cost you can do a quick back
of the envelope calculation to see
whether it's worth while to get parallel
or not there's all sorts of advice about
choosing good plating splitting sources
like a ray list
much better than linked lists good
intermediate and terminal operations as
well I'm not going to go into this
versus a session tomorrow by Maurice and
Kirk which I think will go into this win
more detail about how to get performance
out of the java rate streams so there's
been a bunch of enhancements we have
done for java 9 i showed you the
optional stream already in in flat map
we also added a stream nullable if you
want to create a you've got a null value
and you want to create a stream from
that that helps and that's all for
better integration with flat map this is
pain points we've seen on people writing
on stack overflow and on and on the core
libs email list in the JDK we also added
collectives dot flat mapping if you've
ever used something called collectors
how many people have used stream stream
collectors Oh quite a few so we added a
flat mapping it does what you expect it
would do so hopefully that would be
useful to people as well we've also
added stream returning methods in
various places in the JDK one thing I
was motivated to do was look at
everywhere that there was an return a
method returning an enumeration which is
an atrocious class and see what we can
do to improve it by using streams
instead so network interface used to
have a bunch of enumeration methods on
it and now it has equivalent stream
methods on it so let me just show you a
quick example of that so if you want to
get all the inet addresses out of all
the network interfaces you have if
you're doing it new using numeration
you'll see two while loops coming in
there but we can we can get the stream
of network interfaces and then we can
flat map to get the stream of Internet
addresses and then we can simply print
them out it's much more expressive than
using just enumeration see and we can
run that it probably won't be much
because I've got my network I got my
network connection and you can see my IP
address ok so it's very simple little
tweaks we've done to the to the
libraries but it makes a lot easier to
use these types of interfaces I also did
it
to Java security permission collection
not sure people care much about that but
it's still much more usable to use
elements of stream than elements and we
might have to go clear up our own code
to do that if we if we have time clear
up some technical debt but that's quite
an old interface yes I'm touching
security code is delicate in the sense
if we've had to do it carefully but yes
agreed and in fact there's security
implications even in the code we
modified the network interface so we
have to be careful we're making sure
that do privileged blocks in our
implementation weren't changed in terms
of the functionality so quite careful so
there's been some larger enhancements in
Java 9 as well what we've done we've
added two new operations take while and
drop while I think there's a kind of
obvious what they might do but I just go
for a little demo of that
so let's say we just got some data and
we want to use take while and we just
want to take take some elements not all
of them
okay this is an easy question to ask but
what elements will be printed out there
yep so we get one two three outs so
basically it's a short circuiting
operation that will stop after this
predicate returns yes
I will get I will get on to parallel
implications in a moment and a little
demo of an infinite stream as as well
we're also got dropped while which will
do the inverse instead of 12 free will
get four and five these are like kind of
what had talked about with fold left
these are predominantly sequential
orientated operations if you try and go
parallel these Bell have the same
performance implications as limit and
skip which is basically accounting based
versions of these types of things so
that predominately therefore sequential
and also for ordered streams this does
not make sense if you've got a set and
the elements can come in any order what
does it mean to drop while on I less
than 4 for a set of integers it doesn't
it essentially a non-deterministic
result if you run it sequentially it
will be deterministic but if you run it
in parallel it will be non deterministic
ending could get any result out of it so
you have to use these wisely in terms of
parallel execution they're in there
already in the in the in the JDK nine
dead builds it's all done I've been
there soaking in there for quite a while
so so here's an example of where you can
use take while in a quite an unusual
situation I originally thought about but
it might be useful we said about
parallel and unordered but there is a
use case where it does work for parallel
and I'll ordered quake and they're quite
reasonable one as well so we want to
generate a bunch of information that
generation has a computational cost like
probable primes a fantastic demo example
they computationally expensive to create
and you can do it in a few lines which
is great for Fantastic Four demos so say
I wanted to generate an infinite stream
of probable primes and I say I want to
generate it until I've reached a certain
duration so I'm doing it here slightly
inaccurately but I'm creating the start
time I'm creating a duration and I'm
taking while I'm within that time period
within that duration
and then I'm just going to count them up
like that course count will actually
execute the screen because it doesn't
know what the size is so we can run that
sequentially and see how many we can
count so we're creating as many probable
primes in five seconds and weez about 96
what we can do is actually go parallel
and we can run it again and let's see
how many it creates in five seconds
about 385 that's almost not quite a
linear speed-up on my mac but it's
actually doing quite well so if you have
these use cases actually there is
actually a case for take while that
works in interesting scenarios I think
it's an eight-core but they share to
cause share the same sort of acting is
like hyper threading going on so it's
really for in some cases so that's a 4x
beat up and in those cases but there's
some there's some probably some overhead
internally in here but it doesn't get
better speed up so those are nice little
additions there we might add some more
ops 2 streams if we have time there's
also we've done some parallel
performance improvement for files lines
and we've also added some stream
returning methods for match and scanner
as well I'm not going to go into the
details of the latter one today so I
talked about stream take while and drop
while so one of the things I wanted to
do was change the implementation of
files lines previously it was based on
bufferedreader dot lines which is
essentially inherently sequential
operation and the way we derived
parallelism from that was to copy a
prefix of elements into a buffer and
keep growing the buffer it and we derive
some parallelism from that but it
actually performs quite poorly but we
have an optimization we can do for
character sets like utf-8 iso 8859 and
so forth USS ki where we know that line
feeds are easily identifiable we just
look at the bite
and we say whether it's aligned to your
carriage return so what we can do is we
can actually memory mapped files and we
can look at the midpoint of it say I you
a line feed know okay let's look behind
you let's look in front of you and we'll
stop when we find a line feed and if
you're processing a file four lines
you'd hope there are lines in that file
so there's a reasonable as a reasonable
optimization that so we can actually
efficiently chop the file in half chop
the file in quarters and so for that and
then parse the lines on all that cause
keeping them all nice and warm and that
works very effective so here's some
performance results I got here so we're
comparing on the left hand side
bufferedreader dot lines and we see the
actual parallel so it's essentially
processing lines counting them up a
thousand hundred thousand lines 80
characters each and we actually the
parallel execution is slightly slower
than the sequential execution you
essentially getting no speed up because
there's just not enough it's not enough
parallelism in there to do it but if we
switch to the implementation and files
lines now which is in the JDK we
actually get free x speed up so forth it
depends and we get a nice boost in speed
up for utf-8 USS ki and things like that
so it actually is a real real boost in
performance that I used jmh on my
macbook pro this macbook to actually get
the results here and g MH is a fantastic
tool to do benchmarking absolutely
fantastic i highly recommend it so
what's happening beyond java 9 what we'd
like to do is improve the parallel
production of lists like collect two
lists and so forth like that at the
moment there's a lot of copying going on
we're using ArrayList under the covers
and copying what we'd like to do is do
better merging of lists and maps and
improve performance but it's going to
take some time to work out the right
algorithms there and what we'd like to
do is leverage value types and generic
generics over values so that we can have
a simpler and more powerful API and
implementation going forward and that
will make it easier to introduce new
types of extent
to vapi such as map streams or an spi to
plug in operations that we don't have
today and what we want to do essentially
is I showed you in stream and long
stream and so for flow what we'd like to
say is Express in stream as a subtype of
stream event and we can't express that
today but we'd like to express that in
the future and so we're experimenting
with ways to actually try and implement
that and see what problems we're running
into trying to inform us how to how to
solve this in project Valhalla I'm one
of the ways way we implemented streams
excuse me in Java 8 and 9 is we have an
in-stream a long stream a double stream
and a reference dream and as a whole
bunch of duplicated code copied and
pasted code copied and pasted javadoc
and it's painful to maintain it's easy
to make mistakes between the two so what
we'd like to do is express this but have
a runtime to all the nice specialization
under the covers so we don't have to
read we don't have to explicitly
generate this code and we want it even
more such that when we express a stream
event that's backed by an ArrayList
event all those imps are nicely aligned
in memory so that cache coherency works
nice and so we get nice good performance
so as brian says in the keynote is dense
and packed so not just stream event
stream a point stream of into 128 which
might be composed of two Long's but
nicely aligned in memory and then we
want the stream pipelines to inline
better than they do today that's a hard
problem to solve what we want is that
main processing loop when we do a
terminal operation to all in line in
line nicely we call that loop
specialization click click write a blog
on it a number of years ago cutting
called the inlining problem it's still a
problem and we still need to solve it so
that's a lot of things to ask and I
haven't even got to two pools yet so
here's why this is important this is on
Jonas boner from akka a type-safe has a
nice just on github showing the latency
times
in computing other things so if you want
to access reference in the cache it's
like five nanoseconds if you want to
access main memory that's 100
nanoseconds if you have things dotted
around all over memory the cost is
enormous compared to what is actually in
the cache already so if you blow your
caches your performance is going to
nosedive and this happens when you use
boxing so if I create this integer array
here okay 10 integers if you use a tool
called Joel on OpenJDK it can tell you
where those integers reside in memory
and you might think initially initially
when you create this array of integers
it's all nicely aligned in memory it's
not it's not particularly dense but it's
flat but when GC kicks in it's going to
shuffle all those integers all around
because GC thinks I need to move this
one here I need to be this one here and
its trying to compact defrag memory and
so forth listen manager and the effect
is the linear list of integers you have
in the box is its pointer chasing so if
you look at the results here you can
actually see that we see where's integer
0 is right at the bottom integer beans
jawan is in the middle there's about 170
k difference between the two integer to
is popped down again free for wit
pointer chasing we're blowing our cash
or not nicely aligned and that's that
makes your performance nosedive and you
can have a performance of stream of
integer and in stream and see the
difference between the two that's why we
want value types dense flat data and
streams can really take advantage of
this in the future so there's a
prototype in Valhalla you can actually
play with it today excuse me you can
there's builds on adopt OpenJDK you can
download and play with there's a
temporary home for what we have
converted classes of stream arraylist
and so for that we called it any Utah
this is a temporary home this is not
permanent we're not going to introduce a
new package
into JDK 10 or 11 called any util dot
stream and fork things and the code is
actually significantly reduced in there
because you've removed all the explicit
duplication of code between the
primitives and the reference types nests
and out all unified together so here we
get onto gentleman over there asked
about zip so why don't you just add a
method to zip two streams in Java 8 and
9 it's a good question i had zip in java
rate before it was released and we
removed it why did we do that well we
could just add one here reference dreams
a and B and a by function that
transforms it takes a and B and return
to see like so forth like that but is
that enough we have in stream long
stream double stream I want my stream
and in stream well I've chosen by
function here but we're going to have
boxing coming in on the on the function
here and escape analysis and so forth
like that might not actually optimize it
so we might have to introduce another
functional interface is optimized for
this case but I want my stream and long
stream I want my stream and double
stream I want my instrument stream in
stream long stream in stream double
stream long string alarms doing long
zoom double stream you get the point and
then I haven't even got to the fact
whether i need to do with the weather i
focus on the shorter stream or the
longest dream there's another axis but i
can support as well and this is getting
ridiculous and you might as well just go
read a zip code directory instead
because it'd be more productive so
that's the reason why zip was not added
because we could do the simple case but
we couldn't do it properly so we decided
not to do it at all you get this method
and functional interface explosion so
this is much easier to support in
valhalla with fewer methods and fewer
functional interfaces and support the
tuples would be really really nice here
but how many would like to pools in the
language and we would like to pose in
the language but not value types okay so
there's a priority here first of all we
have to get value types in
we have to specialize that and then we
can start building up new features as we
go so let me do a demo on this so I have
a little project set up with project
Valhalla built up and I've implemented
my unzip so here's an example of a
stream of integers and mapping it and
I'm returning a stream event here no in
streaming site and there's no red
squiggly lines either in IntelliJ why is
that let's have a look I'll get the
project up with IntelliJ decides it
wants to do it there we go so IntelliJ
added a thing called X for experimental
Java features and so it understands
viene keyword so you don't get any red
squiggly lines which is really nice
thing for them to do it really helps
developing code in valhalla because it's
just squiggly lines everywhere it makes
it horrible to look at so it just it's
just a really nice tweak and it didn't
take them long to do so we got an
extreme event and we want and we got a
stream of string and we just want to zip
them together and we can use the
function lambda function here no boxing
going on and we get a stream of string
coming back and if we run that will see
it work and we'll see Valhalla say spit
out a bunch of things thing I'm
specializing class so and so for
integers we see when we're doing some
name mangling here and the classifiers
it's not what you'll see in the real in
the real deal later on this is a
prototype and we're generating new
classes on the fly based on the existing
classes as templates and we're saying no
this actual a load is actually an I load
for an integer and safe labounda
bytecode and so it's specializing a
whole bunch of stuff we would have
explicitly specialized in the Java 8
implementation and we get it we get the
result we expect we're just combining
but the the numbers and the letters
together and we can go a little bit
further just just pushing on this we
could have a zip that
could return a tuple but what would a
super look like I don't quite know what
a tuple would look like so i invented
one which is not particularly very nice
syntax wise but if two pools were value
types and we had better syntax for this
in the language you can see where we're
going but we can't get to here yet until
we get to here so there's a priority of
features we need to do and this to get
to hear and to get it all nicely aligned
dense and flat is a significant amount
of work to do so hopefully that gives
you a flavor of that you can you can
actually play with it and play with your
own api's if you're inclined to do so
and see what works and what doesn't
because we'd love feedback around this
and streams for us has been a great way
to get feedback on how we're working how
we can improve this and so forth like
that and in fact if you look at the
implementation in zip you'll see the use
of any here which says I can be
primitive or reference and it's actually
just very simple implementation
underneath like you'd write it today
just for references so hopefully that
answers a zip question okay
okay that's the safety slide I can go
back and do some other coding examples
or I could just take questions so we
just take questions i have 10 minutes
for questions at all right okay
I you're going to have to if we have a
microphone you got have a microphone
okay it's very difficult to hear you
sorry you don't have to come up and
shout it to me when I can I can
yes it's a fork join common pool not
xsplit there is a way to do it you have
to run your stream within a fork join
task which is obtained from your
customized bread pool but it's not a
supported functionality
right so you have to run your fault you
have to run your streams in the
customized fault joint task from that
from that pool and that it's a hack but
it will work for you but we don't have a
way of customizing the the pool that's
used by default in streams today
unfortunately something we need to work
on no you should you should use the full
loop when you think it's right to do so
don't don't go blindly replacing your
for loops of streams you should use it
where it makes sense in terms of
readability if you don't have any
extreme performance concerns stuff like
this but don't go wildly replacing your
students and trying to fit things in
ways that don't fit so you're orienting
the goal oriented I want to do this yes
it's a recipe approach and it can make
code much more readable and I think
that's a good if you can if you can do
that that's a good thing but don't try
and contort things that don't matter
does we have a skip we can skip</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>