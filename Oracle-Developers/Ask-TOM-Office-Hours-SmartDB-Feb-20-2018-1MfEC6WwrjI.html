<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ask TOM Office Hours: #SmartDB | Feb 20, 2018 | Coder Coacher - Coaching Coders</title><meta content="Ask TOM Office Hours: #SmartDB | Feb 20, 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ask TOM Office Hours: #SmartDB | Feb 20, 2018</b></h2><h5 class="post__date">2018-03-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1MfEC6WwrjI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay hi let's just stop sharing and I
think we're pretty much on the hour so
let's say let's get let's get going so
hi everyone I'm Chris Saxon I'm part of
steven feuerstein oracle developer
advocate team and the answer team on ask
tom
it's my job to help you get the best out
of Oracle database hopefully have a
little bit of fun while doing so so with
that in mind I'm really excited today to
be hosting this office hours session
with Brin and tome it's gonna be all
about smart DB and how to best
architectural application help answer
your questions they're both tuna tone
and brain have been working with Oracle
database and presenting at conferences
forever so I let them each explain
introduce themselves starting with you
Brin okay and now I'm going to share my
screen yes and before I say anything I
just want to make sure that the
mechanics of that they're working first
of all I assume that everyone can still
see welcome to ask Tom can you see that
Chris yes that's where we got up okay
and my host is me and I am with myself
shortly so here I am and can you now see
a slide saying the smart Phoebe
manifesto we can indeed yes okay so I
will and relax now the technology seems
to be working and I should just say
before I say anything else about the
formalities of questions Cohen and I
decided that we're both too slow witted
to look at chat while we're speaking so
Chris will be monitoring the chat and he
will use some discretion along the way
and if he thinks it's useful he'll
interrupt us in mid-flight and say
here's a fascinating question can
respond to that on the other hand his
editorial decision might be to leave
such a question until later and but not
me and not tone we won't be looking at
the chat so Who am I um I'm an Oracle
time server I don't know who all are out
there but I know that lots of you know
this already so I'll be brief I started
in Oracle in the UK in 1990 and I came
to headquarters in the mid nineties I've
had a series
of jobs but from about 2000 I've been
the product manager for PLC co and
somewhat later along the path as
addition based redefinition was invented
in the PLC code team I should say I took
on product manager responsibility for
that too and I would only say after that
that has product managers go I would
like to think I'm not at the fluffy
marketing end of the spectrum for them
at the ordinary solid heavyweight
technical end must be said though that I
don't get any chance to write real
programs all I do is talk about biting
real programs and designing minimal test
cases minimal illustrations resorts of
new functionality or bugs or that kind
of thing so you have to all take that
into account when I appear to be
speaking from a position of vast
experience so enough of me now then um I
would assume too that all of you know
this but if you want to find me on
Twitter it's very easy this in case you
wonder is just a little self-deprecating
slight at the idea that some people seem
to think that I can't write anything
except it has to be a white paper so
this is the lightweight version of me on
Twitter and they're talking of papers
there is a paper and never mind all that
stuff they're the simplest way to find
it I would think would be just wherever
you are go to Google type in me there
are all sorts of other people out there
by the way have stole my name and PL
sequel and I tested this a moment ago
yes it's still working
there's this paper I referred to and
there's blog not all that frequently
updated but I would like to think that
when it is and I do write some quality
and so it goes so enough of that I think
you can find all the resources you need
and in a heartbeat without memorizing
URLs and this is the start of the
manifesto then and this
statement is not so much part of the
manifesto but it's the background for it
I'll just read it out loud software
systems must be built from modules a
module hides its implementation behind
an interface that exposes its
functionality this is computer science
his most famous principal and I've read
that out it oh 10 or more conferences
and I always invite people to challenge
it just to say and if it's what they
think but know that that's utter rubbish
look at this look at that it doesn't
make sense bla bla bla bla not at all
everyone I've asked and finds that this
is a solid piece of wisdom and it's been
regarded as such for many many decades
certainly since before I wrote my first
program and that was sometime in the 60s
so then um it's got a few words in it
module we've all got an intuitive idea
of what a module is interphase that goes
hand in hand usually with API as an
abbreviation we've all got a rough idea
of what that is too and we'll explore
those notions in a second because after
all we're talking about systems in this
talk and the series of set up talks
inside this series of ask Tom office
hours things we're talking about
unashamedly systems that use oracle
database as the database of record and
as well as tone down this will say late
so we have in mind one particular kind
of application here and that's the
classic OLTP type of thing where many
many users are all working at the same
time and each is making smallish atomic
changes or concurrently and we're not
talking about a business intelligence
sort of thing where super heavyweight
users understand a data model and
navigate through it and invent different
ways of querying we're not talking about
that so then I'm just connecting the
dots between the first bullet and the
second bullet in any system that's got
an Oracle database anywhere in it and
using the intuitively obvious idea of
modernization and top-down and bottom-up
and everything if we take the top
down approach it's got to be the case
that the Oracle database is among the
modules at the highest level you've got
the whole thing and then when you look
at the next level of decomposition
you've got an Oracle database other
things but you've got that so it's a
module now then what about the rest
implementation well the basic low-level
property of an Oracle database is that
it can hold facts and it holds the facts
in tables and it puts the facts there
and changes them and gets rid of them
with the famous insert update and delete
and it lets you see you what you've got
with the famous select and it seems to
me then just a tautology not a question
of politics or stance or interpretation
but just a basic and paraphrasing of
this first thing it seems to me then
that the implementation details that the
general high-level wisdom and computer
science want you to hide ah the inserts
updates deletes that operate on the
tables and of course the tables
themselves everything about them that's
what ought to be hidden and we just need
an interface to expose the functionality
and that goes hand-in-hand with the
notion of a procedural API and we've got
one of those in the form of PL sequel so
I don't think I've said anything here
that is in any way and ours with the
wisdom that computer science has
followed for decades
let's just and refine our thinking a
little bit with respect to our domain
and what are the modules I already said
that briefly I should say it doesn't
matter really for the point of view of
this discussion if we have an elaborate
system where the larger understanding
limit is that you've got information
system in the hospital and an
information system this is the us in an
insurance company and each have their
own separate database and patients go
into hospital and the insurance company
need to be billed and signals have to be
passed that's a large system and it's
got various modules but in that larger
system there's still one Oracle database
if we
I mean that rather than from another
vendor and that will be maybe along with
another Oracle database but this one
will be one of the modules so then
business functions matter and business
function is a term that sometimes use
just in the domain of requirements
analysis of what you want to do and and
that leads to an understanding of what
kind of information you need to assist
and retrieve but ultimately when the
thing gets implemented then the business
function takes on there a very concrete
form as something that's done and that
produces all sorts of in our case
interactions in the Oracle database
maybe fact samples sent to it and those
are also results of those facts going to
its queries are done in facts come back
for display maybe other sometimes facts
are sent in and changes are made and a
response is given either success/failure
or maybe some indication of the how the
world looks now after the changes we're
done those are business functions and
obviously they matter and that implies
thinking about it in a particular way
after all the low level implementation
details can change we've all heard of
refactoring changing the shape of some
table from many rows and few columns to
few columns
sorry many rows and fifth columns too
many columns and few rows or vice versa
so while the semantic content is the
same people do this kind of thing it has
no bearing on the actual definition of
the business function and therefore that
things should be held cleanly apart as
concerns and this leads us to this
notion that responsibilities in other
words the responsibility to make all
those business functions do what they're
supposed to do it needs authority and
the responsibility let's be clear about
this is after any change that has been
made to leave the database in the exact
state that it ought to be in given a
whole catalog of detail about what the
actual function is supposed to do and a
general larger understanding of all
sorts of constraints that the data must
satisfy one doesn't always repeat all
the constraints when one mentions a
particular business function was to
operate in the general territory of
established constraints like that so
that's the responsibility and indeed
more than that it's a responsibility to
show the right stuff in response to the
right parameterization or particular
presentation that's given in the outside
world and there's a subtle notion there
to do with security it sometimes happens
that one realizes oh my god I'm showing
something sensitive I have to close off
straightaway and that's another of the
responsibilities of the of the database
not to show the wrong stuff and if in
error the wrong stuff is being shown to
be ready to close it off instantly um
well then there's only one way to do
this it seems to me and that is exactly
this to encapsulate and close the
database in the hard shell in other
words everything to do with all the
internals are hidden and the own only
thing that the database presents as a
module to other modules is its
functional API even if this means more
programming effort than you would need
to do in some other schemes that are
more chaotic and well I'll say this at
the risk of annoying some people and
I've talked to lots of people along the
years and I talked to some people who do
just what I said and the conversations I
have with them are always fruitful they
start by an acknowledging that they've
got a system that that's generally
pretty good and everyone's happy with it
they're happy with correctness
maintainability security and performance
but there's some little incremental
improvement that I'd like the makin we
have a conversation that flows well
sometimes though I talk to people who
were unfortunate there in this world
that I've been them lampooning has no PL
sequel and it's two things emerged
certainly you get the impression by the
way they're saying it that people are
dissatisfied in lots of ways and more
than that you can't really get to the
bottom of anything you can't get a clear
description of what's going on even to
start
to wonder how things might be improved
because there's just such a spaghetti of
concerns so then this is a picture
version of what I'm talking about now
and this is if you like the the top-down
thinking about the whole system once the
requirements spec and the external
designer in place clearly there's going
to be a some kind of clients of it both
human and robotic and each of those is
characterized by the set of operations
that they are going to do the things
we've been calling business functions
and there needs to be a lot of concern
given to the UI and how to make things
most ergonomic and whether it's best to
gather all these facts in one go or to
gather a mover several screens that kind
of thing it's it's a really serious
discipline but it has the special
property that you can completely
decoupled thinking in that space from
everything to do with how those business
functions are actually incarnated
brought into being so as far as the
people on the right are concerned I mean
the human beings who are designing all
the client systems all they need to
think of is that well I can call
endpoints and when I present the right
facts the right thing will happen or the
right facts will come back and that's
the end of my need to understand this
part here the system the backend system
in our case the Oracle database I tried
to make this look modern by going
through the picture of the icon that's
the ORD s and ending up at there for
some place in the database those
diamonds are callable things in the
database in other words PL sequence
database and json in json out these days
and that's why I've called the thing
there adjacent shim now I'm going to get
a little bit more concrete than I was
doing before and I'll say that and the
day
bass is different from the outside world
and that the database has schemas and it
has very strong well understood notions
about cross schema privileges and a
general understanding of security within
that domain and it lets you organize
your code among schemas this has in some
ways some significant security effects
but it also has a straightforward and
code classification effect and so the
main point of this set of slides here is
that those diamonds we now understand
are nothing other than the exposure by
the execute privilege of the ability to
execute some sub programs into a schema
or the domain of a user where you
connect and this gray thing here this
connect schema is deliberately
completely empty the only thing anyone
who connects to it can do is to call the
design set of sub programs there and
with respectively larger principle of
encapsulation in a hard shell that's
enough you could do everything with just
two schemas you could have your connect
schema and your everything else schema
but if you did you'd be giving up all
sorts of opportunities not for the main
principle of modernization but for
interesting code classification and as
well separation of duties among
different developments that's a
significant point too so I'll show you
the code an indication of one code
classification scheme that you could use
and here I've put the actual real PLC
code rather than the JSON in JSON out
functions but the ordinarily
parameterize PL sequel in a different
schema just because it gives you mental
clarity when you're looking at it and
thinking about it and querying a
metadata in the database and I'm now
going to draw attention to the fact that
these ordinary PLC code functions and
here's a few more of them could be
exercised find more classical clients
like a robot using an OC I program or
something using no js' I don't mind
so this
two layers of interphase here this is
the one as its conceptualized in
ordinary PL sequel you know IB or I
should say index by pls in digit table
of record in and resolved out that kind
of thing or JSON in JSON out and then so
it goes on these sub programs will be
implemented in various ways and for what
I've drawn as a single schemer could be
divided into as many schemas as you
please according to whatever
classification schemes you have and
however you want your different
developers to be able to do more or less
things among the whole universe of items
in the database and then finally the
data and again separate in the code from
the data is not essential from the point
of view of higher levels of security but
it is critical from the point of view of
just the security concerns of human
beings and we're going to maintain all
this stuff and complete the picture
there'll be some error hongting but i
could talk at great length about all
this talk i've already probably talked a
bit too much but the main point here is
that the critical thing is if you have
an empty connect schema that exposes
only the execute privilege on a design
set of sub programs the secondary point
is that within the database you can take
huge advantage useful advantage of all
the notions have that come with schemas
to organize your code sensibly but maybe
different people have got different
ideas about the detail and they're all
entitled to their thinking so this is
another way just the simple sort of
piece of code that says what we're
talking about this is if you like my
understanding or my assessment I should
say my assertion of the smart database
paradigm then you arrange it such that
outside of the database clients can do
only that it might be a different name
and it might be a function that's JSON
in JSON out but it would still look like
that and this slide just shows that we
have something to talk about
it's a Sun survey during a few years ago
that showed that sequel was hugely
popular and no database programming
we're even on the map so that's to say
that not many people are doing what I've
proposed there and this is if you like
the simplest way I like to put the whole
thing I like to say that an application
was data is not persisted and treated
correctly is worthless and the only way
to get the correct data persisted and
retrieved is what I just said the
Hardwell sequel shell and it that to be
very very specific just to say it for
the third time means that the only
places that select insert update delete
ever come from are from database PL
sequel and I would say this is the
time-honored way people were describing
this as absolutely the best approach in
the 90s and of course performance and
security and maintainability matter and
they come along as almost free gifts if
you set your high-level goal to be
correctness and this now is my final
slide it's my dream that we can stop all
the various ways we talk about what
people do in our general space and just
acknowledge that there's a real trade
out there it's the Oracle database
development engineer whose
stock-in-trade
has to be data modeling and everything
that goes with it including therefore
sequel and formal logic set theory all
that stuff and PL sequel that has one
continuum of skill and by the way these
people don't need to know vac backup
data guard all that kind of thing so
I'll just now hand over the tone by
saying this is how I see our aims we're
going to advocate this approach we're
going to give people who are on the call
or subsequent calls who follow this to
ask about some details and to talk about
how they're doing things and we want to
and give the chance to people who are
less convinced about it or these think
it sounded sounds promising but can't
quite see how to go about it
how they might move those roadblocks and
also we want to get people who are dead
against all this lot to say why they are
and air there is foods so I probably
gone on too long
but there we are I'll stop now so tone I
think you can just seize control from me
is that correct I think I can yeah oh
let's go ahead
can you guys see my screen now okay
we still got Britain screen up I'll stop
there just in case that helps now I can
see yes no I'm gonna make a step so
there's one thing that I want to mention
that we should have said during the
introduction we're gonna have a series
of this smart DB office hours and at
this very first kickoff session we
decided to to give you what we call it
smart DB manifesto and since Brinn and I
are slightly coming in to the smart DB
Arena from a different viewpoint we
decided that we each give our version of
the manifesto but in the end we're
talking about the same thing the same
approach of building database
applications so so I'll give my version
of the manifesto now and we can open up
for questions after that and then in the
subsequent sessions next month and the
month hereafter we will probably go into
details of various aspects of this of
this approach I'm not going to say much
about myself I have a small bio up on
the deaf Jim you can read that for those
people who do not know who I am I see I
see a lot of people on the call who do
know what I am so the way I want to
approach the database man if the smart
DB manifesto is as follows and there's
one person on the call who will
recognize this I'm gonna talk about
requirements very briefly then I'm gonna
start reasoning about these requirements
and from the from the reasoning I'm
gonna end with recommendations so
requirements the scope as brain already
mentioned is LTP enterprise applications
how to build them and we want we want to
develop suppose we want to develop a
node that the enterprise application and
there's a couple of things that these
enterprise applications need to have in
them they need to be maintainable they
need to have good performance
preferably nowadays they need to have
state-of-the-art user interfaces there's
a whole bunch of more things probably
but I've picked these three to start
doing a little bit of reasoning so OLTP
enterprise applications that are
maintainable have a good performance
have state-of-the-art interfaces I'm
specifically interested in these
applications being maintainable because
the bulk of the cost of these
applications is in the run and maintain
phase and not as much in the initial
build of these applications so I'm gonna
start reasoning about this in various
ways first I'm gonna look at the
high-level architecture of these
applications and this is a picture I
very often use at a high level you can
conceptually see three tiers of that
these applications consist of they
obviously have a datastore at the bottom
they have interfaces at the top for
humans or machines and then they have
this big thing in the middle called
business logic now I'm going to talk
about the data first because what I'm
gonna talk about the data because the
data of these applications is the heart
of the application and the data are the
crown jewels of of these applications
and the way you organize the data is
basically the blueprint the foundation
on which all else rests on which the
whole business logic and eventually also
the user interfaces rest now there are
different ways to structure this
foundation in the history we've had
these three models of organizing data
we've seen the hierarchical data model
we've seen the network data model and
I'm talking decades ago here that's the
70s and early 80s here were that I'm
talking about and then at some point mr.
Cote gave us the relational data model
that that's a model of doing your
database design in a way that got rid of
all the negative things that did prior
to models had now since then we've also
had the object oriented the deviation to
model data and behavior as one now one
of the issues that I've seen
earlier projects with object-oriented
domain models is that these are in
essence hierarchical domain models and
and they fail heavily in the
maintainability aspect and this is just
a deja view of the hierarchical data
model that we used to have decades ago
there are similar issues that pop up
when you model your data that way yeah
and one of the main reasons is that in a
relational database design contrary to
the other two ways of modeling your data
every table is what's called a
first-class citizen you can you can
maintain every table as as its separate
entity and this dis not this used to be
not true in the other two models so for
maintainability it's best to base your
application on a sound relational
database design and by that I really
mean one that is genuinely designed
relationally not one that's derived from
an oo domain model and then persisted
inside an our DBMS because then you
still do your initial modeling in the oo
world this is something that I think we
should move away from and we should move
back to genuinely designing the data
requirements in a relational manner now
the other thing that I had in my picture
here is this big thing in the middle
business logic let's do some reasoning
about that now where are the tables that
structure on which everything is found
it could be considered the crown jewels
this is the guts of the application this
is where all the magic happens that you
want to achieve with your application
now viewed abstractly the the core
essence of business logic is as follows
it's code that transacts or queries data
from your data store and it's not in its
code that actually composes these
transactions and then executes them it's
code that compute composes the queries
and then executes them and both they do
this in a way that the business requires
this to be done in this application
so in in essence it's what I often call
embedded sequel statements inside some
programming language and inside the
programming language you code out the
way you want to have the sequel
statements executed for a given
transaction or for a given report that
needs to do a bunch of queries now I the
meaningly called us here if-then-else
loop code I'm not specifically referring
that this should be three GL code or
some imperative programming language
because obviously we have to we see a
lot of Java and object-oriented
programming language from which sequel
is being executed but if you go down to
the essence in the end it's all
if-then-else code that conditionally
executes different types of sequel
statement depending on the inputs etc
now let's let's look at an example
because there's there's a very important
point that I want to make and make
absolutely sure that everybody gets this
point I have an explicit example here
I'm using PL sequel because I'm happy
doing PL sequel but I could have used
any other programming language I'm gonna
talk you through this example real
quickly so this is a business logic use
case model a business logic module that
I want to use as an example so what's
what's that going on here I'm selecting
an order yes and specifically I'm
selecting just a single column of an
order selecting the limit of an order
then I have some business logic I'm
going to show that as blue it's just
basically going to look at the limits
and see if it's more than 20 and then
depending on this outcome is going to
conditionally execute some code that
code in itself is a loop I'm gonna loop
over all the order lines of this
specific order in that case and then per
order that sorry per order line that's
being fetched I'm gonna look at a couple
of columns in that order line in this in
this case the status and the discount if
the status is open and if the discount
is greater than 10 I'm gonna do
Cree's the discount by 10 else I'm gonna
assign zero to the discount and then I'm
gonna update this new discount back onto
the order line yeah so here we have a
mix of if-then-else loop code with
embedded sequel statements in this
particular case with single table single
row types of sequel statements something
we often see nowadays now some of you on
the call may realize that there is a
different way of doing this exact use
case the whole procedural code with the
multiple single row single table sequel
excesses in this particular case can be
done in a way that we refer to as set
based data processing set based data
processing is basically any sequel
statement that affects multiple rows at
a time yeah so here I'm updating the
order lines decreasing the discount to
be the greatest of whatever the outcome
of the greatest of these suya over here
is where the order the parent is the the
order that I was looking at the line
status is open and the parent is indeed
having a limit greater than 2000 so this
this way of doing the same kind of thing
that I had on my previous slide is
basically declaring what needs to be
done instead of coding out how to do
something and this this is a very
efficient way not only of doing the the
initial build and and getting getting
your code done but also execution-wise
this will execute a lot faster which I
won't mention come back to a little bit
later so the point that I want to make
is that this big blob in the middle that
I had and I called the guts of the
application is business logic and it can
appear in two distinct ways it can
appear as code lines in some programming
language that issues what I call poor
sequel or it can be embedded inside a
rich set based sequel statements and
obviously in the real world you can you
often have a mix of both some things you
can do set based some things you may
want to do robe robe a
and you'll have a mix of this but but
the set based approach definitely has a
bunch of advantages just look at the
lines of code being written in these two
these two alternatives yeah there's
definitely here an impact on
maintainability of the left and the
right and also there's an impact on
performance again I'll come back to that
in a minute so that's a bit of reasoning
about the business logic of these old B
database applications so now now you may
say what I have to write sequel why do I
have to write sequel I have over a mess
that can do that for me yes but over
ends always do the single row single
table version is in practice and you
have to write sequel not only do you
have to write it but I claim that you
can write set based rich sequel for most
of the use cases of these kinds of
applications and there's a fundamental
reason for this which I would like to
convey to you I'm going to use a little
bit of animation here so on the left
here I'm depicting the real world and we
live in the real world and we used in
natural language to reason with each
other about the real world now what's an
application an application is just a
model of a small bit of this real world
there's parts in the real world that we
want to model and execute as an
application on computer systems so that
we can reason about that bit of the real
world using computers how do we reason
about this well I contend again that we
often can do this using rich set based
sequel why do I think that's always
possible now now I'm gonna close the
loop here sequel as many of you know is
based on logic and set theory what some
people do not know is that logic and set
theory are based on the natural language
in particular those bits of the natural
language that deal with reasoning that's
the origins of those two mathematical
studies logic and set theory
yeah so in essence we can reason in the
model using a language sequel that was
based on how we reason in the real world
and this is why sequel fundamentally
fits what we want to achieve when we
build these kinds of applications this
is also why you see all these nocebo
vendors that popped up the last 10 years
slowly but gradually all adding sequel
to their products because it simply is a
fundamental fit for building these kinds
of applications so I have to write
sequel yes you do and you know what
these sequel statements you have two
hands right because the essence of them
is always very business specific you are
building a very specific application
through the very specific relational
database design so you have to manually
produce these sequel statements there's
no way you can have a framework that
generates these kinds of things other
than a framework on top of which you
basically write them again but inside
some meta language that that in essence
is the same as just writing the sequel
yourself now so preferably write these
sequel statements with business logic in
them because it reduces code and it
increases the performance and again it's
a natural fit for the requirement that
we have at hand let's do some more
reasoning go back to this picture I've
talked about the bottom part talked
about the middle part now let's talk
about the top part we always have user
interfaces and/or other interfaces that
is the layer inside these OTP
applications where we have the biggest
volatility in terms of technology yeah
we see new hip text X coming up every
one or two years maybe even less than
that we see complete paradigm shifts in
the top level in the user interface area
every six to seven years and these
paradigm shifts are never a purse
compatible and I can imagine that your
application that you're building is
going to outlive the
kinds of periods you probably build or
have applications that will live decades
10 15 maybe 20 years so they probably
will have to go through many of these
paradigm shifts if not many of these
tech stack upgrades at the top layer now
at the bottom we have relatively stable
technology sequel inside the database
it's been upper 2 compatible since 3
decades now and in the middle we have
lots of if-then-else loop languages so
we want state-of-the-art interfaces that
was one of the requirements now since
that layer is the most volatile this is
the layer where you want to be what I
call agile to the extreme and by agile
to the extreme I mean you want to be
able to switch and and take on one of
these new paradigms throughout the
lifecycle of your application now you
don't want to architect your application
to switch from a database you want to
architecture your your your application
so that you can be agile at the top
layer then that means that we should
architect your applications such that
that you can easily swap out and swap in
new tools and that and that in turn
means that you should not do anything
else in these top layer tools then the
user interface as soon as you do other
stuff in these frameworks in these tools
you'll you'll make the swap that you may
want to have to do or want to do very
eagerly in six or seven years much more
expensive now the question arises and
brynn already alluded to that also how
do we then interact between the user
interface that we are going to employ
deploy as thinly as possible with the
business logic layer well current wisdom
here is rest and Jason have you asked me
this question 15 years ago I would have
said soap and XML had you asked me this
question
25 years ago I would have said sequel
net are you going to ask me this
question in six years from now I may say
something different than
Jason right but currently its rest and
Jason that's ensuring so we have a
high-level architecture with JavaScript
frameworks inside the browser giving
these fancy user interfaces and all they
do is call rest with Jason messages in
and out which goes straight into
database api's has been explained with
this with this various schemas set up
now we had we have the technology
volatility here at the top but of course
you want to be agile in the business
logic and maybe also in the in the
design of the data structures now
throughout the lifecycle of an
application the requirements from the
business may change we may want to
change business logic maybe even
introduce or modify existing tables so
we want to be agile here so that we can
maintain this kinds these kinds of code
bases throughout the lifecycle of an
application so what do we do here well
we can use Java JavaScript c-sharp PHP
Python and there's probably a lot of
more languages available that you can do
sequel from and of course we can do PL
sequel also now since we're hand writing
the sequel statements it's very easy to
automatically go into also let's use PL
sequel in this area because real sequel
is the only language where sequel
statements are first-class citizens
there is an immense amount of efficiency
built in PL sequel to do sequel you
probably don't have an idea how much
things are happening under the covers
that are that are being programmed out
in layers inside a java stack via JDBC
etc now by doing sequel and PL sequel
which basically means you're bringing
the business logic into the database
because PL sequel was this if-then-else
loop language where we do business logic
you automatically gain these all these
nice features that the database has to
do for instance impact analysis like
fine grains
pendency management's that that enable
you to to do serious easy impact
analysis which you will need during the
lifecycle of your application things
that are more difficult in other
solutions the last bit that I want to do
some reasoning about before I come to
the conclusion with my recommendations
yes that everybody knows the database is
always the first bottleneck right
this is common-sense knowledge and this
is why at the end of the 90s and the
early in the early years of this
millennium why business logic has been
driven out of the database in the 90s we
did business logic in the database we
were very happy doing business logic in
the database but since then we're doing
this all in outside languages because
when you remove business logic from the
database you remove CPU cycles from the
database thereby you probably have more
CPU cycles left to do more sequels
inside the database this was the common
sense knowledge the common sense
reasoning in this area now I have some
flash news for you for those of you who
haven't seen my video on YouTube yet
this common-sense knowledge was a big
hopes it's a big misconception sequel
from outside is more expensive to
execute inside the database than sequel
from inside PL sequel as I mentioned
just a few minutes ago a lot of
efficiency is going on inside the POC
core programming language to do sequel
which is not available from sequel
statements being submitted s basically
text strings from outside the database
and this added these added expenses
particularly for row by row sequel
statements they are so much more high
doing sequel row by row from outside the
database that the gains that you think
you would get by moving business logic
out are being totally undone because the
sequel suddenly becomes much more heavy
in terms of executing them in the
database now there's something else
going on also the business logic and
no I've given you a fairly simple
example but most examples aren't really
that difficult it's just some basic
if-then-else and loop business logic if
you cannot do it in a set based secret
statement doing business logic outside
the database and particularly in Java
takes 20 times even more the number of
CPU cycles then it does if you just
cleanly program it out inside a pill
sequel module stored stored module the
there's a lot of detail about this in
this YouTube video if you go to youtube
and you just search for my name you'll
you'll get this YouTube video I talked
about 50 minutes where we did an
experiment for those of you who haven't
seen this I encourage you to take a look
at this video again it goes into much
more details explaining why moving
business logic out of the database
and thinking that that will give you a
database where you can do more sequel
and there has been a misperception that
would that we have been facing for the
past 15 17 years since we since we have
been moving business logic out basically
what I do in that video is I compare
three approaches I compare row by row
sequel versus set by sequel when done
from a no peel sequel outside the
database language versus from inside the
database language and actually I have
not tested this version here I'm only
testing those three where I empirically
showing where I am empirically showing
that this gives a speed of 2x and you
get another speed that speed-up of at
least 10x when you go to set based but
I've not done that this one because we
hardly ever see that as over ends don't
just work this way they they always
produce the row by row sequel so you
want the performance right that's what
was one of the requirements well I've
been reasoning about this I know I've
given you a summary but the reasoning is
all in the YouTube video
what this basically means is suppose you
have an application and you deploy it on
an application server and you can do a
hundred transactions with one
application server and it gives a
certain load on your database if you add
an application server you can get
scalability but the database becomes
more busy and with three apps you may
even possible to do go through 300 400
500 transactions per second but at some
point you you cannot scale any further
with your app service because the
database is the bottleneck and this is
the big difference with smart TV which
smart DB you should realize that you can
do the same thing those same 500
transactions if you employ set based
sequel and if you get rid of all the
additional CPU cycles that these app
servers compute inside JDBC layers and
what-have-you kinds of frameworks over
there you can do the same load in much
less CPU cycles inside the database and
if even if you go set based and you do
business logic inside sequel it gets
even further than so so the point that
I'm making here is with this smart DB
architecture your scalability issue
being the database is always the first
bottleneck happens way later way later
you can you can you can get more done so
with that I'm gonna move to to my
recommendations and they are basically
having looked at the requirements and
reasoned about them a little bit is to
have your relational if you have your
data structures as a generally designed
relational table structures as the
blueprint and the foundation of your
application this helps in
maintainability refactoring a data model
when it's done properly is the easiest
and it's done relationally it also helps
in performance areas I'm maybe gonna
talk in this sequence session about this
but I wanted to mention it here
one of the things that I've mentioned
that I see a lot when people struggle
with database designs is they are scared
to introduce new tables they like to add
just more columns to existing tables
this this is wrong this is totally wrong
and I'm probably going to talk about
that in a separate session in one of the
upcoming months what this also means and
that's my recommendation is you should
employ people who are educated and
experienced in designing databases if
you don't have these then smart DB will
likely still fail you need these people
the other recommendation obviously is to
do with the business logic use the
database as a processing engine instead
of a persistence layer only it helps in
performance in maintainability and when
done properly when you have the clear
demarcation with the JSON shims you can
you can have state of the art user
interfaces and and are able to keep up
with the paradigm shifts in that area
but here you need to employ people who
are experienced in set-based sequel and
Peele sequel again if you are not
encouraging these kinds of people to be
on your project smart DB has a highly
likelihood of still failing what's what
it is possible to deliver for you yeah
so here's the picture the smart DB
approached the database should be a
processing engine it should have the
table store it should have all the
business logic as PL sequel because
that's the language inside the database
from which we do all the sequel
statements yeah and the the last thing
that I want to leave with you is if
you're doing a smart DB project again
sequel and Peele sequel are your main
tools of course you're gonna need other
tools of course you're gonna again need
something to do the UI with very likely
you have workflows event processing or
batches you may need to have different
file kinds of frameworks or technologies
outside the database to do these kinds
of things but the thing that you need
should take away from this
recommendation is all those other
technologies that you may employ not
just the user interface they only ever
just call database api's yeah and it's
the people who design the database and
who build the api's that are driving
your project and they should cooperate
with the other people which you may even
higher and not employ that deal with all
these other things and make sure they
communicate and deliver the right api's
for the other guys in your projects and
with that I'm gonna end my version of
the manifesto we have nine more minutes
Chris yes okay well that was great
thanks Brynn intone so for those of you
watching this is your chance to start
asking questions for brennan tone about
what we've just covered or anything else
that you want to know about smart DB
please just put them in chat we'll
address them we're kind of running a
little bit short of time now but as they
both said we plan on doing more of these
this is gonna be a series we didn't
cover more things so could bring could
you give me a bit of an idea or give the
viewers a bit of an idea what you plan
on covering in future sessions kind of
whet their appetite I wasn't planning to
cover anything in a teaching fashion
like that was the purpose of the
manifesto rather I'm ready now to start
taking questions and some questions
might lead to our kind of you know
little bit of an expository sidestep to
lay some foundation rather than just
being anatomic and spelling a sequel
this way but that's roughly it yes and
do you want to just launch into some of
the questions because after all if we
don't really could be perhaps accused of
you know violating the trade
descriptions okay so here's a question
that's come in so it says you think this
this is as globally scalable as some of
these more modern architectures you do
you think you could build Facebook using
this
I'm gonna say no without any further
comments okay Facebook Facebook to me is
not the scope of what we talk about
we're talking about LTP enterprise
applications Facebook is a different
piece as is Twitter as is you name maybe
10 10 other different companies on this
earth but the but the ten thousands
difference of companies that have back
office systems but which are web enabled
with with self-service modules etc
that's the kinds of applications that we
talk about you got anything to add to
that brain oh no no I think tone said it
very well I think you think this
appointment very few of us are ever
going to work on an application of that
scale and it's with not unless we change
our job radically in which we might do
we might think enough of all this lot
I'm gonna go and join Facebook and
corrupt the world oops I didn't say that
so someone's come in saying the trouble
is that everybody thinks they're
building Facebook yeah yeah yeah because
everybody is is is doing a very hip
startup and thinks they will become very
big and investors will get the money
back very soon yeah if there's nothing
to be said there's nothing to be said
there the only question is do there
exist use cases where what we're talking
about is applicable and of course they
do all over the place you only have to
log on to look at your bank account and
move funds from one place to another to
realize many many examples of that that
are critical to our ordinary functioning
in the modern world okay thanks
so there's another question that's come
in saying in Java workload is evenly
distributed in two different UNIX boxes
but all the products this all process is
resides in database boxes how do we
avoid it so
I guess they're kind of getting at if
you you can have many many instances of
your java application but it is a I was
expecting I think I was expecting
discretion and that's why I specifically
added that one slide where I'm showing
that when you have linear scalability
horizontal scalability of your
application servers the database will
becomes the bottleneck at some point but
but with a proper sport DB approach the
database will become the bottleneck
later a smart DB approach out skills any
non smart TB approach in these kinds of
applications so so again I would
encourage people who run Java middle
tiers to do some profiling and figure
out how much time how many CPU cycles
are being spent in frameworks chasing
pointers doing JDBC specifically in
having row by row statements it can be
that sixty-six percent of your CPU time
is spent inside JDBC those sixty-six
percent across those five application
servers simply do not exist if you do
your sequel from PL sequel yeah so the
fact that you now have five application
servers with sixteen CPUs that are all
100% busy running your application
doesn't say a thing to me because I
suspect that only 1% or less of those
CPU cycles in these application servers
are being spent on the true business
logic and when you move inside the
database you only spend time on through
business logic which is the one percent
if I am
to add Brent no no no no okay so here's
a question which I'm not sure if we can
answer but so they're asking what is
your opinion about m/s AP software which
completely avoids putting any kind of
business logic in the database at all
including avoiding to use database
constraints it's actually and etc well
people do various things for various
reasons and there's no accounting for
the human behavior patterns that we
observe is all I can say and I think
I've already said by implication that I
don't think much of such a scheme and
I've advocated and what I think is a
sensible scheme and I think that my
reasoning was sound and the flip side of
that I didn't want to dwell on it is
that departing from that is and not
sound now people do various things
there's no accounting for ultimately
what there is people get in their heads
and do we see it in the world in general
and we see it in politics on a global
scale and all one can do who believes
one can see a sensible approach is
advocated the fact that people do things
that are not sensible is no grounds for
dismissing the validity of what seems to
be a clear thread of logical discussion
that shows a different approach is more
sound and the thing that I may add to
that because I now also see is somebody
making a remark it's not just essay peas
or con you business sweet also
of course we do there there are large
pockets inside our organization that
that do not adopt the smart DB approach
we are a very big organization over a
hundred thousand people you cannot
expect that we all think alike but we we
believe that whenever you embark upon a
custom bespoke application development
effort
maybe not a commercial of the shell
shell type of application where you
often get the argument we want to be
database agnostic and then of course all
the arguments go away because if you sit
if you set up front you want to be
database agnostic okay then smart DB is
out of the out of the picture and you're
gonna end up with an architecture that
will have lots of scalability
performance and maintainability issues
but you said you wanted to database I
can also see so that's that's the thing
that you don't have to live with yeah
okay well I think we're we're pretty
much up on time now I see there's small
questions have come in so sadly we're
not gonna have time to answer today
folks but if you come back next time so
we're having we'll be holding these
sessions every month that's right
Brennan tone yes that beast
what is it third Tuesday of each
calendar month yeah so if there is
anything that you didn't we're thinking
and didn't get chance to ask or you walk
away and more questions come to your
mind over the next month or so come back
or come back to any of the future
sessions
I want to thank Brennan tone for
spending their time helping share their
wisdom here thanks for everyone who's
joined us please go on can I kind of
just add one more thing I'm open for
suggestions of specific topics for
future runs and you can all email me if
you have specific topics that you would
like to we're further detailed very
likely in smaller slide decks than we
did today leaving open much more time
for questions and I think we also had a
couple of questions up front inside the
dev Jim we have the email emails of
those people who submitted those I think
we bring we should we should write
proper replies for those submitted
questions yeah okay the next few days
okay anything else you want to add
friend before we close it close this up
no I don't think so okay thanks everyone
it's great to see you all and hope to
see you again soon
good bye thank you bye now</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>