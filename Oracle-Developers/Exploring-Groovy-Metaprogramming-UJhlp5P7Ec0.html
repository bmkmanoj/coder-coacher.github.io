<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Exploring Groovy Metaprogramming | Coder Coacher - Coaching Coders</title><meta content="Exploring Groovy Metaprogramming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Exploring Groovy Metaprogramming</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UJhlp5P7Ec0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright let's get started welcome to the
session on exploring groovy
metaprogramming my name is Venkat
Subramanyam we're going to talk about
the wonderful concept of how we could
actually extend programs while program
is executing meta programming is a
pretty fascinating idea it is a way for
us to write programs that write programs
I mean why would you write programs when
you can write programs that write
themselves right so it's a lot of fun to
be using this but of course the question
is why do we really want to use meta
programming
well meta programming gives us an
ability to do certain things in a lot
more easier way than other techniques
that are available let's take a look at
a few examples of where something like a
meta programming can help us quite a bit
along the way the best time to ask a
question or make a comment is when you
have it so please don't wait till then
anytime is a great time for questions
comments just grab my attention and ask
your questions be delighted to hear your
views so let's talk about a few examples
here let's talk about one example in
particular that can be pretty easy to
see and understand and that is about xml
builders let's say for a minute that we
have a particular map of languages with
us so here are a bunch of language names
and their author names now imagine we
are told to produce an XML document that
represents this piece of information so
how would we create an XML output from
this anybody here who has written code
that spits XML out of course right we
all have and how do you feel about it
excited not really right well once you
do a write code for writing XML a few
times you will quickly come to a
realization that writing code that spits
XML should be given to the people in the
prison right so nobody in the civilised
free world should be forced to do it
well thankfully it doesn't have to be
really that hard so if you notice over
here I'm gonna say builder equals new
groovy dart XML dart mark a builder
and I'm gonna go ahead and create a
builder object now once I create a
builder object I'm gonna simply see a
language just over here and notice as
soon as I run this little code a little
XML baby just popped out so the point
really is it doesn't take a whole lot of
effort to create xml but the question
here is how did this actually work well
we can see metaprogramming at work right
here we went to this object called the
Builder and this is the mark-up builder
and we called a random method on this
particular object who decided what this
name of this method is well we just did
we could call it whatever you want to
call it we could call it blah for
example or we could call it languages as
we just did and as you can see very
kindly this object rather than rejecting
our method call it went with the flow
and said sure I'm an XML builder you
call something I don't understand so I'm
gonna give you a benefit of doubt and
assume it's a element a root element
that you're creating now if I go into
one level down a child element right
here and if I said language here for a
second
notice that became a child element based
on the context over here likewise what
we could do here is rather than calling
language over there we could say Lang
start each and then we could say key and
value now in this particular case this
clearly knows what Lang is that's a
variable we defined up here in lexical
scoping so it doesn't have to really
worry about what that is but when I put
the word language inside of this you can
see how it's able to create multiple
nested elements out of it now we could
of course say for example name and in
this case we could say that's the key
and notice how that became an attribute
value and then of course we could go
another trial level and we could say
author and specify yet another child
element inside of it so this shows to us
how we can't be extremely dynamic in
creating things now to create something
like this in groovy is pretty darn
simple
thanks to made-up programming so the
idea behind make meta programming really
is that we are really writing a code
that's very flexible in terms of what it
can do and how it can evolve and it can
figure things out at runtime quite
dynamically and that is exactly what
meta programming really is all about so
meta programming is an ability to really
extend the program and vocabulary in the
syntax of the language at one time as we
please as we make sense now I just
showed you one example of this here
another example of this is Gradle and
Gradle makes a really good use of meta
programming in terms of how it allows us
to write tasks and execute them so
Gradle is why another good example
Grails is another example of meta
programming and groovy grants wouldn't
exist if we did not have meta
programming and GUI so this is a very
important facility for libraries and
frameworks that thrive on the system to
be able to support this so as you saw
here I'm talking about things on writing
code I don't have any slides to show but
if you're interested in downloading the
code examples you can download them from
my website the download link up is up
here I will also post the download link
down below as well so there's no rush to
copy it right now well another thing
that you can do with meta programming is
you can create these so called ESL's or
domain-specific languages we'll take a
look at some examples of this towards
the very end and see how we can use it
so the question then is okay we saw an
example and a few discussed a few
examples of what meta programming can do
for us but how does it really work well
that's what we're gonna spend the time
on in the rest of the presentation and
look at a couple of different options
available for this to really be powerful
on use at the very start of this is a
class called a meta class now GUI has
what are called GUI objects
what's a GUI object a groovy object is
any class that's been compiled using the
groovy compiler so if you write a class
and compile it using Java compiler are
the other languages on the JVM it is
considered to be just a Java object as
far as GUI is concerned but if you take
the very code and if it's a syntax that
brewery can understand and even compile
it using the groovy compiler it simply
becomes a groovy object now the groovy
object implements an interface called
the groovy object interface and has a
result it's got a bunch of interesting
methods in it one of them is an invoke
method but really what really this gives
us is a couple of different interesting
things for one how do you really of
support meta programming where you can
inject new behavior into the code well
in Java we know that a class bytecode is
created and then we simply load the
bytecode and we execute it oftentimes
well in in programming we know one thing
that we can almost solve any problem
using one more level of indirection as
David West said so that level of
interaction is metaclass so in other
words in groovy when you call a method
it doesn't look up on the class or the
object to see if the method exists
instead it goes first to what's called
the meta class and says hey made a class
do you have this AR method if the mega
class has the method it executes that
method and only if the meta meta class
doesn't have the method it goes to the
original object or class and looks for
the method so in a sense you can pretty
much overwrite the behavior of classes
in groovy by putting the methods into a
meta class that gives you quite an
interesting amount of power on your hand
so how do we query for methods and work
with objects in this case of you know
meta programming so we're gonna look at
how do you find methods in this
particular case so let's say we have a
class called person and let's say that
person has a run method which takes a
value which let's go ahead and say is km
and I'm going to simply print out here
running and I'm gonna say km and then
say kms so I want to call this method
let's say the the run method so we could
say to find Sam equals new person and we
could have said Sam door
run and we could simply specify let's
say to to call that particular method
but imagine you are not aware of what
methods are available maybe the user
sends you a command of what method to
run and you want to pull that particular
method and execute it now we all exactly
know how to do this right we call this
job a reflection but if you ever use
Java reflection you know how it feels
right so you want to use reflection so
what do you do you go to the class class
and say get class and then you say get
method and remember what parameters get
method takes the first parameter is the
name of the method
and then comes the fun part you got a
pass to it an array of class objects and
by the time you construct this array of
class objects you lost every interest in
the code you are trying to do right so
that is called I will suck the life out
of your excitement kind of a pattern
right so a lot of times to me
programming is a series of light bulb
moments I'm coding away and suddenly I'm
like hey wouldn't this be cool and I
want instant gratification I want to try
that code right now and if I'm gonna
spend 15 minutes writing a code just to
make that simple step work I'm gonna say
you know what never mind I'll probably
try this after lunch and that never
happens well actually I was on a flight
one day and I was writing code with
groovy and I had an idea how I could
make this extremely dynamic and so I
said to myself you know what I could do
is I could say the class Sam and I could
say medic class and get made a method
and I could get a method out of this so
I could say equals and then once I get
the method I could say method or invoke
on Sam and maybe send it to to it but
the question is how do I really call the
get meta method to be able to execute it
well it's very simple I can pass the
name of the method as a parameter
obviously I don't know the method name
is run it's a variable but then how do I
pass the parameter it takes and as soon
as I thought about it I lost every
interest like losing a tap
right it's like I don't want to be
sitting there and writing an array of
classes and all this stuff it's boring
and it quickly dawned on me I was no
longer programming in Java
I was actually programming in groovy and
all you have to do in groovy is just
give a sample data and it's more than
happy to work with you so in this
particular case notice I just gave a 10
as a just a sample so what do you
normally do when you're working with
code you have a sample data on your hand
and you're trying to find a method that
would accept the data absolutely no
ceremony so by giving an example of
their data you're interested and it was
able to quickly pull the method that
matches the name you're interested and
the sample there are you provided on the
other hand of course if you were to give
something different than the acceptor
data for example our way
you can see that we got a
nullpointerexception because the method
doesn't exist at this point of course
you would do error handling for that and
deal with it so that is an example of
how you can quickly query and get the
methods so one of my favorite methods in
groovy is the get meta method method and
get a measurement that he's actually a
query on the metaclass and that easily
gives you access to methods available
and this not only will give you the
methods that are already there but this
also can give you methods that have been
injected or added during one time as
well so it's a very powerful construct
for us to use in groovy so we saw how to
you know query for methods but I really
want to access a method dynamically how
do we do that well if my method name
here is in a variable called method name
and I want to call this method every
groovy object has a method called invoke
method so you can call the invoked
method and send the method name and
possible data that you want to call so
that is an example of how you could call
methods but you don't even have to go
this far to call invoke method you can
simply say the class name and then
followed by a string and you provide the
expression of the
name that you are interested in and you
can call the method so easily as well
and this is again one of my favorites
and tax in terms of how we can call the
methods on objects simply provide a
double coated string with the variable
name as an expression and it's ready to
evaluate that method and call it so this
can i came to remove a lot of ceremony
when writing code you cut to the chase
and directly write the code you are
interested you are not sitting there and
fighting the language you are productive
getting your things done so this all
falls into the so-called Maeda class
that I talked about well metal class is
your friend when it comes to the meta
programming and we're going to see quite
a bit of this along the way as we use it
now of course one of the things we
normally do is we perform a opie now how
do you do it what does AOP aspect
oriented programming how do you do a ope
in languages like Java
well you normally would need a bulldozer
to do this right you would bring tools
like aspectj or aspect works and once
again you would lose interest along the
way to use it because it becomes way too
complex there is a reason why great
ideas are not common in usage because
the burden of using great ideas is more
than the benefit that we can even
perceive at that point so they don't get
adopted so easily but with what is
available in groovy metaprogramming is
AOP becomes extremely trivial to do so
normally when you do a ope you deal with
advices now there are three advices an
AOP well just like in real life real
life has three advices to write I call
them good advice bad advice an
unsolicited advice we normally get well
the case of AOP those are called before
advice after advice and even better
around advice you completely hijack the
call and do something else entirely so
you can implement these advices almost
trivially from within the classes using
meta programming let's go ahead and
implement the before advice for example
let's say we got Sam over here and we
could call the method on Sam to run so
I'm going to say Sam dot
1:10 and you can see it prints running
ten kilometers but before running the
run method I want to make sure off a
certain check maybe this is a security
check a logging check maybe I want to do
some other checks whatever that I want
to do how can I do those checks
well one trivial way to do that would be
to go modify the run method but that's
no fun for two reasons one is because
you don't want to touch every method
that you want to do some checks before
and second even better the person may be
a third party class written by somebody
else
you know in the world or it could be
written by somebody in your own company
and your dare not touch that person's
code there are some people like that at
work right you would never dare touch
that code so their code so it's a third
party code you don't want to touch it
it's not in your political reach you can
actually inject behavior into that so
let's take a look at how we gonna do
this I'm gonna say Sam dart made our
class you can see the metaclass
appearing one more time here and I'm
gonna say over here invoke method so we
are using a special method called the
invoke method I call the invoke method
the Maziar method because no matter what
you do it takes control right so the
invoke method is gonna get called and
notice what I'm gonna do here I'm gonna
provide it a closure I'm gonna say
string over here name and arguments that
I want to provide to this and notice at
this point what I have done here is I
have given it my little closer to work
with now within here I'm gonna say
running before and if I simply do this
and then I say define method equals and
we already saw how to do this a few
minutes ago I'm gonna say person that
made a class start get meta method and
in this case the method I'm interested
is the method with the name name and
arguments look at how beautifully that
fit in now because you're simply giving
a value that you already have you don't
have to go through the ceremony of
taking the values and figuring out what
classes they are you just give it a
sample and
could you please get this method for me
please and then once it gives you the
method I can say method dot invoke over
here on the object that is the context
object I'll talk about delegates a
little bit more later and then you pass
the arguments to it so if you look at
this particular code right now now that
we wrote the invoke method in this
particular case all I'm gonna do in this
particular case is to call this method
called get meta method and metal rather
merit method method so mera method and
so once we get the method you can see
running before we quietly intercepted it
so if you look at line number 16 that
method is completely the method call is
oblivious of what we just did we just go
to the object and call a method but we
did a before interception right there
and so we said I am gonna go intercept
the call do some pre operation whatever
it is that you want to do look at the
beauty you got full context of the call
on your hand you know what object it's
being called on what the name of the
method that's being called you also know
the parameters being provided to you so
you have all of that on your hand and
then of course once you do for example
you may even say let's say this is a Sam
that you really want to give a hard time
you can quietly say define km equals and
then you could say arguments zero and
then make him work a little harder and
then you can change that value quite a
bit in this case and then you can have
him run a little longer as well right so
you could do things like that very
easily by enhancing the object to run a
little longer so Sam thought he was
gonna run ten miles but it's sweating a
lot today because you just hijacked that
and did a pre-op on it so this gives you
that before advice quite easily as you
would prefer and so this is a way for
you to do some operations a or P
operations before but what if you want
to do an after advice rather than a
before advice well I'm gonna store this
into a result I'm gonna return the
result over here but I could do after
running and then we can do an after
advice as well as you can see right here
so that part of the code is running
after the other part of the code ring
but instead you want to do something
totally different for example there are
days when I really really want to run
but unfortunately that is the way I am
wired I would walk up to the treadmills
but along the way some thought would
come to my mind and quite suddenly I
would start coding on the way and this
is called the around advice right so
basically in this particular case we
don't have the real code at all I go for
a run but I end up coding instead so
that could happen as well this is an
around advice we can completely hijack
the real call and do something else
entirely different this can be a very
powerful marketing technique as well
among a lot of other benefits this can
provide for you so that is an example of
how you could use these different AOP
advices and notice how this is baked
into the language already so you're not
really spending effort learning yet
another tool and installing third-party
tools and stuff like that if you're
using groovy already all this is
one-stop shopping you already have it
available and readily useful for you on
your hints so I did use the word
delegate so it's probably a good idea to
talk a little bit about what delegate
really means and then relate back to
what's going on with metaprogramming
itself so to understand that let's go
ahead and define a closure called greet
and I've got a name over here and I'm
gonna simply say hello and then a name
right here for me to print it so now I
call greet over here I'm gonna send Joe
and you can see in this case it says
hello Joe as you can see in this
particular case now of course in this
particular example we know exactly what
name is on line number one that's the
parameter that's been passed to this
particular object so it's very easy to
see what name is however what if I were
to do something along these lines rather
than calling hello I'm going to simply
say to uppercase over here so if you
look at this code now notice that we
again can clearly say what name
yes name is the parameter given to this
particular closure but if I ask you what
- uppercase s the answer is we don't
have a clue right it's some random
function we are calling in here
well here is a nice interesting property
of closures and groovy that if a closure
encounters a particular method or a
property it doesn't understand rather
than failing it immediately runs over to
an object called a delegate object and
says hey delegate I just received a call
to a property or a method I don't
understand could you please help me out
with this if the delegate is capable of
handling it then the delegate handles
that prop radicular property or a method
and if it cannot the delegate may in
turn pass it onto its own delegate if
it's meaningful otherwise eventually
it'll fail well this feature in groovy
is extremely like a feature that's very
popular in JavaScript you know what the
feature is it's the prototype feature in
JavaScript so we essentially are using
the prototypal inheritance when it comes
to closures in groovy that's basically
what is available here so the delegates
act as a prototype for us to use so to
understand this let's twist this a
little bit here let's go ahead and say
force salutation and the salutation is
going to be in and I'm gonna say hello
and let's say howdy and now I'm going to
go ahead and say call the greet method
that we have here and it's gonna fail at
the moment when I run this and it fails
because it has no clue what to uppercase
really is and as a result it said sorry
I got a method that's missing but if I
say greet dart delegate equals
saturation notice that it's a very
different behavior now it all of a
sudden takes the hello given to it and
converted to uppercase so what's really
going on well on line number one when we
call to uppercase the closure said I
don't have a clue what to upper cases a
run
/ - its delegate on the first call the
delegate is hello and so hello is a
string and strings know what to upper
case is so it said sure I understand
what to upper cases convert Italy hello
- to upper case and returned it and the
delegate said thank you the closure said
thank you for that delegate and then
printed that and moved on and the next
time around it's exactly the same
closure but we modified its delegate to
howdy and as a result you can see it
says howdy instead of hello again in
upper case so this is a very powerful
concept as you can see well this is big
into closures already in groovy and
closures can the forward automatically
calls they don't understand to its
delegates now this is extremely helpful
when it comes to meta programming
because when you inject a method into a
class as a thank you the injection
process hands back a delegate to the
closure and the delegate is the instance
on which the method is going to run so
within a closure it's meaningless to use
the word this because that this refers
to closure so imagine for a minute right
you can come to me and say who are you
and I will tell you who I am but if I'm
in a business setting and you come to me
and say who are you I'm gonna most
likely tell you that I'm representing a
company that I've been delegated for so
in other words when you go to a closure
and say delegate it really says that it
is that this object of the class for it
it is running so within a closure don't
use the word this instead use the word
delegate right and the delegate refers
to the contextual object for which this
code is running you're gonna see this in
just a few minutes as we begin to use it
so so we saw the power of the delegate
over here and how we can use it very
nicely but I'm gonna step back here and
talk about two very fundamentally
different but very powerful concepts in
meta programming we've been kind of
slowly you know walking along the lines
of meta programming now it's time for
her to dive deeper into it and I want to
distinguish between two separate
approaches that groobie provides one is
called method injection and the other is
called method synthesis and Method
injection is where you go to an object
and you literally insert a specific
method into the object that I call as
method injection now Method injection is
so 20th century the real fun is in
method synthesis methods synthesis is
where you make up stuff along the way
that is a lot more fun so in other words
based on the current context of an
object its state and behavior and the
surroundings you can start producing
methods dynamically and that is called
method synthesis we're gonna learn both
of those techniques here we'll start by
talking about method injection first and
then we'll come back and talk about
method synthesis and see how we can use
it now in case of method injection you
can add methods to specific classes if
you are interested so for example let's
say we have a particular instance of a
string and I'm gonna call it as greet
and what let's say hello for a minute so
I've got a string called hello on my
hand and I'm gonna go to the string and
say shout this is like you saw a friend
after a very long time you don't go to
the friend and whisper hello you shout
hello right you're excited to see this
friend so I'm gonna shout hello and of
course when I run this code you can see
it failed because too bad JDK doesn't
have that excitement our shout method in
the string class but in in groovy you
never take no for an answer right well
if that method doesn't exist and you
feel it's important to have the method
so be it so what you can do is you can
go to the string class and go to its
medic class right
here and say hey I want you to have a
shout method for me please
and then you specific fight over here
what do you want to do to uppercase in
this case and as a result when you run
this code you can see it says hello all
in uppercase now you may look at this
and say wait a second what are we
dealing with we are dealing with the
origin of strength what in the world is
string and you will notice that it is
nothing but java.lang string and you
look at this and say wait a minute did
you just add a method to the sacred
java.lang string well the last time I
checked we live in a free country right
this other program so who stops us from
doing that so absolutely we took the
string and we added a method to it which
is called our method so we can easily
add methods to existing classes as you
can see and what is the benefit of this
to give you an example I was working
with an insurance company and while
we're coding we decided hey wouldn't it
be nice if we well you know let's sit
back for a second what do you normally
do when you want the function but that
function doesn't quite exist we create
this thing called the utility classes
right now you lick my utility classes
are so boring I have a feeling that you
delete classes get together in the night
and they cry right because they are like
oh we don't know where to put him okay
put them in the utility class right so
that is so babe
well what if we can do something a lot
better and write the code more
expressively so I was working for this
insurance company and we decided hey
wouldn't it be nice if we walk up to the
bait object and say hey date object ease
policy in effect and drop an insurance
policy to it and it would say yes or no
right
isn't that cool right so once just get a
hang of it you could be programming and
you have a date object on your hand like
a today's date or whatever date the
customer is talking about and you say
date dot is policy in effect parameter C
is the policy and bam you are done and
it tells you whether it's true or not
except for one problem very very likely
that we did not write the date class
right but there is a stop us from
writing that method so we just took the
date
and injected the method call is an
effect and of course within our domain
so this becomes really Oh capital e
within the domain and as long as you are
programming in that application you know
that that particular date can have that
method go ahead please right the
question is if I create a Java doc where
would I see the method you certainly
would not see it in the in either of
those places you would have to
separately create a documentation for
this but also you could square a series
of unit tests available for this rather
than a Java doc itself so that it's
easier not only to know what this code
is doing but how to use it as well but
but it wouldn't really go into the Java
doc per se unless you create an explicit
Java doc that would be a separate
standing Java doc but not certainly as
part of the original Java doc please
isn't that fun
well so so the thing is this right but
we gotta be careful about a few things
here one is the word accidentally we
should not let people work in isolation
that's one of the things we do long you
know our field right somebody comes
along they write a random method here
somebody else writes my method over
there well you gotta have a fairly
decent suite of automated tests because
we are playing with matches here you
definitely don't want kindergartners to
be playing with this right so we
remember Uncle Ben's word get great
power comes greater responsibility so
we're gonna have a very really good
suite of automated tests available and
if we do when somebody comes in you know
accidentally adds a method which is
pretty normal right you know I'm sitting
here encoding I just did not realize
there is such a method already I inject
a method my automated set a set of suite
will immediately fail I'm like oh darn
it somebody got to it before I could
they already have a method but if we
don't have the culture or the discipline
of writing automated tests I would say
this is the easiest way to fail fast
right we're gonna create burning hell
very quickly by doing this so that
discipline is extremely important I'm
glad you brought that up
yes please
I would say you want to whatever
injections you perform in the context of
your application you absolutely need to
have let me mister back you shouldn't be
writing any code without having a test
in the first place so as a result we
wouldn't be injecting the third party
code without having a test already so so
testing is extremely automated testing
and feedback is extremely important so
absolutely we would do that in that case
the other thing I would also say is that
you don't want people to arbitrarily
come and hack your system by adding
these things I would say that this is
something you would do more
collaboratively maybe a small set of
senior programmers who would be in
charge of injecting the methods in
collaboration with the rest of the team
rather than it becomes a free-for-all
and people keep hacking everywhere and
the third thing I would emphasize there
as you want to have a very defined place
where you would have these injections
because if you start injecting and
everywhere in the code it becomes quite
unmaintainable so I would have a
separate library or a separate packet
where only in the package Biello
injections so if somebody wants to know
what injections are already available
there is one good place to go look for
it so thanks me a question those are
some disciplines we have to really
enforce in improving it otherwise this
can become extremely hard to
meaningfully maintain please how does
this play with Java security model well
you know Leslie Lamport once said the
most secure system is the one that's
locked in a room with power turned off
right so so the point is it is really
not a violation of security any more
than what's already there because GRU is
not doing anything that was not possible
already right you already have tools to
do this Grube only makes easier to do
what's already possible so it doesn't
make it any less than what was there
already we have tools for a long time to
do it every one of what I'm showing you
here there's absolute nothing that's
been done here that's not doable already
except it doesn't burn and you doesn't
hurt you to do those things question
here somebody had a test yeah please
right so the question is is this similar
to extending a class so when it comes to
inheritance let's think about that for a
minute right so in the case of
inheritance you are developing a
separate class and then your derived
class have everything from the base
class but has a few more extra things on
the other hand what you're doing here is
it's very much like here's a backpack a
carrier on all day right and you come to
me and say hey can I have a change for
$10 please I'll give you a change from
my pocket but if you say can I have a
change for 10 euros please there's no
reason for me to have euros in my pocket
but I got some in my backpack I can
reach over and get it but in the same
vein you could replace my backpack and I
could be carrying a completely different
backpack tomorrow and it may have some
other stuff in it than what this
backpack carries it is the same vein kid
still but when kids behavior is altered
by the backpack he is caring so it's
unlike inheritance that's why there's a
prototype inheritance where by attaching
the prototype you are varying the
behavior of the object because it goes
through a prototypal chain of command
pattern if you will to identify things
so while inheritance is powerful it's
very rigid prototypal inheritance is
powerful and very flexible and very
dynamic good question again where does
it occur in the class loader it doesn't
so groovy says you go through your class
loading like you normally do when
everything is said and done it has a
separate entity called the meta class
so for example it say you are the class
let's say she is the middle class we'll
just load you up like everything happens
but when the call is made I would never
come to you and ask for your method I'll
go to your meta class and say do you
have the method and the meta classes yep
I do or no I don't and only then I come
to you so it's a level of indirection
that it goes through so it never messes
with what's happening in JVM but just
bypasses and has one more level of
interaction to do the checking so in
Java you normally invoke virtual to call
the method directly on the object here
you don't use invoke virtual you go to
the meta class and say here I run this
method for me please and the mega class
either runs it for you or forwards it to
the real object so it's a level of
indirection that it goes through yeah
absolutely
there is no boundaries whatsoever if
you're worried about security keep in
mind
encapsulation never ever gave us
security we've been fooled by thinking
we it does right so even in Java I can
show you within 10 seconds how to modify
a private variable right so all that
groovy does is it says let's not pretend
right you could already know this I'll
make it easier for you to do that's all
yeah absolutely so it's only a fear more
than what we have because it was no
worse are no better in Java already it
is this that just makes life a lot
easier that's all right that that's a
that's the entire point about this yes
please
when does it load that you are saying
well it's loaded as in this is the way
of life in groovy right so there's no
loading of metaprogramming
this is the way of life in groovy every
call you make when you have not turned
on static compilation every call you
make is loaded with metaprogramming 95%
of the time because you did not have a
meta programming in effect in the code
it bypasses and calls the real method
but this is just a way of life in groovy
there's no loading that happens that's
the way every call without sorry
compilation that's the way every call
actually happens yep does it kill
performance it does and the the thing is
this right we got to know what
performance really means right and
that's why I get a little you know
unsettling to me the word performances
so for example right if you ask me I
need a car that can drive at 200 miles
an hour I'm like that's great what I
gonna do with it I'm gonna drive through
the streets of San Francisco
no that doesn't cut it what you need is
a bicycle here most likely not a car
that rides at 200 miles an hour
so the question is if performance is
what is the most critical for you you're
looking at a wrong tool right so it's
really a combination of what are you
really trying to do there is a huge
amount of application area where your
performance is adequate what for what it
provides and you can enjoy the benefits
it provides at that point so that's kind
of where we need to really look at if
you're doing enormous number crunching
with it we have no reason for meta
programming in that layer right so in
that case you would write the code
either with static compilation in groovy
but honestly most likely will be writing
directly in Java for that I wouldn't be
using groovy in the first place for that
so yes performance is going to be poor
but I am very much willing to do that
because it's not poor it is called being
adequate right so that's a real question
we should ask is that adequate and if
it's not adequate this is not the choice
for us
right so so we are not there yet they
are they're still working on it we
should know when it is ready they are
working on it and the jury is still out
on what it is so it's a little too early
to comment on that okay so let's look at
a couple of different things here so
here I added one method but what if I
want to add another method call the
encrypted really good questions by the
way thanks for sharing those thoughts so
encrypt over here and what are we gonna
do in an crip well this is like your toe
hit the door you're gonna return let's
say that one right so stirred art
encrypt I'm gonna call that but notice
in this case we added two methods this
is a little annoying to see this
verbosity here well you can quickly get
rid of that as you can see here you
simply say shout right here and then you
can wrap those two into one common block
rather than providing multiple blocks
and so you can put a mirror class a
little closure and start injecting
multiple methods one sad thing over here
is I added a method to a class and
adding a method to a class generally is
a very bad idea because if you add
methods to class you are over reaching
so there are only two sets of people who
will add methods to classes those who
know exactly what they're doing and
those who have no clue what they're
doing right so as a result do not add
methods into classes it's a very poor
practice why am I so you know upset
about it and the reason is if you go
back and inject a methods into classes
it is visible in to the entire class
loader that you are using right so which
means in a web application it makes no
sense to do this your request comes and
I add a method later on her request
comes in I don't want her it was to be
polluted by your request it's got to be
independent of each other another
problem with this is if this makes
test-driven development really really
hard because remember one of the tenets
of TDD is that you want the test to be
isolated from one another
well you call one test that injects myth
into a class and that blows up every
other test after that is going to be
blown up right so it's better to inject
into objects rather than classes so
notice in this case I'm gonna say stir
to equals and I'm gonna say this is
going to be bi and I'm gonna print stir
to dart shout and notice that both of
those have the method in this case
because we added shout over here to
really the class called string I do not
want shout for string - I want shout for
string one so what do I do I'm gonna
simply replace the word string with stir
so now when I run this code notice that
it provided those methods for stir but
it failed the Forester - because stir -
no longer has the shout method so you
can inject behavior into objects
metaclass rather than injecting behavior
into class metaclass I call this a
civilised meta programming rather than
trying to inject into classes themselves
well that's great so far but I want to
switch gears to synthesis rather than
injection so what is the benefit of
synthesis you are adding domain-specific
methods to do classes like I said that's
great but synthesis is where the real
power is so what do you do with
synthesis you can call methods and if
you call a method that does not exist
then it can intercept those calls so if
I say for example Sam equals new person
and I'm gonna say Sam dart run now
obviously there's no run method in Sam
it failed now remember I mentioned
earlier about the invoked method and I
said the invoke method excuse me is
called mafia method because it takes
over all the calls we don't want invoke
method here because if a method exists
you want to go to that method but if a
method doesn't exist that's when you
want this feature so there's a special
method called method missing
and so you say method missing string
name and arguments and in this case I'm
gonna simply print out you called you
called and I'm gonna say name right here
now I call the method missing as the
mother of all methods it says if you
don't know what the method is come to
mama
right it's a very very giving method as
you can see so it takes on methods that
don't exist if a method was already
available you won't even go to the
method missing you go directly to the
method that's available well notice in
this case we use this method called
method missing and it's at you called
run well you probably have seen this
quite heavily being used in Grails you
can go to the gorg or an object and say
find by first name find by last name
find by email find by first name and
last name and those are all dynamically
synthesized when you call them that is
metaprogramming an action so how do we
really use this let's go ahead and take
a look at an example of this so to
understand how this works you play by
some rules and the plain rule that we're
gonna use either word play itself so if
a method does not start with the word
play I'm gonna reject it so notice what
I'm gonna do here define and I'm gonna
say in this case if name dart starts
with play I'm gonna accept it if not I'm
gonna say throw new missing method
exception on the name on the person
class with the arguments and I'm going
to reject the method if it doesn't exist
notice that run method was rejected
because the run method does not start
with the word play so we could do that
but in this case I'm gonna say play
tennis in this case and notice this time
around it is quiet because plate and it
starts with the word play but of course
I want to do some work here so what am I
gonna do well I'm gonna say define
activity equals name - play so this
gives me the real activity you are after
and I'm gonna go back here and say Sam
dot activities equals and I'm going to
define two activities Sammis in
trust @n tennis and of course football
so this is going to be very special to
Sam because Sam cares about tennis and
football so now I go to Sam and say play
tennis so we're gonna say activities
equals an empty array and in this case
I'm gonna say if activities start
contains activity then what do I wanna
do I want to do some work else I'm gonna
say print line
I don't play and I'm gonna say activity
so if you notice in this example we call
the play tennis but if they play
politics for example right so you can
see that Sam doesn't quite like to play
politics he says I don't play politics
so you can apply rules to decide what
you want to support and what you don't
want to support at the method name level
as you can see very nicely but I can
call play tennis quite a few times over
here and now I can go back to this code
now that it's an activity we actually
support I'm gonna say print line I like
like to play and I'm gonna say activity
so now when I run the code you can see I
like to play activity tennis but I can
also say Sam dart play football and I
can call this a few times over here so
when I run this code you can see this is
able to handle that as well but of
course if you say define Jo equals new
person and you say Jo dot play tennis
you can see Jo protesting I don't play
tennis because the activities were for
Sam and not for Jo so you can do very
method specific object specific
interpretation as well very nicely so we
came quite a long way to synthesize
methods but there is one side problem in
this code as you can see the problem in
this code is we are paying a very heavy
toll when it comes to performance and
what is the toll we are paying and the
toll is we are doing an interception
every single time
so for example I'm going to say
intercepting and I'm gonna say all our
name and in this case it says
intercepting play tennis intercepting
play tennis which is you are repeatedly
doing the same work over and over if
you're gonna be synthesizing database
calls you would want to synthesize the
call ones but execute it several times
each time for the call right because the
database is not going to change in
structure so often that data is going to
change more often than the structure so
you want to gain the performance of
caching rather than regenerating the
code over and over so what I'm gonna
show you here is a way to avoid this so
notice what I will do here I'm gonna
first of all come to this object and say
over here number of methods and I'm
gonna say here in this case Sam dart
metaclass dot and then methods dart size
and I'm gonna find out how many methods
the the object contains I'll just say
number : so I'm going to ask this after
each of the method calls here as you can
see when I run this it is 18 constantly
right it's got 18 methods that didn't
change at all now on the other hand
notice what I'm going to do here I'm
gonna get rid of some of these so it's
easier to see this so I'm gonna go call
play tennis just once and after I call
play tennis you can see the number of
methods is still 18 but instead what I'm
gonna do is I'm gonna go back to this
code right here I'm gonna say over here
implementation equals and this time I
will provide a closure where it takes an
object array we'll call it D orgs and
then I'm gonna say it right here
simply print line I love to play and
we'll say activity we could even say for
example width and something like the
args dart join so in this case I could
even implement a feature where I like to
play
tenants with James I like to play tennis
with you know Sarah I can have
parameters in so we can use that as well
now that is stored into a variable here
all I'm gonna do is simply call that and
invoke on the arguments we didn't gain
anything yet notice the number of
methods are still 18 but before I call
the method I'm gonna say person equals
let's say this person equals a current
object and this person d'art
metaclass well I cannot use the word
name here because the name of the method
is not named after all the name of the
method is the value in the variable
called name but we already saw hope to
get around that you simply put a little
dollar and put an expression on it
equals to impl and if you notice now the
number of methods in the class went from
18 to 19 so this is essentially where we
synthesized the method but turned around
and injected the synthesized method
meaningfully you would never do
synthesis without injection because you
would be wasting your time recomputing
when you don't have to so now if we go
back and run play tennis one more time
notice that all doesn't exist anymore I
can call play tennis any number of times
it has cached the method and
re-evaluates the method of course if I
do Sam dart play football now well that
method doesn't exist and as a result you
can see the interception going for that
now if you ask him how many methods is
gard you would notice it's 20 methods
now and no longer 18 or 19 because we
just synthesized to play football and
injected that method back into the class
so synthesis gives you the ability to
dynamically bring in methods at runtime
based on certain conventions that you
define Grails does this all the time
where Grails has defined the convention
methods we'll start with the name find
just like our method starts with the
name play and then they parse through
the method name to find out what your
database fields are they generate the
SQL command cache the SQL command and
then they evaluate it every time you
call the method that's exactly what
Grails is doing under the hood to make
that wonderful gorm facility work and
you will see a lot of these available in
quite a number of different places so
with all this given what can we do with
something like this so I'm gonna give
you one final example where we can
actually do something fairly interesting
with this I am gonna say over here John
over here is 10 Sarah is has 14 and Bob
has 9 and I'm gonna say winner if you
show this to somebody and say what is
this it is very unlikely they will look
at this and say it is groovy code right
it is a data file of some sort well
don't tell them you just say yep you are
right but it actually is groovy code now
we're gonna run this code well let's go
ahead and run it and sorry it didn't
work but how do we make this actually
work we're gonna take baby steps to make
this work so the very first thing I'm
gonna do here is let's comment out the
whole thing let's come to winner for a
minute well what does this look like
well for a person it looks like a word
but for a gluey programmer that should
look like a property name well you know
what a groovy property is it is backed
by a getter method and a setter method
sure we can do it then so all I'm gonna
do is define a method called get winner
and what does the get winner method say
define and I'm gonna say over here for
example I'm gonna simply say define
winner equals and let's go ahead and
define a winner somebody with no name
and we will say the value is going to be
no value zero for a minute so what I can
do now is I can simply say in this
particular case winner
is we could say winner s and then we
could say the winner darky as the value
and then I would say with score and then
we could say winner Dart it's a winner
Dart value well in this case of course I
want those two properties in here but
where do I get that value from let's say
players and scores over here max and I'm
gonna provide an entry and return entry
dot value as a result so we have written
the gap winner method which is using
what is called a player's and score
let's go ahead and define players and
score to be empty ArrayList so in this
particular case what I have done is I
have taken the players and score which
is empty a hashmap I come into the get
winner method so the get winner method
is going to be called when I call the
winner and it says I'm gonna find who
the winner is by going into the players
and score and I'm gonna call a max
method on it and that gives me an entry
and I'm gonna return the entry dot value
because I'm interested in simply
returning the biggest player in this
particular case right and then of course
when I'm done I would come back and
display the winner and specify who the
winners name is and then I could also
say what the score is by giving the
value of that entry for now I would
simply say winner is and I'll just
display the winner alone here we'll come
back and resolve that in a little bit so
so that is going to display winner is
now we don't have a value that's why it
failed a second ago but what am I gonna
do with this now so I want to implement
these methods well I got a great idea
we could implement a John method of Sara
method and a Bob method what do you
think no come on think of the positive
that gives job security right no we
don't want that job it gets boring so
we're gonna use the mother of all
methods for it so define method missing
string name and then we're gonna say
arguments and with absolutely no error
checking we're gonna say players and
score name
equals arguments zero so now what we
have done here is we have implemented
that code to produce the result we just
saw so now we could say winner dot key
for example to say who the winner is and
then we could say with score and then we
could say for instance winner dot value
and so that little code here can be
executed
it says Venera sara with score 14 so you
can write very flexible syntax of course
at this point is using other groovy
features to put that into a separate
file load that file into your running
code use groovy shell to evaluate it at
that point you're massaging the code
rather than using metaprogramming but
the crux of meta programming is write
that so what did we just do we
implemented essentially the variable to
hash map we implement the get winner
method and we implement the meta
programming method method missing to
synthesize these dynamic methods that
are being called you would obviously do
a lot of error checking here for this to
work but you can see the benefit that it
provides so we saw how this plays a role
in various number of tools and
techniques and so to me if you remove
meta programming I have completely lost
interest in groovy groovy the power of
groovy is actually in its meta
programming capability and this is where
the real fun is
and to me meta programming is extremely
important to have so I'm gonna summarize
this by simply saying the following pure
let's call this as meta programming the
mughals call it monkey-patching but in
any case I love meta programming this is
for the fun part in my opinion with
programming in groovy I hope you found
this useful thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>