<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Science and Art of Backward Compatibility | Coder Coacher - Coaching Coders</title><meta content="The Science and Art of Backward Compatibility - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Science and Art of Backward Compatibility</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/K55HcG1TJ2M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so today I'm gonna be talking about
backwards compatibility and just to give
you a quick sense so you can decide to
leave now if this is not your cup of tea
what we're going to be talking about is
two kinds of backwards compatibility for
each time we're going to talk about what
exactly we mean and and and why we care
about it and where we should care about
it the two types of backwards
compatibility the first is going to be
when sending data over the wire so we're
going to focus primarily on Java
serialization but a lot of the stuff
that will be talking about will apply
equally well to many other marshaling
strategies you know jack speed for XML
Jackson for Jason protocol buffers from
Google's take your pick the second part
of the talk will be focusing on API
design and what what to do when you have
a library that is being consumed by
clients that is going to itself evolved
and how you can do that in a way that
doesn't mess your clients up over time
in both cases we'll also talk about you
know not only how can you do these
things without breaking clients but also
what are some strategies you can use for
making sure that you're doing that
successfully so just a few quick words
about me I'm an application architect at
married genetics where we do DNA testing
to determine predisposition sort certain
types of cancer I've been working in
Java for about 14 years mostly on
large-scale projects and particularly
projects that tend to have a fair number
of libraries that depend on each other
and send data around between systems
I've been carpentry I blog and tweet you
probably don't care about much of any of
that so let's move on so starting off
with serialization why does it matter
whether we have backwards compatibility
well the first question is you know why
might you use serialization and the
answer in general there can be various
reasons but the situations where you
might use it and backwards compatibility
is really going to matter
distributed computing as a rule of thumb
there's lots of ways once you have an x
distributed computing I mean that
whatever it is you're doing runs across
more than one machine so whether you've
got a front end and a back-end server or
you have a mobile client talking to a
back-end server and all these sorts of
situations serialization or at least
marshaling and unmarked lling of data in
some form is going to matter so web
services you may be passing data back
and forth with you know something like
Jack's be rmi uses serialization under
the covers JMS if you use JMS one
convenient way to pass data back and
forth is with the object message type
which just uses java stuff all
serialization sometimes you're storing
data maybe just on disk or someplace
else to read back later distributed
caching systems usually take advantage
of serialization so things like hazel
cast coherence and so forth so a lot of
different ways that you might be taking
advantage of serialization perhaps not
even immediately realizing that you're
doing it so the question is why do we
need backwards compatibility we're
backwards compatibility basically means
that if I write out data in one version
of a client and someone else reads that
data using an RC one version of my class
and someone else tries to read that data
in using another version at the same
class that they will actually succeed in
doing so so the reason you might want to
care about this is that in practice in a
distributed computing environment not
every client that is to say not every
application can upgrade at the same time
now this is definitely the case if
you're in a 24-7 environment and you've
got you know multiple servers with fault
tolerant sealed you upgrade one server
than the next and so forth and in that
situation it's pretty obvious that you
can have two servers with different
versions of the same class talking to
each other at least for a little while
even if you're thinking you know this is
a major maintenance we're just going to
shut down the entire system and then
upgrade you may still have some
some places lurking around that are
going to have older versions of your
serialized data for example if you have
a cache that you're using and that
doesn't have to be recycled during the
maintenance then that's going to contain
old serialized forms if you're using a
JMS server and you didn't drain every
message out of the out of the system
before before shutting down then it
still has old messages in it maybe
you're saving certain configuration data
to a file on disk and reloading that
when you start back up all of these are
going to be situations where backwards
compatibility is going to matter so and
I guess just the other thing I'll say
again is you know that this really does
not just apply to Java serialization so
but that said let's focus for a little
bit on Java serialization and see what
it is that we need to think about as we
evolve serialize classes of course if
you don't ever evolve your serialized
class then you don't have a problem
because there's never going to change
there's nothing to be backwards
compatible with but that assumes you got
it right the first time you know and if
if that's you you're awesome but that's
that's not me anyway so how do we vote
serialized classes well the first step
is to write serialized classes so Java
makes this pretty easy sort of it
doesn't just make a tea old class
serializable you have to actually
implement the serializable interface now
if serialization had been introduced
starting in Java 15 it almost certainly
would have been done instead with an
annotation because the serializable
interface doesn't actually have any
methods on it it's really just a marker
saying I'm okay with this class being
serialized and Java wants you to say
that explicitly because there are
certain classes that you might not be
okay having serialized perhaps they
contain sensitive data that you simply
don't want being written out perhaps
they refer to things that are specific
to the JVM you're on right now like
threads and those don't naturally
transfer themselves so because of this
oh and one other reason is perhaps
you're concerned about maintaining
certain class and variants in
serialization can make
a little bit more challenging so the
first thing they do is they make you say
implements serializable but there's a
hidden trick here which is that this
only makes serialization work but if
this is all you do you will almost
certainly have backwards and
compatibility issues as your class of
bolts and the reason is that by default
java computes a serial version uid for
every serialized class and this is
computed by taking a look at a lot of
things about the class what its name is
its package those are some obvious
things but other things like what are
the variables in this class what are the
types of the variables and some of the
methods and so forth so really if you
change your class in any interesting way
the odds are the serial version uid that
java would calculate for you will change
and what that means is if you serialize
with version 1 and try to deserialize
with version 2 and version 2 has a
different serial version uid you will
get a I forget the exact I think it's an
incompatible class exception i'm not
sure but in any event you will get an
exception thrown which is probably not
what you want the way around this is to
declare a serial version uid it's simply
a private static final long and that's
what the JVM in that case we'll use
instead now if you've created a
serialized class it's out there in the
wild you now need to evolve it don't
panic you can run there's a serial
version or excuse me a serial ver tool
in the JDK that you can run on any class
and it will tell you here's the current
serial verb serial version uid that
we're using for this class so then you
can just paste that into your class and
and have that to stick with going
forward but if you remember to do this
ahead of time you can just use the
serial version you idea of one you do
not need to have different serial
version you ideas for different classes
this is really just a way of saying that
if this changes then don't even try to
be serialized me because something
horrible has broken hence the only
reason you would ever change this is
intentionally to break backwards
compatibility in other words you change
this if you want to be rude and you
don't want to do read I hope so going to
talk about a lot of different ways that
a serialized form of a class could
evolve and talk for each of these cases
and I'll go into depth on each of these
strategies for dealing with it so the
simplest things are adding a field or
removing an existing field you can also
change the allowed values on a field you
can change the type of the fields you
can move fields around in the
inheritance hierarchy and there's a
special interesting case for a news that
will also dig into a bit so the simplest
and probably most common case is you're
adding a field so in this and almost
every other serialization story there
are two situations to worry about the
first is the situation where the reader
is going to upgrade before the writer so
in this case what this means is that the
reader is now using a version of a class
with a new field food and the writer is
not sending that field over which means
that the reader needs to be okay with
the fact that foo is not present in the
serialized form conversely if the writer
upgrades first well in this case the
writer is now sending a field foo across
and the reader is looking at this and
saying I don't know what field this is
and so what this means is that the
reader needs to be okay with unknown
fields showing up and of course in the
worst case you actually could have the
writer and the readers sort of upgrading
ahead of each other in the sense that
you've got a distributed system and some
readers are upgrading some writers are
upgrading and you still have some old
ones of each in which case you have to
worry about both of these so the really
good news here is that Java
serialization handles this really well
and in fact jack's b jackson and many
other marshalling tools also handle this
really well and it's because the the
default strategy to take here is you
know if you tell me something that I
don't know anything about I will ignore
it and if you don't tell me something
about something i dunno about if you
don't give me the value for a field i'm
going to get that field a reasonable
default value so it pays to know what
the default value is in java for a field
the easy way to think about this is it's
the representation of you know however
zero gets interpreted for that field so
it's a numeric field well that's 0 if
it's an object reference the 0
equivalent is a null pointer and for a
boolean the equivalent of 0
from our sea days is false so a date
field generally is pretty
straightforward you don't have to worry
but there is one thing you do need to
worry about and that is semantic
compatibility and what that means is
that your class needs to behave well
when this newly added field is given its
default value and so in particular this
means that any new field should not
change the values of any existing fields
that you have and to see an example of
where this could go awry let's say that
we've written a dimensions package
dimensions class excuse me and this
dimensions class you know it's maybe for
a shipping company of large containers
and so we're measuring the length the
width and the height and in meters and
this this class is out there we're using
it we're sending data around and then we
get a request from some American
customers saying you know we really
prefer to do this in feet instead so
there's this various ways and think
about approaching this and maybe not the
best API choice but but one that you can
certainly engage in is to say alright
we're going to add a boolean flag use
metric and the fall for this flag should
be I mean if it's true then we'll assume
that these numbers here are measuring in
meters but if it's false will soon
they're measuring in feet so you can
kind of see what might go wrong here
because if you serialize something that
was in version one your your
measurements are necessarily interpreted
as meters and you send this over to
something that's reading it in his
version too and it doesn't see a value
for the muse metric flag the default
value is false so it's now going to
interpret these in feet so now all your
meter data is being read instead as in
feet and you know if you're NASA this is
how you end up sending a rocket to Mars
and just plain missing so do pay
attention to this normally you can avoid
this simply by more sensible API choices
okay removing the field is actually kind
of just like adding a field but in
Reverse and what that means is that
before where we talked about
the reader upgrading first well now it's
the writer upgrading first and vice
versa so if the reader upgrades first it
needs to say okay well I no longer know
about this field who that you're sending
me so I just need to ignore it and if
the writer is upgrading first that means
the readers not going to see about you
for few anymore because the writers stop
sending it in the reader will be getting
the default value so it's pretty much
the same story it's just it's just a
switch and as in the previous story you
also need to still worried about
semantic compatibility one interesting
note here is that if you rename a field
that's really removing the field and
adding another field because you know if
I had a field that was a string called
foo and now I have one called bar the
JVM has no way of knowing that I meant
for those to be the same thing so if you
think about makes perfect sense trust me
even if you don't think about it it
still makes perfect sense okay so that's
that's the simplest things we can do you
know adding removing field another thing
that can happen and this is a little bit
trickier is to change the allowed values
for a field so for example let's say I'm
writing a voting application and I you
know there's there's a person class of
over class and it's got an age field and
I have a restriction on the age field
that you have to be the age has to be 18
or greater and I'll throw an exception
if not and then suddenly you know
Scotland comes up to me and says we've
got this referendum coming up well they
would actually say we fought this
referendum coming up or something which
I can't even do but that they'll say
we're going to recommend coming up and
we want to let 15 year olds vote so now
i need to say all right new values are
allowed well if in this case i'm
allowing more values than i used to
allow that suggests that the reader
should upgrade before the writer because
otherwise what's going to happen is a
new writers going to send a voter over
with age 16 and the reader is going to
get that and it's not going to be
comfortable with that and you know what
our readers to get uncomfortable so
either it needs to handle unaccepted
values and sort of be able to make some
sense of them or just upgrade the reader
first conversely if you're going to
constrain
the set of allowed values then you
either want to upgrade what you
basically should upgrade your writer
first so that they stop sending what
values are no longer going to be allowed
now one thing you might be thinking to
yourself is well you know I can kind of
protect myself because I've got this
constructor and my constructor will if
it sees in the unload values it'll
either throw an exception to make sure I
don't run into some weird problems down
the line or it'll maybe do something
with those on allowed values to convert
them into allowed values but here's the
problem in Java serialization ignores
your constructors completely it's not
just that it says you know I need a
default constructor and I'm going to
call that one even though you've got a
nice instructor taking arguments it
doesn't use the constructors at all the
JDM completely bypasses them instead it
basically allocates a number of bytes
for the class storage and then it starts
filling them in with values so you need
to remember this in general with
serialization don't count on your
constructors doing anything for you if
you really actually need to do something
like that with serialization you're
either going to need to override how the
deserialization happens well you're
gonna need to override how it happens
and you can talk a little bit about that
later so a more extensive example of
changing the allowed values for field is
to actually change the type of the field
and basically you know that the easy
direction here is when you when you sort
of refine the type so this is basic
liskov substitution loose cough
substitution remember is the idea that
if a method expects something of type
foo and you send it something of a type
which is a child of foo that should be
just fine and the same thing applies for
serialization if you're if you're a
client if your reader is expecting
something to be of type java.util.date
and the writer passes a java java sequel
date which is a subclass of Java util
day that's going to be fine everything's
going to work out just fine on the other
hand if your writer is sending a
java.util.date and your readers
expecting a job a sequel date that's not
going to work out so well because you
can
casting until today to a sequel day so
generally speaking what's going on here
and this is kind of true of a lot of
these things but the reader needs to be
able to process what the writer is going
to send so this is fine but sometimes
life doesn't work out this simply and
sometimes we realize we want to make a
change of type that isn't a simple
subtype change so what do we do in this
case well what we can do is we can sort
of instead of changing the type of our
field we can add a new field with the
new type and then have the old field in
some sense forward to the new field so
let me let me give an example of this so
let's say we start off and we write an
invoice class and in particular this
invoice has an amount on it and we're
thinking you know amounts they could be
whole dollar so they could be you know
some fractional dollars so we're pretty
smart we're going to make a float class
because that's that's great and so we
have a getter and setter because we're
writing Java that's what we do and we
might think it's stupid sometimes it is
actually to be really helpful in this
case that we have it get her in the
setter because what's going to happen
next is that we're going to realize wait
a minute floats are awful for money we
just saw Joe Darcy's talk about floating
point arithmetic which hasn't happened
yet but will happen this today or
tomorrow I can't remember which but
anyway just seen that talk and we
discovered that rounding errors are just
they're all over the place with with
floats and you don't want that with
money so we're going to instead use a
bigdecimal well if flow doesn't really
cast to a bigdecimal or the other way
around so we've got a problem so what we
do is instead of changing our amount
field we're going to add a new field
called and that's going to be of type
bigdecimal now of course the new field
can't have the name amount because we
need the old field to stick around so we
have to think of a new name and mating
with an additional experience we've
realized a better name anyway and so we
contain the total amount but one way or
another we'll need a new name ok so so
far so good but if I send over an object
with a float amount the bigdecimal
amount of total amount field
not going to be populated and that could
be a problem so this is where we start
taking advantage of the fact that we
have getters and setters so first of all
let's say someone is still using the old
float amount and they're setting that
field well what we can do is we can say
all right we'll set the float amount but
we're also while we're at it going to
set the total amount field by converting
our float amount into a bigdecimal so if
you populate float amount in the new
version of your class you'll also get
bigdecimal for free you can also do and
you should also do this in the other
direction so you should have a set total
amount which populates both as well and
that way you can actually get
compatibility in both directions now I'm
not showing that second center because
screen real estate is tight and I also
want to show you an example of what to
do on the Gator side and the reason you
need to worry about the Gator side is
because remember serialization doesn't
use constructors or setters so we need
to deal with the possibility that what
happened was that we simply got
initialized with our float amount field
and our total amount field is empty
which means that if someone calls get
total amount we should look and see if
we have a total amount value know if we
do that's great but if not we'll fall
back to using the old amount field so
with this strategy you can effectively
migrate from version 1 diversion to in a
smooth fashion and and I should I should
emphasize here that you probably also
want to deprecate your set amount and
get them out fields are methods so you
can eventually get rid of the old of the
old float amount field so the next thing
you can do is that you can you consider
what happens if i am moving fields
around to my hierarchy so for example
let's say that i started off with a
simple person class that was
serializable and it was extended by an
employee class and sometimes employees
have names so I I put in a name field
there and then eventually I start
realizing you know I think all people
have names so let me let me fix that and
let me move up the name field into the
person class well this seems like a
perfectly reasonable thing to do and
you're your code will still compile with
that everything will still work because
the fields still there but there's a
small problem which is that from the
point of view of serialization these
have nothing to do with each other and
the reason for that is that in
serialization is not just the name of
the field that matters it's the class in
which it's saying basically you can
think of it as sort of that when it's
sending it across the wire it says all
right here's the person field or this
gives me the name field from the person
class and on the other side and they're
saying well that's nice do you have a
name field for this sorry the name hope
for the employee class on the other
sighs that's nice do you have a name
field for the person class because
that's all I know about they're not
considered related at all so if you do
this sort of thing recognize that
serialization is not going to work out
so well for you unless you go to some
extra work one approach again is to take
a strategy simpler to excuse me similar
to what we just did with the changing of
the type which is to have some getters
and setters which can kind of massage
the difference for you and leave the old
field around by the way I forgot to
mention this but in the example that we
saw with on the previous slide with the
forwarding field this is also a strategy
that we could have it arguably should
have used in the dimensions case where
we were changing from the possibility of
only metres two metres and feet so bear
in mind this strategy when you're
dealing with the situations where you
might have one field change the values
of others is consider adding additional
fields or methods instead all right last
thing I want to talk about as far as the
types of changes that we can have our
news and these are sort of a special
case and the reason there are special
cases because of how different
marshalling frameworks handle them
there's basically two options that
you've got one is that you can encode
the name of your noon and this is what
for example Java serialization does so
if you have it a pneum with constants
foo and bar and you send off evaluate
the ANU that's the food value it's
sending the string food
across the wire which means that if you
should refactor to later change the name
of your new inconstant to something else
that's not going to give you backwards
compatibility on the serialization front
the other option is that you might
change the order of your noobs in your
source code you think this shouldn't
matter I'm just sorting them in a new
way there are other marshaling
technologies such as protocol buffers
which send the value of the ANU of the
ordinal values 0 1 2 or 3 so if you
reorder then you're going to get a very
hard to diagnose bug because i'm still
getting a value but it's not what i
expected and i don't know what's going
on so what this means is basically if
you're going to have a seat well and I
nunes I believe are all is serializable
so if you're going to have it a new man
it's possible that it will get
serialized try not to do any
refactorings like this either changing
constant names or changing the order now
of course one problem is that sometimes
we use the names of our noon beyond just
in the Java code that we're writing
someone might say you know I need to
write a display function and this
display function it needs to show which
type of thing this is and my Anu has
this handy name method on it so I'll
just use that or maybe I'll just use the
two string method which defaults to the
name method the upshot is you shouldn't
do that you should always at least users
a news two string method which you can
override so that if later you decide you
need to change how these things are
displayed you're not stuck with now
breaking backwards compatibility on the
serialization front ok so we've talked
about a lot of different rules for how
to avoid backwards compatibility
problems in serialization and so now
you're set you can go out there you know
everything you need to do you just just
need to make sure that you never make
any of these mistakes and anyone else
working on your code never makes any of
these mistakes either sound good and I
ok maybe not so how do we figure out
when we get it wrong so the answer is
testing and there's a couple of
different strategies you can use here if
your main situation that you're going to
worry about is the situation where the
reader upgrades first and by the
that's a really good rule of thumb is to
try to design things so that the reader
has to upgrade before the writer it just
tends to be easier to work things in
that direction and if that's the
direction that you're trying to support
one thing you can do is you can say all
right let me you know every time I have
a version of my class I'm going to
actually serialize a few instances of
this class out to a file I'm going to
check that file into my source
repository and I'm going to have unit
tests which try to read those files back
in using whatever version of the class i
currently have if those unit tests run
into problems I know I've got a problem
so that's that's definitely one approach
you can use and that's an effective
approach it will only give you forward
compatibility in from you know in the
reader upgrades first but that may be
enough for what you want another option
is a lot harder to set up but gives you
a lot more flexibility down the road and
requires sort of less thinking about it
in each phase and that option is to say
okay when it comes to running my tests
i'm actually going to go out to my
artifact repository so think Nexus or
artifactory all the Nexus seems to have
the better swag at this conference is
nexus and what I'm going to do is I'm
going to use a class loader trick where
I load in an old version of the class
and have that serialize out and then I
load in another version of the class and
try to read it in and I can actually do
these in both directions I can use my
new version of my class write some data
out and have the old version try to read
it in you can basically set up a matrix
of any any you know like 1.1 should be
able to read 1 point 0 and 1 point2
should be able to read 1.1 1.1 should be
able to read 1.2 but you don't need
compatibility from 10 to 12 so you can
have this matrix of things that you need
to worry about and then you basically
keep that matrix up-to-date so if you
finally decide all right we no longer
have any serialized instances version
one out there and nobody's writing any
new ones we can drop testing for that
particular version we don't need to
worry about it anymore okay so you do
that and you discover you have a
serialization and compatibility and you
look at it and you start thinking about
all the different things we've talked
about and none of them seem to work and
you're you're thinking of shoot
you know I can't figure out any way to
get default serialization to do what I
want here well you still have an apt and
that is to do custom serialization and
deserialization and there's there's two
strategies here the first is if your
class overrides a private method read
object and I realize saying overrides a
private method is weird it's not
actually a method on objects you're not
overriding and its private anyway but if
you declare this read object method the
serialization framework and remember
they're already creating instances
without using constructors so they're
allowed to do anything it's going to
call this private method to read in from
an object input stream and and you know
populate your class and generally what
this what you're going to want to do in
your read object method is the first
thing you're going to do is you're going
to call the read fields method on the
object input stream this is going to
give you a object of type get fields and
get fields has methods on it where you
can say you know get me the value of the
integer field named foo or give me the
value of the object field name bar and
you can basically ask for each field
value in turn and then you can do
whatever you want with it so if the
field name used to be foo and now it's
bar you can read in the value of foo and
then write it out as bar you might also
want to look for a value bar in case
you're reading from a new version one
caveat here is that while it's easy to
use it's possibly problematic in
particularly large classes with lots of
fields the reason is that the
implementation of get fields what it
does is it first reads in all the fields
off the stream and it stores them in an
array and the array has you know for
each entry of the array says here's the
field name and here's the field value so
when you say get field of food it starts
going through the array and it says the
first element are you food second
element are you foo and so forth so if
you remember cs101 this is going to be 0
of n squared if you're trying to access
all the fields and a large sift you know
you've got a 100 fields that's gonna be
a problem but you may have other issues
if you have 100 fields so there's also a
corresponding object output stream and
it has a corresponding right fields
which has our put fields I think which
has a foot feels methods you do the same
thing on the
the creation side normally you won't
need to override both of these usually
one direction is enough but if you want
you can override both finally there is
also the externalizing interface that
you can implement and I won't go into
details on this but this gives you total
control over serialization and
deserialization basically at this point
you're dealing with a byte stream coming
in you're picking stuff off the byte
stream however you want so that's great
that lets you do anything you might say
the first field I send is always going
to be a version field and then based on
that I'm then going to proceed to read
things however I feel like one thing to
recognize though is that there are a lot
of tools out there that can read
standard java serialized data for you
and display it to you even if the tool
doesn't have access to the class that
the serialized data is an instance up
because usual serialization says okay
here's feel foo and it's a type string
here so you know I can just kind of
display this information for you fairly
effectively if you go to the external I
zabal route you're now abandoning all
convention these tools can't do anything
to help you so there's something to bear
in mind on that and obviously if you go
this route you want to have lots of
testing one other thing I'll mention
there is also something you can do which
is a read resolve and write resolve
method this is a strategy where you
basically let serialization do its
normal thing and then after the fact you
can make some tweaks you can even
replace the object that serialization
gave you with a completely different
object so if you want to do no class
changes at that level that's that's an
option okay so that kind of concludes
the serialization half of the talk and
before I go any further I want to ask if
there's any questions people have about
this half all right moving on so API
compatibility so this means i have a
library version 10 and then someone's
written code against first 110 and they
upgrade to version 1 dot one and they
should still be able to run without
having to make any changes to their code
or even recompile it hood and a very
suitable question is why is that even
necessary because they've already made a
decision to upgrade to the new version
of my library so they had to change
their name and palm to change the
version or Gradle build file or whatnot
why can't they also change their code
and and that's a fair question and if
the only consumers of a library are
applications that's actually a very fair
question the answer as they can but the
problem is that it doesn't always work
out quite that simply so let's say that
I've written a class to parse CSV files
comma separated values and I wrote this
class cuz I'm pretty sure no one out
there does this this is a need and thing
in the java space so i write this class
and because it's the only CSV parser out
there other people naturally start using
it so someone's writing a little library
that talks to the National Weather
Service and get some weather data back
and it is in CSV form so it parses it
out someone else's written a service
that talks to the San Francisco Transit
Authority and finds out what traffic's
looking like today that's also in CSV so
uses my library to parse it out so far
so good um and then someone else decides
you know I want to write a little app
that can recommend what you should do
for your commute this morning and so
obviously traffic day is going to be
important but if this is for San
Francisco you might want to take the
ferry so you probably want to know about
the weather to know if the water is
going to be too choppy so this is great
okay now back to the CSV parser I decide
to upgrade it with with a new feature
I'm now actually going to support quote
to my CSV files and but I do this in a
way that is incompatible backwards
incompatible and I think you know that's
okay my clients can upgrade and indeed
the the weather stats reader author
decides to upgrade and in fact they not
only upgrade to my new version of the
client they also adding some new
functionalities of their application
which is rather useful the traffic data
breeder author is busy she does not have
time at the moment she's got other
things needs to worry about so she's
going to get to this later but right now
she can't upgrade and now we get to the
commute recommender well the problem
with the commute recommender at this
point is commute recommender author
this new functionality that is in the
weatherstaff's reader library they're
stuck they can't use it because at this
point what's going on is if they upgrade
to the new version then the traffic data
reader won't work and if they don't
upgrade to the new version then the
weather stats reader won't work so at
this point you know what your your stuff
and so this is basically the problem
with with the backwards compatibility
and API is it shows up when you have
chains of dependencies instead of a
single dependency it's all very easy to
think about in single you know
application depends on library case but
when you have application depends on
library depends on other library and
really application depends on two
different libraries depending on the
same library this is where things get
really really sticky and the solution
here really the only good option is that
those libraries that people depend on
should be backwards compatible when they
upgrade so what does it mean to be
backwards compatible for a library well
there's there's there's a few different
kinds of meaning one is to be source
compatible and what source compatible
means is if I compiled successfully
against a previous version of your
library I will compile successfully
against the current version that's all
it needs there's also binary
compatibility which means if I compiled
code against a previous version of a
library and now I upgrade to the new
version my code will still link without
recompiling so this is this is not a
compile-time issue it's a little bit
more of a runtime issue and then there's
a third type of compatibility which is
called behavioral compatibility which
means that if i use your library and i
start using a new version of your
library things still work the way I
expected them to before so the third
version you know something like I have a
bank account app
and our library in the first version of
the library there's a method that gets
your account balance and then in the
second version of the library i say i'm
going to get your account balance and
also launch a nuclear missile that's not
behaviorally backwards compatible even
though it could be source of mine are
compatible so there's that so source
compatibility is fairly easy to get to
because the Java compiler is going to do
all sorts of nice things for us if you
decide to change the return type of a
method to be a more specific return type
wow that's just casting the compiler can
do that for us all the time and it does
so source compatibility is fairly easy
to get to it's not as strong as binary
compatibility and binary compatibility
is really what you need and the problem
is that it's easy to make a source
compatible change that is not binary
compatible and not notice and the reason
for that is the following you've got a
bunch of unit tests that you run I hope
and you change your library code in a
way that is source compatible and then
you run your unit test but before you
run your unit tests almost certainly
your build system is going to inhale
your unit test for you which means that
if there was any binary compatibility
you won't see it because before you ever
run your tests you recompile it so
source compatibility it's nice it's easy
it tends to be a siren call that lures
you to crash against the rocks so you
got to be careful of it and all of this
really raises the question what is the
difference between source compatibility
and binary compatibility and to really
understand that we need to take a step
away from job because Java is about
source code and we need to start
thinking about Java bytecode that's the
JVM so we need to understand how the JDM
thinks about method calls and there's a
couple things it does that you haven't
looked at it before you probably
wouldn't suspect the first thing is that
for an instance method there's actually
two different ways to call an instance
method in the JDM one is through an
opcode called invoke interface it uses
this if it's invoking a method on an
interface but if it's actually a method
on a concrete
then it calls invoke virtual reason
being that for invoke virtual you can do
a quick dispatch look up in the class
tableware invoke interface you have to
do a little bit more work to figure out
exactly which method to dispatch to the
second thing that you might not expect
is that whether you're calling invoke
interface or invoke virtual the JVM
specifies very precisely the method that
you're calling it says the method name
it says how many parameters to take it
says the types of those parameters and
it specifies the return type of the
method as well and unlike the Java
compiler the JVM does not do any sort of
conversions type conversions when
looking up these methods so let's just
take a look at an example here let's say
I've written so this is not like oh this
is Java code let's say I've said you
know I want to create an array list of
strings and and then I'm also going to
declare in a variable list of type list
and assign that to the ArrayList
variable so this is a type interface
declared type interface array list is a
declare type of the class array list and
then I call add on my array list and I'm
going to also call size on my list so
the bike code for the add method is is
what is it doing its saying okay well
first of all I need to load the constant
string X don't worry about that and then
i'm going to call because ArrayList is a
declared type array list the class which
is a class it's going to call invoke
virtual and it's going to call the
method add and if you look at the
signature here you'll see add it takes
in something of type object I know we
said as a type string but there's a
ratio so it's going to take in an object
and then it also has a Z at the end
which everyone should know stands for
bullion I think B stands for bytes so
they took the next best letter so anyway
it's so it's your calling a method that
is explicitly expecting an object and
and is returning a boolean so as long as
you have something that is of object
type you're fine but you need to also be
expecting that billion to come back
if I call list sighs well now i'm going
to call invoke interface because list is
of a declared type java.util.list which
is an interface and in this case i'm
calling the method list size which
doesn't take any arguments and returns
an int now I can call list size and say
I want to return I want to assign it to
a long and if I do that in Java that's
fine the Java will do the necessary cast
conversions for me the Java compiler
will but the JDM is not going to be
nearly as forgiving okay keep that in
mind as we start talking about the
various things we can do so the simplest
thing that we can do in adding a
evolving api's to add new methods and
this is almost always fine you can add a
new method to a class and you should be
fine your clients clearly weren't
calling the method before because it
wasn't there I mean unless they were
using weird reflection to see if a
method existed and so forth call it and
oh if let's do with that you're going to
be fine you do need to be careful about
one thing which is the possibility that
someone might have extended your class
and already declared a method with the
same signature as the one that you're
declaring now which means that their
method is now overriding your method and
you need to hope that there is behavior
compatibility so the classic case here
is that you start off with an artist
class and the artist class has a method
paint and then someone extends it with a
class named artistic gunslinger and the
gunslinger has an additional method draw
to pull out his gun and shoot at someone
and then you upgrade your artist class
to include a method draw which is
supposed to paint a pretty picture and
you call that method and suddenly
there's a big problem at the Museum so
be careful about that case you want you
want to think about and one way to avoid
this is effectively just you know I
don't have real generic method names try
to make it specific enough the odds of
collision drop if you're talking about
libraries that are maintained within a
company you can go a step further you
can actually take a look at what classes
are implementing if you can access your
source code repository
story what classes are extending your
class and make sure you're not going to
run into problems interfaces similar
situation it's fine to add a new method
to an interface as long as clients
aren't implementing the interface
already if they are you could run into a
problem because someone could take a
meth an instance of one of your client
classes that implements your interface
and try to call this new method and get
a no such method error but it's not
necessarily a problem so another
interesting fact about the JDM JVM
verifier checks a lot of things but one
thing it doesn't check is when you say
hey I implement the interface list it
doesn't check to see that you actually
implement any of the methods and lists
so instead it just assumes you're
probably fine and it's somewhat ever
tries to call a method on list say the
size method then it will say okay let me
find the size method and if it can't at
that point and only at that point we'll
throw an error Java has used this for
years in the way that it's upgraded the
Java x sequel interfaces if you've ever
paid attention you'll notice that in new
versions of java the java x equal
package adds more methods to its
interfaces and it can get away with that
because basically it says you know look
we know that maybe the my sequel in a
driver isn't going to immediately
upgrade and implement all these new
methods that's fine just don't write new
code calling these methods these new
methods if you're planning on using the
my sequel driver until they upgrade so
you can use that strategy to you just
need to be careful to make sure that
you're not putting your clients in a
situation where they might end up
calling the method that hasn't actually
been implemented yet now of course
starting in Java 8 we got a new trick to
play with and that's default methods if
you want to add a new method to your
interface and it's a convenience method
meaning that it is something that you
could have done with the existing
methods in the interface and a little
extra work you can now do this so for
example if we had a person interface and
we had a get height in feet method and
then we decided in version 11 you know
we should really also provide the height
in meters well we can add that meth
to our interface and not break anyone by
providing a default implementation so
this was primarily added to support
adding new interfaces excuse me new
methods to the collections API in Java
to work with lambdas but you don't just
have to wait for someone like Marco
Reinhold to add it to one of his classes
you can do it for one of yours too it's
perfectly legal ok so that's the case of
adding methods obvious next question is
what about removing methods this tends
to be a little bit trickier because of
course well if none of your clients are
calling the method then you just need to
make sure you're not calling it you're
fine so again if this is an in-house
library for a private company you can
probably figure that out and be ok but
if it's an open source library who knows
how your methods are being called or if
you've got a big company you might not
be able to figure this out so in that
case removing methods is a little bit
dicey so the best practice is before you
remove the method give plenty of warning
you want to deprecate the method and
when you deprecated it you should
ideally tell people what to do instead
in the Javadoc so they're not just sort
of wondering you should also say in your
Java doc you know this isn't just a nice
theoretical deprecation this is actually
going to go away as of April 2016 so you
give people advanced warning and and
then at that point it's up to them to
actually be watching the warnings on
their compilation notice they're using
deprecated methods and switch over
conversely incidentally if you are a
user of a library and you find yourself
suddenly calling a deprecated method pay
attention to that unless of course the
library is the JDK which never removes
any method like Fred stop from 10 was
deprecated in 11 and I don't think it
will ever go away now this is where we
start getting back to the stuff we were
talking about earlier with how the JVM
calls methods if you change the
signature of your method that is the
same as removing it from the standpoint
of binary compatibility know if if mark
reinhold were to say you know lists
they're getting kind of big
days I think the size method should
start returning a lawn then all the code
out there that's been called that's been
compiled to call the list interface
method size that returns an int will now
fail because there is no such method
anymore it's just the method returning
wrong so this poses a real challenge
because it's not unusual that we want to
do things I mean changing from into long
is perfectly source compatible but from
a binary compatibility standpoint it's
it's a disaster fortunately there are
some techniques we can use in this
situation when we want to evolve an API
that would in ways that would be source
compatible to also make the change
binary compatible so the simplest
approach is when you're changing
parameter types and the good news here
is that for better or worse java
supports method overloading and what
this means is that if i had a class that
was declared to take a parameter of type
java and i now want to change it to take
java.util.date well if i just change the
method i'll break my clients or at least
my binary clients but what i can do is i
can define a new method that takes
java.util.date with the same name leave
the old method around have the old
method simply forward to the new method
directly so that I have no complete
behavioral compatibility of no surprises
there it's worth mentioning that I might
actually instead want to create a
different method name and deprecated the
old method and start encouraging people
to switch to the new method and the
reason for this is that if I have any
clients which were calling my method
that took a java sequel date and those
clients were actually passing in a
declared a type that was declared to be
a java sequel date when they recompile
against the new library the java
compiler is going to say ok i have two
options i can call the java.util.date
version or the java sequel date version
the java sequel date is a more specific
map so i'm going to call that one which
means that their new compiled code will
still be binary incompatible with any
library that removed
that method which means I have to keep
that method forever so if you actually
want to be able to get rid of the old
method signature you might instead of
wanting to overload actually change the
method signature okay that's parameter
types return types are a bit trickier
remember the JDM when it makes a call
its specifying not only the parameter
types of the method but also the return
type of the signature so that has to
match too and you can't in the Java
language overload on return type only on
parameter type this kind of makes sense
because if you overload on return type
how do I know which of your methods to
to link to if I'm the Java compiler but
the JVM remember the JVM that
restriction wouldn't make sense because
the JDM is already expressing explicitly
which method to call so it shouldn't
care if you have multiple methods with
the same name same parameter types with
different return types and in fact it
does allow it and the Java compiler will
do this for you behind the scenes when
you do subclassing and when you change
the return type on an overwritten method
in your sub class so let's take an
example here let's say I decide to write
a new exception class called self caused
that will always return itself when
asked for the cause I'm doing this
because I like to mess with people that
like to show the cause on their stack
trace and keep drilling down I like to
give them stack overflows of the
ultimate cause so because I'm returning
myself when I call get cause I can
instead of saying I returned throwable
which is what the original throwable
interface declares as the return type
forget cause i can say i'm going to
return get cause as self cost so what
does the job at compile agree well the
first thing it does it says okay so i
have this get cause method and all that
does is load the reference to myself
returning done but i know that there
might be code out there treating me as
an instance of throwable expecting there
to be a good cause method that returns
throwable so i'm also going to make one
of those and what that one's going to do
is it's going to simply call my actual
new get cause method and then return it
and it's a self cause which is a
throwable so that's fine
it also marks this method as synthetic
meaning that at least some reflection
tools will be smart enough to ignore it
saying this isn't something the user
wrote this is something I added to so
that's great the Java compiler can do
this for you but it won't let you do it
yourself for other situations so if you
can't do it what can you do well you can
trust the fact that coast k can so Costa
Cal Gucci he's the creator of Hudson
since named Jenkins she's now cloudbees
really smart guy he has this habit of
doing things that are called the project
of the day he's working on something he
runs into a problem he knows how to fix
it he starts fixing it and then realized
this Gus you know why don't I just
package this up an open source project
blog about it get it up on maven central
publish it and then you know the day is
done and we want my next project so one
project of the day that he created was
bridge method injectors and what this is
is an annotation process or combined
with a maven plugin and it gives you the
ability to create methods that are
overloaded on return type so let's see
how this works let's see in version 10
of my class I have a get food to get bar
method helpfully returning types of foo
and bar respectively and now I want to
about my class I won't get food and now
return actually something of type food
child seems like a perfectly reasonable
thing to do but we know it's going to
break binary backwards compatibility so
I pulling the bridge method injector
project and i say i'm going to annotate
this with the with bridge methods
annotation and that takes in a value
which is a class i say in this case the
type is food class and what this will do
annotation processor will kind of note
it's there and then the maven plugin
will do some bytecode manipulation on
your class before it's put into your jar
and saying okay the actual version of my
class it has the gift foo method that
returns food child and then it also has
a get foo method which returns foo and
is is simply calling the other one so
it's doing the same thing the compiler
would have done for you in the in the
override case but it gives you control
over it in fact you can also do a little
bit more if you had a method get bar
which returned bar and now you want to
return a parent of type bar well of
course in general that's going to
violate liskov substitution but if you
know
that any situation where people use to
expect it to be of type bar specifically
you're still returning something of type
bar but another case is a more general
type you can use the Brutes method
injectors class in this case you just
need to say one additional thing which
is that it needs to perform a check
cashed it needs to actually explicitly
cast the bar parent type to a bar and if
that cast fails with a
classcastexception but you just need to
make sure you avoid that okay class
hierarchy what do you do when you change
a class hierarchy well it's always fine
to add to the list of implemented
interfaces that's never going to break
anything it gets a little trickier when
you start talking about changing the
inheritance hierarchy so what your
superclass is it's generally fine to add
something into the inheritance hierarchy
but you need to worry if you effectively
remove a superclass direct or indirect
from your inheritance hierarchy this is
going to be a problem if any of the
following happen one is that you have a
client which is trying to cast an
instance of your class to the superclass
of course that cast will now fail you
also need to worry if there were methods
defined on that super class that clients
were calling on your class if you don't
implement those methods yourself
obviously that's going to be a problem
as well one way to get around it if you
need to is you can you can add those
methods directly to the child class same
story pretty much applies to removing
interfaces you need to make sure that no
one is referring to you as an instance
of that interface final change that you
can do is you can decide to change a
class to an interface or the other way
around and when I say you can do this i
mean you can do this but it is not going
to work out so well and this goes back
to the fact that there are two op codes
for invoking methods there's invoke
virtual and there's invoke interface
neither one works with the other mean if
you have an interface today and you
change it to a concrete class and you've
got code trying to call get foo with the
evoke interface method that's
bail likewise if you had a class and
people were calling get food with in
both virtual and now you're replacing
that with an interface that's also going
to fail so the upshot is when you're
designing a pis think very carefully
upfront about whether you want to be
using an interface or a concrete class
because that the decision that you
cannot change easily or really at all
without running into trouble yeah
there's just not much more to say than
life is sad i mean if you're an
interface you want to switch to a
concrete class make an abstract class
which all your concrete classes can
inherit from but keep the interface
around ok so as before we can be perfect
and immortal and never make mistakes
though if you're immortal you're
probably going to make more mistakes
because you're living longer or we can
figure out a way to figure out when
we've made mistakes so the answer here
again is is one approaches is testing
and this is a little bit tricky because
what this effectively name means is that
you need to load in old versions of your
load in old clients and try running them
against new versions of your class which
may be fairly straightforward if you've
got the old clients sitting around in
your artifact repository it may require
some class loader tricks it depends
there are ways to do this it's a little
bit time-consuming to be very effective
I by the way also recommend this
strategy if you have a web service and
you have clients compiled that are
designed to work with a person you can
web service try running those old
clients against new versions of your web
service for example that will that will
show you some problems sometime before
you hit production which is a bad time
to find anything out there is another
option there's an open source project
called whatever that word gets
pronounced as clear maybe I'm not sure
and what you do is you point it to two
versions of a library and it tells you
all the differences between them and it
kind of breaks them down into warnings
and errors of just casual information in
particular any change that is binary
incompatible will be flagged as an error
so if you're getting ready to release a
new version of your library you can set
the clem maven plugin or the Gradle
plug-in are amp plug and however you
want to compare the
version with your existing in the wild
version and report all the differences
you then look at this and first of all
if you see anything that can cause a
binary compatibility you now have a
chance to fix it it's also kind of nice
because you might notice oh yeah I added
that method i should probably document
that in the release notes because people
might and i don't want to use it okay so
the last question is what do you do if
you have to break compatibility well the
answer is easy don't and so you're
saying yeah and that's nice but no I
really have to add it and to which I say
really you know ask your colleagues ask
your friends ask your mom ask somebody
is there any way that I can do this
without breaking backwards compatibility
get together start thinking about it
there's almost always I mean I have
almost never seen a situation where this
couldn't be done where a change couldn't
be made in a backwards incompatible
fashion so try to figure out a way but
in some cases you're going to discover
no really can't or at least it's not
worth the trouble and so in that
situation first thing you should do is
change the major version number of your
library there's a project called
semantic versioning that gives you ways
to it provide strategies and it says
that you know if you're ever making
backwards incompatible changes the major
version number should change another
thing that you should do and I strongly
recommend doing this is to change the
name of your library so that it's a
different maven coordinate and repackage
your library into a different package so
what that basically means that people
can have the old library and the new
library sitting side by side the Jackson
folks that's a library for JSON do
serialization they did this they decided
they wanted to redo the API in a non
incompatible fashion and they were
polite enough to do this in a way that
allowed people to you know gradually
migrate their code over summer going to
use the new AP is in the new package
some of it will use the old api's in the
old package no problems so if you're
going to make that change do it on the
other hand if someone does this to you
there is a package out there called Jar
Jar links that you can use to repackage
their library into a different name
space ASM used to recommend you use this
but it's kind of
need to do is so try to avoid making
your customers or your clients do that
and I apologize with just about at a
time but thank you so much I asked that
you fill out the session evaluation
forms those are very valuable to me if
you want slides that's my SlideShare
account it's my first name spelled
backwards in my last name spelled
backwards otherwise don't delete
gibberish and I think we're out of time
but I'll still take questions as long as
nobody tells me to stop I was that clear
I don't I don't buy it now bye well then
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>