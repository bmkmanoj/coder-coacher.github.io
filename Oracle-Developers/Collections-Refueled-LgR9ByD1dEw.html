<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Collections Refueled | Coder Coacher - Coaching Coders</title><meta content="Collections Refueled - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Collections Refueled</b></h2><h5 class="post__date">2016-09-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LgR9ByD1dEw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello good afternoon welcome my name is
Stuart marks I work on the JDK core
libraries team at Oracle and this talk
is collections refueled so here's a
quick talk outline I'm going to talk
very briefly about the history of the
collections just to give a little
perspective here not a not a very
detailed long ranging history then I'm
going to talk about Java eight
collection enhancements and Java nine
collection enhancements probably 40% of
the talk is going to be about eight and
the rest is about nine I'm kind of going
over eight because people are still
transitioning to eight but there's a lot
of stuff that went on the collect in
collections in Java eight that might
have been overshadowed by the the top
line features in a like lambda and
streams and finally I'll close off with
just a little bit of information about
what we're thinking about for future
collections work beyond Java nine so I
have a Twitter hashtag for this talk
it's collections refueled I'm not going
to be taking questions on Twitter during
the talk but if you have follow-up
questions or comments I'll be looking on
that hashtag and and I'll respond on
that okay 20 years of collections on one
slide so as as you probably remember
Java's 20 years old now the collections
framework proper is not 20 years old but
the initial JDK 1.0 had what I'm calling
the legacy collections namely vector and
hash table and so forth in and those
those are twenty years old at this point
now the actual collections framework
wasn't introduced until a couple years
later in JDK 1.2 so they're actually
also pretty old so they were introduced
in 1998 which means they're 18 years old
now and quite frankly I think they've
done quite well I think maybe you tell
me otherwise but there's this basic set
of interfaces collection lists at map
iterator and so forth and concrete
classes ArrayList hash map and so forth
still in daily use today and still work
quite well they've been re implemented a
few times particularly hash map but I
think they've they've survived quite
well and you know let me know if you
think that's true or not a big upgrade
was in Java
se5 in 2004 when generics were added
that that made it was a huge change in
program ability of the of the
collections of course that was a
language change that was for which the
collections framework was the primary
consumer and also the addition of the
java.util concurrent package which
introduced the whole set of thread-safe
and concurrent highly concurrent
non-blocking collections and then I
think this is also easy to forget
because because there's a different set
of implementation classes that were in
dribbled into different JDK releases
that are not talked about very much in
particular things like a ray deck
priority queue the enum enum set a new
map and so forth they're fairly
specialized but in particular array deck
I think is one of the more underused
collections and in fact is very very
useful all right so that's just the
overview I'm just going to dive right
into Java eight here so as as many of
you familiar with Java eight top line
features were lambda and streams but the
most common stream source I would say is
collection and the most common stream
destination that you can send send
results to through a collect door is a
collection so while the lambda n--
streams are not really actually part of
the collections framework streams really
does provide a lot of power for
transforming collections now the the the
features that were added collections
that are easy to forget about and then
were overshadowed by lambda and streams
were a set of default methods that were
added to the collections interfaces and
so a default method is a language
feature introduced in Java 8 that allows
us to add methods to existing interfaces
without breaking compatibility and so
certainly things like converting a
collection into a stream that that
that's a default method okay but there
are other methods that we introduced on
the collections interfaces that provide
a lot of power to all of the
pre-existing collections so without
actually adding much if anything to the
existing collections by adding these
default methods to the interface
is the programmability the collections
across the board has been enhanced
greatly so iterable collection and list
got a few methods which I'll run through
quickly and map and comparator got quite
a family of methods and so I will talk
about I will go into I'll have some some
more detailed examples for each of those
alright first one is iterable dot for
each basically if you have a function
that you want to that you want to call
on each member of a collection instead
of writing a standard enhanced for loop
or the for each loop is it's sometimes
called you can simply pass it a lambda
or method reference list dot for each
here so this method actually appears on
iterable and collection is a sub
interface of iterable so every
collection every collection
implementation inherits this so
sometimes people miss this because this
is all the way up on iterable and people
don't look at it herbal very often
because it's not all that interesting
the only thing you know it used to be
the only thing you could get from an
iterable wasn't iterator but in fact
we've added this new for each method to
iterable as well so that's useful so
it's pretty simple but you know
sometimes it comes in handy so another
thing on me actually this is wrong it so
the the iterator interface if you have
ever implemented an iterator you've
always had to if you didn't want to
support removal you had to override the
remove method and have it throw an
exception so we add a default method
that throws this exception so it makes
it easier to implement an iterator
because if you don't want to support
removal you don't have to do anything
you inherit the default method and it
throws the exception for you now if you
do want to support removal you just
override the remove method just like you
always did so so this is just a little
convenience thing now the funny thing is
you know we thought this was going to be
a great feature in java 8 because we we
added this Oh what will be wonderful we
can write iterators without having to
worry about remove anymore but it turns
out we don't write iterators anymore we
always write splitter raters so anyway
but it's useful if you use iterators
makes things
little bit easier all right so this one
is a little more interesting there's a
new method on collection called remove
if and so if you ever wanted to iterate
over a collection now instead of using
the enhanced for or for each loop you
you can't modify the collection if you
use that loop what you have to do is you
have to you kind of fall back to the the
long form for loop and get an iterator
so you have to kind of go back to that
old style because you actually need a
reference to the iterator in order to
call the remove method on it so the top
half of the slide shows the Java 7 idiom
for that if something meets matches some
condition then you call the remove
method on the iterator and in Java 8 all
you do is you write a lambda expression
that has that condition in it and then
you call the remove if method and it
applies that predicate to every element
in the collection and removes the ones
that match now there's an interesting
interesting little wrinkle here if the
collection is an ArrayList the standard
Java 7 ATM has order and squared
complexity and that's a little hard to
see but if you think about what
ArrayList has to do is so first you
unavoidably have to visit every element
in the collection so that's order n
right there but in an ArrayList if you
remove an element from the ArrayList
everything on the tail of the array has
to be shoved up one one space but the
ArrayList so that's what the remove
method does but the remove method
doesn't know that it's in the middle of
a loop where more things are going to be
removed so it potentially has to do a
bunch of extra copying and in fact it
has to do order n copies for each
removal so it's really order M times n
but if you're if your predicate is at
all related to n then it basically boils
down to order N squared so in the remove
if implementation we have ArrayList
overrides it and provides a more
advanced implementation it knows it's
going to visit every element and so it
has a faster path and it basically can
do the entire remove if operation in or
and in fact if you go look at the code
now it works well but actually they're
even further optimation optimizations
that can be applied but still it remains
at order n okay there's another there's
another default method we added on the
list interface which is replace all and
so this invokes a basically the use case
is you want to visit every element and
replace it with potentially replace it
with something else and so in Java 7
there are a couple ways to do this you
could use a list iterator and use the
list iterators set method and so here's
an example of converting every element
in a list of strings to uppercase or you
could if your if your list what if you
wanted to index you sorry if you wanted
to access your list by index you could
do get and then call something on it
then set it back into the same location
in Java 8 you can say replace all and
that lambda expression is applied to
every single element and replaces the
one it was called with now the
restriction on this is that you cannot
change the type of that element so you
can only replace list elements with
other elements of the same type and so
if you want to change the type you
really need to copy that into a new list
and to do that you have to use a stream
and so actually when I was writing the
slide is that you know here's the the
standard list iterator idiom how many
people use list iterator Wow not very
many people less than five hands okay
well it's interesting because listed
orator is a way to use an iterator idiom
and it has a bunch of other methods like
you can step forward and backwards and
you can insert things before and after
and so forth and so I was wondering if
anybody's interested in another default
method that Lau's allows more
generalized list editing than replace
all and so anyway so if you're
interested in something like that
talk to me after or tweet to me okay so
another another default method we added
was sort and this sorts a list in place
now there's already a sort method on the
collections utility class
and so big deal we can call sort
directly on a list instead of calling
collections not sort on that list what's
what's the what's the difference right
so collections not sort the the old
collections not sort because it had to
deal with every kind of list basically
the way it was implemented was it copied
everything out of the list into an array
sort of that array and then copied it
all back in and so list dot sort can be
overridden by the specific list
implementation to provide a more optimal
implementation and so in particular our
favorite list implementation which is
ArrayList overrides the sort method and
in fact since it has an array it just
sorts it in place so we just saved two
copies of every element so that's a big
optimization and then so the other thing
is that we we changed collections not
sort that's that static method to turn
around and call the sort method directly
on its list so that list can override
and provide a more that list
implementation can override sort and
provide a more optimal implementation so
everybody benefits from that all right
moving right along so on the map
interface there a couple interesting
ones here
so if you wanted to do something on
every element or every entry in the map
you used to have to iterate over every
entry of the maps entry set and it was
kind of cumbersome because you've got
map entries out of it you have to call
ket value and get key I think the big
advantage of for each is that it breaks
out the key and value into separate
parameters and so you get a - argh
you got a - argh lambda here so you get
separate separate K and V key and value
parameters for the lambda that you pass
to map dot for each alright now here's a
similar one which is map replace all so
instead of just for eaching on each map
entry what it allows you to do is modify
the value of every map entry so it's
pretty similar but what it does is you
you the return value from your lambda
expression is
used to replace that value of the map
entry all right so there are a bunch
more methods on math of default methods
that were added and and so instead of
talking about them individually what I
decided to do is is bring them together
in an example of creating what's
sometimes called a multi map and so some
of the some of the collections library
is outside of the JDK such as guava or
the Eclipse collections formerly
goldman-sachs collections so anyway some
of these other collections libraries
have a multi map data structure built in
and so the the jdk map has one value for
each key and but in a multi map there
can be multiple values for each key and
so you might you might choose if you you
could if you have those libraries
available great go ahead and use them no
question about that they're very useful
data structures but if you didn't have
those libraries available you might
think how would I do this using just the
core JDK classes so you might say okay I
could have a map say that maps from a
string to instead of a single integer it
maps to a set of integers so the set is
actually the value of of the map and so
that's what that would look like I could
declare this variable multi map which is
a string which mapped a string to a set
of integer now if you did this in Java 7
it's it's pretty painful it's not hard
but it's tedious and there are some edge
cases that you have to worry about so
for instance here are here are partial 1
and 1/2 implementations of multi map
methods put and remove so suppose you
want to you suppose you want to put a
string and an integer into this this toy
multi map we have so the first thing you
have to do is you have to do a get on
the map to see if there's an entry there
at all and so there might or might not
be a set of integers present if there
isn't you have to create a new set and
then put that back into the map and then
finally once you've done that you can
take that integer that you wanted to put
in and then add it to that set so you
know not really hard but it's like four
lines of code when you really
you wanted to do one operation now let's
say what you have to do is you want to
remove an integer from a set well you
have to do that same thing you have to
get from the math to see if there's a
set there at all to remove from and if
there is you want to remove that integer
value from that set oh and by the way if
the set is empty now you want to delete
that entry from the map because if you
delete a bunch of stuff you don't want
to leave empty sets in entries in the
map so it's just more cases to deal with
and in fact I ran out of room on the
slide so and I only only implemented one
and a half of these methods here so with
the default methods we added in Java
eight and with lambda expressions these
turn into one-liners and in fact I was
able to implement many many more methods
of our toy multi map here so for
instance to put we call a new default
method compute if absent and and
actually for some of you this might be
familiar already because things like
compute if absent were already on
concurrent hash map but in Java eight
these were promoted all the way up to
the map interface so anyway what compute
if absent does is it basically takes it
takes your key and a lambda expression
and evaluates that lambda only if that
key is absent and so that's the case
where we want to create a new hash set
as the value corresponding to this key
and then it puts it into the map but if
the if the if the entry is already
present it does nothing but what it does
is it returns the value whether it added
it or whether it was already there and
then we simply add to that set so that
just turns into a nice little one-liner
so remove is kind of similar except we
sort of want to do the opposite thing
instead of compute of absent we say
compute if present and so here you can
kind of see the same the same sort of
conditional eyes conditional operations
going on if if there's no entry present
removing does nothing so we don't have
to do anything at all if there is an
entry present then it calls our lambda
expression and then we room
move the integer from that and then if
the set is now empty
we also return null otherwise we return
that same set now here's a little
wrinkle if this is true of both there's
a whole computer there's compute of
present computer absent and just a plain
old compute method they return the
replacement value and if that value is
null that actually has the side effect
of deleting that entry so it's a little
a little bit of a wrinkle there so so by
returning null from the lambda
expression in compute if present we
actually end up removing that entry and
we want to do that if the set became
empty as a result of having removed the
integer from it so contains you can it's
a slightly different thing but it's kind
of the same flavor you can get you can
get the set you can get the value out of
the map and if if there isn't one
there's there's an sorry the usual
problem is if you get an entry out of a
map either you get the value or null if
there's no entry present so get our
default says if there's no entry present
use this value instead and so here we
say we want to get the set we want to
get the mapped value but if it wasn't
there we can just substitute the empty
set and then ask whether it contains the
value we're interested in and that it's
just a shorthand way of implementing
this and then there are a couple other
things that don't actually have to do
with with default methods but it shows
you how things like streams and lambdas
work well with the collections so if we
wanted to find the size of a multi map
in the sense of the number of values not
the number of entries but the number of
values since there can be multiple
values per each entry we just stream
over the values and convert ask each set
how many elements it has and then sum
them and then if we want to get a stream
of the values we we can we we get all
the values and flatmap them I'm sorry
I'm going to take questions at the end
so anyway so we can have streams that we
can use streams to compress a lot of
things that used to require a lot of
logic down to one line of pretty concise
code okay so moving on to the comparator
interface does anybody enjoy writing
comparators okay okay one guy over here
yeah I know and now these this is my
crowd of hecklers over here okay
so simple comparators okay not too bad
but but but complicated comparators are
are pretty tedious and error-prone to
write because they have lots of weird
conditions in ED cases and I think it's
one of those one of those classic things
like on Stack Overflow somebody says gee
you know something's not sorting right
okay well where's the bug in your
comparator right so you look through it
and there's usually some logic error in
there or something like that so so what
Java eight provides is a family of
default methods and static methods on
the comparator interface that let you
build comparators from simpler
comparators and so that's usually what
happens instead of the most most
comparison logic isn't all that
complicated by itself it's usually
cascades of comparisons and conditionals
relating them that makes that makes
things complex and it's easy to forget
conditionals are easy to fit it's easy
to forget edge cases and if you
accidentally forget something that's the
source of bugs and and so forth so so
let me run through an example here which
is a two-level sort suppose we have what
I'm going to introduce a student class
not very interesting but a student might
have a last name and a nullable first
name and if the students first name is
null we want that student to be sorted
first in the list and so here is a Java
7 example of how to write that and so
I'm not going to go through this in
detail I believe this is correct but
basically collections that sort of
students and let's assume that that this
is a list of students and then we have
to use our anonymous inner class
constructor here new comparative student
and then it implements the compare
method with a bunch of kin
additions in it that we just have to
keep track of and return return the
right value okay so this is not terribly
complex but you can see if you're you
can easily imagine how if there were bug
in this code like if I accidentally
reversed one of the one of the
comparisons you wouldn't be able to see
it and be very difficult to see because
there's a lot of visual noise in this
all right well Java 8 has lambdas so
lambdas ought to be able to help us with
this well not really I mean it helps a
little bit because we have the new list
dot sort method so we don't have to call
collections I sort that saves a little
bit but we and we change the anonymous
inner class into a multi-line statement
lambda but it basically has the same
logic in it so we bought a little bit
but not very much so now this isn't Java
8 we can use these these new methods in
comparator to completely replace the the
code on the previous slide and so I'm
not going to go through a long-winded
explanation here and you probably have a
whole talk about how to build
comparators but there are a few methods
that are that are interesting so one of
them is oh and I've also these are all
methods on the comparator interface
which I have I forgot to put a line in
the slide that says import static
compare you know Java util comparator
dot star so it by not having to by using
static imports it really makes the code
very concise so we can say students not
sort comparing student : : get last
names so that's that's what we refer to
as a key extractor it's just a function
that says if if I want to compare to the
job of a comparator is to compare two
things and so if they're not if they
can't be compared directly to each other
usually what you want to do is you want
to pick something out of each object by
calling a method on them and then take
the object that was picked out and then
compare those objects and that's the
result of your comparison and that's
exactly what the comparator dot
comparing method does and you pass it
this this method that picks out the
value you want so that's the key
extraction process now to have a
two-level sorting you can
say compare doc comparing so if you
wanted to sort just on last name you
could say sort comparing student : :
last name and you're done but we want a
two-level sort so we also add then
comparing and that has the extra logic
that takes two comparators and composes
them so the way you do that is you run
the first comparator and if that gives
you if they're not equal if the first
comparator says that one is greater than
the other you're done but then the
two-level sorting is if the first
comparator says that those are equal
then you have to call the second
comparator and see whether you know see
what its result is and you have to give
it a different key extractor and then
there's some condition that is a
conditional operator there or yet
conditional sorry if the if the first
comparison is equal only then does it
call the second-level comparison and
then that becomes the result of the
overall comparison so then comparing
encapsulate that logic for you that's
kind of the repeated the repeated logic
that occurs in a lot of comparators and
so natural order is a creates a
comparator from two values that are
comparable this is kind of a you know
weird confusing area in the JDK API but
then if you want to take if you want to
take that comparator and by default
things that are comparable are not null
safe because if you want to compare two
things and one of them is null you get a
null pointer exception so nulls first
transforms that comparator into
something that either sorts the nulls
first and there's a corresponding one
called nulls last which sorts them to
the end so anyway so this is a lot to
pack on one slide and didn't want to
spend that much time on it but basically
the flavor is you can take all this
complex logic and compose a comparator
oh I should have put I should put this
this is this is sorry this is the
explanation that I just went through by
waving my hands
but basically it's you know that's what
that is
so so instead of writing out a lot of
complex conditional logic you can take
little bits of comparison functionality
and compose them and that's what these
methods do so let everybody finish
taking pictures this before I advance
the slide okay all right so now all
right so we ran through a bunch of Java
eight stuff now I want to move on to
Java nine all right so the main thing in
Java nine is the kind of replacement for
collection literals so there are no
collection literals in Java and there
there won't be but the history is that
there have been various proposals over
the years to introduce collection
literals into the java programming
language so in Java 7 there were a
series of proposals some of which got
into the into the language including
things like try with resources but there
was a proposal on the table for
introducing collection literals into
language and it was I thought you know
reasonably well thought out but it I'm
not quite sure what happened to it I
think there were some it was one of
those things where it's easy just easy
to propose something and it made sense
but there were a bunch of implementation
issues that that needed to be tackled
and there just wasn't time so but it was
very popular I think what at my point in
raising that was a lot of people said
yes it would be wonderful to have this
in Java 7 we've been waiting for this
for years and so in fact there's been
pent up demand for having collection
literals in Java but anyway it did not
get into Java 7
so after Java 8 we said well let's
revisit this idea of collection literals
and so a gem was filed Jeff is a JDK
enhancement proposal and so so this was
a little odd it was not as not an actual
proposal for an enhancement it was a
proposal to research an enhancement so
it's called a research Jeff and so it
was basically an investigation into
adding collection literals to the
language and there was a bunch of
discussion about that and some some some
proposals were floated but basically it
kind of fell there is
that it ran aground because the the
simple thing to add to the language was
too limiting and to make to add
something the language that was
full-featured and general became wildly
complex and so it was that they were
caught on this this axis of design that
was was uncomfortable and it didn't it
didn't seem like it was worthwhile so
basically the result of that was you
know this idea of collection literals is
really not it doesn't seem to be working
and I think the reason why it didn't
really work is that Java unlike unlike
some other programming platforms Java's
collections stand at arm's length from
the programming language so the the
collections libraries in Java all reside
in Java dot util they don't rely in Java
dot Lang so if you added collections to
the language then what that would do is
a baked into the language some kind of
information about the specific
collections in the JDK and there are
third-party collection libraries which
provide various interesting trade-offs
relative to the JDK collections and
those are valuable because people like
them because you know provide more
flexibility or different features or
whatever that's a good thing for the
Java ecosystem but we didn't want to
introduce collection literals that
favored only the JDK collections because
it locks out all those third-party
collections so that that's the problem
here if you have a library construct
then everybody has a level playing field
so I think that's the that's the
difference there we didn't want to bind
the language too tightly to a particular
set of collections implementations but
then if we wanted to make it general
enough to satisfy all collections
implementations then it got incredibly
complex so that's why the language
didn't does not support collection
literals all right so we backed away
from that and instead we're saying okay
we're not going to solve the problem of
trying to support every collections
library in the program
language instead what we're going to do
is introduce a set of library api's that
support only the JDK core collections
but they're just library api's and so if
third-party collections want to
introduce their own well unfortunately
they do have to be different but we're
not we're not we're not baking the
language and we're not binding language
tightly within any particular collection
API so this is a this is another JEP a
JDK and Hansbrough proposal convenience
factory methods basically what it does
is it introduces factory methods that
are a convenient way to create
collection implementations and it's only
a library API feature it's not a change
to the programming language and this
gets a lot of the benefit you know maybe
80% it's hard to it's hard to say it
gets maybe 80% of the benefit of
language cheney's changes but the cost
in introducing a library API is much
much less than introducing a change to
the programming language so we went
ahead and did that and this is in JDK 9
so anyway the main goals of this project
are convenience and brevity space
efficiency is kind of a secondary goal
but I think that's something that we
paid a lot of attention to it's very
very important and also I think I wanted
to promote promote this to a main goal
which is to provide a set the the
collections that result from calling
these factory methods are immutable and
there's not immutability in the type
system so you don't get back something
called immutable set but the
implementations are in fact immutable
and that's a that that I think is a big
feature so the current status is they
are they are in JDK 9 in current builds
if you go to if you get any of the JDK 9
early access builds you will you'll find
them there and you can see the you can
see the API in the Javadoc and so one of
the interesting things about this is I
think this is the general pattern with a
lot of JDK stuff it is apparently very
simple and if you put up the API here
it's a it's a pretty simple API but what
it did was it is a surfaced a wide
variety of
surprising variety of design and
implementation issues that went behind
this and so I will go through some of
those later in the talk all right so
this is the API it and it is pretty
simple so there is a set of fixed ARB
overloads for lists of up to ten
elements and if you have more than ten
elements there is a varargs overload
that can take an arbitrary number of
elements that you type out or you can
pass an array there because that's the
way that varargs works similar with set
of you can have up to 10 fixed Arg
elements or an arbitrary number of
varargs or an array and map thought of
is is different since the key and the
value of math are of different types you
can't do something quite so
straightforward so instead what we do is
we provide a family of fixed Arg
overloads for up to ten key value pairs
and if you have more than ten keep Lu
very key value pairs then what you
basically what you have to do is you
have to box them into a map entry and
then pass an array or varargs of mount
entry all right so hey where any of you
in the community keynote this morning
and yeah a bunch of people okay so after
that' so i had a small part on stage and
there were some laughs with what i said
and a few people afterwards said to me
that i had a knack for comedy and i I
was thinking about that and I said you
know that's that that might be true
because when I posted this API somebody
on reddit said is this a joke so so
really this this is this is though this
is this is yeah this is map and if you
look at list and set you'll see all this
huge huge variety of overloads here and
yeah it's kind of ugly but the reason we
did this is we VAR args is actually kind
of expensive because what it does is is
is it actually creates and allocates and
populates an array which is actually a
fairly expensive operation in Java
and then passes it to the method which
basically unpacks the array and then
throws it away
so varargs is necessary and useful but
it incurs an expense that we did not
always want to pay and so the design
compromises here is to clutter up the
API in order to make programs go faster
and we believe that small collections
are fairly common common enough to
warrant an optimization from avoiding
varargs so I think this is kind of a
flavor of what goes on in the JDK which
is we're willing to make design color I
mean this is not a clean API right I
mean so I wouldn't I wouldn't call this
clean but it's a pragmatic design
compromise because we want people to be
able to write programs that that run
fast and we're willing to clutter up the
API in order to do that we're willing
but we don't like it but we're willing
to do it and you can see this in other
places in the API if you look in the
family of functional interfaces in Java
util function people said same thing
same thing about how this is an atrocity
you know all this stuff when they saw
when they saw that package or another
example is all of the overloads for all
the different primitives in the
java.util.arrays class that's an
extremely cluttered class and we don't
like that but we don't really have any
answer to that today but we wanted to
provide this useful API today maybe
there will be some ways to solve this in
the future with with value types and
generic specialization but that's that's
all that's kind of far future stuff so
this is this is what we do today in
order to make programs when you when you
call actually I'll put up the next slide
here when you call the these methods you
don't see that complexity so if I want
to and so top half is the Java eight
stuff bottom half of the Java nine stuff
when you call one of these methods so I
want to initialize list with three
elements list of ABC so that that looks
nice and neat so you don't see the
complexity of that API unless you go
look in the Java doc so here I think
everybody everybody understands these
examples if you want to initialize in
Java eight and earlier if you wanted to
initialize a collection with a set of
with variety of elements you had
- you had to do a lot of typing and you
kind of had to look at and it was kind
of cluttered and in Java 9 I think
things things get cleaned up
considerably and so this only shows the
fixed aargh variations of the the map
overloads this is here's an example of
initializing a map with with actually I
don't know how many key value pairs
there but basically an arbitrary number
of key value pairs and so actually I
have some design rationale coming up but
this is what it looks like basically
there's a helper method named map entry
lower case entry you can you can
statically import that and it makes it
reasonably neat to to use that in a
varargs fashion like this alright so
this is one of the big design questions
for the API which is like I said before
with lists and set you can have fixed
args and VAR args and everything works
naturally with map there's no obvious
VAR args solution and so so we
considered about 15 different approaches
of having builders and having you know
passing passing a certain number of
lambdas and having chained method calls
and this and that and the other and we
came to a firm technical evaluation that
they all suck so so the game became
which of them sucks least and when you
when you're dealing with this I think
it's always instead of having oh I like
this better this is cluttered this is
neat and so forth I think it was useful
to come up with a set of criteria for
choosing among these alternatives and so
the top line the top line goal was a
convenience and simplicity and so that's
clearly one of them there but we also
had to stay consistent with with I'm not
sure what to call it other than Java's
traditions Java is a very very compile
time
compile time type safe language and so
the the one of the consistent design
goals in Java is that if the compiler
can detect that you're making an error
at compile time it should tell you at
compile time and that's something we try
to to stick to
so for instance there a variety of
things where we say object dot if the
key and the value were of different
types than what what type unifies them
well everything is an object so you can
have you could say you know initialize a
map from varargs of object dot well that
that just seemed wrong because it's very
easy to make a mistake there that's not
detected until runtime okay so a number
of elements known at compile time what
we didn't want to do is have an
arbitrary chaining of method calls that
might that might cause map resizing to
occur during initialization we wanted to
be able to pre allocate something put
things in place and you're done this
next one key and value should be
adjacent actually I should clarify that
key and value should be adjacent in the
source code
so an alternative is to have two arrays
you can have array of key and array of
values but then when you when you when
you look at the source code there
they're widely the key and the values
are widely separated from each other so
yeah that works but well it kind of
sucks so here we are and avoid boxing if
possible and it turns out I mean it's
possible to avoid boxing but it turns
out that the solution we ended up with
satisfies all of those criteria but not
but not boxing essentially what we do
have to do is when you take key value
pairs you have to box them into a map
entry and then those get put into a VAR
args array which then gets passed to the
mouth of entries method and that's
that's kind of uncomfortable because
it's doing a lot of boxing and
allocation for stuff that's thrown away
but you know maybe in the future this
can be you know if if JIT compilation
technology advances maybe some of this
can be compressed out if we get value
types in the future maybe this math dot
entry can change into value type stuff
like that so can't promise anything like
that but it it seems to work certainly
works well in source code and if your
initializing a big map then you just
have to know that it is going to be
somewhat expensive to do that all right
so that was one API design issue they're
a bunch of design and implementation
issues well I kind of threw immutability
in here but but anyway so there's a lot
going on behind this API so I don't
going to click through a bunch of issues
in that regard
alright first one is immutability wanted
to clarify that this is sort of classic
classic collection immutability where
basically it means in the collections
framework certain methods are optional
and if the collection chooses not to
implement them they throw unsupported
operation exception and so these are
just like well from that standpoint
these are just like the collections not
unmodifiable wrappers so if you take one
of those and call add on it or something
like that you'll get unsupported
operation exception and so if you take
one of the collections from you know
from list of or map thought of or
something like that you get the same
behavior the difference with the
unmodifiable wrappers is that these are
not wrappers these are data structures
implemented by classes that do not allow
modification and so any modification
attempts will throw an exception and I
want to contrast this when sometimes I
mean there's this terminology confusion
in in the computer computer software
industry sometimes people people I want
to draw a sanction between immutable
collections in the sense I just
described versus what I'm calling for
clarification immutable persistent
collections where where there are their
methods or operators that apparently
will modify a collection but give you a
copy of the collection while the
original remains unchanged and so in
that sense they are persistent and
they're a variety of third party
libraries out there then implement that
in Java and of course many other
programming languages implement these
kind of collections as well core JDK
does not so I wanted to draw that
contrast there so immutability I think
you know if you've been talking about
parallelism you know and concurrency
immutability is good because it's it's
automatically thread safe after
construction but there are also some
other other things we can do which is
that since the data structures do not
have to be capable of being mutated we
can make them much more compact and so
that serves the goal of space savings as
well
finally just a 1:1 distinction between
the unmodifiable rappers with the
unmodifiable rappers if you call
collections dot unmodifiable list on
some list then you get a view of that
list which prohibits modification but
the underlying list is still mutable so
if somebody has a reference to the
underlying one it can still be changed
so again
contrasting the contrast with the new
collections is that these new
collections are do not support mutation
at all hence we are calling them
immutable instead of unmodifiable
alright so here's here's an interesting
one which is we are deliberately
randomizing the iteration order of the
new collections so there's a lot of
history here so if you look at set and
map in particular so list is definitely
ordered so we're not talking about list
here if you look at set and map the
hash-based set and map and possible well
yeah the hash-based ones in particular
the iteration order is unspecified so
that means that if you look at the
specification the implementation is
allowed to change its iteration order
and still conform to the specification
what seems to happen in practice is that
people write applications that have
inadvertent dependencies on iteration
order and also in the JDK what we've
tried to do with the classic collections
like hash map what we tried to do is not
change the iteration order but
unfortunately there are times when we
are forced to change the iteration order
such as if there's a security hole we
might have to chain make some tweak that
changes the iteration order of the hash
map and there are also different
optimizations and whatnot where from
time to time we will make some some
optimizations that are a clear win from
the space and performance standpoint but
end up having the effect of changing the
iteration order now that's allowed
within the specification unfortunately
people's code breaks and we don't like
it when people's code breaks and neither
do the
authors of that code but but there's a
problem here because the spec says we
can change it but we sort of can and
sort of can't because it breaks code and
so forth so and I've been on projects
where we get these weird things weird
behaviors and random test failures and
stuff it's like mmm they're an ordered
pen see here so why don't we change that
hash map to a linked hash map which
preserves iteration order and then the
problems go away it's like what just
happened there what it means is that we
don't understand our code as well as we
think we do so anyway iteration order is
a big deal and I think there's lots of
code out there that has latent
dependencies on iteration order that has
not been that has not been discovered
yet so our response to this I say
solution here I'm not sure it's a
solution but our response to this is to
deliberately randomize the iteration
order in set and map in the new
collections and so in so so whereas
before the iteration order the
collections was it was unpredictable but
stable these are predictably
unpredictable so every time the JVM
starts up we get a random number and we
use that as a seed value that gets mixed
in with the hash values so if you run a
program that initializes a set and then
prints out the elements in the order
you'll get an or you get an answer and
then if you invoke the JVM again and run
that same program the set of elements
usually will come out in a different
order and so the idea here is that the
problem is if there are if their
iteration order dependencies in your
code what what used to happen in the
past is a new JDK release came out and
you test your code and it's like we were
getting these weird things all right and
then you know take hours of debugging to
trace it down to some kind of change in
iteration order but what that meant was
there was a bug in that code that
depended on the iteration order now if
you vary the iteration order more often
like every JVM invocation
then we hope then that weird behavior
will manifest itself much more
frequently and in fact we hope while
you're doing while you're doing testing
as opposed to after you've moved code
into production so if you in you know so
there's a network of assumptions here
which is that if you run your code say
in a continuous testing integration
system you're going to be invoking JVMs
repeatedly and since the iteration order
is not repeatable that will tend to
flush out any latent latent order
dependencies in in that code now I want
to clarify here this this applies only
to the newly introduced collections in
JDK 9 because by definition since they
did not exist before no code can depend
on the iteration order in those
collections the behavior of the existing
collections will remain the same
I mean hash map hash map stays the same
alright so so I wanted to move on here
away from iteration order
we're disallowing nulls I'm not going to
I'm going going through this in a little
too much detail here but historically
nulls were allowed in the original
collections framework and in retrospect
this this is mostly viewed as a mistake
and so recently introduced collections
have always disallowed null and we are
continuing that trend so here's an
interesting one it's a it's a it's a bit
of an outlier but if we're fashioning
this after collection literals then for
things that require uniqueness such as
set elements and map keys then having
having duplicates in a set or map is
really a programming error but it turns
out that there are actually very few
systems out there that that treat this
is a programming error so if you put in
ten items well actually more likely if
you put in 50 items and there happened
to be some duplicates in there
you only get 49 items in your set and
and if you have a large if you're
initializing initializing a large
collector
and there are duplicates that are far
apart in the code then then that's a
programming error that sometimes hard to
spot and so most systems with the
notable exception of closure and strict
Eknath script most of those systems are
kind of last one wins and so but in
these collections if we detect while
we're creating the collection that there
are duplicates we will throw an
exception at initialization time might
be nice if it were a compile time error
but we just don't have the capability to
do that because the collection is not
actually initialized until run time so
here's an almost repeat of the slide I
put up earlier see if you can spot the
duplicate all right raise your hand if
you see it okay a pretty good eyes all
right all right so okay space efficiency
so I said one of the one of the top
goals of this effort was to improve
spatial efficiency it turns out that for
the for the existing data structures
that use things like internal nodes are
very space inefficient and so consider
consider a hash set with two strings in
it I mean a classic one Java eight and
earlier and so there's the code to
initialize it notice the table has to be
size three because of the load factor of
of hashing and also let's let's say we
want to make sure that this is
unmodifiable so we put an unmodifiable
wrapper around it and you can go through
the analysis and count the objects but
it turns out there they're a bunch of
objects here that that represent this
data structure rather more than you
might think and so here's a here's a
here's a diagram that represents those
objects we have the set we have the
unmodifiable wrapper which wraps the
hash set but a hash set is built on top
of a hash map so there's another object
and then hash map has an internal table
which is an array which is another
object and that array contains two nodes
each of which contains the the actual
contents which we refer to as the
payload so if you add that all up
it ends up if you have
entries in a set it takes 152 bytes
which is which is quite a bit because
two references references usually four
bytes so you think two references might
take eight bytes but it's like you're
getting you taking up a hundred and
fifty two bytes and and the other thing
is each individual object has its own
object header which has additional
overhead so there a variety of things
including the project Valhalla work
which try to attack this at its
fundamentals of course we're not doing
this in jdk 9 so for these collections
and this this is where the immutability
comes in hashmap is very general because
it needs to add and remove elements
since we don't need to we can do things
like oh if you have a set with two
elements all crew have a class that has
exactly two fields in it and then store
the store the elements there and so the
cost of a immutableset if you say set of
foo comma bar that takes 20 bytes as
opposed to 152 bytes so that's a big
space-saving and actually I got a
message from one of our one of the
engineers who's working on the JDK
during the conference and actually was
last week he What did he say he is
working on J link which is the new
modularity modularity tool in JDK 9 and
he converted some of his code from
classic hash set data structures to
using set thought of and his very simple
changed saved 13% of static heap size at
initialization time and so if you're if
you're doing performance and Space
engineering making one change that saves
1313 percent that's pretty big and it
was really simple change to I looked at
it and it's you know like 20 lines of
code or something like that so that's
pretty good so we're pretty happy about
that and and we intend to do more as
well multiple implementations just a
quick thing on this there are several
different implementations of each data
structure and we choose them depending
on the size of the collection so we have
a specialized implementation that is
empty specialized implementation for one
entry special
is implementation for two entries and
then actually at that point we go to n
and this is not new I know the eclipse
collection guy is sitting right here so
I'll acknowledge they do that too it's a
good idea so we're adopting it
they are the collections are all
serializable one one one note about
serializability is that implementation
class names tend to leak into the serial
format of of the serialized output and
so we use serialization proxy to make
sure that the in the implementation
classes are all internal and private the
only way to get to them is by calling
list offset that of map dot of so we do
not expose any any actual implementation
class names like array map or anything
like that and so in order to keep those
secret during serialization we use
serialization proxies so that there's a
unified serial form for all of these and
we're not so the point there is that we
can still preserve serialization
compatibility even if we rearrange these
internal implementations later on
alright so that's the end of the JDK
nine stuff I just wanted to talk very
briefly about some some future work so
as you might know my alter-ego is dr.
deprecated ER and my dr. Debra Gators
task is to look for things to deprecate
and so what I refer to at the very
beginning of the talk is what I call the
legacy collections vector and hash table
and so forth and I think it might be
time to deprecated those it might also
be time to deprecated linked lists that
was introduced as part of the the core
collections the main collections
framework in 1.2 but really if you if
you start to examine the trade-offs
there are vanishingly few cases where
you would use linked list over ArrayList
so maybe it's time to do something about
that so in the short term there a
variety of you know reasonably
interesting kind of point enhancements
we could do to the core collections and
also to Jeff 269 the immutable
collections
things like one of the things most
requested features is I I had that I had
that whole segment about randomized
iteration order and what people would
like to say oh I'm gonna I want set of a
comma B comma C and I want them to be
iterated in that order
and I think that's a fine thing to ask
for and that would be a different that
would be an additional feature to have a
set of ordered elements a comma B comma
C and so you get a different collection
implementation that preserved a stable
iteration order so that would be a fine
enhancement for us to investigate in the
future now in the far distant future
project Valhalla is going to give us
value types and generic specialization I
think the main impact of that work on
collections is with generic
specialization the idea is that instead
of genera fiying only over reference
types we could genera fie over any type
not only value types but also primitives
and so we can finally get things like
list of int that would be very nice
thing to do and then I mentioned early
on about immutable persistent
collections fairly often we get requests
to add a mutable persistent collections
to the JDK I think you know I think
that's something we're keeping our eye
on meanwhile third-party libraries have
the space covered pretty well but
they're interesting things we might be
able to do in the future but that's
really far off and all pretty
speculative alright quick summary here
collections have long history and
promising future what I find interesting
is that the framework the original
framework is 18 years old and I I think
it's I think it served us quite well
we've been finally been able to enhance
it with Java eight default methods and
it's it's given the collections
framework new life I think and so we're
still working on it and in Java 9 the
the big feature from the collection
standpoint in Java 9 is convenience
factories and you know I think there are
some good features convenient to use and
good space savings and there's lots of
stuff we can work on beyond Java 9
and a couple links there one is to the
to the JEP text JEP 269 there and I
invite you to look at the JDK 9 early
access builds and try these out there's
Javadoc there and so you can find that
that that mess of set thought of
overloads there but I think try out the
new api's I think you'll like them so
looks like I'm exactly at the top of the
hour here so we've reached the end of
the session at the end of Java 1 at the
end of a nice long summer in San
Francisco I hope you enjoyed the
conference and have a safe journey home
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>