<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Understanding Asynchronous Processing and Patterns in Node js | Coder Coacher - Coaching Coders</title><meta content="Understanding Asynchronous Processing and Patterns in Node js - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Understanding Asynchronous Processing and Patterns in Node js</b></h2><h5 class="post__date">2018-03-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iAdeljxq_hs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright let's go ahead and get started
here I'm not sure why the talks not
showing up do I need to do something
all right well we're getting the
technical issue addressed I have a
couple of questions for you guys any
JavaScript developers in the room all
right perfect
and anybody working with nodejs already
okay good this is the perfect groom all
right I'm not gonna stand because I do
cable wouldn't reach I'm gonna sit here
instead this is understanding acing
processing and patterns and nodejs brief
safe harbor statement please don't make
any purchasing decisions based on what I
say here today we've already covered a
little bit about you guys so a little
bit about myself my name is Dan McGann
I'm a developer advocate at Oracle I
focused primarily on the JavaScript in
Oracle database communities which means
I spend a lot of time working without no
database driver for Oracle but there's
actually some new and interesting places
I get to work too for example we have an
mla engine now an Oracle database as
well as my sequel which is being used to
execute JavaScript within the database
we'll stop I have my contact info here
and of course these slides are already
available via the schedule online so you
want to download the slides feel free if
you have questions for me related to
this or other JavaScript and database
related topics please feel free to email
me and reach out
what is node Jas what I have here is a
screenshot of the description you'll
find if you go to node.js org and
there's a couple interesting pieces of
information that jump out here so the
first is that node Jas is a JavaScript
runtime built on v8 so prior to no js'
JavaScript pretty much just ran in
browsers one of those browsers was
chrome in Chrome's JavaScript engine was
v8
where is v8 and it's known to be one of
the very best JavaScript engines in
existence and so Ryan Dahl in 2009
basically with a few others took v8 out
of chrome because it was open source and
then plugged it into Linux allowing
folks to execute JavaScript now on the
server side not solely in a browser and
this was very interesting the demo that
he did was building a web server with
just a few lines of code and when he ran
the demo he got a standing O because oh
my gosh folks that knew JavaScript could
now build web servers what could be
cooler than that what else stands out
well it's the largest ecosystem where
that npm provides access to the world's
largest ecosystem of open source
libraries so just by using node you have
ready access to tons and tons of code
that you could use in your applications
to make you more productive that's
pretty cool what about this part
event-driven non-blocking i/o whoo this
is where things get a little bit more
complicated now when Ryan Dahl was
making this tool this platform back in
2009 he often said that javascript was
the perfect language for this because
javascript was sort of evented already
was written for this kind of thing
because of the way that the web works
but what does that mean well here we see
in some example code and I could run
this it's just a very simple web page
that shows a button and when you click
the button it says hey the button was
clicked once and when you click it again
it says the button was clicked twice
that kind of thing right
and of course it's evented because we
have methods like you see here down on
line 17
button dot add event listener but it's
more than that in JavaScript
functions are first class now some hands
went up earlier when I asked if anyone
was doing JavaScript does anyone know
what functions as first class functions
are first class means can anyone call
out a line or two here which
demonstrates that functions our first
class is not a line number there's a 1
in 23 chance you'll be right these lines
here so in JavaScript timing is
everything and what's happening here
this function I'm moving my mouse here
we go this function I'll just use it
over here on load is being declared on
line 7 and this function on load is
being passed to another function call on
the document down below so document dot
addeventlistener
and then we pass a string and then we
pass a function not all languages allow
you to pass functions like numbers and
strings and arrays and so on
that's what functions in first as first
class means that functions are just like
any other data type they can be passed
around and invoked in the future we're
not invoking onload here instead that
function will be invoked in the future
the same is happening with on-click
so that was cool that helped well what
else helped well the fact that functions
in JavaScript provide closure and this
is kind of another necessary ingredient
for what we're doing here with async
work does anyone know what that means
if anyone caught a line number that
would show that so it's here the way
this works we have a function called on
click and in that function we are
referring to variables that were not
declared within the function but rather
in an enclosing function scope now
here's the interesting thing about
JavaScript we're taking this function
called on click and passing it to button
dot add event listener click and we're
basically saying that when this button
is clicked invoke the function on click
and javascript says ah because this
function on click is referring to
variables declared in the outer scope
I'm going to create a closure around
those variables and I'm going to
guarantee that the function has access
to them when the function is invoked and
this is unique and different but these
were necessary for evented programming
and already there
now despite JavaScript being so well in
purpose-built for event-driven
asynchronous programming when rising
stack recently did a survey on node.js
and asked folks what nodejs
topics are criminally under explained
you know the results varied quite a bit
but three of these kind of really stood
out to me and they were asynchronous
programming the event loop and promises
which are all kind of interrelated that
in fact you could just say asynchronous
programming and in fact some of these
other things are also related to that
but these are the primary three that
that stood out to me and why is that
well in JavaScript try catch finally is
in fact a thing you can do it and so
what do you think would happen if we ran
this code in a browser so we have on
line three here well let's let's go
through it so on the try block we're
saying try one log that out to the
console then throw an error and then log
try to we catch the error and then
inside of here we log catch one we throw
a new error and then log catch - and
then and finally we just log finally
what do you think you would see here so
would we see try - that wouldn't make
sense right we're gonna come out of here
we're gonna fall into the catch block
we're gonna see catch one obviously are
we gonna see catch - no because it's
gonna throw an air it's gonna come out
whoo what happens here are we gonna see
finally yes because that's what try
catch finally is all about make sure
that you run the finally block prior to
letting the error that may bubble out of
the catch block proceed up the stack so
that's cool but this is a big but you
can't actually use try catch finally the
majority of the time you want to within
JavaScript
and the reason is you're doing
asynchronous work so for example you
want to get a connection to the database
you want to use it to do some work and
catch any errors that might occur and
then close the connection here's the
thing the asynchronous work is not being
executed in your and your single thread
here that asynchronous work is being
offloaded run in a separate thread and
then when that thread is finished doing
the asynchronous work then your callback
function gets executed on the main
thread again and you cannot catch
exceptions that occur in a separate call
stack just can't do it
other things are like common things you
might think are it's going to be easy
like doing a loop let's say you want to
just do a simple synchronous loop you
want to loop and process some rows and
then when you're done you want to do the
next thing well it doesn't work like
that no just because each of these loop
iterations is actually an asynchronous
call scheduling work for a separate
thread so it stuff just doesn't work
like you'd want it to well how do you do
acing flows like this with no js'
whether you want to do something
sequentially whether you want to do some
things in parallel or even combinations
of these flows how do you get it done
well you got to learn a little something
about the event loop and node and I say
a little something because really the
level of detail that's out there is
sometimes maybe too detailed but in case
you like that level of detail I'm
pointing out not only this video which
is everything you need to know about the
event loop and node.js this is a great
video that explains it in detail but not
too much it's about less than twenty
minutes this video as well and one is
kind of a top down approach one's a
bottom-up approach you learn a lot just
by watching these videos but I'll cover
some of what they cover just very
quickly so the way that no js' works it
is built on top of another sea level
library called live UV it used to be
built on when back in 2009 when it was
just for Linux
they used a library called live a i/o
and the a IO stood for asynchronous i/o
so that
only worked for Linux they needed
something that worked cross-platform so
libuv came around and libuv offers the
event loop that nodejs uses to execute
the JavaScript code and it basically
defines seven phases on its website if
you go to the node J s website and I
have links here at the bottom you can
use to get more detail on what I'm
showing you you'll see that there is a
corresponding event loop of course
because it comes from libuv but they've
simply collapsed idle and prepare into a
single phase and then I went ahead and
created my own for the purposes of this
talk with just a bit more detail so this
is my version now the first thing we're
gonna do is point out that idle and
prepare are only used internally a node
so your JavaScript code doesn't doesn't
use this particular phase so we get rid
of that one simplify it some so what's
left well we have timers and basically
timers is a phase where if you make a
call to set timeout or set interval to
basically schedule some work to be done
in the future well this is the point at
which it will be done note is going to
look at the various timers figure out
which ones have passed and need to be
run it's going to take those basically C
functions which have a pointer to the
JavaScript function that was passed to
it and it's going to queue them up and
execute them and then move on to the
next phase so then it goes on through
pending IO callbacks and I almost
removed this one but it is kind of
relevant so basically sometimes you have
certain operations like TCP errors that
don't get executed during the normal
time they would which is down here in
the poll phase and so they're scheduled
for the next iteration of the event loop
instead okay now this is the big one
this is the poll phase where you're
basically pulling for i/o and I'll show
you a little bit more about that here in
a second but basically there's two types
of i/o there's evented which is
efficient and then there's thread pool
which is not as efficient but necessary
but either case it's pulling for i/o and
this is where the majority of the
callbacks that you're specifying are
going
vote then there's another poll
or two rather in the check phase or work
scheduled via set immediate and then you
have work that you may have scheduled
when you grab an object and you say on
the close event then execute my callback
function okay that gets executed at this
particular phase but what about process
next tick which is a function we can use
as well or promises which allow us to
basically resolve things in the future
well they happen to have their own
queues and they're executed after each
of the phases you're currently looking
at like so it kind of looks like this at
the end of the day so you you just have
one queue for your next text off one
queue for your promises and so it goes
through this cube into this one into
this one goes through this queue into
this one into this one into this queue
and so on and so forth this is basically
how it works
the truth is you don't need to know all
that level of detail although these
slides may prove useful in the future
when you do need it but when you're
starting with node as most of you would
be you don't need it what you need to
know is that first of all your
asynchronous code must call some C layer
of code so set immediate and process dot
next tick we use those in JavaScript
land but ultimately they're going to be
calling some C layer API and the reason
for that is because libuv is a C layer
API so it needs to be in C now the
important thing to know about libuv is
how it separates work and the first
grouping is this network i/o as well as
the timers you saw so network is evented
meaning it uses kernel level api's to do
what it does and this is what Ryan Dahl
was really trying to do build a platform
that daugther hand you have file i/o
certain DNS operations and then user
code which is a big bucket these are
going to use a thread pool now I created
this diagram I'm going to show you
before many moons ago in the first video
that I showed you before you can watch
later
the presenter said you know everyone
does these diagrams of the thread pool
and they're always wrong and he's right
my diagram is not correct entirely it's
not entirely accurate but it is useful
for simplifying and understanding how
async processing works in node so I'm
gonna keep showing it anyway
and the way it works your JavaScript
code runs in a main thread and that's
essentially the event loop right and
you're gonna make some async API calls
like maybe you call set timeout as I
mentioned that's evented maybe you make
a network call-outs to request a webpage
that's also invented tcp and UDP
completely evented kernel-based really
efficient maybe you're reading or
writing to a file so you're using file
system api maybe you're doing a DNS call
translating google.com to an IP address
or maybe this user code here is a really
big bucket and basically includes things
like any third-party module that you npm
install such as the database driver that
we use with oracle or if you're doing
some kind of compression or encryption
these types of things utilize a thread
pool the reason being if they stayed and
did that work on the main loop you would
be blocking so imagine this main loop is
processing thousands of end users that
are using your api's or your
applications this main thread this
single thread is more than capable of
supporting many many users as long as
you don't block it as soon as you block
it
you're basically killing your node app
that's why we schedule this work to be
done asynchronously so this the kind of
logic you'll find here is always very
lightweight you know if then else simple
loops but if you're doing heavyweight
stuff you offload that to one of these
areas now when you make an async API
call such as set timeout and JavaScript
you pass a callback function and that's
been true up until only very recently
but it's true still for the most part
you pass a callback function that should
be invoked when the async work is
complete so what happens the async work
is done when it's complete
your callback function is then added to
some kind of queue which this queue
doesn't really exist as we saw before
it's more complex but it's a simplified
version so the callback function will
eventually end up at the front of the
queue and then hop back up here on the
main thread to be executed and think
back to what I said before about why you
can't catch an error right now hopefully
it's a bit more clear the main thread is
where the error occurs but the async
work that you were doing was not in that
thread or being processed there the
async work might have been here and then
this callback function comes along with
the error that occurred and it's too
late can't catch that anymore
so there's different types of async
flows that you might be working with the
one I'm gonna focus on in terms of a
demo here is gonna be the one header
detail transaction it's a simple type of
interaction that I think most of us done
in the past if you ever worked with
databases where imagine you have a
parent-child table relationship and you
want to insert some detail records into
the child table but first you have to
insert the parent that will give you the
primary key of the parent then you can
insert the child records with a foreign
key relationship to that parent right
it's like a two-step process at minimum
so we'll be investigating that but
there's other types of flows like maybe
you're doing some kind of ETL process
from the database and for that you want
to you know transform an API call write
it to a file there's lots of different
flows you could do they're all supported
and no the approach you might use may
vary and we'll look at a couple use
cases of both let's start with the
header detail scenario and just imagine
that we have some API endpoint
it's the endpoint is some URL slash API
slash orders and the idea is that
somebody is going to issue an HTTP POST
against our URL endpoint and what we
need to then do is define some logic
there this is the data they're passing
us very simple the top level is a parent
thing just a name property the details
is an array of child things with the
just a name poverty and the goal for us
is to get this data into the database
right we're gonna explore a couple
different options to do it now to do
this work I'm going to be using the
Oracle database driver for nodejs it's
known as node Oracle DB what you seen
here is a class overview I won't go into
too much detail I'll just start by
saying the base class is used to do two
things either create a connection pool
or a one-off connection or a dedicated
connection to the database whenever
you're creating something like an API
you always want to create a pool first
if you if you want
the API to be able to scale and perform
well and then once you have your pool
you get connections from the pool it's
the connection that you use to do the
bulk of your work such as inserting rows
into the table as we'll be doing here
but also you can do all kinds of sequel
and PL sequel using the connection and
we have other objects like result set
and lob objects for streaming data into
and out of the database when you're
doing more complex operations
so let's start by looking at nodejs
style callbacks and back in 2009 this is
really the only option you had to do
async work and node because this is kind
of how javascript has always done async
work with callback functions but when
they went to approach the callback
functions and no jest they said hey
let's not do the free-for-all that
everyone's been doing up until now let's
define a couple of rules and they were
pretty good at following these rules the
two basic rules are a the callback
function when passed to an async API is
always gonna be the last parameter
passed and that function its first
parameter is reserved for errors and you
can do this with name functions or
anonymous we'll see examples of both but
here's what this look like it looks like
so we have at the top here an async API
being defined and this is just a simple
JavaScript module and I'm exporting or
making public from the module a function
called get random number and it's a
simple function it takes in a number of
milliseconds in a callback function and
in order to invoke that callback
function in the future I'm using an
async API here called set timeout so I
use set timeout to invoke the function
after a certain number of milliseconds
is passed and note here that when I
invoke the callback function on passing
null null when I invoke the function
that first parameter is reserved for
error so if an error doesn't occur then
we passed null instead and then I pass a
random number so down below you see me
using this module I'm requiring in the
file from above async API and then I'm
invoking the function that's been made
public passing the number of
milliseconds as well as the callback
function so all I do is log that out
after number of milliseconds it passed
now what you're not seeing and the use
of the API is proper error handling and
this is what that should look like so
now when I invoke the function what I
have to do is check to see if the error
parameter has a value and if it does and
the API implementers have been following
the correct standard it will either be
null indicating nothing happened or it
will be an instance of error
and so down below you see I'm checking
to see if error because in JavaScript
things can be truth it can be a simple
check like this if error then
console.log the error or console error
the error and return and this is really
important we're short starting short
circuiting the logic of the function
we're exiting the function because an
error occurred and if we get past this
point if we get down to line 9 we can
assume that the async API successfully
completed and then we continue our
success logic any questions so far
all right so this is the node J style
and this is what it looks like to
implement our solution remember we have
a REST API
we're expecting a post call so I have a
function here called post and it's going
to take in the order and the orders that
jason you saw before and it's going to
pass a callback and this callback is
something that we're going to invoke in
the future when the header and the
detail rows have all been inserted
successfully now I've collapsed this
function it is in fact about a hundred
and ten lines of code but this is what
it looks like from a high level
I'm gonna go into some sample code here
and we'll see what this implementation
actually looks like so we're doing
anonymous callbacks first all right so
here's our function post and note that
above I'm bringing in the Oracle
database driver also a configuration
file so we can get a connection to it
but we have the driver and we call get
connection now note when I call get
connection I pass that configuration and
I pass a callback function the callback
function is following the pattern we
discussed before the first parameter is
reserved for errors when that function
is complete it will be invoked the
callback function I'll check it for
errors if I don't have an error I can
assume success I now have a valid
connection now I'm going to use that to
execute an insert statement using the
data that was passed that order object
I'm using buying variables here for both
security and performance and again at
the end of the execute statement what
are you seeing yet another callback
following the same pattern we check for
errors if there wasn't an error I can
assume success and continue on if there
was an error maybe I close that
connection and exit out but assuming
success we now have the result of the
previous call and I get the header ID
and I use that then to start inserting
detail when this insert successfully
completes this callback will run and
I'll insert the second row of the detail
and when that successfully completes I
can then insert the third row of the
detail down below that you're starting
to see what and nodejs we call the
Pyramid of doom so basically its
callback functions nested in callback
functions nested in callback functions
and you start to see how it comes in
here this is the sort of inverted
pyramid here and it can be a real mess
if you
approach your no Deus applications like
this using anonymous callback functions
is not is not going to result in
maintainable applications
so you know what meant to show you at
the very least that that's working so to
show you that I'm just gonna open up a
terminal here and before that I'll show
you in sequel developer will open a
connection to my local HR schema and I
have this header table with no data oops
we have data and I have a child table of
detail all right that one's empty let me
go to header I'll just delete these rows
omit that okay so now all the data is
gone and I'll go back to my terminal
here and I'm gonna call node past one so
this is a test file that I've written is
specifically test the first
implementation of the code using
anonymous callback functions I run that
says it's done we refresh this and we
have our parent thing and the child
things are there as well
so cool it actually worked that's about
the only good thing I could say about
that code on the bad side is their
question the question was is the code
running on the server side or the client
side and the JavaScript code that I
wrote was running on the server side
note is a server-side platform for
JavaScript so when we talk about client
or server that term actually means
different things in different worlds
right for Oracle the client is often
what some folks would call the server so
in this particular case it wasn't
running in the browser that's probably
the best way to put it running on the
server it was not running in the browser
it was running on my Mac my machine here
I could run it on Mac Linux or Windows
but no does not run in the browser
not sure I understood the question maybe
that's one I can take after the top
thank you all right let's move on to the
next implementation this is a header
detail with named functions so we saw
that there were some issues with
anonymous functions and we can stick
with this node J s style callback
pattern but do a little bit better just
by giving our functions a name which
allows us to call them by name so you're
seeing here at a high level what this
looks like I now have a post function I
have a create order function and create
details function now one of the issues
with the anonymous pattern was that I
had a fixed level of children but what
if I was passed four instead of three or
two instead of three that code couldn't
handle it but at least now with a named
function we can handle this situation
correctly we'll take a look at what that
looks like the next pattern is named
functions and I can make all this code
available if anyone wants to go through
it after the talk so just like before
only now we get our connection and then
we come down and we invoke a named
function create order create order is
defined down here now when we invoke
create order we have to pass along some
state such as the order that we want to
create the connection that we had just
gotten it'll pass those along and then
connection dot execute can insert the
header row when that is successfully Pat
created inserted then it's callback
function will invoke create details know
what it's doing here is passing the
order details as well as the header ID
that was retrieved and the connection
again that came from the first function
so it passes that and then create
details checks this index parameter
which defaults to zero and as long as it
doesn't equal the length of the array
that were inserting for the details
it'll continue to iterate through here
using manual recursion so we see the
name of the function here create details
and within it and the success callback
where again
Volken create details to insert as many
child records are necessary but we're
doing this work synchronously one after
the other
I'm just gonna leave these slides like
this because I think it'll be a little
bit easier than toggling back and forth
so once we moved to name functions we
got a whole lot less nesting so we're
avoiding the pyramid of Doom is a
question
mm-hmm the last parameter was not a
callback in the previous example I
showed so it's basically when you're in
oh you know what
good call I'm gonna I'm gonna give you
that one so in this case I am the
implementer of the API and I've
basically made a bad decision here so
I'm gonna update this code after this
talk and switch the position here of
these two parameters I'm sorry no it's
it's almost like a rule that is like a
handshake you know you're supposed to
when implementing async api's follow
these standards but there is no
enforcement
is that the same as one that's correct
it's the same as error so those two
rules that are the that make up the
node.js style of callbacks are not
enforced by any means and in fact the
implementers of nodejs did not follow
them 100% we all make mistakes
all right so some good things less
nesting we could handle arbitrary
collections also fewer lines of code on
the bad side the functions were tightly
coupled the way we had to pass around
state wasn't great and nobody likes
manual recursion that's never fun so
what else can we do well there's a
module in the community called async an
async is a really powerful module one of
the most popular libraries and nodejs
it's really easy to install NPM install
async - has saved to add it to your
packages on Jason and once you install
it you then have access to about well
around 70 different methods to work with
async types of operations some of the
more interesting ones well they group
them into three different groups you
have functions for working with
collections or arrays of data functions
for setting up the control flow through
what your application needs to work and
some of these have similar names they're
just into the different buckets and then
there's a utility set as well but you'll
mostly be using functions to find here
so using the async module at a high
level starts to look like this so now I
have my foot a single function called
post and within it I'm using the async
modules series method this is a control
flow method and I'm passing it an array
of functions and basically what happens
a sync is going to execute each of these
functions in the array for us one at a
time now how does it know when it should
go to the next function well it passes
us a callback and expects us to invoke
it to tell it to go to the next function
and if we pass that callback in error it
skips the rest and instead invokes the
second parameter after the array which
is sort of the function that'll be
invoked at the end or if an error occurs
and it gets passed the errors the first
parameter you can think of async as a
library that builds on top of the node
style of callbacks but exposes a lot of
really handy methods so once you know
how note style callbacks work and you
combine that with the async module you
pretty much have all that you need to do
some of the most intense kind of async
operations within nodejs that's all you
need
it will take a quick dive into that see
what it looks like now the truth is at
that high level you were only seeing the
control flow method series which was
working through the different series of
functions so the first function here
gets the connection I invoke the
callback that I was past so then insert
header can go it inserts the header and
then I get down to insert details now
you're seeing a second method and in
sync or an async you didn't see before
called each series this is one of those
methods that doesn't work for control
flow but rather for arrays and
collections now I'm saying each series
or each detail and the order object
invoke this function so no matter how
many elements are in the and the child
array it'll invoke this callback
function and insert a row into the
detail table when all that's done I can
commit the transaction and if an error
occurs I'll just close the connection
and exit out
the good with a sink is that you can
really keep nesting from going too far
it makes working with control flow and
in a synchronous array processing much
easier than it would otherwise be but at
the same time it might just be another
form of callback hell because you can't
escape these callback functions that's
correct
the question was is every record
insertion a callback essentially yes
because it has to be done asynchronously
because we can't block the main thread
and anytime you do asynchronous work you
have to pass a callback
all right let's move on to the next
thing so basically we're getting into
promises now now promises are a new oh
sorry another question mm-hmm
so the question was if an error occurs
somewhere in this array of functions and
our final function is invoked and passed
the error how do we know where the error
occurred up here well don't forget that
you are in fact invoking the callback
function that async passes you and so
you are passing along the error that
occurred so if that error is in fact
relevant and you want to track it at
that point you could you could do some
kind of execution perhaps you have a
logging framework that you're using and
invoke the error method and the logging
framework to make it more obvious
otherwise you can inspect the error down
here and the error message itself may be
somewhat indicative of what went wrong
in the processing it really just depends
on the situation but there's certainly
options to handle it
you repeat that
you know what let me take this question
after because I'm down to just a few
minutes but I'm happy to address that
after the tone all right so the way
promises work now what we've seen thus
far callback functions are of course a
part of JavaScript and node just has
their own style for working with them
async is its own module but JavaScript
started to advance in fact it was driven
by the community which started to create
modules for abstractions on async work
things like promises and deferreds
became a thing and it was all kind of
tricky and some libraries implemented
these things differently than others and
all of a sudden at some point it became
part of JavaScript and it was
standardized and simplified some we got
these promises to work with now promises
are just objects that can have one of
three states they're either pending
resolved or rejected so they go from
pending they're resolved if everything
is good they go from pending to reject
it if some error occurred and promises
have methods like then and catch then
gets executed if the promise is resolved
so you pass a callback function but then
and it'll get executed if the promise is
resolved rejected invokes what you call
it what you pass the catch and promises
when you invoke then in cats they return
promises you can chain these and
construct a flow of promises and if we
use promises to solve this problem at a
high level this is what it would start
to look like so now no third-party
library what I'm doing instead I'm
calling oracle DB get connection now our
API is with the driver our overloaded
such that if you do not pass a callback
function as the last parameter we assume
that you wanted a promise returned so
it's it's like going from one pattern to
the other and the only thing you have to
do to tell us that you want promises
don't pass us a callback and we're
assuming you want to use a promise API
so get connection here returns a promise
and I use then here to say what should
happen then if we get a connection
successfully and it'll be passed the
connection and then it can do something
with it and that will return a promise
and if that goes successfully then the
next then is in
vote and that can do something after
that now if an error occurs somewhere in
this chain it'll skip the rest of these
bends and go right to the catch function
that I specify here and invoke that
logic instead
question
why does it have why do promises even
have a state parameter or property let's
look at the actual code and see if it
makes sense once we get into it is
that's that's sort of a 30,000 foot view
so in this case I'm calling gate
connection passing the configuration and
get connection returns a promise a
promise has been and catch methods so I
can chain off of this then
and I'm going to end this function
return' another promise right
promises are getting used
ah well the the way I'm using the
promise is simply to use the ven and
cat's methods
why do promises I'm not sure I
understand the question
promises do have a property that
indicates their state but I'm sorry
three correct right why does it promise
not have an executing or running state
an interesting question I've never
considered it before
perhaps there are promise
implementations that do as I said when
promises were implemented in JavaScript
as part of the spec things were
simplified some some promise
implementations have a concept of an
object called the deferred frankly I'm
glad things were simplified some and I'm
not sure that having such a property
would in fact be beneficial but maybe
there's a use case for it I couldn't
think of one at least not right now
when I show you the cat sure though
very quickly we go through then here
here you see something kind of awkward I
need to get through the the details
array I'm using a synchronous for each
loop and I'm building up what's called a
promise chain so I have to kick-start
this chain invoking a function called
promise that resolve to basically get me
a promise that's already resolved then I
go through the loop building up my chain
I take the promise chain I set it equal
to itself plus a bend call and then I
can do my async operation and basically
out you can think of it as I'm winding
up some things that need to be done
asynchronously and then the promises as
they are executed will be unwinding
themselves but they're no fun at all
quite frankly we wanted to see the the
catch I'm going to show you that down
here this is at the very end I'm
catching any air and just logging it out
but frankly I'm gonna come up just a
little bit you're gonna see a ven call
here where I pass two functions the
first if you pass two functions to then
the first is meant for success
the second is meant for error so there's
two ways to handle errors with promises
this is the second way and so what you
see I'm doing here if any error occurs
above I roll back the transaction and
then continue to close the connection
and in catch frankly this isn't my
favorite of the implementations but this
does in fact work so it looks like we're
out of time but I haven't even gotten to
show you async/await I'm going to show
you a single weight in less than 60
seconds the way sync a weight is
basically a new feature of JavaScript
that builds on top of promises so
unfortunately guess what
you can't escape promises and that means
you can't escape callbacks
so you kind of have to learn these
previous things before you can finally
get the async await but here's the
beauty of async await even with promises
I still had about 80 lines of code the
async await implementation got it down
to about 60 now you remember before when
I said that try
catch finally doesn't work guess what it
works again remember when I said that in
a sync loop isn't something that you can
really do in JavaScript guess what you
can do it now so here's an example of
both basically where they sink away you
put the keyword async in front of a
function definition and that means
within that function you have another
keyword called a weight that you can use
now if you're working with an API that
returns a promise basically the way it's
called co-routines the the the execution
of this function will stop right here
it'll do the async processing and then
return the result from the promise this
allows us to write clear concise code
without all these crazy callbacks and
such but you you have to really
understand and know what's actually
happening behind the scenes this is in
fact still executing asynchronously as
it was before
just the execution of the code looks
more synchronous so then we get our
result from the header nice and clean
here is a synchronous loop I'm using a
weight within the loop so it doesn't go
to the next iteration until the previous
one finishes and then finally we can
commit anything goes wrong we'll catch
it will log it and finally close the
connection and we're out
that's correct it's not necessarily one
call back there were probably a couple
of callbacks in that code but ultimately
with async/await
because it builds on promises we can
almost avoid a lot of the callbacks you
would have seen before and start to get
code that reads clear and and still
executes as it was with callbacks there
is more once you've learned those basics
you'll get into things like streams we
do support streams with the driver
there's other libraries such as rxjs
which you may have heard about it's a
completely different way of thinking
about asynchronous programming it's not
like bringing in a library like you know
you might have done with jQuery in the
past but rather a completely different
way of doing things more like angular
would be I will however point out that
although it's getting more popular rxjs
it's still nowhere near is used as async
so learn a seam first and then consider
rxjs perhaps in the future in summary
there's no perfect solution for async
work in node at a minimum learn the
callbacks promises an async await and
then perhaps take them take on some of
these other libraries and in classes of
the streams when they make sense to do
so there any other questions in the back
so the question was when will oh I'm
sorry I'm not with you at all anymore so
do you remember when I showed you this
slide before and I said this is kind of
like a high-level overview of the event
loop and I threw in at the very end the
fact that next taken promises have their
own cues so when you're saying dot then
and you're passing a callback function
to dot then that's essentially the
starting of some acing work and then
when it finishes it gets queued up for
execution
oh I think all the VINs had an argument
oh I see it's it's basically right yeah
yeah yeah right exactly
so when one async function or when one
function that's executing an event call
returns a promise the next then call
will not be invoked until the previous
promise is resolved when that promise is
resolved and the API calls something
like get a connection you'll get the
result of the previous I'll take it I'll
take it after I apologize so for anyone
who I said that to throughout this talk
if you have questions please feel free
to come up here and I'll take them after
the talk thank you very much appreciate
it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>