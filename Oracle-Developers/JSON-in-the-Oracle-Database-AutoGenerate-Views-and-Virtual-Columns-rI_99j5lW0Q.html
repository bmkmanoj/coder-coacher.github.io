<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JSON in the Oracle Database: Auto-Generate Views and Virtual Columns | Coder Coacher - Coaching Coders</title><meta content="JSON in the Oracle Database: Auto-Generate Views and Virtual Columns - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JSON in the Oracle Database: Auto-Generate Views and Virtual Columns</b></h2><h5 class="post__date">2018-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rI_99j5lW0Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in the last video I've shown you the
sequel function JSON data guide which
samples rows from a table to retrieve a
schema summary of the JSON data
obviously sampling thousands or millions
of rows is quite expensive so I show you
another way of getting the data guide
information and that is as part of the
JSON search index so for this demo we
again create a simple table and insert
some JSON data in this case it's a
hundred thousand reviews from the Yelp
data set if we select this we see that
each of these rows looks quite similar
we have a bunch of key value pairs like
name which is for example the name of
restaurant or of another business if we
create the JSON search index we can give
it an option to enable the data guide
every new document every new jason that
gets inserted whorfin existing one gets
updated the search index will scan it to
see if the schema has changed for
example if a new field occurs or if a
data type of a field has changed if we
query this view user JSON data guides we
see that a data guide is available on
the table called demo tab and in the
column JSON data this is the table we've
just created and this is the data got
here so we are we're seeing the familiar
fields the array and then the objects
which tells us there is citi field which
is a string and the length I refer you
to the last video to go a bit into these
details so now if I insert a new JSON
into the database this one has a field
note which has not occurred and if I
commit this change the jason search
index sinks on commit then the data
guide should reflect the change so now
if i query again the view we see that
the XYZ has been added we can also
retrieve the data guide in an
hierarchical format which is basically
the json schema format so let's take a
look at this so we see that this is a
slightly different
representation of basically the same
information we see that X Y Z is of type
boolean and the length is 4 this is some
field we're gonna see later what this is
used for so I can use this to validate
my data this is a schema validator and I
can say I have an object I want to
validate it's X Y Z and let's say I give
it the number 1 then I see an error
message here this is an invalid type it
expects it to be a boolean so if I make
it a boolean we see that the instance
document here is valid with this schema
here so what this allows you is to
create a JSON schema from the documents
you have and use this to validate it if
you have a schema validator now the
feature we build is to use data guide to
automatically create a view since the
data guide contains the path to the
fields and their datatype it's
relatively easy to create a view
definition for it so this happens if we
execute this package function DBMS Jason
create view on path we give it some
parameters which is the table of the
column name if we describe this view we
see that all the fields that occurred in
the Jason have been projected out as
view colors and the name or the column
name has been derived from the field
name and the jason so if we select from
this view we see the data from the jason
instances now as plain relational rows
and columns this also allows us to query
this data with plain sequel operations
so for example if we want to find the
name of businesses in the city of
Toronto and order them by the best
reviews and we would run this query
which gives us the result somewhat
similar to creating a view is to augment
the existing table the table with
adjacent data with virtual columns so if
we describe our demo table then it
basically only has to call
the ID column and the Jason data column
the PL sequel function add virtual
columns we'll take a look at the data
guide on our adjacent and for every flat
field meaning for every scalar top-level
field it will create a virtual column
definition and alter the table to
reflect that so if I describe the table
after this operations I will see plenty
more columns which I can directly query
as well so if I want to find all the
vegan places in Toronto I can issue the
query straight against the demo table
and the predicates here are using the
virtual columns which under the cover
will run against the JSON so these
virtual columns are not persisted and it
seems there's only one vegan place in
Toronto thank you for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>