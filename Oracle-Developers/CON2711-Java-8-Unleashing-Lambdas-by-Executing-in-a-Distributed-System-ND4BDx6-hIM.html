<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON2711   Java 8   Unleashing Lambdas by Executing in a Distributed System | Coder Coacher - Coaching Coders</title><meta content="CON2711   Java 8   Unleashing Lambdas by Executing in a Distributed System - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON2711   Java 8   Unleashing Lambdas by Executing in a Distributed System</b></h2><h5 class="post__date">2015-12-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ND4BDx6-hIM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you for coming it's it's late and
about 5 30 s late it's late for me I
live in Boston this is usually my
bedtime so I'm going to struggle through
this with my jet lag my name is brian
oliver i work as an architect with the
coherence engineering team in oracle I
we did quite a bit of work with a Java
team and if you were at last year's open
world java one you would have seen a
keynote and I got on stage for a few
seconds and we talked about doing some
cool stuff at lambdas and streams and
this is really the first part of a
two-part series if you can get into my
other talk which is on thursday i'm
going to talk about streams but today
we're just going to focus on lambdas and
you would imagine how could I possibly
talk for 45 minutes on lambdas and
there's lots to talk about I'm going to
try my hardest to put code on every
slide and i think i have about 30 slides
and i have probably about 10 different
demos I'd like to do so and you're going
to ask questions you have lots of
questions and I'd like to sincerely like
to answer every single question but
unless we get a time machine it's not
going to work very well so I've put my
email address up there which is probably
really bad things to do so I'm
apologizing up front that I may not get
back to you in any any short timeframe
but we're doing a we're going to do our
best okay so let's do surveys because
that's what you do at a start of a talk
the speaker says hey let's ask some
random questions of the audience who's
tired I'm the only one I guess a few
people fight okay who's here because the
word java the term java 8 was in the
title oh this is a java 8 talk yeah not
many who's here because it says lambdas
whoa who knows what a lambda is okay
most people do we're gonna do a little
bit of lambda star okay I one last
question who wants to know about
distributed lambda
ah that's better okay these things are
really very very cool and i can honestly
say this is probably in terms of the
talks are probably going to about a
hundred talks at Java conferences this
talk to me is that probably my pinnacle
talk okay maybe my Thursday one might be
better but we've spent an enormous
amount of time researching this
designing this my background has been in
functional programming languages for
over 20 years and being able to deliver
this on top of Java is just fantastic
and the good news is we're making almost
all of it available to the java
community and in a really nice way as in
the past would have been hard and
expensive to get a hold of this stuff so
let's get started so I i have an
obligatory staff harbor statement if
you've been to any talks with oracle
employees are talking this is required
reading and I trust that everyone here
will read that ok moving on ok so the
agenda says we're gonna talk about
lambdas briefly this is not a course on
lambdas we want to get into the
distributed stuff and then we're going
to talk about remote functional
interfaces and remote lambdas and then
we're doing demonstrations and then
we're gonna talk about challenges and
limitations in the abstract we talked
about getting into bytecode you know we
looked at this and thought that's
probably not what we want to do so I'm
leaving out the bytecode and I think
most people will be happy with that if
you want to talk by code come and see me
afterwards and buy me one beer probably
ok just a lot of Pierce I've got to give
kudos the coherence engineering team I
had this crazy idea about doing lambdas
and Java right on top of coherence and
the Karen's engineering team and really
built this so I'm demonstrating and
talking about a lot of things that a
whole team worked on and it's
unfortunately can't be here but there's
you know huge kudos to them I say that
because they're recording me and if I
don't then they're not going to buy me
beer so let's go and then we'll talk
about next steps
so introduction to lambdas okay so
what's cool about this so okay it's a
defining feature of the Java platform I
think everyone wanted it it's been in
every other language scalars got it and
functional programming languages got it
and they're really cool but for Java it
allows this hybrid sort of
object-oriented functional programming
style of development and what's nice
about it is giving developers a
functional style is very good when you
have problems which suit a functional
style of programming and you sort of
know them when you get used to it you
run into them versus having to use
imperative style programming and parody
of object-oriented style programming
when you want to really use functional
programming and vice versa so the
lambdas you may not use them all the
time but they give a really nice
capability when you need them but
ultimately what it does let's allow to
pass code blocks of code if you like as
data and and in reality you can pass
code as arguments and if you really want
to be fancy you can actually return code
so you can say hey function here's some
parameters and actually get it to return
some code which you can then pass on an
execute and use later so the classic
example I'm gonna sit down a little bit
if i go to sleep just someone throw
something at me so the classic sort of
example is you know i've got a you know
some sort of map here and I've got some
candidates and I you know I've decided
to use a u.s. presidential election
election candidates as my topic of
choice I think last year i'll use disney
characters and I have no affiliation
because I'm not allowed to vote so but
it would be fun so in lambdas in Java
ray what we can do is we've got these
really cool new methods i can say
candidates for each and then here is my
lambda so those of you the four of you
who haven't seen them before this is
what they look like I have my arguments
here k and v
because I'm dealing with a map which has
keys and values and I have this new
special special operator thingy which
says write execute this thing on the
right hand side so for each of my
candidates passing k and v and then do
this so that's just going to output can
be and we'll run this a little bit you
know nothing nothing super cool about
that but in the past he's sort of what
you would have had to have done is
probably use anonymous inner classes and
we'll talk about that in a minute but
what the cool thing is about lambdas is
that one was just sort of stateless one
you can actually make them sort of
stateful and you can do what's called
closures or lambdas are closures and
what we're saying here is that you can
capture the surrounding arguments so in
this case here I'm saying well I want to
output Mike you know my candidates you
know their name say and in brackets i
want to say oh if a Republican it's
going to be our it's going to be a
Democrat d for Democrat and but in this
case here I'm I've said okay I've
defined there is my curse at one it is
i've defined party here and then i've
used that variable down here so my
lambda is using a variable which is
actually defined outside the lambda and
the cool thing about lambdas is it
captures these things we that's the term
we're using so it captures them and the
lambda is a closure which represents the
function plus the environment that it's
running in cool these are really
important concepts and we start to talk
about distributing these little guys
around the place
so how we used to do this well we'd say
basically anywhere we would use
anonymous inner classes or we'd start to
write inner classes we can now use
lambdas so before we would write
something like hey executor submit
here's my new runnable on it is in line
and it's beautiful but now I can
actually say hey submit and I can say
well in this case my runnable isn't
taking any parameters just like my run
method isn't and I'm going to I'm going
to do this now if I go back a slide
you'll actually there's some some cool
things to note I left out the types of k
+ V because Java can infer those types
based on the type of the candidates type
right so all this lovely generic stuff
that we that we put in and we're
fighting at some time actually starting
to become useful so we can infer the
types you'd have to specify them so it
becomes nice and nice and clean it's
nice and consistent and somewhat some
people would argue that it is more
readable I think the notion of
readability is in like beauty it's in
the eye of the beholder so let's let's
not talk about it you either like it or
you hate it and I can show you some that
you'll absolutely hate but it's a start
so okay and to basically any interface
inside of inside of Java that has a one
method that isn't implemented can be
used as a functional or call the
functional interface which means we can
use a land or in any of those places so
runnable is defined like this in Java
and we now have this new annotation but
as it has a method that isn't
implemented java infers that when you're
using a lambda against this type that
you're implementing that method and it
infers all the parameters and refers
that return type for you so makes it
nice and consistent so everything's
great
but and this is the big but this is
where we start so can these things be
distributed and and how can we like
invoke them I want to distribute them
and invoke them and and why would I want
to do this at all well the number of use
cases now where you have a piece of code
and you want it to run somewhere else's
is a massive right any sort of data
processing where you have to process
such a volume of data that you can't fit
it in a JVM and you want to split it up
a bit in some notes ql solution or on a
file system or like anything that won't
fit in a JVM you probably want the code
to run somewhere else and often the code
you on a run can be quite small I e
lambda so being able to distribute the
distributive as a pretty cool thing and
you notice like my think Amazon last
week talked about a new lambda service
they were introduced try who lambda
service it's a it's interesting it's
catching on right people want to be able
to say here is my day to run the service
against this stuff okay so but can we do
this like what does java do well we run
into the first challenge and this is
where we went to the java team and went
what did you guys do you've got lambdas
but leto distribute very well in fact
they don't distribute at all and the
challenge is that basically when you
implement a lambda unless it's
explicitly told it's not serializable
and if i want to ship these things
across the wire and java i have to be
able to serialize them I've to serialize
at least their state or their parameters
right I have to be able to serialize
them over and I have to go to serialize
the result back but cool what is nice is
that you can cast them if you want you
can say here is my runnable i want
something that's runnable and
serializable and you can do this so
who's seen this before right this is
like hardly anyone has seen this right
you can do this with generics as well
you can say hey this type T
extends this and something else so just
by doing that we now java when we
compile it creates a lambda that is
serializable and at the bytecode level
lambdas are different serializable
lambda versus a regular lambda are
different they have different bytecode
and unless you tell the compiler which
you probably don't do you always get
stuff that only runs in a single JPM you
cannot move it right and one of the nice
things about lambdas is that they're
anonymous right they don't have a class
name so with an anonymous center with a
normal class I can say hey what's your
class I can find out where you are I can
serialize the class name I could do a
bunch of tricks to try and get the get a
class to move across the wire even if it
was completely stateless I could find
out the name of the class i can send to
the name of the class to another machine
or a service or the cloud or whatever
you want to send it to and then say hey
this is the name of the class
instantiate me one of these and just run
it but lambdas don't even have identity
so we can't really even do that well
they sort of have identity but it is so
weak you should never trust it and
there's a really awesome thread on the
Java language forum about this and it's
about two miles long if you want to wade
through it and so it's it's a bit of a
challenge so if we're going to serialize
these things well what we don't want to
do is make everyone do that because that
would truly make the use of lambdas
quite horrible so inside of coherence
not even sure you can see this I can't
zoom it in but inside of coherence who
have this little help a method which
lets us do some byte code inspection at
runtime of what's going on and we can
find out in this case we say hey what's
the type of our and it says hey it's a
serializable lambda and the capturing
classes and what is capturing class
means that's the class the lambda is
defined within and what what function
interface does that implement art
implements runnable where is the
implementation
it's invoked static examples are that's
the name of the lambda and what are the
captured arguments there aren't any in
this cases so we we built this theme to
allow us to do all sorts of bytecode
magic and this I thought I just show you
that because it was cool so so what's
the challenge I could I could cast
everything to serializable every time I
wanted to use it but that's a really bad
solution and let's just look at what job
rate did to us we've got all of these
new interfaces every one of these is
probably a candidate to go across the
wire to a device the cloud another
server stored in a database right once
you serialize something you can put it
anywhere right you know I could create a
lambda and put it in a database and then
come back later take it out of the
database and run it right I may put it
in a JMS queue JMS picks it up another
client picks up runs it right I may send
it over the wire over the air to a Java
ME device which then runs it so we have
all of these things here which are
probably things that you would implement
using you you definitely implement these
if using streams you would absolutely
touch almost every one of these things
but none of them are serializable so we
have a bit of challenge and a hands and
of course we've already mentioned our
old favorites so none of these are
suitable to be used in a distributed
environment so what this means is if you
want to do any type of parallel
distributed computing with lambda like
things you can't use until now the Java
language because the Java platform has
defined everything to be local oh I know
you can do it as long as you cast
everything to serializable and we're
working with that right yeah let's
imagine what okay don't like so what
have we do so one approach was one one
thing we did in the coherence team and
we're going to talk a little bit about
coherence and
minute for those of you don't know what
it is and we're not going to talk too
much about it but i'll give you a bit of
an idea what we did was we took every
single interface functional interface
that's defined in the Java 8 platform
and created a remote above it so this is
actually code out of coherence we have
this class called remote and we have a
thing called a remote function and we
said our remote function extends Java
function and serializable so this means
every single part of coherence where you
would expect function you can use remote
function and that automatically makes
everything serializable beautiful which
means if you're writing lambdas you have
to do nothing right which is good and we
did it for all we do it for runnable and
we did it for callable and we did it for
predicate and like we did the whole
thing so this project took us a couple
of years not you do we have to do it
we're to test it so I'm going to have a
little a mine you'd interlude here so
let's let's do a very quick demo and see
if this experience got to come up okay
you've got to go to the terminal right
so so what is coherence I'm going to
just do a couple of minutes so coherence
is a java library predominately for you
guys it's a java library you put it in
your classpath and what it does it lets
you cost it together jvms right it
classes them together really really
nicely it's been around if you haven't
heard of it's been around for 12
something years it can run on tiny
clusters it can run on massive classes
we're talking thousands of servers and
it looks and behaves exactly the same
but basically what it does is on top of
that cost to we implemented things like
map and so it gives you just completely
distributed map but we also it
implements je cache which I was a spec
lid on it implements the J cash back and
it implements a whole bunch of other
things as well but ultimately if you can
use java.util.map you can use coherence
and it will do it in a distributed
manner so everyone's heard about cool
perfect hashing
algorithms that you see in no SQL stuff
like coherence has been doing that for a
long long time and I'll so this is a
little demo this is coherence demo it's
a single jar it embeds coherence and
some few other things in this demo it's
storing a hundred thousand objects and
it's doing a bunch of aggregations
because when you have stuff in a map we
can do streams against them we can do
aggregate them we can do all sorts of
cool analytics and as you add more gbms
what you can do is do stuff in parallel
so I can go down here and so I'm going
to add a new server and you'll see what
happens I'm my servers going to start to
come online and in August gradually like
start sharing the data between the two
servers okay so I've just scaled my
system out while it's running your ad
just can add service like payment system
running right I need to double my
capacity just start adding JVMs they'll
cluster together no need to take it down
I need to reconfigure it just add them
single jar so we have to do and so we
can add some more service and you'll
notice here basically we had this sort
of aggregation time it dropped in half
it was about 400 milliseconds and now
it's around 100 milliseconds we had a
spike here because the aggregation at
that time was delayed because we're
scaling it out but once it scaled out it
just carries on so as you add more
servers you had more processing capacity
you add more network bandwidth you add
more memory all of these things are good
for doing things in parallel so that's
what it's doing is just running some
servers and it distributes the data
between the service and you as a
developer don't have to care you're just
using map you're just writing something
against right stream running aggregation
run some process against map as the
service come up you don't get any
exceptions you have to retry it's all
done for you so very very simple and you
can do things like you know I want to do
a bunch of updates I'm going to update
my portfolio and going to say well I'm
going to want to stop this over
so you know I stopped the server and I
still have the same amount of data and
it's still running and it recovered all
the data so it's a bit like rate it's a
bit like raid inside the JVM for your
data so ok enough that's off so that's
that's all cool um we can we can kill we
can kill this so that's been so you've
got an idea coherence is a platform
which implements map and lets you scale
it out and it's clustered and I might
run it anywhere we can run into cloud
run it locally run it my data center I'm
running on my notebook okay do two digit
okay so so we said we implemented all
the functional interfaces and but that's
not enough so for example the map map
map has defined this new method called
compute if absent and you pass in a key
and if it's if it's absent it will
evaluate that function and it return
some value and remember I said that
function is a java function so that
thing's not going to run in a
distributed manner unless I have to
unless I cast it to serializable which
is what we don't want to do so what
we've done in coherence and and the
implementation of mapping Curren is
called name cash we basically overwrote
overloaded that method so we overloaded
that method and said computer if absent
takes a remote dot function so the cool
thing is that Java compiler says ah i
see a more specific method so if you say
hey map compute if absent and say here's
my key and here's my lambda the compile
goes i think you mean the more specific
method here in fact that's exactly what
it does so it says I know you want to
call that lambda meads a remote function
which naturally causes the compiler to
generate a serializable lambda which
then we can send across the wire we can
send across the wire we can store own
desks we can put on a queue you know
what we like so thanks to the Java
compiler that one rule and overloading
lets us avoid ever having to write
serializable lambdas so now for an
enormous number of demos okay so the
best way to demo is from the ID eat and
it's so so I have all of the Java demos
so for example if I run the if I run
this one my for each we can see in my
demo
rated my candidates and I think I've got
most most if not all of the current
candidates and I can say hey candidates
for each and output their output the key
and value and we can see who is all the
key and value great brilliant nothin too
nothin too genius about that and I have
the version that uses closures and not
going to run those as well but in
coherence so we want it to be the same
but it needs to be a little different
cuz you don't just sort of new upper
cash we have to get one so there's a
there's a factory which lets us get a
typed cash we should we should zoom in
on this right let's we don't need this
and I've created a candidate object here
and that all that is is just some it's
just a very simple object which has a
simple class which has the name the age
and the party that the candidates
affiliated with and it's got some
getters and setters so it's a standard
Java Bean okay so I've written
everything is test so every time I run
something it's going to set up my cash
get my candidates cash and so now we
have for each so let's um let's look at
for each so here's my first question
when I execute this for each where
should that lambda X run in my demo my
previous demo I put all of the data gets
spread across the cluster right so in
this case the candidates are going to
get spread across the cluster I have all
these JVM is running and each JVM is
going to have a few candidates in it
because we've petitioned them and
they're all spread across and here I say
right candidates for each Canada I want
you to output this so first trick
question where does that lamb to run
does it run inside my test or is that
lambda going to run inside of the JVM
xin my cluster which i haven't started
yet but i'll start one in a minute
remote okay so we only have there's two
options it either runs it was three
options it doesn't run at all but
something that would be embarrassing and
i would be buying beers if that happens
i shouldn't say that
demo God's might not be with me today so
remote is one the other one it's
obviously local it's going to run in the
same jvm so let's do a vote who says
remote mmm okay it's prob about thirty
percent it says locally that's same so
the other thirty percent are or asleep
or just don't care or don't know and it
is very hard to know it is very hard to
know and we argued a lot about this a
lot because there isn't necessarily a
right answer so for those of you who
said let's let me let me start up some
current service so these are just just
sort of headless JVMs and you can see it
is just going to run run down here give
it a second it forms a cluster and I'm
going to run I'm going to run two of
them just to just to show you and then
then let's run our run our for each I
did it that's right now for each and
let's see where that system out occurs
so it occurred locally it occurred
inside my tests and in my servers
there's nothing now you may say well
maybe the data is not in there I trust
me it's in there I'm going to prove it
too but in this case we thought that if
you're going to call for each on a map
it means you're probably doing something
locally you're probably going to output
something locally probably processing it
locally so our implementation of for
each matches what map expects if you
call for each on map it does stuff
locally on the map now so it's
interesting what happens if this cash
this cluster is backed by a terabyte of
data so we do we bring the entire
terabyte of data into your jvm then it
goes though it's all right out of memory
see you later well we don't we can we
can stream it back and we can let you
iterate over them and so so it lets you
you
use Java API as though everything is
local but it could be spread around the
place so so the people who said local
when you win you get nothing from me but
you win I told you you want people who
said remote bad luck but I understand
where you're coming from and I fell into
the same trap so you win as well and
those who didn't know you also win
because you are smart enough because you
didn't know we're all winners okay so
let's uh let's let's see something else
so so Karen's has this um has this
method called invoke and if anyone's
ever used or looked at Jay cash je cache
has the same thing and it's in je cache
because it came from coherence so same
API same semantics but coherence let's
use the lambdas whereas je cache doesn't
Lee use lambers so here I can say
candidates in vocal and I'm going to
invoke against each entry and I can say
print a so-and-so is here and return
null invoke all is a lambda which takes
an entry and return some value now in
this case we don't want we don't care
about the return value so that's all
we're going to do so in this case when
we run invoke okay who said who thinks
it's going to run locally good good who
says remote everyone those who didn't
say anything you are definitely wrong
okay so now when I run so the cool thing
is you can start to see what what what's
happening in my example here nothing is
output in my test but if I go to the
servers I can see Mick Huckabee's over
there right and and over here we can see
near Hillary's on this server right so
Karen's has taken that map its
petitioned and it's put across the
service and I could do what I was doing
before I could kill the server and start
near one while everything's running but
that's not the point you want to see
that what we've done here is we've
distributed data across servers
and this is standard java and we've used
standard java lambdas which I didn't
have to write serializable against and
we can ship them across the wire and we
can execute them okay now amazon i get
to have a poke at amazon here amazon
just announced lambda service and every
time you want to update the lamb do you
have to package your entire system gzip
it up upload it to amazon restart your
servers does that sound like something
you want to do yeah I can just use
directly use standard Java and just run
it in place while the system is running
oh you might be running coherence on
Amazon you could connect and we'll ship
it up for you so let's say let's go
through some of the other things so so
who cares well this is just we've run
stuff locally runs up remotely why is
lambda is important well let's look at
the compute method so the compute method
basically lets you change an entry in a
cache so the nice thing is in map and
particularly concurrent map when you say
compute it lets you change and entry
without having doors crazy
synchronization locking nonsense in a
distributed system it lets us take that
lambda ship it across the wire and
change that entry wherever it exists
inside the cost of the cloud or whatever
it is right it means I don't have to do
this go across the wire lock it get it
update it put it back unlock it and
traditional sort of data grid type
systems that don't use entry process
takes at least 14 Network round trips
and deport in network trips seven round
trips to do that which basically can be
more than a millisecond with this we can
do the whole thing in one trip and if
you're doing backups is a bit extra but
you can the point here is you can use
standard Java standard lambdas and
efficiently update data in place across
a cluster so
my understanding is Donald Trump may or
may not be Republican and there's a full
full an argument about that so I thought
well I could set him to become a
Democrat and that will probably cause a
riot so let's say he decides to become
independent so let's look at this now
remember our friend Donald's in one of
these servers and the cluster are still
running by the way so let's let's run
this test and what we've done is we join
we go over and we can see that where is
he Donald Donald to become independent
okay and so we've shipped the lambda
over the wire updated Donald the Donald
beam at sitting in that server and then
come back all very good and so in that
case we we had you know our lambda is
stateless but I can do the same with a
closure and so here I could say well
let's let's actually make him Democrat
and let's run this
my cluster still running the background
and now we can see we're ready to go
he's democratic that's really cool hi
mom whenever hear that I'm at my mom's
calling so I made in a Democrat oh you
know what we could do we could also say
candidate he's lied about his age sigh
let's let's update his age and let's
let's make him independent again and
it's just run that and now he's audibly
down the body was 71 he says he's 70 I
think he's a bit more like 71 um and
we're made of independent does anyone
notice i just did
I change the lambda on the fly so I have
a cluster that's running I have a system
that's up and running I have all this
data in it and I actually in a client
application I change the lambda because
I could have another version of that
client running somewhere else with a
different lambda and i change that one
completely right so question is how does
it notice the class across the wire so
let's step back a little bit when i
started the two servers they have those
two servers have the same class path as
my examples here so the identity of the
lambdas the bike code for the lambdas
everything I've been doing so far is
completely consistent those servers are
running right the tests are running
everything is identical I just changed
the test test case here so now the test
classes and byte code is different to
the stuff that's in the service but it
still ran so how did that happen so what
could we do well we could reload we
could restart the apps to fix up the
classpath we could redeploy who loves
redeploying stuff uh you know I just
think reader there's a whole industry
I'm sorry to say it's probably a whole
industry of people who are employed to
redeploy stuff it's generally a bad idea
right hope so what do we do as I said we
do a lot of bytecode magic we we look at
the lambda we look at the capturing
class and then we go we're just going to
look at the bytecode so we actually look
at the bytecode we re-engineer the
bytecode we have a very clever algorithm
of understanding what the bike code is
we send the request to the service and
say I'm running this and they go who
don't have that mind if you give me a
copy I'm going to all share it with my
other friends and then we give them the
other bytecode and then they instantiate
it and carry on because my other example
could be running with the previous
Lambert now if we follow
the standard java platform way of
identifying lambdas which is virtually
impossible because there is no identity
so what we've done is we can identify
them by combination of things byte code
is one part of that and it's a clever
little algorithm but the point is what
does that mean you can have a system
running and change the behavior of the
system through lambdas without
redeploying it is this cool really cool
do this is better than amazon's lambda
service yeah I didn't have to zip
anything I didn't have to upload
anything and we we do all sorts of all
sorts of stuff to make sure they're
consistent and we care we of course we
cash them and we clean them up and so on
ok cool so other other things ok my
watch I can see my watch so we can do
closures but there's there's a few
there's a few problems with this then
there's a few rules that you have to
have to look at the problem with this
style of development while is completely
possible having a closure it makes it
very hard to read so we thought about
this a little bit and said well if
you're going to do something like this
what you should do is is make a function
that takes the arguments you want and
builds the lambda and returns it so in
this case we're going to change function
party remember I said we can have
functions lambdas can be returned as
values so here I'm creating a lambda and
I'm returning it and I'm capturing here
the closure completely encapsulates the
locality of the variable party party is
only defined there we know that it's
going to be effectively final it's much
safer to use you create these helper
functions static functions in your code
base they'll let you define these it has
no effect on performance as far as we
know and far
we can tell from looking at bike code
but it makes a huge difference to code
readability because you can either look
at that you can either look at something
like this piece of code or you can look
at this right so using the ability and
not many people do this as i can tell
use the ability to return lambdas from
functions to your advantage because you
can create helpers to make them more
readable now of course one of the
problems with compute is with map
compute returns the previous value which
sort of is bad imagine in my cluster in
my cloud I have these huge graph objects
and I'm sending lambdas over them to
walk the graph whenever I change part of
the graph I don't want the whole graph
returned to me so again java.util.map is
defined to run inside a process your
data is already there returning a
reference to the object is free in a
distributed system sure you can use
compute but you don't want to return the
whole thing so the coherence you have
this thing called invoke and we saw
it'sit's brother before its sister
before so here I'm going to say look
invoke against some entry get the value
from the entry set the party change it
and I can return null which means the
return has no payload when I go across
the wire now if you think about this I'm
going from my mobile phone or mobile
device to a thing and back I really
don't want my mobile device to get the
entire graph I'm just changed to coming
back so coherence has some other methods
which give you the same capabilities as
Java but with a bit more with
optimization for being across the wire
and again we can use the same process
something here so I can go through all
of these things but you can see I can do
replace or so if i want to make all of
the candidates names uppercase that's a
standard java java.util.map
and you know suddenly they're all upper
case which is all good and that that
actually goes out any of the mutating
functions that you have in map we
actually send the lambdas to where the
data is we execute it there because we
have concurrency control and then we
return the results right so mutating
functions we do in the grid because if I
have 400 servers and I have data spread
across all those 400 I can do all four
hundred concurrently and if I have lots
of threads in those servers I can do it
with even more concurrency right and the
talk on Thursday when I talk about
stream parallel stream processing that's
sort of cute but imagine doing parallel
stream processing across an entire
cluster which is doing stuff in parallel
so the throughput is massive and the the
point here is again standard Java
function standard interface standard
lambda okay so and we can do all sorts
of stateful things and on the coherent
side you know I you're most likely going
to end up with a lot of data in some of
these sorts of maps so we've added the
ability to index things so on in I have
this map and our there's parts i want to
index cuz on a search on it or I'm going
to sort on it so i can create basically
say hey add an index and in this case i
want to index a candidate's name and the
candidates age and then I want to do
things like saying hey candidates give
me the all the candidates with less than
age of 55 so here I can take a defender
method if you like a method reference
and I can take that across the wire as
well all right I could just send that in
send that across Iraq and Syria Liza
execute it locally collect the results
send it back but I'm not going to go too
much of that because I've got a whole
talk on just how to do this with streams
okay let's uh let's look at let's try
and wrap up how much time of it up
so one of the biggest challenges we had
is obviously serialization we talked
about it and we worked a lot with brian
and brian steam and he he just summed it
up so well for us because every time we
try to do something had a sense of
across the wire we had to serialize it
and we discovered that a java platform
itself doesn't didn't make it
serializable which meant a lot of extra
work for us and and they did apologize
but they said bad luck so so weird to do
a lot of work but he said serialization
is this funny thing it's a gift that
keeps giving and he didn't mean a gift
in a good way it just it traps you it
catches you every time you sort of try
to move around in a distributed system
you know even in terms of version
compatibility between classes of
different clients that may be running
different versions of Java or working
against the same data pool or data grid
so that sort of stuff wasn't wasn't easy
to solve so Java provides a bare minimum
unless you go outside the JVM you would
never hit this stuff and if you go
outside the JVM you would hit it all the
time but we've done our best I think
we've done an awesome job at making sure
you'd never never run into it as you
sort of mentioned a little bit about
lambda what they called lambda stability
in terms of its names and and we provide
a solution for that so you don't have to
ever worry and I think the important
thing is I sort of demonstrators like if
you're running a system that has you
know is backed by coherence which may be
back by disk last thing you won't have
to restart sucker like you can't take
the system down but you want to change a
single lambda which is a single line of
code right so even restarting a massive
JVM could be problematic so we've we
help solve that so of course problems
closure serialization when we see
realized something basically anything
that your closure your lambda use you
shouldn't reference fields or methods in
the class
certainly you shouldn't try and touch
things that aren't on the might be on
the client and the server so lambdas
effective let you write any Java code
you think about you could reach out to
anything whatever you reach out to has
to be on the server it has to be
serializable you have to contain it
that's why we said use a factory to help
do that the other surprising thing is
never nest them so it's interesting when
you start using lambdas you end up
starting to nest them and that's why I
sort of had that comment about
readability of lambdas nested lambdas
can look pretty bad so though so for
example coherence has this ability to
extract values based on method
references and that this looks quite
quite ok but so this lambda here we're
okay with but this reference here is
embedded inside another reference a
method call and we can't get to that so
what you actually have to do is declare
it outside and you say hey um I
extractor is this function interface and
it just so happens this function
interfaces promotable and so the
compiler goes our you've got a method
reference but it has to be remota ballon
which serializable or compile goes i'll
create you a serializable method
reference and then it all works so yeah
something have to do and this is not
going to be a this is not a carrot
specific thing this is a java platform
thing if you start to serialize lambdas
even if you do it yourself by casting
them as soon as you have lambdas that
aren't Cyril serializable embedded in
other lambdas it won't sore eyes you're
going to run into it all and you get
really cool stack traces would be like
and you ask the java team what does this
mean so summary distribute lamb is just
a rock it's like they absolutely rock if
you're doing any sort of any sorts of
processing you know anyone's using no
SQL that sort of stuff it's like imagine
just doing lambdas against no SQL using
regular Java isn't that nice
so this is exactly the sort of things
that we're trying to do at Oracle the
things that we want to provide in the
platform you know why should you have to
learn another language another API
another set of tools and compile them
and manage all those versions why can't
you just use the tools that we have that
are built into the language so if you
want to learn distributed Lang but
Landers you should just have to learn
lambda learn lambdas and that to be it
coherence is the first product that we
know of that lets you do this and it
solves a whole bunch of things and lets
you run them locally and without without
restart so next steps as I wrap up so
coherence it's a commercial product
right and so oh well so yesterday oracle
announced the 12 to 1 release and they
also announced not that you'll probably
have heard about it is that all
development license and test licenses in
our free you can just go and download
this and play with it okay no one's
going to come after you so even if you
just want to play around with distribute
lambdas it's off you go it's all there
if you want to use if you're a Java
advanced user it's now included with
Java advanced so Java advanced is like a
support version of Java which has all
these other cool features and we just we
threw in coherence into that so you can
actually now start using coherence with
Java advanced and it's incredibly cheap
like it's just ridiculously cheap and
you get the benefit of giving like
getting all the other Java Runtime
management tools and Java support and
like it's a very very good option you
can go and download it from a few places
you can also follow us on usual social
media stuff there's a bunch of YouTube's
about coherence and there's a whole
range of new stuff coming out there's
like our long talks on each of these
topics so you can
watch them at your own at your own
leisure and I think that is it I can
have some time for questions unless
they're kicking me out and this is the
last this is the last talk in this room
so we can hang out as long as you like
so so thank you for coming yes ah
distribute exceptions well exceptions by
default are serializable if you
implement an exception and you somehow
make your exception not serializable
then you're in problem they are in
trouble but we managed to implement the
Java contracts for C realized what for
exceptions around that stuff so for the
most part we catch them and re throw
them the incoherence if you throw an
exception inside an entry processor
which which were the invoke methods will
actually rethread as a runtime exception
and the reason we do that is because
often the client is not java so if you
imagine you have a JavaScript client
invoking something inside of Java
against a Java object model javascript
has no idea what it is so it gets
returned as hey this happened and same
with nad and C++ and rest and memcache
and all the other API so sorry
yep yes the candidate object was
available in the classpath for the cash
service yes yeah that's right yeah so
the the PO Joe if you like the beam
candidate being was actually in the claw
original class path that was used when
we started all the servers you do in
this example you have to but you can
switch to a different type of
serialization for example Curren is a
thing called portable object
serialization and then you don't need
them at all but you can't then use
method references right but we have
what's called like we have this path
based reflection through a portable
object so we can traverse a portable
object not even knowing what the classes
and we can reflect and modify values and
even modify bits in the bitstream
without having to change the whole graph
so serialization is the gift that keeps
giving right but that's that's what
you're fighting you're either yeah
full lambdas yeah that's a general
lambda policy though that's not a we
didn't we didn't say do that that
lambdas basically said look if you're
going to write lambdas generally make
them small making concise make sure the
closures are local don't ever so that
list of things that by recommendations
and challenges all but one of them are
the standard Java wants the one we added
was make sure your stuff is serializable
and by serializable i mean for coherence
however serialization is configured like
Pete if nothing's configured it's Java
civilization but it could be avro it
could be your custom one so whatever you
have make sure it will serialize with
that thing so high yeah all the wrong
peers yes
yes and hence the name coherence so yes
and you can probably search the pattern
database to find some of those some of
those techniques because they fall out
they fall outside the purview of Java
platform and even Java e's tries not to
mention so much stuff about
serialization and compatibility but we
have to worry about it like we have to
worry about it so right yes yeah yeah so
you yeah and it's also so you know in
the example at the end I sort of said I
have a function that returns a lambda
you can also have the cluster return
lambers back to you so you imagine I go
over to do a request and the request
says I want them yeah like yeah I'm like
I send you a request and you're in the
cluster and then you instead of sending
me data back you say i want you to
execute this so you send me back some
land or a runnable or something and then
i go mike i'll run that and that
includes the bytecode and the closure
comes back to me and think about this
and so if I'm a mobile device or I'm
like an Internet of Things device I want
to do an update on a change of setting I
want it like you know the you expand
your mind as to your running in the
cloud I'm a embedded device in a robot I
contact you and then you go hey you're
out of date you send me back a lander on
update myself or golf and request some
stuff right and that's why Java 8 is
important job right emma is important
like all of this stuff it's very subtle
at the top but the complexities that
we've solved very simply and you just
use the land standard lamp java stuff
right sorry the back
yes yes because we go here it's our self
and say we coherence doesn't care it's
just stuff ously in fact you could you
could create a map with keys backpack
the keys could be lambdas the values
could be lambdas and incoherence is a
whole eventing framework so you could
put whenever you do anything to an
object you know inside of coherence you
get events so you could intercept like
when value arrives and go arts or lambda
I'm going to execute it locally and my
server and then whatever the value is
put that back in like it yeah yep yep
yep
Yeah right yes there are options we have
to like optimize that but you imagine
when I send a lambda to the cluster each
member in fact each partition deals
because its petition it's not just
members the members have petitions and
each petition can deal with the lambda
in its own way so they can all be run
concurrently but that whole petition it
can be dealt with atomically getting
back to consistency so we can then run
all the lambdas atomically and then take
all of those backups and in fact we we
have the binaries we can do a delta of
the backups and then we just ship the
deltas and that's all like you just
choose that's the optional one yeah we
could we could actually just run the
Land Rover as well but the interesting
thing is imagine that the lambda is
bigger than the value so you then go
well okay how much was chained you
actually spend compute time to work out
and in fact our Delta backups don't
Delta backups we have sort of a curve as
to when to turn Delta's backups on
because actually calculating the Delta
is slower than actually just sending it
over right and the same same rule
applies to lambda as well yep
you should come to my Thursday talk
because we're talking about aggregation
and streaming like that's exactly like
yeah we can do them in parallel you can
do parallel with in peril on the
petitions yeah yeah no you can use
slammed if you're only executing it
locally then that's fine but imagine
imagine I gotta have a lambda I just I
just have a lambda and I make it
serializable and I just put it on a JMS
queue and i can i can put put any
bytecode any bites in a JMS queue so i
can just create an object right stream
right my lambda to it it's not going to
send the bytecode but it's going to
serialize the lambda request and then
someone else can pick it up but if your
lambda is nested and and the whole thing
is not serializable you're just going to
hit the wall so yeah you're going to
have problems but we what we've done is
we because we overloaded all the Java
methods as soon as you swap out map for
name cash or the coherence version of
name cash which is the same API the name
cash extends map so it's completely
compile-time safe to do that soon as you
swap them out the compiler will actually
choose the remote versions and that will
make your land lambdas naturally
serializable it just won't fix the lamp
the nested ones sorry yeah
I I would honestly if I was going to
read lambdas me I just pick up the Java
language back but that's pretty hard to
read it can be hard to read I would just
google introduction to lambdas thinking
yeah there are two parts the lambdas one
is how to use them in Java but the
thinking about them in functional
programming language is actually the
more important book there's some really
good books a really good book on
functional programming by Phil wobbler
it's like 30 years old it's
exceptionally good book if you can find
it it's it's by Phil wobbler you should
be able to look look him up on
functional programming he did it so it
has a bunch of concepts which Java
doesn't yet have which hopefully will
have one day but that's where I learnt
functional programming it's a beautiful
book it's absolutely beautiful sorry
yeah yeah
how do we do it yeah so we use similar
techniques to the Java compiler
coherence itself has its own
disassembler and its own compiler built
ins built into it we also use ASM which
is what Java uses internally actually
uses ASM for doing to do all the lamb to
work and so we we use that as well so
so yeah well I can't give away all the
secrets because the whole patent on this
but basically we have to look at the
lambda locally and we don't know if the
server has the bytecode but we just
don't know and we don't we also don't
know if it has the enclosing class
either so we have to traverse a whole
bunch of stuff inside the bytecode so we
can find the clients enclosing class and
that class may exist on the server on
one of the servers but not the other
ones and we have to work out well what
is this thing like how to identify this
thing so we've got a bunch of bytes how
do we identify this thing and find if
other people have another service of it
but even then that's not enough because
if they don't have it we you can't
actually just ship it over so we
actually have to rewrite some of the
bytecode because the enclosing class may
not be there so it's quite complicated
to do yep and the on the on this on the
server it's still lambda nope still
lambda
we have a class loader which looks after
it no one asked about security this is
really cool but no no sir right sorry
coherence has been used for over like 12
years as anyone using lambdas know it
was released yesterday but entry
processes all of the foundations of
lambdas that actually do the execution
work and like our compiler and that's
been around for for 12 years so in fact
what we do is we we convert all the
lambs of stuff into entry processes and
then we ship entry processes around
because they work like we know they work
and then we then we unwrap them and deal
with it the other side but they still
remain lambers yeah yeah
oh yeah so it's a deployment question so
when when sort of companies first start
using coherence they usually have one
app in mind so you know it Macy's or
Apple or like there's one app the
building one thing Lowe's like you can
basically nilly all comms obviously
apart from amazon using something like
currents or using coherence in there so
they start up with one up and then over
time there's more and more things in
that app so let's say it starts with a
cache of products right so if you cash
the products that's scalable and
distributed and then someone comes along
and says I'll we need a mobile app where
are we going to get our products from
okay well we'll talk via rest to
coherence and we'll get the stuff out
from that and then someone says I've got
a C++ app that wants to do some
analytics on stock flow inventory
management and I have this analytics
library so the C++ guy so over time the
ecosystem builds around something like
coherence and it becomes a system of
record and that's why it has the latest
release has persistence which by the way
you get with coherence so you
effectively get scalable no SQL out of
the box completely persistent so you can
do all of the things you do with no SQL
which is basically get put plus lambda
on topic errands so it grows and then
you know it's almost becomes as middle
sort of middle i got middleware
basically and you can back it by a
database if you want to bring it back up
and down or federated to other sites and
so it usually grows from something quite
small yeah yes
yep yeah so the there's about the fault
tolerance of coherence is about eight
different strategies inside of coherence
deal with type different types of fault
tolerance there's multiple layers of
network protocols that deal with and
detect fault tolerance so a good example
is it's really simple to say our server
crashes in fact that's the best thing
the best thing you could happen is a
server crash because it's dead it's not
coming back it's never coming back it's
dead so we'll get it to that so so
imagine you have a app that GCS how long
is it bad GC and if it does GC when do I
when do we give up send your request to
it when the clients give up and then the
minute you decide I'm going to give up
and you send a request to another node
that comes back right that that problem
alone is incredibly hard to solve but
essentially what Karen's does for
partitioned caches and there are like
eight different types of caches
basically but petition caches partition
the data and the actives we have actives
and numerous backups the actives are
evenly distributed across all of members
of the cluster and the backups are
evenly distributed across the members of
the cluster on different physical
machines if we can identify it so with
single backup you can lose any single
machine at any point in time without
data loss if you want to have multiple
server to tolerate multiple server data
losses you just increase the number of
backups and we guarantee that the
backups are placed on different physical
servers
no its raid so every petition is a
master so by default this demo had 257
petitions for one cache that I was
playing with there are 257 masters each
service has its own master that's all
independent they're all independently
versioned and then every backup is
watching the other masters and they're
individually managed as well so it's
forms a tight mesh full type mesh it
doesn't replicate everywhere and also
they also use buddy protocols which is
similar to what you see with in
telephony systems so there are classic
examples like you know I'm trying to
send you packets like but you're not
responding I like hmm what should i do
should I just wait how long should I
wait because he could be in a GC you
could actually be dead but i say what i
could do is ask your neighbor who I know
is on the same machine hey is that
process still life no it's okay great
it's not right so you're responding but
you're not responding because I yeah
there's network buffers between you and
I there's a switch there's like a huge
range of stuff that's getting in the way
of us actually communicating so we do
all sorts of triangulation through the
network through members because we know
about where they are and what their role
is and and all that's completely
transparent and it changes at runtime
based on the topology based on what's
happening on machines slow yep
yeah so we petition petition first yep
yes so we try to solve we deteriorate
performance to ensure we have persistent
where partition intestine see first so
that's why you saw that spike so most
like no se hace debt solutions you'll
say it you'll see them go ah that
servers not available I'll just go
somewhere else and you could get invalid
data or if you do decide you want
validator the base of the whole system
locks up is it and what we do is we try
to ensure that a single petition is
correct and the order of all the
messages is the same like if I have five
requests to you and then you fail or you
pick up one and I have to failover and I
have to send those five requests because
I've doing updates that are in sequence
that I have to make sure every message
this way this way this way this way is
or what always in order even as the
whole server is restarting it's not easy
but we've been doing it for a long time
so I we take it for granted I yeah
someone asks a security question don't
look here security is really important
it's for our said so so you imagine
someone can send a rogue lambda which is
their system exit why not I'll just send
a system exit lambda to my clustering
kill it or I can send it back to a
client and say hey die so the we use
standard Java security manager so you
can lock it down and we isolate through
a class loader all of the things that
these things can do so by default is
running with no security manager which
says I can do anything but you can tie
these things down quite a bit the more
security have the slower or the lower
the throughput you're going to have
because it's it's pretty pretty hard but
we have this release provides entry
level security
so we can authenticate connections users
to whatever you want to use whatever
security framework you have we use the
stuff out of java standard java stuff
but you can plug in your own if you want
to write your own and we follow that
from the request from the client right
through to the server and we can track
every single thing it's really nice from
the calling thread usually and yeah
usually from the calling thread so if
you've got a request that's coming from
like that from glass official wls we
have the context already and it just
comes right through and we have to pass
that right through because if you've got
a database on the backend of coherence
and we have to call right through we
have to pass that all away all the way
through high
yep right yep right
yeah yeah I mean you you're already
scaling coherence to deal with it but a
lot of use cases coherence is used as a
massive buffer right so it's like I'm
just going to store all this stuff I'm
not going to do anything with I'm just
storing it to some point that I'm going
to push it out to some back-end system
so carrots is really so yeah so
coherence is predominantly used in low
latency high frequency trading type
applications like where response time is
incredibly important like millisecond
response time is important so peaky
large workloads as things that you would
definitely use coherence for so it
depends what you mean by peaky do you
mean like every single person sending us
SMS message at the same time at the end
of the year yeah that's Becky we can do
that sort of stuff everyone walking into
starbucks in the morning and getting
free 18t or what used to be a 2 into
internet access authentication like yep
so they had coherence behind it it's
like so it's everyone goes in around the
same time as a few million hits millions
of hits it's like so yeah that that's
that's pretty that's pretty picky
yeah yeah you're running you're running
a coherence cluster all the time and
then you can scale that cluster out as
you need because ultimately you're
keeping all the requests in memory
resilient Lee keeping in the memory
instead of like because you want fast
response time you're not you don't to
write them to disk you don't to write
them to queue you don't want to like
just like here they all are but I don't
want to lose them either and then then
you're going to process them afterwards
and by that afterwards it might be a
millisecond later but it's a different
programming model against a datagrid
versus what I typically see is like
throw it in a queue will pull it off the
queue we need to make a queue run really
fast whereas with coherence it's like
throw it in the grid make it really big
and then process everything in parallel
where possible unless there's some
workflow in which case post us all the
workflows in power so right and that's
yeah and that's where I think the things
were the Oracles sort of Java cloud
stops going to come in so you can the
Oracle Java cloud stuff so you can have
like that amazon style hey I want so
much and I want to be able to scale out
and scale back and and I want coherence
in that as well so we have customers who
use coherence on on on amazon I've used
on amazon I spread it around the world
it's it's pretty cool and it yeah it's
exactly that use case I think ah ya know
the trouble with docker is it's got
absolutely horrible networking it's is
it's like what virtual machines were
like five years ago 10 years ago like
you could run something but you can't
connect to it so docker struggles a lot
with any type of networking and it
struggles hugely with multicast traffic
so imagine i want to set up so yeah you
can run coherence you can run a whole
bunch of coherence servers up with
docker be you can't get them to talk to
them each other very easily because you
have to go through this software layer
which is at the moment I think it's very
buggy we've managed to do it because we
want to certify on docker we've managed
to do it but it's a horrible mess and
we've had to use the latest experimental
everything and barely does it stand up
and it's not carrots and it's not java
it's just it's not there yet but I think
like within six months a year it'll be
there yeah
no because most people it's funny
because I think it relates to how big
the lambda is like how much lambda can
you write in a page it's like it
naturally prohibits you writing big ones
but even then like java bytecodes not
very big wait nearly like all of those
requests fit in a single packet they're
like less than a k like yep
no no it's a by default it will use
multicast to discover but if you don't
have not a cast and you need to tell
each node one other node at least one
other live node yep yeah yeah but in
fact they all use the coherence actually
uses the same port now every cluster
users so important unless you override
it and the reason we did that is because
it's very easy than to discover other
clusters and so you just name them
clusters of names they can have security
associated with them they can like have
you can have different levels of
encryption on the on the wire so they
won't run into each other yeah that's
right yep yep by name and if you don't
specify a name we use your name you just
when you start the cluster you can
specify a parameter just a cost the name
is this nope just one just say hey I'm
in cluster javaone and then they'll
discover and they'll all join
it's all of the secret what's that yeah
yeah you don't have to tell any you
don't have to identify any member or
isn't and you don't have to identify any
yeah basically just give it the name
yeah nope yep yeah and the other thing
is like so we go here it's 12 to one has
users port 7574 which is now
internationally recognized port for
coherence so just as this HTTP port 80
and https is 443 coherences 7574 so you
know any traffic on that port whether
it's multi castle unicast is is for
karen's and so when we when we start up
a cluster on a server we bind to every
network address that we're allowed to
bind to that's reachable on that port
and that way it doesn't matter if you
have multiple nics you can you can ask
that server and if coherence is running
there even if it's not your cluster it
will know and will tell you and it knows
the other clusters and it so yeah it's
very very nice it snows all you need to
do is specify a name if you want to be
isolated just give it a name and if your
problem was like good examples used to
be in a hotel someone else in the hotel
is running coherence and they're on the
same port right and they they didn't
specify a name and now suddenly we're
clustering and i'm putting my java
objects in and they've got their java
objects and we're getting cost not
founder as a nice guy on here why am i
getting requests and it'll be worse now
at land as well i'm setting lambdas in
here and we're just starting to be using
the same cache so all yeah we used to
have to set like a whole bunch of things
to do isolation now
let's just give it a name don't worry
about ports don't worry about network
cards just just give it a name so it's
very simple if you don't give it a name
we're going to use your machine name
which isolates you which stops you from
going to another machine so it's very
very safe sorry yes yeah so you can say
cash dot a sink dot invoke yep give it
we give a completa bellucci back and
then you can chain them and everything
you can do in Java right you can do with
currents where they sink or you do say
sink
when they arrive like that's why if
you're talking about doing my
aggregation and that's you need to come
to my streams streams talk yeah because
we can do them I sink as well parallel
icing distributed streams we're done
then I go home yeah yeah
yeah we we keep them around and we can
cash them so karen says like
fundamentally has caching technology so
it's just bites so we just cash it we
can expire them and like yeah we just
throw the classloader way when we feel
like it so that yeah there's a bunch of
there's a bunch of optimizations that we
we do under the covers I mean our we our
class letter is fairly sophisticated
like in terms of like how we hold on the
classes and the bytes so yeah there's a
lot of deep engineering which I honestly
don't understand it all because it
depends on the type of request so
imagine if it's a computer request like
a map compute request then it's against
a single key we know which petition it's
in we just send that lambda to that
petition in that member but if it's like
an invoke all that has to go to all of
the members there may be in in vocal
with a filter it may like so we have to
determine where the request has to go
and then we can encode in the request
the signature of the lambda and a bunch
of other metadata and then the servers
can serve as can request additional
information if they don't have it and
they can cash it
we ship yeah we only ship once yeah you
can put in a tight loop with the same
land ownership once and and the other
thing is like I don't know if you saw
the logs like identity is very important
for us so we don't identify members by
these massive uu IDs because it means
every time we have to send a thing
across the wire it's like a massive uid
which has to get serialized we actually
use int and we have an inset that we
recycle and we can send just the deltas
events so at the bite level like what
goes on the wire is tiny it's like I
think it was like less than 1% of the
traffic that goes on the wires actually
to do with coherence the rest is all
your app code there's no like the
metadata is tiny even when server
members die and come back we don't
resend the entire server set was like
ten thousands ten i think is only five
different ways now we actually different
encodings for depending on what happened
how we send out the sets this is very
important to be optimal on the wire
because remember everything that comes
off the wire has to come into the JVM
and be like take heap space so after use
as little as possible i'm going to start
packing up if it's okay but we can carry
on these guys might want to steal a
microphone off me and tell me to shut up</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>