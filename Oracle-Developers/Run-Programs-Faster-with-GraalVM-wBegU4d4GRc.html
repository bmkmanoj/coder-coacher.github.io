<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Run Programs Faster with GraalVM | Coder Coacher - Coaching Coders</title><meta content="Run Programs Faster with GraalVM - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Run Programs Faster with GraalVM</b></h2><h5 class="post__date">2018-04-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wBegU4d4GRc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right thanks for joining us all
we're going to go through a little bit
more detail and then show a lot of demos
for all and we just launched growl via
morgue today oops wrong way if on the
first screen so go there we have a lot
of code samples we have documentation a
big new set of documentation downloads
bunch of new stuff there just launched
during the keynote a couple hours ago so
that's something you should check out as
usual new Oracle talks don't make any
purchasing decisions based on stuff I
say cuz I'm gonna say a bunch of future
looking things that may or may not work
before we actually get them out so okay
so they I talked a little about this in
the keynote but there are two key
aspects I really wanted to talk about so
one is that when we're supporting all
these languages the thing that was very
important is that these languages to be
compatible with them and you want to get
to a hundred percent compatibility so
your code will just work they have
actually a lot of native libraries in
them so JavaScript has native code in
node Ruby has a lot of needle libraries
as well R has native libraries Python
has need of libraries so other
implementations that have tried to
re-implement those languages have
run-ins the problem of how do we make
those native libraries work so one thing
that we did in Brawl is to support
native code directly via an l vm
interpreter so we actually take the back
end of l vm which generates bit code and
we interpret that in the same way we
interpret javascript byte there java
bytecodes or javascript source code or
whatever and so that's a key technology
that's in girl and I think Chris will
have a little bit more to relate to that
later I want to talk a bit about
substrate vm so what substrate vm is is
it's kind of a pluggable infrastructure
that allows we're all to run in all
these different engines so open JDK for
example likes to control memory
allocation and threading and it wants to
control the whole system and guess what
databases like to control all those
things as well and so what we're gonna
do is it with substrate vm you can plug
in whichever underlying capabilities you
want from the underlying system so if
you want to specify resource management
of what kind of memory what kind of
threading you want to use with open JDK
you can use the open JDK tools to do
with that
in the database you can use a database
tool to do that and then in that case
particularly substrate vm provides its
own garbage collection you can also run
code with substrate vm stand-alone where
you can combine it compile it ahead of
time which is great if you care about
lots of little programs that they care
about startup and and footprint rather
than firing up a runtime like the JVM
you can just run a binary and all that
says pre compiled for you
and then of course there's there's zero
cost to interoperate between these
languages and so we'll show you cross
language interrupt and one of the tricks
that we do underneath the covers to make
all of this work is that we actually
allow any memory layouts to appear like
a need of language objects so that if I
want a Java object to be native in
JavaScript I don't have to first create
a JavaScript object and copy all the
data in or I don't have to create a
proxy object that well you know for each
JavaScript method then call the Java
method we can actually directly access
the data structures which is a really
important thing and it's a performance
improvement as well and underneath are
all they're basically there's kind of
two modes that it operates there's two
levels there's there kind of a
precompiled section and there is a
dynamically execute computed section and
both Java code and native code and growl
VM can optionally be in either mode so
we can either dynamically compile Java
at runtime or you can ahead of time
compile Java and the same thing with the
C or C++ code that you're running from
the native libraries and so one benefit
of this is that the growl languages
themselves don't have to be trusted and
so one of the goals that we have to make
growl a secure platform as possible is
to minimize the amount of source code
that has access to all the native state
and they defeat and free access to
pointers so the java language itself and
node and all the different languages you
support and there's a lot more language
code we have now with all these
different languages does not operate in
a trusted mode so we don't have to trust
the JDK and so then what that means is
this the host language level which is
where the trusted code runs it's still
managed in garbage collected and balance
checked so even that C C++ code we can
we can garbage collect out if necessary
we can also even if the Java code
is running precompiled will still have
all those features and we create a
whitelist and only expose certain parts
of that code to the dynamic languages
and the dynamic languages then can also
be put into a memory box or a time box
to make it a little bit more safe to run
untrusted code one of the big
applications for girl and this
architecture is where you have like a
large java application you want to allow
people to upload some code to customize
it so for example NetSuite is using
growl now to provide sweet script which
is JavaScript extensibility and they use
the memory boxing in time boxing but it
can access all the native Java data
structures underneath and of course all
that stuff you can get to with no
boundary crossing costs and so the
overall goal here is that your code can
run on the bralette ecosystem and you're
gonna get you know its availability from
all the different languages rather than
just being available in the language it
was written in and you're gonna get that
code to be available on all these
different embedding so it's not just in
you know if you wrote the code for the
JVM it's not just available there it's
also available in the databases and in
spark engine X or anything else where it
may not otherwise be compatible and then
you can use the the common brawl tools
and infrastructure and all the
optimizations across all that code so
it's creating more multiplicative value
at so and I mentioned before that one of
the key technologies in Brawl is that we
can make any memory layout look like a
language object and it's that logical
physical data isolation so one example
research project that we did actually
done yell I did who's sitting here in
the front row allows you to have access
directly to the network buffers so you
didn't have to create new JavaScript
objects every time a rogue or column
came back from the database you could
just point to those network buffers and
so you can see a pretty high speed up
this is just a research project yep but
that's something we're working on and
doing in the in the product and I want
to talk a little bit about the roadmap
and then we'll get into demos this code
this this is Oracle code system mostly
about looking at codes I'm not going to
do too many slides Chris we'll get to
the demos in a second
one feature we just released now today
it's called isolates this is something
that you've had in browsers but it
hasn't been available in a JVM where you
can create multiple heaps that are
provably separate and they have isolated
objects that can't reference each other
and they're garbage collected separately
and so if you want to have separate
tenants and kind of manage them
separately and create a heap have a sub
application allocate things and that
heap then throw it away separately you
can do that now with Java I with
isolates and girl and that works in all
other languages we do have research one
of the things of course we aren't
supporting now is is Java or PL sequel
as truffle languages so there is a
little bit more cost there and they
don't per state and our tooling
infrastructure so we have some research
projects to add those obviously are free
running drawn hotspot there's not an
issue with that but if you're in a girl
on the database you're not using the de
graal implementations therefore those
languages I mentioned the database
driver but there's a set of other crawl
enabled libraries we did a paper a
little while ago on smart collections
that can get more optimization than of
collections by using some of the growl
features in the in the library there's
some security features we're working on
such as running the C code in the LOV M
interpreter in a management box also
doing dynamic paint tracking for looking
for untrusted input that's getting put
into like a sequel driver and trying to
look at sequel injection attacks today
we have Linux and Mac OS available for
download but we are working on support
for Windows as far as operating systems
goes today most of our optimizations
have been focused on x86 but we also
have a back-end actually the Red Hat
contributed forearm and we're now
putting some people in from Oracle to
make that port better there's a lot
fishy a lot of people that are caring
about the arm ecosystem and I guess
Apple announced that they're gonna move
to arm soon so we're gonna really try to
ramp up the support for that processor
and then also recently Java 10 is now
having growl as the experimental
compiler so that is if you pass the
write command line flag so a gig or all
available and you can do some things
with that that's just a compiler it's
not the rest of the languages or
substrate VM but there is some work to
incorporate
with substrate vm as well into jdk and
then our version you know if you
download it you're getting JDK 8 most of
the customers we talk to are still
insist staying on JDK 8 and so that's
where we add features so we're gonna be
trailing a little bit on the Java side
and the Java guys are gonna be trailing
us in terms of adding our features but
there's kind of like that everyone wants
to wait to the other guys stable thing
so that's kind of the infrastructure we
have so I'll take any questions now on
this stuff and then we'll go into some
code demos so so one of the things I
talked about VMware is is designed to
interact with your software at the
operating system level right and so the
only knowledge it has of what your
program is doing is whenever the your
program makes call that's the OS we're
actually executing every instruction of
your program and so we can watch what
your program is doing so I cannot you
can ask like rah VM one of the things
we're looking at is is that program
mining Bitcoin or not like it turns out
that we have problems with people like
running Bitcoin you know miners like in
hiding in an open source packages right
so let's say I want to detect that well
we can actually detect that because we
have access to the internals what your
language is doing and so that's one
major difference right and so you know
we're compiling the code VM where you
have to provide the code that's compiled
that's it it's a different level of
virtualization any other questions
comments all right let's go do some code
just swap the display
so I'm Chris Seaton I work on one part
of the the growl vm project I'm going to
show demos from all parts of it go vm is
a really large ranging project no matter
what sort of software development or
Operations you work in there's probably
some part of Grove VM that's of interest
to you and is applicable to what you're
doing the place to get Gro VM the first
step is to go to grow vm 2 org and
there's website there which has lots
lots documentation and has the actual
download links to go and get what we're
looking at I've already got the the tar
ball which I've downloaded and extracted
and set up so I won't show the the setup
process in detail get it straight into
the demos nice and large for you ok so
what is gravi em you may be thinking
some of these concepts have been
abstract at the moment
so one thing growl vm is is a JVM
it's a superset of the JVM provides more
than a JVM but does but it provides the
same as a JVM does but it runs your Java
code faster than a standard JVM would so
I've got a java application here it's
called top 10 and what it does is it
takes a a set of files on the command
line and it tells you the top 10 words
it finds in all those files it doesn't
using the stream API it's a fairly small
simple program but you can imagine me
wrong this with perhaps some large
inputs we'd want to run it as
efficiently as possible so grow vm does
include standard sorry Grove Ian does
include standard commands like the the
java c compiler and the java command so
we can compile that top 10 application
using the java compiler and then we can
run it using the Java command and I'll
use the the time commands time how long
this runs now I'm using the time command
cuz I want to run this on the one a time
how long the entire thing takes so I'm
not running a micro benchmark I'm
running the complete application with a
large input from beginning to end I'm
asking it how long is that gonna take
when you run Java from the ground VM
it's configured to use growl by default
so I'm using growl already here this
this takes about 17 seconds and we can
disable growl by using this command
here I'll say I want to disable using
the JVM CI compiler JVM CI is the API
that growl users are similar disable
that API and I've run the same command
so now it's using the standard hotspots
server compiler also known as situ or
opto to run that same program and it's
gonna take it a little bit longer to run
that so it takes 21 seconds so this is a
drop-in replacement for Java that's
running a program in 17 seconds the set
of 21 seconds and in an environment
where we're used to getting a 1%
increase in performance for the JVM is
pretty impressive this is very
impressive
and this is why Twitter a deploying
growl themselves in production at the
moment because we get this this real
impact on performance which translates
so real money in terms of running a
large data center but that's running a
large input if we won Java on a small
input it's not quite so impressive this
finally is pretty small there's only a
few hundred K but Java still takes quite
a long time really to to start up and
run that program this has been
historically something Java isn't the
best that if you write something like a
command line you said it always takes a
little bit of time to start up and
that's because the JVM is quite a
complicated sophisticated thing if you
want to run small commands we can use
something in the JVM in grow vm called
native command so I'm gonna do is I'm
gonna run native image on the same top
10 application what it's going to do
here is it's gonna compile that java
application down to a single statically
linked binary that doesn't run on the
JVM it's a native application now you
may be thinking what it's doing is it's
taking a JVM and sticking the jar inside
it it's not doing that you may be
thinking it's crazy native application
which links to Lib JVM it's not doing
that it's creating literally a single
statically linked executable which
implements this Java program we can run
the the old tool on it to see what it
links to so it just links to the the
system libraries there doesn't really
link to anything and if we look at the
size of it it's it's only 5 megabytes or
so and if we run this now I'll run the
last one again so it takes point three
eight five seconds from the native one
it runs much faster so what we've done
here is this is an option for running
Java commands without that kind of
startup overhead and it also means you
don't need a JVM to run this so I could
take this 5 megabyte executable I'm his
thought on system which has never had
the JVM installed and that's the entire
Java program the way it works is
examines all the code that you're
actually using your application it walks
through all the classes you're using and
it compiles in parts of the JVM you need
such as the garbage collector and it
boils it all down to a single executable
so if you're interested in
high-performance Java we've shown that
can do that if you're interested in fast
start up low footprint Java which only
can do that as well so that's Java but
we talked about other languages and
polyglot so what I have here is an
application which is written in
JavaScript inside the nodejs framework
so it loads lose the Express webserver
and what I have here is I say I want to
use a bit of Ruby code here so I use
this API polyglots eval I say I want to
execute some Ruby code and then ruby
code is inside this string here so I'm
requiring a ruby library so say there's
some Ruby library I've got that I want
to use from JavaScript it's called the
color library for working with different
colors and I was simply want to return
this module color RGB then I can use
this within my node.js application I
have an endpoint here and what it's
going to do is I'm gonna take the name
of the color and they will look it up in
that color module by name and it will
return it as an HTML color so a hex
encoded with a hash in front of it and
notice what we're doing here is I
haven't had to do much ceremony to do
this Interop what I've returned is a
Java Ruby module that I'm calling
methods on that Ruby module which are
returning objects and I'm calling Ruby
methods on those objects I haven't had
to wrap the object haven't had to say
create a proxy for anything I simply
naturally say I want to call these
methods on this Ruby object
I won't run the module install commands
because I don't want to be dependent on
the Wi-Fi but we can simply install
using again gravi em a ruby module we
can stall a grain using the gravi em
conversion in these commands Express and
then I can run the server I said one to
run node and I say I want to load all
the polygon libraries and I want to run
on the the JVM in this case and then I
can go to that endpoint so with CSS and
the name of a color so I go to CSS ak
marine and it'll tell me what the HTML
value of that color is so the JavaScript
is running the server and then the
libraries written in Ruby the idea is if
you have a library which is already
written in dumb a language you can take
that from that ecosystem you don't have
to wrap it to create a version of that
library you can simply naturally use it
from one language another and this same
demonstration here would work with a
Python library or in our library or a
Java library if people write other
languages the future an automatically
work of those all need to do is change
that that language identifier there
let's try more sophisticated example
with a library that you really might
want to use from no Jess because it's
not actually available so I've got an
application here that is again it's
running in no Jess is the outer layer
I'm gonna use some Java here so
JavaScript doesn't have great support
for big integers there are libraries you
can get but there they have to work in
quite slow ways to work around Java and
numeric types so I'm gonna say I won't
use from Java the type Java math big
integer I'm gonna wait at endpoints I
wanna do is I'm gonna create a big
integer ten raises the power of a
hundred I'm gonna add 43 to and convert
it to a string and then I'm gonna use
our and I'm gonna draw an SVG image of
some some shape of some points moving
around so we're using Java and we using
our we're using from the the know Jess
as the outer language
this one takes a little longer to start
up because it pulls in and our module
dynamically but if I open up the browser
so it loads a and our package there what
we have is that's that big integer
printed out as a string and then we get
this SVG image printed in line so this
is a use case you can imagine it's very
practical something you might genuinely
want to do if you have a Java Script
node.js application there were lots of
jobs grits graphing libraries but
they're not always terribly
sophisticated the are ones are very
sophisticated I've lots of clever stats
libraries you can use and it wasn't hard
to write that simple application that
combined our and Java and it uses the
uses each language for its best at so
you don't have to worry about what
language your ecosystem has you can pick
the best tool for the job another aspect
of grow VM is operations and tooling the
idea is because all these languages work
in a similar way they all work on top of
truffle so truffle is the layer that the
languages all talk to and the idea is we
have to do is implement tools once for
truffle and then all those different
languages can work with the same tools
so you get that one point where you can
implement something once and they use it
from all these different languages
including languages you may not know
about someone else is using and if you
have a program written in more than one
language the tools work across those
languages so I've got a jobs with
application here fizzbuzz application so
simply goes from 1 to 20 and it prints
out fizzbuzz based on the classic
programming problem the reason i've
chosen this because it's got different
branches which are taken at different
points in the application so I'm gonna
run the gras vm version of java script
and it printed out there and loads it
sound nice and stuff nice and fast that
started but I'd like to debug this I'd
like to see when we get to fizzbuzz so
I'm gonna do is I'm going to run the
JavaScript command I'm gonna give it
this extra flag now inspect and that's
available for all these languages it
comes from the growl vm system so what
it does is when I run that is I get a
URL which I can open in chrome so Chrome
has a JavaScript to bugger built-in
for debugging JavaScript applications I
think use of no Jess as well and what
we've done what we've done is we've
written a layer which can interface with
that so what we've done is we started
the application it's paused on the first
line that does some actual logic rather
than just a function declaration so I
could set a breakpoint on the line I'm
interested in and I can continue
execution until we get to that point and
then you see we get features here such
as it prints out the current value of N
and it prints out a call stack if I can
navigate through as well we have things
like watch points and you can inspect
other variables so I think if I go to
the program I can print out I can see
the value of and try to do that but err
we are we've broken on this and this
pointed fizzbuzz and then I can I can
remove the breakpoint and I continue
executing and it finishes but chrome
tools already does debugging for
JavaScript it does it for the built-in
version of JavaScript it has we can use
it for other languages to do exactly the
same thing so I've written another
version of that fizzbuzz program this
time in Python
I'm going to run the the growl version
of Python and I get exactly the same
thing I get a URL which I can open in
chrome I get a similar interface so I'd
again I can set a breakpoint on the line
I'm interested in and it's new execution
and again I get back to BA go back to
same interface exactly same utilities
where it's telling me the the current
value of n and this isn't something
that's built into chrome support for
Python you don't normally get to see
this but our back-end could work with
all these languages so I'll continue
execution
and again we can debug ruby frequency
so the breakpoint I'm interested in a
run and again it tells you've got the
the value of n at that particular point
and for our again we can debug a lot of
these languages don't always have good -
buggers of their own if someone's
written a fairly small language that
doesn't have much support from industry
you may find this not many particularly
good tools for it if you write your
language on top of the truffle ecosystem
you get all these tools of the same
quality as you do for the the main
languages like JavaScript again we can
set a breakpoint in our we can run it
around
remove the breakpoint again it tells us
the value of n using the the our way of
talking about things we continue that's
just once all the chrome debugger we
also have tools for things like
profiling and there's an API to build
your own tools so you can write one tool
and have it work across all these
languages and the same way you can write
a new language and get all the tools
existing so it's a real sort of force
multiplier you have this one point where
everything could come together and
everything go in and talk to each other
through it and if you have a probably
got program you get polyglot debugging
once all we have that we've modified to
work particularly well with truffle is
it's a visual VM open J visual VM which
is the tool that you get inside there
the JVM normally but we have a modified
version of it not sure I can zoom that
but I've got screenshots I can show you
when we come to it
so gonna run the Java top ten program
again with a large input and I can open
that from visual VM I can do things like
I can take a heap dump I'll stop it then
and I'll show you a screen shot then so
we can see our our java application
tells us the things like how many
objects ads inside it and these are
really good tools of Java and Java can
do this because it can introspect itself
and this is one of the reasons why I log
people program on the Java platform
because you get this sort of high
quality tooling and jva and the Grove VM
extends this to work with other
languages so if I have written a ruby
application here which renders a
template in a loop I've done that so it
generates qala objects and interesting
garbageman's of that and I'm going to
run Ruby for that application I'm going
to say I want to run on the JVM because
the JVM has better
introspection facilities than the
substrate VM does the substrate VM
trades off that introspection for be
able to start much more quickly so now I
see a ruby application there it has they
a picture of a cop which is the the
growl logo I can perform a heap dump I
can see how the garbage collector is
working so when you if you ran an
existing implementation of Ruby on the
JVM such as JRuby you'd see Java objects
here and this is what we see by default
and that's a real limitation and that
the languages never like first-class
citizens you always see like the Java
version of things it's always in this
sort of Twilight Zone of not really a
separate language but we can do is I can
say instead of the Java heap I want to
see the Ruby heap and it'll translate it
into Ruby objects for me I'll show you
the screen show again because it's
larger so now we see that I've got
string objects and symbol objects in
class objects array objects it tells me
which objects are large and it's lots of
hashes that tend to be large in this
case and tells me how many of those
objects we have I can do things like I
can see what are all these symbols so I
can double click on them I can see these
symbols are all these different names of
encodings and things like that and types
and whatever is going on inside the
application again if you write an
adapter for jvz or PM which explains how
your language likes to be able to look
at objects what those objects mean in
terms your language then you can run
that application okay let's go to a more
extreme sort of polygons people are
running languages like Python and and
JRuby on the JVM already I've said why
they aren't quite as sophisticated as
what we do but let's take it to another
level what I want to do is run a C
application on the JVM what I've got
here is a version of gzip so the new zip
compression utility I've got a version
that's this one single file so csail
have this project where they have single
version single file versions
applications for doing research on it's
just much easier to work with one going
to do is I'm going to compile the
application using the standard version
of clang so it's not a special gravi
Asian version of clang it's my system
class
so I've compiled it that geez it but
I've got it to emit LLVM bit code rather
than emitting machine code so if I look
at what files I've got I've got the
originals C source code then I've got
this bit code that's a machine readable
version of the program as LLVM interpret
LLVM intermediate representation what
I'll do is I've got this small file and
that's what it looks like it's from
great expectations and what I do is I
want to compress that using the system
version of gzip I want to do now is I'm
gonna run our LLVM interpreter on the
gzip bit code so I'm saying I want to
run this bit code file and I want to
decompress that file I just created
one's nice and quickly and then I can
cut the file again and it's been
decompressed so what we're doing there
is we're running AC program on top of
the JVM it still uses native memory we
have projects to run this on manage
memory instead of native memory and to
provide safety in this case of Trani in
native mode you can run C applications
like this but one of the main reasons
we've done it as Eric described was to
in order to be able to run C extensions
resisting languages and like all the
other versions of growl VM languages
this provides a sort of level of
abstraction and that when you have a C
structure and you read fields from it
that could be real C structure or could
actually be a ruby object or a
JavaScript object or an R object and you
can think you're reading from memory but
actually it's being redirected into
doing something else that provides a
level of restructure that allows you to
do things such as read for memory that's
actually being done via a remote
procedure call or something like that
okay so that's about running things
within the JVM and running things using
Java libraries perhaps that we would
like to Purdue in the studies to take
libraries from the Java ecosystem and
use them within other larger native
projects I've got a library here that's
from Apache it's the SAS library it's
for doing geo information so be able to
do coordinates on Globes and things like
that it's a real off-the-shelf
application I've got this up
I've written here which uses it it takes
four doubles and it tells you the
distance between them is a lat long I'm
using the library so differences
utilities have assigned distance so
again I'm gonna compile that and I'm
gonna run it and I give you the
coordinates of London and New York it
tells me there 5,500 kilometers apart
what gonna do now is I'm going to
compile that like we did before with the
top ten application I'll compile that to
a native application instead
so again this produces a single
standalone statically linked binary it
doesn't need a JV able to run I can run
that to produce the same result and it's
so much faster it started because of its
natively compiled now but what we could
do more interesting here is we can add
this C code to it I'm going to say that
I want to add a CAG point called
distance and it's got those four doubles
then it runs the same code and if I
compile this saying that I want to share
two library instead of an executable
what's going to do is now it can produce
a dynamic library so a dy Lib on macros
or an Esso on Linux
and again this doesn't have any any
dependency or anything on the JVM it's
simply native code and it wouldn't know
it's any different to us if you drip the
whole thing in C but you've produced it
from is off the shelf or modified java
application and now i can write a c
application to use that so it automatic
produces a header for you lib distance
dot h that's automatically generated by
the same signature
i set up a few things so i create an
isolate i create a thread this gives you
the option to do things such as have
multiple versions of the library and the
subject VM running at the same time kept
separate and it passes from the command
line and it runs that code so I can
compile this driver application using my
standard version of clang I say I want
to dig link to that lib distance and I
can run that application again to
produce that this means now that if you
have a Java library which does the
functionality you want but you have a
native application or you have an
application written in some other
language which has an FF I like Lua or
some of that you can now use Java
libraries from the Java ecosystem in
that application and when we talked
about running growl in the database this
is affected what the database does links
this library and then database loads it
and the substrate VM is designed to be
well-behaved enough that you can put it
in as a direct library it doesn't try to
own the entire world like the JVM does
normally we've packaged that up into a
utility called polygon Lib that provides
an interface to be able to use that
automatically so this is an API which
you get in Grove VM by default that
includes a function basically polyglots
context eval it allows you to run any
language that you want from the growl
ecosystem in a native application so you
know languages like invitations like v8
have an API you can use to embed and use
them that's what no Jess does this is
the same thing but for all the languages
you get in the Grove VM so i do is i
ieave al a string that i get on the
command line and i print it out
basically
so eval and print it out
and again it's simply using the the
system version of clang to compile that
and if I look at what that depends on
you can see it depends on this lib
polygon which is provided by default in
growl and then I can run that so by
default it evaluates stuff as JavaScript
I can explicitly say run it has
JavaScript and I can use a language like
Python as well so if you have a system
which has some sort of embedded
scripting language perhaps or uses
JavaScript as an embedded language and
you can now replace it with this API
instead and you can run any language
then the interface I've shown is just
eval but it includes sophisticated
things such as to be able to call
methods index arrays things like that
and finally polyglot in the database so
this is an application of all the things
we've shown so far jazz well application
you can download this multilingual
edition of the database from this link
multilingual being like like polyglot
I've setup already because it takes a
bit of time to set it all up but
basically I have have the database
running in docker and then I have docker
running here so what I want to do is
that's all setup commands I'd like to be
able to use JavaScript libraries from
the Oracle database so there's a huge
ecosystem there for example there's good
libraries for doing things such as
validating inputs cuz people do that a
lot in JavaScript if I go to the NPM
website and I say I want to validate
things I'll search for validator this is
library here that does string validation
to can tell you if things are valid
email addresses like that so there's an
example here if I data dot is email
tells you if something is a valid email
or not so I might be able to use that
from within the database if I'm using on
my client ID much not to run exactly the
same code in the database so now to
program it twice and I don't get it
wrong while I translate it so it's doing
something slightly different and what
we're gonna do is I'm gonna install that
validated library and then it has a sort
of
package of plugins and then when uses a
command D bjs deploy what I'm saying is
I want to deploy that node module into
the database and then we can load up the
new SQL query interface I'm going to say
is I want to select validator is email
and see if this email address is a valid
email address and it tells me one
meaning yes if I run it doesn't look
like an email address then it tells me
no so I can have this in my stored
queries I got this as part of my normal
queries and this code is being
dynamically compiled if needs be if it's
on a hot loop and being inserted into
the database and that doesn't just work
Java scripts it's multi-language and
it's not just JavaScript tradition so if
you have other language you want to run
in insert it into the database as well
so we can get more information on this
there's absolutely tons of information
if you go to grow vm org you can
download the system from here and you
can recreate those demos that I've
showed you there today there's a
community Edition which is all
open-source free for production use you
can take that you can build it yourself
you can use it in production if you want
to as an Enterprise Edition which is
free for valuation and you can talk to
us if you want to talk about commercial
use or support
yes there are some components which are
in the Enterprise Edition but not the
open-source one moment and the
Enterprise Edition is available from mac
o s-- whereas the community edition
isn't available for my course at the
moment but you can evaluate it of course
so you can see that the impact of the
difference if you're interested in that
Grove VM I'd say it's a really large
wide-ranging project there's a very
large group of people working on it this
is a tiny proportion of the people
working on it now it was a few years ago
that's a list of the people who are have
been involved with the project at some
point this shows you how much oracle is
investing in this and how important we
think it is to create this one platform
where everything can go through and we
think will be a real force multiplier
for being able to use different
languages different libraries from
different ecosystems and a label you to
to program as you want to so if you want
to use a library you can use it you're
not restricted because you made some old
choice to use one particular platform we
have a get a room where you want if you
want to come and talk to us and see
about anything that we've talked about
today you can go to this Kitty room or
you can tweet me if you want to tweet me
while I'm still here today then you can
you come and talk to me and see all
these demos again what will you do how
they work
thanks so much Eric Joomla conclude
no I guess that's it I mean probably a
morgue check it out we launched it there
today so then any questions from anybody
today
good well so he showed you how the
native library works right so what this
people we did is we took the native but
dulled and we use that to run the
infrastructure and then you can also
dynamically run classes so when you sign
a mclee loading a Java Script package
and it's that's being dynamically
compiled that's that's that top level
piece okay a question over here
yes
so what's faster is that the compiler is
a lot more aggressive at identifying
object and lining and said so much it's
a growl itself was actually a compiler
written in Java so the weight growl
works is it first compiles itself so it
allows us to write a compiler itself in
a higher-level manner so like the
compiler that's been in a hot spot for
last 15 years or so it's called c2 and
that's written in C++ and so it's
written kind of in a low-level it kind
of knows it's a compiler like here's the
left operand node the right operand node
you're not just saying a plus B you kind
of have your operating at this lower
level so growl has you know some
infrastructure called snippets it makes
it much easier to write compiler
optimizations and so the compiler itself
is just a better compiler and so
languages with more abstraction like the
more abstractions you use one of the
things that Chris didn't show today is
there's like we have a stream API so
like it runs a lot faster yeah the job
application yeah I mean the Java 8
stream API this stuff here this is
actually pretty abstract it and so we
can do like very substantial speed ups
on this depending on the size of your
program which you were showing in that
example you did it was like it was 23
down to 17 will say so like that's what
30% faster right and and so like the
more abstractions a helps if you use
like stream API and Java eight or if
you're using Scala or things like that
with more abstractions we have more like
gunk we can get rid of and so you can
see more performance improvement there
and you know the code at the end of the
day grow let me have the projector girl
is still generating snippets of machine
code so we're running the same kind of
thing that that hotspot is and so when
you're running drawn hotspot you're
still running that the hotspot runtime
specifically the optimizations that
Grodd includes the top spot dozen and
things like partial escape analysis
which allows you to remove all occasion
of objects even if they're on some paths
they escape and the reason that's in
grub and a hotspot is because it's so
much easier to work and grow because
it's simply a java application people
think about jits as being really really
complicated applications like
and level applications but really
they're not there are a function from
byte code to machine code machine goes
just an array of bytes so there's no
reason why we can't write that in Java
and when we do it's much more easy to
make these changes and we have done
because it's easier so we get better
performance so what's happening here is
when grassi's code is going through the
trouble api we're compiling code and
they're just little chunks of code
because you what the VM is doing is it's
running interpreters for the stuff that
doesn't see a lot and and the stuff
that's in a hot loop then the hot loop
stuff gets the the hot loops here kind
of get the compiled code snippets in it
and it can do compilations in the middle
of a loop so if it sees okay i'm bronze
to this loop enough times now I'm gonna
actually replace the interpreted logic
with the compiled logic and then you're
running just kind of native assembly
code like it was compiled at the C
compiler but it's actually even more
optimized because we have the profile of
what the program is actually doing so we
actually have some examples where you
can show JavaScript running faster than
C and what's happening there is the
profile has actually allowed us to do a
more application specific compilation
where we can say oh hey the data types
are looking in this shape so we can
actually compile for that particular
data type as the assumption hey most of
the numbers in this column are not long
numbers they all fit in a two byte
integer or four byte integer so we'll
compile and use smaller size and
integers and then throw an exception if
we get a big one and if we see that from
the profile that hey this column always
has like money in it we can just
multiply by 100 and count pennies we can
use integers rather than floating point
or big decimal or whatever those kind of
optimizations we can do is that hope
the parlor reason why it's too much work
though is because it's so difficult to
do within hot spot wind that the c2
compiler the theory work is complicated
yes but implementing anything in hot
spot is very very difficult these days
there's very few people who can do it
and when you look at the source code of
growl I'll take you to some source code
of growl if you like later and shoot how
high level it is and how easy to work
with so we have we have PhD students who
come and add really significant
authorizations to growl without much
effort so
you can don't like listen to us wide me
we're poor you know listen to the
Twitter guys right there actually found
that they you know they learning 10,000
servers and you can save 10% that's a
thousand servers enough to buy ring they
wrote it running the JVM today it since
Carla Carla so it does tend to generate
more garbage that yeah the more
obstructions you do the more performance
you get right I mean if you're running
code that just kind of looks like equals
C code poor to the Java it's probably
not gonna see a big impact right okay so
right
no this is a really common misconception
we can take a java application and turn
it to a statically and binary we can
take a Python interpreter written in
Java and turn to a static binary we
can't do the next level and turn the
Python program into a static binary so
Java is kind of language that it has
static typing but it's dynamically
compiled other language you support and
we've really focused on our dynamic
languages that are dynamically typed and
of course you know C is something you
can do as well so you can do though is
the way the subject bien compiler works
is it runs your java application up to a
certain point and then freezes the heap
deposit into the binary so what you can
do is you could run Python or Ruby code
during compilation so you can do things
like initialize your libraries create
objects create classes 2phi that and
then when you start running the compiled
code they just magically appear in your
heap
well so hotspot remember it's a VM right
so like when we're running in hotspot we
haven't when you're running on an open
shady K you're running with the open JDK
garbage collector for example and JDK
has very good garbage collection right
it's actually much better than the
garbage collector in v8 for example
right V JavaScript you know VMs are not
really designed to run a lot of garbage
because you're running short running
webpages they care more about startup
the JDK is really designed for servers
and so you have like big heaps like
gigabytes of heaps and and their long
running applications hotspot I think has
like by far the best server class
garbage collection and so you want to
use that like in the context of the
database substrate vm has our own little
built-in it says much simpler garbage
collector but usually what's happening
is you're doing one select statement and
at the end of that select statement we
throw away the heat right so we don't
actually need to collect garbage we just
throw away heaps and that's the way
database has always been built so you
don't actually keep around language
state past the one JDBC call and when
you run with substrate VM in the
database and so so we have a simpler
garbage collector node you has a simpler
garbage collector hot spot has a great
garbage collector and and there's a lot
of contributions from the community into
garbage collection if you're running
short running code then grow VM is gonna
make a lot of sense right it's gonna
make more sense probably if you're
running long running code it's going to
be in a server running hot spot but with
the girl compiler in hotspot right so
we're all runs in hotspot right so we
aren't necessarily oh I mean like growl
and Java are not always the same thing
right so there we can mix and match the
components of whichever infrastructure
you want so hey let's say when you're
running growl in Java what we add is
multilingual isn't the Java that's much
more effective right we add the compiler
is faster right but you're still getting
JavaScript garbage collection and you're
still getting the JVM garbage collection
is looking the je viens implementation
of all the GDK right gives you another
degree of freedom at the same rate we
now letting you choose which language
you want which libraries you want from
different languages we now also letting
you choose do you want high startup to I
joined quick startup time and low
footprint or do you want best peak
performance and you can choose between
the two depending on which situation is
appropriate for you so give me all these
extra degrees of freedom we still
haven't yet supported people running
Java and v8 as the VM no no but we
actually have a little research project
to run growl and chrome so that you can
have a collect call VM where you can
like run you know our Ruby as instead of
JavaScript but that's just kind of a
little fun research projects along we
had more questions over here
the truffle has a standard way of
writing a standard way of applying a
debugger on top of your language and
then it said the interfaces with crowbar
a published API they have opens a socket
talks to Chrome and it simply tells it
that your missed line of this file and
chrome prints that and you tell it this
location is a variable if it's got this
value and chrome prints that so crow
doesn't need to know about the language
is if he gets told
yeah yeah right yeah because if it does
support other languages like
CoffeeScript I think it uses source maps
to do that most of boogers now have a
remote access protocol and our
multilingual you do the same thing with
NetBeans the same tip I showed you what
yeah yeah that's kind of the more depth
of the Java you know kind of API for
yeah oh and then we support the
JavaScript API and again it's more level
all of those linchpins where everything
can go through and you could swap out
the backend and everyone could work the
same just with a different back-end any
more questions
probably well out of time at this point
all right well thanks everyone for your
time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>