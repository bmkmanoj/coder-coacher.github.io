<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Rethinking API Design with Groovy Traits | Coder Coacher - Coaching Coders</title><meta content="Rethinking API Design with Groovy Traits - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Rethinking API Design with Groovy Traits</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/K1pwBmyRx58" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so let's start with drinks so I
know that you use groovy maybe some of
you use color anyone in the room okay so
you use about trade since car I'm going
to explain some slight differences how
many of you know what traits are
actually good so in the first part of
this talk I'm going to shorten it a bit
because last time it was 101 half and I
didn't have time to explain everything
about rates so that worry if you have
questions come back with and talk to me
after decision and i will answer so for
me basically trades our first a static
issue problem why well before data eight
what we used to do in Java is actually
defined contracts through interfaces
right so the contract is what allows you
to color method basically you say okay a
fan I have an independence defining some
methods and those methods belong to the
contract so this is some kind of
designed by capability so interfaces are
actually mandatory in Java if you want
to be able to call methods on an object
without knowing the actual type of the
object you only know that it implements
some interface so you have some kind of
contract what do you do actually if you
want you have more than just a method
signature but a default behavior what do
you do ja surplus so basically you
create an abstract class that implements
that behavior okay but what if you have
multiple contracts to implement how to
do that multiple abstract classes okay
that works
but if you want the same class to
implement multiple contracts how do you
do that any ID I'm not surprised because
you got yeah you you are just tap with
the basic problem which is we don't have
in Java multiple inheritance we don't
have it for good reasons and with trades
we're going to try to solve that problem
without bringing with us all the
problems that multiple inheritance us so
in groovy if you don't use compound
static or tab check if anyone doesn't
know what compile study on Patrick is
you've raised your hand okay so type
checked in Ruby I'll compile static let
you switch the mode the compiler works
and instead of being a dynamic language
basically behaves like Java with compile
time error so if you don't use that that
you're just using dynamic groovy you
don't have the problem because if your
object has the method you can call it
you don't have to use an interface
different define a contract you just
have the method and it's okay so we have
a problem java and we have a problem in
type checked
so in groovy even if we have multiple
that even if we have that typing we
still have problems with multiple
inheritance really it can't do multiple
inheritance like you can do that in Java
it's because we share the same virtual
machine and allowed by the type system
the VN doesn't allow that so we have
some problems so even if you do that
typing for example if you want to know
whether a class implements a contract
not you have problem the only thing that
you can do is Utley is instance of
something so you have to define it
interfaces just you know if a class
implements some contract if you don't
want to rely and just get method and
find if the method exists ok so in
groovy we tried to find some solutions
to that problem and one of the solutions
was mixing how many people use mixing in
groovy right are you happy with mixing
ok it's ok for you right so it's ok for
you on good but it has lots of problems
so mixing how does it work you can
define two classes so maybe for you or
far away is going to be a bit small
where you have two classes one classes a
cat that can meow and another one is a
youtube dog and you want it you want to
talk to be able to mirror ok so how do
you do that you can mix in a cut into
the dock so you mix two features into
one and then if you define the dog you
can call the meal method as well as the
bark one so you mixed two objects into
one and you really have two objects this
is what is important to know about
mixing when you do that without you
knowing about it you have two objects
being created
you have an object of class dark and the
other one of class cats and actually you
have some kind of delegation process
behind hood you can call those methods
but it's really a dynamic fit almost
dynamic because even if it relies on
dynamic features of groovy to work it
still has some compile-time
transformations to do that so mixing is
something that works sometimes and
actually it has lots of problems so if
you go on the jireh every port system of
grooving and just search for mixing you
will find probably 20 bucks only the
reported once just about mixing and the
problem is that we don't know how to fix
them set hut many many problems one of
them may be one of the biggest problems
factoring memory because as I said when
you use mixin you have two objects being
created instead of one so you don't have
a single thing that you can manipulate
you have multiple things and for each of
those objects you have meta classes
because it's groovy so when you create
an object you have the object and its
companion with the class and for mixing
you have one metaclass per instance so
you have four objects just to be able to
use mixin just that's a lot
another problem is how you make the
difference between the objects which is
mixed in and the mixing itself and
actually you have two objects so
sometime this doesn't refer to what you
think it is and you want to refer to the
mixed in object or not depends and
sometimes you don't have the choice it's
just the metaclass system that works
behind the hood and you'd have no
control over laps so mixin okay if it
works it's good for you if it doesn't
work you probably can't use it so what
we did in ruby three is just to
duplicate mixing in favor of traits
another solutions delegation so it is
more or less what mixing does behind the
hood but you can be explicit so the
difference between delegation and
inheritance and I know that those days a
lot of people are saying don't do any
inheritance do delegation because spare
is safe etc I kind of disagree with that
I think both models have interests I
mean for me the choice is just this one
if you can say something is a something
then you have to use inheritance and if
the end if the question is more who acts
as something then delegation is probably
a good model for that but you shouldn't
resume just because someone says
delegation is better i'm going to use
delegation inheritance has interest okay
if something is a something use
inheritance the problem is that in java
h or groovy if you want to emulate
multiple inheritance you have no choice
but using delegation
so imagine that we want to have an
object which is a starch and only a
stack nothing else that it's just a
stack not the Java one because the
german one actually has a problem the
Java stacked class inherits a lots of
method from its contracts and when you
try to call them sometimes it's throws
an error which is what is this not
implemented sir yes and supported a bear
thank you it just makes no sense just
because you inherit some contract that
you don't want to implement you have to
throw some errors okay so with my stock
while I want to do is just implement the
two methods that I care about in a stock
which are push and pop so I create a
delegate which is the regular Java stack
and I just delegate to methods and
that's all all I want to do is just have
a start that has two methods and only
those two appear in the contract not the
other ones I don't care about them so
delegation is a very good model just for
that just to delegate and say limit what
I delegate you to some methods so in
Ruby will have a nasty transformation
that lets you do that easier which is
delegate you can say I want to implement
the interface that the delegate
implements yes or no and you can do
includes just to say which meant that
you will delegate you such as with a
similar notation you have all those
delegate methods which are implemented
for you so I use delegate I annotate the
delegate with a stack and say I don't
want to clear it those interfaces by
default delegate will do that but I
don't want to
and then the advantage is that it's done
at compile time so if you use a class
for example from Java you would see
those methods it's not a dynamic
behavior it's Renta it's compiled on
base and if for some reason the star
class changes you would have all those
methods delegated for you for example so
delegate for me is really a good good
mobile if you want to delegate a subset
of the capabilities of an object to
another one and what I'm saying here is
that if he is delegate to implement
multiple inheritance some kind of
multiple inheritance well don't be
ashamed it's just because you have no
choice if you want to do that you have
to define an interface implement some of
those methods and delegate to an object
that implements that and that is the
only way that you can call methods that
belong to multiple objects just creating
delegation then as i said before
delegation should probably not be used
if you can say is a something so it's
not a suitable solution at least for us
and it wasn't for job so how many people
use java ate already okay few hands do
you use the default methods feature and
you knew what the default methods
feature is okay so default methods
actually the name of this feature
changed several time and the first name
was virtual extension methods and
virtual part is very important and
this is one of the major differences
with trade so I will explain that so
what you can do in Java 8 actually is
some kind of trades some kind of and
some people actually call traits default
methods in Java 8 are some kind of
trades not the one that we do movie but
some can so what is you can define an
interface and inside the interface you
can define a method and with the keyword
default you can define the default
implementation of that method and all
objects implementing that in phase would
take that implementation if they do not
define their own levitation so what they
did in Java 8 is basically destroying
the whole concept of an interface just
it's not even to face anymore it's an
interface with code it straight so you
can have a class implements gritter I
don't define the grid method that I
don't care because I will inherit that
by default it's very simple and why
actually that feature came into jdk it's
just because they wanted with the new AP
is that you have in Java 84 for example
streaming API etc you have lots of new
methods on the collections API and as
those connections api's are probably the
most widely used connections APM is in
each other in the world if they added
some methods in the Indian faces then
they would probably kill backwards
compatibility for every user that has
custom implementations those interfaces
so to avoid that they added those
default implementation directly in the
interface so if your class doesn't
implement them you get them for free
without breaking compatibility binary
company so it's really an important
feature for delight so one thing that
you have to know about Java a default
method is that they are stateless so
that means you don't have fields into
the interfaces that you can refer to
that is easy to understand and the main
reason why you're a stateless is that
actually the diamond problem that you
have with multiple inheritance only
occurs if you have state otherwise just
methods that you hope and you have no
problem enter and virtual means that if
you define your own methods into the
class then this one takes precedence
okay so i found a virtual greeter class
implementing the gradient face greetings
face defines a default method but as i
define my own this one is taken it's a
virtual call so for those of you who did
some C++ it's the same meaning for
virtual one thing that you have to know
is that even if groovy supports riddock
age since groovy 23 I think yeah so you
can use those default methods in
geography you cannot define in groovy an
interface that contains default methods
if you see the difference okay you can
using interface that has default method
but you can't define one in group
probably something to come and groovy
three okay so we have Java defining some
default methods which are some kind of
trades but it's stateless the movie we
wanted to have something to eat fool so
what are traits in group first it's very
similar to what you have in July it very
similar but not identical important is
that we wanted to support the decay six
seven and eight I don't know how many of
you use Java 8 in production probably
not a lot java 7 is really recently that
many people use that in production but
until one year ago it wasn't the case
you want trades to be stateful and if
you remember what I said a few minutes
ago I said that if you have staged into
an interface then you have the diameter
so we see how we work around that and
the main thing is that trades should be
thought as units of composition last
it's not really virtual and that one is
very important to design new AP honest
so the basics of traits first this is
the first time since I think Ravi one
that we have a new keyword and groovy
which is trait so you can define a trade
using the trade keyword where you would
use interface just you straight and you
define a trade which is flying on a
method called fly using print line I'm
flying okay so it's really just looks
like a class but it's straight then I
kind of find second one just quite
and it quacks and now I can compose
those into a single class just using the
implement scheme so class duck a duck
can fly and get quacks so it intervals
flying and cracking that's easy okay
so you can have a ride actually the
behavior of those just like you can do
that with JK a default methods if you
want the judge to be able to say duck
fly instead of I'm flying you can do
that you just override and implement
your fly methods but that duck class
would implement the two trades flying
and quacking and one interesting feature
of traits is that if you take that class
and look at that class from the Java
point of view import that class into a
Java project you would actually see that
flying and quacking are two interfaces
so from Java traits are seen as
interfaces there are sinners interfaces
but without default methods so you only
have those abstract methods defined in
the interfaces if you watch that from
your Java point of view so this means
that when i use the implements keyword
actually i'm really implementing
interfaces ok oh good so far
for those of you who use compile psych
of course it's compatible with compass
tag so you would be able to use that ad
compile type to a class that use a trade
or if you use combine static on some
code that calls the trade would be
perfectly compatible so no problem point
but stateful stateful is really what is
important because if you want to compose
behavior it's very rare that actually
you don't have some kind of state that
you want to share okay so i know that in
functional programming paradigm you
don't use mutable states like you see
hostage ok so the traits you will have
state so i can define a trait which is
geo localized and it contains some
regular groovy properties so i can
define the longitude latitude etc place
name and i can create a class City
implementing that in that trait and
basically it would have those properties
available so i can create the object
using the standard groovy constructor
with map constructor named argument with
nadja to the latitude and the name and
it works so we have something that
allows you to extract some behavioral to
trade and just that so you can already
see what you'll be able to do with
trades which is extracting some small
pieces of behavior and then compose them
into objects
sorry so it's a bit more complicated
than that so you would have sort of
questions just maybe I should repeat the
question so those are private numbers of
the city class not really you would have
some fields private fields into the city
class but actually Lane spaced with the
trade name so i don't think that i will
have time to explain that in that
session that you have some this is
basically to avoid the diamond issue so
of course if you can do that the
interest is that you can compose trades
that have state so implement multiple
trades providing their own set of fields
stateful so you can for example define a
new trait which is something which is
inhabited defining the population and
then my city can become something
implementing gia localized and inhabited
and I would inherit the fields from both
traits into a single object so now
without using artifacts I'll delegation
whatever I have all those fields free
and I can compose my objects so it's
it's very common actually that you have
some small parts of components that you
want to share into multiple objects and
what you are used to do in Java is
actually thinking differently just to be
able to implement it the wager that
wants you to implemented with traits you
don't have a problem you can think of
small pieces and then compose them
that's between single object so small
bricks of behavior is what I think is
the most important thing to understand
about freights a trait will define a
small behavior which is
in my case watch geo legalized
inhabitant etc so things that you think
that you can share in multiple objects
then you can compose those into a single
costs and the important part is that
doing that you increase the reusability
of your code and it's also easier to
test actually so you can test of course
you can test rates you can do that okay
so no questions of up yeah so groovy 23
is required gia straits yes so for those
of you who use greys I think the latest
craze version already uses screwing 323
and grace 3 is actually immigrating own
code using custom mixing plugins etc to
use trades instead yes
I will I will explain that yeah I will
explain that later too okay so let's
let's continue so one feature of traits
is that actually you are not restricted
to a trait using a single behavior you
can have traits inheriting all the
trades as I sit in some cases
inheritance is good it's a load so it's
allowed on trades so we can we could
define actually my G localized trade
differently using something which is
named and inherit the name future it's a
load it's just how you will design that
it's just your way of designing I can't
do that for you it's one way to do that
you can hear it do whatever you want I
mean it's your design you can he'll
inherit so this is important you can
inherit from multiple trades so we have
some lots of questions I could agree on
the mailing list about this keyword
implements you should use implements but
personally when I have a trait that
extends another trait I prefer to use
the extent skew it just to say okay this
straight extends this one but if you use
implements it just behaves the same so
you can use extends or implements
whatever you want will do exactly the
same
trades are not necessarily limited to
default implementations you can also
define methods that need to be
implemented some way so in this example
I can define a trade which is polite
someone polite and he will be able to
think and just I rely here on the name
property which is actually an abstract
method okay so I'm just defining that
nitrate will require to get named method
to be implemented and if I know that
it's okay so now I can just have the
person class implementing a polite and
just the fact a defining a property I
will have that getname method coming
from from the property of groovy so I
can use that and then ok.thank will work
just because the get named method will
be implemented is it okay for everyone
good so the question now is more why
using the implements keyword so as you
have seen actually in Java 8 they also
use the implements keyword for default
methods it's it's the same and actually
there is no difference between an
interface and a trait it's the same and
for those of you who do scholar you know
have those two concepts you have the
concept of trade and class but there's
no concept of interface because actually
an interface is nothing but a trade
without any default implementation so
adding a new keyword chest because we
have a trait would be confusing and it
would be more than confusing it would be
a problem if you combine them and try to
resolve conflicts as I think Nora member
who asked about conflicts bitch we're
coming to that just now so conflict
resolution in traits is important
because you will have the problem which
face that problem
so imagine that I have a trait worker
defining a run method and a runner
defining run method Oh too bad I have
two classes to trades defining the same
method but they have total different
meaning but one plus I want to implement
both who wins any idea in july eight
what happens in 28 it's a compile-time
error you have to resolve that in groovy
it's not the case it's not to compile
time error by default last one wins so
actually it will take the implementation
from Rena okay so if i change this I say
Who am I run will use Runner because
runners define last but if arts switch
the interfaces and use workers ask then
it will print work instead okay you
don't see any problem with that I can
see one at least so it works for very
simple cases but what if you want to use
a method for rent one trait and another
moment from the other one how do you do
that so this is the situation situation
you have two traits one defining lucky
an adjective which is low key and the
name which is Alice and unlucky which is
and the case the objective and the name
is Bob and I want to class which is
lucky Bob a lucky Bob wants to use the
implementation from lucky for the
adjective and name from and lucky well
you can do that then you switch to
another mode which is explicit conflict
resolution in that case in ouch actually
you can define ok i'm using the super
method from lucky so it will call this
one and four name i'm using the unlucky
one so class dots
dot so it's the same syntax as in Java 8
if you have the conflict with default
methods in Java this is the way you
solve that so we reuse the same syntax
it's just that in groovy by default you
have a resolution conflict strategy
which is last one wings okay so what's
this so when I talked about mixings I
told you that you have a problem because
you have two objects you don't have the
problem with traits because in the end
you have a single object a single
project so this is really the object
that you create so if i define a method
riff called self in a trait and that
returns this another have a class
implementing with this then so the is
method in groovy is the equal equal
default in Java no because in Ruby equal
local the equals method so we have to
use is to have reference equality so
when i do that i can make sure that
actually me is the same object as the
trade itself so you don't have the
problem as knowing where the method
comes from and more importantly the have
two problems knowing who you are you are
an object implementing some interface
done very easy yep
it was it would return me because this
is really the object that implements the
trait because you cannot implement you
cannot instantiate a trait just like you
cannot instantiate an interface without
having an actual implementation so you
don't have that problem yeah but that
then get class would return the class of
that anonymous implementation ok renton
question is probably one of the features
are like most about rates so I know we
discussed a lot with a joke about name
of that feature and yeah why rent I'm
correction in groovy you have multiple
ways of implementing interfaces in one
actually works at runtime using the SQL
so if you take just a single interface
having one method you can define an
object def explicit equals a closure as
line is now and at runtime actually it
creates an object implementing that
interface this is one way to do that the
second way is to define directly the
type and then relying on implicit
closure question to an interface ok so
into seclusion question I think came in
groovy 23 q naught 2 3 2 2 3 2 and then
yeah you can call those methods so it
works the same for trades so you can
have a trait and you can define a trait
in line just like that a class
implementing the trade at runtime so you
have a closure which says written down
as greater and groovy
that actually does a single abstract
method single abstract method so the
only method that mrs. implementation is
actually get name so when I do that
chloral ask Rita what I have here is the
body of the get name method and the
other one comes from the trait
implementation so if i do Rita the greet
reprint hello done so you you can use
the same syntax just to implement trades
at runtime so why is it important to
understand that this behaves it rent I'm
so sorry for those of you who are a bit
far away from the screen so basically
you have two objects one object sorry
which doesn't do much support objecting
something but I have two traits one is a
superpower and the second is just
something that has name and I can do
that in groovy I can have def oh can you
pour object so it happens at runtime I
create a new instance of an object a
poor object but I want it to behave as
something which is named so I can do Oh
as named and for those of you who do
scholar for example and when you have
new something with some trait it all
happens at compile time you have behind
the hood something created at compile
time not run time so you can't do that
in Scala you can have something which is
an instance coerced into something at
some time so you do that and then you
can manipulate but what you have to
understand is that the object which is
returned here named is not 0 anymore
it's a new object you have two objects
you have the original one and you have
the named one so two instances
so you can do that and you can call a
superpower and you would inherit the
methods from there too but what is more
interesting is when you want to
implement multiple trades at runtime you
can do that just instead of using the
ask you would use with traits which is
there and you can say okay I will
decorate my object with the features
from superpower and named and then the
object which is returned implements /
with traits okay so you have a different
object returned so the original object
still have its metal clasp and the
object which is returned we have its own
data clustering if you do that class on
on what object unnamed you will have the
metaclass of the instance of a proxy
as something else yes you can do that
problems that you create more objects so
this is one problem and the other one is
that its proxy which is generated okay
just like spring proxies whatever you
have something which delegates the
method calls to something else so it's
slower and speaking of speed yeah
so it will work with a combined static
just the limitation if you do run time
cast is that the object which is
returned is only known to implement the
trait interfaces so you wouldn't be able
to call the original methods which are
not defined in the contract that clear
so actually it knows a bit more it knows
the trade methods plus any method
implemented by in an interface whatever
interface it is so this is why
interfaces are still important groovy if
you is compiled sadiq obviously if you
don't use it you had problems just
delegating it works the method is here
ok so this is an interesting use case
that Eric cracked showed me actually on
Twitter and it wasn't understanding why
it was so slow so I have a trait which
is not most backtrace and the advantage
of doing that is that when you throw an
exception it doesn't feel the stack
trace so it's much faster to generate
expect the exception so if you create a
class which is expensive exception that
just extends the default exception it
will be slow then I have a cheap
exception that implements the stack
trace so it will get that method from
the trait ok and the last one is
actually doing the same new expensive
exception as no stack trace so what do
you think will be faster which only
three prolly wants
okay so here are the results actually
the last one is much much slower than
the others and can be a bit strange if
you don't understand that actually as
means do this at runtime very important
as always means in groovy at runtime not
compiler so it's true for trades its
troop interfaces if you do that then you
have first an expensive exception
created then it is cursed into an ox NHO
stacktrace exception so actually you
paid the price twice you pay the price
of creating the exception and you paid
the price of coercion so very bad way to
think about that so you can't use trades
just for that rent I'm trades actually
you have to use them at compile time
using the implements keyword if you want
them to be fast okay so I have around 15
minutes left so let's talk about these
not really virtual stuff and traits so
imagine that I have a trait defining get
color method when I have a class
implementing that I can get the default
implementation and acid that you can
define a custom method and then sioux
city is defining your class it will take
precedence so I just implement the
contract but in the end it uses my
method it's quite natural right natural
what what happens in that case if you
have a new trait that defines yellow and
a class implementing extending that a
class ID so it's not a trades to class
so class extending yellow and implements
a score so it's not really virtual just
because of that when you use implements
keyword it means take the implementation
from that trait and bring it now
so even if the method is already defined
it will take the version from Haskell
just because implements is there so
where you put implements it means bring
the default methods implementation so
why we did that I'm going to show that
just after it's actually one of the most
important things to do to define new
kind of a PRS so what is nicest that you
can use that feature to share Tony some
other rides and I had the use case
between the groovy code base for test
cases when I wanted to recreate the food
tastes sweet just of the writing always
the setup method and instead of having
to create new classes and define an
override in each of the class that every
time does the same thing I can just
choose a trait that over rice that has
that new setup method and then it would
implement that every time so I don't
have to repeat the code and if the code
changes all classes would benefit from
that directly so next the meaning of
super actually is more than just what I
thought before which is resolving
conflicts in a trait super means
chaining so chaining imagine that you
have an interface defend defining a
single method on message and a trait
that implements that interface i can
define the implementation on message
which is receive message message
something ok so now i create a class my
handler that implements that trait and i
don't have to bring my own method if i
go on message it will call this one ok
more interesting imagine now that i have
an observer hand that implements message
and let you and in on message i'm going
to just log what happens so I'm seeing a
message I can eventually log the payload
if I want you but I'm doing super dot on
message super dot on message interesting
very interesting actually because what I
do here is just say I'm done but now
call the next rate in the chain that
answers that message so if i have a
class that implements the default
message handler and the observer the
observer is the last one it wins so if i
call on message it will go observer
handle on message lock the message then
call super dot on message and super
means next trait in the chain
implementing that method so actually
there is one which is default message
header so it could delegate to that
trait so you have chaining possible and
where it will be really interesting if
is if you use that at runtime actually
because what you can do is that kind of
new dsl's using handlers for example and
delegating you can create add some
handlers multiple handlers and compose
them at runtime so I just create a new
handler which is a base handler and then
I can decorate it at runtime with
multiple trades so applique is
duplicating an observer so what will
happen observer will lock the message
and delegate to the super super is
duplicating handler and what is
duplicating handler doing actually
called super done message twice so it
will call this one the next one in chain
twice so
have something logging runtime in
uppercase twice so it's very interesting
feature because you can compose all
those handlers at runtime as you wish I
have yeah less than 10 minutes yep it
will use the one from the implementation
that you have it will fail with an error
you have to design your API just do that
yeah it will fail probably with the
stack of the flavor because if you try
to call something which doesn't exist
every time hello it what probably maybe
with code knock rules we could probably
try to catch that Smith's yeah maybe
it's bit difficult especially if you run
time questions difficult to know what if
you will have that method available not
because I didn't have time to show that
but actually in trades you can define
dynamic methods too so you can define
method missing at property whatever you
want you can define that directly in a
trait so you could have behavior which
exists at runtime which is not defined
at compile time so just a few words
about HT transformations so this is a
problem today that we're going to work
on and try to sell bit unless unless you
find in the documentation say something
saying this is the transformation is
compatible with trades not use them
because you would have surprises so just
as an example compiler static is
compatible so you can compile static at
trade so everything here would be
statically compiled ok this would work
too so we you would have a delegating
trade that uses the delegate annotation
and then if you have a class called
dynamic implements delegating then you
would be able to call all those methods
which are delegated that works that this
one would not actually two string is not
compatible
so if you do that if you put two string
in the class foo that implements named
actually the two string representation
would miss the get named feature so it's
not as easy as it seems to solve that
problem because when you use these two
transformations in groovy in general
they are applied where you put them but
for traits it's a bit more complicated
do you want DHT transformation to be
applied on the trait or you want it to
be applied where you use it and in some
cases it's really not easy to make the
difference so we will try to solve all
those problems from time to time so take
a look at the documentation so before I
ask top this session and it was about
API design so what does it mean actually
rethinking API design well first traits
lets you define campus able visit
behavior components that you can pose I
think this is the most important thing
to understand you have components that
you can compose so if your kids are used
to play Lego it's very the same you have
bricks and you can pose them to have
complex behavior and that is really the
most important do you know about traits
stack ability is also very important you
know the message that can delegate to
super etc so this is stackable behavior
or stretch of traits you can have calls
to methods delegating to others etc etc
so as an example of that you can use
that kind of new api's for example I can
do something like a list with traits
filtering so I would have something that
implements that trait and it returns a
new list which is itself a trait so this
one would return the filter method and
if I call the myth the filter method I
have something which has the total
length method available so you can play
with these cells using traits composing
their behavior to all at runtime so it
opens a new kind of deer cells that you
can write using Ruby last just before I
keep two minutes for questions take a
look at the documentation because
they're much more than what I said here
so it's actually pretty complete because
we have rewritten the whole really
documentation it's not complete yet but
new features are much better than
documented that the end of all the while
it's actually so you have good
documentation of traits and yes I think
now I should probably take one or two
questions for the trim unis left that I
have so yeah okay
so it's so technically if you take a
look at the bytecode of a class
implementing a trait so just if you take
a look just at the trait how it is
compiled you have actually an interface
which corresponds to the whole methods
and this interface has companion classes
which define static methods and the
first argument of the static method is
actually the class that we implement
trait so when you have a class that
implements that rate it will delegate
all to the static helper classes so this
is for methods and four fields it's a
bit more complicated you have some kind
of new fields added dynamically in the
not dammit dynamically bit at compile
time you have new fields created which
are named spaced corresponding to the
name of the trade just to avoid that you
have two fields of the sailing in the
same lost if they come from two traits
so it's actually very interesting to
take a look at how it is implemented if
you if you want to you to take a look
sir it's the last one that wins in any
case so it will take the method from the
last rate but you would still have two
fields one which is for them say that
you have a trade foo and another bar you
would have a field which is foo X and
the other one bar x two fields yeah yeah
you have two locations and you have to
deal with that conflict in your code so
this is something that that I don't have
to talk about in that session that yeah
you have all kind of conflict resolution
strategies and this is all explained in
the documentation so the question last
one nope so thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>