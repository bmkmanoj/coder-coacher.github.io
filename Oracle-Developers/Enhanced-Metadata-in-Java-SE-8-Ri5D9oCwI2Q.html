<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Enhanced Metadata in Java SE 8 | Coder Coacher - Coaching Coders</title><meta content="Enhanced Metadata in Java SE 8 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Enhanced Metadata in Java SE 8</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ri5D9oCwI2Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone to enhance metadata in
java SE 8 I'm Alex Buckley this is my
colleague Joe Darcy we're in the Java
platform group at Oracle and I have to
start by asking did anyone see this
session last year 12 people that that's
good because this is substantially the
same as the session last year the
material was absolutely hot off the
press last year this year it
substantially the same of course it's
had more time to bake it's shipping now
and JDK 8 as of March 2014 so the
material is also relevant and I'm glad
I'm glad you're all here to to hear it
so let me do the customary survey that
survey that I do who here is actively
developing on JDK 8 quite a few hands
two hands from that gentleman magetta
case 16 who here is targeting primarily
jdk 7 as a balancing number may be a few
more JD 6 some five some 1.4 okay yeah
we've spoken and 1.3 1 point 2 1.1 1.0
point 9.2 excellent so most people are
on 17 and that's great and in a couple
of years most people will be on it most
people many people are on it now more
people will be that's great so we have a
few features to talk about that a new in
java SE eights i hope you will enjoy
using them i'm going to show them very
briefly they're not terribly complicated
to see what in some ways more
interesting is the the story of their
design and the constraints of
compatibility i'll spend some time on
that Joe will discuss evolving the
various reflective AP is of the java SE
platform there are more than everyone
thinks and we'll also cover some of the
changes or potential features for
metadata and reflection
after se aids so the language features
I'm going to show three language
features the first two were related to
annotations third is something else so
repeating annotations who here has used
jpa in their code quite a few so you're
all familiar with John column and join
columns right you know that if you you
could write one at join column
annotation on your class on your method
but there's been a constraint in the
Java language since Java well since Java
Sea five six and seven that said you can
only have one annotation of any given
type in any particular location so if
you wanted to have more than one
annotation of a given type join column
you had to wrap this container
annotation join columns around them is
everyone people are familiar with this
yes and so that was seen as a pain and
so as of java SE eight you could we have
removed there we've removed the
constraint and you can write multiple
annotations of any given type possibly
with different arguments of course at
any location in the language on class
declarations feels methods etc etc a
question already yes an excellent
question on what happens when you call
get annotations excellent question
that's the compatibility story will come
to that thank you for the concern really
that's what takes all the time so
there's actually no syntactic change in
the Java language to allow this because
you've always been able to write at foo
at bar at bar that quacks honor on any
given location they just had to be
different types and now they can be at
the same type they don't even be
particularly arguments and that just
works to reflect over those things hero
is the same source code at join column
this i joined column mats if you were to
get the java.lang.reflect.method.invoke
you say I'd like all of the join column
annotations you get back an array of
those and then you can iterate in the
usual way there are really no surprises
it'sit's trivially trivial syntactically
is trivial to use the design of the API
is is is less so that repeating
annotations you can repeat annotations
in all the familiar locations like i
mentioned class declarations field
declarations method declarations
variable declarations etc type
annotations are a new feature in java SE
aids and their their annotations but
sort of in a different dimension so in
SE seven annotations are typically used
to express properties of declaration so
here's a field F it's a tight list
string and we're going to declare that
feel as a non null list the exact
meaning of non al I don't want to get
into we by the way we don't ship
non-null in the JDK that's not an
annotation we ship but I could have used
that foo but then people say could it be
non-null and I say it could be so I'm
just going to show not Nels begin with
imagine it does some useful checking
about where their F is now or not that's
fine that saying F itself is going to be
not know the overall list what about the
elements how would you say the elements
themselves must be non now well you how
would you do that you could declare a
class that extends string or you could
have string wasn't final but you know
what I mean that would within the type
itself express the property if not null
is non-null less and then you have a
list of non null strings there's nothing
else you could do syntactically in the
language to express that property in se8
essentially any place that a type name
appears at the top level like list in a
type argument like string in a nested
type in an array type you can sprinkle
annotations into those types to be very
precise about what you want your
property to be so for example list of at
non null string a variable text of type
string and it's an adding list string
you say okay well that look like I could
kind of write the at English string
takes before but that was on the
Declaration of text itself not on the
type string you might say those look
similar well okay look at the
the third line where I have a string
array and I can say the array itself is
non-null and then the strings inside it
are notionally at English and you can be
in this works with multi-dimensional
arrays with it works with parameterised
types with generic types with nested
types really anywhere there's a type
name which turns out to be a lot of
places in the language you can put the
annotations in question the question is
is there an annotation process that will
ensure that the whatever values you
assign to the text variable are in fact
English strings and not French strings
we don't provide that annotation
processor I'll show some examples very
shortly of annotation processes that do
things like that that you can download
for free and use so they're not in the
GDK but there are many checkers like
that yes another question
excellent question which is
syntactically at English string text
that annotation it's just hanging around
in the grammar before the type do you
intend for at English to apply to the
type string or to the declaration string
text excellent question and the answer
is the annotation designer whoever owns
public at interface English as an API
really of its own get to decide the
meaning the scoping of the annotation
type so you put your familiar with that
target the metro annotation Joe will
talk about extensions to that to allow
you to say my annotation my annotation
type English can be used here here it
can be used on method declarations field
declarations and type names I'll say yes
that there are rules to disambiguate
difficult cases yes it's basically you
can essentially you can model it any way
you like you can have it as one as
neither or one or the other or both does
good question so there are like I said
that are at there are many places in the
Java language where tight names appear
here's a generic class foo t extends our
there's a generic type parameter with an
upper bounds an at non null string
there's an extenze claws on the class
there's a wild card or that not not at
not null in front of it there's a upper
bound for the wild card there's a throws
clause here are some expressions with
type names in New no I cast to string a
lambda expression whose formal parameter
we've just that you know you know you
can avoid writing formal parameters are
formal parameter types for lambda
expressions but if you choose to you can
then annotate those formal parameter
types there is a who's familiar with
method references and construct a
reference in Java rate excellence on
they cool yes good so I thought I want
to take I wanted to get a method
reference the list of size and it's a
list of string sighs that's that's legal
and actually it's list or non null
string so it's you
see this is really orthogonal these type
annotations to the rest of the language
we really had to slide them in at the
right level and you know here's a here's
a constructor reference for an array
type and the array is an array of non
the arrays non null and all the values
in it a notional e non zero so we want
to really maximize the expressiveness of
this and I'm going to catch an exception
which is pretty sure that's guaranteed
not to be null pretty sure about that
someone asked okay who checks whether a
string is English who checks whether
something is now the answer is there is
a tool kit you can download called the
checker framework use your favorite
search engine it will come right up and
that provides a large number it's got to
be 20 plus of checkers the runners
annotation processors on your command
line to java sea I believe Eclipse has
some built-in support for the null list
stuff examples null pneus is a value of
this type allowed to be null or not null
is a value of this type considered to be
tainted because perhaps it came from
user input or is it not tainted those
things shouldn't reach that's the
checking that you're referring to if
I've got a string maybe I have a string
the value must be a regular expression
or a particular format or a fully
qualified name versus a binary name for
those of you who care about that
distinction in Java what about saying
types have dimensions and what are the
units of those dimensions different
concepts right what if I have a type I
have values of types and those types can
or cannot be compared by a double equals
first is the equals methods in other
words are there some values that can be
interns or that logically can be interns
and so can be double equals compared and
there are it goes I should have had some
double dots because it goes on and on
and on so look up to check your
framework and read the manual and have
fun with that yes
oh the question is are these kinds of
checking mixing compile-time checking
with runtime checking it's true you
could you could enforce many of these a
runtime the checkers are checking all
these things at compile time there is
obviously a certain amount of
imprecision you can get with that and
you get more imprecision with more
control flow sensitive stuff like
guarded by and holding than you do with
more data flow analysis stuff like
tainting right the the null list
checking taint checking string
dimensions all that is pretty well
understood data flow analysis that that
works great at compile time it's true
that some of the some of these checkers
the control flow analysis they do is
more sensitive to runtime behavior and
the right talk to it tends to discuss
that was yesterday where Verna Dietl
whose standard Verna who is one of the
authors of the checker framework I
believe discuss things like that yeah
okay those are the annotation features
here is my third metadata feature in se8
it's a long-standing bug in the java SE
platform that nate names of formal
parameters are not stored in class files
so a number of EE API is required that
they want parameter names to generate
you know rest interfaces and things like
that and so typically you had to put an
annotation actually it's actually on the
Declaration of the formal parameter and
you just you know irritatingly have to
repeat the name of the formal parameter
in the annotation and then you go and
reflect over it get parameter
annotations let me find the one that I
as any framework and looking for etc in
SE eight we finally let these parameter
names be stored in the class file so you
can get rid of your query parameter arm
annotations and there's a new type
java.lang.reflect.method.invoke I day
and you can get the name and whether it
was final and whether it was VAR arcs
and any annotations on it and type
annotations and it goes on and on so
we're letting you write less and it just
it just gets integrated into reflection
smoothly let me talk let me keep going
it off a little bit about compatibility
let's just go back to repeating
annotations I showed what many of these
EE ap is refer to as the container
pattern if you have multiple joint calm
annotations and parameter this and
configuration annotations because there
tends to be more than one of them there
is a container annotation that you have
to write which and to come back to the
question before means that frameworks
have a very precise idea of what they're
looking for in almonds frameworks that
are that were written in the SE 6 days
that are still running today have a very
precise idea that they're looking either
for a container annotation let's say
join columns or if that's not there then
they must be looking for the one join
column annotation right so this is the
code
I reliably assured basically exists in
all of the reference implementations of
these api is first look for at join
columns and if that's not there go and
look for join column so that's a
situation that as we found it
essentially coming into se aids so now
we say okay we're going to relax the
Java language so that you can write at
join column at join column in source
fine the obvious thing to do is just
store those annotations directly into
the class file there's no mystery about
that there's no problem with the class
file format it allows it if we did that
then the existing code would it would
look for um get annotation it would call
get annotation to look for join columns
it wouldn't find that couldn't we put
joined column directly into the class
well and so it'll say okay I'll now I'll
now get the join column annotation V it
assumes there will only be one and we
could make the reflective API return the
first one there's no problem we could
make that work but in fact there are two
openers and there's no container
essentially it was felt that the
reflective frameworks would get quite
confused about things you've written to
join column a and column but the
existing reflective code in frameworks
will only see one and you will you will
then be confused subsequently in
addition this was the point you made
anyone who calls get annotations is
prepared to receive that foo and at bar
and a bassinet works they are not
prepared to receive two at Foos two
adjoining columns I don't know what your
reflective code looks like I don't know
what can side conditions it has in it
but I know that the guarantee that get
annotations has always made is that you
will only get one really it's at most
one of any given annotation type lots of
annotations but you'll never have more
than one of any given type so that's a
that's a problem any framework where we
basically break would any framework
could potentially get broken if we
change the invariants so we really felt
we had no choice but to effectively
embeds the container pattern from E into
java SE so for compatible it's really
behavioural compatibility with the
pre-existing ee reference
implementations it's kind of necessary
that when whatever you write in source
at join column and join column we wrap a
compile-time in an adjoining columns
annotation that goes into the class file
the existing reflection methods from se7
they don't change at all if you call
them they will see the contain
annotation they will see what's inside
everything that existed before eight
still works unchanged we've effectively
given you some syntactic sugar and what
that means is if you're an API designer
and you declare an annotation type like
join column you have to nominate its
containing type it's almost always
obvious what that is in the existing API
is joining columns and you go to join
columns and of course it has the array
fat joint columns doesn't change
actually between seven and eight but
join column itself does right and then
now that we know that we're going to
take your source code with the PT
annotations and wrap them up in the
class file we now we know that we can
provide a new method get annotations by
type that unwraps for you if you say guy
annotations by type join column but
class it will look up join columns see
that it's a repeatable annotation type
become aware of the possibility of join
columns and if it finds a join columns
in the class file open it up pull out
the array inside it yup value there's
the value area and actually return you
an array of the join column annotations
aside it's so if it's new code you get
to use this nice new method old code
doesn't break you still in source code
get the benefits of being able to write
repeating annotations so there's sort of
this triangle of
and design constraint that we're trying
to keep keep straight and I think we've
been successful in that as Brian gets
would say all this complexity which is a
problem it all comes from yesterday's
solution yesterday's solution was you
couldn't have multiple annotations of
the same type and so he had to come up
with this pattern blah blah blah and
here we are basically embedding it into
SE and that's a level of complexity we
would rather do without but
compatibility matters so is that an
annotation type designer you always have
to think as my annotation type
documented inherited what target does it
work on what's the retention policy in
addition you net you now have to think
should I allow it to be repeated right
this again was something we wanted that
the annotation type designer to be able
to opt into and you get this question of
where can you repeat it it's possible to
say I want join column to only be
allowed singly on field declarations but
multiple e.on method declarations and
type uses you can set that up with
enough at target met annotations moving
on to the parameter name access feature
the design constraint here is what is
the role of parameter names in the JVM
historically they weren't there in the
class violent if they were they were
there for debugging purposes which is to
say technically they were there but only
through the debugging API is which a
pretty low level and not through
java.lang.reflect.method.invoke so that
someone can access them through core
reflection but a number of questions
come up one is well should we just have
Cora flexion go and try and pick apart
the existing debug attributes local
variable table a local variable type
table where parameter names can be
expressed today to cut a long story
short no that will be very messy and
conflate concerns
should in the JDK build we include
parameter names for say the java SE AAP
is in the jdk class files that would be
quite useful to many people the trouble
is then we've got this question of
stability we've got a new compatibility
surface because now we can't change any
of those parameter names for someone's
code will now be reflecting over them
and relying on the third parameter of
something obscure an AWT being called X
and when we want to rename it to be no
point X your code breaks so we don't
want that new stability that new
compatibility surface should we say okay
well the JDK is going to opt out to this
but maybe we should opt in all of your
classes to store parameter names like
secrets and key and password for all
your private methods in the class file
that doesn't seem like a very good
decision either for us to take on your
behalf well class files would get bigger
they would they would in a sense leak
new information that they never had
before that that would make people
unhappy so there was also the question
of well even if you do want to have your
parameter name stored in class files
natural format pretty straightforward
but what's the policy for putting them
in what approach would you like there
were numerous approaches discussed some
people said oh just have you know
java.lang.reflect.method.invoke lass
that means all of its methods get
parameter names in the class file and
other people said that's too obvious I
want I want a meta annotation on at web
service so if I say at web service on a
class it has a meta annotation that
triggers all the public methods of the
web service class to have their names
and you say public matters what about
protective methods it goes on and on and
on and on and on there was no consensus
in the SE a time frame on this mechanism
it's kind of like a syntactic discussion
different different concerns have
different proposals so we left it up to
tools so type Java C minus help right
now and you see a minus parameters flag
that will on a file by file bassist all
the parameters there we may revisit this
policy in se9
if we're doing Java C minus parameters
start a Java then it's on for everything
I believe there's a checkbox in eclipse
which turns on for everything as you dig
into this sort of thing an amazing
amount of complexity shows up what kind
of parameters are there in the Java
language as many as you like sir almost
as the answer everyone's familiar with
declaring a method having a formal
parameter that's great that's
ninety-nine point nine percent of the
time you explicitly declare a parameter
in your source code great other times
there are parameters that you don't
explicitly declare but the language
declares on your behalf right an example
of that is if you have it in a class
what does the nested class and in a
class and it has a constructor that you
declare you get a parameter put in for
you that's not a compiler specific
detail of Java Sea it's actually
required in the Java language BEC that
that be done but then there are other
parameters which are neither explicitly
declared by you nor implicitly declared
by the Java language an example is if
you declare any num and you declare
declarant enum type and you declare a
constructor in there so you can say
things like penny 1 and dime 10 etc etc
it turns out that the parameters of that
enum type constructor are in fact
implementation-specific they're not
specified by the Java language back
there's a limit to how much basically
into compiler compatibility we can
guarantee these different kinds of
parameters actually it matters for
reflection that these different kinds
Mathur for reflection because often you
know typically we don't want to expose
what's in the class file if it's the
third kind of parameter it's an
implementation detail it should be
really hard to get to through core
reflection we should only be showing the
first kind stuff you write good and the
second kind stuff you didn't write but
you kind of know it's there and there
are there are actually quite a few
examples like this in the language and
so
this ultimately all comes down to we
create some new access flags in the
class file to distinguish the meanings
here the representation is trivial it's
a bit one way or the other but we say we
have this concept of ACC mandated so I'm
a parameter in the class file I have a
name I have whether I'm final and I have
I indicate if I don't indicate anything
at all then it's something that was
declared in source explicitly i can say
that I'm mandated which is I wasn't
explicitly declared but i'm here in the
class file because of a language spec
probably the Java language back but it
could be others and we expose that and
it should have get to the sense of a
compiler contractor we hope that this
flag is very very useful for core
reflection it's currently only supported
for parameters but we hope to get it on
two classes fields and methods it's very
useful in the class file to say what
kind of white basically why is this here
you go to class file you can run java p
on it why is the content here in the
first place and then there's the
existing ACC synthetic flag that applies
to classes fields and methods that we
let apply to our parameters as well to
say this guy's here because the compiler
privately decides to put it here and do
not rely on it being present next time
you compile nothing to do with us
entirely the decision of the compiler
Joe is going to talk about API evolution
and more about the reflective api's I
think for the next half hour probably
thank you Alex
now you may be a little surprised about
why we'd have a API evolution section
discussion about language features but
there is a surprisingly long list of
tasks you might have to take on if you
want to change the java programming
language besides the obvious ones of
updating the language specification and
reflecting those language changes in
your compiler often there's an interplay
between language features in the library
so you might have to update the library
to support the language features in
various ways in Cory flexion and
elsewhere of course you want to be
writing tests we want to make sure these
work and the job we also have
conformance tests so that other
compilers can implement the same
specifications when you update the
language you often have to update the
virtual machine specification as well
even in a trivial way even very small
changes to the virtual machine
specification have downstream
consequences for instance all the tools
which consume class files of which there
are surprisingly large number even only
just in the jdk platform often have to
be updated to accommodate that might
have that changed jay and i will be
talking a lot about the reflective api
changes we had to make for these
features one of the reasons a
serialization is amongst the least
favorite features of the platform is
because of the wide surface area we have
it has we actually had to update the
serialization mechanism to support enums
for example back in jdk 5 and as a long
and sad story behind that and of course
we want to update the Javadoc output too
so of this rather long list we actually
had to implement nearly all these sorts
of things for the annotation features
out alex has described the spectrum
compiler updates we had a very extensive
set of tests suite for these our quality
team as well as our development team
actually used annotation processors to
automatically generate lots of test code
so we testing thousands or tens of
thousands of different combinations of
possible things that were now valid or
invalid so that was all part of the test
methodology for these sorts of
annotation features Alex described there
are
new attributes in the class file those
attributes have to be respected by tools
like pack and unpack 200 which are in
the JDK so that's part what we had to do
to update that but there was a large
amount of work to update the reflective
api's and as with many things in Java
platform it's very rich it has a large
number of reflective api's so we have
Corey flexion java.lang.class and
javelin reflect there's the language
model API a tell vex line model that is
use primarily by annotation processing
but is not limited to be used in
annotation processing there's also the
annotation processing API itself that
you used control processors there's a
question about that before like how do
you tell your annotation process or
whether or not you want to process
certain kinds of annotations so the
specification there had to be updated to
accommodate there's also the doclet API
which hasn't been updated quite as much
so what's one of these core changes
needed for type annotations so you when
when you're declaring your annotation
type the way you indicate that this is a
annotation type that can be used as a
type annotation is to say it has a type
use element type so previously you could
say something like this can be put on a
a method or a constructor or a field now
you can say it's on a type use and that
lets the rest of the annotation
machinery know that this is a type
annotation in addition we filled in a
little gap left over from Java sc5 where
you couldn't put annotations on a type
parameter no fun emotion you couldn't do
that this is actually exactly analogous
to putting a annotation on a normal
parameter or a field or anything else it
was just an oversight back from j sr 1
175 and we fill that in house you can
also say your type parameter in terms of
the compatibility concerns we took in
mind so there's an enum that lists these
out and we made sure to put these
two new constants at the end of the new
type that meant the ordering of all the
previous Constance was the same in case
you're relying on that in some fashion
so Alex talked about before about the
changes to annotated element that's the
interface that includes the new methods
to read the annotations in different
ways and you can see them here we also
change an existing convenience method on
this interface there's an is annotation
present method that returns a boolean as
opposed to returning an annotation or
not this was around from jdk fall Ivan
we decided well we have this great new
feature in java SE eight of default
methods we can rewrite is annotation
present in terms of this other method on
the interface type and then we can get
rid of about four copies of this little
method without the jdk so just make our
lives a little easier for the new
methods in question there is a very
carefully worded and detailed
description in the annotated element
interface about the different ways you
can have an annotation present on a
method or type use or whatever you're
looking at it can be directly present
meaning there's some representation of
that annotation in the class file and
there are a few reasons we define this
in terms of the class file one of which
is that quarry flexion provides a class
file view of the world despite his name
and another is so that this makes it
clear that it's not just limited to the
Java language so if you're using class
files generated from different kinds of
language languages there's still some
notion of course election operating with
them you can have annotations present
the inheritance annotations can be
inherited and as was discussed
previously annotations can be wrapped in
these containers and you could also have
inherited annotations wrapped in
containers so there are many different
questions you might want to be able to
ask in terms of something is something
there on the element directly is it
they are in some sense because it was
inherited or was it there because it's
wrapped and you want to look inside the
container and look inside and with the
methods we've added to annotate an
element you can ask each of those
questions now and there's a different
method for that and the Javadoc goes
into detail including this table about
how to do what you want to the map that
regard now I mentioned before that we
replaced this convenience method on the
interface with a default method and if
we were writing this class from scratch
that's exactly what you want to do
that's how you want to code it up today
with the language features an eight
however ran into a little wrinkle when
we tried to retrofit this into the
existing type so we got rid of the
annotations so we know that a lot of
people like using newer versions of Java
Sea to compile their old sources so for
instance they'll take the Java Sea from
JDK 8 and they'll say source target 7
and then they'll recompile their classes
and they'll want to use those classes on
jdk 7 that's not quite a legitimate way
to compile your classes for jdk 7 unless
you also change the boot classpath the
RTR and the reason is the libraries can
change now what happens here if you
don't change to use the older group
class path is that that is annotation
present method is not visible anymore in
the implementation types because the way
Java Sea models things you have a
default what method from lewisham
something from eight and then you're
operating in a source seven context so
what does that mean it's kind of
undefined it's asking a unreasonable
question so since we you realize this
would be a problem for people in
practice we made a minor tweak to the
refactoring here where the code is
shared and we call the superclass but we
do you know they came out on the keynote
on Sunday also of previously this
conference compatibility is very
important so we do take this seriously
this is feedback we received during the
development of eight and we acted upon
so be a smoother experience using this
for our users
so up between for Java of five through
seven we could only apply annotations to
elements but now we can apply them to
types and of course there can be more
uses of types of a given type then
there's a declaration because in some
sense there's only one declaration of
the type now the java.lang.class objects
are tied to declarations of types they
captures the identity so if we have a
unique identity and multiple uses we're
not going to be able to use class
objects to directly model returning
annotations on type uses because we need
many of them this points out a initially
not obvious but long-standing flaw in
the design of the core reflection API
there is no separation between
declarations of types and uses of types
in co reflection before we had generics
one could argue in some sense there
wasn't a lot of distinction with them
from most perspective in core reflection
however when we have a generic you often
want to be able to do too serious
between I'm making a statement about
java.util.set as a concept and I'm
making a specific statement about set of
string versus set of integer versus set
of T versus something else and if you
need to make that kind of distinction in
an API you need some different way of
modeling those two different concepts
and corey flexion just doesn't have that
that distinction for many years class
doc interfaces that return the class
objects on the poor use so again those
are tied to the identities of
declarations so we we need many things
and we only have one so our solution to
this problem was to add new things that
could make the distinction we need so if
you look in the core reflection API will
you have a get foo method now there's
often to get annotated food method
that's a sibling and conceptually this
returns a tuple one part of the tuple is
the type represented by the class object
and then the other part of the tuple is
the actual annotations you have
and that's how we solve this this
identity problem a little bit later I'll
be talking about the job x lying model
where the impact of this change was
little was much less but the API impact
this was a surprisingly high there's a
five new subinterfaces for instance just
to support this very basic capability of
returning type annotations using core
reflection so just to just to make sure
this this concept is clear we can look
at a little example here we have our
class bar with a non of excuse me we
have our class foo its parent class is
bar and we say this is a non no bar so
we let's say we want to just discuss
annotations on super class if we do food
out class that gets super class and we
look at the annotations on super class
that will give us the annotations on the
declaration of bar and if we go look at
the declarations that might have a b c
and d e f in particular would not have
non null that's because the non null
annotation in this example is associated
with the use of bar as a superclass in
this case it is not associated with the
declaration of bar so to get the
annotations associated with the use of
bar we get the annotated superclass back
that gives us another object that has
one part that represents the entity the
superclass are in another part that
represents the annotations on this
location which is at nominal likewise as
we've seen earlier there are new methods
and corey flexion to return repeating
annotations the summary is all the
existing methods in quarry flexion for
reading annotations from jdk five six
and seven behave exactly the same on the
same inputs so if the classifier you
have today was repeating repeating
annotations looks like it does under jdk
7 you'll get the same answers so it's
only in the new methods will you'll get
different answers and you can really see
that there's a concept of repeating
annotations
versus a container annotation and things
that might be inside we can see some
distinctions here we can call the get
annotated types for different locations
now if you have a complex type you then
have to kind of go inside of it with
this unfortunate looking instance of
checks so there's not in court
reflection a very good API for
decomposing the types because
essentially what you need is a tree
structure representing all this but
there it is possible to do it with the
API we have in jdk age so that's what
this api feature looks like in quarry
flexion but that's not the only
reflective API we have fortunately in
particular the java lex lying model api
was designed around the same time this
paper by gulaab Rocca and dave hunger
was written which are very conveniently
lays out design principles one should
use when creating a reflection API and
these design principles were used in
both the apt API which preceded the
standardized and his processing API and
a Java XY model so it was um one of the
design principles from from the paper
was basically clarity of modeling and in
Java X line model there's a clear
separation between the declarations
which are called elements API and types
there's a separate packages to mention
these now since this API came into
existence to help model annotations for
annotation processing the parent element
interface contains a subset of the
methods of annotated element meaning
conceptually it has one of the both four
or so methods that were available in co
reflection but repeated in this
interface so in terms of code reuse or
semantic reuse it's very good in because
the way the API was designed there was
no we didn't have to make any changes to
the API to accommodate having
annotations on type parameters because
the type parameter
interface already happen to have a get
annotations method it just never
returned anything before so what did we
end up doing what we ended up doing was
actually fairly simple we created a new
interface to hold the methods to read
annotations we took the existing method
that read annotations moved it up into
the new super interface we added another
method to deal with repeating
annotations for the same reason we added
separate methods to Co reflection for
repeating annotations we want to keep
the behavior of existing method the same
and then we just had the element
hierarchy which models declarations in
fluent the interface which was doggie
doing half of and for the annotations on
types we just had the interfaces in the
type hierarchy in fluent this annotation
implement this interface with these two
methods and that was it it was all very
nice and clean because we happen to be
starting with API that was a better
model of the language what we had to do
how many people are familiar with
annotation processing oh good most of
the audience for how many people attend
one of the two back to back annotation
processing talks early today okay we
have a few few veterans in there so just
briefly for those not familiar with it
annotation processing is a
general-purpose metaprogramming facility
that's part of java sea it's with
standardized back in jdk sex and the
processor interface is how you have your
code your plug-in interact with the
compiler to communicate with it so a
question came up before your processor
tells that the processing framework what
annotations it processes so how to type
use annotations work with this not very
much the we decided to essentially
ignore type annotations for the purposes
of annotation processing for repeating
annotations also for compatibility
reasons there
not there indirectly ignored but the
recommendation is if you want to process
repeating annotations you should process
the containing annotation that join
columns as well as join column and that
way whether or not the code is written
using the direct annotation or the
container your processor will still work
if you've enjoyed using apt in the past
I'm afraid the time to do that is over
so we've removed apt from JDK 8 after
many years of warning including
deprecating it in seven so we always
knew this was a transitional technology
and we heated one of the calls we
frequently hear conferences to remove
the deprecated functionality from the
JDK so this this isn't part of the SE
API but we did remove apt and it's not
coming back now in case you're still
using apt having been the lead engineer
for apt and the annotation processing in
Java Sea I can say the annotation
processing in Java Sea is unreservedly
better it's faster the API is better so
you really should migrate if you can't
migrate right away there is a
transitional project here that
reimplement apt on top of java sea or on
top of the Java Sea interfaces to help
help you migrate there java SE aid
shipped this March we don't want to stop
there what else might be coming we've
talked about the core reflection API in
some of the shortcomings of it we've
seen Java x line model which is based on
interfaces so would it be technically
possible to have this more modern API in
Java x lying model implemented on top of
crusty old co reflection the java x line
model api was never intended to be
solely used for annotation processing
and was hoped that over time people use
it in other context and the answer is
yes it is docked really possible to do
this we have a little existence proof of
this in terms of sample code in jdk 8 it
conceptually is pretty simple which is
repeated uses of the adapter pattern so
you take a java.lang.class object from
Corey reflection and you create a Java x
lying model element type element wrapper
around it that you know does those are
proper forwarding you use some little
tricks with the quality and whatnot and
then you we have specializations for the
other sorts of things and pretty much it
went very smoothly so we have our base
API are our key from Java excellent
model element we create specializations
that are appropriate to call reflection
we also fold in some of the
functionality that's in the utilities
package in a Java X line model directly
into the elements here and add some
reflection specific functionality to so
that worked out pretty well one good
consequence of this exercise you went
through has actually improved the quarry
flexion API a bit for instance we now
have a Java line reflect a superclass of
both method and element cement yes
particles from a method in constructor
yes thank you if you looked at the
method and constructor classes and corey
flexion they had almost all their
methods in common sometimes you'd want
to abstract over them and there's no
convenient way to do so until now in
java SE 8 where we finally added this
new new class and there's a few other
classes there too this is something
we're looking to possibly bring more
into the standard in jdk nine so if
you're interested in this please give
the sample code a look and see if that
helps meet you needs and at this point
I'll turn it over to Alex for the
inclusion
so i can imagine someone coming and
saying wow this restriction about
annotations from java 5 where you
couldn't repeat them is really
irritating can you can you just change
the language to allow that and we could
say well yes that seems like a
relatively small change to make in the
spec and in java sea I wonder if that's
all there is to it and of course as
you've seen in this talk there's always
more to it there's always always more to
it in more dimensions than you think
there will be even if you think there
will be a lot so now for repeating
annotations you have to change the
compiler core reflection API language
model API annotation processing API no
JVM changes involve that but you know
lambda has formal parameters you want to
allow the representation of a lambda
expression which is quite magic inside
Java Sea look what a lambda expression
compiles do we want to allow repeating
annotations on those parameters and
perhaps on those type parameter perhaps
on the types of those parameters even
for this new lambda expression thing
that compiles it's a totally new code
how you can power lambda expressions
you've got to ask those questions and
I've mentioned the container pattern
that came from Java EE api's and so that
like I mentioned the the needs of the EE
frameworks governs the design of this
java language feature right type
annotations was a very similar story
less Java EE input but then because
these type annotations in new locations
needed class file changes you've got JVM
changes needed on top of that to expose
them through reflection the access to
parameter names are similarly you've got
more JVM changes to store them in the
class file Java EE is interested again
in the design and again reflective AP is
and then the language model on top of
core reflection there are no changes to
the core reflection API by definition
it's all it's all work in the language
model space and in addition to these
dimensions you've got various forms of
QA you've got the implementation QA and
the standards conformance QA you've got
specs you've got the Java tutorial demos
training
I de support remember the Eclipse
compiler in Eclipse is not Java C so
whatever we implement in Java Sea
according to a spec the Eclipse team the
JDT core team in the Eclipse Foundation
independently implements and that's a
great fantastic way of identifying both
bugs in Java Sea implementation and in
the design and you can see there are the
enhanced metadata spec discuss mainly
list at OpenJDK you can see eclipse core
developers and us and java sea
developers going not around around but
discussing some of the finer points of
the finer points of this kind of thing
and then of course you've got JetBrains
with IntelliJ as well so the summary of
all of this is that enhance metadata
annotations on annotations on steroids
in some ways plus more support for the
parameters ultimately this is about
enabling more powerful frameworks for
java ee or your own repeating
annotations make it easier to configure
those frameworks type annotations make
it easier to express properties that
frameworks might use and the parameter
names feature it improves readability it
fixes a long-standing bug it opens up
issues for us to clean up the class file
more in future and access to the
language model is a significant because
the API is so much better than call
reflection should improve ease of use
for framework developers in the future
and I think you would agree that
compatibility doesn't just affect but
dominates the language and API design as
usual you know that we surprised it's
always like this many individuals in
development and test and the EE guys and
the tutorial are involved in this it's a
significant effort with that I'd like to
thank you for listening and take
questions if there are any more
questions yes tues just a question
the question was about you can annotate
generic tight here's a generic type food
generic aunty so now that you can
understate so you can actually annotate
the tea as well that's the type that's
the type parameter so can you do
something the answer is yes this all you
know so this was showing type type
youths annotations and that first tee
after food is actually not to use it's a
declaration at I variable you know the
difference excellence you can do
everything you want to do you can do yep
question are you mean annotations
referring to each other I know what
that's to me no yes
to say the question again you said is
there a list of restrict is a
restriction okay so over over the years
it has become apparent that it would be
convenient to have other sorts of fun
things as the kind of information you
could retrieve from an annotation type
such as these funny method handles and
maybe field references and things things
in the future so that was duly
considered by the lambda expert group it
was not it did not quite make the cut
due to the non-obvious things would have
to be done to it so maybe someday not
right now
one right
there was something I wanted to add to
the conclusion that is the value of
being involved along the way we gave
another examples in this talk where we
made changes to the design and
implementation based on feedback so now
that nine is getting other way please
try out the nine builds which I've been
available for some time and let us know
how they're how they're going
the containing type that sometimes we
call it the base annotation yes so the
question is okay hello Chloe let me let
me let me write this this guy so there
are two class that there are two
interface 2282 annotation type
declarations one is the join column is
the repeatable type join columns is the
containing type ah if you call so if
you've got a method declaration say and
you call get annotations on it that's a
legacy method you will get exactly what
is in the class file which is to say
which is in this case app join columns
which is what you were getting in seven
because that's what users had to write
in source if you are writing a new
framework and you make your annotation
types look like this you can just say
get annotations by type join column as
the API designer you can opt you you
have to opt into the repeatability
repeatability so so the the provider the
annotation type has to opt into being
repeatable for these methods to work and
then you have to be on 8 or newer to
have the new functionality in the
annotated element interface
right and we have talked to our
colleagues to get the various ejs ours
updated to use the repeatability feature
for future versions ve yep this one
thing it actually is yep excellent
question if the so I'm going to assume
that the annotation type designer who
owns query parameter class hasn't
changed it right so it's still a that
was the elements I'd formal underscore
parameter it's not formal it should be
should be formal underscore parameter as
opposed to attack from any weight so its
parameter if that didn't change and you
recompile this work method it's still a
declaration annotation I know it's in
the same location as a type annotation
would be if the annotation type owner
added type use that is an unfortunate
aspect of the java programming language
that there is no other space to write
things before the you know we have the
type name and then the declaration it
would have been possible I suppose in
java SE 5 to say our a query paramus an
annotation on a declaration therefore
should go before the word ID not before
string before ID technically that would
be the right thing to do but they didn't
know in two thousand and they didn't
know in 2003 yeah it was just rhetoric
Josh block that's the type annotations
or type type use annotations to be very
precise would one day come along and
claim the same ground and there was a
question about disambiguating and you
know the next question I asked is can I
go to the definition of query pram and
say it's both a type view sanitation and
the parameter declaration yes you can
that has meaning and what happens is
it's actually both in the reflective API
so Joe talked about will if you ask for
it as a type annotation you'll get it if
you ask for it as a declaration
annotation will get it you actually you
actually have complete control over like
the four-dimensional space of this above
it guy Steele would want to talk to you
about this kind of a source code layout
yeah higher-order Declan higher-order
identifies yeah this was a significant
problem in the GSR 308 that designs type
annotations array types with all those
square brackets type constructors and an
annotation before a square brackets what
does that mean what is the natural
meaning of that syntax was a big topic
of discussion and views were welcome two
years ago frankly it was discussed it
was discussed in the open it was in the
spec it is what it is you can read in
the JLS how these kind of overloaded
source locations are treated and then it
goes into the reflective API I think
there's one question the back yours
before there was there a question at the
back okay there's a question the front
then
oh my
the were actually
there was no feedback from Scarlett
people but you you'll say that you can
say whether an annotation I want to be
clear we let you say as the annotation
type owner whether annotations of that
type in all the millions of programs
they will ever be written in can be
applied to declarations or uses so we
let you do that are you saying Scarlett
should do something more that's the type
declaration absolutely yes okay
yes so right as I understand so the java
ways it's up to the API designer the
owner boxing on this is this is
repeating annotation more than type
annotations but the owner of the
annotation types gets to decide just
like with default methods the owner of
the interface declaration gets decide
what the default methods are you can't
monkey patch things later as a user
that's the Java way ok I think that's
all thank very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>