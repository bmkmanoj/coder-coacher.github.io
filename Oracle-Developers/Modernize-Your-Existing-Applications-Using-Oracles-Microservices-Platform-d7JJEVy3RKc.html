<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Modernize Your Existing Applications Using Oracle's Microservices Platform | Coder Coacher - Coaching Coders</title><meta content="Modernize Your Existing Applications Using Oracle's Microservices Platform - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Modernize Your Existing Applications Using Oracle's Microservices Platform</b></h2><h5 class="post__date">2018-03-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/d7JJEVy3RKc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">everyone Oh start slowly so my name is
Peter er Shabbats I'm a consulting
member of technical staff at Oracle if
you're wondering what that means I'm a
software developer I basically write
code but I have this nice and long title
to Oracle I spend about 10 years at
Microsoft when I was working with Azure
and cloud and in the recent year so I'm
mostly working with communities and
micro services so today I'm gonna talk
about modernizing your existing
applications using micro services before
we start you've probably seen this as
the previous presenter said whatever I
say I'm lying so anyway so how many of
you have heard about micro services all
right anyone building them already right
running in production as well yeah all
right that's good so I'll spend a little
bit of time explaining what micro
services are just very shortly compare
it to how does it how do they compare to
monoliths then I'm gonna talk about some
best practices the way that micro
services interact with each other and
finally I'll touch on some monitoring
and diagnostics and something about how
you would go and migrate your existing
application or existing monolithic
application to micro services so what is
a micro service if you usually when
people talk about micro services they
compare it to monoliths so if you think
about a monolith as a bunch of
functionality or capabilities built into
a one process or one executable you can
similarly think about micro services as
a single capability and a single app or
a single process further on there's big
differences in way well not necessarily
differences in way the monoliths versus
mic
services are deployed it's more of
consequences that they have in regards
with deployment for example if one part
of your monolith you make a change to
one part of it I can just ship that one
part of it you have to ship and package
the whole thing and then you can release
it with micro services since you're
basically sliced your monolith and just
in two different pieces you can deploy
each piece separately so you don't have
to deploy the whole application you can
just deploy your shopping cart for
example you can just scale out your
recommendation service you don't have to
redeploy the whole thing also one thing
I want to mention is micro does not
necessarily mean that the service is
smaller it has to do more about the
complexity of the code so you can think
about micro services being less complex
then probably huge monoliths are they
still have a famous model list they have
business logic they have a data store
and they also expose define API
so some of the best practices for
building micro-services just treat them
the same way you would treat any other
product that you're building it has its
own code base and as its own release
schedule its own versioning basically
you can deploy and develop them
independently from each other make sure
you're thinking about service boundaries
so each micro service should have
well-defined API and well-defined
boundary and make sure you're not using
or using any shared libraries because if
you have services depending and share
libraries you'll yeah it's very bad once
you reach hundreds or thousands of micro
services and you change something or you
want to rev the version of the common
library basically they're not in a good
spot finally about data handling this
one is pretty important each micro
service should own its own data store so
if you have let's say an order micro
service and you have a recommendation
micro service recommendation micro
service should never go and talk to the
order service database directly ever
right always use the public API they
should always go through the public API
since every micro-service owns its own
data store you'll eventually run into
some eventual consistency issues in a
monolith you're basically you can update
a bunch of things in one transaction
there's there might be multiple data
stores but you have everything in one
place but micro-services is distributed
and you have each service owning its own
data store it's just a mess
don't even try doing distributed
transactions because you'll run into
deadlocks and you run into a bunch of
issues you should perform all of your
that include involve data in an
idempotent way basically if I give you
an example let's say I have a bank
account service and I called the service
because I want to withdraw $100 and that
call fails so next time I call that
service it should not withdraw another
$100 or it should not withdraw that
hundred dollars multiple times so
idempotency basically means that there's
no effect on the system's
if you call it multiple times the way
you solve this or make it better as to
or manage it rather is to add a your
calls or requests that way the service
can use the request city and check if
this message has already been processed
and if it's been processed it's just not
gonna do anything
another way you could manage this is if
you're using event sourcing what event
sourcing is you're basically storing all
the events and you're basically keeping
a record or off all the events that are
happening throughout your system right
so we have one ledger where you're
keeping all the events that are
happening and in addition to that with
compensating you would also store the
pointer to the code it's going to undo
the action so if you think about having
workflow of let's say 15 different tasks
right and the task number 5 fails how do
you know to undo that transaction or
that whole work these patterns you know
all the records you know the changes
that happen between calls and since
you're also storing the code or pointer
to the code on how to undo that action
you can basically play everything back
and just undo each of those actions to
get to the clean slate next point is
about api's as I said is the way the
micro services communicate to each other
so make sure your document and well
there's a tool that I want to mention
it's called swagger
so with swagger you can use JSON or yamo
to describe your API and basically
describe your endpoints you describe the
inputs you describe the outputs so you
basically have one source of truth for
your API and I think there's a nerd talk
later today there's gonna talk about
some swagger anyone's interested in that
also thing to keep in mind is that
you'll have to publish those changes to
any dependent services any services that
depend on the API that have you've
changed and finally about security at
each level at the orchestrator level a
platform Orchestrator container and
finally at the service level make sure
you're thinking about security and
securing your micro service
so let's talk about microservices and
interactions a little bit I have a
simple example of how microservices
might interact with each other so I have
a front-end micro service which is
basically my website and then I have an
order and profile micro service which
are two of the micro services that I'm
running each of them have its own data
store I also have a registry so registry
is part of the orchestrator where you're
keeping track of all the services of all
the service instances you can do routing
based on versions you can do a lot of
things there finally there's a
Diagnostics part where all the micro
services basically send their
Diagnostics data in and I would hit the
load balancer the load balancer would
serve me up but basically ahead of front
an instance of a front-end micro service
that would serve me up the website that
website if it wants to if it wants to
call for example the profile service it
would go through the registry service
registry service will resolve the actual
service address and it's gonna just
forward the call to their profile
service similarly for orders or if any
other micro service needs access or
wants to call any other service it would
go to the registry to figure out its
address finally all the micro services
are forcing data to comma and
Diagnostics store and go and look at all
the logs later
I mentioned the service registry and
discovery a little bit here is if you
think about a monolith and you're
breaking up your monolith and you end up
with hundreds of micro-services the
service registry and discovery needs to
be highly available and scalable you
don't want that to be a bottleneck in
your system also it should support
service announcements and API lookup as
well as notification notifications and
health checks so for all of your micro
services you should and I highly suggest
you do that it's a good practice
implement health check for example for
my order service I might have an
endpoint called health and what I do
when that endpoint is called I might
check if the database is up I might
check if any other service is up and
running and basically return a 200
response that everything is good in case
something goes bad the database is down
I will return a 404 400 and then the
orchestrator knows that's a signal to
the orchestrator to take that service
out of the circulation and it's not
gonna route any requests to that broken
or unhealthy service it can also tie
into like an alerting system you could
get an email or its popular these days
to get calls 3:00 in the morning if
something goes wrong so you can look at
what's happening anyone using kubernetes
alright so kubernetes has all this
already built in pretty much there's
health checks there's I think kubernetes
also differentiates between health
checks and readiness checks so readiness
is something is going to tell the
service discovery that your service is
up and ready to receive requests in
addition to having a health check or you
can also use a managed service if you
wish such as like an API gateway for
example talking about API gateways
external internal services
basically external services give clients
access to your services they basically
if I talked about a gateway which I have
an example on the next slide you
basically have one entry point and you
encapsulate all the other services with
it and your API gateway acts like a
single entry point next point is the
internal services again run inside your
cluster or inside your system they're
only accessible from the other internal
services and there's no like it's all up
to you what protocols what serialization
you want to use just optimized for
performance right there's no outside
requirements for it here's the gateway
pattern that I mentioned again person
sitting at a computer hits the load
balancer it's gonna hit the API gateway
and then the API gateway will basically
do the correct routing to the micro
service and needs keep in mind that this
might introduce a single point of
failure you also have to maintain this
if you're writing your own there are
probably some managed api gateways out
there that you can use they have a lot
of like diagnostics and logging already
built in just keep in mind it's a good
it's a good pattern if that's what you
need pretty much some more about
communication between services more
services more communication of course
more data flowing usually the protocols
between services are HTTP and HTTP
internal services can also use TCP or
UDP if you're doing a lot of
serialization or the serialization that
can be a bottleneck imagine having
10,000 of 10000 services calling each
other each of those services doing some
serialization deserialization
it can become a bottleneck right so
distributed systems will introduce
things that you haven't thought about
earlier before we can
something that's a small thing and a
monolith might become a big thing in a
microservices architecture therefore
make sure you pick your serializer
wisely
in addition to json look at protocol
buffers or flatbuffers and I'm assuming
you're mostly Java developers yes anyone
using anything else or Java alright so
the combination of Jersey Jackson and
jetty sorry jetty if used this
combination of tools you can get brief
are they're pretty good and weld
implemented so you're starting this is
fine so talking about more communication
and more services it basically means
that it'll have to you think about retry
policies failures how to recover from
errors all those things mm-hmm
here are some of the patterns the
simplest one or the first one that you
should probably implement is a retry
pattern it's fairly simple you call some
endpoint if it fails you're gonna retry
you're not you shouldn't be just blindly
retrying indefinitely right because you
don't want to strain a system so we
implement a retry policy that says after
each call sleep for at for example after
the first failing call sleep for one
second make another call if the second
call fails sleep for three seconds
you're basically doing a back offs right
and then finally if it fails in the
fifth time just failed throw an error
and say I don't want to I I don't know
how to deal with it right second pattern
here is a circuit breaker pattern so
explain the difference between retry and
circuit breaker let's take the let's
take that you have an endpoint that
reads some data from the database with
the retry pattern you're basically
calling the end point and the endpoint
is gonna try and call the database and
it's gonna fail it's gonna sleep it's
gonna call again it's going to
so what the circuit breaker does he
basically define a threshold who say I
want this circuit breaker to trip after
five failures right so you make the call
the the call to the database will fail
five times on the sixth call the circuit
breaker will trip and it's not gonna
call the database anymore because it
failed for the fifth time it will return
the error directly right so the
difference is that you are put a circuit
breaker you're not straining the system
as if you would with the retry pattern
so it's just you can think you can think
about a circuit breaker as an object
around your functionality the tracks the
number of failed calls right finally
bulkhead pattern the idea here is that
you would put in your services for
example you could have your warehouse
management services in one group you
could have your financial services in a
group which we would have anyway but
just for an example the idea here is
that if your if any of the services in
the financial financial group fails you
don't want to bring down the warehousing
system or weight housing services so you
would use this pattern to basically
isolate the services and group them
differently so they're not impacting
each other and of course services will
fail if you have one model if one binary
you wish with microservices you have
hundreds of them hundred binaries more
communication they'll fail like your
hard drive will die someone will pull
the plug somewhere something will happen
so plan for it so this gets us to
monitoring and diagnostics the most
important thing here is to make sure
you're defining a common logging format
and make sure you do that when you start
implementing your services like don't
wait for
don't wait until you have ten or fifteen
of the services and then try to
implement some well you should do it but
you can get a situation where you have
hundreds of services and all of them are
using different logging formats so your
next couple of months are basically
going to be spent implementing our sirs
and implementing converters from one
format to another format so it's
extremely important to have a common
common logging format across all of the
services in terms what to log there's no
like any special things that you should
log log whatever you've been logging
before and user requests any failures
stack traces the service heartbeat if
you wish what I always like to say here
is that if a service fails for example
if I get a call 3:00 in the morning and
I need to look at the failing service I
don't want to go to the code I want to
go to the logs I want to try to debug it
from the logs first if that doesn't work
just revert to the previous version
that's tough but make sure you have good
logging in place that will help you
debug your service we're not looking at
the code we should also aggregate the
logs for the entire request I'll show an
example in the next slide and use a
centralized system where you can go to
look up all the logs from from your
system you can also log performance data
so you can also start with dad you can
see the trends and you can see if
there's any birth issues system-wide and
the last point here is make sure you're
logging baseline or you define a
baseline for your service like this is
the normal service status because once
you have that then you can implement
alerts on any difference from that
baseline like if it's easier to do that
if you know what the healthy state means
like if if having sorry yeah yeah you
could do that yeah you could do response
time and then you can say if the
response time is greater than 3 seconds
whatever I I know that something's wrong
there
yeah there's other things that the other
thing is like response time of two
seconds might be good for you you know
what I mean like if you're doing some
intensive operation two seconds is not
that bad right so that's why you need to
set a baseline to know like if if my
calls are two seconds or less then it's
all good
right and if it's more than two seconds
or if it's five then something's wrong
or you can translate that two
milliseconds as you wished
yes so here's an example of how you
would log or actually use activity and
correlation IDs again that's me or
someone sitting at a computer
I hit a website the first service that
is hit or called is going to generate
like a random ID and that ID is then
gonna get passed to any downstream
service that that gets called and if you
follow all the good logging practices
right all the services will log its own
status as well as this correlation ID so
what that means once the call is over or
once the whole once the request is over
basically you can go through your blog
aggregator or your diagnostics and
monitoring page and you can basically
trace the request from the beginning to
the end and you can see you could see
birth data you can see any errors that
happen in between and another good thing
with this what you could do is you could
report this to an end user for example I
go to a website I try to log in or do an
action I would like to see that request
ID and a message that tells me contact
our support and tell us this correlation
ID for example that way they can look it
up really quickly and see what or what's
happening
and basically diagnose diagnose the air
alright let's talk about how would one
go in migrate to micro-services I'm not
telling you to migrate to micro-services
it's everyone's decision if they want to
migrate or not but it is where a lot of
people are going it's a trend so here
are some of the reasons like a lot of
them stem from the fact that you can
scale and deploy micro services
independently so if you want faster
time-to-market
you have smaller services that you need
to be that you can deploy you can scale
them independently break down your
application make sense to do it right
another point is let's say let's say you
have a portion of your application and
you want to rewrite it because there's
better libraries for it or there's some
better frameworks but it's not in the
language you're using right I think
python is popular with machine learning
so let's say if you want to do some
machine learning you could break that
piece off implement it and find on and
then use that instead of your instead of
the language that you're using for your
monolith and finally if your code base
is got that gotten big and complex it's
always a good good decision to try to
simplify and try to break off pieces and
work on them separately as for some of
the options there's probably not
probably there are a bunch of other
patterns that you can use here the first
student can get you started
strangler pattern and anti-corruption
lair patter both of them are very
similar and they can help you get
started breaking breaking off breaking
pieces of your existing application and
implementing it in microservices way so
here's an example our strangler pattern
would work it would basically the way
you would do this is you would implement
a facade first and in that facade you
would route the request to your existing
application right that's stage one if
you wish
then you can take pieces of your
existing application break them off
implement or really implement them as a
micro service test them in isolation etc
go back to the facade and then update
the facade so it's gonna route the
requests for that piece of functionality
to the new micro service instead of a
instead of an existing application note
that the architectural wise it's you
still have middle where you still have
data store so there's not there's not
differences there right as you break off
more pieces you're gonna be left with
less stuff on the left side and more
stuff on the right side hence the name
the strangler pattern
you're basically strangling the
application and creating smaller pieces
out of it until you're left with
hopefully nothing on the left side and
bunch of things on the right side
similarly to the strangler pattern
there's the anti-corruption layer
pattern again there's a facade same
thing the only additional thing here is
the previous slide this is not real
world like no one has a clear cut
between their functionalities and
components and most of the cases
anything that you break off from the
existing application will probably
depend on something that's in your old
application still in that case you would
introduce the anti-corruption layer
which is basically a translator for a
meter new API to the old API or new
database schema to the old database
schema and similarly as with the
strangler pattern you're moving stuff
from left side to the right side once
there's nothing on the left side we move
the AC layer and you're done yes yes
it's basically it's like I would never
go and take an existing like a
monolithic application and say all right
we're throwing it away and implementing
everything from scratch
there are cases where that might be a
good decision but I would always caution
people to start with like start with
small right if you always developed
bigger monolithic applications right
start small make it a test you know what
I make an experiment take a small piece
of the application implemented get into
the feeling of the developing and
working with microcircuits yes yes as
you're exactly as you're transitioning
so once you don't have anything on the
left side anymore right once you've
moved everything to the microservices
there's probably no need for that piece
anymore it's just a stopgap - so for the
new stuff to talk back to the old steps
so welcome to the distributed computing
world a lot of communication more
services your performance of the system
might go down so be aware of that
there's gonna be more error checking
more resiliency that you have to think
about in regards to your services
services are also harder to test some
monolithic application are of course
hard to test as well but if you think
about Twitter or Netflix that has
thousands and thousands of micro
services in production imagine testing
one service in isolation and that
service depends on 500 downstream serve
upstream services and has 300 downstream
services that it calls it can get very
hard against good logging will get you a
long way
similarly for debugging it's it's almost
impossible right it's very hard to debug
and there are some tools out there but
everything is pretty much in its infancy
still another thing that I forgot to
mention in previous slides is version
handling since you're not deploying one
thing anymore you don't have single
version of your application you will end
up with hundred different versions of
different services and you will be
deploying and implementing them in
appendant Lee so make sure that as you
rev up the version on service a that
you're not breaking service B or C or D
so just keep that in mind you have to
figure out a good way to handle
versioning finally more services more
moving bits and pieces automation
becomes harder so start automating
things even small things like builds
deployments everything make sure you
have scripts because your ideal state
would be you press a button and you
deploy the service to production without
any interference from another human that
would be the ideal place not all of it
is that bad like being on the side where
I was developing micro services it gives
you more freedom as a developer to pick
the languages and pick the frameworks
you want to use if you're a Java shop
you don't have to force the Java
language on everyone if you if it
doesn't make sense right if something
makes more sense to be written in
JavaScript or NGO or Python go for it
right just make sure you have
well-defined API and the services can
talk to each other through the API it
doesn't matter what's underneath also I
mentioned this before you need to get to
a state where you can develop and deploy
services faster so you've probably heard
stories of I think it was Netflix Ted
you don't Netflix or Amazon where to get
hired by Amazon you're supposed to
publish the production the first week
here they're right so they have micro
services and everything so fixing a bug
should and deploying to production
should be just like doing f5 or running
something locally on your machine right
so you want to get to that state because
you can you can fail fast but then you
can also revert back to a previous
version really fast I can Microsoft for
example when we were running some
services and production as I said my
first thing when I got a 3 a.m. morning
call was look at the logs is this
something that I can fix by scaling up
the service if not I'll just
revert to the previous version and
that's it I'll look at it in the morning
I don't want to spend time but in order
to be able to do that you have to had
good tooling and good processes in place
and everything needs to be automated be
flexible lady your team pick the
languages as they said frameworks they
want to use but make sure you provide
some standards as well such as logging
standards because you don't want to be
in a chaos right that just invites chaos
finally your services will fail so
always assume failures and build for
resiliency so I'm going to show you a
simple I was going to try to I don't
know if I can talk here and then doing
them on there Oh perfect
all right so this is just a simple
simple service or simply oh you don't
see anything full screen all right
front in here I have two services our
front-end service and a back-end service
if they click on the pants it's linked
it's basically gonna call the backend
service and it's going to show me all
this data so let me generate some just
do refresh a couple of times to generate
some traffic so I'll show you a couple
of open source tools so you can
integrate today if you wish the first
one is Zipkin so this is without any
extra like I didn't write any code to
get this to work I only wrote my
services and they talked to each other
that's it so if I had a more complex
system you would see potentially
hundreds of services here but right now
you see a front-end and there's a
back-end here this is beginners ball
this goes with Diagnostics and tracing
so I can simply say fine traces I can
filter it down to let's say back-end
only they're gonna see these are my
traces so there was a call from the
front-end going from the front end to
the back end it shows me the time it
took and there's a bunch of extra
information that's included again single
line of code that I wrote to get all
this another tool which is called
visceral let me just generate some more
traffic here by the way I'm running all
this locally if you're if anyone's using
kubernetes you can run it locally now
using docker for Mac it's much easier
than getting a real cluster if you don't
have means to get a real cluster go here
so I generated some load so now you can
see on the left side it says unknown but
that's the Internet traffic so there's
traffic coming from from the Internet to
my front end and from the front end to
the back end let me just refresh so you
can see them there's like a nice
animation of calls and it happens let me
try and refresh oh look at that see it
shows you how the traffic is flowing
from the internet to through my front
end service to the back end service it
also shows you the response times and it
can also show you like the details of an
IP like where the actual instance was as
well as any incoming or outgoing
connections and finally a chakra fauna
this is completely configurable you can
do it on your own
well you can configure it on your own
the way you want it but it basically
shows you traffic to and from your
services
with that sorry the last one agra fauna
yeah bro fauna is the last one
previous one is visceral and then the
first one was Zipkin that's pretty much
it for me if you have any questions feel
free to ask now or I'll hang around here
for 10-15 minutes more so so the second
tool is called visceral with me I'll you
know what I'll put it in two slides and
I'll add an extra slide and then you can
download it but all the tools names yes
so you know so the question was what to
look like how do you start basically
breaking off do you start with the
highest use or what is the I will I
wouldn't start with the highest use
component unless you have like
experience and you've done like micro
services before you know what to expect
you have tooling in place and processes
in place I would start with something
that's let's say insignificant or
something that even if it's down for a
day it's not gonna have a huge impact on
your business that way you give your
team some time and leeway so they can
learn right but once you get up to speed
it's just gonna go I'm pretty sure teams
will be on the onto the next service and
finding the next component they can
break off and implement yes
nothing else comes comes to my mind
right now but that's one way that you
could implement it I can if you want to
talk afterwards we can discuss it more
but I don't think I don't think that's
definitely not the only pattern that you
can use I'm pretty sure there are others
just can you can think of anything but
the idea is pretty much the same you're
storing your events and you're storing
the information that's needed for you to
revert that event also you need
something that's gonna do the reversal
or the starting of the workflow and a
reversal of the workflow right yeah so
what I would do is you would you would
probably make the calls at the point
that it fails you might need to call
another service or publish an event that
says transaction with this ID failed and
then another service might pick that up
and say oh this is I'm the transaction
cleaner service or controller or
whatever and that service would go and
look at the event data and just replay
everything back in reverse and revert or
undo the actions that the micro service
is made yes yes yeah but you're caught
like think about it's reverting the
transaction or reverting an action on a
service is just a different call from
applying that you'll be basically
calling the same service again and just
in a with a different operation right
sorry
sorry
yes yes like the distributor systems are
hairy and hard yeah
well well again it all depends you break
off and form you formulate your services
but you should always go through the
public API I always go through the
public API and that's how you talk like
a service if you think about the API
gateway for example right a service
service a right will call through the
API gateway to say I want to reach
service B and get some of its data so
the Gateway will figure out which
instance of service B to call and you're
gonna get back the information right if
there's a like I would again depends on
depends on your application right
ideally you would have one service
responsible for let's say one table in a
data store right like you would have a
user service and that user service would
know how to create a user delete a user
whatever right everything user related
if there's an order that needs to be
created it's gonna go in the order
service made
true yeah yeah but but your location
service would be separate right even
though it's used by multiple services as
long as you're going through a public
API and since location service is
something it's going to be used no more
you could bump up the instances for
example right it'll make it easier sir
yes yes
yeah yeah I would say though you can do
like its it gives you an option to
rethink like you know how it is whenever
you finish a product we always go back
and it's like oh if only we could do
this differently or change it right this
is your opportunity to do something
different if you
ah yeah
hard to say there's no like I could say
either-or and I could be either correct
and I could be wrong
hey it's I I would I would personally do
I would experiment I always like to
start small right start small get it out
there see how it performs see what
you're missing oh there's a need of cash
would it make sense do this with this if
you have all the all the tools and
everything in place you can get
information right away right there are
some techniques I've heard like Twitter
for example what they did is they would
deploy a test version of their service
to production right and then route
actual user data through that service
just to gather information and see how
that service performs without actually
affecting user experience so when the
call would come in and at the load
balancer they would duplicate the
traffic right and send the actual
production traffic to production
services and send the other duplicated
to do the test to hit the best service
as well to get information there's a lot
like there's huge opportunities a lot of
interesting stuff to do in this space
yes
so what are the biggest challenges for
moving to from monolith to microservices
I think it's a mindset like at least
10-15 years ago it was I'm talking about
my experience in Microsoft right all the
the shipping period was a year like I he
worked in virginal studio and we would
start on January and we would ship the
next year
so there was enough time to do planning
do testing do like we had enough time we
would spec everything out etc etc today
you cannot do that like you're gonna
you're gonna lose because someone in
Silicon Valley or whatever is gonna
spend their weekend and come up with
something and just gonna ship it and
you're gonna try it out right so I think
to go back to your question I think
mindset is one of the things that might
be hard to well how are we gonna just
ship this and then without like rigorous
testing and everything like
theoretically your users will be testing
the product for you
assuming you have good monitoring things
and everything to catch those errors and
you have a good fall back - fall - if
your service fails in production for
example that's one of the things the
other thing is the whole distributed
nature as I said there's a lot of
connections going from a lot of
different boxes to a lot of other
different boxes that's challenging as
well - like to understand and actually
work in that in that area and there was
one other thing that I wanted - yes
tooling right duelling there's a lot of
tooling and stuff out there but it's
still not perfect right it's like it's
very hard to debug for example a micro
service I can run it locally but that's
not the same right it's not the same
environment I want to run it inside my
cluster to see how it behaves I so hope
that answers the question
yeah yes
true like if you're starting from
scratch building on a service you won't
have any users right or if you don't
have enough traffic or enough diverse
traffic to try it out it's
well the idea here is that you're just
duplicating the traffic right so the
actual user is not gonna see anything
but again to get to that state you have
to have infrastructure in place it's it
goes to the the tooling is not mature
enough right hopefully one day it would
be nice if I can just go to my
monitoring dashboard and say I'll send
all the traffic from like duplicate all
the production traffic that I'm getting
and just send it to this this set of
micro services it's gonna figure out
reads and writes from a database like
that's a big that's the first challenge
that you're gonna hit right
okay so user logged in which database do
you read do I read the production
database or user bought something how do
I like I don't want to touch production
data and I said there's a lot a lot of
challenges right but a lot of new things
that you can work on and experiment with
all right we're out of time I'll be I'll
hang out here for a couple of more
minutes if anyone has more questions
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>