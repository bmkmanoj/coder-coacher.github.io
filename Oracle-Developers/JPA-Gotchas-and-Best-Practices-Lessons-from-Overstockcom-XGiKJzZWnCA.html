<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JPA Gotchas and Best Practices: Lessons from Overstock.com | Coder Coacher - Coaching Coders</title><meta content="JPA Gotchas and Best Practices: Lessons from Overstock.com - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JPA Gotchas and Best Practices: Lessons from Overstock.com</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XGiKJzZWnCA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right glad to see so many people
excited about JPA and just out of
curiosity how many people currently use
JPA in their application that's just
about a majority how many people are
using hibernate as their provider how
many people are using eclipse link let's
say there's open JPA you know a few
valiant souls here and what's on
datanucleus
anyone using that anyone that didn't
understand the questions ok nobody good
one guy all right so Who am I
my name is Neil hardener I'm a lead
Software Architect at overstock.com and
I have about eight years experience with
hibernate enough anybody who any of you
are at the there's another JPA
presentation yesterday by I think her
name is Patricia I like to actually put
it she had a relationship with hibernate
had its ups and downs it's kind of how I
am some days I really love hibernate
some days it really hates me and you
know but it's it's such a ubiquitous I
mean everybody uses it unlike web
frameworks where there's dozens of them
that seems like JP is sort of the de
facto in the Java world and you know I
think the things that we're going to
talk about are some of the there's a bit
of what seems like magic and JPA and
like magic can be really cool you know
we all like magic tricks but it's not so
cool of them like instead of pulling a
rabbit out of the Hat like the rabbit
explodes or something and so I'm kind of
the guy I wouldn't call myself like a
JPA expert I mean I've worked on it a
lot that's just you know when the
rabbits exploded over stock I'm like the
guy that has to look into that kind of
stuff so I'm just gonna share some of my
experiences with things that have
tripped up developers that I've seen
often you know we've had a lot of
developers come through overstock so
Toby a bit about overstock we're online
e-commerce company last year we did 1.3
billion ins in online sales and this
year we're hoping for more might be 1.5
and there's a company in Gomez that
measures all the different major
ecommerce sites measuring for
performance front end time back in time
and over suck often wins the you know
the Gold Award for the fastest retail
site on the internet and if we don't win
ever usually AK in the top five and so
we do that even you know using hibernate
so hibernate can be performant you can
use it on a large e-commerce site with
lots of traffic can still get really
good numbers out of it
overstock is headquartered in Salt Lake
City between Devon tests we don't
necessarily count them separately but
there's 300 developers and testers it's
usually two to one ratio so I'm guessing
there's probably 200 developers at
overstock and we'll get the obligatory
hiring site out of the way we are hiring
looking for good Java developers if
you're not a good developer we prefer
you apply at Amazon so actually I take
that back because I do a lot of shopping
at Amazon so maybe a Walmart I don't
tend to shop there a lot so you can
visit our website
overstock.com such careers most of the
developers are located in Salt Lake City
so we pay for relocation but we we
strongly prefer that everybody work at
the Salt Lake location or you could
shoot me an email that's my email
address the the slides I'll get to a
point I'll shoot show you a link all the
slides are online there's going to be
some code samples that you can also get
online that are on github I'll point it
out when I get there so you'd have to
worry about taking pictures or anything
because because everything is already
online so let's go through the agenda so
we're gonna talk mainly about entity
management which the main topics there
the entity manager transactions flushing
and dirty checking a little bit lazy
loading we're gonna look at some
real-world examples from overstock where
JPA has kind of surprised us and along
the way I'll try to give you some tips
on how you can sort of change APA to
avoid some of these gotchas and most of
these things that I'm going to talk
about if you've read that book they're
in there somewhere I mean the books like
yay thick and one time the book went
missing at the office and I couldn't
find out couldn't figure out where it
was I'd found out somebody was using it
as a monitor
because it's you know such a nice big
book so hopefully if you haven't read
the whole thing you know I'll give you
some maybe some interesting points out
of it they'll help you so when we talk
about JPA I think there's two phases to
it when you first look at a hibernator
JPA you're thinking I just need
something that takes columns in a
database maps it to fields in a class
and then there's this other thing this
other side called the entity manager
which is doing things like you know
hibernate the session and it's the
keeping track of what's in the
persistence context and when things need
to be pushed at the database and all
that kind of stuff and that's sort of
I'm gonna focus on is what I think is
sort of the you know the uglier side the
the more magical side and often less
less spoken about so you know just just
to define what what the entity manager
is so entity manager it's the unit of
work it's a single-threaded
class you shouldn't be sharing this
across threads there's a factory so you
can create one per thread and it's sort
of things thinking of it as a direct
abstraction on top of the database it's
better to think of it as a queue of
sequel statements that at some point or
are going to be synchronized or sent to
the database and then it's this map of
all the the entities all the the data
that you've loaded from the database or
that you were intending to persist to
the database so let's jump into some
code and we're gonna start with a I'm
just going to do a simple scheme and we
can see kind of some interesting ways
that we can get you know pretty
interesting behavior from hibernate just
with a simple example here so let's
suppose we have a person table and
person has you know an ID which is just
a surrogate primary key we're gonna have
it be sequence generated it's got a
first last person has person last name
will have an address so that we can have
a one-to-many relationship where a
person can have many addresses so if we
look at this
it's pretty simple if you use JPA you
know this should all be standard stuff
we've got an ID we've got we I don't
even need to put those at column
annotations because hibernate assumes
they're going to be part of the
the database attack actually have to
mark them as transient if I didn't want
them to be the same thing with my
address entity it's just got you know
simple properties and and then it's got
immunity to one back to the person so so
let's jump into our first you know let's
pretend you're new developer coming on
you want to use hibernate so we'll
actually try to do this some live coding
and see if this works
so I've taken this code that was on the
slide and first I'm gonna gloss over how
I created the entity manager Factory but
you know that sort of just reference
material you look up how to do that I'm
gonna create a person I'm gonna create
myself and as this font big enough to I
need to make it bigger for people in the
back a little bigger okay let's do that
luckily I am an Eclipse expert on font
resizing so let's try and maybe that a
little bigger okay any bigger and it's
constructor wrap off the screen so
anyways first line create the entity
manager I'm gonna create myself this is
just you know my pojo that I've
annotated with JP annotations I'm gonna
persist and then if it makes it to this
point I'm gonna say hallelujah I have
been saved and close it so now I've got
this project called p6 pi which is a
driver that can sit between the real
driver and in this case hibernate and
what it will do is it'll show me the
output when I run this so actually let
me let me run it again will clear the
output so jump in here start with my
entity manager nothing really
interesting is gonna happen on the
database yet once I create the person
now here we're going to think okay at
this point a lot of developers would
when they're first using hibernate would
expect at this point we're gonna insert
data into the database but actually all
that happened was Hibernia went to the
database to get an ID because the the
minimum contract for persist
is that after you call persist you will
have an ID or an identity on your object
and so another theme with hibernate is
that hibernate is as lazy as possible
and it does things as late as possible
it for the most case and so in this case
it was being lazy said I don't really
have to insert into the database the
minimum I have to do is just grab an ID
from the database and since I'm using a
sequence from the database that's why I
had to go to the database I could have
used like it could have used an ID that
I generated client-side like a UUID in
that case I wouldn't have even gone to
the database at all and I keep going I
print it out and then once I close well
now surely here it's gonna get flush to
the database but in fact it didn't so
this should be a pretty easy one why
didn't it flush to the database anyone
didn't do a transaction it's correct
so however it was kind of just jumping
back here you know it lets you kind of
do all these things outside of a
transaction and if you never start a
transaction or if you forget - then
nothing really happens so the answer
here is you know never I'll never get
saved in that code and no changes were
persister persistent because I never
triggered any sort of event that would
cause persist to flush to the database
so let's talk about flushing what will
cause hibernate to not be lazy and
actually do the work to put it in the
database and so this is the process
called flushing hibernate uses a right
behind strategy
like I said late as late as possible in
here really the three criteria or
hibernate is gonna flush when you commit
before a query is executed that might be
affected if you didn't have that data in
the database and then you can also
explicitly call flush so sort of the
lesson here is don't think of persist as
writing to the database think you've
persist the saying hey hibernate
whenever you get to a point where you
find it convenient to flush or when you
have to flush write it to the database
and so most often this is done through
transactions usually you don't
explicitly call flush and you don't
depend on
queries causing your changes to get
flushed and so let's jump into
transaction so in a transaction is
atomic unit of work in the database now
actually even though with hibernate I
didn't start a transaction when you're
actually talking to the database you're
always in a transaction and while
hibernate is doing is turning auto
commit off while you're doing that and
so once I disconnected the changes that
a you know if I actually do have done an
insert with it just roll back so let's
try using a transaction and then we can
actually jump back here so so begin a
transaction and committed and so now if
we run our example
a little slow to stirrups so this is
using an in-memory databases using h2
which is it has good compatibility with
different modes so it's set to Oracle
mode so this is nice for testing because
it actually has pretty good compliance
with like oracle syntax or there's other
databases in memory databases like derby
that if n don't work as well with or not
Derby what's the other one HS key yeah
that the compatibility mode isn't quite
as robust so now step over it I persist
it still did the same thing even though
I'm in a transaction it still just did
the laziest thing as possible which is
just grab an ID at this point I'm lying
because I actually haven't been saved
yet
oh and then I whoops I actually hit
continue and I went to the end of the
program so when I got to commit here was
when it actually inserted into the
database so anything you see in colored
here is p6 by and then I have there's a
plugin for eclipse called grep code
where you can set up expressions to
highlight based on certain patterns so
in the case of select I have a blue pad
or an insert green zone so great now now
it's working kind of how you'd expect
so now let's see even with this now that
we've got it at least flushing at this
point we're seeing it only flush at
commit time so let's see if we can get
it to or start to insert at commit time
but let's see some some other ways that
will cause hibernate to do it at times
maybe we wouldn't expect or maybe one we
would expect so so coming back to the
slides what if the person table is
queried during the transaction so for
example like this we do a query we're
gonna select from person in this case in
the in the example here I'm doing a
filter by the first name trying to pull
the record I just got out and so at this
point we're kind of calling hibernates
Bluff that if we switch back to the code
here so at this point you know if I
looked at my me object and even
inspected it and I saw there was an ID
you know hibernate sort of fooling me
into thinking it might be in the
database and it's pretty hard to tell
that this actually hasn't flushed to the
database
I'm at this point in the program and I
don't know what's happened previously
it's pretty hard to tell that me
actually isn't in the database so now
let's try and create a query query from
person and we'll just do something
simple like get the result list and so
now if we debug this again stepping
through it again persist just calls
sequence but now when I run the query to
get all the people from my person table
well now high everything says oh crap
they're hitting the person table I've
gotten persisted changes to that table I
better go flush so that the results I
get back are consistent and so in this
case now I am telling the truth that
when I say I've been saved I actually
have been saved now where could this
this run afoul so as you can see get
result list is one and it's gonna get
saved but we can get some unexpected
exceptions when querying via JPA so
let's assume that in my database and
I've already set it up this way that
I've got a non a not null constraint on
say the first name and last name field
then people should always have a person
last name so if I jump back to my
example here you know my name is Neil
sometimes I get called ni L which is
similar to a null so let's say that I
decided to put a null is my name and
again we run this example and so this
should blow up but the question is where
is it gonna blow up and we're gonna
persist oh it didn't blow up there now
we're gonna create the query and run it
and we got an exception now when you get
an exception or under running a query
you're probably gonna think there was
something wrong with my query but
instead you look down here you can see
my query through
constraint violation null not allowed
for column first name and developers
gonna look at this and say huh I'm not
using first name in my query maybe I
need to until they might start putting
you know first name clause in there it
really comes down to because of this
behavior of hibernate of flushing as
late as possible you get some odd
unexpected behavior that select what
what you think of as a select is
actually doing an insert than a select
and so you just need to be aware this is
what I try to you know teach developers
that are news that you need to be aware
that all these changes that are
happening can get flushed just about at
any time when hibernates when you're
dealing with hibernate and so because of
this you have to worry about not just
the immediate line of code but there
could have been several you know lines
of code back or even if you're in a
transaction that's spanning a lot of
different classes then boy good luck
finding out where it you know where the
offending line of code is so this is
sort of one of the things I think is the
bad magic of hibernate that when it goes
wrong when the rabbit explodes it's like
well why
where was the cause so any questions on
that before I move on yeah question
there where's validation framework
cookin okay I anticipated such a
question thank you so the validation
framework I'm gonna set it up now we're
gonna do Auto I believe is that okay so
let's run this and I'm just gonna run it
again not in debug but just let it loose
and it's gonna blow up again actually
you wanted to see where it blows up they
don't know oops
so let's run it again okay so we're
gonna run through it step through it
persist didn't blow up I'm persist so
you kind of would want it seems like
that would be the nice place to validate
right is you're telling me to persist
this but again hibernates being lazy and
saying well it's broken now but maybe by
the time I get around to persisting it
it'll be in a good state and now at this
point you'll notice nothing went over
the wire to the database whereas before
tried to do an insert data
Rebecca error in this case this is a
validation exception from hibernate so
the advantage here I mean still having
the same place but hopefully this is a
little more readable in saying it was
happening during persist and at this
point I know now it's not I prom with my
query it's something wrong with like
validation so probably good to enable
validation if only for that reason that
you get your you're better error
messages any other questions I indeed I
can so let's let's do that so I've broke
here I'm broken if a hibernate were to
flush now if I do need a set first name
and I change it back to Neal and now I'm
just gonna now I can just run it should
just work or not well now you've stumped
the presenter out here so actually let's
do it this way let's do yeah okay so
that's right so what's gonna happen
first it inserted with the original name
I gave it so which is also interesting
right that actually I'm gonna run this
in debug that when I run this daft an
agenda in debug
okay so now when I step over it
and I persist did it select just to get
my name changed my name didn't do
anything but now it says when I write to
the database well what you actually did
is you first inserted Neil and/or feel
and then you change the name so it's
keeping track of what you initially
persisted and then it's seen that you
changed from what the initial value was
when you called persist afterwards and
so if you're sort of trying to mirror
how that would look in the database then
you have to insert in an update and it's
sort of questionable is that the right
or wrong behavior I don't know it kind
of makes sense any other questions back
yeah it's gonna roll back so we can do
that so if I if I do that now the
problem is I'd have to take out this so
it would roll back so I wouldn't see the
the commit at the end in fact if I keep
playing through this then what happened
in order to go yeah so it wouldn't it
wouldn't commit at the end it would roll
back so it was still done the insert
statement and if there was any database
constraints or errors it would have
rolled that question over here sorry
say it again merge so you'd have to do
merge if you had an entity that somehow
got detached so let's say let's say I
grabbed a me out of the database or you
know I saved me and at this point once
it's committed I could I could detach me
from hibernate or from JPA and now what
could happen is that I've got this
version of me and then if I went and
loaded it again from the database since
this instance this me instance has been
detached JPA slash hibernate doesn't
know anything about it if you go to the
database again it'll pull the data again
into a new instance at that point I've
got two instances that are really the
same thing if I try to save
it will blow up saying you've already
gotten an instance with this identifier
in the persistence context so merge is
to say I've got these two things one
that's not persistent one that is and I
need you to merge them so that there's
just one of them I know that answer okay
okay any other questions all right the
gentlemen the front wants me to set my
name two times to see if I get multiple
and I'm almost positive it won't so you
know and what's your name Christian so
let's try me in Christian so just
updated Christian now the interesting
thing is I don't know if I call persist
in between well that's somehow give
hibernate a hint that nope still all
just the first last so yeah so it sort
of works but yeah that's kind of
interesting that you think well if it's
gonna if it's gonna call update because
I called set wants white in a call
update twice and I think that's just
it's not really defined how that's
should work I think in JPA yeah well
that's why saying earlier is that so if
you were to think of hibernate is
exactly mirroring what happened in the
database then if we were to insert here
then we didn't sort of fill and then
when I set my first name we've already
inserted it so we'd have to go do an
update so this is where I think
depending on the implementation provider
you might get different behavior so I'm
not positive on that I'd have to do a
little more research
so hi everybody haven't so gentlemen the
front said that when you call when you
persist something and then you change a
property on it it's an implementation
detail of the JPA provider whether they
do and insert an update or whether they
just see the final state of the object
and insert that instead of doing it to
an insert an update sorry I didn't quite
can't review the question right so
you're saying if after I think what
you're saying is if after I do the
commit here if I were to start another
transaction yes I mean I think I'm still
not understand the question so repeat it
again so tell which line of code are you
talking about where he persisted on the
query where line 21 or the persist
actually happens on the 19 yeah okay
well so that's that's work when you're
talking about merges there's a method on
on entitymanager called merge that's
where you have two different instances
of an object that's merged not that then
there's well it'll dirty check and we'll
get to that that it'll see you know if
it's some point it flush it to the
database
it'll keep track of what it last flushed
to the database when it sees you've
changed it it'll do another dirty check
and at that point so let me go back and
repeat the question so he's asking if
you've already flushed to the database
when you call set again won't hibernate
merge or propagate those changes again
and the answer is yes that
after it's been pushed to the database
if it's still in the entitymanager
persistence context and you change it it
will flush again so I think there was a
hand in the baggage you have another
question someone no okay all right who
are we
okay so this is where what will happen
I'll get a constraint violation
exception which is maybe surprising
so we've seen hibernate save when we
called commit we've seen hibernate save
when we called generated a query now
let's see what happens if we change the
sequence identity strategy so back here
there's a certain type of identity
strategy if we look at a person called
the sequence generator and that's what's
causing it to do the sequence ID that
way but with Oracle you could actually
insert or generate the sequence as part
of the insert statement so let's do some
magic here and this one is much more
complicated to configure it's the
generic generator which is hibernate
specific you have to know this is one of
those string lis typed properties where
you have to know that it's sequence -
identity as opposed to you know if
they'd had some sort of like a new more
something here I'm loaded in nice and
then you're passing the parameter that
this is the sequence and this is the
name of the sequence in the database and
now if we do this and we debug now we're
we created me we step over certian this
may indicate a bug oh yeah I forgot one
thing here I think
hold on so when you use this you have to
switch to you have to enable this this
feature called use generated keys
meaning you're going to let the database
generate the key as part of the insert
so I've got another example where I do
this let me just pull it up really quick
yes
so I'm going to insert that and
hopefully this works otherwise I'm gonna
call it move on all right let's try
Segen still failed okay um this other
project should work ever got it working
but the idea is to go
it's different projects roughly the same
code so undo that this one was for a
batch test this is the code that's sorry
this is the code I've uploaded github it
I'll use the link to that but if we do
it this way we're on this class you'll
see that when it does the insert that it
actually puts instead of fetching the
value then setting it it will inline it
with part of the insert statement so
when you do that if we come back to our
demo here actually maybe I need to clean
it but what would happen is that the
insert would happen right there because
remember that persist has to return the
identity if you're generating the
identity as part of the insert statement
well now hibernate can't be lazy it has
to run the insert statement so that
Oracle generates the ID so that it can
get the ID and so that's where persist
could happen here for using that
strategy
it could happen elsewhere later on if
you're using the sort of get the ID then
insert it later strategy one thing to
note about this strategy is that
hibernate will disable batching on this
and we get a tub later so I don't
recommend using with Oracle at least I
don't recommend using this strategy I
recommend the other one the original one
I had so let me undo that
so this is using the h2 database but in
Oracle compatibility mode and I did
verify that this you know I don't want
to have to run a local Oracle database
during a presentation so all right so
let's go back ok so listen here's the
hibernate bury persist changes just
about any time to the database you
really can't unless you're explicit
about telling it to flush you should be
defensive and expect that it could flush
at any time which means it may throw
exceptions at any time maybe when you
least expect it like when you're doing a
query another thing this is from the
hibernate Doc's so one thing that's
unfortunate when you throw an exception
when the database throws an exception is
this really confuses hibernate as you
can imagine if it's got say a hundred
things I asked to flush the database and
it's running through and the database
throws an exception hibernate can't
guarantee which ones have made it to the
database so which ones haven't so the
recommendation is you abort you rollback
everything and you start over because
otherwise you could end up with changes
that hibernate thought it had persisted
it really hadn't or things that it
thought it blown up because it
misinterpreted
maybe the database error and so this is
this is one that it's hard to deal with
because a lot of times you're like I've
made all this work it's hard to pop back
to the beginning and like if you don't
know exactly which thing caused
hibernate to fail and so we've tried in
two different situations that overstock
to like say you know like salvage the
session at that point to either clear it
or you know try it again and it sort of
questionable at best so moving on let's
talk about transaction boundaries in a
web app so overstock most of our apps
are either web services with with Jersey
or you know our website is a Java based
web app and so now you have to deal with
when do you create the entity manager
when you create the transactions and
there's a very popular pattern some
people call it an anti-pattern called
the JPA or in hibernate is called the
open session of you and JPA it's called
the JPA open entity management view
and the idea is that you have a filter
at the beginning you has a request you
open an entity manager and if you follow
the hibernate recommendation you also
open a transaction and then at the very
end of the request when the filter runs
you commit or rollback the transaction
depending on what happened and close the
entity manager so in essence that means
you have one entity manager and one
transaction spanning the entire web
request this is essentially the source
code lifted from the hibernate website
there's was in this was using session
and I adapted it to use entity manager
but there's some problems with this
having one transaction wrap your entire
web request so the first thing is a
transaction locks of database connection
unless you're doing some elaborate like
detaching the transaction from the
connection but if you're just doing like
the simple you know transaction with
this but the default settings you're
gonna lock a database connection and as
we saw earlier possibly delays you know
all these things that you've thought
hibernate was persisting they may not
actually get flushed to the database
until after your view has been rendered
and now you're in the filter and the
filter is doing you know its final
cleanup work and so what do you do if
like you get an exception there you know
you've you know potentially if you
caught it earlier in the lifecycle of
the web request process and you could
have shown them a different response
message based on you know the kind of
failure but at this point you have no
idea what's happened so we don't use
this strategy instead the differences
are we don't run it in we have one
entity manager spanning the entire web
request but we don't use a single
transaction over the entire web request
instead we try to be as small with our
transactions as possible so it means
within you know if you hit a page all
over stock that's gonna have to do some
updates to the database there's probably
going to be several transactions that
comprise that request and if you look at
spring Spring has an open entity manager
and view filter we're not quite on
spring ant on our web
site so we're not using this but if you
look at their source code it's basically
following the same pattern I'm just
describing where they don't open a
transaction for you they do synchronize
the entity manager with like the
transaction whatever that's called the
transaction provider so our version was
a little simpler all you do open the
entity manager go ahead well so that's
where I mean you're right if if you're
doing something that doesn't necessarily
have to be all or none across the entire
web request like let's say you're doing
20 things in a request and maybe these
10 things have to go together and these
other 10 things have to go together then
you have two transactions one for the
first ten and you know as long as those
complete then if the next 10 fail you if
you can still say the first 10 should
succeed then you're fine you don't throw
them back where it gets more complicated
as if you do something where you change
the database you call a web service
you're doing other changes and now you
realize you know in the case of when we
book an order this is very there's a lot
of steps to it we have to first make
sure that we have inventory we want to
go reserve the inventory we want to go
authorize your payment but what happens
if we can't authorize your payment well
we've already committed the changes to
the database to reserve the inventory
and the reason that we don't call and do
the payment authorization as part of
that same transaction is that calling
our payment provider could take you know
in bad cases sometimes they're late and
that can take 5-10 seconds so we don't
want to have a transaction open for 10
seconds because then we get all these
transactions locking all the connections
in our connection pool on the database
server you got a lot of transactions
going so we try to be as quick in our
transactions as possible and not call
any external resources so in this case
where we've already committed the
inventory we call an external resource
that says oh they can't actually pay for
this order then we have to do like a
compensating transaction where we
unreserve the inventory so if you can
avoid that that's that's the best
because you know keeping track of what
you did and when you have to undo I mean
that's some complexity and so you know
if it's in a small web app we're running
a transaction
across the entire request isn't a
problem it's not a high-volume web
application the requests don't take a
long time to to process then you should
probably go with the default which is
just open one transaction across the
whole thing with the caveat that you
might want to flush before you render
the viewer just to make sure that
nothing can't be inserted but in the
case of overstock we're having millions
of requests a day and especially during
like Black Friday we just can't have all
these transactions running you know
stacking up we have to be in and out so
now we have to deal with the more
complex case of doing and undoing
transactions it's an extra question okay
so the pro tip is get in and out of
transactions mmm as quickly as possible
I guess I should say with the caveat
when it's a performance sensitive
application all right so here's a this
is one of the earliest hibernate gotchas
or JPA gotchas that we ran into so new
developer comes in and you know we have
a price on our website and then we have
discounts for your on where maybe it's
ten percent off everything in furniture
or 10 percent site-wide so you might
think well I'm gonna pull the price from
the database via hibernate but then it
might get price me that I'll apply the
discount you know I'll just
I won't you Tate the price so in this
case big decimal does subtract doesn't
mutate the the price it creates a new
big decimal with the new value so here's
what happened on our website now this
didn't make it to production because we
did have a QA team that was very sleuthy
so you know you look at the page pretty
good price $40 for the JPA or java
persistence book and then as you refresh
the page the price would go down by 5%
until eventually everything's free
all right so I think you're probably all
smart enough or most of you understand
why this would happen but this is
another one you know just a good
refresher why did this happen
well it's subtle we can actually have a
demo of this as well to go to debug all
right so let's just simulate this that I
create a product or sorry credit
transaction mm-hmm I create a new
product give it a name and a price
I persisted I committed and so if we run
this we see a date got the ID it
inserted hydrogen in action 40 and
inserted the idea that I got okay so now
let's have some fun with it let's say we
create a loop herbs and actually
okay so I'm gonna create another nad
manager and now I'm going to grab that
product and I know that I'm gonna cheat
here I know the IDS alone because every
time I run this it resets the database
so and let's output the price all right
I need to actually capture what I got so
we'll print the price do we gonna trash
this whole commit okay so this is gonna
run I had to run ten times in this loop
oops
take that brick point out
all right so if I step over this we can
serve our product and now I'm in the
loop where I'm gonna go grab it so does
it select get the price I haven't done a
discount or anything so still 40 and if
we keep going it's just gonna keep
showing 40 over and over commit ran but
it didn't really commit anything because
I hasn't done any inserts now of course
if we set the discount will say this I'm
just gonna fix it's a $5 discount and
now I'm just still running there now if
I run in I'm not gonna debug it if I run
it you could see by the end my price was
zero because you can see what's
happening is that grabbed it from the
database I printed the discount was 35
hibernates said oh the price is now 35
even though I didn't modify the the
value of the clasp it saw that my getter
was returning 35 and so it updated the
price to 35 so a couple interesting
things happens here one is it keeps
regurgitating the same name
you know this name property of my
product even though I didn't change it
it's still updating the name column and
the price column even though it really
has to do the price column so in some
cases this has caused problems for us so
we have a product table has 172 columns
in it because this table is like 10
years old and people just keep adding to
it and we're trying to fix it but you
know you know how databases are now look
we don't map all the columns in that
product table but you can imagine there
could be some 3040 out columns that are
actually still being used to get mapped
so the DBA is get real bent out of shape
when we're changing one property on the
product and then hibernate goes in
inserts and updates you know updates all
40 columns even though only one of them
has a new value the database has to fire
all the triggers that are attached to
any of those columns only to find out
that you know like typically in a
trigger you say well if the old value
doesn't equal the new value then don't
do anything but it still has to fire all
these triggers it has to has to lock
the RO while these triggers are firing
so they really don't like it so it's not
something that necessarily say you
always have to do this but one thing
that can help with that is well
hibernate you can say I want to dude
dynamic update and so if we run this
example again then at least now I can
see that it's only updating the price
now so at least that's nice I can see
there's only one thing that's changing
in this one I look at the logs so again
I guess I switched off that too fast
there's this annotation dynamic update
there's a similar one that for insert
but insert kind of seems like nearly
probably should be inserting all the
values the first time even if they're
null
anyway so that was really wasn't the
problem so the problem is our price is
mutating and so that's because I subtly
put the ID annotation on the getter
of the gate ID instead of the property
so when you put it on the together then
hibernate this is what's called property
access which means it's gonna treat the
value when it does dirty check it's
gonna look at the value that the getters
return so in this case my get price is
returning a value that's different than
what was in the database so if I wanted
to do this I'm not recommending this is
how you implement a product discount but
if you had to do this I can now fix it
by just doing field level access and now
it it always returns 35 because it's
pulling 40 from the database applying
the five dollar discount give me $35 the
other thing I could do and this is also
something I highly recommend is if you
know that this class should never this
is really you're just trying to read the
data this is an application that
shouldn't be updating the data you can
put at immutable on there and hibernate
will you know even if you modify the
object it won't flush it won't persist
changes question in the front
mixing API animation it is because I
meet well it wouldn't if I was using a
Clips link because the clips think
doesn't know about this annotation but
Eclipse link has their own similar
annotations so at this point I'm not
I can't just swap out a Clips link for
hibernate or vice versa
an eclipse link I believe at a mutable
is called at read-only and it's in the
like orga Clips link namespace or
package I'm not sure dynamic update I
believe I believe on this one they
actually do use some of the hibernate
annotations rather than invent their own
they since they know everybody's using
hibernate they own or some of them but
yeah that's a good point that not all
the JPA annotations can provide this
functionality so in that case you end up
having to use provider specific
annotations alright any other questions
cool alright so we've got next okay so
we went through that so dirty-checking
hibernates going to synchronize changes
to the database even if you don't call
persist so in that case I was calling
get in my transaction I was only doing a
get I never called persist and some
people think I've seen in code where
people pull something from the database
change it and call persist thinking I
have to do that in order for hibernate
to update the database but it's
completely unnecessary it's gonna
persist anyway since it's a managed
entity like I said think about using add
immutable or at read-only for eclipse
link use filled level access and if
having all of your columns be updated
one only some of them have changed as an
issue consider using dynamic update and
that's duplicate so so the thing about
dirty checking is there is a performance
issue potentially so let's say because
you don't like this behavior of the
inserts not having happening until
commit then what some people might do is
start calling flush really aggressively
and just saying okay after I called
persistent flush persist flush but what
flush is going to do is go through every
entity that's been persisted that's in
the persistence context and dirty
Checketts so in this case how many times
will an object be dirty checked and the
answer is 5050 because the first time it
runs is going to dirty check the first
one the second time that runs it's gonna
cherry check the first line the second
one when you call flush the third time
it's going to dirty check the first the
second one third and so you've got
basically an N squared performance there
which I just described yeah so Big O of
N squared so the tip there is try not to
go let your your entitymanager or your
persistence context recession get too
big the other way this can buy you is
that you know that when you're doing a
query hibernate has to dirty check to
see if well because of this query I
might need to flush stuff to the
database so I've seen apps that when
they start up they're loading a bunch of
data and then they might do some changes
and then the queries become slower and
slower not on the database but in
hibernate because as you get more and
more objects in your session every
select you're running run slower because
before does the Select hibernate is
doing this dirty check on the entire
persistence context so where possible
keep your your session and persistence
context lean any questions there cool
the next one is batch processing you
know so most the time most of our apps
aren't batch processing they're web apps
like I said but occasionally you have to
have this app that runs it's gonna pump
a bunch of data into the database and
since you're familiar with hibernate you
know your first tool of choice is
probably gonna be hibernate so the naive
approach might be to start with you know
let's say you're just gonna insert a
bunch of new persons in the database you
create your transaction you call persist
a bunch of times now we know that
there's going to be some performance
issues because of all of these persons
sticking around in in the entity manager
and I don't really care once it
persisted I'm not referring to it later
I mean as well get rid of it
but I don't want to flush too often I
don't want to flush every time so I
might do like a batch size where maybe
every hundred records I'm going to flush
and then once I flushed I can clear
clear those out because I don't need
them anymore so this is going to give
you some performance boosts if you're
using hibernate with JPA you can drop
back to you can unwrap the entitymanager
and get the session factory at which
point you can get what's called a
stateless session which is a hibernate
specific implementation of session which
as the name implies maintains no state
once you call persist it's no it's not
maintaining it in the context so when
you call session insert it will
immediately fire insert it into the
database and no longer hold on to it and
if you're using batching so JDBC has a
batch API where hibernate will figure
out that even though you're calling
insert all these times it'll keep the
same preparedstatement and start adding
multiple inserts onto that
preparedstatement and then execute the
batch for performance better performance
so if we look at this with JDBC you can
even do this with JPA you can get down
to the raw prepared statement and
connection first you do the same thing
you get the session then they have this
do work method which you create a an
honest inter class that takes a
connection and that point you're getting
a connection via hibernate or via JPA
and now you can use preparedstatement
you can do this insert and here I'm just
doing kind of the equivalent of the
simple JP example where I create the
statement I add a value to it I execute
it
if I use the batch API this it looks a
little different once you are done
modifying the end once you've updated
your insert statement you add it to the
batch and then at some point you need to
execute the batch and so if you've done
102 AB batch calls and then you call
execute batch then those 100 inserts
will will execute as far as one one
batch statement to the database
okay so I ran a little benchmarking this
is the thing on github that'll show you
the link where I benchmarked all of
these against each other using an Oracle
database this is on basically an
enterprise Oracle database on production
grade hardware and these are the results
so just using JPA the first one where I
didn't do any flush clear took about 98
seconds for a hundred thousand persons
to be inserted if I do it with an
explicit clear flash I get a little bit
of a performance boost I get 86 seconds
which is back basically the same as this
stateless session approach with JDBC I'm
getting 66 seconds and if I'm using the
batch API it's clear down to nine
seconds now the reason for this is sort
of subtle and in this case I sort of not
cheated but I I gave hibernate a bad
hand on this one so if we remember back
that when we're doing the inserts it
doesn't select and then it does an
insert so even though it's doing all the
inserts in batch it's still going to do
100 selects to get the IDS and then one
insert to insert those 100 records
whereas in my JDBC example I did the way
where I can do the sequence as part of
the insert statement so in that case I'm
doing no selects in the JDBC world
I'm only doing inserts and in batches
and so I can Trump or beat hibernate on
that one so the whole point of this is
there are some cases where if you're you
know hibernates sweet spot is I think
kind of the web app where there's a lot
of rich interactions with a database
going on if you're just trying to throw
a bunch of data in the database
hibernate may not be the best choice
this is the site sauce on github slash
and hardener if you go to their I have a
repository jp8 gotchas and that has all
those code examples as well as the
slides are in that project the one you
got off github will run out it should
run out of the box if I've done it right
because it uses a h2 database the the
results aren't gonna be valid because
you really want to hit like Oracle or my
sequel or something it still performs a
little bit better on h2 but the
differences between the different strata
these are much less significant so I
want thread safety but I think I'm gonna
close early so if we have any well let's
just say this so I've got one more thing
it's really not that interesting is sort
of if I had time I'd go over it but
before I close let's open up for any
questions about anything we've gone over
any lingering questions that I can
answer I've got one friend yeah so
that's kind of like what well so sorry
the question was I said if you're doing
a batch application with lots of inserts
consider something else what's that
something else so in the case of
overstock we've got our own homegrown
sort of like layer on top of JDBC that
does things like resource management
resource cleanup of connections spring
Spring has like spring JDBC templates
that probably be a good choice there are
lots of frameworks that aren't ORM s
that are just sort of we map objects to
you know two columns in the database I
don't have a lot of familiarity with
those I can't really recommend one but
for pure performance so if you've got an
application that takes five hours to run
and the the Ops guys are saying really
five hours you know in this case let's
say that this was the exact performance
problem you get down from five hours to
say you know thirty minutes or something
in the back
okay so gentleman the back says eclipse
link solves this issue because you can
have a prefetch of batch of ID's though
you do with Oracle
let's try well so are you talking about
with hibernate where hibernate can do
like this high-low generator where it'll
say I've fetched like ID one and I know
that the next one is going to be so let
me repeat and make sure that you agree
with that so he's saying that it works
in that if only one application is doing
this they won't get colliding IDs but it
sounds like the Eclipse link method is
would actually run the it would go run
the select a hundred times or how does
it how does it effects like a hundred
you might have a gap in your sequences
right so you could you could you could
fetch a range of sequences and you're
saying you can do the hibernate okay
so I stand corrected there may be a way
to get around this I'd be curious
somebody come talk to me after and we'll
try it and see how that performs against
the JDBC example so that's all the time
we have it looks like we've got one
minute left thanks for coming
I've been great eyes</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>