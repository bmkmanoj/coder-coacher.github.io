<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Functional Groovy | Coder Coacher - Coaching Coders</title><meta content="Functional Groovy - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Functional Groovy</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-W36UtrDgks" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay this morning we're going to talk
about functional groovy groovy czar
never meant to it wasn't invented as a
purely functional language if you want
to go and learn a language that's purely
functional groovy wouldn't be your first
choice but if you want to do everything
you can do in a functional language
groovy will let you do those sorts of
things sometimes with a little bit of
work sometimes very very easily and with
no effort so we're going to have a look
at we'll start off very slowly I presume
most people in the room know a little
bit of groove who's seen groovy before
nearly everyone that's great so I've got
a few one or two slides at the very
start which just introduces some some
closures and we'll go through that it'll
be a little bit slow for those of you
who are familiar with it but then we'll
pick up pace once we get past that I'd
hopefully not lose everyone in the
audience who may not have seen some of
this stuff before so we'll start off
with just a little bit on style and
basics and so I do want to make sure
that you're familiar with the features
in groovy for doing functional notation
but also the concepts behind functional
so there's lots of good languages out on
in on the JVM and outside the JVM many
of them support functional ideas there's
a lot of function ideas that you should
bring on board not necessarily
everything has to be functional oh I'm
not I'm someone who likes to when I'm
finding a solution for a customer use
whatever's best for the problem at hand
many times that might be functional
other times it might be imperative logic
programming other other other things so
I'm not going to tell you that if you
don't do everything functionally you're
a bad person
so we'll but we'll look at that as we go
through and we'll see pros and cons of
the different styles we're going to be
looking at so what is functional
programming it's same sort of program
you've done before but favoring slightly
different things than you might have
seen so we want to write composable
expressions so trying to have a slightly
more declarative way of writing the our
code in favor of slightly more
imperative which is telling the computer
how we're trying to write it slightly
more declarative code that's expressing
the intent of what we're trying to do
and there's particular kinds of idioms
that are very very important in
programming that we're that are
encouraged so things trying to write
side-effect free functions trying to
write immutable code when it makes sense
when the algorithms you're writing lend
itself that way which is often the case
it's very very useful to make your data
structure as immutable and we'll have a
look at that in fact probably the the
main focus I want to do for many people
who know functional programming they'll
be familiar with a persistent data
structures and things like that nothing
to do with databases but many people
who've come from a Java background won't
be familiar with that so I will probably
spend a little bit more time on that
than on some of the other topics as well
and why are we trying to do this we're
trying to write declarative code we
we've been doing this in whatever
language you've been using that's always
been a goal try to move the level of
abstractions up to the kind of things
that rather than low-level assembly
language telling you no shift this
register one space to the left or
whatever we're trying to set right
things in the way a human might express
a problem we're potentially going to
reduce a whole lot of errors so when we
have a look at some of the immutable
style some of it might appear very
subtle but if you go it's like when
you're encouraged to use a finally in
front of you some of your variables what
soon as you use final in front of a
variable you'll know that reference or
that primitive type won't change for the
next segment of code so if you're trying
to read code and understand it it gives
you a clue straight away oh that's not
going to change anywhere else you don't
need to be 50 lines down saying ah
what's happening here oh that might have
changed what's going on so there's lots
of areas in your code that will become
clearer and they can actually lead to
lots of optimizations as well different
patterns so we're all used to different
design patterns that we might have used
when we're doing imperative code
different kinds of refactorings that we
might do once you move over to using a
more functional style some of those
patterns disappear some of them get have
to be refined so we'll look a little bit
of that and there's the ability to get
different kinds of reusability sometimes
automatic concurrency by some of the
that we're going to look at and when
we're looking at functional there's
going to be a whole lot of issues we're
not going to sort of read through this
slide picking them all out but some of
the concepts that are here are going to
be important to us lazy evaluation
versus eager evaluation the immutable
data structures higher-order functions
we'll be having a look at these as we go
through okay so how's that can you
people at the back read that getting a
few nods hopefully that's okay so this
is just a couple of slides on just some
basic stuff which is closures so this is
like lambda lambda expressions in driver
eight that we've been hearing about at
the conference Groovy's had those if you
want to if you want to go and use that
lambda type expressions in double four
or five or six seven you can go and use
groovy users closures and you'll you'll
get all of the features in lambdas plus
a bit more but let's have a quick look
and I don't spend too long here is a
closure it's just a chunk of code so I'm
happening to it having to assign it to a
variable twice and in this particular
case up the top here it takes a single
parameter none and it's just gonna add
num to itself so it's got basically
return twice what whatever I pass into
it and to call it I can just call twice
as if it was a method passing a
parameter five and that'll come back ten
I'm very simple it happens to be a
closure object underneath the covers
that has a call method that's some same
tactic sugar you don't never need to use
the call necessarily normally but just
to show you that it's there and you
could do it if you needed to okay
here is a another one this one doesn't
take any arguments so I can leave I
could have put the minors greater than
sign if I wanted to here to indicate my
intent that it's got no arguments but in
this particular case it's fairly clear
so just two times ten and that's gonna
be twice ten I can just run that just by
putting empty brackets there it's got
hasn't gotten the arguments and that'll
return twenty he's a triple write the
same as what we had before but I've
decided not to bother with the type I
could I could put a def in there or no
type and that'll be basically object
type okay and I can go triple five is 15
this is also triple if I don't give if I
don't bother putting the argument in
there giving it a name or don't know
type no name it'll default to object
type as we as we saw here but it's got a
default name called ITU the the iterator
for the closure or the the thing that's
going to be worked on okay so this is
also triple and I can call that on six
and I'll get 18 in when I'm declaring my
closures I can refer to other closures
okay we'll see that we can refer to
methods and other things later as well
so I so here inside quadruple I can
refer to twice but there's another
little thing that's happened here is
I've got a default value for my
arguments so in groovy you can have
default values for your method
parameters you can also have that for
your closure parameters so if I happen
to call quadruple with five Arg will
become 5 and so twice five will be ten
times two will be 20 if I don't call it
with any parameters I'm not sure why
you'd want a quadruple that defaulted to
- but it'll default the two and
quadruple of no arguments will default
to eight okay now
closures are first class citizens what's
that mean they can appear inside data
structures or as return types for
methods or other closures they can
repeat as argument types for methods or
other closures so in any way you can
have any put a variable you can put a
closure so here I'm going to create a
map this is a method that has a closure
as a parameter and also I'm going to do
call with five if you pass in to me a
closure I'm going to call that closure
passing in five okay and so if I now
call with five and passing triple from
the previous slide triple is a closure
it'll call triple with five as the
parameter and that will be 15 does that
make sense
so it's no no sort of rocket science
nothing tricky here okay this is just a
normal method now so methods in some
ways look like closures but they're kind
of locked inside our class or inside a
script so this method here is a sort of
lock inside
the script here I can't put it inside a
list or a data structure on its own
there's a trick we can do what's we're
going to see just very shortly but
otherwise it looks very similar so it
had a parameter and had some some code
so if we have a method like that it
doesn't look much different but it
couldn't be put inside a data structure
or passed as a parameter or whatever on
its own but there's a little trick we
can use so this is also twice if if we
have an object that has a method you can
do you can do it with statics as well if
it was a static method in a class but
here I can just go this dot end twice
method which this will point to the
script that I'm in and it's got a twice
method it'll convert that method into a
closure okay underneath the covers so
now I can call also twice with five and
it'll come back to me yep
straightforward
okay another thing that we like to do is
build closures in terms of other
closures so functions in terms of other
functions and here we've got also
quadruple we're going to take the twice
closure from the previous slide and
compose it with itself so one takes a
parameter returns an argument so if we
compose we feed what came out of the
first one into the second one so we're
going to feed it through twice twice
which will be quadruple does it make
sense yep so it's the same as if I call
I haven't shown it on this slide but if
I called twice open brackets twice open
brackets input five that would be
equivalent to what's going to get called
underneath the covers with we're not
compose these okay there's another
technique it's called called curring or
in fact it's more strictly partial
evaluation would be the the the example
I'm showing here for what's happening
and what that allows me to do is I've
got a closure I can parsley fill in some
of the parameters okay so if you
remember our quadruple method took a
parameter I'm going to curry that
parameter and feed in ten what that
means is it produces a new closure a new
function call for T that already has the
parameter filled in so it's like um
I'm calling quadruple we've already
already 10 there that's what this new
coach is gonna be so I'm going to end up
with a the 40 closures gonna take no
arguments because they've all been
filled in and I can call it with no
arguments in order to return 40 because
that's quadruple ov-10 does that make
sense yes yep so so um yes multiple
arguments are possible there's there's a
long story we could talk about the
difference between this and other what
other some other languages do with
single parameters and stuff but if I had
multiple parameters I can use courier I
think I've got some slides later on that
you should know this but I'm not sure
but so I'll explain it right now and
hopefully there'll be something else
that comes up if I curry with the normal
curry command it fills in from the left
there's an hour curry that fills in from
the right and there's an end curry where
I can say fill-in parameter number four
fill in Premanand more to fill in
parameter three and so I can go down and
fill these in where is it useful if
you've got a whole whole bunch of
closures and you want to fill in the
exact same parameter all the way through
right and and then repeatedly call it
why not go and curry it all the way
through first that clears it there's no
dupe you trying to remove dupe in your
code that'll clear the dupe in there
yeah and call the the rest of the things
that you want you might have a method
that does its more general purpose than
what you need and so you can go and fill
in you might have defaults that you've
got you're forced to fill in that's
false for this you know false for that
false for that rather than then filling
all that in and putting noise in your
code all these things that you're not
using you can fill in used curry fill
all those in and you have a nice clean
command you can call with just the
parameters that you're interested in
No No so not until I call 40 at this
point will it actually evaluate okay now
I said before that closures are
first-class seasons you can put them in
data structures so here I've got a list
of closures so a list of code I've got
twice triple and quadruple or the next
example I'm going to have also twice
also triple also quadruple the first one
I've got my bits of code and I call
collect well that does is is going to
take my original list do a
transformation into a novel list and
what's it how's it going to transform it
well it's what it's going to do is
collect all the things that are produced
by taking my code and doing this on it
or taking whatever's here and doing this
on it so what I'm doing here is calling
my closure and passing in five so I'm
gonna call in twice passing in five
we're going to call triple passing in
five called quadruple pass in five and
so it comes back a new list so collect
takes one list turns into analysis
transformation if you've heard of map
transform reduce this this is a sort of
a transforms or map mapping step map
filter reduce our publisher we said yes
click collects a method call and it
you'll find it on nearly all the
aggregate types in groovy so it in
groovy there's a thing called default
groovy methods or extension methods what
it allows you to do is add methods on to
existing types in the Java framework
those of you haven't seen this part
before so if I've got a list I can go
add a collect method then every list
that even a Java list will now have a
new method so I can call I can create a
new ArrayList linked list from Java call
the collect method on it and if I had a
list of strings I could collect and I
could return the strings dot size or
length or whatever and it'll basically
transfer my strings into a list of the
size of my strings okay and that works
on normal Java classes pushing up the
back
yes so the question was why doesn't
groove you automatically treat those
methods like they are closures or
functions that's really just part of the
Oh Oh the conventions in typical error
code there is no way to get to those if
you look at any of it if you look at
Java exactly so so yeah if you've seen
in the Java rate examples you will see
in my example you would have seen the
name of this script where so script
colon colon
twice method is another way to get to
this exactly so Oh groovy did do it but
it just didn't use the same syntax that
Java right is now using it yeah so so
yeah so you can get to them as you
should be able to but it's not as
convenient of the syntax by putting that
even in Java that drive rate lambda is
putting having to put the class colon
colon or whatever is just automatically
do that um well you could do it's just a
converter if you happen to have a
variable with the same name as a method
and so on you'll you've just got a few
things to deal with but it could be done
yeah it just wasn't time and so in the
final example here I'm going to take the
other ones do the same calling method as
I did before but instead of collecting
them into a list I'm going to sum them
all up so it just comes out to 45 so it
makes sense
yep so collect as a method call and
there's a convention I didn't really go
into it I've probably shown examples
already no I haven't shown examples
already um so here when I called call
with five and I passed in cripple
alternatively instead of putting triple
here as the name I could have started
with the curly brace and gone all the
way through the curly brace copied that
cut and paste that and put it in there
right that makes sense it turns out that
if the only thing if the last parameter
or the only parameter you've got in a
method call in groovy is a closure you
can remove the round braces as well in
that case yep they're not adding
anything so here I could if I wanted to
put the round brackets around here but
because it's the last parameter and in
fact it's the only parameter I can
remove those round braces as well and
that turns out to be really really nice
when you're writing your own sort of
control structure so if you think of an
if-then-else you wouldn't expect it to
have the round brackets in there this
allows us to avoid those sorts of things
in many scenarios so it's a very nice
technique okay now here's some more
examples of yet calling for a list as
well as the collect and the sum I've
shown you there's other methods as well
as like dot each which takes a closure
as a parameter so for each of the
numbers 0 1 2 I can print them out do
things like that ok you'll be able to do
very similar things to many of this C
with Java rates lambdas so
so one some of this will carry over the
names will be slightly different before
each and other things and a few other
little things you might need to do if
using streams but on the whole many of
the things that groovy introduced
sometime back and out will now some of
that will be available for you groovy
goes beyond what java rate does okay now
I'm just going to whiz through a couple
of other slides it the the fundamental
nature of having closures in Groovy's is
just widespread right
there's been 10 years where the fact
that we've had them has permeated
through all of the libraries that are in
groovy so even though drive rates now
getting and that's fantastic it's only
had a few months to permeate through the
libraries and yes they're doing some
really wonderful things and yes they're
borrowing off ideas out of groovy and
Schuyler and closure and so on but it
will take some time before the level of
integration of closures gets through all
of the the Java libraries so if you want
to jump ahead of the crowd and do things
you can you can play around with groovy
if you want and it's all the way through
so many of the design patterns if you've
heard of the Gang of Four design
patterns and beyond lots of things that
we were taught good patterns for
structuring your code turn out to be
anti patterns they're not needed at all
once you have closures okay so this
happens to be a strategy pattern which
is a way of creating a class hierarchy
that has algorithms inside it we can
just put our algorithms in closures and
have lists of them do whatever we want I
don't wanna go into the details of those
patterns builder patterns so if you're
trying to create yourself some HTML it
might look a little bit strange what's
going on here I'm creating a markup
builder and I go dot HTML and do
something dot and then a head and then a
body and then a u1 so on this actually
spits out this HTML everything between
the angle brackets here these are
closures chunks of code right so I can
have arbitrary mix and match something
that looks like a declarative expression
of a data structure intermingled with
any arbitrary code anywhere through and
that's it's what closures make possible
again I don't know explain the Builder
in detail come and see me afterwards if
you're interested in that sort of stuff
many of the da cells that we write again
this one here I don't go into the
specifics of how I've got another talk
later on today which goes into some of
the specifics of this DSL but the fact
that I can ride a little DSL that's a
mixture of Maps and closures allows me
to write expressions like this this is
actual groovy code okay if you're
wondering wondering that how it gets
passed it's the the the please method
taking a show parameter which show just
happens to be another closure up here
and so on which would
this when I call yeah please is this
method here passing in show it returns
an object which has a V it happens to be
a map that has a the method that has a
square root parameter which happens to
even be another bit of code and when I
call the square root it passes another
map object back with an augmented that
and I take 100 is my parameter so I can
write little things like this in the
fact that I've got closures everywhere
here is the thing that supports this
kind of functionality so it permeates
all the way through all the different
features of groovy and if you want to do
the same thing in Japanese you can you
can do that as well and you get nice
little Japanese expressions for squaring
the root of 100 ok so um that was just
some background on people who might not
have seen those parts of groovy before
trying to get us all up to the same
speed now I want to start talking about
you know some more advanced concepts so
the first thing I want to talk about is
our side effects and we'll come back to
more detail about side effects later
it'll turn out if we go and write code
that doesn't use side effects we can
automatically optimize stuff
automatically remove stuff automatically
we refactor stuff automatically paralyze
stuff ok so there's lots of reasons why
we might want to do it if we try to make
everything pure functions there might be
times when we get code that's not as
efficient as we'd like or maybe it's
really really hard to do that mutually
recursive Fibonacci factorial prime
number generator or recursively in your
head I'm not going to stop you from
going and writing an imperative solution
but what I'd encourage you to do is
limit where you're using mutable
structures and so on in such a way that
eventually you get a boundary that you
can say nothing of my mutable you know
imperative style is leaking out of this
boundary at that boundary level I can it
might not be at my finest level of
granularity but it that boundary I can
now do all the things I talked about
Auto concurrency refactoring at that
boundary level not if not in between and
so on so there'll be lots of reasons why
this is a good thing to do in future
versions of many languages will
improving on this in the because we've
had a a very a sort of a barren period
in terms of functional not totally
barren there's been lots of research
going on but compared to the amount of
money that's poured into a parrot of
programming over the last couple of
decades really the the knowledge about
how to do really good functional
programming how to really optimize
things how to how to really do some
really smart things is only just
filtering through into our sort of
collective knowledge on what best
practices are so you're going to see a
lot more happening in this space
now the services gets back to this
example and it's explaining what what
it's doing I'm defining an increment
method here which just takes an argument
and returns the argument plus one it
makes sense okay now if I haven't gone
and done any weird metaprogramming magic
or any global transforms behind the
scenes this is a pure function so if I
call increment of ten it returns 11 okay
what can I do juice if I happen to have
other variables in my program like X if
X was four before I ran this pure method
it sure sure is going to be four after I
run this method right so that's what we
mean by pure if I go and run this method
it can't affect anywhere else so if I'm
trying to reason about my program and
inside a pure function nothing else can
be changed you can't go and tweak
anything else it can't can't go and do
any nasties now closures in groovy
erector if you've heard of the term
lambda functions and closures lambda
functions are functions that are only do
things with their arguments they can
still do imperative stuff inside
potentially nasty side-effects if you
wanted but they can't do it they can
only do it with things that they're
given in his arguments that are closures
the full-blown version of things
actually can reach out into the
environment that they're running in okay
so increment with side-effect I'm going
to declare here it's going to be the
same as this increment but as well as
returning so the last what gets returned
in a closure or a method
in groovy is the last result if you
don't do an explicit return so the last
results going to be argh plus one the
same as what we saw before here so for
many people who run this thing they'll
think it just looks like increment but
I've snuck in a little nasty side effect
in here so I'm going to reach out into
my environment to this variable X and
increment it so I can now call increment
with side effect on ten and it comes
back eleven and yes fine cool it on a
hundred comes back hundred and one yep
all fine but now X is six because I did
a side effect and I reached out so side
effects are things like poking at things
that are out so in your environment
there are other variables if the
immutable immutable law or otherwise the
things that you're not supposed to get
access to writing to files writing to a
database sending things over a socket so
side effects are all those things now
many of those side effects are kind of
useful so might be nice to write the
results out so the user can see them or
store a result away in a database
actually perform a transaction they're
all side effects and there are things
that can cause havoc in a purely
functional world now what what you what
I'd recommend that you do because if
you've got a language group groovy
obviously that's you and do things with
side effects because that's we release
or stuff is what you want to do is tease
apart your API s and push the stuff
that's doing the side-effects sort of
your outer layer and all this to all
your core API is you make pure then you
can reap the benefits of doing auto
concurrency and all sorts of refactoring
and things in your core api's and still
do the valuable business things in your
outer layers so we'll have a look at
some of the impacts of that okay so I'm
just defining some some variables here
defining a method don't need to worry
too much about those but now I'm going
to just assign the variable Y to three
argh is now the same as Y okay X is
going to become Y plus one I'm going to
call that method and then I'm going to
say Zed is y plus one and I want to
assert that x equals EDD
now if I go and look at that it might
seem we're over here I did X equals y
plus one here did Z equals y plus one I
can probably make this assertion right
well you can if method doesn't have a
side effect
so if method went and incremented Y for
instance then by the time I got down
here Y is already incremented once and
these won't be equal okay so if I knew
somehow that method was a pure function
and in groovy you could try to analyze
this you could go and have a look at
what it does inside okay it's not using
any system.out.print lines it's not it's
only doing the dealing with its
arguments it's not touching other
variables you could make the the
compiler smart and it could auto
optimize this it could say aha I've seen
that expression Y plus one just before
and I assigned it to X so when it gets
to here it can say R I'm not going to
bother going going y plus one again I
know that happens to be sitting in X and
it can replace that statement with this
statement Z equals X and then of course
this assertion will be true but if I
can't tell that method is pure then I
can't make that optimization so so
there's a whole range optimizations we
could do if we knew we had pure methods
future versions of groovy you might have
an annotation that as a programmer I
could say ampersand at pure as an
annotation and that's me ouchy for the
purity of that method and then I might
get optimizations like this
groovy doesn't optimize other languages
like Haskell and so on will optimize
code like this they won't get you won't
build a write a method an unknown pure
method without special tricks and the
compiler knows when you're using those
special tricks and won't think it would
allowed this to be optimized here's
another example the same sort of thing
we're going to create a if you remember
that remember there rules for creating
calculating the hypotenuse of a right
angled triangle yeah so the base and the
height so basic weird times height
squared factor square root and that'll
give me the the size of the other side
of my triangle yeah so I've got this
math dot square root I've got x and y as
the base and the height so X square
y-squared take the square root so if I
feed in 3 &amp;amp; 4 it'll come back 5 right so
if I happen to know that Pythagorean is
a pure method and in fact if we look
inside here it's only using its
parameters x and y and it's calling math
dot square root which I'm assuming let's
assume that that's a that's a pure
function out of the libraries it's not
going and changing my other variables on
me so that's a pure function so what in
fact what the compiler can do here is
several things so so first of all it
might decide I can take your function
and automatically memorize it now I'm
going to tell you about memorizing later
which basically means it'll cache
results that it's seen before so it
could do that it could automatically say
oh yeah I've detected that this is pure
what I'm going to do is remember that
the results okay one of the other things
that you can't do inside a pure function
is like have a random number generator
or something like that so so we could
actually go and auto memorize that so
that's optimization the compiler could
do if I do not know this is a pure
function I cannot make that optimization
but in fact we can go further and this
is what Haskell would do in this case I
can say are actually a and B here are
constants so in fact I'll go and
calculate math dot square root at
compile time and I'll just plug in five
so in fact this turns into C equals five
that's what happens inside your Haskell
code now we can't do that yet in groovy
because we can't make those assumptions
in the future if I could annotate this
with pure or something or you know limit
I know I in a certain circumstances of
limited myself to a certain context and
it is pure then we could do these kinds
of optimizations as well so there's lots
of optimizations that you can do now
these are all all look like they're
fairly low-level but imagine this was a
very complex calculation there might be
huge savings to be had here so auto
memorizing and then just Auto replacing
that DS is potentially a very powerful
thing okay so what I want to do now is
um flick through to show you some
examples
actually I'm not sure I'm gonna get to
show you all the examples so I will show
you this one I'm gonna make I'll make a
bit bigger for you so don't fret if you
can't see it just let me I'll just pick
out the ones I want to show you and just
bear with me okay so we're going to in
the interest of time you're going to
trust me that I've created a method that
calculates whether something's Prime it
happens to be using factorial maybe I'll
have to convert Duke did a nice one that
only used a prime detector that only
used plus and and the quality I might
have to go and change my example to
benefit Vanina but we weren't do that so
I've created a a function that tells
whether or not a numbers Prime happens
to be using a trick using factorial it's
a fairly efficient way to do it a
palindrome is a number that if
palindromes are word that if I take the
word and reverse it it looks the same
okay
for numbers if I've got number one five
one and it whips it around in Reverse
it's one five one so what I'm interested
in is looking at the numbers between one
and a hundred and I want to find out
which one's a prime and I want to find
out which ones are palindromes and which
ones are both so if I'm going to do this
in an imperative style yeah okay I've
done four loops before what I'm going to
do is start from zero which will the
earth element which will be a hundred
and I know there's a hundred of them so
I'm going to step up from 0 to 99
incrementing by one going to grab out of
my candidate numbers here the next
number along so this is this is just a
right arrange notation in groovy if you
haven't seen that they'll effectively be
a list from with a hundred 100 and 102
all the way up to 200 because I've it's
a inclusive list as it's written here
so I'm going to take the next number if
it's a prime using my tests that we've
weathered are you gonna trust me works
then we're gonna add it to an empty list
they're empty initially we're gonna keep
adding them all the primes that we find
all the palindromes we find we're going
to add to this list and if it's both
prime and a palindrome we're going to
add it to the both lists okay that
seemed pretty straightforward yep and
then I'm gonna put them all out so that
works I won't bother running it because
we'll run out of time can anyone think
of something that might not be ideal
with that solution yeah so is prime it's
it's potentially a fairly expensive
operation is palindrome might be a
little bit so the fact that I'm calling
this factorial doing this modulation
twice might be a little bit inefficient
so that's easy enough to fix so I can go
all the way up to here
okay so we'll do the same thing again
but this time we'll just remember that
we'll have a little boolean that tells
whether or not it was prime or a
palindrome and then yeah we'll just use
that to store the Millennium in malice
okay there might be a better way in fact
then using these little boolean's
because in fact I can just go intersect
between my two other lists and it'll
it'll find all the ones that are in both
lists so this might be a more
declarative nice away rather than having
to go through the lists imperatively yep
but what I probably want to do if I want
to really make my code imperative all
this code will be up on github so don't
don't fret if you don't have to try to
write it all down as we go all the
slides will be on github there's already
a version of both on there they're just
a version from a previous time ago so
I'll update those with the latest
examples as well it might be nice if I
didn't try to do this imperative lis and
I just did take my numbers and find all
the ones that are prime okay that's a
much more declarative way so that would
be functional style okay now one problem
with this approach is that I can no
longer do the efficiency in the same way
I did it before right when I did this
rumored my boolean's and did the both
sort of trick up here I can't do that
anymore so sometimes when you're using
functional style you don't have the same
level of control over efficient things
you might think in your mind okay and
yes the functional compiler is getting
very very smart and doing lots of these
things under the covers for you but
there will still be times when they
won't be as efficient as you today right
now the good news is for this particular
example is well it's easy to do it I can
do some sort of composition functional
composition we saw before but really
what I probably want even for this
example is just to do the intersect
right so I'll just do these two as we
did before and then just intersect them
and that would be the most declarative
thing so combining these three I didn't
really lose much okay but this is this
example is just to show you that it's
it's sometimes very very easy to
to move it towards a functional style
but you may lose some control don't but
don't fret okay in a similar vein I'm
going to swap over to this project and
I'm gonna I've already told you little
bit our composition to memorize I'm
gonna skip those there's a fancy thing
called trampolining which is basically a
technique that allows you to write a
closure that's recursive that doesn't
keep incrementing the stack right and
there's also a tail recursion annotation
we can use there I'm going to skip over
those and come back to them if we have
time but I'm going to jump on to another
one that's just to do with style here
oops now have you ever seen there's a
little puzzle send more money the idea
here is to take the digits 0 to 9 and
plug them into the different letters so
if I've got an e here I've got to plug
the same number in this line and this
line and this line and end up with
something which when I get the four
numbers here and four numbers there it
actually adds up to this final line if
you've seen those little puzzle and you
have to go through and plug in all the
numbers yeah we're going to do is going
to try to solve this one and we'll look
at a imperative solution some
efficiencies we can do with that and
then we'll look at a functional one and
so forth so we'll first off start with
just brute force so it's gonna look very
similar to the palindrome and Prime one
so I'm gonna go through this pretty
quick lips make that forget the right
key
all right so nothing magical here this
is just a brute-force for each of the
letters I'm gonna run through the
numbers that can fit now just so that
what I probably don't want is zero on
the front so I don't really want s or m
to be zero because I wouldn't naturally
write a zero in front of my numbers so
that's the only restriction otherwise
the num so basically s and M can be the
numbers 1 to 9 every other letter that's
here can be 0 tonight yep
so here's my example I'm just going to
go brute-force so s is going to go 1 2 9
as was M all the others are going 0
tonight so I'm just going to go through
every single combination here I'm gonna
create a list of all of those and what I
want is all the numbers to be unique
here so I don't want to have any cases
where this is s is like 1 and I make en
and D 0 0 0 M is 9 and make the 0 0 0
and then it so 1000 plus 9 thousand
equals 10,000 that's a a fake solution
to this problem we're going to allow
that so we want all the digits to be
unique so there's a couple of different
ways I can do that I'm just going to
throw my list into a set and check if
it's the size of that set happens to be
the same as the size of the list okay
that'll tell me three you know I could
use unique and I could use a few other
things ok so if I found a bunch of
unique numbers well I'm just going to do
the multiplication here so I've got a
thousand times s a hundred times e 10
times that right and I'm gonna calculate
send calculate more coke the money if
send plus more equals money print out my
solution ok now this turns out to be
very inefficient takes about a minute to
run and turns out very easy to make this
more efficient because it turns out this
uniqueness constraint actually changes
it impacts what values I can pick from
so in fact once I've if I pick s is 1
then none of my other numbers can be 1
ok if I then go and pick ears 2 then ndm
and so on they can't be 1 or 2 and so I
can make this a lot more efficient right
so I take my digits and then as I'm
going through with my fall list here I
can start pruning out the things that
I've already used and this makes it much
more efficient ok and same sort of thing
as before we can run that and that'll
work and it turns out this there might
be more functional ways we can do this
sort of thing and in fact looking at the
properties of what the letters are going
to be it's actually going to be the
permit
Asians of the digits so if we actually
go and look at a solution that Groovy's
got a built-in permutations function if
I just take the permutations of my
digits and then assign them I can then
just do my calculation pretty much
directly now as if there's a little
couple little tricks that are going on
here I don't really go into the
nitty-gritty but because I've done
permutations
I'm not limiting SNM to not be zero so
I'm just taking all the permutations so
I have to do a little check extra check
I don't to remove them
the other little thing that's happened
here is you might think there's ten
digits here how come I've gone and
stuffed them into eight variables here
well in fact there'll be two unused
arguments here
but what groovy will do so this is this
is if I have anything that it's a list
and I have a list of variables here it's
this is the same as declaring all those
variables individually and saying s's
perm zero years perm one and so on if
there happens to be more things on the
right-hand side groovy will just throw
them away what what that will mean
though is when I run this one there's
only one solution to the previous ones
there's only one solution there'll be
two solutions to this one okay so it'll
turn out all the numbers about three and
four get used here that value plus 3 + 4
or + 4 + 3 will be 2 solutions that come
out of this puzzle they look the same
but yeah we could even remove that we
could we could do things like that would
now I could do that continue in there as
well if I wanted to I can dive in and
even get rid of that second solution if
I want to but I think it's this solution
is clearer just leaving it that for now
and if I wanted to I could just print
out the first other things that gets
returned or whatever okay so that makes
sense so that's that's a more um yeah
functional way to solve this but what
what
they happened here is by moving to this
functional style again my ability to do
the same level of efficiency tweaks as I
was doing in the imperative one has gone
but I may have in fact this permutation
one turns out to be just as efficient in
fact probably more efficient than the
even doing it by hand so I haven't lost
anything in this case but in potentially
I might have now just to those of you
some of you might have heard of
generators so if you've heard a link in
in in c-sharp and so on
there's which you will probably do the
yeah I'll just show you there happens to
be a three generator libraries that are
pretty good this thing called groovy
stream as a functional groovy library
this thing called mono dialogue Oh
dialogue II these actually give you some
of the stream functionality so the
stream function L it's in Java right
groovy doesn't have a built-in library
for that but there's lots of libraries
around that do it and you can go and use
one of those Stream libraries as well
here's how you do the same sort of thing
okay so there's lots of options
available to you and there's you can do
it with or without permutations we can
use them even as stream sort of fashion
um so I just wanted to before leaving
this example to show you one more
example and yes we had imperative yes we
had functional I think I preferred the
functional ones in this particular case
but we don't need to limit ourselves to
just those particular paradigms I might
decide to use a logic solver in this
case here I'm using a thing called
Chacko but there's a whole bunch of
these around anyone's interested to come
and come and talk to me for this it's
like think of Prolog writing Prolog
facts or writing a rules engine here we
go and feeding our rules and we just say
yep s is something between 1 and 9 is
between 0 and 9 and so forth I want to
make them all different please and what
I want to do is do a scalar addition on
some coefficients and some of those
variables that I told you about and I
want that to be a constraint on my
things please go solve it and that's all
you do and it goes and works out there
must have
and again with in some sense we've lost
the ability to have fine-grained control
over this because whatever solution it's
using to go and solve this problem using
a lot of rules engine is a little bit
out of our control but it turns out most
of these api's actually let you even go
and specify hint at the algorithm to go
use to try to find optimal solutions so
you can actually swap over to other
paradigms and find solutions of these
sorts of puzzles so don't if you go and
you know there's lots of functional
religion around at the moment
yes functionals there's lots of really
nice things about functional programming
but it's it's not a religion you don't
have to always do it sometimes there's
nicer ways to solve your problems and
this might be a nice way to solve this
particular problem okay I promise to to
talk more about so here's some some tail
crows and I'm gonna skip over those
persistent data structures I said was
one of the key things I wanted to talk
about so I wonder why I get in and talk
about that now so what's immutability
all about so it's it's we don't want an
object value to change once it's created
okay so if you've seen final in in
languages that's the kind of thing that
we're talking about here now there's
lots of things that already immutable so
strings primitive types the wrapper
classes basic enums if you don't do any
nasty stuff inside your enums there
they're going to be immutable there's a
bunch of classes not as many as you
might hope but there's a bunch of
classes that are immutable or
effectively immutable you have to use
deprecated methods or nasty little
tricks with them to to not make them
immutable even though they're strictly
not as immutable as they could be and
there's various kinds of aggregations
that you can do or if you write your own
classes and follow a bunch of rules you
can make your own things immutable so
it's going to turn out to be useful now
I'm just gonna show you we're gonna lead
through a couple of different examples
why do you want things that immutable I
eat a reason about your code like
remember we before we had the x equals y
plus 1 and then Z equals y plus 1 and we
wanted to reason about it but we also
want to potentially for um optimization
so the compiler could go and swap the
what the second Y plus 1 for X if it
knew
nothing had changed so there's lots of
reasons why we want to make our things
immutable let's just dive in and have a
look at some things so you've probably
seen three different styles that you
might have been used to so if you if you
used array lists or link lists oh let's
just say array lists for now up they're
mutable so if I've got an ArrayList of
characters and I've got already got the
character C and a in my list and I try
to add the character T it it's just a
block of memory and it just goes and
plunks T into the next one
very efficient there's inserting and and
certain kinds of operations on these are
extremely efficient other times it's a
real pain if you're in a multi if you're
trying to do any of these pure functions
or you're trying to do multi-threaded
code concurrent code there's lots of
issues with having mutable data
structures like this so one of the
things you might do is use a mutable one
so if you've used as immutable in groovy
it'll automatically turn your collection
is something that can't be changed and
when you're doing things that are
immutable lists you'll either have two
variants ones that just throw exceptions
if you try to change anything there's
other ones that will change things but
they'll leave the original intact so
what will happen here is if if I have C
and a in my list a mutable list and I
add a T then it'll go and copy the C in
the over and and and put a T there and
return the whole thing to you and it'll
be a brand new copy now if anyone else
is still pointing to the original
they'll just keep pointing to the
original so you don't need to worry
about concurrency issues potentially
they'll still point to the original and
anyone is interested in in the new thing
you've just created will need to point
to the new thing that you've had so any
throw one is pointing to the old thing
it'll just get garbage collected yep
so this is nowhere near as efficiently
for doing lots of inserts because I'm
going to be correct potentially creating
huge numbers of these objects yeah but
it'll remove it'll take away a whole
class of the concurrency problems that
we had with not all the concurrency
problems if
if we've got a whole bunch of places in
our code that now need to they were
referring to the old one and now they
now need to refer to the new one we've
still got to find a way to coordinate
how they now need to know about the new
one so there's still a class of problems
that this won't solve but yeah and
there's the efficiency problem so what
we really want to do is something that a
bit different to either of those two if
you used a linked list it's that sort of
idea so in fact what we'll have is if
we've got a C in an a in a list will be
a C there and an a linked together and
if we add a T we'll end up with C 80
okay now for this avoids it's sort of
like the immutable one here but we're
sharing lots of information so the C in
the a that we had to copy in and throw
away potentially now will get shared
between these data structures yeah and
this turns out to be really really
useful for a whole range of different
algorithms but not every algorithm
certain algorithms you'd be better off
going back to mutable but stick it hide
it away inside something where you can
lock away that
the impurity so you know only do it in a
little local context sometimes the
immutable one will be better but
there'll be a class of problems with
this persistent ones better and there's
a bunch of this is some examples that
are using that but initiative time I'm
gonna skip over them is some advice for
doing using the immutable one okay avoid
a doll and things like that that's going
to mutate the list in place use plus and
so on that'll create new versions this
will be doing the immutable sort of
flavor if you're going to use any of the
JDK JDK is built-in ones that mutate
things go and hide it away instead of
using the built-in shuffle make yourself
your own shuffle there yes it goes and
does mutable stuff but we hide it away
inside their own little TIA
so my shuffle will be a pure function
and there's some code that's using that
and there's a whole range of benefits
but we'll skip over there
there's some examples of how you can get
the the second class we'll skip that
this is the one we were interested in in
going into more detail okay so what
we're going to look at is a little bit
more details because this is the one
that many Java programmers and maybe
even quite a few groovy programmers
won't have seen too much of before and
I'm going to go and use the persistent
data structure out of functional Java so
the word persistence got nothing to do
with databases or anything like that
it's not comes to getting out to a file
store or anything so here we've got a
list and suppose I want to well you know
so last year was daddy daddy on a pony
so we bought a horse
this year it's daddy daddy I want Nemo
so we bought a fish okay so what we're
gonna do is create a new pets object
that's the same as the pets from before
we're going to add a fish okay
the beat many of these libraries will
use things like cons and so on and and
so on some might use other things but
we'll just use the one that's out of
this functional Java library and what
that's going to do is anyone is pointing
to the original pets they will keep
pointing to the original thing there'll
be a new pet object now that points to
this and it'll reuse all the stuff
that's underneath the covers here it all
makes sense yep okay so now that we've
got an email we want to you know the
horses costing us too much in hey we're
going to send it send it off so how a
might we do that okay so I'm gonna I'm
gonna leave pets as it was leave new
pets as it was I've got this remaining
one it's going to be this list here and
oh I noticed that it's this list but
we're just that horse chopped off the
end so my imperative brain says AHA I'm
going to point this remaining to the
fish here and a jump along here I'm
going to chop off the horse is that
gonna be a problem
yeah because the people who are the pets
people are looking at pets or new pets
they still want the horse there it's
only remaining that's not going to see
the horse so in fact you know I want
this I want the size of these things to
be 3 4 &amp;amp; 3 here after I've done the
operations so in fact what's going to
happen is I'm going to call the remove
move and the library underneath the
covers is going to do a copy of all
these data structures across here and
it'll remove the horse off off the end
here and now the remaining will point to
this and pets and new pets will point to
the to the what they always pointed to
okay now you don't need to worry about
all of this the libraries are smart
enough to do this underneath the covers
and this might look it like it's grossly
inefficient and in certain certain
algorithms as a certain hours it is
grossly inefficient but the people who
are researching this have gone and done
brilliant sorts of things with trees and
finger trees and B trees and so on
basically they'll typically have
everything's built at trees your sets
your lists your mat your trees are all
built the trees and they've gone and
done very efficient things like they've
got a tree with me this little mini
lists a little mini arrays inside them
so they they kind of do the best of both
worlds and they hide it all away from
you so that they can get some huge
efficiencies that an ArrayList they can
borrow some of the efficiencies that our
ArrayList could give you by having
little tree little lists in Norway in
their trees but then they go and use
this sort of structure here when you're
going in inserting things it's just to
show you one more example here's a tree
and we want to add one more element to
it now if I was did if this is a mutable
tree I just walked my walk myself way
down to this G node and you would have a
left and a right branch and I go and
plunk my new UK leaf onto my right
branch and I'd be done but with a
persistent data structure I've got a
little bit more work to do I'd have to
go and create a whole new tree all the
way down decay and point off to the
other stuff so I'll reuse as much as I
can but I won't necessary be able to
reuse everything does that make sense
now again the good news is all of this
is happening for you underneath the
covers you don't need to worry about it
but once you start using these
structures you you will want to explore
a little bit more about the efficiency
of these algorithms sometimes things
that you think are a trivial operation
or I just want to insert a new node here
end up with potentially massive things
happening into your tree structures
underneath the covers yes there's lots
of smart people looking at smart and
some other algorithms to this see right
into where too much
okay so you don't need to write this
yourself I've got some links in the
slides we if you want to go and look
into this more you can go and have a
look I just showed you lists and trees
but there's all sorts of different kinds
of things that happen to have different
performance characteristics in different
circumstances so if you find that one of
these data structures isn't good for you
there's probably a different data
structure you can go use so don't don't
fret and yep probably the last thing
that I've got time to talk about today
is writing your own immutable classes
I'm sure you've all effective Java I saw
it in the bookshop just down the down
the hall a little ways you can go and
read the couple of the rules in there
that tell you how to write your own
immutable classes as a bunch of rules
you need to follow quite a lot of code
again things like groovy will say well
lot of that's boilerplate so we'll just
do it for you
if you annotate your classes with
immutable we're going Fillion all the
rules for you so that's the kind of
things that you can do okay so there's a
little bit more material here that's
diving into various aspects once I've
made my pure functions I can make things
lazy and calculate them only when I need
them I can turn things concurrent and
there's a couple of other examples here
the examples here that we'll go through
using a parallel data operations in in
jeepers and using some of the dataflow
stuff and the other thing that I might
want to look at is type safety there's a
slide on type safety but I don't have
time to go through that today but please
come and see me if you're interested in
any more of that the full slide deck
will be up on SlideShare with all the
stuff there and there's code examples on
github for all the examples as well okay
thanks very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>