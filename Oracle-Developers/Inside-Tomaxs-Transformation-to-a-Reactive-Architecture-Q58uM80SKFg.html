<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Inside Tomax’s Transformation to a Reactive Architecture | Coder Coacher - Coaching Coders</title><meta content="Inside Tomax’s Transformation to a Reactive Architecture - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Inside Tomax’s Transformation to a Reactive Architecture</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Q58uM80SKFg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright well should we go ahead and get
started I think this is most of us that
are going to be here I'll just start
with a quick introduction all that Ryan
introduced himself as well but my name
is scott lewis i work for a company
called studio stingray we do consulting
and have been I have personally been
working on Java for about I don't know
since our late 90s so quite a while I
worked on banking and a bunch of
different nonprofits as well as retail
we'll talk a little bit about that
tonight or this afternoon and I'm glad
to be here and I'll turn some time over
to Ryan for a second yes so I'm Ryan
Knight i worked for typesafe as a
consultant and trainer yeah I've been
doing a consulting for about 15 years
originally worked for actually for the
sun java center about 15 years ago and
now i work for types if I travel all
around the world which is a lot of fun
just see a lot of places have been to a
all over Europe and South America doing
trainings so turn over to Scott yeah
Ryan will be back in just a little bit
we're going to i'm just going to talk a
little bit about introduce you to that
the topic of this talk is an inside view
of Tom axes transition to a reactive
architecture I mean just a little bit
about the Tom acts there in the retail
software industry they have quite a few
clients probably run around 25,000
different POS systems all over the world
point-of-sale systems all the united
states i should say there are a few
outside of if you count canada and and
jamaica as also outside the united
states but they have been doing cloud
software for a long time they actually
went against the grain of what retail
systems we're doing at the time they
actually we're taking servers and
putting those in the stores whereas Tom
acts they actually 10 years ago too
to take this servers out of the stores
and centralize that and it gave them the
ability to do real-time inventory gave
them the ability to be able to know
where all their inventories at at any
store at any time and it was kind of
helpful for the customers and there's a
lot of their customers so that's why
they chose tommix they do things besides
point-of-sale they do inventory talked
about store operations we'll talk a
little bit about that one of the areas
that we first transformed into the
reactive architecture do some
merchandising workforce optimization
which is basically figuring out based on
sales and other algorithms how many
people need to be in the store and in
each department you know of that store
so feel like a Safeway or a larger store
you can they can predict that and so
they always say that they were in the
cloud quote unquote but in in there back
to 10 years ago the cloud basically was
you know a lot different than it is
today and so one of the things we've
helped them with is moving them to more
current cloud architectures and so you
know one of the things that we when we
went in there we looked at it and said
they needed to build you know an
architecture that was resilient and
scalable because as you guys can imagine
you guys have tried to buy things that
rush times if anybody try to buy the
iphone recently that was solve
everything was crashed on everybody's
sight but they have things because their
brick-and-mortar they have the day after
Thanksgiving they have for one of their
clients it's Halloween for another one
it's Mother's Day Valentine's Day those
sorts of things so they have to be able
to scale really really well and now that
they're in the cloud they needed to be
service based as well all right so their
product has been very successful there's
there wasn't a situation we're going in
to save anything we're actually just
going in to augment this and they have
they do many many millions of
transactions years you can imagine
I think I said they're 25,000 registers
every day or hitting this with every
transaction that they that they they do
but they wanted to do a lot more so the
world is changing is we have all seen in
our in our world how in retail
especially you know used to this be the
brick-and-mortar was one system the
online was another system and they
didn't talk and so it's frustrating for
us who you know go to a store like what
do you mean you don't know what
inventory you have you know and I can't
go on the website and find out you know
does this store actually have this so I
can drive over and pick it up and so
they call that omni-channel or retail as
I like they like to say it and then they
also had another challenge they need to
bring in mobile devices because you know
these big registers or four thousand
dollars plus are expensive plus they
they've also done research this shows
his associates go out in the aisles they
actually double or do you have some
factor on who would have figured you
know you customer service people
actually buy more and so they did
research on that and found that that out
and so they needed to take these big old
registers and move them out in dials
well it also meant that now there's more
people because everyone in the whole
every single associate in the store now
has a device that's a point of sale
causing more and more transactions but
it has it had a different idea there as
well that not only that but you can't
just expect these devices you only use
them when you pull them out typically on
a computer you're not really looking for
information as it happens but on a
device you actually are looking for
things to happen one anecdote to that I
used to work all before this I worked at
ancestry com and they're predominantly
for fairly older people you know doing
genealogy if you guys are familiar with
that company and strangely enough the
first one of the first adopters of iPads
in that demographic were the older folks
and they would sit an iPad next to their
computer and they would change something
on there
shooter and then nothing would happen on
their iPad and they were like you know
confused and upset and that we get all
kinds of mail saying hey no hey I do
this and this doesn't happen it so that
dawned on me that you know world is
changing you know it's like no longer do
we have this separate these separate
channels that can just sit all by
themselves we now have a situation where
when I change something somewhere on one
medium and in one platform don't it
better change in the other and vice
versa so that got me thinking and when I
started on this project that was fresh
in my mind and and we had similar
situations just one last quick slide on
on tonics these are some of the clients
so it's not you know they're you may not
know who Tom axes but you probably know
who several of these companies are so
they're actually in lots of different
fun places all right so so E is just a
quick review they the issues that we are
facing as you guys all can imagine is
that service-oriented architectures are
hard we had a talk yesterday with the
doctor guy it talked about said the same
thing service re architectures are hard
and we need to find a way to make that
easier we and one of the things in
retail we talked about burstiness you
have to provision the data center for
the peak minute not the peak hour the
peak day you have to be ready for the
peak minute because otherwise your
system is going down so you have you had
could have a possibly a lot of hardware
to sit around doing nothing for the rest
of the minutes during the year so and we
needed more fault tolerance as you can
imagine it's probably not pretty much
not acceptable to walk into a retail
location and say okay sorry I can't take
your money or I can't I can't sell you
this to this piece of merchandise and
then we also you know looked at
technologies and you know how do you do
push how do i do you know we have push
notifications that are when your device
is off but how do I do eventing when the
device is actually connected to my
server how do you handle that and how do
you do
handle a sink non-blocking what's the
what's a good technology to use so these
are kind of things that we went in there
and that and as we looked we looked at
all the all the major ones you know we
looked we actually went out and talked
to gilt groupe who has been talked about
today in other sessions and they are
massively scalable so we talked to them
and saw what they were doing we talked
we looked a little bit about what
Twitter was doing you know obviously
this isn't the biggest Twitter but why
not look at some of the big the big
stuff so we could see what was happening
and we evaluate a lot of technologies
and we came to the conclusion that you
know we really needed a new architecture
that we couldn't really build it into
the one that we had currently today and
we really needed to use a lot of the
stuff that we had still in the in the in
the code base because we can just take
25 year old software company and just
spin them on a dime and walk away this
was what was going to happen and so we
we came up these additional requirements
it needs to work in cloud environments
so that you can take care of that peak
minute on somebody else's dime that
they've racked and stacked a million
dollars with a hardware for you and you
don't have to it needs to be scalable so
that when when we when we need it it
needs to be their fault tolerant we
talked about the push I server site
eventing we thought that that was a good
good option to look at and also web
sockets and then we wanted it to be
microservice friendly because we wanted
to be able to take things and package
them up into into discrete chunks that
we didn't have to you know redeploy the
whole farm in order to make something
happen we learned that from gilt groupe
they do a really good job with that I
think they they told us they had over
300 microservices that run their site
and there's a far smaller in the sense
of what they do compared to what we do
so
and then we needed something that had
production support so we couldn't disco
you some some you know site that are
some open source software that didn't
have a good backing because we have to
go into large corporations and and we
needed that and also somebody who could
do training and consulting and so what
our research led us to is is what we're
really talking about today and that we
chose the the types a platform which is
consists of play acha or the the
frameworks and in Scala the language and
we we weren't really set necessarily on
scala but it has it really simplifies
you know the new way of programming
these asynchronous systems and the
syntax is a little bit cleaner it's far
less code so we we really got that was a
really great bonus that we got on top of
those those things and so we'll talk a
little bit more Ryan's going to delve a
little bit more deeply into the into
that but one of the things that I just
wanted to talk about is that the
architecture surprisingly enabled new
types of things that we didn't even
think about before so you can imagine
you normally you just go in through rest
web services and and what ends up
happening is you end up putting a lot of
your logic a lot of the the the
orchestration goes up in the client and
your client gets smarter smarter and
your service get dumber and dumber it
kind of like moves the makes the server
look a little bit more like the database
and the client a lot more like the
middle tier and and if you analyze maybe
some of the reasons why that is because
the client knows some stuff right and
you don't really have ability to spin
off long running processes because you
don't know that they're going to get
done there's a lot of those sorts of
things and so what this architecture
allows you to do is flip this on its
head because and I'll give you an
example here in just a second but what
you
do is you can actually spin things off
and you can make sure that they get done
so you can a when you run it up against
something and you don't know what to do
you have a long writing process to go do
some research it can go and do that
research and then when it's done it can
go and inform the client because I have
a connection there that I can then push
stuff so the first application that i
was really surprised that that this was
happen we were asked to do a receiving
app has anybody ever worked in a store
before but I k you know so you guys know
how boring receiving is right i mean you
get this box of stuff and you got to
make sure it gets into the computer well
strangely enough we have one of the
clients where we have not very technical
people and we would have we went and
watched them do this and that one of
them would sit on a chair at the
computer and the other one to take the
box and read off the label that's the
UPC the little bar code there and they
would type that in and then they would
go manually search for the document that
it needed to be on and then they would
proceed to do that with with pallet full
of stuff and we like man engineers we
know we can make this better we quickly
learned that that simple process is
actually pretty complicated there's a
lot of things that a lot of moving parts
and so we started looking at it and the
first thing we noticed is that we can
scan anything in this in this whole
palette of things and then we can send
off that just the number that's all we
need to send that off to the back end
the back end then researches what
document that that is possibly part of
all that again then if it doesn't need
to send back all the documents it can
actually determine it there's only one
document that that item could be on it
just sends back the document if there's
more it'll send back the additional
documents and then there's many
different types of receiving I won't
bore you with a with the gory details
there but it also can figure out and
tell the client hey by the way here's
the stuff that you're going to need and
by the way I know they're going
be a lot of stuff in this one so I'm
going to send you down a whole bunch of
data so that you can its pre cached and
you don't have to come talk to me every
time at you you scan this you can just
go as fast as your little scanner can go
and then as it runs into things we found
that you know imagine this customers
don't use your software the way you
intend them to and we found little
idiosyncrasies with how they do that
well you're going along and all of a
sudden you find an item that's not
supposed to be on this palette it's
actually part of another one and they
actually either the shipper messed up or
they're just happy scanning somewhere
and so we can spin that off and we can
go do some research we can go look at a
lot more do a lot more logic and just
let them just continue on we don't even
we don't even interrupt him and let them
know what's going on and then it then at
some point when we have the research
done it gets put into a queue so that
then they can at the end of the process
we can say hey by the way here's the
couple of things that you didn't you
didn't do you can imagine with wet with
just plain old rest web services that
that might be a little bit of a
difficult thing to do because all that
stuff I'm talking about needs to be on
your device it needs to have the thing
going back checking the the you know the
the stuff that's not it is supposed to
be in the palette it needs to be able to
go and know all these things and so we
can actually fix that by moving it so
one of the challenges that I would like
to you know mention to you guys that
when you actually do look at this
architecture if you guys do think about
how that's going to actually change and
how that's going to flip that so when
you build an iOS front-end you build a
web front-end you build an Android front
end you don't have to put all that stuff
in there you can actually push a lot of
that more back down to the server we
were pleasantly surprised by the by that
and so with that Ryan's going to now
take a little bit time and talk about
the actual underlying tools and parts
that allowed us to do that so
let's talk in here sure
you sure naturally
you guys cold it's really cold in here
and you're staying awake eh at least you
don't fall asleep at the beans are cold
right so so who's sort of the reactive
manifesto that looks like a good
proportion of you already of you using
like Scala acha play I know the as you
guys are a couple people are you guys
are over there cool yes so when I we
started working with tomax i went to toe
max right and they have this fruit I
won't say it legacy because are going to
still use their architecture but they
have probably have a very much with this
traditional database right with EJ be
sitting on top of the database and it
was the the challenge was is how do we
take this legacy architecture that's
very much of this request response pull
based architecture and change it to a
you know very much of this reactive
architecture and how do we transform
this architecture into a new
architecture so to kind of explain the
architecture and how we did this I'm
going to go through the clicker cool
talk about why reactive I'll just give a
little bit of your background in
reactive you if you haven't heard it
before and then we'll go into the
architecture that we came up with for
tomax so the reason for reactive kind of
the boat driving factor behind reactive
is that the rules of the game have
changed how we build applications today
is fundamentally different than it was
even a year ago five years ago and
because things are changing so much we
have to think about how we think how
we're building our applications and
rebuild and completely differently so
write apps and you know sixes to the 90s
their original for single machines now
they didn't have to scale between you
know multiple servers whereas today you
know the apps are scaling you know four
clusters of machines we have to be able
to handle you know large cloud scale
absolutely rigid for a single core
processor like your server only had one
you know a single core processor you
didn't have to worry about scaling up
your application you have to handle
multiple cores which today you write you
we have now you know multi-core you know
16 core processors so how do you take
advantage of all these chords how can
you you know have enough you know
processing going on to effectively lever
to all the cores in your CPU right Ram
needs to be really expensive today we
it's really cheap
so we have this you know this this
complete change of the Paradise the
servers are using we have a lot more RAM
available to us how can we make use of
this ram and your expensive disk where
we have cheap disk slow networks and
today we have fast networks these are
things are you know now we have cheap
ram chief just fast networks what about
this enables this enables a whole new
class of applications we can now do a
cluster computing in a whole new fashion
because we can we have a you know a much
faster network we can now enter connect
these nodes in a new way and it's a much
more powerful application so we can
build based on this right so we used to
you know only be able to handle a few
concurrent users today the loads that
you know typesafe sorry the Twitter you
know linkedin you know all these large
companies are using a Facebook they
handle these massive loads and users
this was the unheard of you know even
you know five ten years ago to have to
handle this large of a load right so we
used to deal with you know small data
sets you know today everything is about
large datasets big data and so how can
we effectively process these massive
loads of data how can we you know you
know we've gone from your having to
process you know a couple of gigabytes
to several terabytes of data and you we
also want to process these large data
sets you know in near real time and how
can this all be done you know so you
know we've got a lot more resources
available to us but we've got a lot
bigger challenges to face and so how can
we really you know deal with all this
right latency used to be in the second
you know used to be acceptable that you
go to a website and you know hit refresh
and it might come up in a couple of
seconds you know if you want to see like
data I'd have to you know keep hitting
refresh until the you know the picture
showed up or whatever is expecting today
you know the latency is expected to
instances in the milliseconds you know
people expect when they update their
Twitter that they are going to see you
know that Twitter changes you know
affect any client instantaneous so it's
a fundamentally different way of
thinking about it all right so what we
say is you know a change may just may be
just around the corner things are
fundamentally different today and for
this we have what we've come up with is
recall the reactive architecture
is basically a new way of building
applications and these are the
fundamental principles of a reactive
architecture the first is elastic and
its meaning you're being able to scale
on demand being able to scale your
servers up and down adding resources
dynamically as your load changes you're
reacting to your load message driven so
instead of the traditional pull model
it's a message driven model you know
being able to react to messages and push
those messages on up to the client
resilience being able to react to the
failure making you know figure a first
class citizen in architecture so it's
more than just you know login the fader
hoping that it doesn't happen we want to
have you know really smart ways of
dealing with these failures and be able
to still return response to the user
even when we have a server go down and
the most important is this responsive
that's being responsive to the end user
you know honoring you know tight you
know response time guarantees being able
to respond in a very you know low
latency timeframe you know agreed very
quick responses so really what this
comes down to is right these reactive
applications in rich user experience
with a low latency response so the
applications we build our very much
these these rich applications are very
different today but they're a much more
powerful application a lot more day a
lot more information is flowing down to
the user and it gives the user a much
better end-user experience so the types
of reactive platform I just to give you
an overview we're going to spend a lot
of time about this I think a lot of
you've already know about this if you
haven't heard about it play is a web
framework we call it a high-velocity web
framework the rights different than your
traditional framework is that it's fully
it's stateless there's no States of
scales out horizontally it's just hit
refresh workflow meaning that you don't
have to you know build a war file and
deploy it out to a servlet container or
anything like that it's containers built
in so you don't worry about container
management anything like that and then
we have acha acha sarkar currency
toolkit it basically helps with
asynchronous processing it's all actor
based actors are basically a message
space
processing so the idea is that instead
of having your objects that we have to
call you know sinking in a synchronous
fashion instead we're going to call that
object with a message and when that
processing happens is you know
asynchronous and alka actors are you
know supervision actors are built in a
hierarchy that you know sorry a
top-level actor can monitor I'm children
underneath it and then playing acha
weird so they're built on top of Scala
but they expose the Java API because it
all runs on the JVM any JVM language can
be used to program play and akka we've
specifically you know we do a lot around
java 8 and lambdas making it really easy
to use both playing akka from Java
that's a huge emphasis for us we also
have Scala right scholars our own
programming language if you've never
used Scala to the idea is to blend a
very functional language with the object
oriented and to kind of blend these two
worlds together and and it makes for a
really nice programming paradigm some of
the biggest things it has is this
immutable construct so by default you
can make your collections your variables
in Google which makes it a lot easier to
deal with concurrency right so i think
is immutable i don't have to worry about
shared state i don't have to worry about
who's modifying my data structure
because it's in mutable so you know we
often get asked was is anyone really
doing this is this very popular so just
to give you a sense of the clients that
are out there using our software this is
just kind of a snapshot of a couple of
clients this is just a fraction of who
we see using the software today so we're
seeing a massive uptake or the software
a lot is happening so where we at with
time there's two three okay yeah Scala
yeah so the scholar right it's like some
of the things about scholar you know I
talked about you fully interoperable of
Java you can any kind of Java API can be
called for Scotland vice versa immutable
data structures strong list processing
what that is is instead of you know
having to you like a for loop and do
your transform it you know having a
temporary list and then I go through my
list and do the transformation on that
list and you're storing the
transformations in temporary variables
what it does it says list processing
basically I can tell it you know i added
a function i say you know take this list
and run the functionary element of my
list so that's called mapping and
basically it's a running this functional
transformation on my list for
comprehensions it's just another way of
doing list processing and saying how I
want to do the transformation of my data
structures or nested data structures so
the idea is that I don't have to declare
how I'm doing those transformations I
just declared what I want done and Scala
is going to do it for me pattern
matching it's extremely powerful because
you can do pattern matching and it's
like you know switch but the difference
is is I can do pattern matching on
collections I can do it on case classes
I can do it on a lot of tights in the
scholar language and that it's a really
powerful contract to make it a lot
easier for your billion your programs
play we talked about play already so
yeah so why is play different the
fundamental difference with play is this
that right we normally have a client
that makes the college of the server and
it's a blocking call when that server
handles the call it's going to block on
that request and it's going to hold that
thread so now what no other requests can
be handled and then it's going to go on
it's going to make another block and
call out to a back-end service so what
we're doing is we're tying up multiple
threads those are threads that can be
had any other requests and they're not
doing anything so they're just sitting
there waiting for a response so what we
want to do is we want to make everything
not blocking from end to end so when the
client makes the request of the server
we want to make that that request
non-blocking asynchronous so that threat
can be handled by other the thread can
go off and handle other requests other
clients and then I can go off in my
background and I have to make background
service processes you completely non
blocking yes go ahead
vodka perspective there's like this is
what changes in terms of latency nothing
so the idea is that the although it's
asynchronous and right you do you have
to you know you do i suspend a thread in
a sense but it's done so fast and the
contacts routine is so fast that you
don't notice any difference so I mean
like LinkedIn for example they're using
our hours like play for their a lot of
the the play wet sorry for a lot of
their website and it means if you go out
to linkedin today you will notice I mean
you wouldn't even tell that it's a
non-blocking because it's so fast yeah
I'll do any comments on lightweight fix
I don't yeah reactor perhaps with acha
acha has the actor model and actor is
like a Java object except for the
difference being that it's an object
that can receive messages so just like a
normal Java object it has state has
behavior but the difference is it
defines the communication patterns so
defines what messages it can receive and
respond to so this is it's the
fundamental building block of acha is I
build everything or two actors the other
part of acha is that it's you know
highly concurrent scalable it basically
matches the sot those actors for you it
has its own thread pool and it matches
this windows actors get run and process
the messages i'm fully tolerant fully
adaptable loosely coupled in distribute
oh it does all this with them because
when you create these actors you just
have a reference to your actor I don't
have a direct handle to that actor
they're just a reference and so that
actor can live on my local machine or on
a separate server and because of this i
can distribute my actors across multiple
servers and that makes it really easy to
do clustering you know if I just have a
reference to an actor and I said it a
message it could be running on you know
any of twenty servers that I don't care
where it's writing and then I just get
the response back so this makes it
really easy for
acha to scale both up and out so when we
went into tomax we looked at you know
how can we take this you know a somewhat
of a traditional architecture and you
know kind of wrap on top I just you and
say wrap it add a new layer on top of it
that's going to make it fully you know
this fully reactive we want to make a
fully asynchronous so at a very high
level this is kind of the the high level
architecture we came up with I think a
piece that's missing is where i played
with ah can react with server behind
that play with autoreactive server there
should be another boxes like the Aqua
clustering so you can imagine you
basically have these web socket
connections to come into a place server
they make a one-to-one connection for
each client you have a connection a
website connection taraka actor Duda
alka actors talking out to a back-end
acha cluster and so and then what
they're doing is you right because OCH
actors have a message event-driven it's
a very nice paired for web sockets where
you have this very much of a send a
message and you and then it doesn't
block it just has a call back when you
you have something you send a message
back up to the WebSocket so it was it's
interesting I think this is a hooah zude
Scott who the hell yes yeah Erin Hilda
guess she recently spoke at a I OS
conference Golikov yeah and he basically
said this is what he sees as the future
architecture for anyone who's building a
back-end service for an iOS client is
going to be moving to this kind of an
architecture where you have a WebSocket
talking through an event-driven server
so this is this is not a
request-response server this is a server
that's pushing data up in real time
which is fundamentally different than a
you know just having a bunch of rest
endpoints so we had this architecture
and what we did is behind the play with
awk I was a JB's on top of a database
and the idea is we basically take the e
JB's we check our acha actors and inside
that actor we call out to the ejb so the
aqha actors providing this you know
layer between the ejb and the database
and so it takes this data was it on a
timer a time kinda time to update we
grabbed it was now it's not now no it's
no longer on timers now it's on a JMS
queue that listens for things that
change right right so listens for
changes from the database reason pulls
them out of the database using ejbs
which we were kind of stuck with the ejb
because of the we have to state you know
we can completely replace the term ax
architecture where we had we want to you
know have this very much event driven to
right so you have the JMS queue is that
pulls the data off on the aqha side we
use Urraca clustering quite extensively
acha clustering has what's called
publish-subscribe which you worked out
really nice because what you have is
every client that wants so you know you
can imagine you have you know 20 30 you
have a question yeah that's a framework
that they have it part of that they
already had that so it's part of
replication it's part of being able to
keep I don't know what you call it like
a disaster recovery up and also to keep
a reporting database so you pay you back
on top of that yep yep yep yeah yeah go
ahead we did a similar architecture with
non missing technology and one of the
challenge you live because we're about
the same
geology as to what with race exceptions
it dis created EDX with us and when a
year have been driven nowadays I think
of race exceptions guys talking or do
you mean race exceptions so like because
they're like race conditions may be a
race conditions in like someone created
and the update comes earlier than the
create or the second thanks get out of
order right yeah one of the things that
they have built into their framework so
we didn't run into it as much as they
actually have an ordering it's a strict
ordering that so this event framework
does have some you know blocking in some
things in it to handle the things that
are really tikki on the on the race
conditions be right there are plenty of
those one of the things we've seen is
actually the race conditions go down a
little bit because we not in the
creation and an update but you know now
we have real-time updates for two
devices so two devices are in the store
and they're both scanning things we know
far sooner than we used to that they've
done the same thing and they're part of
the algorithms that we've had it but in
the back is ok when this happens how do
we how do we handle that and so
sometimes now we're able because the
server has all the information it is
says oh good I can handle this sometimes
you know we need to actually surface it
and say did you really get two of those
or you know do you did you you know one
of them yep much much faster I mean
because you can actually sit on one iOS
device scam with the other and you can
watch the numbers just change like
instantaneously so it's kind of nice
because now when people can look down
and see what's happening as a manager I
can look and see oh yeah this is this
event is happening it also changed to
where now we don't have to have a
manager come over you probably all been
in a store
and you have to wait for somebody to
come up with their key and the register
type in some code or whatever and Allen
takes forever now I met instantly as
soon as a price override or as soon as
anything happens the manager gets it 10
seconds later you know or less then it's
already overwritten and you're ready to
go so it's a lot of good a lot of really
great things that come out of it but
you're right there are there are some
things you have to pay attention to yep
I just can see with race conditions
that's another nice thing about acha
actors you can think of an actress like
this walled fortress so the only way to
interact with that actress to throw a
message over the wall and so that
guarantees that inside of that actor I
have this we call it the illusion of
secret being synchronous so right
although the it's underneath the covers
the alkis matching how that actually
gets run and processed internally I
don't ever have to worry about that
state because I'm only processing one
message to the time and it's guaranteed
that i only receive one message and
process one message at a time so it's
impossible for that actor to ever have a
race condition internally and so that
actor can have you know mutable state
you know and it can modify that state
with each message but it's never going
to have multiple messages processing at
the same time because I guarantee of
synchronicity because of receiving those
messages so that's another thing that
really helps with race conditions big
advantage you also can if you wanted to
and you don't care about that sort of
thing there's a there's a concept of
routers and you can spread those across
and machines and have them doing all the
work at simultaneously but and when you
do need to have it in a fashion that you
can't deal with out of order that's a
great feature yeah because in the
regular GM as implementation without
what you do like let it really careful
Yusei only one consumer at a time and so
your guarantee of not having race
conditions yeah go ahead and you have a
question I knew you're going to be
trouble you say over there either in the
front and so that look JB's you were
calling out to I'm assuming those who
are mostly blocking calls or Richard yes
so how did you call out to those from
the actors so so we have a yeah so we
have a pattern in acha we call the
bulkhead pattern so bulkhead comes from
a ship and the ship large container
ships they bulk had the the ship so that
if you get a break in the ship it
doesn't spread throughout the entire
ship right on the bottom it's actually
individual like sections and that
basically prevents it from the problem
from spreading an archive what that
means but by bulking what we mean is
we're going to create a separate thread
pool and we're going to create have
those ejbs running on a separate thread
pool so it doesn't affect the rest of
the system and it can isolate those
particular actors on the on a blocking
thread pool and so you can imagine you
know the ECB's might be you know ten
twenty percent of our system so we're
going to take you know twenty percent of
our threads allocated to this blocking
egv thread pool and let acha manage that
for us run those actress on that and
then the rest of our system is going to
be maintained you know very hight
asynchronous concurrency yeah there's
there's unfortunately there's no way
around i mean traditional you know jdbc
davies drivers they're blocking ejbs are
blocking i mean you have to deal with
blocking and the best way you deal with
that is to put it on separate threats
you don't affect the rest of your system
yeah go ahead
Oh
when the specificity family for any
transfer but
yeah post stress right with with the
postgres that they have the reactive
they have an event-driven driver I
haven't even tried it but supposedly
with postgres right you can have an AC
not blocky driver yes there's not a
general asynchronous because it has to
be built for that specific driver that
specific database so like Mongo has an
async driver cassandra has a sink but it
has to be built specific you know
everything that's blocking yes yeah yeah
so I was just going to just talk a
little bit about how clustering worked
really well with their application so
you have all these clients that you can
imagine this story you have you know 10
20 a handheld iOS devices they want to
listen to you know retail sales data
they want to see you know real-time
Sales inventory everything like this all
those clients are going to want to
basically subscribe to the same event
but you don't want to have to pull the
date the database and you know get all
those events for each of those clients
and so what we use is called the
publish-subscribe pattern so with acha
clustering you can have a particular
node subscribe to updates you know and
it could be subscribing to updates and
then you can publish you know to that
particular topic and you can subscribe
to that topic sorry client that comes in
for that particular store could say okay
I want to subscribe to events for story
you know 532 and then when we get the
updates they're going to be published to
that update and that allows it to scale
very nicely because those the update
services could be a you know a
completely independent node and then the
clients when they come in and make those
connections they're all just going to
listen to that same note and it could be
sent across the network using that
clustering so that was part of em pause
that was the em store em store store
that store management so were you yeah m
store so do you want to talk a little
bit more in depth about the architecture
this next lecture
we'll puff the then you just get on like
can interject alright so I apologize you
won't be able to read this but that's
not the point wasn't so you can read all
the little little details it's really
more to talk about meant to talk about
how this all kind of kit fits together
so as we talked you have the the iOS in
this case that's the chosen platform
that they that they wanted to go with
and it essentially uses a library called
socket rocket it was written by square
and it's an open source project you guys
can download if you guys wanted that I
think they're there are plenty of others
for the other platforms for Android and
that sort of thing but soccer rocket
seems to work pretty well and what it
does it just sets up a handler for every
time anything that comes in it notifies
that there's an odd message and we made
a platform such that we we could figure
out what kind of message that was then
goes off to a handler so you don't have
to like have you know a traditional
request response you basically have this
you know object that sends out a request
and then has a wait for the response and
then processes that this these handlers
just sit there and waits for this socket
rocket to tell it that there's a message
message gets pulled off the queue and it
goes on the other side there's there's a
couple of pieces there we actually to
handle the situation where we have the
legacy software we built this adapter so
you can see there's two sections to that
up there where the have play framework
is and then we have what we call the
retail net adapter the retail that
adapter below essentially will get
replaced over time so and theoretically
it could be used if we had a different
kind of system not retail net underneath
there all of the socket connections and
all the handlers that deal with the
messages that come on there just like
the iOS side has a handler framework
that is a message comes in you figure
out what kind of message it is and then
dish it off to the the type of code that
are the type of object that you need it
to be it's our way to zoom like one box
probably not yeah like I said I just
kind of intentionally kept it a little
bit vague but anyway so the the top part
of that is essentially a play server you
can actually do that just if you can't
see this is the this is iOS apps this is
the iOS apps this is the day I left side
right that's the mobile library and this
is talking over WebSocket to the Play
Framework write the play framework is
talking into the the part you can
understand is all these dots represent
the Aqua clustering basically and so
this is the idea is that these cluster
nodes are talking into the play
framework yep and so and then you can
see down the two boxes down below that's
a database so we do talk directly to the
database or and we also talked to the
legacy ejbs yeah the latency like how
long does it take to in milliseconds is
very very very fast yeah there's no you
know actually the the longer time is
actually in the ejb framework and talk
to the database everything else is
almost indistinguishable from database
and ejb work yeah um I'm not sure I can
disclose those numbers I don't have
permission to do that so it's many tens
of thousands so
do I have to play around with that no no
there are there are some tuning and when
you get into your particular environment
tuning acha is an art a little bit and
it's good to get some help with that
that's yeah the WebSockets we we haven't
had to do anything with those it's more
on the aqha side that we have to do we
have to tune that up so this is red hat
this whole runs on red hat yep we have
red hat in amazon ec2 yep one of the
pros and cons of using acha actors for
to handle these web psychic connection
versus like using like a jetty or
something like that this it does it
right I mean from my perspective is web
sockets are very much of an event-driven
right i mean so they're not request
response at all so you very much of this
event driven i send any event down the
socket and on the server side i
basically want a callback that handles
that event when it comes back and i
don't want to be block at all so I don't
want right so it's a very different
model than when I'm done the processing
I might be able to send that message
back up so underneath what I want to hit
handle this is something that's event
driven from the ground up I want an
event-driven architecture from the
ground up to handle this and that's
where actors fit perfectly because an
actor is event driven by nature and by
using play play websockets actually has
a you can now do it's a WebSocket with
actor so basically I have my web socket
an actor and maps that actor to the
WebSocket and so each client that comes
in right each client connect creates a
WebSocket connection in each of those
website connections has a dedicated
actor that's managing that website
connection and you know a lot of the
samples I do is I show having that
client sending messages down feel like a
JSON message and in my acha actor it's
just expecting that message JSON message
or a special message type from the
client processes it and then just sends
a message back up so it's very much of
this event driven model and play makes
it really easy we write play with
WebSockets I play play website with
actors and makes it wiring everything up
easy I think a traditional you know
servlet container they don't have that
they're very much bill for the request
response and so it takes a lot of
twisting to make them work with the
WebSocket be event-driven and handle it
properly so well I mean I mean vertex is
a vertex is a great product I mean no
Jess I mean there's there's alternatives
but you know I mean I guess the way the
way I look at things if I already
evaluate an architecture today I'd say
you know how does it handle failure what
part of that architecture you know how
is it resilient how am I going to
recover from failures you know how can I
make this architecture scale how easily
is it to scale across multiple servers
and you know and look at these in you
know and how can I tune the
responsiveness make this very responsive
so there's a lot of factors that go into
you know deciding which framework use
and there is there's a lot of it you
know reactive and rated frameworks out
there today so yeah is there another
question good
yeah yeah cuz play uses Nettie
underneath the covers right so plays but
just basically rapping Nettie to make it
easy to you know connect to those web
sockets yeah good if you could start
from a clean slate what would you use oh
we actually we're actually planning on
replacing that all wholesale so we just
do that because there was a lot of logic
that was still down in the in ejb s the
little by little we're moving it to just
connecting directly to the database from
from either player for Makka yeah nonaka
persistence is a little different so we
use there's a couple of different
libraries you can choose for connecting
to the database one of them is a norm
this is one that we happen to be using
so i think type states now pushing a
different one what's a call with slick
and so i would i would definitely look
at one of those no yep correct yep right
we're moving out away from j2ee
completely yeah
in this the same way so there's a
transaction semantics and the drivers
for that as well as you know I don't
know if there's other stuff in slick the
I we don't you slip I imagine that
there's a little bit better transaction
support and slick so yeah we I mean so
instead of using egb transaction just
basically use database transactions into
direct database transaction so and if
you want to really get into a
transactions I mean like the whole the
if you really can distribute computing
eventual consistency you start to
realize that a lot of your data doesn't
need transaction so it could be more a
lot of data is kind of more of like you
can think of it like a log base data
where it's an aggregate value so you
look like a bank account bank accounts
actually don't have to have transactions
because I can just log up to e taking
you know it deposited withdrawals and
I'm or logging those and because i'm
logging it's more of a log that doesn't
need an exact lock on it so there's it's
a very different way of looking at your
data to you know what you're talking so
well that's eventually consisting is it
all about how i eventually come to a
consistent value for that data and that
doesn't necessarily need to have a
transaction so there's a there's like
I'm you know there's community of CR DTS
community of data types that commute
because it doesn't matter what order the
operations come in they'll always go to
the same value so yeah so other
questions or so tell us tell us a little
bit about what the future is you're
doing a lot of spark and big data to
just I think that's really interesting
as well yeah yeah so I don't know how
many of you heard of spark you guys
double spark before so do you guys all
know that it's written on Scala and and
these technology so yeah and so it makes
it a lot easier so after this
architecture we're actually embarking on
another architecture that makes it easy
for customers of tau max to bring in all
kinds of data from census from weather
data from all over the place and be able
to aggregate that and we
is that in spark as well as I do to
aggregate that because nobody's data is
the same we're finding you know that you
basically need a ski Milus spot to put
that and so a spark we're able to bring
in we have a one customer the tum ex has
one customer that essentially in their
mind they realize they look at the last
quarter and they say oh you know it was
kind of cold this last quarter so that's
excuse i'm going to give to the board
that our sales are down and so we're
actually trying to make that so that
it's actually we have real data that
backs that stuff up so yeah so what
exactly hope you're going to be using
what exactly in Hadoop we're using yeah
we use HDFS there's a lot of different
things we use their one of the big
things we're using with spark right now
we're waiting for we actually with
hortonworks and so we're using or C
files because or C file formats are
really good for figuring out who about
what with what type things so we have
looked at Parque actually we did to park
a first but with Hortonworks it's not a
first class citizen yet so that's
supposed to happen at the first of the
year though so we may choose to go back
that way but RC we can still use Taz and
ORCL together so yeah
yeah we use a lot of different things
yeah hi we basically use almost
everything that's in the hortonworks
platform to get stuff in get stuff out
to do from processes yeah yep yeah big
thing with using spark is how you get
your data into spark and so it's very
much of again that's very much of a you
know a reactive a stream based process
so you know you want to take a snapshot
of your data you through you know a
particular point in time until you want
to look at that data is it streaming
through your system and you know using
acha to basically as to help ingest the
data and put it into spark it's a huge
part of that process because awk is very
much event-driven i want to process the
stream and i want to stick it up into
spark or I want to put it somewhere and
then do the analysis in spark and then
when add analysis is done I want to you
know take out event you basically fire
for another event and that gets sent
back up to the client so we're streaming
is in Vicki's you have to work with that
well it depends on what your use cases
you know we use both of them together
actually we have we have a big acha
cluster the brings data in from the
transaction side and gives it to spark
so it's really nice for the ingestion
process of pulling on the same thing of
pulling the day down saying is your
client you can imagine you're just
putting that data out and setting up to
a spark yeah yeah so that's exactly what
we're doing yeah cool any other
questions oh yeah did you have any
trouble showing the type safe step to
the development team to the development
team yes but luckily the CEO of this
company is very well read and he can
just let us he's like you know I want
you to go find an architecture let's I
want you to evaluate the best out there
and luckily he was well read and when we
came to him with like you know given
your situation this is the best that you
the best thing that we would like to
recommend he was pretty much on board so
we kind of got luck yet may I dodge that
question I guess because we had a unique
situation other places I think it is a
little bit difficult to at times to do
that but once you give the education its
it makes a lot of sense and when you've
done the research it's actually pretty
easy to sell because there's just so
it's such a use there
so many useful pieces to this especially
when you deal with failure when you
start their own failure into this
there's really no better platform to
handle failures and to to react to those
than that acha framework so still kid I
mean once we once our leadership got
educated on the value of this literally
I mean they it became their idea and
shattered it that's which was kind of
you know we were we were pushing it from
the bottom up and yeah once we educated
them they were like okay we believe and
then pushed it all the way down which
was that's absolutely the same thing to
happen uh yep exactly still an internal
plant but organizational regions they
are going to sort of switch at the same
time since the synchronous boundaries
and still you can actually make this
work that same way you know so you can
still wrap this thing with the Reich
regular web services and they would work
the exact same so you don't have to
immediately go to web sockets this
website because gives you a digital
productive in because you're not going
to you probably wouldn get all the bang
for the buck but yeah you get you get a
lot of it you know that you you
basically get recoup a lot of your
hardware I mean I guess I mean another I
mean like a type-safe website there's a
case study from whitepages who they
rewrote their architecture using akka
and I don't remember the exact numbers
but basically they dropped the number
service from like 40 down to five
servers and that's largely because acha
so much more efficient in how it uses
the processing it can really leverage
all the CPUs and the cores and so just
being able to reduce the number of
servers and really you know leverage
really leverage the resources you have
you're reducing your operating costs
your DevOps costs all your costs are
going down so even though you do even if
you have a synchronous client you're
going to get a lot of ants in the back
end from resource utilization you know
and you'll get advances because you know
is your develop and we see developer
productivity increasing it because plays
a lot easier to develop with so I think
there's other advantages besides
just having an asynchronous client I
think you get it you know a lot of
benefits and some other parts of the
system as well so yeah that's a really
good question do you guys throughout us
feeling currently um we have that on the
on the plan to add better auto scaling
the auto scaling the talk that was given
yesterday I can't remember the name of
it with the doctor container and may
sews so guy by mesosphere actually has a
really good we're actually planning on
doing that and we're following type
safes they're actually building the
reactive was it called the reactor
runtime reactive runtime which is
basically me so stalker all bundled
together with this so follow that and I
think you'll get what you're looking for
there so all right thanks I think rather
time so if you have any other questions
come on up thank you so much everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>