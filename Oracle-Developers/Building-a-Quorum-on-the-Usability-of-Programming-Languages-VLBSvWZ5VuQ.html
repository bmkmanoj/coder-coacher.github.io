<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building a Quorum on the Usability of Programming Languages | Coder Coacher - Coaching Coders</title><meta content="Building a Quorum on the Usability of Programming Languages - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building a Quorum on the Usability of Programming Languages</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VLBSvWZ5VuQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is andreas tefik I'm a professor
of computer science at University of
Nevada Las Vegas do these just turn off
okay humorous turn out of Las Vegas it's
a big research institution in Nevada one
of the two research institutions there
my main area of focus is predominantly
on studying the impact the productivity
impact of developers on programming
languages with competing design features
so what I'm gonna be talking about today
is really that it's really if you use a
particular programming language there
may be features which are actually
impacting your productivity and you
should have some idea about what these
things are but before I start talking
about what some of the data or some of
the evidence in the literature shows I
sort of want to acknowledge that I what
I think all of us probably intuitively
know as it is and that is that as
computer scientists we really like to
argue about this stuff right like I
think all of us how many people just by
show of hands have argued about perming
languages in the course of their career
how many people have even gotten into
heated arguments about programming
languages and how many people are right
yeah see that's what I thought except
for that guy apparently he's not right
so no comment okay so let's also
acknowledge that right now we're at this
weird point in the history of computer
science like if you really take the long
view as an academic I kind of have that
luxury you can say right now there are
thousands of programming languages and
some people might say that this is great
this shows the creativity of our
discipline but there's a number a
growing number of academics that are
saying hey this is a problem because
each one of us is using a new framework
every week each one of us is using a new
language every month and we're not
really evaluating what the impact of
those choices are on us for example I
was a DARPA session not that long ago
and I can't speak to the veracity of the
claims but one of the people that worked
on aircraft carriers claimed that they
sometimes use five hundred languages on
an aircraft carrier to me that's just
astonishingly stupid right right that
just that just screams productivity
problem but we don't really know exactly
how many language
there are and there's some debate in the
academic literature on this depends sort
of how you define programming language
what that means etc so one report
claimed more than a thousand I tend to
think it's more but you know is HTML
language it just depends on your point
of view right it also seems
extraordinarily unlikely that all of the
language designers have made choices
that impact productivity positively
under all possible conditions for all
possible people that seems if you
believe that that would be an
astonishingly dumb thing to believe
because it just seems really unlikely
that that's true right you know like for
example is the difference between
dynamic and typing really equal are
people equally perform it with each of
them well that's an honest question we
can answer and unfortunately the
programming language design community
and academia is actually facing kind of
an identity crisis for a long time the
folks in these communities and you may
know some of the names like oopsla
anyone hurt oops law or poeple these are
sort of big programming language
conferences dedicated to language design
they've been focused with the laser
focus on performance and mathematical
proofs that a feature works I think all
of us can agree that we would like our
languages to work so this is appropriate
however in the last few years a number
of people in the literature have started
to say wait a minute but how come you
have proofs that this feature works but
it's clearly abhorrent why don't you
actually test whether it makes sense
right so some people are saying maybe we
should gather empirical data one person
in the literature argued that the
situation is in fact so bad that the
entire language design discipline is
based on faith literally this was
published in a major academic conference
that you're just a faith-based
discipline pretty crazy never hear
arguments like that macadamia is just
unheard of but the the audience was a
little hostile by the way but whatever
so anyway my point is there are too few
sort of rational and objective studies
of what these are and so I'm going to
tell you about some of the ones that do
exist today and you start to at least
prime the pump and telling you what does
exist and what people are thinking about
nistam
but I also have to acknowledge that in
fact we really do know very little about
human productivity with programming
languages and in fact astonishingly
little we know quite a bit about how a
novice might use a visual programming
system because academics on the other
side and the educational community have
had a laser focus on creating tools like
Alice anyone know Alice or scratch
they're like these little drag-and-drop
tools and you can program if statements
with a little drag-and-drop utility
those are all well and good when you're
you know ten years old but of course
when you're building Microsoft Windows
you're not going to write a colonel in
freaking Alice or scratch right so so
it's sometimes unrealistic in industry
on the other hand these are effectively
one of the only systems that are
well-studied from an empirical human
studies perspective so on the one hand
you've got the Technical Community and
they're focused to say these language
features work and then you've got the
educational community and they're saying
we only really care about visual systems
and we only really care about the very
first programming class and everything
else can just go by the wayside soliis
this giant gap of like the rest of your
career as to how it goes and it
basically ignores text based systems on
the other hand some people believe that
in fact many of these usability issues
were hammered out long ago like how many
people for the claim that small talk was
well studied in empirical experiments or
ADA and have you heard this claim before
well I've evaluated these claims pretty
carefully and oftentimes this historical
literature does things like say we ran a
study but there will be no data in the
paper or as we call it in the biz
evidence right and and this is really
bad in fact here's here's a graph that I
did recently have one of the programming
language conferences that claims to have
data on human usability of programming
languages and this is a workshop it gets
actually much worse at poplin OOP saw in
fact I think we found it oops aw they've
published like two to three papers ever
that have evidence on human productivity
and I think me and my team wrote half of
them or something like that so in this
particular case the little blue bar on
the bottom these are papers that make
claims or may
may or may not make claims or might make
claims that are unrelated to languages
despite the that this conference is
supposed to be sort of about this but
either a have no evidence at all or be
our sort of tangential or sort of
unrelated to actually studying humans
using languages the other categories are
listed on the right and they won't make
any sense to you because they're just
numbers like 1 2 3 4 5 but we find these
astonishing things like for example you
notice that 5 is actually not
represented at all that's functions like
using functions ever just never been
evaluated in this comfort ever anything
about them like passing by reference the
use of closures passing by various
styles having named or not named
parameters I mean any of that stuff just
astonishing that no one's bothered just
like put 50 people in a room and have
them try it this way I have them try it
that way and do a comparison just
ridiculous right the point is if you
believe that this stuff has been well
studied there's reason have doubt toward
that claim right and unfortunately the
things that there are a few there is
reason to believe that this is a really
serious problem for industry for a
couple reasons number one if you look at
novices there are a few papers and I'm
going to go through some data today as
well showing that things like syntax
remain a huge huge issue for novices in
fact it may be related to things like
dropout rates and computer science
programs which even industry should care
about because there's so many people
that are not getting into the pipeline
which is a big deal something like I
think it's expected for there to be
about a thirty percent increase in the
number of demand for software engineers
within ten years but the educational
community can't even meet that demand
because so many people drop out of
computer science programs so it's people
in industry should care about that
number two though it turns out that even
in real world studies of professionals
they show that productivity declines in
some languages but not others in other
words you use language and you can go
read the papers and find the details how
productivity is measured and all that
good stuff but the point is you use
language X it might have a problem and
if use language why you might actually
be significantly more productive with
that language multiple studies have
shown that
with different kinds of groups one of
these like 40 40 100 projects across
domains this is a big deal you don't
just want to pretend that no matter what
tool you choose it's going to be okay
that's just not what the evidence shows
right okay but fortunately we do know a
little bit about language usability and
what I want to do in this talk is
twofold number one I want to give you a
sense of what the academic literature
shows because I'm going to make the
assumption that most of us don't read
all of the literature is that correct
you don't like download the ACM digital
library and read it on a daily basis
right well I do so because I have to
summon academic as boring and ridiculous
as it is sometimes but but so I'm going
to try to give you evidence and I'm
trying to tell you about only those
studies that have control groups and
statistics and data and things like that
so what I'm trying to say is the types
of things i'm telling you are what we
now know as probably our facts right
that's what I'm trying to tell you so
inevitably when your favorite language
gets shot down because that's what the
evidence shows it's not my fault we take
measurements and take hypotheses and I
tell you what happened and then you can
decide for yourself what that means does
that make sense in other words if you
brought your pitch for it just please
put it aside and say well oh well that's
what the facts show okay alright so
first let's talk about type systems well
for a long time we've debated whether
dynamic type systems or static type
systems are beneficial to people and it
turns out to be the case that in
controlled experiments randomized
controlled studies that turns out that
static type systems are actually more
beneficial than dynamic it basically
what we've been able to show is that you
can write correct programs more quickly
using static type systems compared to
dynamic and some people don't believe
that but unfortunately that's what the
evidence shows so if you're using a
dynamically typed language generally
speaking it is probably lowering your
productivity by a little bit so let that
sink in for just a second and then we'll
try to explain why right okay so believe
it or not we've actually learned more
about type systems in like the last
three years or so then we probably
have in the last 30 because people have
been running controlled studies
repeatedly over and over again under
different conditions in different ways
and they've all been coalescing around
the same answer so they seem to all
indicate that static types of swings
beneficial this is not the rantings of
one academic this is a series of
experiments so you know there's two
basic methodologies that have been used
one is randomized controlled trials very
similar to the way medical studies are
done and also some analysis of
open-source software stuff like what has
actually been used with generics things
like that right there's also show as I
said they can decrease the amount of
time it takes to write a correct program
however if you're writing a very small
program i'm talking like three to five
lines of code in a method dynamic typing
might benefit just a teeny teeny tiny
amount they call that a statistical
interaction we can show you the data but
whatever in addition generics it appears
that one study suggested through an
analysis of a great deal of source code
version controlled source code that
people just generally don't use generics
that much which isn't probably that
surprising when they do use generic asst
a vast majority a significant amount of
the time all they're really doing is
using a list and then a string and
that's it and nothing else features like
the extends operators and all that kind
of stuff are used extraordinarily rarely
and even on a team that use my very few
number of people so and this gets even
crazier it turns out that in fact with
generics even though that's true we know
that generics do actually also increase
your productivity just a teeny tiny bit
when you use them however if you're
writing a generic class you go something
like 10 times slower for writing a
generic class 10 times something like
that right this paper is not even out
yet but it's been peer-reviewed and I
know about it so in addition we know
that novices also have documented
difficulties with the syntax of type
annotations and I'll go into that later
because I ran the study so i'll tell you
about that actually i write about half
the studies that's not the point
okay so how many people have done
parallel programming using threads and
locks how many people use transactions
all right so the best estimate today
done by a guy at UT Austin I had nothing
do with this study 237 people these are
undergraduate students learning
concurrency in a course so everything
that that implies good and bad you know
it's a lot of people a big sample on the
other hand you know it's people that may
not be experts although there is one
experiment showing that students are
actually very close in performance to
professionals that might sound come non
intuitive but that's what people seem to
say nowadays but in this case I'm just
telling you that's what they did right
but interestingly enough it turns out
that using transactions based system
sorry coarse grain locks they had seven
times the number of bugs in their code
how many people find that believable
just on its face only 2 i'm surprised
has anybody ever had a bug with a
threading library I mean for me I mean
you know to me this this result I was
sort of like duh but on the other hand
that's a huge effect size in other words
if you're using some kind of parallelism
you should at least consider not using
locks and threads because you're
overwhelmingly more likely to have bugs
in your code I mean this is it from a
statistical standpoint this is a massive
effect I mean rare to document something
this large it's a big problem yeah
that's a great question and I don't know
the answer but do you see that last
sentence ironically though novices found
transactions harder to use my guess is a
couple possible things often times the
transactions library have this syntax
that makes it look like freakin Swahili
so that's one possible answer another
possible answer is that threads are
taught in schools and as such people
just sort of say well it doesn't make
any sense but I kind of know what it is
and stuff like that but the paper
doesn't go into ye just sort of says
that that's the case if I recall so so
I'm not sure how many people know what
aspect-oriented programming is a couple
so aspect I really I have a set of code
and I might weave in into that code at
various points called join points other
code and you might do this for example
if you're working on let's say the
NetBeans platform eclipse you might want
to have a logger run well you could
hypothetically write a logger in every
single method or alternatively you could
write one aspect so to speak and excuse
me and it will inject your lager code in
every class on the entire system
theoretically easier right well it turns
out that when this was first came out
this was developed by this guy named
Gregor Cazalas right and when cuz almost
first started doing this there was a
number of studies that are at least sort
of suggestive that this might be
beneficial unfortunately now in my view
I think these studies have been largely
invalidated in fact they seem to choose
cozy situations for aop to do well right
and in fact it appears that a opie the
best available evidence is that it only
helps you under extremely specialized
situations so really if you really are
writing a logger that really has to go
into a million classes yeah aop is a
good idea if however you're just writing
code normally maybe not in fact it might
hurt your productivity right that's what
the evidence seems to show and in terms
of it turns out that we actually do know
quite a bit about API design there's a
number of empirical studies on API
design and they have some interesting
results some are better than others for
example one is that
there's a paper out there that's kind of
sort of shows that constructors should
not include parameters leave it or not
so here's the debate right like on the
one hand you require a parameter and
then on the other hand you don't require
a parameter but you force them to put it
in as like a function call right after
the object has been instantiated and
stylus and Clark claim through analysis
of looking at programmers at Microsoft
for whatever um yeah you're supposed to
laughter I'm just kidding under those
conditions they seem to imply that it's
better if you have just no parameters in
your constructors however this study was
kind of not the best they didn't really
have a really firm data so it's the best
evidence that we have but it's not very
good evidence that particular study not
really a controlled study or anything
like that however a couple hours that we
do have more firm evidence on method
placement appears to matter so for
example one example of this that I think
always makes sense to me at least maybe
you maybe not is in job you've got this
collections API right and if you want to
sort something you can't just call a ray
dot sort it doesn't work that way right
or maybe it does now but it used to at
least have to go like whatever it is
collections not sort then pass the thing
and then you can optionally give it a
comparator or whatever stuff like that
it turns out decisions like this while
they may actually be beneficial for API
design possibly or lease debatably they
do lower productivity and so method
placement in terms of API actually makes
a big difference to programmers things
should be clumped logically of course
you know that only tells us so much but
nonetheless we know that that at least
matters we know that it can impact
productivity in addition it turns out
that the factory pattern anybody use
this so instead this is a basically
instead of instantiating an object you
call a factory and it decides what to
instantiate for you sorry and it returns
it to you it turns out this pattern
generally lowers your productivity
believe it or not there might that
doesn't mean you should never use it
there might be good reasons for you to
do it and some platforms use it heavily
I think you could debatably argue that
the look of pattern and netbeans is kind
of similar cetera et cetera but in
general the evidence show
that it lowers your productivity so be
aware of that right if you're going to
use it have a really damn good reason
right and if you don't really really
need it then consider not right just let
people instantiate the objects so
there's more in this area on API design
but you know not a whole lot in general
so what I'm trying to promote or what my
lab is working on is what I call
evidence-based programming and many of
you I hope will look at this and say dot
right and here's how I define
evidence-based programming I say the use
of the scientific method to identify and
filter lesser designs from
general-purpose programming languages
thereby increasing human productivity as
much as possible for the largest
possible audience in other words take
into account as many people as you
possibly can at all ends of the spectrum
from students to professionals under
various conditions those close to death
they're so experienced and those that
are just starting an industry students
at various points in the academic
pipeline etc etc and try to raise their
productivity when solving as many
problems as possible using solid
language design and I'm designing a
programming language that is based on
this work in other words based on the
academic literature or what we do is we
Anna we create the language we analyze
every feature in it every word choice
every decision on the type system
everything and we put that in controlled
experiments when a feature wins it is
retained in the language when a feature
loses we throw it away and put in what
wins and i'm going to show you one of
the studies that we did today on this
work one of many of course our language
takes into account all the stuff i just
showed you to my long-term goal may be a
bit of a pipe dream is to create an
evidence-based programming language and
to document it formally and submit it
for peer review from anyone in the world
to change and alter according to
evidence if it's sufficiently convincing
my studies over the last few years have
involved a number of pieces especially
type systems and the choice of syntax
because ultimately you have to choose
syntax
tired of programmers arguing about it
and in fact it's very easy it turns out
to run syntax studies that give us very
solid evidence and I'll show you some of
them we could even predict at the token
level the probability that a person will
understand it and it's not that damn
hard to figure out how to do it right so
I'll show you some of that so we've done
a number of things like surveys with
novices accuracy tests like how
accurately can they use stuff a number
of studies of usage of various
programming systems from the syntax
studies at the broad broad level it
turns out that language designers are
often very terrible at designing
programming languages for people to
understand it turns out in fact I'll
show you the depth of the terribleness
and hopefully that will be interesting
in fact syntax design in the roller can
be significantly improved and it's easy
to do right it's trivial to figure out
how and some languages have met in fact
made decisions so bad that we can
generate programming languages randomly
and they do just about as well with
normal humans and I'll show you how that
works and show you a formal controlled
experiment where we tested this twice
under different conditions the current
version of this language is called
quorum you can go to quorum language
calm and you can download it and you can
look at the syntax choices that we've
made some of the choices we do not have
the evidence for them up and running
because our paper is still we're still
waiting it for it to come out this is
all done it's all been peer reviewed
it's in major academic journals and
stuff like that but we're waiting for it
to come out and then we'll put all the
evidence online so you can decide for
yourself right just to give you a little
bit of information about it quorum is
built in that means it is out it's a JVM
language one reason why I'm here and it
has common features that you probably
know like object orientation methods
fields inheritance it has a standard
library it has IDE tools like debuggers
and code completion and all that kind of
good good happy stuff right we've
actually collected a lot of data on
quorum we have things like every
compiler error ever received from people
that were willing at least we have tons
of surveys on the syntax we have field
data about its use we actually use the
NetBeans IDE
engine to gather it believe it or not
and tons of control experiments there's
way way way too much data to talk about
for this talk I would bore you all truly
beyond tears however i will give you
some idea of some of it to give you some
clue as to what kind of decisions you
should make and one thing to think about
when this is how many people know
domain-specific languages are you heard
this before is anybody written one or
sort of yeah so one reason why you might
care about this kind of data is because
if you aren't a psychologist how many
people are separate psychologists that's
why I figured if you aren't a
psychologist you're just a guy building
a dsl and you're really you really care
about performance you've heard about
really care about some of these issues
if you don't know any better and you
have do not have better evidence you
should use the same decisions because
they've been well tested right copy
freely it's under the BSD license it's
illegal to patent this kind of stuff
anyway because syntax can't be patented
and as we know from the Oracle versus
Google case neither can API designs and
as such you can and should copy anything
that you see if you don't have better
evidence right okay so one thing that we
asked at first when you're first
designing quorum we asked a question
like about human perceptions of syntax
one reason we cared about this is in
part because when I go to some of the
academic conferences on language design
I look at the syntax chosen and I die
inside because I don't even as a
professional with a doctorate no less I
have no idea what it means it just looks
like gobbledygook crap on the screen
right so here's the question you might
ask it's which words and symbols should
I use in my programming language if
you're a language designer you have to
choose and you have two choices you can
use evidence or you can pull it out of
your ass right so generally speaking our
goal was to go for the former right
let's at least try to use evidence even
though we know full well it's not going
to be perfect and no amount of evidence
is going to make everybody happy right
so you got to choose it's possible that
some choices are good and bad or it's
also possible that syntax
matter that's that's a perfectly valid
outcome it could be the kit and in fact
it's true sometimes that syntax makes no
difference and that's the way it is
right could be the true it's not true
but it could have been true but it's
also really hard to know something like
how can we measure something as specific
as a word choice like if I'm using a
word in a language how do I know whether
that's good or bad what do I even do
what kind of strategy do I use how do i
compute that well one of the dumbest
things that we did first was we thought
well we don't really know what to do so
let's just ask hundreds of people and
see what they tell us right so we did
surveys this is dumb because it doesn't
necessarily tell us anything about their
productivity but it also allows us to
rule out a lot of choices that maybe
debatably bad if people tell us that
right so it's more a mechanism for
ruling things out than it is for
definitively saying something's good or
bad so first thing we did this is
actually a second survey we have other
stuff published but it's not the point
one of these this had 166 people we
asked people that are arguably
programmers sort of people late in the
academic pipeline generally and non
programs people no experience why would
you do that well for a good reason and
I'll show you that later it turns out
that if you ask programmers they're
horribly biased right in fact we found
we were even able to generate an
equation that computes the amount of
bias for various situations it turns out
to be something like for every year of
experience that you have in C++ you
automatically write something half a
point higher on a scale just doesn't
matter what it is you be the ugliest
crap in the world it seems like that's
true though so you need a control group
that can give you a baseline measurement
otherwise you can't measure this right
it's important scientifically so what we
did is we did the dumbest thing possible
you just said hey does this make any
sense we asked how intuitive is this on
a scale from 0 to 11 where 11 is you
know one hundred percent 0 is nothing
right so what we did was then we asked
people we gave people like descriptions
of computer science concepts and these
are always tough to define so what we
did all sorts of normal scientific
procedures like we asked a bunch of
computer scientists
we sent it through peer review several
times we debated about it endlessly and
then we ran pilot testing I mean there's
all sorts of stuff that goes on with
this but no matter what how you describe
these examples at least one person will
not like it but be aware we're at least
saying this is what we did you can
define the questions in your own way and
that's perfectly valid but of course if
you're going to make claims you should
also do pilot testing and ask lots of
people and all that stuff and one of the
first things we found is that some of
the very common things by the way
apparently our non programmer here is a
kitten one of our first things that we
found is that many of the choices that
we're very used to as programmers make
absolutely no sense at all to novices
for example the three worst choices
replicated across multiple universities
and multiple samples for describing the
concept of iteration where in this order
for while and for each the three worst
choices in that order and those are the
most common for is probably the most
common while it's probably a second for
each is probably the third right and it
turns out those are inversely bad if you
will in fact they're so bad that novices
tell us they're about twenty percent
intuitive one of the worst scores in our
entire studies across multiple
universities terrible to say the least
but we don't just test things like
functions I mean test things like loops
we test all sorts of stuff like what
should we use for the word this that
lots of languages use well it turns out
me and self do just about as well we
choose me and quorum because it's
shorter and you have less to type that's
usually our rule if we have a set of
alternatives and once the shortest we go
with the shortest one because then it's
not annoying to us right no turns out
the word undefined does really well in
surveys for exceptions that that is a
little bit unclear but words like check
and detect seem to do really well like
you're detecting an error I guess at
least that's what we think novices
probably thought so we're not sure or
pros there's lots of others assignment
operators the equal unsurprisingly does
find for string concatenation I'm sure
you all be very terribly surprised to
learn that PHP's dot operator doesn't do
so hot modulus and increment increments
interesting because the plus + and minus
minus operators don't make much sense to
people however there's also another
study
out there that did a controlled
experiment on plus plus and minus mice
and found that it actually lowers your
comprehension as well so this isn't just
some survey it happens to map to actual
empirical results as well words like
class do okay but there's other choices
that are similar we've got words for
inheritance parents abstract public and
private defined for protected no one
really seems to know what that mean
which is actually really revealing given
that seemingly every programming
language defines it in whatever the hell
way they felt like it that day it's true
right i mean like you go to java in its
package and subclasses c++ it's like I
don't even know no one really
understands I mean you understand right
there's lots of ways to define protected
but it doesn't seem like that comes out
I'm going to take a wild guess that all
of you can guess what the concept of
constant what word probably best
represents that can anyone guess yeah
that's obvious right isn't that
completely obvious why that would be
right static it turns out we the data is
astonishingly unclear in fact we think
we are programmers put in words that
seem to not make any sense so we think
our question was just unclear for the
word static unfortunately so that the
data for that question is pretty
worthless in my I mean I wrote it I'm
just criticizing myself so there's stuff
like use or imports our description here
was probably more like Java imports so
it doesn't necessarily capture all the
mechanisms so it's not totally fair the
dot operator bizarrely the colon
operator seems to do the best and in
fact one of the reasons why i did a
replication on this study is because i
didn't believe that the colon operator
actually made any sense so i ran an
entire replication like i said with
almost 200 people and got exactly the
same answer on a new sample so
unfortunately in quorum we use the colon
because that's what the results show the
word knoll again i think i said was
undefined okay that's all well and good
that's surveys that's just a teeny teeny
tiny bit of our surveys which are giant
giant collections of data we ran a
second one and in this case we use sort
of bigger constructs right like we had
whole if statements and whole
and hold pieces and then we asked him in
something like eight or nine programming
languages like go and Java and you know
Python and Perl and Ruby and small talk
and quorum and blah blah blah again we
did this sort of intuitiveness type
survey stuff and then we asked people
and it's almost impossible to actually
see from the audience I know that but
nonetheless the point is that languages
actually vary a lot in terms of whether
people make think they make sense this
is for programmers and non-programmers
generally speaking even programmers
think that some language is make no
sense at all right but we also know that
there's this bias factor if you learn
language X you tend to think that one
makes sense right but novices who are
neutral tend to basically if you look at
the graphs they tend to sort of match
with programmers in a lot of ways except
the bias seems to disappear so you can
sort of get this idea of which ones
might be the right decisions right
because you can pull it out that's why
it's a scientific study right so there's
lots of cool stuff there's funny things
like for example if apparently in Perl
having the implicit return operator
where you don't have to give it a name
that's a really dumb idea apparently it
makes no sense to people even for
programmers apparently and some
languages just do very poorly across the
board small talk does particularly
atrociously instead of sorry despite the
fact that they ran the studies in the
past right so apparently they should
have put the data in there so if your
stats person you care about this stuff
this little slide will make sense to you
and if you're not a stats person this
has been peer-reviewed I'll say that
right so these numbers are basically
telling you whether these differences
are due to chance or whether they are
due to you know like natural variation
and the data or whether they're not and
what this slide shows is it's
extraordinarily unlikely that these
differences are due to chance and since
we've done replications in addition to
this you can be pretty confident that
these are reliable metrics despite the
fact that they're subjective right
they're subjective metrics but they're
very reliable right we get the same
answer when we use the same same thing
again all right surveys are all well and
good
but if you're like me i only care so
much about surveys what i want to know
is how productive someone can be when
they're actually programming that's
usually what i would care about right so
a lot of the type systems tests that we
do we time people and say how long did
it take you to do using this tool in
this particular one we had a different
idea we wanted to know do these surveys
make any sense in the context of how
human actually uses a language like do
they make for language for words that
make sense do they make less errors with
that is that true and so I developed a
technique that I call a token accuracy
map and a token accuracy map allows us
to predict with high statistical
precision the errors in a person's
accuracy of a program right so we can
tell you whether a particular token was
used correctly and how often stuff like
that right it's based on these DNA
processing algorithms it's not very
complicated but it works so I actually
invented it for working with blind
children but this has nothing to do with
that but I just sort of observed that it
would probably work for language design
as well and it did so great so we ran
two studies and we decided to do it on
novices in part because of this bias
effect if we test of course while you
want to test everybody eventually we
sort of assumed that if we had C++
professional programmers use C++ they're
probably going to do fine because duh
right because they're professional C++
programmers and you would expect that
they can write C++ I mean if they didn't
that would be really surprising and so
it seemed like if we were to test that
it'd be a total waste of our time right
okay so we tested novices we ran two
studies one was a small scale pilot just
to see if we could get this technique to
work and so there was only 18 people in
that pilot we tested pearl quorum and
random oh and I'll get to random on just
a second this is this randomly design
language then we ran a replication study
for reasons that I'll explain shortly
and then what we did is we used what's
called random assignment this is a
standard procedure in medical sciences
and psychology and biology in physics I
mean you know any of these disciplines
that are what we call science they tend
to do stuff like this you randomly
assign people to groups to prevent
accidental bias
accidental bias is a good word and then
we use what's called a repeated measures
design basically just means we had
people do a whole bunch of stuff and let
me use standard statistical procedures
for repeated measures design which has a
name called a repeated-measures anova
which is the standard thing if you don't
know what all that stuff is it really
doesn't matter because that's what peer
review is for right because trust me if
you send it to peer review and use the
wrong statistical tests they will tell
you right then and that's that's normal
I do stats consulting all the time so
it's for me it's no big deal but
nonetheless okay so we use this
technique that I mentioned about
computing accuracy called artifact
encoding that's the name of the thing
you can look that stuff up if you really
care all right so one of the things that
I was thinking about those I was
wondering well can them medical studies
are hardly perfect but since computer
scientists tend to not gather evidence
at all are they at least better than
what we're doing which is nothing so by
definition yes right so I was thinking
can we use these some of the ideas in
medical studies to sort of make our
community more scientific so what I
thought is what i did was i found out
that in the late 1700s they were there
was this technique called mesmerism as
anyone familiar with this it's sort of
like at the time they were thinking of
things like gravity which are these sort
of mysterious forces nobody really know
what was going on and so this guy named
Mesmer said I can heal you through this
sort of magical natural for timing force
of some kind and so Louis the fourteenth
the French King hired Benjamin Franklin
like the actual founding father to test
this using only natural methods which
means don't include any bull crap right
so what they did is they basically
tricked people they use what are called
sham treatments or as we call them today
often placebos right and they would do
things like have someone tried to heal
someone from within a box where the
person can't see them so that it's not
just sort of there assuming they were
healed and there before they claim that
they're healed right and they found
basically that mesmerism was a total
joke that it didn't work at all and we
have other examples of this to how many
people know what homeopathy is this is
what we call fake medicine right now
granted technically speaking in the
United Kingdom they still actually fund
homeopathy but of course the science
that is actually study this issue isn't
very happy about that because when we do
formal controlled studies we find that
it has no benefit right that's just the
reality of it right and of course it
makes no sense at giving people water
will magically cure them when they can
drink it out of a tap that's just stupid
but whatever okay so we thought well
what would a placebo be what would a
fair sham treatment be for a programming
language and so I thought well I think
most of us would probably agree that if
I generated a programming language
randomly that this is not good design so
what we did was we took quorum with all
of our supposedly good choices of words
and we kept the structure the same
because we don't want to go crazy and
then we roll dice effectively you
actually used a random number generator
and we pulled random symbols from the
ASCII table and that was the syntax for
the language or a good choices right
okay then we compare that against quorum
and pearl so what are the outcomes if
there's no difference even for novices
syntax doesn't matter we don't have to
care ever because you just learn it move
on with your life right if there are
differences then we have to ask under
what conditions and why right that's the
other question you ask all right so
here's another one of these barely
readable slides and it just has all the
syntax for the languages on there if you
want to see this more carefully I can
show it to you after the fact but
basically it has the all the other
languages or ones you know like Ruby
Python Java quorum and parole ebay not
no quorum and this is quorum one point
oh so it actually has a lot of fluff in
there that is gone now but random oh
really does look like you know terrible
right just trust me all right so we ran
a first study when we did this we we ran
the statistics as per normal and we
found not that surprisingly that quorum
actually was easier to use than or
student offices were more accurate with
or however you want to say it pearl and
random well unfortunately pearl in fact
did not perform better than a language
that we designed with a random number
generator so for just a minute I would
like you to let that sink in because
when we ran that study we thought to
ourselves
how could that possibly be correct so
what I did was we said what most
scientists do and we said well screw
this let's run a replication we got to
be sure we had a small sample size but
let's throw other languages in there and
see if we can't figure out why and it
turns out we ran the same study again
double the sample size and got the same
answer so let that sink in a little
deeper and when we actually go out and
look at the analysis it turns out that
it gets worse in fact Java does worse
than Pearl I was a little scared to say
this at javaone but it's not my fault I
just work here right so and it turns out
we know why it turns out that in fact
for for novices this is how we know the
type annotations cause harm for novices
this is about a three percent difference
and that's that's what we observe so
that's the most likely explanation
causally as to why this occurs between
pearl and Java what is it does worse so
okay couple of things to know here
number one quorum didn't do quite as
well in our replication study and
interestingly it looks as if quorum use
might be bimodal at least for the first
but more importantly than that we found
all sorts of problems in our design and
being the designers we were very lucky
and that we can just change the language
to do whatever we want so the pearl
result i should say just you know it was
we got the same answer to within
zero-point-three percent accuracy with a
whole new group of people so in fact
these are very reliable metrics this is
that I mean that's with human beings
that we often claim or so different and
so new and so unique and that's total
crap it turns out that in fact many
people are have pretty much the same
characteristics I'm sure you're all
shocked but more importantly when we
look carefully at the data it is
strongly suggestive the cause of this is
not pearl or Java at all in fact the
problem is see style syntax languages
that deviate from C style syntax almost
invariably do better in formal
controlled experiments than those that
do not but you have to be careful
because there's many things you can do
wrong and these sort of studies tell you
what so for example
here's an example of quorum code and
i'll try to show the pointer if you look
up here it's a little hard to see but
there's these little teeny numbers next
to this token this token is integer this
is static type annotation it turns out
that for this number you can see that
there's a point five and then appoint
for to the point five is the original
study that's the percent of people that
got that token correct and then there's
the point four two that's the percent in
the larger replication study that got
that correct approximately approximately
the same answer but the point is less
than half of novices got that annotation
correct so easy answer we get we add a
little bit of type inference we can
still keep static typing to conform to
the studies that we showed for
professionals earlier having no tangible
worst case for professionals but novices
get the benefit of not having to use
that token and therefore it can't make
the mistake which we observed in Ruby
and Python happens they tend to be able
to write the rest of the code just fine
just the annotation squeeze them up
interestingly enough however in / and
Python and Ruby we know because of the
four to five controlled studies on type
systems that that will negatively impact
professionals and as such you don't want
to get rid of all static typing that's
bad too because that also lowers your
productivity once you're like in the
third or fourth year of your experience
with programming in other words you want
it ideally you want this sort of
evidence-based design your design should
help the most possible number of people
as best as possible in this case it's a
nice compromise because it retains the
benefit professionals keeping the
annotations at the top of a method
declaration while removing them on the
inside of functions which while
retaining static typing and as such it
has the best of both worlds it's a nice
solution at least we think more
important than that this is interesting
if you look here there's an if statement
and then there's a single equal sign
that quorum uses now one thing you might
think is that since quorum uses a single
equals here that that would foul up
people that had equals for assignment
turns out that's not true in fact you'll
see a one one right here next to the
equal that means even when they had to
use them both overloaded under the same
situation in this
same task one hundred percent of novices
use the equal correct and as such you
can't get better than that so solutions
like colon equal or those types of
things bad idea because the only thing
you can do is go down right in addition
oops in addition interestingly enough
this little token here slightly hard to
see the equal sign you notice that has a
one at a point six seven next to it that
means if you look at the replication
data which is what we use more only
sixty-seven percent to the people use
the equal sign correctly for equality
but and that might seem bad but as I'll
show you in a minute if you use equals
equals it is dramatically worse
dramatically worse and also
interestingly if you have an if
statement here you have an if you'll
notice that quorum in version one plano
he has these little end at the end
because we thought oh it's if then
that's plain english everybody
understand that turns out that's total
crap that's not true at all in fact the
people that use then on the first if
which is right about here so saying if
then only got that right about half the
time and if you want to make your syntax
parallel with these else's so you have
to say else then otherwise this code
doesn't make any sense across if else is
right if you do that people got that
right only eight percent of the time in
other words it turns out the syntax of
ruby was in fact substantially better
than the syntax of quorum with the
exception of the double equals operator
and as such in forum 1.7 it's 2 point 0
now we actually use the best parts of
ruby and the best parts of forum and now
it has the best of both worlds so that's
the thing about evidence-based design
you get to win you'll always win because
the moment you lose you just change the
language to win again right you get to
cheat right but you do it based on
scientific data right and evidence okay
so let's keep going so with these
results you might ask yourself well but
how do you know that this isn't random
noise how again do you know that this
isn't random noise this is an important
question to answer but again we did the
normal stats and the rule here is 99.9
percent confidence that's far in a way
above what is standard macadamia about
95
I percent confidence and in fact it is
so strong that it's close to the point
of accuracy that they use in physics
extremely reliable extremely reliable
that's the key here if you run the same
study again you'll get basically the
same answer with a different group of
people okay so overall a couple of
things to notice our loop syntax and
corm did not change at all virtually
every other language did extremely
poorly with loops including things like
Ruby Ruby's has operators like dot dot
no but he knows what that means and you
know of course I've got dot dot and dot
dot and everybody has to remember the
difference so we sort of played with
that a little bit of course nobody knows
what it does Ruby if statements did
better than any other is statements so
those are now in quorum as well
interestingly with the I told you this
equal equals operator well it turns out
that we have sort of a nice way to use a
sham treatment for this to test this it
turns out that in random oh we just by
pure chance use the bang operator to
represent the quality symbol and it
turns out that this bang operator did
just a smidge better than equals equals
so in fact equals equals is incredibly
misleading to people okay oh by the way
sometimes when people say but yes but
then you can't use an assignment in an
if statement if you have equality me if
it means equality there and my response
is typically yes you'll have to make the
ultimate sacrifice and put that line of
code one line above I mean big freakin
deal right but whatever in addition we
know that novices did not have
difficulty using equality for both
assignment and equality the overloading
does not matter in this instance that's
what the evidence shows in addition
dynamically typed languages actually did
pretty well novices have trouble with
type annotations they really do but we
have to be careful we don't want to
remove the type annotations from method
declarations that's crucial and it's
important the annotations are in there
we've done other studies on this and it
turns out if you remove the annotations
themselves even if you add documentation
saying what the annotations are that
doesn't help you it turns out that if
you really want the productivity boost
you need the actual annotations in the
actual type declaration even if it
screws up novice is a little bit it's
worth the effort because it raises their
productivity later at least that's what
we think right that's what the best
evidence shows yeah
that that's actually the exact solution
in coram I said it but you're exactly
that's exactly what we did so yeah I
will say one other thing though I did
say dynamically typed languages mostly
did well but there's one caveat to that
it's not the dynamic typing us the
problem it's the removal of the type
annotation is that was what was helpful
for novices and the reason for that we
know that that's true is because pearl
doesn't do that it didn't make that
decision it uses like dollars and how
many people know it dollar underscore
left brace zero right brace means one
guy okay good what does it mean right
see and I and of course novices of
course knew this right no novices have
no idea what that means it was either
like zero people got it right or maybe
one or something and we gave them
examples you know so they had examples
of this stuff so it wasn't like they
were flying blind it's just they didn't
know what the hell it meant but so when
you add characters like that in then
inevitably their their comprehension
goes down even though it's really not
that big of a difference but it also
tells you something deeper it says if
you're designing dynamically type
language don't put those stupid dollars
on there it's pointless and it fouls
people up and it serves no value except
for the parser but I don't care about
whether your parser is hard to build or
not right not if your language is going
to be distributed worldwide and I'm
going to use it forever right so okay so
from my perspective if I really want to
make this an evidence base language
there's a couple things we got to do
besides building form which is already
done and available on online senators
are we got a quorum language we released
quorum two-pointer last summer and we
have what's called we're adding all
sorts of tools to help people program
because of course it's not just the
language that matters for professionals
it's office also things like you have a
really good debugger do you have really
good code completion do you have all
these sort of productivity tools or
factors and all sorts of stuff quorum
doesn't have all of that but it does
have a debugger and it's an omniscient
debugger does anybody know what that is
it's a debugger that can like go
backwards and allows for searching and
stuff like that ours is not fully
perfect yet however where we've based it
on some brand new research out of
that allows for commercial scalability
of these kind of tools so we're thinking
within about a year I mean it's really
really close to commercial scalability
right now except for some minor bugs and
stuff like that but we're hoping within
a year or two at the most you'll be able
to do things like not just run a program
in the debugger but you can like type 12
and it'll find all places where you've
ever had the variable 12 and roll back
to that spot or if you have an exception
you roll back to it you don't just jump
to the line no no you can roll back to
any place you feel like that's what
we're building because we want
productivity to be a really important
focus in the language not just at the
syntax or semantics or other level but
also in terms of like the tools you need
and what you really need to make your
self productive or your team productive
right so we're working on stuff like
that also we added in tons of extra
little features our code completion
libraries are actually pretty solid now
for the most part and the compiler is
solid as well we've done a lot of work
to make sure that that actually works
right so the next version we're working
on a number of new pieces so for example
we're doing this same type of analysis
right now in concurrency in part because
when I look at languages that have
concurrent solutions the syntax scares
me and oftentimes the solutions are also
highly different from each other so I
think it makes sense to ask what is the
productivity benefit of each of them and
can we take the best approach and then
whatever wins and we don't care what it
is that goes into quorum and all the
others get thrown away right so we're
doing that same thing with closures
we've actually finished two empirical
studies on closures I won't tell you
those results because they're not
published yet we're also working on an
enum system but we're not exact there's
a lot of choices for some of these and
so it takes a while to design the
studies if you want them to be fair and
objective so these I'll take time and
we're also adding many new API features
for for the language as well so okay
before we sort of start hammering down I
also want to say how you can get
involved if you're interested in this
there's a couple ways number one is one
way that you can get involved is you can
gather data on human beings and you can
do it in a controlled way but of course
I'm not really here that
say that I expect you to do that but if
you do have a team and you have people
do projects in different languages
measure their productivity and send us
the data so that we have some more
information because that's just really
helpful or work with us because we can
also do analysis with you at your
company for your teams and then you
offload that to a university you get
some information on how productive your
team is we get data that we can publish
anonymously and everybody wins so if
you're interested in that please feel
free to contact me and that's possible
right data aside we're also doing a
number of things in quorum to try to
improve it number one is quorums bsd and
we're adding in a new library system
that will allow you to submit stuff if
you submit libraries to the quorum
project there's a couple things that
happen number one goes to peer review
right or hopefully nice peer review
because peer review can have daggers
sometimes but it'll go through peer
review and to at least have consistency
checks and quality checks and actually
run the thing and make sure it works
stuff like that right number two we also
accept submissions if you think we're
wrong right so for example if you say
the decision you made about the type
system under this particular condition
is terrible send us some data if you
send us evidence on controlled
conditions we will change the language
right the point is to make it a
scientifically design language
evidence-based design and to adjust it
according to what the data shows not our
own opinions we are sort of the stewards
of quorum but it sort of lives on its
own right okay you can also submit
libraries and this is through a sort of
competitive process at least we're
hoping it will be in other words if you
think our file library sucks and you
just want to add a couple methods you
just send us a new one it goes through
peer review if it passes that becomes
the new file library right so you don't
have these problems where in many
languages where you know changes don't
necessarily happen quickly because
anybody off the street can send a new
version and as long as it passes
reasonable peer review it's okay and
it'll get integrated into the next
release so potentially it could be
faster we'll see another way to look at
this is if anybody swinger things like
gems in a way this is kind of like a gem
type system the difference is that you
don't get gems that are crazy
you you mostly have gems that at least
somebody's looked at and said yeah this
is okay and it makes sense and it's
consistent and reasonable right so you
get like I said you can also submit
changes to the language this can also
include code if you're at a company and
you would like to actually use quorum
for something it is a it is a
commercially scalable compiler it should
work just fine for you and so if but if
you'd like to make changes or do things
with it you're welcome to get in touch
with us or adjusted and you're also
welcome to submit patches anything you
want to thats under bsd so you can do
whatever you want with it so alright
well thank you here's some more
information if you want it we've got
corm two point oh there's a website
looks pretty slick with all sorts of
cool stuff lots of support in to
NetBeans and you can find it out foreign
language calm and I'm hands happy to
answer any questions you have I think I
saw you first
ha yeah that's a good question that's a
great question and I'll tell you so 11
other reason why we run that Ram at
second replication with a colon operator
is because it pissed off everybody on
the team to have to go uh right as
opposed to uh you know what I mean like
you have to press two keys to do the
colon operator so I will say we don't
have a test on organ ah miix I'm not in
there probably probably as possible I
don't know if I wouldn't have an impact
or not but it's something to think about
so great question
that's a good question and the answer is
formally no because we we have to we're
trying to make the language based on
evidence however I'll say this when we
first designed the language things
changed crazy fast because we had run
new studies all the time and change
syntax and stuff but we haven't changed
much since acts in God almost a year
just because we haven't needed to
because we haven't found anything that
refutes us yet however so what that
means is if more studies come out that
want to change in the language they need
to be increasingly convincing in other
words we have a bunch of data on the
syntax now but if some group like let's
say you you you're like hey man this
syntax is fine but we ran this study and
we think that you're wrong we want you
to look at it and change it if this has
been if a piece of syntax or something
has been established for a while the
evidence needs to be increasingly
convincing because you have to push that
to the whole deaf community right so in
other words no but they're not things
that we change willy nilly either right
you know if the if we want to make a
change it has to be convincing
scientific evidence does that make sense
yeah
I have no idea it's to my knowledge has
never been tested in any lab so it could
be I'm not sure I will say though that
most programming languages are written
in English so I'm not saying that that's
good or bad but we probably won't buck
the trend on that one just because we've
got a million other studies that we
would like to conduct so that probably
wouldn't make it into the queue even
though I agree with you it's interesting
and important
it's the complex characters without
replicating
yeah that's a good question as well and
I think that that one's really important
because complex the issue you know in
any programming language no matter which
one it is these sort of complex issues
come up no matter how good the language
is or how bad the language is there's
going to be complexity issues because
reality is complex right so corm doesn't
have any magic but magic silver bullet
right so there's nothing that we can do
if you have like 50 million lines of
quorum code hypothetically you know you
have 50 million lines of code I mean
that's going to be complex no matter
what right
well i'm trying to think there's
probably some studies done in the
software engineering literature on that
sort of packaging type stuff and
certainly quorum uses similar
conventions to any other languages so i
don't think we're really innovating in
that way but we're not doing any worse
either you know like i haven't talked
about it all but quorum does have a
packaging system that's kind of kind of
sort of similar to java which is
probably not surprising since it's a JVM
language we did make it somewhat simpler
i think but we haven't tested this
formally like for example you can
declare packages but the compiler is
smart enough to arrange everything in
the right location so you don't have to
mess around with it and you know we have
and.yeah stuff like that but i mean does
that make a huge difference well if you
know the convention maybe not but on the
other hand the compiler does it all for
you so you never have to mess with it
either so yeah
heart
around
yeah I don't think we really disagree i
mean i think that I'm just saying that I
think all the languages are pretty
similar on this front I mean so and I
don't think forum has any silver bullet
there so there are some tools i think
that Microsoft is done on tracking which
files developers use and stuff to try to
help with that stuff and I've heard that
they helped a little bit but i'm not an
expert on that data so so i think they
did some kind of tracking okay looks
like we're out of time okay sorry folks
but thanks hope you enjoyed</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>