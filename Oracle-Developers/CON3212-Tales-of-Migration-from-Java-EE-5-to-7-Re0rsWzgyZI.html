<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON3212   Tales of Migration from Java EE 5 to 7 | Coder Coacher - Coaching Coders</title><meta content="CON3212   Tales of Migration from Java EE 5 to 7 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON3212   Tales of Migration from Java EE 5 to 7</b></h2><h5 class="post__date">2015-12-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Re0rsWzgyZI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello guys good morning thank you so
much for joining my session about
migration tales from Java e five to
seven and it's glad to see you all here
at eight forty in the morning are you
guys enjoying the conference awesome
thank you so much it's like the first
day and I'm guessing people already
tired because being very long conference
we still have a little bit to go so once
again thank you so much for joining me
and I hope that I can deliver you an
awesome session for you guys if you
please allow me first let me introduce
myself my name is Roberto Cortes and I
working a lot with java ee technologies
over the last six seven years mostly
working on the finance and insurance
sectors and I'm being very involved with
all the versions going around since Java
e 5 6 7 and even for right even before
we got annotations going other than that
I also try to follow a speaking careers
that's why I'm here today and I'm also
have my own blog where i post some of
the stuff i usually do around my work
time and some other stuff that i like to
work on and I pretty much love
everything around Java as well so if you
guys have any questions regarding my
work or anything else you can reach me
on twitter my email I can just come up
to my blog and see whatever else I'm
doing there
so before before even we start I like
like tell you guys that this
presentation is not really about
technology axe versus Absalon so it's
not like javi five verses 7 or Java e
versus spring I'm not going to go into
those details what i want to tell you
really about is my own story that I've
been working on on some very big
projects around migrating stuff this is
not also something like follow
step-by-step guys to do the migrations
when you need them especially because
each case is separate case so what I
want to give you here is some of the
experience that I have when I have to go
do these migrations and hopefully you
can learn from them
and try to apply them to your case also
I want to share some something knowledge
that I got in here let's go we're going
to get it through in the future when we
see some of the things I been working on
and hopefully i think that people
usually learn a little more with
mistakes that you actually do instead of
the success stories so hopefully i'll
give some of the mistakes I made some of
the success i made as well and you can
apply them to your use cases so as my
colleague Peter mentioned we are using
crowd mics that's the name right sorry
grab on here so we are not that many
here you can use the app to send me a
questions and I'll answer them right
away and when I see them here on the
iPad but if you like you can ask me any
question any time during the
presentation I like it to make it more
interactive instead of like me talking
all the time and then you ask questions
in the end sometimes it's just one to
ask questions at time and then you
forget it in the end so please raise
your hands or send the question by crowd
mics and I'll be gladly answer your
question thank you so much so I want to
talk a little bit of history about Java
EE but before going to that let me ask
you who's here still using Java e4 ok
have a couple of people in Java e5 and
most of you I'm guessing that's because
that's why you came to this recession
and java 6 ok have a couple of more
actually even though this is the title
of Java 526 I think it's job is five to
seven I mean I think that the people
still on java 6 can also learn a little
bit from here in Java 7 ok one person to
person ok yeah hopefully after this
session we'll all be in Java 7 and Radek
java 8
so if you look into the years where java
e5 came up and we taught me about 2006
we are coming to in 2015 that's like
seven years right so seven years in a
technology world is like a century it's
huge just look at how things evolving
technology look for instance on our
mobile phones like every year we have
like new mobile phones in like two years
before the mobile phones that we have
from two years ago they just suck right
so I'm not saying that java ee sucks but
honestly we have to keep evolving our
applications so we can be ready and also
try to make fun and use of the new
specifications and technologies and
features available for us there are some
some major changes introduced from five
to seven maybe most of you already
familiar with that but I want to do as
well to talk a little bit about that so
we are exactly sure what we're talking
about so do some of the specs that we're
introduced with java e5 some of them
were already existing Java e4 as well
but they as you can see here we have jsf
Jack's the west serve word jthj PA and
and a couple of more and not a big deal
but now look when we jumped java 6 we
got introduced all these five new specs
CDI managed beings web fragments jax-rs
and bean validation so that's a lot more
content that we had on java ee also and
i haven't put this here on the slide
because it will probably over complicate
a little bit but all the specs from java
e5 also got reviews on the versions from
five to six so jpa got a lot of other
stuff
Chuck sir lewis as well and all the
others got like major reviews now if
you're going to Java 7 we have four more
specs introduces into the spec so JSON a
little bit dark hope that you guys can
see it json web socket concurrency and
batch my personal favorite I'm it's a
bit boring but I love batch and also a
lot of all the other specs got major
revisions other minor revisions but as
you can see there is like big jump
between five and seven now I wanted to
talk a little bit of the platform iming
working on so you guys can understand
why we need to do this migration so a
cigarette that's one of the project I've
been working on over the last five years
is a platform that integrates the
insurance company systems in a big
network in Portugal so the insurance
companies use this system to share
information between each other and it's
very useful for their business because
they are able to cross reference data
between their clients and see the deals
between them see if someone is trying to
make fraudulent insurance and some other
stuff so it's a very fun project and I
love working there nonetheless new
challenge arrived every day and honestly
after seven years using Java 85 not
because we don't love it we really
needed to start doing other stuff to be
able to get into the new stuff that we
have offered to do on the project
so I'm going to little more detail into
the technical architecture is mostly
like a seoul-based architecture using
messages xml messages via soap and in a
batch as well so the insurance companies
came through wet with our system using
these channels they can they might have
systems on their own that you can use a
WS and batch to send us the messages or
if they don't they also have like a web
interface where it can call and do all
the operations that they need so just
for you guys to might have an idea on
how this works also a few numbers about
this application in this part too firm
so currently we have around 65 65
company's insurance companies are using
our system these are composed for more
than 30 k users so we are not talking
and users are talking about the
employees or the partners that work with
insurance companies and they use this
system for their day to life work we
have around 141 million page views and
more than 300 million several requests
this so this post blast numbers are per
year so it's not exactly small app not
exactly like a big app but I probably
considered like a medium to big app now
portugal's not very country a very large
country either so there's only one 10
million people so anyway
regarding a little bit of legacy of the
visa application since 2007 we are using
Java e5 and we use other technologies as
well so we just wait for the early for
you why because there's a little bit of
spring specially for doing bad stuff at
that time we didn't have the batch
specification for Java EE so we have to
rely on something else and we pick
spring batch you also stands the Apache
project velocity birth of the reporting
so these are kind of technology that we
use on unscrewed net and runs on jboss
for who here who's Rev us for one person
okay let's try to go with the old
versions of application servers
glassfish free one percent to know
weblogic like seven or six a couple
websphere like seven or six as well yeah
couple more yeah so let me see that also
for j one person okay did i forgot any
server know who is 0 soon something else
you can you can talk no one's going to
bite you it's fine okay anyway we come
to a conclusion that we need to stop
some of the legacy code that were
introduced you because every new feature
that we were developing we were
developing with using java e5 so that's
more legacy that we are introducing to
our application so I I be draw this
graph just to have an idea on how the
application grew and well when we
started developing the appt 1 2009 well
actually started a little sooner but it
was like requirements gathering and so
on but we started with like 140 k lines
of codes and we steadily be growing the
app all over the years and you can see
that increase is being like 200 to 300 k
lines of code each year
until we actually give the migration so
the migration actually stopped or the
grow that we had on the lines of code
per year why especially because the new
implementations and new specifications
from java 7 simplified so much the code
that you write that you actually going
to write less goes actually some of the
stuff we already have we are using some
of the new stuff of course we're still
using some of the old stuff as well but
gidea will be to simplify it and you're
going to reduce the the lines of school
that you have is this a bad thing or a
good thing in my opinion I think is a
good thing because you have less lines
to maintain it's much simpler to read
and it pretty much allows you to not
have to write so many codes when you're
developing the app is something that you
send sometimes isn't she a see at long a
short term but that long term as you can
see here on the graph it's very
important so whatever what are the
motivations for you to migrate one of
these applications especially of course
use the latest improvements and we saw
some of the specifications already so
CVI is an awesome specification batch as
I say as well I love it bean validation
is an awesome spac Jack's arrest of
course everyone now is using West
services with micro services and
everything else so you have like plenty
of stuff here that is a very very big
motivation to migrate
just take advantage of these new specs
also remember that javi 5 is linked to
java java version 6 from gk 6 so as you
probably are aware java java 6 and those
life was on the first scorer Oh 2013 so
this also means that probably the
servers that you're running on Java five
maybe their support java 7 or 8 maybe
not but the thing is you are running
you'll probably running on over on
version of java that's already
unsupported and you don't have security
fixes so who's here is using java 64
their servers yeah a lot of you so do
something that have to concern you
because we see so many security fixes
going into the Java platform and you're
not taking advantage of those security
patches and especially you're exposing
yourself to those security holes and
that can be very devastating to your
business if some attacker might be able
to get into your system and use them to
their advantage so this is like a very
very big motivation to migrate of course
we also have like increases maintenance
costs
I mean people don't don't know about
maybe they don't know about the old
specs then don't know how to write the
old code you need to train them you have
much more code to read as i can i can
show you on the graph on how the the
legacy crowd grew so and you can't
really take advantage of the new specs
so if you want to do something like bean
validation you just don't do an
annotation have to write the code to do
the validation yourself so it's a pain I
know totally probably also my my
favorite is you have to keep your
developers and your team interested in
what they're doing so who hears he
doesn't like working with Java 85 now
yeah couple of you it's not it's not
because it's at it's just because it's
an old technology so who here wants to
work with Java 7 okay most of you so
that that's my point also he had also to
realize that companies sometimes they
might even spend more money because they
get stuck in this infinite loop hole
where developers they lost interest on
their technology because they know
technology so they move to another
company then you have to iron new people
you have to teach them the technology
after a while they get bored because
it's no technology they leave and then
you get in stuck in this infinite loop
hole and you probably and end up your
business end up wasting much more money
and this init loophole then just paying
for the migration
itself right anyone disagree cool so
let's try to dig in and so now let me go
into a more technical approach into the
this session so let's try to try to big
into the hole and I mean it might be a
task that a little bit hard to perform
because we don't exactly know where how
we're going to start it but one thing I
want to make sure to you guys the
migrations are not really a
straightforward process so it depends a
little bit on what you're doing and what
do you have so it's really difficult to
know the path that you should follow we
have a lot a lot of we have a couple of
problems when we're doing it so we have
to deviate a lot from the things what we
were doing so learn to expect the
unexpected and you're probably going to
be fine with that so let me also talk
about two two things that you can do
when you're doing when you're starting
to look into this problem is the
strategy they're going to use to do the
migration so there are a couple of
strategies that you can use one of them
is doing the secret freeze so you pretty
much stopped all development and just
focus on the on the migration at some
advantages and another disadvantage of
course so many disadvantages is that
it's going to delight the new business
features and this is what sometimes very
painful for your client most of the time
this doesn't work because clients want
new features every time and creates like
new the deadline there's no pego shovel
right so if you say you're going to do a
feature freeze and we're going to
complete it by at the end of whatever
that you actually have to fulfill that
type because everything is going to be
expecting that
since they already feature fries they're
probably not going to allow you to have
more time than you had a hat and the
good thing is that I mean you are able
to focus on that and it's going to be
like one shot so it can be used in some
scenarios you have to look for yourself
but this is one of the strategy that you
can use for that then you have something
that I called the combined strategy so
you keep your development going and of
course that's better for the business
because you keep delivering new features
but requires that you have a more
detailed plan on how you're going to do
the migration because now you have to
combine when you're doing migration of
the new stuff to the new stuff and I at
the same time you're introducing old
stuff with new features so i have to
like take a balance on that and have
like a very good plan for that doesn't
for that to work you can you can now do
it like try to split your application by
module or by cannery so like only a few
features you migrate or by application
for multiple applications multiple war
files you can do that it might be a
little patient because that requires you
that you're going to have to scale your
environments to have like application
servers for for the old app and the new
app or the new part of the object was
migrated but still that's another
strategy that you can use and usually
it's probably the with the one that I
use the most because it's very hard to
convince the clients to go features
freeze
so the first steps you know in our case
since we were using jboss we kept kept
with the Red Hat products and we went
for 158 we could have migrated to
glassfish or some other java ee 7 server
but at the time when we were working on
this while flying glass fish were the
only java 7 certified servers so we had
to pick one and because glassfish didn't
have support we pick up Wi-Fi and that's
when we are using now as I mentioned we
were using the combine strategy so that
means that you pretty much have to
duplicate all your environments do I
like the old application running in the
New York occasion running with the
migration stuff and also the support
tools that you might have so this is
what the ones that we were using also
need migration so maven Jenkins sonar
others so at the time we were using
maven too and we have to make my own
free all the drinking scripts that you
have needs to be updated because the
deployers are going to be different so
you pretty much have to duplicate
everything which it's like a very big
task
now
after we have this vision then we start
we can start walking down the path so we
started like giving into a black hole
that we didn't know exactly what we
would expect now we have a little big
little idea on what we can perform so we
can start like seeing some light and
that can illuminate our path you can
start walking down that path so let's
see what we can do there we have
something I like to call the pendency
chaos especially because sometimes you
have code that's tied to the plication
server so who's here is using code
that's tied to the plication serve
itself I have one person to two three
four okay I feel for you so the rest of
the after of the audience that's not
using well then unfortunately in my case
we were using some coded to start of the
caching server so that overcomplicated
things a little bit we were using some
stuff that was tight twat per night some
other stuff that were using from Jay was
for that was called a gb free extensions
that's not available while fly anymore
so we kinda need to rewrite those little
bits first before before starting doing
the migration itself so my advice to you
is if you're if you have cold tied to
the caching server first thing you have
to do is we have to remove that cold and
try to use only the standard Java EE
specifications implementation because
that will make your migration much
easier since then you actually can even
choose the application server you want
and not be so much ties to the one
specific version of the server
also some of the stuff they're also we
have we have a lot of in-house code that
we develop to surprise Java e5
limitations so who's using in-house code
to do this kind of stuff as well ok I
have like five six seven people yeah so
this is also something that you probably
have to to look for I'm going to give
you a few examples as well so let's see
if you guys recognize this so for
Charlie five usually have JJ bapi
dependency persistence JT a JSP API
servlet and then if you're using any
kind of the server jars you have
something for jboss jboss annotations
hibernate hibernate jboss colman's
whatever so this is what I called the
pendency cows because I mean you're here
i'm using maven not sure maybe other
diffuse are using enter gravel but our
palm files were like huge of course who
has like huge palm files on their
project pretty much all of you and we
want to simplify that right so one of
the things that's cool about java ee 7
is that you can get rid of all of this
and you can just use one char to rule of
them which is java ee 7 api jar and you
don't have to worry about any other
specific implementation just use this
one and refrain yourself to use any of
the other jars or other dependencies
so this is kinda to summarize a little
bit of this this was some of the
dependence updates that we made so we
changed my even 22 free that was not
very hard I'd like some some minor
issues there especially with the parent
definitions or the pronunciation issues
that you have but mostly it will work
fine then of course shall we 57 we also
were using spring too and we migrated to
four also using some cash provider llega
cash and we also migrated to version 2
and then get from one to two as well and
pretty much that's why I advise you to
you guys to do change your dependencies
on your pump files of course III then I
didn't mentioned this yet but depending
on the control versioning system that
you're using of course to always leaves
on a branch so you can try out and play
with it and she tried to compile it
change of course the JDK version and see
the project at least compiles and try to
fix the compile errors first yes
of course
okay of course so that's a very good
question let me just repeatedly for
Jonas all the others career so how do I
pick the dependency that's the lightest
or
what if this dependency of other plans
with other versions is that correct okay
so for the moment one that was not very
hard it was actually the lightest one
from Java EE 25 up 25 27 that's also a
no-brainer there now regarding regarding
spring we what what we what we did there
and the other ones as well is we try
them out so we started with the lightest
one to see if he actually has everything
that we need and if not we either go for
lettuce for oldest one to see if they
have the all the bug fixes in if it
actually works and if he doesn't we
start going all the way backwards so let
me ask also give you another example of
i think i have it on the side to the
front is that we actually started we
were using well slide eight dot one
because that was the lightest one that
we had at the time but actually has some
bugs so we actually had to wait for 82
to be to be able to finish it up so this
kind of how do you pick dependencies i
usually try to always go by the lightest
one and then i try to like move
backwards if that's possible and it's
not then i try to reach for the
dependent for the vendors to see do you
have any version available that he/she
that i have or report it to the team to
see if they can find some some some
solution
I mean it's kind of like try and trial
and error here does that answer your
question okay thank you so much so
regarding also this dependence
resolution so my advice to you is always
try to keep with the standards which are
not going to be easier to for you to
migrate only introduce additional
libraries to your project is absolutely
necessary so that this will mean that
you're gonna have like a pump vouches
only a couple of dependencies and when
you start introducing more and more and
more more complicated it's going to be
to migrate in the future or to manage
that even when your current project so
start with java ee 7 api dependency then
just add only just to the necessary
because then when javi eight javi 9ja
v10 comes out it's going to be much
easier to my grave right so just going
to go to that dependence in change eight
seven to eight eight to nine and so on
then one of my personal favorites the
class loading hell so let me let me ask
you a couple of questions whoever
haven't seen the classnotfoundexception
okay and no class they found error not
just a couple in class cast exception
okay couple more and and in jboss dispar
like a more specific jboss problem we
have what i call the dreaded unified
class loader for the apps so
one of the problems when you're doing
this kind of migrations is dependable
specially because of how the class
loaders evolved on the application
servers you might run into all of these
at once only few of them it depends i
cannot really give you a recipe what i
can i can try to to give you is so
usually you get classnotfoundexception
when of course you cannot find the class
and that might mean because maybe when
you change dependencies are in your palm
files the new versions of the
dependencies are not including something
that they were including before and now
you have plus missing that you're using
on your code you're not seeing so one
useful thing is you can use something
called the maven dependency plugin so
you can list the dependency that you
have and you can actually do that on
your role project and the new one and
see which jars are including one and the
other to see if something is missing
have the know plus they've found a
classcastexception so these are my
personal favorites as well because these
specially happens when i'm not exactly
sure if other application servers are
using something like unified class
loader but unified gosselin on jboss
means that actually all the ER packaging
are loaded in one single class loader
and have visibility to all the classes
so when you actually migrate and of
course we got into the specs each
application should have it's a single
class loader so they don't they're not
able to see each other classes
and when you try for instance to call
methods from one application to another
using a GPS or something else you might
get some classcastexception because if
you guys don't know usually the class
name on the application server is the
class loader name plus a fully qualified
name so if you have appt 1 and up to
you're going to have like class folder 1
plus class X and then you have up to
with class because loader from the other
app and then when they go and try to
even if it's the same classes classes
are different you're going to get these
really weird classcastexception so it's
kind of like a really really big plane
understanding fix these problems so what
I've asked you is yet to look into the
maven dependency plugging do and
analyzed with the plug-in I have
analyzed goal you have a tree goal then
you have to look into application server
sometimes application servers even pack
dependencies are going to interfere with
the dependency two are they have on your
project so what advice to you as well is
try to see what's on the applications
that were ready remove them from your
project use the stuff to turn on the
server itself and then you have to
update all your app to to do that so
this kind of a little bit of pain I
cannot really give you a recipe so I can
just reuse some some pointers to try to
figure this out so pretty much this
summer eyes a little bit for I'm being
mentioned to you so since jboss 4 12 5
they did change a lot the the library
they have on the server so that's also
true for glassfish weblogic and
websphere this clash with the dependency
to where they have on your project and
sometimes you need to redefine them
sometimes we write your code as well now
other things that now with Java 7 I
think that you can also work on is
simplify your packaging so who's here
using er files a lot of them so one of
the things we also try to do was
simplified the deployment a little bit
and change their files to war files so
before we were using air files because
we 25h abs or persistence this was not
supportive or more files on Java five
but now it is so instead of having like
a more complicated deployment descriptor
which with a with a year file which just
packs Wars and then jars and then a lot
of other crap in there let's use a more
simple approach and just use a word file
which is now supports persistence and in
jammies and pretty much everything the
travelling can give you and pretty much
covers all the apps that we freely I
need to do present here using SAR or RAR
files okay one person to person yeah our
liberals are using this so these are
very old archives
that people were using at that time so I
also recommend you to move this to war
because will be much simple as well to
manage and then migrate in the future
for new versions as well and I'm not
sure this day in the future might be
discontinued or so
sorry sir Oh forint a v6 yeah so javi
five was like the first version and that
introduced annotations and other stuff
and then we were able to use servlet
that CD I wasn't there I yeah so 24 for
the wharf I didn't have much choice on
javi five so that's why I kept two came
with some interesting ways to inject
some stuff on I found unserved for
instance you couldn't even use the HIV
and rotation if you wanted to inject
njbia notation on on a servlet and you
really have to have the two jar as a
module or an ejb module an application
XML on the air foul if you want to use a
gps and and persistence but now you can
use it one more file and that's a bell
from java 6 so if you're moving for five
to seven you already can use these as
well
so we pretty much went from this dark
path and we start what I call seeing
something in the end of our tail and
start seeing some good news in the end
so when we have all these fixes then we
can start actually working on our on the
on the cool stuff so over our I like for
you to introduce you is what i call the
easy-to-use goodies from java ee 7 some
stuff that you can pretty much use right
off the outer bat on your project it's
going to simplify them right away so
there are other things that you can use
it's probably going to take more time
but these are kind of kind of like quick
wins that you can use right away when
you're doing migration is going to take
you much time and going to improve your
code very very easily so let's look into
some some of them this is some of the
code that we actually had on your on our
application can can you guys read it
okay cool so we were using this code to
be able to get the local beans or the
local IJ between from initial context
and be able to inject it in anywhere
from from the app as i was mentioning
for instance heb annotations were not
available and serve lips or pretty much
all of the job environment there were
only you can only inject HIV is another
AJ bees I think probably Killeen Texas
identity listeners as well and
interceptors I don't remember exactly
now so we pretty much have to come to
this creative way to do it and
you can pretty much replace all of these
with using TV I inject pretty cool huh
all right okay and also use that JV give
me either depending on the server but
pretty much you can use inject know when
you're writing a setlist green and this
also for for stressful as well but i use
the status example here it was a pain
because you will have to view well you
put the stateless annotation to say the
stateless it's fine but you also have
javi five we always had to put an
interface there and if you have like a
big class you have to put like an
interface like 200 methods well that's
not really a good thing because a class
with 200 matrices an athlete's very big
you have to split out but sometimes not
like these really big interfaces that we
have to maintain for nothing because you
sometimes you only want to stateless
beans to like do local calls on your app
and you have to always add an interface
and then put the local annotation to
define your interface which was a pain
so starting in java 6 and all seven as
well you can pretty much replace these
with this so once again we are removing
cold so removing cold is not bad it's
actually good and these are some
something very easy for you to do can
even do it as a refactor on your IV or a
fine and replace
even if you have like 200 or 300 beings
it's very easy to do and it's going to
be less cold and easier to understand so
this is a prodigious not like the name
is not very good for you guys to clearly
see what this is but you could play
still this is a singleton right when we
have this method called get instance and
check for an all the static
variable and start the newest start a
new a new constructor default to have
only one instance on the server so
that's pretty much how you did
Singleton's on Java 5 pro there are some
different flavors how to write these
goals probably has a couple of bucks
because it's not synchronized doesn't
matter anyway since Java 7 now you can
replace all of this by using the single
turn out the annotation what cool huh so
once again we're removing codes and
we're making your core or application
much more amenable and much more
enjoyable to read so it's going to be
something like this pretty cool huh like
from here
sorry yeah yeah yeah actually I'm III
think so I'm sorry I don't actually the
grammar probably is right here that's
why I probably had the trees i I'm sorry
I don't really remember that moment but
yeah I think it's right told a couple of
other examples so this is something that
not very familiar actually probably
never seen this before because it's a
hen house cause that I develop some beer
is actually called sequel it's called
like Cortez foreign language it's my
name because I know better right and I
wanted to make my own JP I criteria ipi
instead using the one from a brunette
because i didn't want to be locked into
a vendor so i wrote things java if i
didn't have criteria ipi a critic ipi
yet i wrote my own and of course that's
also including legacy code it's a pain
to migrate so this is kind of like what
I have I like create something called
optical like fulfilled criteria and feel
the don't even remember them now field
search or something like that and then
you can just call these methods and pass
the criteria spice to search and equal
just generate the the query to perform
of course after after a while only
meaning you how to write this and
maintain it so it's probably a problem
that some of you might have but since
now we can also on java 6 as well you
can is not going to be much more simple
but this is standard we can use the JP I
a criteria API and i can rewrite that
code into this so it's a little bit more
but at least use a standard code and i
can remove the i'm going to be going to
be a little bit staff they're going to
going to be rewriting that a little a
little more but still at least is better
for my colleagues because they now can
find documentation online
so also in Java file you're not you were
not able to invoke stored procedures so
you usually have to do it like with a
creator native query which was also a
pain so now you can just use the and
this is from javi seven not six you can
use the annotation name stored
procedures I actually didn't put all the
code here because we'll be a little bit
more painful because there are no
textures going to not be more simple
likely it's going to be more standard
you have more annotations that we have
to use for the parameters themselves but
at least it's more easy to use stored
procedures now and some of the well we
have other features of course but these
are the ones that I found the most
interesting for you to start using it
right away who here you stored
procedures yeah five six persons yeah
and this is also one of my personal
favorites so this is some in-house code
that I wrote to do bean validation so
that column class over there is actually
the GPA annotation that you use on the
JP entities to define a column and then
I had the max length there so I wrote
something that introspect the entity get
some excellent from the column and then
I do like a validation that rejects the
when I'm creating it or something I
reject if the value that I pass is
higher than the max Cohen size so this
is what I had to do in Java five because
I didn't have a bean validation so now I
can just delete all of these goals and I
can just replace it with something like
this I can just put not know and Max on
the property field of the entity self
and I'm fine pretty cool huh so this is
another example of like quick wins that
you can do i'm not sure if you if you're
using any in house called library to do
the validation refusing any other dollar
berries there's anyone using something
like this no how do you guys use
validations then on Johnny Five No
xml oh you okay xml it's not that's an
eternity of course and then hopefully we
get to the end of our journey and find
these little shining unicorn that we all
love and I want to tell you why I think
it was worth it for us to do the
migration especially because we move
removed cold and as you can see removing
code is not a bad thing it's a good
thing because it will make your code
more simple and easier to read and also
when you have much more code more
there's more possibilities to introduce
bugs right so it's kind of like the law
of two great numbers more than the more
people you have the more chances trap
buds you have let's go do you have less
chance to have bugs and with all of
these new features and you have much
more so i can give you a few examples so
the new JMS api is also more simple to
use you have a lot of other stuff that
you use from CBI there I didn't show
here you have like a huge amount of
talks that tell you how to use them that
you can start using on your app batch as
well I'm going to well note I don't have
any code here but actually since we're
using spring batch who's using spring
batch okay a couple so since the java j
batch is very similar to spring batch
like the migration is very
straightforward as well so you're going
to work that one out later
but the main point here is that our code
now is growing into a more slower pace
so we actually doing the same features
but collecting less code which is great
and of course that makes your
maintenance easier to perform either now
or in the future and of course new clean
members had arrived they have less code
to read so it's easier for them to
understand as well you also get
productivity games so let's start with
some really cool questions who here has
a deployed time of 3 minutes one person
four minutes five one six seven more
than ten most of you more than 15 or
between 10 and 15 okay half an hour ok
so it's painful that when you have when
you're doing deep boys we have to wait
like 10 or 15 minutes or even seven or
even five right it's painful so our
deployed time with this app was five
minutes and after we do the migration we
cut down to one minute only of course
the servers are also smarter now so
usually they only deploy the app and
don't start all the service right away
they only start them when you actually
request them so we you can start taking
advantage of the features of these
servers but of course is going to be a
very good productivity game especially
if you have a big team and you have
everyone deploying and taking ten
minutes just do the math you're also
going to take advantage of performance
of JVM so we were able to especially on
the batch processing because we have a
lot of that we were able to
measure performance increase from ten to
twenty five percent just by changing the
jdk version without changing any code at
all so that's also something that you're
going to yes sir jdk 8 so we started
with seven but since we started in 2003
and JDK 8 was not out yet but since we
took a little longer to do it then we
actually use a dedicated straight off
the back so these are numbers for JK 8
i'm not sure about jdk 7 i think it's
going to be very similar as well but
probably a little bit less but still you
can measure on your own if you might
have a little less a little beef a
little a little more depending on what
you're doing with the app so this is can
actually be seen much better when you
have very high intensive applications if
you're just doing like a very small
application with just like that web
users probably not going to see much but
just try and down to measure yourself
and see and you can actually come to me
and say / burrito I follow your advice
my great name now we are twenty-five
percent faster now be happy we were
already using 64-bit on jdk six so we
kept the secret for weeks as well we
didn't we didn't do any measuring about
32 vs 64 we probably could have but we
intend much time yes so as I say we
started on 2014 and we ended up two
weeks ago but I mean it's art its art I
can give you what we took but it's ours
for me say how much time is going to
take to you because each case is one
case you also had a small team we were
sometimes we had to stop or developments
because have features to develop and
deliver to the customer some other time
he had to wait for a new version of well
fly to get out to fix some of the folks
we were having so we have a couple of
bucks relating with authentication that
we're not working one of the versions
and we had to wait for the new version
to fix those bugs so all these apps as
time so I cannot really give you what's
good what do you what you're going to
take but at least I can give you the
experience that I have and I'll sorry
okay yes I have them are right here and
I'll show you some and of course you can
have all the developers happen you
wanted to now come to work on your king
or we will all this new technology and
you can start doing all this crazy stuff
like talk or micro services that now are
like the new buzzwords and everyone
loves so we cannot say that we can do
doctor and can do micro services and can
have like very lightweight stuff so it
that's cool enough and then actually
development want to keep on your team
and they're not going to go out so yeah
so we started down 2014 and finished in
October 25 it was very fun because
actually I we make the production
release two weeks ago or three weeks ago
and of course we also have not exactly
classnotfoundexception o'clock it was
like let me tell you this story because
it's fun
so for you guys to have understanding of
kind of funds that you might have so I
didn't come to the bottom of this yet
but as far as I understood jdk and the
operation system when you do like the
list classes from the file directory so
this is like class loading stuff the
order of the classes that when you get
them from the file system might not
always be the same so and in our case we
were because we were fixing some bug and
some of the jars that we have we were
having a duplicate class that we
implemented so we thought this jar that
we were using actually was from great we
have it a version of her own we were
overriding the same class name using
exactly the same package and same class
name so on the light on the older
versions of the JDK you didn't have that
problem so our class was loading always
first than the actual library class and
when we do it in production one of the
nodes we're actually doing the opposite
so it was loading the class from the
library first and not our own class and
then we we got to the conclusion that it
was how the JVM was listening the
classes from the file system so it was a
very fun problem to debug specially when
we were when you're doing the production
release so something that's going to
take like one hour to ten it was funny
enough so the solution that we had was
we pick up the jar from the original
library and remove the duplicated class
so we were sure that our class was the
only one on the server so it can
actually be load correctly but the fun
part this was only operating one of the
nodes so we
you really understand what was really
the issue there yet but i know thats
related with how the jvm least the
classes from the file system so some
lessons learned some of the setbacks is
we underestimate the job a little bit
especially because you have to as I say
here you had to duplicate all the
environments we have all the all the
servers so that takes some time then you
might think going to be easy but then
you start seeing oh we forgot about this
code over here that's type to the server
this server oh now we have this
dependence it doesn't work out with this
one so it's going to sometimes you get
into like this labyrinth that a little
bit hard to navigate but we were able to
do it so we have the little setbacks
over there and we probably end up using
twice or three times more time that we
originally estimated but I mean this is
not easy to estimate it's not like
something like say I'm going to do a
screen over here it's going to have a
table and only so it's not like some
straightforward feature yes sir
ok
priorities
okay so
okay so the question is how do I deal
with the funding to this kind of project
right so as I say I didn't have any
leadership actually so i have to like
come and present a proposal to our
customers say we have we have we are
using this infrastructure we're using
these technologies so we here is a
proposal to migrate all of this and some
of the arguments have used were
something wrong long lines like this so
we're using jdk six end of life so we
could see people using but you're not
going to be able to get security patches
anymore because the server running on
doesn't support jdk 7 or 8 so this kind
of like a very big argument especially
if you're using if you're talking about
banking and insurance sectors everyone's
very worried about security we hold
these days so if you tell them you're
not going to get any security patches
anymore it's not and you're not tricking
them them it it's actually the truth
we're not so this is DS jdk version not
supported on this server so there is no
way we can do this I mean we can rewrite
the server to support but proj is going
to be the same to my grave we can also
say to them with wasting much more money
in training new people every day because
people are quitting because they don't
like to work with this technology so
that that's another thing that you can
use to convince them and you can
convince them saying we have all these
new features that it's going to be
easier to develop so you're going to
take less time to develop these new
features by using the new specifications
instead of being locked in the old
version we're going to take much more
time going to waste much more money so
when you do the math you're going to see
that's easier or at least more less
expensive in the long run to do this
then just keeping on the same on the
same version give me a sec how much time
do they have are we done okay so we are
done one minute
okay so just to finish up vendors are
moving solid Java 7 we have a couple of
now we will walk with 15 bucks with the
mixer that multiple times and we didn't
have enough confidence in our test so
that's also why it takes a little more
time we jump straight for java java 8
we've ready to face the new Jerry
versions and I think now it's much
easier to upgrade to new versions and
you can keep inside the code using JMS
batch achillion to do testing adopt new
specifications like WebSockets to do
some cool stuff pushing stuff to the
client right away and that pretty much
is so thank you so much for being here
they for it in the morning thank you so
much for attending if you have any
questions I'll be around and I be glad
to answer your questions outside the
room thank you so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>