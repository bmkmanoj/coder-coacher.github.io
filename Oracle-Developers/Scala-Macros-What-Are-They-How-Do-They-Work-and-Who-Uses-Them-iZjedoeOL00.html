<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scala Macros: What Are They, How Do They Work, and Who Uses Them? | Coder Coacher - Coaching Coders</title><meta content="Scala Macros: What Are They, How Do They Work, and Who Uses Them? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Scala Macros: What Are They, How Do They Work, and Who Uses Them?</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iZjedoeOL00" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">euskara my hosts have access to the SD
the ASD is represented as a family of
case classes so each scholar construct
has a a corresponding case class which
we can inspect manipulate which we can
inspect existing a sts pass to the
microwave so that's the code argument
that is passed to the macro and we can
commit can generate basing on that other
asds which are the result of the my
friend which will take place on the
macro invocation in the compiled code
and so Skylar Marcos has have access to
some AP ice the compiler API Center the
reflection ap is the reflection API is a
different API that the Java reflection
it's more powerful it basically you can
inspect all of the STS of the not only
of what's being passed but also of your
environment and if the East is not
available you can still get like symbols
which describe and all of the
information can get from from reflection
and a very important part is that it is
type safe so whatever code we generate
is then being checked by a scholar a
compiler again if it is actually types
right and if it's if it complies
correctly so it's not possible to
generate a code that doesn't compile
that that isn't types and so Scylla
isn't the first language to have a
macros and like probably most of us had
an episode with C or C++ or still have
and so ya see past us they had SI like a
dedicated you can say a dedicated
language for writing macros right the
defines which not only constants but you
can also write kind of functions with
the defines a lisp
it takes the idea to the extreme and
Lisp encode this data right code is just
a list of something so you can
manipulate it is the same way you
manipulate data a similarly in scheme
and enclosure closed road is like can do
most of things list can do however an
important note here is that even the
list outsource were warned you not to
overuse macros and if possible if it's
possible to use a normal function if
it's possible to is a normal function
then use a normal function and because
generally when you use a macro it's a
bit harder to reason about the code and
the results so i could have to be it's
not like a tool for everything only for
some specialized in areas and so why
adds a macros to scala in the first
place so this like a scholar already has
quite a lot of features it's not really
a ling language and i don't think
anybody would describe it as such but so
there's another of compelling reasons to
actually add macros so and the first
reason is to provide a deeper embedding
of dss so either of internal dsl's or
external research so when you're have
you can take a string and kind of
compiler to generate code waiting on the
string on the string you can provide
nice api's for embedded sdss by a
passing encode and manipulating it at
compile time in the long run a marcos a
can replace some of the most specialized
is color compiler features and so like a
principal lazy valves right it is kind
of a compile-time transformation right
there's some code generated to actually
make the value later right so it's kind
of a macro and also scala marcos a can
be used to replace most of runtime
reflection use cases and that has a
number of benefits it's typesafe so
whatever compile-time reflection you do
is being checked by the compiler so this
you guys you get much less possibilities
of actually getting a reflection really
related exceptions at runtime and you
can still inspect the code right using
reflection and ok stir like reactions
tomatoes were mixed and some people love
it some people hate it they're very
opinionated so yeah and we see how you
end up after the talk and and finally
the mandatory about me slide it does so
let you know what kind of experience I
had with scholar so I've i'm the
co-founder and the software engineer is
so formal which is a software house in
poland we do scholar consulting and
scholar development we are types of
types of consulting partner we do all
kinds of software for clients from the
US mainly but also Australia South
Africa and so yes I'm I'm coding as
caliph like three years now a full-time
and before that as a hobby and i have a
blog i invite you to visit it a number
of things about scala but not only
hopefully interesting i also write some
open source projects origin i'm the
original author of vibrant and verse
which is an entity auditing entity
auditing library and also a couple of
projects in Skyrim acquire users macros
and if we will make it we see how it
works in action and a couple of others
so yeah that's it and if you have any
questions to try out the talk like
something's not clear or anything you
notice us ok so there's a couple types
of macros that we could have a
in Scala the first type is was
introduced in Scala 210 so it's like
almost years ago and it still has this
to have an experimental status and but
they made it to talk to 11 and they will
be present in 212 as well because to 12
though will the only changes like the
major changes will be that it will
require Java heat so there will be no
like language changes anything like that
and yeah so we will take a look at how
to actually write a deaf macro so this
macro looks like a method invocation but
it is actually Dustin transformation at
compile time hence metric def is the way
to define a method in sky so we will
write a macro a for the bugging and I
don't really often use a debugger the
most effective way for me to and to the
bucket programmers use print signed
statements and it's run it unit earth or
something like that and i'm not sure if
it's the best place that's what i use so
we will write them a macro which takes
some code and transform that into a a
print line which first print out the
string representation of that code and
then divide you right so like often when
when we do the print line the bugging we
write x equals and value of x price so
he will have it automatically hopefully
so that's like the idea from fritz it's
clear yeah so we have to transform the
debate on to a print line at compile
time okay so let's let's try how this
works
now as idea okay okay so we have a heavy
project ready here and so first thing
let's take a look at the build fight and
I want to know it always okay so it's
like a fairly standard SBT project right
by using scholar 211 nothing very fancy
here hey what is worth noting is that we
need we need actually to sub-projects
right we need one projects one on a
project well we will write the macro and
another where we will use it so test it
right the reason why we need two
projects is that because Mike Ross I run
at compile time right before we compile
code using a macro the macro must be
already compiled itself so you need one
project where we write the mark when
that they will get compiled and then
before we use it it needs to be
comprised right so we need a separate
projects why we will use right so we
have one project for writing the macros
and one factory using them and the usage
project of course depends on the
microphone okay and another thing that
we need to it here is a minute access to
the compiler and the STA guys so we add
a dependency on the road on the reflect
library in the same version as the
skylabbers right okay so we are set up
and that will be a couple of steps and
that we will throw it will develop our
and away the back back row so the first
step is very easy way we just want to
have a hello world micro right which
will transform the hello method
invocation to a print on hello world at
compile time okay so that's like we we
could do it with a normal method will go
with a macro you know just for
educational purposes and so yeah so
that's like that's how we want to use
our macro right so I have like the
skeleton
I do the implementation is not yet
they're so so that's that's how we use
the micro okay and that's why we
actually write them right this step on
usage is in the usage and sub-project
the step one macro is in democracy
sub-project okay so there's a couple of
things here to note first of all we need
to do an import to enable the macros
feature like it's an experimental
feature so we have to tell Scala let me
know what we are doing we will write the
back okay otherwise you will get a
compile timer is saying that you have to
editing mode and and then we have some
imports right so here's our migrated it
looks like a normal method on the
outside right and that's what we invoke
in our usage and however then we specify
that it's actually macro and the
implementation is over here right hello
ample this our implementation so the
implementation needs to have a specific
form first of all the first argument
list must consist of a context a single
parameter context so this like how the
invocation context of the macro the
second parameter list must mirror the
parameter list of the a method over here
right so in this case both are empty it
will get when facility finally the
results type a must mirror the result
type of the macro right so here we are
returning unit here we are not returning
unit we are returning an expression of
type unit an expression is an abstract
syntax tree with the type right so the
macro doesn't really return if a value
of type unit it needs to return an AST a
code whose type is unit in that case
okay so that's funny what we need to
return and knowledge of course a great
implementation which wouldn't work so
yeah let's try the writing something so
the first thing we always need to do is
import the universe so
in the universe all the ASD classes all
the chaos of describing code our path
dependent types and they live in the
universe right so just to gain access to
the STS and told the method structure
right Mike Ross minute and posit the
universe so that's something you don't
need to do and okay so now we can
actually write the macro so we need to
we want to generate code which prints
hello world right so we could construct
the case classes ended three by hand it
wouldn't be that easy there is something
there's a method which actually helps us
to do that and it's called Rafe I it
takes a block of code and turns it into
an abstract syntax tree so we will write
Phi print line hello what okay so what
does we specify a block of code so it's
like normal Scala code and Ray if I
takes a block of code and turns and
turns it in plain abstract syntax tree
okay so in fact Rafe is a micro for
writing macros okay what can it be
easier okay now we can actually run an
hour code so let me switch to SB teen
and we start up eventually project usage
right and now we run our main class so
that we can see the completion is step
one is right we run that and hopefully
we see not a computational but yeah we
can see how about right so that's that's
good now you know just to get you
convinced that it's actually happening
and happening at a compile-time we can
do two things so the first thing we can
use print on the bagging to see that
this code is actually a invoked at
compile time so let's add a
so what i'm doing here is i'm just
invoking print line in the macro body
right so it's not going to be
transformed into anything is just called
its run during compilation right the
print sign over here is being
transformed is naasty and that will be
just involved during completion right so
if we now go back and we just will write
compile we get the compiling message
right over here and if you run it again
right it's already compiled so we just
get the hell out okay finally we can
take a look at the white coat with a
java p usage target scholar 211 classes
come software move step 1 usage delayed
in it body class okay so that's like
that's the bytecode of our usage side
rack right and what we can see here is
that we have a print line somewhere here
put food 11 and Wes 11 we should see
Howard here no we don't and okay maybe
something changed in Java p since last I
tried anyway there is no invocation of
our step 1 dot hello right so this got
removed and a I was convinced that was
hello maybe I took the wrong class
anyway there is no invocation of step 1
dot hello here right so the invocation
of the macro got removed and instead a
instead we get a system out print line
with the right class step 1 users
delayed in it the body anyway I'll take
a look like okay so okay so we have our
first step now let's take let's make
something more complicated so now we
will write a HelloWorld a replacement
okay and so we want to have a macro
which takes a parameter and transforms
bed into a print line with that
parameter okay so a bit more complicated
than the last in case so we go to the
implementation again right we have the
same future import again we have we have
our method which looks like any other
method this time it takes a parameter
and it is a macro right so this time our
micro implementation and takes a second
parameter list which mirrors the
parameter list of our method and here we
get the parameter which is the abstract
syntax tree representing the code let's
pass the parameter okay so the value of
the parameter is it's the code that we
pass in right so it would be like an
abstract syntax tree representing that
code
which is a literal string and okay so
now we want to generate another one to
generate print line with that parameter
ok so again what we have to do is we
have to import the universe and then we
have to make me do the like kind of
thing right we read by some code we do a
print line so now we want to print line
a parameter right so you could just do
printing param but it's not quite
correct maybe we can try compiling that
and we will get an error right we get an
error have you forgotten to your splice
and we have so why is that wrong so here
we are trying to create an abstract
syntax tree for code which print lines
the variable power but like in this code
the param there is no variable param
right it's in like in another world so
the power arm comes from the microworld
not from the code that we generate here
right ok so let's that's just the
abstract at the abstract syntax tree and
we don't really want to print the
abstract syntax tree want to print the
code the result of evaluation of the
tree right so what we have to do we have
to write totes price is nice works only
when nested in Wi-Fi and what it does it
embeds the ast represents by param into
whatever we generate with right fine
right so ray if I you know generates a
st for writing print line and then when
it sees paradox price takes the three
represented by param and puts it inside
that place ok so now we will end up with
an esper abstract syntax tree which has
the print line and in the as the
parameter we will put in that tree ok so
let's see if it actually works and now
we will run step 2 usage
and we have our front line over here
right we cannot add for example of
course something like that and you can
see that our code is generated equipment
right nets all day all done at compile
time so a in the compiled code in the
bytecode with this gets transformed to a
print line and the string right there is
nothing at runtime which would see step
2 like this this method invocation okay
so that's step 2 and finally we get to
the way we want it together step 3 right
that's the interesting part we have a
value here it's X and we want to and the
buckets value right so we want to
generate code which will print x equals
done okay the Bible so it's the the
beginnings are the same right we have a
method the parameter which is reflected
here so what we need to do it me to
import universe okay okay all right now
we have to take couple of things so
first of all we need to somehow generate
the textual representation of the code
right we have the abstract syntax tree
but we don't really want to print sign a
series of Christ classes we want to
contain a nice representation of that X
right so there's a method for that it's
called show so we will run that
alright so a param is an expression
which is a type tree an expression is a
tree and a type so we take the tree and
we use the show method which takes a
tree and provides a nice representation
of the tree as a string all right so
yeah we don't you can see where you the
type here and maybe that will be better
it's small but it returns a string
anyway yeah it is okay so now we have
added three as a string so the second
thing that we need but it's it's a
string in the macro so now we need to
generate code which represents a literal
string so that we can put it inside a
our generated code right so what we do
is we generated three by hand this time
we use some pace classes literal
constant from how do you actually know
which case access to use I will get to
in a second and we create an expression
and so the type is going to be string
and the tree is three we have just
generated okay three okay and finally we
use our old r AFI with sprint line okay
so now what we have to do so first ones
to print line the tree representing the
code so we wants to print the textual
representation of our code so we take
the expression that we have created here
right and we splice it because it's an
abstract syntax tree that was to put
inside right then we generate then we
had an equal sign and finally we splice
a the tree sir right so here we have an
expression an abstract syntax tree
containing the string representation of
the code and here we have the code
itself so that it is actually so that we
actually get divine wave so now let's
run it and see if it works before we get
any further so it will be step three
usage compiling we get what you write so
we get almost what we want because like
the internal representation of
eggs inside the compiler it is like
fully fully reference right so we got
step 3 users desktop this was a dot dot
X but i guess its toes enough to be
useful and anyway we can we can offer
example to some more advanced so we can
about y equals twenty-two and we can say
X plus y alright so it's an expression
so let's see how this works out and we
can see that now we actually get an
invocation of a plus method on X we add
this to i right and we get 32 which is
the correct value and okay so addition
works and scholar is good and okay so
now how do you actually know what's a
how how they actually know that you have
to create a literal constant and that
you have should have to use these case
classes to create a little constant
string again Prince I debugging house so
during completion we will just spit out
some messages example print 93 okay and
besides the show method which takes an
ast and provides the nice representation
there's also the show row method which
provides a which prints out the case
classes as they are okay so now we will
print line an example 3 and we will
generate the tree from ray file print
line hello all right industry okay so
what we do is we take a piece of code
right we convert it into an expression
with Wi-Fi so we generate the abstract
syntax tree we take only the three we
don't care about the type finally we
convert it to a string which is like all
the case classes involved and MP printed
out during compilation so let's see how
it looks like compile and here is our
abstract syntax tree for actually
invoking the print line right so we can
see that we apply so we apply the
methods to a it when
stance and so we apply parameters to a
method is the method is we select from
the pre def an object we select a term
9th print line and here's our parameter
list so it's a list right because it's a
list of parameters and the first
parameter is a literal constant hello
right so now we know now we can see how
at three representing a constant string
looks like and that's exactly what we
have over here right only we use our own
string not Oliver okay so that was the
hard way so that's how it works in the
background it's also an easier way to
actually write the same thing and it's
using quasi books so whaza quotes are a
bit like string interpolators only for
code okay and they also so it's I like
it's a better form of Wi-Fi they
generate code and based on the textual
representation of the code so we like
generate strings and you embed strings
in there and again and we can we can do
the same with string enjoyed in Interpol
actors so again if our users will be
here the same right again we have just
the back we can just change it for 2 12
so that you see that it's different and
yeah and then let's right let's write
the example using and interpreters
that's actually need you have the code
here okay so first of all force we
import the universe as always right we
still needs to generate
the detection of representation of our
code so we use the show or meet her
again but now instead of you know during
the rape and so on we'll use a string
interpreter so we will return an
expression of type unit and now we have
to pass in a tree we use Q which is a
the entry point for like with string an
internet with string interpolation
you'll use s here we whisk us Kwazii
code and now we can write a kind of
Scala code inside that string and it
will be converted to an AST okay so we
went print line right and now we embed a
parent rap plus equals one ok so it's a
kind of similar to splice right so
instead of splice we use the dollar
notation right because the S param
references the parameter over here rice
is exactly the same as in a string
interpolation except that we don't
interpolate strings to interpolate code
ok so here that's going to splice in the
tree that's represented by param inside
the quasi code now param wrap this just
a string right but we still can
reference it with the delimitation so a
there is like a built-in mechanism in
Kwazii quotes for a uncoating as they as
they call it certain types so that you
can put them into into a bicycles and
then I built in in unloading mechanisms
for primitive types and four strings so
well they don't have primitive site but
flag for int long bullying's and strings
which automatically convert a
a little string so like a like us a
string in the macro into the
corresponding tree right so we get that
for free and yeah so let's see if it
actually works and now it's going to be
step 4 and yeah yeah we get a very
similar result right we get the that the
x is equal to what actually it looks
nicer if you do it in a method so
because you don't get the deep prefix so
def test if we wrap it in a mess out we
just get x equals / right because it's
not a ex is not a member right right now
x is not a member field it's just a
variable right so x is like describes
the full reference to it to the value
and okay so that's that's how at the
back macro any questions baby yeah how
is the market use
you will get a compile-time error and
yeah we can try it frontline plus X X
actually exists as you although it would
fail anyways yeah not fun for you
and and that's actually this can be
tricky to trick part with micros dead if
the micro has a bug and it generates
some invalid code out of the sudden you
see that you have a compile-time error
like this and are not variable you like
what you write I don't know so that's
the tricky part about workers and okay
so for a second let's go back to the
slides yeah so there are also more time
is it action okay still something so
there are other types of micros and then
either available now as a compiler
plugin which is called macro paradise
and and you can do also kind of things
with micro paradise of course and so you
can use it you can use them into 10 and
12 so the yeah so so far we have seen
def macros so they don't look like a
method invocation and they generate code
basing on the parameters passed basing
on the enclosing method or class and
they can also implicitly lookups they're
also implicit macros which I very useful
when implementing type classes so for
example here we have a typical
implementation of a type classics
scholar we have the schäuble which is
the type class right which takes a type
parameter and provides a way to show the
type in some way depending on whatever
it it it has to do and we have a user
sides of the second here we have how we
can use our type class right then we
require an implicit value of a show
before the given type and here we when I
can example implementation of a of the
type last show before the internet right
so now the question is what if a no
implementation if I given type exist in
the implicit in the current implicit
scope and it is possible to provide a
kind of a default implementation for a
type using a marker right so we can say
that this macro
a Hui run is like the lowest a
precedence in the implicit locker so if
there are no other implicit values
magazine type available generate one by
macro and the micro you know can inspect
a can inspect the type and generate a
sensible the default basing on the shape
of of the actual class so that we can
actually have an implicit value for the
type so this implicit macros those two
micro annotations and implicit macros
are available in 2002 11 out of the box
to use micro annotations you need the
macro paradise and with micro notations
a you can generate code it micros can be
invoked or a triggered by placing an
annotation is on a class on a parameter
and so for example here we have a full
interface which has two methods and we
have a wrapper which has a delegate
right but we only implement one right
and however we can implement a delegate
macro which will automatically implement
any methods not present in not present
in our wrapper right so it will in this
case it would automatically generate
generate m2 which would delegate to
DeGraaf m2m implementation and so it's
like only one of the possibilities you
can actually one of the things you can
actually do with macro annotations and
yet so like the macro notation right is
its define as another notation you only
need to add a micro transform method and
you receive a number of adult is over
here ok so the Amity is depending on
where the macro is used it can either be
the annotated class and its companion
object or it can be the method parameter
the owner class and its companion object
and you can do a lot of things with
macro annotations you can actually
extend if they give in a class we can
add new methods you can also create
companion objects so there's quite a lot
of things you can do however you need
the compiler plugin for to make that
work
and yeah and classic quotes so apart
from what i have shown you already with
classic quotes and you can also use them
in other ways you can use them to
extract stuff so you can like pattern
match so here we have like let's in fact
the pattern match right so you can
extract you can deconstruct a tree into
the components to inspect existing Scala
code you can do pattern matching and you
can construct all kinds of scholar
constructs not only terms but also it
types case patterns and yet mushroom
patterns and yet you can construct
arbitrary complex Scala code just by
writing it down in the industry yeah so
as I said a errors a can from can be a
challenge and you can get some cryptic
error or structure using my cross and
but there's a way to provide a
user-friendly errors so we can say that
like when compiling let's say we compile
an internal durcell like a DSL in a
string in a macro to some code and we
have some errands right so we can say
that hey here's an error and UK we can
provide a nice string you know like like
a nice message to the user at the exact
position in saying what's wrong with the
code right and it will turn out as a
compile error right and now to the
second part of the demo so where I'm
actually where micros actually used and
have some time available mm-hmm
when you step into a macro well it
wouldn't find the source so I guess you
just I haven't tried actually and I
guess it would just step over because it
wouldn't be able I could put to be stuck
on the same line for a couple of steps
right because it wouldn't be the line
number annotations would be all of this
to the same line you know I guess you
don't really so you're on macros user
just shouldn't read they require
debugging i guess like it said either
one either but one or the other yeah
they wouldn't crash anything like the
tag it's kyle already has quite a lot o
gentle of generated code so complex
macro macro call the questions and you
want to step from where you enter the
macro into where it calls a function
right i never know yet yeah and
eventually it will go to that other
method right and okay so some a couple
of years edition so first it's quite go
i can show you the full run so first
this a library called Skylab leads
scalability aims at a couple of things
you just find the code so that i can
write it without a lot of errors okay so
scholar blitz it has like a new
implementation for his new
implementation for parallel libraries it
also has some macros which aim at
optimizing existing code so for example
here we have you know that's like one of
the many features of blades we have a
large list which has 10 million doubles
right from one to 10 million
and we have a very simple benchmark
method which takes a block of code and
see and it checks how long it's actually
running and so here we are benchmarking
a method which calculates the average
value in the list so we sum up the
values and we divide them by size right
and yeah and it runs in some time and we
can also write an optimized method so I
just copy that blog and that would be
our optimized nordstrom and we run both
then and all right so we have so we
import this color collection election
optimizer okay and that's going to do so
idea is very keen on optimizing the
imports as soon as I type them
and I actually have I need to have an
error in the code so that i can type in
the import anyway that's a that's a
feature and so so yeah so like the only
difference here is that using the
optimized method from scholar blades
which takes a bottle code and tries to
optimize it in a couple of ways Sonia
let's see let's see how it works it's a
little extra run the demo and see if it
actually helps in any way hopefully the
optimized version should be faster right
than the non optimized version and it's
a very unscientific benchmark I'm sure
you can do it in a better way and so
yeah so like the non optimized version
usually take some guy I'm not sure why
but the first one always is much faster
than that one's I'm sure there is an
explanation but i'm not sure i may be
some memory layer I don't know anyway
the optimized version is always faster
right you can see that hopefully and so
what's color bitch does is it takes a
block of code and try some eyes a couple
of things so it tries to do better in
lining it specializes the operators it
eliminates a boxing and optimizes
aggregate methods so like both some and
size and our aggregate methods which can
potentially a lot of boxing and unboxing
and scallop this tries to optimize that
to work on the primitive values in the
JVM and so yeah so it actually blitz may
be included in some future versions of
Sky's I said it has a new implementation
of the parallel libraries and so this
may replace the current plans at some
point yeah so let's let's collaborate
and ok not a lot of time so I will just
show you two other examples so the other
one I'm sure the complete versions and
not that much so the other 1a
is Cara I think it's colorizing
transforms a it transforms lets you
write a call you using futures in there
blocking like way which gets then
transformed into a non-blocking version
right so here we have three examples so
that's the first example right we have
two futures where we sleep for random
amount of time and we return some
results right and we take the values and
we return the song right so that's like
the so we like unpack the futures from
the actual in that they hold and we
return the result right so that's like
the normal where you will use the future
and and and it works right it's using
for comprehension to actually get the
values from the future okay so we can
write the same thing with a sink it's
over here and it will actually get
transformed at compile time to the very
similar form as as we have as the first
example right so here instead of future
so we wrap the closing in an async block
then we can use a Singh instead of
future reduction right computations in
the background but it doesn't really
matter like we could use future here as
well the that is the same but the most
important part is that we can use await
and away it takes a future of tea and
returns a tea so it looks like a
blocking operation but at compile time
this will get a transformed a series of
marks and flood maps that actually that
code will be non blocking okay so
actually like the the whole result of
the async is a future right and any
weights are transformed to two marks and
flip flops so like this alone may not be
the most compelling use case because you
can still write it with with a for
comprehension easily however once we get
to the more advanced ways of using so
for example we can have a conditional
future on which we want to you know
branch right so here
have f1 is a future Pauline right so
it's a figure of where so either try of
holes and now if in the future this will
be true you want to actually get the
value of the f2 future otherwise we want
to return a constant and now writing
that with a for comprehension would be
quite ugly ok it's way more readable to
actually use the blocking like and await
let's forget the virus and just to
convince you that it actually works
let's run it and and we get a like in
all cases like here we had 20 and 22
here at 20 and 22 642 and here it turns
out that it was the result was so the
future was true right because we got 42
as well ok so let's Caillat Singh it's a
very it's like it's a scholar module so
it's maintained by the Scala team and
finally a third example mcwire that's my
project and i use it for kind of doing
dependency injection without the
framework so and here we have a serious
of a process it's like our business
logic countered somewhere across our
application in across packages and we
are using constructors to express
dependencies right so here we have a
user finder which has a dependency of a
database access and security filter
writes out actually they so our
application to make it working it
instances of all those we need then we
need to create all the the whole of the
object graph with the right dependencies
in the right places right so an a very
effective way to do it instead of using
things like spraying or juice is to
actually do it manually when your
application starts up you know just
write it down and all the new
invocations okay but you can also
make it a bit more easy and use in my
choir to generate the new instantiation
code for you so here we see a wire is a
macro consider it isn't micro right has
micro keyword and has the implementation
does not be seen before so it takes a
class and what it does it inspects the
class it looks at what kind of
dependencies the given class has right
so for example here the user finder has
a database access so during combination
my choir will try to find an instance of
the database access class in the current
scope so the current scope is like the
enclosing class and any parents and all
the enclosing objects and if there is
exactly one if we'll use it otherwise it
will produce an error so yeah so if you
I like look at the compiled code this
will be a this will this will be
generated as new user reader status user
status reader with the appropriate
dependence okay can we can run it to see
that it actually works okay and you can
see that yeah here we are just printing
out the object graph like part of the
blue graph it's a case class so we get a
nice to string and you can see that the
classes are properly in instantiated
okay so these are three the most they
wanted to show of existing scholar
projects that use my cross that's
actually and some others as well where
are the sides oh yeah
ok so now as for the trip thing I have
some time and I'm almost finished but I
guess there's only 15 minutes to change
places so maybe it's good so I so as to
the future of Skylar my clothes there's
actually a new project by Eugene and I
pfoa is the Colts kalamita it's kind of
scam across 20 and so Skylar meta is
like a new implementation of my cross
which aims to be of course much better
than the existing one they have a more
user-friendly API so you won't need
improve the universe and they have a
better representation of the SD so there
are some like works with the part of
this tipping mutable which is of course
very ugly but this how the Scala
compiler is and however the STS kalamita
is all immutable and nicer there's much
better ide support so and right now my
clothes don't always play well with IDEs
especially if like generate vessels or
something like that right IDs have no
idea about the microbes right so they
will just provide an error actual idea
underline leg gives red coat in many
places and skaara not only when Mike
Ross is but there's one more place where
it does and yeah that will be a public
preview of scale meta soon you can trust
it in in November hey I guess there's a
conference call conference on the east
coast where they will and release that
yeah so just to sum up some potential
problems with when you can which you can
encounter when using macros they're
quite hard to write so the scalar
component internals are a bit messy
sometimes and the resulting code may be
harder to understand and to the back as
we already said okay but we can also
provide some very nice dsl's for you for
your users and
if it's used like in a limited way and
only when it really reduces boilerplate
or some awesome repeated code it can
help a lot it's usually like Marco Scoob
using library coats or not like in your
everyday business code and so they I
useful value but you had to look up yeah
in a couple of links the tutorial that
happens through here is available on my
blog as kalamita has a website these
three projects that i mentioned and
before they all open source you can take
a look and this the source code for this
presentation is also on a good cup so
that's the last thing and oh yeah i have
stickers if you interested have two
kinds of stickers one is color times so
we are all interested in skala i guess i
hope and so we have a scholar newsletter
which goes out every week which are with
a bunch of interesting scholar links so
we have it I'm very nice the curve which
which you can perpetrate I didn't put
them up so yeah the stickers like them
just you know take them after the
presentation and and and and the second
stickers I'm out of my code try don't
have many of these left and so it's a
somewhat of our code review tool which
we have written our servant with which
we use in our company it's a very nice
store where you can not only comment
call button also live code so take a
look and oh that's that's right thanks
yes so maybe you have any questions yeah
classes like the annotation processors
today that just the full HD and you can
do what everyone well you can generate
any kind of AST you on but you cannot
like modify existing classes you can
only no no no like some what you can do
is you can like with the deaf macro you
generate code which is like putting
inside instead of the macro right so
that you don't modify anything with the
macro notations you can extend the
annotated class or the class to which
the annotate method belongs but you
cannot change any other process
expressions no no it's it's a normal
method and well it looks like a normal
method and anywhere in our method can be
the macro can be used but it's you know
it's just like a method right the user
idea you shouldn't really see a
difference it's true does return
something that usually isn't impossible
to achieve with a method
no no no it's just for the demo like
normally they are like no in and they
don't have to be case passes their case
classes because I wanted to get a nice
to string and they can be anywhere which
is spice yeah so like normally when you
do a manual dependency injection as with
my choir you know the classes they are
anywhere you want right they can be like
in different jars the only thing that
has to be like that is together and it's
like they do the wiring code so the
thing over here right so we actually put
the object graph together that needs to
be like in one place so that the
reference is see each other and you know
you usually want to have that like as
late as possible so you don't want to
generate the concrete instances to too
soon
great so thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>