<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JSF 2 3  The Community Takes Over | Coder Coacher - Coaching Coders</title><meta content="JSF 2 3  The Community Takes Over - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JSF 2 3  The Community Takes Over</b></h2><h5 class="post__date">2016-09-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Fhv-qb47PNY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello good afternoon my name is Ed Burns
and this is my colleague Quito man hello
oh right this thing
oh oh oh we were we were already there
okay good all right so this is a the jsf
2.3 the community takes over thank you
for coming today did everyone have a
good time at the keynote at the
community keynote all right good stuff
that's always the funnest part of the
sessions the silliness all right
Oracle safe harbor statement bit about
me I've been involved with
oops servlet in JSF for a long time
since one dot o and servlet
I'm sorry since one that oh and JSF and
for another one sir would frequent
International Conference speaker written
a few books and so I got involved
actually with JSF one but I wasn't on
the extra loop until JSF at one point to
I I wrote a book around I think it was
actually a JSF one one book or something
a long time ago and the site called JSF
central.com which has lots of resources
and articles about JSF a little little
out-of-date looking now but it does have
some good content on there and I also am
the host of the enterprise Java newscast
if you're into podcasts it's a place
where every month or two me and a couple
other guys will often have someone on
maybe perhaps a guest and talk about all
things related to java enterprise
development etc etc and I also do
training and consulting ok here's our
plan for you today
I appreciate even chosen to invest your
time here rather than all the other
great sessions that we have at JavaOne
so I really appreciate that I'll take a
look at the big picture and how JSF fits
into that big picture then a brief
historical perspective on JSF and its
long ride and then the heart of the
presentation the big-ticket new features
that were bringing into JSF 2.3 and when
I say me I mean you the community has
really stepped up and done a lot of
awesome work in this
and you're gonna see it in several
different domains from the outside
websites and technologies they're
building on top of it down to the core
specification itself which is being
driven by the community as well first
off though I wanted to talk about
primefaces primefaces wins the Duke
Choice Award last night Akito accepting
the award as the yeah definitely I'd
like to just take a moment to thank at
chat I and his team at prime tech for
creating such a great open source
product and I've been very pleased to be
part of it
over the last several years and I think
it's well deserved so hats off to chat I
and prime Tech and primefaces
so just in case not everyone has already
seen this quino's got a big primefaces
demo already right or do we not do that
one alright so while he's getting that
up there prime faces is a good example
of a community technology and one of the
reasons why I really like them is that
they took a lot of the complexity we
added to the spec in terms of
extensibility and plug-in points and
really leveraged it for what it was good
for it's because it's possible to use
any technology to just get the job done
scratch the surface use the little bits
of it that you need and you know coast
along fine there's nothing wrong with
using technologies in that way but we
put a lot of effort and thought into
making JSF very extensible and pluggable
all the different pieces that can be
replaced and decorated and subclass and
all that kind of great low stuff that we
try to do and jatai really took a good
look and said ok this is this is a
renderer this is a tag handler this is a
component this is a converter a
validator you know all of the different
parts of the lifecycle and really did
use it to the full extent which is
different from a lot of other component
libraries a lot of other component
libraries were like well we are our
component vendor
we have this kind of component and this
kind of component we're just gonna have
JSF is another one of our components and
in that case they just kind of you know
use the top level of the features rather
than diving in and really understanding
it and I think you know the thing that's
key here is that you know over the years
primefaces actually pushed JSF a lot of
the features that primefaces has had
over the years we're now even some of
them now we're still rolling into JSF
2.3 so it's always done a great job of
really giving you everything you need to
build a JSF application and this is just
as the primary showcase which is always
a great to show and essentially you know
at its core it's still just has lots of
different components right you know your
normal input controls and and but what's
cool is that even for the input controls
they all integrate with all the themes
that primefaces has and they all have a
built in Ajax support and then there is
still probably my favorite is the data
table which is definitely the best data
table I've ever worked with you know has
support for all sorts of things like
lazy loading you know sorting filtering
etc and there's also lots of you know
other sort of interesting components so
you know you build an application and so
you get some strange requirement or a
specific requirement you're like man how
the hell am I going to do that well
there's probably a JSF component and
maybe a primefaces component that does
it for you so this is a diagram right so
this one's useful you know you have your
data model residing in Java and you'd
like to present a graphical view on it
so can you show the the code for that
one yeah
so you see how he's getting the data
from the model right so everything comes
from this model right and the model is
essentially just an interface or
basically you create an implementation
of his diagram model and just fill it up
to POTUS and you've then got a lovely
you know look and feel and some of these
the mind map is similar basically going
here you can navigate through it and you
know the nodes are actually something
you can move around which is nice and
again the model for this is all the same
you know it's basically using actually
on the you know of course on the
client-side using canvas and html5 and
things like that but in terms of the the
way you use it you just specify an
element and give some Ajax event
listeners and you basically just have to
populate a node right so you're building
a tree so this is like a lot of what
primefaces has done and you know there's
just so many components there's over 100
and I also want to point out something
else which is something like the
client-side validation framework there's
something JSF still does not support and
basically the idea you know you can do
validation
right client-side thank you and even
though it does a client-side it uses
ordinary JSF validation or ordinary bean
validation right but the point is client
side is not sufficient alone you always
have to do service exactly so in this
scenario you basically can go ahead and
do your your normal bean validation
constraints this is a bean validation
constraint and primefaces will actually
automatically do that same thing on a
client side and you may have to do some
additional JavaScript work to integrate
the client-side validation with the
annotation you've created but there's a
way to do it and you get validation on
both levels so this is one of that one
of the innovations that they've done and
we'll be talking a little more about
being validation later in the context of
one of the new features in JSF 2.3 yeah
so what important one more thing about
primefaces they've also done a good job
of providing other add-ons so in
addition I can actually here we go to
the sort of core product they have these
themes and layouts and the themes are
great because they take advantage of a
feature we added in JSF 2.2 called
resource library contracts so I'll talk
more about that later too yeah and and
what's great about these they're
commercial but they're very inexpensive
you get like an actual real layout of
your application you know sort of giving
you an idea about ways that you can lay
it out you get little pages you get
navigation etc and then also they're all
responsive so they work well on
different devices and everything so so
in all this again sits on top of
primefaces in JSF
let's go back to the science all right
so here's the revised proposal you've
seen many times in every presentation
I've given which is now three and every
presentation every other Oracle Java EE
person that's giving the different thing
here I want to show is how JSF sits at
the heart of a lot of this we are
leveraging lots of different pieces of
java EE and I'd like to just point out
that we're you know we're using servlet
we've been riding on top of several JSP
of course we're gonna be using security
potentially for some of the stuff we're
getting from Java EE eight regarding off
an open ID and you know more detail on
it later but I just wanted to show that
even though joseph has been around a
long time it is taking advantage of a
lot of the technologies that are
elsewhere in the Java platform real
quick about JSF in the cloud Java EE 6
is already in Oracle's public cloud
offering so you get JSF 2.0 if you're
using Oracle public cloud and then when
you talk about the transition from
monolith to microservices JSF can be a
part of that transition because if
you're starting with a JSF application
there's a lot of different approaches of
doing it but one approach is to take the
existing JSF that's got this in process
calls to CDI for the model layer and
perhaps consider breaking that out and
make rest calls to remote services I
think didn't you mention you had a
customer that did that so you know they
they had the jasa front end they had
some back-end services now what do we do
don't we have to call from the browser
and I'm like no you can if you want to
there's no reason that you can't make
restful calls from Java and they
aggregate them into what you send back
to the browser or what you want to do in
the browser so that's always an approach
so you don't necessarily have to rewrite
everything at once or at all necessarily
you can basically talk to back in
services from any JSF web app it just
that runs on the server and the benefit
of that is that you have fewer security
constraints and things like that to
worry about right you can talk to
wherever you want behind the firewall
but anything you can expose out to the
world you then have to worry about you
know security and things like that right
so there's a lot of advantages to
continuing to use JSF as an aggregation
layer on the server side for example
certificate management you can control
all of that rather than the browser it's
a little more complicated oh yes
during Neal's excellent talk earlier in
the week he introduced me to a new
project called join phases I done heard
of it but I thought I'd call it to your
attention here because people often
leverage spring food in cloud
environments because of its ability to
package the runtime together into a nice
executable module so spring join phases
is a way to build JSF apps into ready to
use spring boot modules and another
thing I think that's important to point
out is that JSF already runs just fine
in a cloud cloud you know it's it's a
web app it's wire you can deploy a wire
and pretty much any cloud environment
that supports Java as is and you could
also very easily throw it in a fat jar
if you have you know the right like
thing JBoss swarm or something like that
if you wanted to as well so you know
just cuz you're going in the cloud
doesn't mean you can't still use the JSF
application and just because you have an
application doesn't mean it has to have
a million microservices so I just want
to just want to point it out okay so
here's the historical perspective we
started out in 2004 the story then was
JSF is awesome it's gonna beat the pants
off of stress and fast forward to 2008
JSF is awesome but I've heard about this
Ajax thing and this Ruby on Rails thing
sure seems like it might be pretty hot
pretty hot well we took advantage of
what was going on in the world at that
time and took inspiration from rails and
added Ajax and
this is when JSF to tato came out and we
really feel like we got it right so in
fact JSF Trudeau was the last big major
revision of JSF where we added tons of
new features and greatly expanded the
component set and you know really was a
blockbuster release and I even said it
back then and I'm saying it now the plan
of record going forward since 2009 has
been we're gonna do incremental
improvements to JSF continue to add
value continue to bring in stuff from
the community that makes sense to do so
and you can see over time the role that
the community has been playing in terms
of the core development of the JSF
specification has been growing over time
so by the time we got to JSF 2.0 the
community was doing a little over half
of the hard work I'm sorry I got the
colors on a little less than a half of
the work at tipped in 2010 in 2013 we
reached released a JSF 2.2 and by that
point quite a few of the key features
were added by the expert group and the
community the html5 friendly markup
feature faces flows and resource library
contracts all of those were well
contributed by either expert group
members or taken from the community or
individual contributors in 2014 we filed
JSF 2.3 and 2015 a year ago we released
the early draft review and now here we
are in 2016 and you can see the
community is doing most of the work now
I will point out this is a specification
and the implementation the TCK is was
and probably will be managed entirely
about Oracle and contributed you know
and developed and expanded by Oracle so
that's one piece of this that is
unfortunately not as community driven as
I'd like it to be but that's how it is
and for those of you who aren't aware
the TCK is basically what validates the
especially the implementation against
the specification so it's basically a
sweeter test just to make sure that an
implementation actually implements the
spec properly as far as I can tell in my
judgment the existence of the concept of
a TCK is really the thing that separates
what we do in JCP for every other
open-source product out there I mean
open source projects are usually done by
people who have a problem that they need
to solve and they use they develop the
solution they solve it and they put it
out there you don't really find very
many open source projects where you can
get different implementations of the
thing so the TCK is the thing that key
in Abel's that here's a quick look at
the releases that we've done it's been a
very long time but very fun and very
rewarding for me and I hope for the
users as well all right we're about 15
minutes in I think now we get to the
heart of the presentation so these are
the big-ticket new features now I say a
big-ticket and I said the same thing in
2009 so this big ticket is smaller than
that big ticket the rel it's a relative
term I suppose there's a very great blog
post by Arjun times who is one of our
very active JSF community expert group
members he and dr. Schatz from safecom
which is a very useful portal for
curated mostly developer kind of content
but it really could be anything yeah but
it tends to specialize in devoted so if
if you think of Stack Overflow is like
this big pile of answers with a decent
search engine on top of it the safe is
more like a directory of things and
they're curated by page owners so all of
these are described in good detail on
this blog post here and I'll talk about
them in some detail here today better
CDI integration way more things being
injectable adding support for WebSocket
which is an important part of html5 it's
often used when you need to it's always
used its main reason for existence is
when you need to have full-day full
duplex communication between the server
and the browser and it isn't something
that most JSF apps tend to think of
because they usually go with request
response request response and and Ajax
but you're still doing a press response
with WebSocket you can move a little
more into the way of single page apps or
you can use the WebSocket to just inform
stuff that's happening in the browser
Ajax method invocation is a fun feature
that I've long wanted and they've just
went ahead and done it and it's
basically a way to in your JSF page make
a call on a server-side Java and get the
response back in a and via Ajax multi
field validation Java date/time support
could either by Josh you know here in
the audience thank you Josh and UI data
and you I repeat improvements okay now
I'm gonna publish these slides of course
on the conference website and this is
being recorded so this is a very
exhaustive list that I'll expect you to
read it all but it's showing how and
this is taken right from margins page
you know how these things are different
these different things can be injected
so JSF exposes lots of the server-side
artifacts that you need to have in a
Java EE application via CDI and they are
injectable in most cases so as I was
doing this talk I came to realize that
before we had injection we had all this
XML and so if you wanted to wire things
together you would have your spring
configure your faceless config that had
the beans section in it and you'd have
to declare all the beans just to get
things to be wired up and then you know
rod Johnson had the conversion of
control idea and dependency injection
came about and things started to be a
little easier where you could basically
let the context the usage context
determine and give you access to what
you need so basically you have what you
need when you need it and at no other
point in time and if you extrapolate
that further and down the road you get
more and more stuff that you don't need
at the time taken away and eventually
you come to a system like Amazon lambda
where you're just basically writing
functions that run in an environment
that you know there's no dependencies
except for what you need for your little
thing to get it done and I just think
it's kind of funny to connect those dots
to see where we're going and there's
another page of those results they're
there any specific ones you wanted to
talk about Quito particular but I think
it's just key to point out that um you
know JSF started out before CDI existed
yeah so that's what we had managed beans
and you could do you know these two
mount with managed beans they're still
great in the sense that they're so
simple you don't get any weird stack
traces that are hard to decipher or
anything with managed beans but there's
no proxying right no proxying
things like that but because of that
when a lot of these features were added
you know we weren't really using an
injection for everything so we've been
slowly adding more CDI to JSF over the
years and it's great to see all the work
the art is done is basically allowing
you to avoid having use it to use faces
context get current instance dot
whatever to get every single objects you
need and also I need to call out my
colleague and co speckly for JSF man for
a dream who couldn't be here this year
I'm very unfortunately just because of
travel budget issues and you know he is
very much behind all this as well I
recall I should have mentioned him at
the outside of the talk but especially
when it came to the CDI integration that
was one of the things he worked on a lot
too okay
all right here is what WebSocket
integration looks like you know what
that's an extra slide on there all right
here's what WebSocket looks like in
black and white here's what it looks
like in color
all right so there's this F colon
WebSocket tag and you can declare the
different channels you'd like to use and
you just have your on message function
there's a few other attributes you can
pass and the nice thing is the
server-side code is super simple you
don't have to declare any extra filters
or servlets it's off by default you
don't have to set a context parameter
turn it on but on the server side you
know you can have your your on the left
you have your POJO and you're injecting
the push context and this is how your
POJO can send data down to those
different channels and on the right is
just a simple website and endpoint
example and actually it's important to
point out the thing on the right is
really a specific issue with with pyaara
and GlassFish so if you're using another
server you don't even need it it just
has to do with its there's a bug file
then there's been some discussion about
ways to get rid of having the endpoint
at all it's just a just basically a
little placeholder right now right so in
terms of the actual API are only looking
at the thing on the left which is the
the push bean and injecting the push
context okay so I think it would make
sense to jump into the demos in context
all right so
okay so here I've got a button so let's
mention angel Lent hard first oh yeah
really good point so so if you want to
see any of this stuff actually running
and play with it
angel inner one heart has done all of
the work of creating an example for
every single new feature okay and this
is what we mean by community doesn't
work for Oracle there's more for any
major company he is an independent
person that's been on the expert who
have been working with JSF and he's got
examples for everything so so on github
just JSF two three examples you can find
it the only change I had to meet to get
it to run was to change the maven
artifact for JSF and the JSF are 2.3 RI
is actually in maven central so look at
my palm here yeah which is awesome I'm
gonna think of it yeah the this is all
you have to do basically the address of
2.3 to your application of course then
you have to deal with the app server and
making sure that it works with that app
server but the absolute picks up the jsf
jars that you just installed as opposed
to its defaults but that's basically
good so so I have to think I'm angel for
his work because this is just demo as
his but I've got a button here and I'm
in click on it and you see open here
okay and if I click on it again I get
another response right and each time I'm
getting DSF partial response coming back
here but basically what's happening is
it's essentially a channel push channel
that's been opened between the PI on the
server so if I look at
so of course IntelliJ is complaining
because you know it doesn't know about
the the new F socket tag I'm sorry web
socket tag but essentially all I have it
is a button here okay and I have a
channel and basically what's happening
is even though it looks like a normal
Ajax update what's happening really
what's happening is that click on the
button and it's sending a message which
is being pushed back it's being handled
by this socket listener class which is
just appending
or inserting this HTML into an element
the Dom okay so we're actually getting a
push messages back and you can do like
cool things like chat servers or just
any sort of continuous communication you
want because basically any anyone that's
subscribed to this particular channel
can actually get the response back so it
can actually be completely different
users you know you can push messages
that's for different users but also
WebSocket has support for a user so you
can actually even tie a concept of a
user whether it's user principle or
something else to particular channel as
well so then messages won't go to
everybody okay
so that web socket tag basically sits
here and then you have your backing
being
and by default their application scope
but they can't actually be a request or
view scope as well okay you just have to
specify on the WebSocket itself to say
hey this is going to be a push
musical beam horses or requests of being
etc and you just inject the push context
and you say what channel you want and
then basically all you need to do is
send the data back okay and you're good
to go
and all this builds on top of the Java
EE 7 WebSocket integration ok which
brings up a point that we've you know
have with these specs over time when
you're in the core spec you can only
introduce dependencies on other things
that are also in the spec so it's
another hurdle complexity that doing it
spec wise you don't have to have if
you're just doing an open source program
you can introduce dependencies as much
as you want yes as we've seen with many
and JavaScript projects right
okay you mentioned Ajax method
invocation you just have a page here
with your command script and so the new
tag is H : command script and you will
reach out and call a server-side method
and you're able to do something you like
what the result there so in this case
we're showing it down that that H yeah H
output text on the bottom so you have a
demo of this would to ideate right yep
what's what's nice about HQ man script
is that if you've ever worked with the
the primefaces
remote command it's the same thing okay
an omni faces has a variation as well so
basically it's just the ability to
execute an arbitrary method on the
backing beam so I'm gonna type something
in here
my name is Kido
let me reload my brush the view
okay so I basically got a response back
now of course I could have just done
that via Ajax but we want to show
command scripts so
okay so in this example the input and
this P here this paragraph are just
normal HTML elements are not using any
any JSF or anything special
okay so when you click on this button
we're calling this method called send
feedback wrapper okay and that's going
to do some work right and turns out that
send feedback wrapper is really a
wrapper around a method that is on our
packing bean okay so needs to be inside
a form and basically you specify the
name this is the name of the javascript
function okay now in a larger
application you probably would want to
namespace this so it's like you know my
app dot send feedback or something which
is fully supported but the idea here is
that now you have this function and with
this you can then do all the normal
command command button UI command
command link sort of features you can
update any part of the page you can
render different parts and I'm sorry
execute different parts of the page as
well see here we're rendering the save
ID and we're executing the whole form
which is really just as one page this
one element and we're calling this
method here and when you call the method
in JavaScript so you see this is send
feedback this is the name of the command
script here you can pass in name value
pairs which are sent as request
parameter so this is basically used
saying hey I want to send some
parameters from the client to the
backend okay so here we're just sending
in the raw values that entered in by the
user but it could be something else okay
and then all what you have to do on the
back end is have an ordinary JSF backing
bean
okay and here is the send method and so
it has to get the request parameters and
then you can do whatever it wants with
them and this could be injected right
here this would be an example of where
this getter chain you would just say at
inject external context these actually
go to the right what's he actually
trying to get to their request which was
also injected exactly so yes this
basically all there is to it but what's
nice here is that we're you know can get
communication back and forth between a
client server and there's lots of really
interesting use cases so how many people
here have used the the primefaces
version of this the p remote command if
you a couple of you and so it's great
works pretty much the same way the
difference here is that this uses the
JSF API is underneath whereas primefaces
on the on the client and in terms of
JavaScript whereas primefaces uses
actually jQuery underneath for its
remote Ajax transport this uses a JSF
api's but other than that is pretty much
the same thing and as an example of a
very good use case for this I've on
projects been in situations where I need
to tell the server something is
happening like a windows being closed or
another great example which I should at
my advanced primefaces talk was doing
logging of a client-side event like an
error message so you get let's say you
get a Java Script air on the client and
you want to actually have it in your
server logs you could just call a method
on the back you mean that writes it out
to the log file okay because you can't
wrap the the JavaScript errors using the
on error events on the window object so
there's all sorts of things you can do
that aren't really you know you don't
really think of you know right off the
top of your head but once you realize
what you can do it becomes quite
powerful alright
oh yeah I added one so this one is kind
of fun
get eval scripts so we added we did JSF
Ajax in 2.0 we added the feature to have
an additional XML element in the partial
response that the server can send that
will just cause scripts to be evaluated
little sense of additional script down
from the server to the client and when
the client gets it after the render it
will execute that stuff so this API was
added to just allow you to access that
so we can see we have a backing beam and
it's just calling partial new context
very partial view context and get eval
scripts and sending an alert down so
basically what's gonna happen is after
the Ajax request completes it's going to
execute that script so you're basically
saying you know whenever whenever you
get back to the client run this Jett
piece of JavaScript for me yeah let's
see pump JavaScript down okay class
level bean validation so this is the
feature that really ties together one of
the important aspects of the bean
validation specification and that is the
ability to validate an entire model
object not just the properties when JSF
and validation happened originally it
was all about just component property
values because it was designed you know
with that sort of struts mindset from
the beginning but bean validation takes
a larger view and we now have that
feature exposed in JSF 2.3 here so the
canonical example of course is the user
account creation where you have to type
the password try it twice and there's
two different kinds of validation you
know the passwords have to be valid with
regard to your constraints such as must
contain eight characters at least and
mixed case and have a symbol in it all
that kind of stuff but they also should
match each other so this is achieved
using this validate whole bean thing and
it is
not the cleanest spec it's not we had to
work around a bit because the as I said
the bean validation model is validating
the whole object and JSF is validating
only individual properties but in order
to perform class level validation the
values have to be in the object that
you're validating however JSF doesn't
ever want to put invalid data in the
model so it's kind of a catch-22 you put
you have to put the data in the model to
validate it but you can't validate it
until you put the data in the model so
we came up with a actually this was from
Omni faces the Omni faces people their
solution which we adopted was to have a
copier concept where you make a copy of
the beam that's being validated it gets
pre-populated with the candidate values
and then the validation happens at the
class level okay
here's what the managed bean looks like
so it's a request scoped beam and it has
this custom annotation on it called
password so this thing is a password
basically that's what that's saying and
you have to specify the group's the
password validation group is what
enables this correlation to be
established between all of the different
fields that are participating in the
validation on the bottom this is the
password validator so to do a custom
validator with bean validation you have
to have an annotation that is a
constraint so you define your own
annotation that is itself a constraint
here where is Mouse I'm trying to point
at the street there it is thank you
and you can see what your message is the
group's is specified it's default there
and it has a the payload but on the next
slide you can actually see what the
valid error looks like so this is the
thing isn't like it develop really well
how do I just get the darn code to be
executed what's the thing that's going
to say true or false if it's valid or
not and that's this thing it's the thing
that implements can straight validator
of password and backing bean so you can
see the method is passed the he backing
bean which is actually the password
instance and because you're saying
calling get password one equals value
get password to copy right so on the
interest of time I think we maybe we'll
skip that unless you really want to do
the demo that's fine I did want to point
out though that what's great about being
validation obviously you can use it on
your back and being like this but if you
have on your model you can use
constraints which are done there as well
so you can do it basically reuse
constraints you have any brown in JPA
entity with bean validation and I also
have it work with JSF in the UI which is
nice okay so here is the date/time
support this one is just you know we
added Josh they're added support for
Java SE date/time jsr 3:10 and it
dropped the drop right in it fits right
in where the convert date/time validator
or converter rather is is doing its job
okay
they made some enhancements to UI data
and you know I repeat basically
supporting iterable and all of the
subtypes of that so that was something
it's been a long time coming
how I end up with all these duplicates
okay all right so one of the features
that is talked about in promoted for
Java EE going forward is the notion of
multi-tenancy and several of the other
job Oracle Java EE sessions you may have
attended talked about multi-tenancy as a
feature that they will be adding well
JSF has had it had features that are
able to take advantage of multi-tenancy
since 2.2 came out so considering that
everyone a lot of other talks are
talking about multi-tenancy I thought I
would spend some time to talk about that
here there are basically two features
that we added in 2.2 that could be and
leveraged from multi-tenant purposes and
that is phases flows and resource
library contracts and phases flows
allows you to modularize
the behavior of your application so you
can imagine if you have a multi-tenant
application that you're let's say want
to have a you have a hosted pizza shop
online ordering thing and you're signing
up different clients that would like to
have an online presence for their pizza
ordering shop and you have it posted on
some kind of hosted provider you you
could have different price points saying
ok do you want to have the advanced menu
a selection workflow or do you want to
have a very simple selection workflow
and you could package these different
flows in jar files and have them you
know you know be present or absent
depending on what the customer chooses
so you could have developed the app once
and have different parts of the app are
that are accessible depending on if the
customer is buying a higher level of
service or a lower level of service so
that's one way you could do that in a
multi-tenant fashion because these could
be hosted on the same infrastructure
it's just that tenant a is paying the
higher level fee so they get the
advanced menu selection flow and tenant
B is not so they don't get access to it
and this could be turned on or off very
simply with
and then on top of that for any given
client you give them different flow they
could have a different look and feel as
well right and that's where resource
library contract comes in so that lets
you modularize the appearance of course
you know if you're gonna be having a
boat a hosted Pizza ordering service the
most important thing is to give a look
and feel that represents the customers
brand but you want to do that in a way
that's pluggable so that you can go to
many different customers and just change
a little bit and then they get their new
brand in there right and these two
features build on all the work that's
come before that's the nice thing about
having a technology like JSF that's been
around for as long as it is you get the
opportunity to build on what came before
rather than reinventing new each time
just a few minutes on initial potential
areas for investigation everything we've
shown you so far has already been done
I'm very happy to say that and so not we
we might decide that we don't do any of
this we might decide you know what it's
JSF q3 is good enough let's we've got
enough in there let's just get it out
and so ever would start using it but I
thought I would just spend a couple
minutes talking about some other ideas
that came up Java EE 8 added a config
jsr and there's a talk I have a slide on
the other sessions on that you're
hardcore Java one go to every session
till it ends there's a session for
config at the very end which you should
check out so the yell with externalize
config is you can have your war or your
executable jar however you're packaging
it and you no longer would have to
bundle the configuration inside the
artifact itself it could be pulled
dynamically based on environmental
constraints
well one common use case people think of
as one set of configuration for dev one
set of consideration for production
instead of configuration for acceptance
testing for example and this is an
important quality when you consider
continuous delivery because you really
need to assure as much as you can that
what you're testing as you go through
the pipeline is the same thing you're
putting in production you really don't
want to get to a situation which
sometimes happens when you're doing CI
at scale where you have to build it for
one environment and then build it again
for another environment because then
something might creep in that's
different
and by externalizing them they config
you are creating one potential problem
because that is a thing that changes but
you can isolate it because it's the only
thing that changes you could also
provide defaults right yes I think so
another jsr that's being proposed is
health check so basically insuring that
the server is up and can contact
downstream services this might be useful
to take that example we talked about
earlier where you have a JSF service
that instead of having its own backing
beans and CDI integration in process is
using the rest calls the health check
would let you say am i able to reach
those other services the security jsr
this has already been filed yes our 375
doing OAuth and time-based one-time
password are really currently too hard
Oh much nicer to make this easier
another concept is this circuit breaker
thing the deal with a circuit breaker is
in a micro service architecture you
would like to be able to know when put
some smarts it's basically a place where
do you put your retry logic and you put
your retry logic in the circuit breaker
and it says you can define retry
strategy if you back off try it and then
wait a second and try wait two seconds
try it wait for there's different
strategies so that happens in this half
open state so in the normal case the
circuit is closed that means requests
are flowing through the minute one of
them fails
the the circuit breaker pops open so to
speak and it goes into this half open
state and then starts doing this retry
business it's also a place where you can
install sort of Mach values or defaults
or you can have the circuit breaker can
customize so that it maybe saves the
response that it last gave some kind of
local cache but it's not hard to think
of this being applicable in JSF where
the update model value stays less you
could itself be wrapped in a circuit
breaker where you know you if you have
some trouble and the update model values
phase you try it again you know you can
imagine that's something we could
consider if we have this chance of life
cycle we didn't talk about it at all but
underneath all of this is the old
request request processing life cycle
we'll have time for questions at the end
for sure okay so we formed the GSR
started it in 2014 we have the early
direct review in 2015 we're now working
on public review these are the
additional sessions that you should
check out I'll leave this slide up
during the QA but before we take Q&amp;amp;A I'd
like to ask people to you know take the
survey if they haven't already the users
emailing list is where you can reach the
expert group you can join the JCP and
stuff and I'll leave this slide up and
now we have about 10 minutes for
questions which is great
Reza in the front
okay sure it's a good point thank you
for bringing that up the question was
how does Jen http/2 relate to this and
if he went to my other talk on servlet
you'll see how it did I really should
have put that in there on this one but
the main feature that's in the HTTP two
feature set that's exposed to
application developers of course is
server push so server push is a feature
that lets the server give the browser
what it knows it will need before it
asks for it because again the whole
rationale of HTTP 2 is to increase the
perception of web apps and web pages and
their performance to make it seem like
they're going faster and in some cases
make it actually be going faster but by
saving the time that the browser would
otherwise have to spend downloading the
HTML parsing it and discovering I need
two scripts a style sheet and three
images the server will know well okay if
you ask for page a you're gonna need
these things I'm gonna give them to you
and JSF is in a very good position to
know that because you have to declare
all of the resources that a component
needs so that it can do its job on the
server side any other questions
what do i okay yeah what do I imagine
the future being post yes f two point
three I imagine that it's gonna continue
to be enhanced like it is I think you
could look at what's happened during two
point three and use that as a template
for imagining what the future would look
like the community continuing to
innovate and such okay any other
questions
the question was does the new get eval
scripts feature make the primefaces
get request context irrelevant or no
longer needed yeah I don't I think
there's still stuff in there that the
crime face is specific so even if some
of these things are ended up being
handled in a JSF way in a standard way
via the partial context there are some
other things in requires context that
primefaces does like integration with
the dialog framework and things like
that right away
right
okay so the just saying the PR guys
haven't J's have two point three branch
that's cool
ah so some of the stuff we talked about
earlier this is your session okay the
question of the statement was the second
bullet point is actually breaking apart
the JSF questions okay and I didn't
meant to mention this the beginning but
you all stuck through anyway I had a
little promo to get you to sit through
the whole talk so this is a I think Java
one 2007 2009 conference bag and I was
going to give this away to the person
that I don't know already who has been
using JSF the longest so we'll start by
the show of hands who has been using JSF
since one dot oh you have to be someone
I don't know alright alright but I don't
think I know you so why not oh you had
two people with one dotto
yep okay what year all right all right
so are you still using it okay are you
still using it I said 1.0 are you still
using it not not one point I was still
using JSF in any capacity oh I'm sorry
yes nothing for you yes
all right so we got a we got a winner
all right any other questions okay well
thank you for your time have a great
rest dear show</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>