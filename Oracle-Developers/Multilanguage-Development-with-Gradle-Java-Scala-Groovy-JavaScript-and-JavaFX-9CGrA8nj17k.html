<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Multilanguage Development with Gradle: Java, Scala, Groovy, JavaScript, and JavaFX | Coder Coacher - Coaching Coders</title><meta content="Multilanguage Development with Gradle: Java, Scala, Groovy, JavaScript, and JavaFX - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Multilanguage Development with Gradle: Java, Scala, Groovy, JavaScript, and JavaFX</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9CGrA8nj17k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to this presentation on polyglot
cradle so it's basically created beyond
building Java projects but including
Java project so who of you is using
Gradle already who of you is using it
not just for Java for which technologies
right right yep who of you is using
Scala who uses using groovy good who of
you is interested in JavaScript who've
you in Java FX ok so yeah my name is
hands doctor I'm the founder of cradle
to CEO of greater where the company
behind cradle and so we talk about how a
good crack Java how some of the
optimizations we do are then usable for
groovy what additional stuff we do for
groovy what do we do for Scala what do
you do for other languages like Java FX
and and JavaScript and C++ and so on so
let's start with building Java right so
cradle obviously has a Java compiler us
which is an interface to the Java
compiler so you can easily in Gradle do
it the end way you know declare a task
that that says hey cradle compile this
stuff this is not a way you usually use
grader but you can do it that way and
then you have all the options you might
want for configuring the compiled tasks
which then delegates to the actual
compiler so you can set whether you want
to for whether you're not want a fork
and debug and whatnot and we have two
different implementations initially we
were using the end Java tasks we were
delegating to the end Java C tasks to do
the compilation
but we still support this for backwards
compatibility reasons but a couple now
would say six six month ago between six
and twelve months ago we implemented a
direct integration with the Java
compiler that way we can do pretty cool
stuff as you will see very soon so one
thing the crew become degraded the Java
compiler tasks does is an up-to-date
check right so this is a general feature
of Gradle when you when you now execute
to compile Java tasks and the compiled
Java tasks compiled to a source code
right creative remembers the inputs and
the outputs of that compiled task so if
you run it again and you haven't changed
the input and the outputs the compiler
won't be triggered it's up to date right
in Quetta does it for everything this is
a generic feature one second not just
for compiling for testing for
documentation generation for deploying
to a do whatever you want right so there
was a question yes please yes yes the
check sums so this is very efficient is
very fast and so this is not to be
confused with incremental compilation
right so so when something has changed a
single source file
what Gradle then at the moment does it
deletes your all classes directory and
compiles everything new right this is a
generic thing if something has changed
do it again if nothing has changed don't
do it not just compile whatever is in
your build right so incremental
compilation is and may even they both
have a kind of certain they offer
incremental compilation in the following
way they check the timestamps of your
source files and if a source file has
changed they recompile that sauce
the problem is if you have a source file
a and a source file B &amp;amp; B depends on the
method of a and you remove that method
in a then only a is recompile and
compile is successful right so this is
not worth it
you don't want to have an unreliable
compiled so therefore for us speed is
very important but reliability is comes
first as soon as any optimizations
becomes unreliable it's not worth it if
it fails in one of ten cases it's not
worth it because the time it takes you
to figure out what is going on and what
is going wrong will will outweigh the
performance optimizations you've got so
at the moment we don't offer our
incremental compilation the thing is at
least not for Java the thing is Java
compiler is fast there are there are
other areas where we can get usually
much more benefits to do the performance
improvement distributing the integration
test paralyzing the build and whatnot
right so I will talk a little bit more
about that later
so yeah the input for for the
comparators are the sources the compiled
class path if the class pass has changed
it will be reacts acute in the compiler
settings the outputs are class files
okay so which Java compiler sorry I'm
just looking for my power adapter so
which jar which version of Java are we
using to compile the code the default of
cradle is to use the same JDK or that we
use for running cradle right that's the
default so if you want cradle with JDK 7
we use JDK 7 for compiling your code
it's never presented in that way so what
is what if you want to target all the
Java runtimes right so we have to do
that for greater
we want to be able to that that that to
make sure that creator can be built on
Java seven Java six in Java five and if
you don't ensure that it happens so
easily all our developers working on
Java 7 so oh there's this right it's a
really interesting attribute in in a
file API method damn I never knew that
it was there let's use it and then we
get some email to the forum in the past
I can't compile this with Java 5 anymore
right so we have to make sure that
created can be compiled with all the
Java version because we an open source
project and people want to be able to
modify cradle and work on it not just
with Java 7 for example so so there are
multiple ways you can do that of course
you can switch the JDK you use for
running Gradle itself
right right that's one way and then
automatically this JDK would be used for
for compiling your code but we worth
Gradle we want to we want to we need to
compile against multiple JD case you
know in one build so another way what
another thing you can do you can let's
say run cradle with JDK 7 and compile
with JDK 7 and then set the source and
the target compatibility right the
problem is yet still won't tell you if
you've used a method that is only
available in Java 7 right so but to do
that you can configure the compiled task
and put in the boot class path property
of the compiled tasks the RT jar for
example of the older JDK makes sense
what I'm saying then you still compiling
with with JDK 7 but against the API of
JDK 5 JDK 6 and with the target and
source compatibility settings of those
jetty case that's one thing you can do
and the other thing you can do to
achieve that you can use the fork
options property of the of the compiler
and just point it to a different JDK
should use for the particular compiled
right so we want to make that in the
future more convenient we want to model
we want to make the concept of a JDK a
first-class citizen right that you can
des do this on a very abstract way just
say JDK 5 and then greater will try to
look for the JDK 5 on your machine
right because there usually are in
particular locations so we try to do a
good job and to make it very convenient
we're not we're not there yet but anyhow
it's possible and it's easy to deal with
those requirements with Gradle and you
can easily then create multiple compile
tasks for your source code that that use
that that built your your source code in
one build go against multiple jetty case
so but usually you don't use you don't
you don't add to compile tasks
explicitly in Gradle so in credit we
have to Java base plugin so when you
type in your project apply Java based
plug-in you get a new language element
which is of a higher level we call it a
source set and then you can tell Gradle
hey cradle I have a set of sources
I call them main write the Java code for
the sources lives in source main Java
the resources you can also define where
they where they live you can tell the
source set where it should put where the
output should be of the classes where
the resources should be what compiled
class path it should use and what
runtime class was it should use for
running then the actual code Gradle has
very powerful external dependency
management so that way you take cradle
for the compiled class pass please use
all the dependencies that have been
added to the compiled scope right yeah
this is not strictly correct as a bug
here the runtime class path should
include all the external runtime
dependencies which include to compile
dependencies but of course it should
also include the output of the compiled
sources of the main source set anyhow
once you declare such a thing in cradle
cradle automatically creates the tasks
for you to deal with the sorcerer
so just by declaring I have sources
created creates a compiled task a task
for copying the resources to the binary
output directory etc this is a
declarative element you just say I have
sources and the actions what you want to
do with the sources created figure this
out for you
this is a this we do this all over the
place right so that way you
automatically get a compiler us by
declaring your sources right this is how
you do it in your IDE you tell your IDE
I have sources you don't tell it how to
compile your sources so the Java based
plug-in is what we call it toolkit
plug-in it provides you a toolkit higher
level abstractions to tell your own
story right so what we now additionally
have on top of the Java base plug-in is
an opinionated framework this is the
Java plug-in if you apply the Java
plug-in then you have a maven like
behavior the Java plug-in has
assumptions as assumptions you have you
have already you have particular sources
you have sources for a production code
you have sources for your main code
before your test code right and and it
creates those source sets which
automatically creates the compiled tasks
for those source sets and then it
creates a task a jar task for for for
bundling your compiled production source
as the test tasks for comfort for
compiling and executing your tests and a
Java doc task right and then you build
script looks like this this is the only
thing you need to do if you apply the
Java plug-in and then you have all the
tasks available to deal with the Java
project and then you can just type a
cradle compile and everything will be
compiled right so and this is a typical
thing we do we have a toolkit plugin a
base plugin and then an opinionated
framework on top yes please
oh yeah easily easily it's this is still
very flexible so you can say oh hold on
Gradle our situation logically we have
main and unit tests but you're all in
one directory and then you could define
some filters and you would still have
the logical abstraction production
source and and test source but the
physical representation is completely up
to you right so and and this is very
important we have this kind of
modularity we have for example for
example LinkedIn as a big cradle user
and they have separate projects for a
production code enter test code so the
Java plug-in is not telling their story
and that's okay they just used to Java
based plug-in and then use the source
sets to tell your own story this is the
cradle way right we offer you something
out of the box but this is a lightweight
opinionated framework it is based on a
toolkit and you then you can just use
the toolkit if you want to tell a
different story but you don't have to go
down all the low level way like you have
to do with end to describe everything on
a task level so there are other Java
related plugins a war plug-in an ear
plug in a Java library distribution plug
in an application plug in so different
types of of Java projects we support of
course right so one cool thing we edit
is the compiler daemon so in cradle the
default behavior is now when you compile
a Java project we fire up a demon that
does the actual compilation as a
separate process and this this demon is
reused across tasks what does it mean
usually when you have a project you mean
even a medium sized project you have
something like what we call a mighty
project did but you not just have you
just learn or compile one little project
you compile my tippet projects write all
your different modules you have linked
in is having a 3600 created sub module
dirt so how often do you need to compile
per project usually when Lincoln is a
little bit different but usually two
times
compiling the production code and from
compiling the test code that means you
would call the compiler in many project
hundreds of thousands of times right
what we now do at the beginning of the
build we fire up a compiler daemon and
that is reused all the time and that
gives you significantly faster
compilation and we use that same thing
also Vitruvian Scala and let's see that
in action so we're using um what why
can't I switch sorry
hmm I have to exit presentation mode
okay don't know what's going on here
with my text mate sorry do
oh my other windows have gone why don't
they come to the foreground
don't buy a mech that's weird yeah you
know I I make it work by all my
shortcuts are not working for switching
between the windows anyhow that's no I
don't want sorry don't know what's going
on here it's not where is my text made
menu bar it's grown let's see
weird so still doesn't work
what I want to do so it's very hard when
your shortcuts are not working to get to
where you want to go so here we have two
spring integration project just to give
you
I can't even type a little bit when I
can't type that's a hard one
well
so this is a weird situation I mean I
get go to fire you see I'm not even
getting a clicking here
but this window is not getting active
Tommy I don't know what I did I don't
know let's let's quit something
I mean I'm seriously considering a
reboot
I don't know I'm not sure if it's the
some of the presentation mode I have no
idea
oh yeah I'm really sorry but I I feel
like I have a virus on my machine
like this is weird
it's Chrome still run no it's not
running just close everything that I
don't need
so just get rid of what I don't need but
the window is not coming now this is
coming into the foreground quick time
let's try it one more time I term hey I
can type Wow sorry for that so let's go
to spring integration right so we're
doing this with the real Java project so
let's have a quick look at spring
integration spring integration is a
mighty module cradle build right so here
we have all the sub modules right and
what we're doing now for this demo we
say do it the old way use the N Java C
task that fires up a Java compiler for
each and every compile the way no MAME
would do it or n would do it and let's
see what's going to happen now getting
nervous with nightlife demos yeah let's
do a clean classes classes means produce
my binaries so now we configure the
mighty module build and yeah we already
we have deprecated the old way but it's
still its own greater to all this won't
be even possible anymore
we're now cleaning everything and
compiling the first module and so on and
so on
spring integration is a really nice
project if you want to learn about
cradle they have a very nice they have
not night use trail in a very nice way
very modular it's it's an really nice
showcase for a clean clean cradle mighty
module built
so compiling module after module of
course in the right order as they depend
on each other and and you see there's
always okay for comply losses here we
don't even compile the test sources so
if we would do a full build here we only
compile the production sources right for
full build we would have twice as many
compiled steps right but even that will
show you the difference between using a
demon and not using a demon so now let's
say let's not use end which is the
default let's do a clean classes there
was one minute and 39 seconds and should
be much faster now
you can see the difference this is
because no you know I have a warmed up
process where all the just-in-time
optimization have happened and not the
Java compiler is a complex piece of
software right 20 26 seconds so right
and for groovy and Scala the difference
will be even more traumatic right so and
this is there's so much cool stuff you
can do in a bill domain that hasn't we
could have done that ten years before
right this is not something this is not
a quantum leap because of that is
enabled by new technology is just giving
life to the domain you know and caring
about hey what can we do to make bills
faster yes please know we would have to
this is not yet a general abstraction
that you can easily use so nothing
there's something like neg and I don't
know if you know that project there is a
kind of open source project to have a
long-running Java process but so far
they are not so many languages right so
we rather what we could do we could work
together with the Catalan folks from
JetBrains and then do something about
that so good point I take that with me
but right now this is not kind of we
don't have a public API for that so now
I have to fire up my presentation again
Gradle talks polyglot
talks
well
okay so that was what I wanted to tell
about Java well I want to do one one
more thing about Java I want to give you
an outlook of what we plan to do in the
future
so one thing about this long-running
daemon it is not it is not really
long-running it is fired up per build
and when the build stops it
it is killed again the next time you
fire up a build we fired up again the
reason why we do that is that we want to
avoid any leakage problems and things
like that so we want to we took it easy
at the beginning to say reliability is
most important let's see how this demon
kind of what what problems we get with
that demon but one thing we definitely
want to do is to reuse to compile our
demons across bills right and then you
have all the time a demon that that is
that is fast the other thing we are
working on and that will hopefully come
out in the next couple of months is a
task is a way to run a create a task in
a continuous mode right that you can
tell great late run the compiler tasks
in a continuous mode within the daemon
and this task then checks have my input
change and if they have changed we
automatically recompile it I mean
usually your ID does it for you but it's
a generic feature we will add to cradle
then you can have a kind of rapid
development start with Gradle if you
want yeah we're working on a better on a
more abstract model for our source sets
because we want to make them reusable
across languages for JavaScript for C++
for Android right now they are not
flexible enough they can't be used by
those platforms and the problem then is
then they can't use some of the other
plugins that expect that source sets are
available so that's something we're
working on yeah smart are up-to-date
checks that there's some optimizations
we can do there and then there's
something we were thinking about for a
long time to do in Chrome
compilation because it will provide you
some performance benefits even in a Java
space what you see at eclis could do is
use our Scala compiler just for
compiling the java code because it has
incremental compilation but it's not the
authoritative Java compiler and in JDK 8
they started to do build in some
incremental compile functionality I'm
not sure if this will be kind of part of
the production release right so so maybe
we get that out of the box with JDK 8 I
know that Arnett guys they have that the
dead compiler doesn't increment a
compile out of the box would be good to
have that in Java
yes piece there was a question in the
back oh yeah absolutely it's the best
dependency management resolution engine
out there so I mean I'm biased but yeah
and it understands Palms and I'm sending
IV xml's and yeah so it's a-ok building
groovy right so building a dynamic
language so we have an indirect
interface to do groovy compiler and the
groovy compiler can compile truly and
Java which is really important because
one of the key value promises of groovy
is this seamless integration with Java
and so again we have a compiler cuvee
task type for this task and you can
configure it similar to what you can do
with with the Java compiler tasks and
the thing is you you can set different
options for compiling your groovy code
and for compiling the Java code because
it compiles both codes the up-to-date
checks is exactly the same as with Java
it's binary if something has changed we
do everything for groov it will be very
hard to do an incremental compilation
because of the very dynamic nature of
the language right
that is but it's usually not not a
problem to compile performance
so which groovy compiler do we use well
if you have a groovy project you usually
tell us
hey for compiling like Ruby code I need
this groovy jar right and to groovy
compiler is part of the cookie jar of
the groovy distribution so so so we have
basically the crew compiler is part of
the library you have specified so when
you say you need to please for come for
compiling my groovy code I need groovy
all blah blah blah this contains the
groovy compiler so and then we just
figure it out okay we do right we get to
groovy compiler from from that job you
don't need to tell us anything more and
again it is a groovy based plugin which
has a baseline cruelly support it builds
upon a java-based plugin and the source
sets are now crew via where when you add
to groovy bass plug-in and it adds a
groovy compiled task for each sauce set
so if you add a groovy sauce set you
automatically get a crew compiled task
for that sauce set and but there's also
an opinionated cruelly framework the
groovy plug-in where everything works
out out of the box like with the Java
plug-in there's a source set for
production code goo resource attic Ruby
saw set for tests the crew redock tasks
additionally to the Java doc tasks and
and so on ok the interesting bit comes
with the crew V joined compilation so so
the default is if you would be using if
you wouldn't have a smart joint
compilation that that the way you could
do it is if you have a mixed Java and
groovy code you you first compile your
Java code and then you compile your
groovy code with the compiled Java code
in the classpath right but what you are
very often want to have is that groovy
code can depend on Java code and vice
versa
right you want to be able to change a
class from groovy to Java at any time
right whatever the dependencies are of
those class so with the join compilation
of the groovy compiler you can have
arbitrary be directional dependencies so
you can have a Java based class in the
groovy class that extends to Java based
class and then a Java
derived class
- cuvee class and that really works with
cuvee that is a resume group so the
promise of groovy to have seamless
integration with Java is is not
theoretical it really works
right so but it's not completely trivial
to do this joint compilation so so all
java and groovy code pass through become
pilots join compile write and you have
two ways to do that either
you put all your java code in the same
directory in the same packages as your
java code this is the way you usually do
things if you for some reason like to
have separate directories for your
groovy code and your java code you just
can reconfigure and tell the crew v
sauce set hey please look for code in
source man java in sauce man groovy
right yep we had the question can you
reconfigure where to look for the source
code yes you can do this easily right so
the crew compiler how does the crew
compiler do join compilation it generate
Java stubs from Ruby code so it so that
then the Java compiler things hey
there's only Java for the Java class
that compiles around and all the
interfaces it has on Ruby classes I
represented by the Java stops right and
then it compares to groovy sources so
let's let's let's do a demo I hope this
works more seamlessly than last time
that it was all set up I have to go
demos groovy Java so what we see here we
have a very simple Java project right
groovy
an application doesn't matter and we
have main groovy raytracer groovy which
does some heavy computation and some you
to the groovy class so this this is a
puke groovy project and we can now take
Radel hey cradle build all the classes
for this movie project so you see the
job that there was no Java that needed
to be compile compile groovy to compile
and the classes are there I could now
run this guy and now the application is
running and we paying some performance
cost because groovy is not as fast as
Java right
that's right yeah so this is not a group
let-let's while the guy is executing
this let's now say oh this is this is
taking too long let's make the raytracer
Java right so we have already JA we have
already said to receive my colons in the
right place to make that fast so right
so finally we get the results now let's
run the whole thing again
now with the ray tracer written in Java
ma should be much was much faster right
so and you and that way you can see how
easily you can change from groovy to
Java and vice versa
pammi
that does it what delete yes it does it
does so as soon as something has changed
we do a complete swipe and with who VB
probably will always do that because it
will be very hard to figure out with the
dynamic language of Cru V what is the
transitive crap of the dependencies
between the classes so yeah so for
groovy using the compiler daemon but
which we do is even more important than
for Java because with groovy as well as
with Scala because of the type system
the warmup time it takes for for JVM to
execute CUDA code is much higher than
with Java the same is true for Scala so
having a warmed up grooving compiler is
makes a dramatic improvement for a
groovy build right so yeah in a future
we want to support the crew via Clips
compiler that the groovy team is
considering of making groovy eclipse
compilers which is to compiler of the
eclipse groovy plug-in possibly the
default groovy compiler it has some
optimizations and if that is going to be
the case we will support it and we also
want to provide some groovy wrapper
development experience with with a
long-running compiled tasks that
automatically checks for changes and so
on ok now let's talk about building
Scala so as you might have guessed we
have Scala compiler tasks is an
interface to the Scala compiler it can
compile Scala and Java so there's also
join compilation in Scala and initially
we were using the end scarlet asked to
do the Scala compilation now we switch
to the zinc Scala compiler as the
default zinc is a module that came out
of the SBT project SBT is the build
system for Scala and and they basically
provide an abstraction to use they're
very optimized Scala compiler also in
other projects and we will soon see why
this is important so
so one important thing with Scala Scala
is a very complex type system so which
gives you a lot of benefits on the other
hand it makes the compile task very
expensive and very long so voise in java
the compile time usually it's not an
issue in Scala to compile time is a big
issue right so so therefore there is a
huge incentive to optimize to compile
speed in Scala and so what so what the
SBT project the Scala built will did
they have developed an incremental
compiler for Scala what does it mean
incremental compiler an incremental
compiler checks there's two things it
checks which source file has changed but
it also knows the whole transitive graph
of which classes depend on which other
class so if a particular source file has
changed this source file gets recompile
but also all the other classes that
depend on that source file so this is a
really reliable incremental compiler
right not just I just rec imply the
files that have changed so usually you
don't need to mess around with that you
know there is an analysis file where the
whole craft information is stored and
and whatnot we just showed us for the
sake of completeness that you can we
configure that but there is something
there are reasonable defaults for that
and this just works you don't need to
you usually don't need to configure
anything for that so so we still do the
do the generic up-to-date check so if
nothing has has changed we don't even
ask the Scala compiler to see if not
something needs to be done right but if
something has changed we tell the Scala
compiler now it's your job to do things
right and with Scala compiler this is
inferred from the Scala compiler tascam
class path as with groovy so you need to
say hey I want to I want to use the
Scala library and from that we infer
which Scala compiler to be used so we
have a Scala bass plug-in you know which
adds so said Scala
so the concept of a scholar sauce set
and
Scala compiler tasks and the process
resources tasks for each source app
there's also a scarlet plug-in which
bill gives you an out-of-the-box
experience right with certain
assumptions and produces the Scala doc
okay Scala join compilation arbitrary be
directional dependencies so you can do
something similar for with Scala and
Java as with Ruby and Java and you can
also either put Java and Scala code in
one directory under the same packages or
in multiple directories also under the
same packages if you like but physically
separated let's not go into the
algorithms here so so one of the
challenges we have with Scala and also
with grooviest Scala and crew V binaries
are not binary backwards compatible that
means if I compile the Scala library
with Scala 2 8
I can't use this jar with Scala 210 the
same is true for groovy in Java we don't
have that problem you know that for good
and pepper for good and that it makes
Java so stable but it makes it also very
hard for the Java people to innovate and
to change something because it has to be
bytecode backwards compatible up down to
Java you know 200 I don't know if it
even goes back to Java 100 I'm not sure
so so this is a complexity you have in a
Java world so we have written some some
logic to to support that so you can out
a cradle hey and you could do the same
with groovy hey those are the target
versions I want to produce the library
that that work with those versions of
Scala right you can specify them and
then so so first of all we produce 10
alive multiple libraries for those
different Scala versions but there's
another cool thing you can do if you
have a dependency on another Scala
library there is a there is a convention
in the scala world
the Scala version is part of the art
effect name and if you put a question
mark here right
we will then for the we will then get to
write Scala zet codependency when we
produce to 281 library and the same is
true for 292 and 210 1 so let's let's
have an example let's do a demo for that
so here we have a simple Scala project
right a single Scala project built just
one class very simple and we have the
build script from before right and what
you can do now you can outer cradle a
cradle build everything
and now we start to do to compile you
see Scala compiler is taking some time
and and you see automatically you didn't
need to do anything we compiled with
Scala 210 with Scala 281 and with Scala
292 and we produced all the different
jars for this version right and if we
now open up or we can use we now look at
the bill directory in the lips directory
you see we have three jars right
this choice you also the flexibility of
greater right it doesn't make sense of a
build system says there can be only one
artifact per project a good reason when
you want to have multiple ones right and
I can also show you the cradle
dependencies report and that's pretty
cool you can see for Scala to nine for
compiling the Scala to nine version we
requested this version and it was
resolved against scholars at two nine to
six oh four if it would go here we would
say we would see this was replaced with
scholars at 281 604 right okay
so yeah powerful type system slow
compiler
incremental compilation to the rescue
zing compiler Scala and Java
incrementally and it works also in
mighty module builds right so that is
important if you have multiple modules
and you in what you'll be you're using a
class that were perceived it was
produced in module a the incremental
compilation which still work that's not
trivial right within the same source
tree it's one thing but across source
trees is it still works so I don't show
a demo the demo just shows you the speed
improvement incremental versus non
incremental it's significant right the
Scala guy also work on making the
compiler faster but it's quite it's
quite a challenge so that we're
definitely if they make it it will take
a while until they get there
so what is for Scala really important is
a compiler daemon across builds because
the startup time of any kind of scholar
application including the Scala compiler
is quite impressive so so having a long
line running daemon is important and we
also want to provide a Scala rapid
experience right like you get with SBT
ok so then I'll talk a little bit about
Java fix yes
you got scared so here we go
Oh
okay who's using JavaFX of you guys
already okay awesome so how are you
building it right now
maven of course okay we want to give you
a quick demo of how you can build Java
effects with Gradle as well we're very
excited that Java itself it's built with
Gradle a really good relationship with
the JavaFX team so which means the open
JDK is partially built with Graner which
is very cool so and it's a very complex
builds with all the different platforms
they have to support the native stuff
they have to do so this is a great erbil
check it out it's a very good graded oh
sorry Ben no problem so here we have
this really exciting demo which is a
hello world application so what it does
it brings up a pane which simply shows
you hello world or a button and whenever
you click the button it will simply
print out hello world so nothing really
exciting just to give you an idea how
this looks like and hans talked about
the conventions that the Java plugin
introduces for you so this plugin that
will we'll show you later on uses the
same kind of convention so it will
expect the application source code to be
under source main Java so here we have
just one package with which is called
hello world and under there we just have
one file which is the Java file which we
just talked about so let's have a look
at the actual plugin and what needs to
be done to build run debug this
application or even create a native
installer so actually this plug-in is
not part of the Gradle core so it's
actually contributed by the community
and what we do here we say we apply it a
script plug-in which is hosted on a
specific repository and in here you can
see we target bin tray which is a open
source kind of repository for hosting
artifacts and our artifact that we
actually request here is just a plain
file so here we say the file name is
Java FX that plug-in could be any kind
of like other name
or it could be a binary plug-in as well
here we call ace what we call it script
plugin which basically sets up the code
for you in the class path that that you
need to have for running Java have Java
FX applications so the only thing you
have to do here say apply from and here
we give it some HTTP URL could sit on
your filesystem as well
and then what it does it gives you
certain properties that you can use to
configure your Java FX application how
it should behave so here we just say the
Java Runtime that we want to target is
JDK one seven underscore 40 and we just
give it the path to where it has to go
that's one specific property that the
actual plug-in exposes to us as a user
so this is kind of like a nice example
where we where we let developers of a
plug-in actually expose their own DSL so
you don't actually have to know how this
works internally you just have to tell
what it should work on and then we can
give it some more other properties where
you say here we give it some sort of
application ID the application name or
of course the main class at some point
of time here there's far more you can
configure I won't run through all of
them and here just some examples so you
can set the job JVM arguments some some
system properties or the arguments you
need for your actual application and
then you can also sign this application
if you want to this is optional so you
don't need to do it but all you need to
do is to set up a local key store that
you're pointing to and then you can set
the password here as well and the store
password we basically externalized this
kind of data so you don't actually want
to check this in with your source code
you want to actually externalize it one
way of doing it is to provide a greater
than property file and here you see it's
a plain property file that you actually
don't want to check in with your code
it's better to put it in your local
Gradle home directory where it's picked
up as well so let's just have a look at
how this behaves actually so when we
apply the plug-in we basically say well
this is a Java plugin
a java application and the plugin
internally automatically knows that it
has to apply the java plug-in as well so
it gives you everything you already have
for java applications so let's see what
kind of tasks the plugin gives us so
some of the tasks you can see here and
they are not necessarily well organized
for this plugin
but there here you could also create
your own groups for tasks so just to
have them better organized but one of
the important ones is run which simply
brings up your Java FX application
there's another one which is called
debug so you can hook up a debugger to
it running from the IDE that you want to
prefer to use there is another task
which is called JFX deploy which
basically creates a native installer and
will quickly run through all of them to
show you how powerful it actually is
what is it how do you version it all you
need to do is to assign a version to a
property called version that's available
to you and your project and it will
simply append that version to your
artefact name that's all you need to do
but that's a basic capability of the
Java plug-in as well so let's say Gradle
run what we would expect is the
application has started so you see here
is also a specific task CSS tube in
which just creates a binary
representation of CSS files just to
optimize a little bit and you say see it
brings up the application it has the
button if you click on it it will simply
print out hello world so nothing really
exciting the same thing you could do
with a debugger so you would run the
debug task in this case and then it
would wait for you to actually hook up
to that port that is exposed just to
give you an idea I don't have a IDE set
up but it will show you what port you
need to connect to and here's 5005 all
you need to do is set up your IDE hook
it up set your breakpoints and you can
actually debug your application very
nicely and this is all driven by the by
the plugin which is really nice so let's
have a look at the other ones that we
had here so let's actually create an
installer and that's for our case it
would be a MEK installer so let's run
this specific task here and that's
called jfx deploy
so there are certain icons we gave it by
default as well here it doesn't find
them because I didn't define them but
what we see here it also signed the draw
file that we created and it will create
this installer now you can actually drop
it into your applications directory oops
it just went away it only takes so long
for the plug-in to actually show up we
can quickly run it again just to show
you what you can do but that's basically
a dmg file that is created for you by
the plugin automatically it brings it up
and then we can either click on on it or
just drop it into the folder it will
basically bring up the application so
nothing really special but really easy
to handle everything integrated in the
already existing build life cycle that
the java application gives you by
default the Java plugin that you
automatically apply with this plug-in
and here you see we also signed the
artifact this works in a way this is
optional but it's configured in our
build as well and you can see all you
need to do is set this up you can even
set different signing modes so you can
say for different environments I'm going
to have a different key that I want to
use so this would basically correspond
to this name here release key that's all
you need to do so that's just a quick
rundown there are more things you can
configure also different profiles for if
you want to target different
environments like Linux Windows for
example here's like a little example
where you would basically have a DSL to
provide certain properties for specific
environments but that's pretty much it
and it's in the early stage I'm pretty
sure there will be more features coming
up later on but very powerful already
yes yes the minimum you can come to our
booth and we can we can give you the URL
or come on you after come to us after
the talk I can put it on my local my own
private get up account and you can just
download there's a very simple example
so if you come by I can show you working
yes so a lot of kudos to Daniel Ferry
like in them and he also wrote a really
nice article about it so if you google
for JavaFX Cradle you publish it at
Chuck's enter and this is wonderful
plugins we so great as a first-class
technology in the Java fix ecosystem
yeah I just hope that at one point I can
have JavaFX explication on this guy's
yeah I have no idea what the plan is but
okay so yeah I need to wrap up so
building JavaScript very important so
cradle has a core plugin for core
javascript support and an external
javascript and CSS s plugin by eric
Wendelin for higher-level
functionalities so you can say apply to
Java Java Script plug-in and then you
can define source sets and or you get a
yeah you get a full lifecycle for for
doing JavaScript stuff with minification
with the code checking and and whatnot
so can go too much into the details
other languages cradle we're working
intensely on making Gradle a world class
C C++ build system and we just released
yesterday grade 1 8 where we made
another big jump regarding our C C++
functionalities and I think at the end
of the year we're already very
interesting but but in a couple of
months we have very compelling
alternative right for for building even
large-scale cc+ software stacks and this
domain needs improvements in the
automation domain right they are
suffering a lot it's the most
challenging domain you can build binary
dependency management extremely
challenging right with all the variants
with all the platforms you have to
support at the end of the day at one
point you need cross-platform builds we
have that but then also distributed
cross-platform builds if you can't build
for certain platforms on your machine
obviously right so
cradle is the default build system for
Android or for those of you who don't
know so we have a cooperation with with
the Google Android team and they are
developing the Gradle android plug-in to
develop Android applications so this is
so every Android developer
sooner or later we'll be we'll be using
Gradle yeah there's really good closure
plug-in a cordoning plug-in out there
very good flex support I KVM for dotnet
world s PEC J GWT iOS there isn't wrap
around to Xcode tooling we want to do
much more if you have languages that
don't have a greater plugin well it's
create and tasks are first-class
citizens in the greater world you can
always wrap around to end tasks or if
nothing helps you can use the Gradle
exit task and execute the command line
compiler but we have I think support for
the major technologies we have good
support and a key thing of grade-a Grail
is not a Java build system where you
have to squeeze in and make a lot of
compromises to get to make it build
another language Gradle is so open it
you can really tailor and model a cradle
in a way that your language becomes a
first-class citizen yeah so that that's
all I wanted to talk about thanks a lot
for your attention and yeah do you have
any questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>