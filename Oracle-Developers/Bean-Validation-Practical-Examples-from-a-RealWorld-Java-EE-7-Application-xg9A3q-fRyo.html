<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Bean Validation: Practical Examples from a Real-World Java EE 7 Application | Coder Coacher - Coaching Coders</title><meta content="Bean Validation: Practical Examples from a Real-World Java EE 7 Application - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Bean Validation: Practical Examples from a Real-World Java EE 7 Application</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xg9A3q-fRyo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to our talk which is entitled
bean validation practical examples from
a real world
Java EE 7 application my name is Gustavo
Durand I manage the software development
a software development team at Harvard
University within the Institute of
quantitative social science or IQ SS
this is one of my colleagues Steven
Kraft Miller one of the developers on
the project so here's our session
abstract if you're here for the talk I'm
sure you've already read it so no need
to reread it but we decided to include
it in the slide deck so later when it
gets downloaded you've got some
information the project we work on is
called dataverse and we'll talk a little
more detail about the project and how it
relates to the validation a little bit
later but the general idea is when we
first started it was a it's a web
application and that was really the main
input for adding new data to the
application was through the web
interface so we use JSF validation and
it worked very well but as we have been
partnering more and more with different
institutions and organizations we
realized there was a need to develop an
API and we ran into issues where we
would either need to recode and re-add
the validation or had issues with the
fact that we had multiple inputs but the
validation was JSF wise so last year at
JavaOne
I went to a bunch of talks about bean
validation and I saw it as the perfect
solution for what we needed it
integrates very part of java ee and
that's what we use and it makes the code
very readable and it allows you to
define the validation in one place and
then regardless of whether you're coming
through the API or through the UI it all
goes through the same set like that but
one of the things about the sessions
that I found at least that I went to is
while they were great introductions into
the concepts of being validation and how
to use them they really talked and
focused a lot more as an introduction
and talked a lot about the standard beam
validations and you know they introduced
the idea oh if you need you can do
custom validators and do all these other
interesting things but they didn't
really delve as much into any real
examples of it or how to do it to a
level that at least I thought was very
useful so when we were in back instead
of using it you know as with any
real-world project you've run into more
complex situations than the standard
things add up that will apply to so
we found that we needed to start doing
some more research and try things out
and figure things out on our own a lot
so we thought a good idea for a talk
would be let's actually show some of
these more complex examples and give
people any of the kinds of things you
can do with bean validation besides just
the standard so the idea of our talk our
general outline is that first we're
going to talk a little bit of the
standard bean validation we're going to
give a brief refresher for those of you
who have used it for those of you who
haven't used it before you'll get at
least some idea of what standard things
are but then we'll delve into the more
interesting things so we'll talk some
about custom constraints and validators
that won't talk a little bit about
Crossfield validation and then lastly
we're going to talk about dataverse and
how in our application which we have
very dynamic data and very dynamic data
requirements how we've used bean
validation to help answer our problems
with that I'll hand it over to Steve for
the first section hi as gustavo said i'm
steve craft or i'm a Java developer I'm
the dataverse project and this morning I
went to a talk by renting phillips of
oracle he talked about security and he
said I'm a Java developer I don't give
presentations and then he proceeded to
turn into David Letterman on stage and I
will say that I'm a Java developer and I
don't give presentations and I think I'm
about to prove that so anyway
Gustavo said I'm going to talk a little
bit about the standard validations that
you probably have all seen before and
they were introduced only you know a
couple years ago we're on one point one
of the validations and basically a the
validations can be an annotation that
you would place on
a field or a method or a class of any
javabeans component and the ones that we
were most interested in would be a
valide that you could place on a field
and an entity because as gustavo said we
wanted to have the validation happen
whether it was done through the user
interface or through the api so Java EE
7 has some basic constraints they
include not null so you if you have a
feel that you want to make sure that
someone puts something into you annotate
it with not know there's min and max
that you can put on a number field and
you give it a parameter the minimum that
you want or the maximum you can put pass
for future on a date field to validate
that you know a data entry is in the
past or the future and then there's the
size constraint which you can put on
strings or arrays or collections and you
have to give it a parameter for a min
size or a mac size or both so hibernate
added some some useful things that we've
actually used in the dataverse one of
them is not empty which you can apply
similar to size you can apply it to
strings arrays collections if you apply
it to a spring that got you there is
that if the user puts in just like a
blank that will validate so the second
one on the list is not blank and that
applies only to springs and it will
disregard whitespace so if the user puts
in a blank it that field won't validate
there's also a validator for email
which takes a couple of parameters you
can give it a regular expression that
the email has to match or a flag there's
a validator for HTML that looks for sort
of evil tags like script and you can
also add it parameters for types that
you want to allow or additional tags
that you want to allow and then there's
URL I've given you a link in the slide
so you know at the end of the talk you
want to download our slides there's a
link that brings you to all of the
hibernate constraints and actually in
the previous slide there's a link that
gives you all of the the built-in Java
EE 7 constraints so we'll show you what
it looks like in an entity so I've got a
simple person class with first name last
name and date of birth I've given it a
constraint of not blank and then there's
a message field so in the interface if
the user leaves first name blank we give
them a nice message enter our first name
similarly for last name please enter the
last name and I want to make sure that
the date of birth is in the past now you
can add multiple constraints to a given
field so for our first name last name
I've added a size constraint and I've
actually the size constraint would take
care of not blank at least in the case
of last name because I've got a min and
a max for first name I just have a Mac
so I can allow a one character first
name but if the user leaves it blank we
want to still say please enter a first
name
and similarly for last name if they
leave it blank we want to say please
enter a last name instead of giving it
the size 2 to 16 characters and
constraints are inherited so if we
extend our person class to say we call a
class teacher the teacher needs to have
a valid first and last name with the
size constraints and not blank
date of birth and we've added a degree
which can't be no so message is each
teacher must have a degree you know
there's another tag on the met on the
constraint groups equals teachers class
and I'll talk about that in a minute
this is a way that you can control how
the validator works through a validation
you can I'll show you in a minute
there's a a parameter that you add to a
validator
when you want to validate certain fields
that you add a group to also I've got
another field certified so your teacher
must be certified we're asserting that
to be true if that's false then your
teacher won't be a valid teacher and
that interface teacher checks those
along with the the group sequels in the
in the validator there so I'm going to
add a course to continue the example our
course has to have a title we need to
have a seat count for the class minimum
of 12 we're going to assert that the
classroom is available and our course
needs to have a valid teacher
so then we'll go through a test I'm
going to set up my validator and then we
go through the test so the first thing
we do is we saturate a course we give it
a name geometry and AC count of two and
then we call the validator so that
validate or validate course and when we
call it like that it only validates
those constraints that don't have a
group design and so we're only
validating the name of course in the
seat count because those didn't have a
group tag on the annotation so we when
we run that validate our on the course
we're going to get a a constraint valid
violation on the steep town because we
only gave it two seats and the minimum
is 12 and then we set the seat count to
12 run the constraint they validate or
again against the course and we know
constraint violations so then we say
okay we need to have a room for our
course and we call the validator again
and this time we have the course checks
class to the validator validate and that
checks all of those validations that had
the course checks on the constraint we
get a violation because the classroom
wasn't available and then I can say set
available to true for the for the
classroom run the validator again with
course checks and I'll get
no violations so now we'll add a teacher
to our course call a teacher we've given
first name last name date of birth from
our person we give them a degree and we
set the teacher of the course to this
teacher that we just created you call
the validator with the parameter teacher
checks so it'll check the the degree and
also whether the the teacher is
certified and we get a one violation the
teacher must be certified so we didn't
set certified to true go to the next
line and certify our teacher call our
validator again with teacher checks and
we got no violations and then the last
step we call our validator
with all our class all of our groups of
validations default that should be
course and teacher checks so you can
also write your your own custom
constraint and when you do that it's a
three-step process you need to define
your annotation we need to implement the
validator and then apply it to field
senior entities yes
which is the
right what right and we are what the
what the bean validation last you do is
get away from writing that kind of code
everywhere that say you have a person
suit so it's it's not necessary to
so that's why I mean when you're seeing
these custom constraints on Stevens
about to talk about you'll see you could
actually define the battery regular
session validation within the constraint
and so the only the annotation would
just be email and you wouldn't be
putting the regular session there you'd
be putting it in the code that defines
the constraint in the constraint
validator so so let's talk a little bit
about dataverse we decided that we
needed custom constraints for our
dataverse basically the university's a
repository for data and it allows
researchers or persistent way to store
the data and allows others to find that
existing data in a different way and the
way that other researchers can find it
is what we call what's called metadata
which is data about the data and
depending on the field of study that the
data that pertains to metadata could be
quite different you know we started out
dataverse mostly for social scientists
we're expanding to the astrophysics and
the medical school and they have very
different metadata so what we decided to
do is at the metadata level to actually
save it all as strings and because of
that when you really needed to get a
validation
well as a custom constraint so so as I
said that there are three steps you
defining the constraint annotation which
remember we saw is like the not null or
sighs or whatever you implement your
constraint validator where you say where
you've described this is what makes the
data valid so I'll go through that and
then you apply your annotation to a
field on your entity so let's see what
it looks like first I'll go to the end
first so this is a an entity in
dataverse which we call data set and
it's got several dates that are metadata
to the data set I've got an acceptance
date and the annotation check date is
actually our custom constraint I've got
a deposit date which we want to make
sure is not like and it also has a check
date so it's got two constraints not
when I can check date that check date as
you see has a year-month-day format for
the day we have a publication date which
has this year and collection date we'd
have a string array of year and year
month so we're validating different
dates in different ways I'm sorry
because for these first size of the
database we were actually saving if we
had a say we've had metadata as one
table with however many fields there are
in certain disciplines there wouldn't be
data for you know hope columns of the
table so you know if we had a metadata
table that would say a thousand fields
long maybe in astrophysics they'd only
use 100 of those fields or less that the
medical school might use 75 but they'd
be totally different fields so what
we're doing is we're saving our metadata
as values and this table is going to
describe how that works in greater
detail but basically it was to keep the
size of the database down I'm sorry yes
yeah yeah that's something we keeps that
every sir okay so here's our annotation
which we are calling check date now in
these there are three required parts
there's message groups and payload
message is the default message if the
validation has failed groups is as we
saw in the previous is a way to
designate which validations are used at
given times if you call a validator
directly payload
payload is used by the clients of the
bean validation API to assign a custom
payload to the to the constraint and
we've never really used payload I see
some examples where they use it to
assign error levels and then our
optional is a springer ready for date
format and as we saw I don't want to
scream like yellow so we've come from
Boston East Coast time and I have a
application which makes it yellow at
night I'm not I hurt my eyes I'm still
on that
thank you if I we taken a string array
of date formats now we need to write a
validator class and the validator class
has two required methods initialize and
is valid our initialize we're going to
take in the date format that you add to
the constraint that I talked about
earlier and then is valid is going to
return whether our thing is valid or not
like I put all the validation code into
a separate method called validate and
here we go
so we take a date string we set boolean
valid equals false
now if the date string is linked 0 we're
going to return true because we've
checked not blank in it in a different
validator if our date spring has
then we loop through the date formats
that came into our string array and we
compare we have another method which
I'll show you in a second is valid date
which takes a date string and the the
string fourth or the date format so is
valid date brings in the the pattern of
the the data we want to check against
and the date string itself we call it we
create a simple date format from that
pattern we then try and parse our date
string against that date format if there
is a parse exception then that date is a
valid we return whether the whether
there's a parse exception if and that's
how we do the validation
okay so the next part of our talk is
about Crossfield validation and so the
rest of the examples will be custom
validators just like the one you just
saw but just different variations and
some more interesting things that you
might be able to do with them so the
example that Steve showed with
customization was validations on a field
level and one of the things that bean
validation also allows you to do is set
validation annotations at the class
level and the use case that we use and I
think the most common use case is when
you want to do a cross field validation
you have two fields on the class and you
want to validate one against the other
in the hibernator validator
documentation the example they use for
example is a car and you might have one
field that's number of passengers and
then the second field is a passenger
list and so you want to validate that
the size of the list is less than or
equal to the number of passengers that
the car can hold another example is if
you have two fields where you want to
validate that the second field has a
value is not null if the first field has
a certain specific value so and that's
the example I'm going to show so we'll
see that a little more detail about that
but to do these cross field and class
validations you can use a custom
validator again and so there are three
steps again are the annotation the
validator and using the annotation so
and we'll show the annotation first just
so you have an idea of what we're trying
to accomplish when we look at the
annotation and the constraint so in this
case we have a department and we have
it's meant to be a controlled vocabulary
and someone would pick their department
but the last value is other because you
know maybe we don't have your department
in there so in the case where someone
selects other as a department you want
to be able to Phil you want to require
them to fill another department field
and say this what the department is so
here you can see the annotation here we
call it not know if another field
you and in this case it has three
properties the name of the field that
you're testing its value that you're
testing for and then the field that
depends on it the one that you want to
make sure is not null in this case other
Department so here we have the
annotation code and it looks very
similar to the custom annotation that
Steve showed one of the differences that
ski is when you look at the target at
the top instead of being for a field
it's for a type annotation type and
that's how you define an annotation for
a class level annotation you can see
that it's constraint is going to be
tested by not null if another field has
value validator so that's what we'll
look at next and it has three string
fields field name field value depend
field name the ones we we saw defined in
the previous slide there's a section at
the bottom that's grayed out i grade
that out because I'll talk about that in
a minute but I wanted to not now focus
on it just yet so here's our validator
class and so we've got our Springs the
field name expected field and depend
field name in the initialized message we
go ahead and we get those values from
the annotation so that we have them
populated you can see that the parameter
to initialize is the annotation class
that we had just defined and then in the
invalid method just you don't just just
like any other how do you validate what
this is so in this case we're using the
common beat common bean utils package to
get the prop bean utils type get
property to get the field value in the
depend field value and then we just have
you know a standard if the checks to see
if the field value of the field
Department is equal to other and then
make sure that the other one is not null
so if it's no then you disable your
default constraint violations you go
ahead and you build your new violation
your newest message and you return false
if it fails validation okay so here's
the custom validation again and so now I
grayed out the first part and the second
part so what this basically is is it's a
list inside of the annotation and so the
reason you might have this is because
and this is at least the way I've seen
other people listed the standard way of
doing it is let's say you have two
properties that you want to test for
their value so here we see we have
Department and we want to make sure that
you know you can fill out to grow the
department
but then we also have the person's
position and we want to make sure that
if they select other in position they
can they have they're required to fill
in what their position is so in this
case like we use that in our list at the
top level and it includes a list of the
not null if another field has value
annotations okay and so our last section
is about dynamic data-driven application
which is our project the dataverse
dataverse is a software framework for
publishing citing and preserving
research data we it's open source and we
have it on github we run an installation
of it ourselves at Harvard and then we
also provide the software for other
universities or other institutions to
have their own data versus that together
they all federally and communicate with
each other and pass data from one of the
other the metadata back and forth and
the idea is it provides incentives for
researchers to share their data so they
can get recognition and they can get
credit we had data citations they have
control over their data and their
branding and they can fulfill data
management plan requirements a lot of
the funding organizations nowadays
require you to have data management
plans for your data and so dataverse and
repositories like it allow the
researchers to fulfill that so Steve
went over this a little bit but I'll go
into some more details so the basic idea
is we want to be able to support any
domain and and multiple research fields
so we don't want to define in the
application itself specifically that
what the astro data fields are like or
what the biomat are so we decided to
make it that we store that information
in the database and you can have
multiple blocks so we can have general
metadata block set available for all
data sets and you can see in this
example the citation metadata is one is
required for one thing it is one of the
gentlemen metadata blocks and that's
going to be things like title author
description keywords geospatial metadata
is another one that's generic and that
multiple different fields not just
social science will use it and things
like geographic coverage and country and
things like that but then we also want
to be able to have the domain specific
metadata blocks so social science and
astronomy and biomedical all have very
different fields you know social science
will have things like topic
classification astronomy cares
about redshift resolution and type and
facility and things that I'm not an
expert on biomedical wants things like
the design the experimental design type
and measurement type and things like
that so in our application
a researcher will define their their
internal repository is called a
dataverse so for their data burst
they'll pick which metadata blocks are
relevant to them so citation was
required but if I have a social sign-on
my was social scientist I'll select
citation and social science and maybe
geo special someone in astronomy will
select citation and astronomy and etc
etc so Anna made data block consists of
data set field types so actually so each
of those things up like I mentioned
title and author and geographic coverage
and experimental design type they're all
different data set field types and so a
data set field type needs to be able to
define what type of field it is whether
it's a day to float an email with small
text and big text in case it's a
something like a description versus a
keyword it needs to define if that field
is required and so one of the things we
also have to worry about is different
data versus different researchers may
have different requirements in my data
verse I may require you to fill in the
keywords while some other researcher
doesn't care so much and so it's not
required there are some fields that are
required at the application level things
for the citation like title and author
but then feels within the other blocks
we allow the researchers to have
separate definitions of what's required
or not the other thing is we dataset
field type will define whether it can
have one or more one value or multiple
values so for something like authors you
might have multiple authors and that's a
data set field type that allows multiple
description is one that there's going to
be one description for data set looks
like that and lastly our dataset field
types define whether it's controlled
controlled vocabulary or not some fields
are freeform some fields especially like
in the astronomy mint data block will
have controlled vocabularies so the way
we do this is we have this these dynamic
data tables and we have an API for the
administrators of the application to
upload CSV files tab separated values
of all the different blocks so when you
first install the software you'll upload
the TSV files that are relevant to the
research that you want though at Harvard
for example we're gonna basically have
all the different metadata blocks
available but there may be some
Institute that only cares about social
science or only cares about astronomy
so they'll load their own blocks and
they may define their own metadata
blocks set we are not relevant to us or
you know or want to add to the community
and they'll have at first but then share
it with us
so these files define those data set
field types and you can see this is the
file of beginning of the file for the
citation metadata block so you'll see
things like name author you've got the
friendly name and you've got the
description on the right and then it's
too wide so I put it onto two slides but
then the rest of the of the rows show
the different basically flags some of
these are for display purposes or
whether they're like display order for
example or whether it's used in search
or not but the ones that relate to the
validation and our important are things
like allow multiples does it true or
false if it's on the right you see
required and then on the left sorry I
should have said field type is one of
the main ones whether it's text or email
I think those are text box is the larger
description but you also have float and
dates in here in this example that we
don't see those three so then our add
data set page looks like this and so
this page is generated dynamically from
the data from those blocks and so
something like description here you can
see has the text box whereas something
smaller like title is just a smaller
field author has pluses and contact
emails plusses because they were ones
that allowed multiple for example and
down below you see subject and it's one
of the ones that has controlled
vocabularies so it's a set of check
boxes that you select which ones are
valid or not and in this case it's not
its controlled vocabulary it also allows
multiple which was why it's such a
checkbox list and not a select box so
this is the object model that we have
for this so down below we have the
metadata block and it contains like I
said one many data set field types now a
data set will use some
those data set field types but not
necessarily them and this relates a
little bit to what Steve was saying
about size if someone has a data set and
for whatever reason they've only just
decided to find title and author and
description which are required on it
then we only want to store information
for those and not for every single other
data field that they're not using
especially if there are blocks that
they're not aren't relevant to them but
are still relevant to their dataverse so
that's what dataset field is like this
this chart should have data set on it
but it doesn't but data set field is the
join basically between data set and data
set field type so if you have that data
set field type in your data set there
will be a row in data set field and so
then a data set field being the deputy
for instance will have one many rows and
data set field value depending on
whether that allows one or multiple
values in it I won't really talk too
much about data set fields compound
value but we saw in the previous slide
where up.there consists of name an
affiliate and identifier so it's one
field that is actually compound and
contains some multiple fields and that's
one of the other things we had to deal
with and some of our logic is based on
that but it's you know it's a detail
that's not as important so one of the
things to note is that you know there
are two main kinds of validations one is
validating the format of things if you
have an email make sure it's you know
something at something dot something and
whether it's require or not but because
there can be multiple values for
something so you can have multiple
contact emails we can't really test if
data set value itself is required or not
because one value might be but a second
one might not and the folk the form is
going to have multiple rows one for the
value and one for other ones if they hit
plus but those don't actually need to
validate as being required they just
need to validate if they typed in
something that they're valid so the
reason I bring that up is one of the
things we've done is the validator that
I'm going to show you that we defined
for this is used for both data set data
set field value and for data set field
and the idea is on data set field value
it will do the value up based on the
format whereas on data set field it will
do the test to see if it's required
because I guess that if you have
or more values of that data set view in
that data center if you'll have a row
here so we can check to see that you
have the row there and make sure it's
required that you have some value so
again we'll show the third step first
just so you see what we're trying to do
so here are two classes data set field
and data set field value just to make
life easy we decide to use one
annotation for both so we have the
validate data set field type annotation
on both these two entities and here is
an example of our annotation it looks
just like our other customers you can
see the target is type and annotation
type it's got you know the message and
the groups and the payloads that are
required for the interface the one
interesting thing and that it's bolded
is that under constraint you can see
instead of just saying validated by one
class here we have validated by data set
field validator or data set field value
validator and so he is one annotation
can be used on multiple classes and can
do different validations depending on
what's valid for each of those types of
classes so here we see the validator
class there are two validator classes
like I said so this is the data set
field value validator you can see that
it has the validator dataset fuel type
as its constraint valid air up here it
has an emotional eyes message just like
any validation like any Valley excuse me
and here's the is valid method and so
you know given the data set field value
we can get its data set field and we can
get his data set fuel type which we
soften the TSVs and then we can check
the field type and then we can test upon
the field data type so in this case I've
only included one of the if statements
but basically if its type float it
checks to see and it you know bills the
constraint violation and says you know
your whatever it is is not a valid
number there within the other ifs for
the different other fields field types
for date and int and text and to check
the size and things like that
are they require or not
right so they're just the fastest to
repeat the question so the question was
if we put all our validations in two
methods one that has the validation for
format and one that's per required then
yes in two classes exactly these and
basically in these two about data
classes correct you you define the
annotation saying that annotation uses
these validators and you present to the
right as the annotation but exactly
exactly so here's the under validator
this time the constraint validation the
validator is validate dataset field type
and this is the one that checks for
required one of the other things that
was useful for us and I forgot to
mention earlier when I was a spamming
dataverse but besides just storing
values we also allow researchers to
define templates for their data sets and
so the idea of template is to set some
default values so if all their data sets
are going to have the same author they
can define a template with that author
prefilled and things like that they can
also use these templates to define
effectively watermarks and say please
enter date or something like that in one
of the fields so whenever you have a
template we don't really want to do any
validation on it because it might not be
a valid value if you're using it as a
watermark also the template doesn't care
if it's right or not because they're not
going to fill out everything in the
template necessarily and so just one of
these things we see in this validation
is this line here I should have line
numbers and sorry about that but besides
checking to see if the type is required
we also make sure that it's not from a
template because if it was from a
template we just skip the validation and
go ahead and say it's fine but if it's
not from a template it's from a data set
itself and it's required and the value
is null then we go ahead and throw our
exception or students throw our
constraint about violation so here we
see an example of using it and basically
one of the things about using these
class level class level validations is
that one of the nice things about being
validation is when you apply it on a
field it works automatically with JSF
and will
throw the make some error messages and
all be handled in the case of the class
level ones since it's not tied to a
particular field
it doesn't actually get tied to a
particular field and also in this case
it won't actually run the validation if
you don't tell it to do parent
validation it doesn't run the validation
until it actually tries to go through
the persistence layer so for our
application one thing that was important
is we want you to test validation before
we actually even try to get this versus
layer because there's some other things
that we do want to save that are
non-transactional if they've uploaded
files and things like that which were
saving files to the file system and so
we didn't want to have to you know
reverse any of those steps so we go
ahead and we called the validation in
the save method is the very first thing
we do so here's where we see we get the
validator I'm going to show in the next
slide the calling of the validation but
basically if it fails a validation we
said it boolean to don't save and we go
ahead and just leave the save method if
it succeeded we go ahead and continue
with the save process and save the files
and do all that so here's the validation
code and so this is fairly standard when
you call the validator but basically you
get the validator and you call validate
we we basically iterate through all the
data set feels and we look to see if
there's any validation there which would
be the checksum required and then we
break well this is not actually there's
some like code that we're gonna see in a
second that has to do with the messaging
so the break isn't really relevant just
yet I apologize for that but after we
check the data set field we then go
ahead and go in if you passed the
required validation we go ahead and
check the values themselves and do the
validation against the actual formats
and so this works well and you can see
that if a user's tried to save the data
set page and they didn't fill out any
information you get these validation
messages on top saying you know titles
required and all the things that are
required if I filled out one of them
with and like the email what that mean
about email the error message would be
that instead but one of the things that
we have a usability expert on our team
and one of the things is you know these
messages are nice but they're not very
usable because it's nice to have inline
error messages obviously like you
instead of having it find where the
title is just from the top you want the
error message right on title itself etc
etc but like I said because this is a
class level validation it's not
automatically tied at the field so what
we did to solve that for us is on the
data set field and a set field value we
added a transient property called
validation message so it doesn't get
saved to the database since it's only
for the you know validation at the UI
level but we had this just string and
then here is where we see that if it
fails validation we go ahead and besides
just passing that message to the basis
context so it would show up on the top
we also set the validation message on
the dataset field itself or on the
dataset field value and that's where the
break comes in because we only support
one message so as soon as we find some
reason why there's something wrong with
that data set field we go ahead and we
leave the loop so that we don't have to
just process all the different messages
that might come up in the values as well
and when we look at the page we see here
now we've got the nice inline messages
titles required or below title author
name right down here and contact email
right below that field and if I could
scroll here you would see the other
error messages next to their respective
fields so and then here's an example of
using that same validator with the API
that we have so at the top here we have
a drive for running a command and so
commands is how we deal with our
permission and authorization model in
dataverse and we'll actually have a talk
a little bit later by one of my
colleagues above tonight if you're
interested learning more about the
command structure we'll talk about that
on the last slide but basically the
command tries to run and then when it
goes and if it throws an exception
because the you know it doesn't pass the
JPA it does the same checking through
the constraint violations to get the
violation violation message and here you
know it's not a UI so we don't need the
faces message we don't need that's our
special property but it gets goes ahead
and gets appeal to a string builder and
then that gets returned back here with
the error message that gets sent to the
API down there
so that's our talk later today like I
said we actually have two buffs ripped
by our colleagues so Phil and Michael
here in front row will be giving a talk
on lien beams are made of this the
command pattern versus MVC and that's
talked a little bit about the command
that you saw in the API that we just saw
and then our web designer and developer
Mike will be giving a talk at 9:00 about
when the prime faces bootstrap theme
isn't enough so there's our contact info
the code is available the dataverse code
is available at github if you want to
check it out and you can check out our
site I take a science and if you have
any questions that don't get answered
during this talk you can also email us
yes you can definitely use the resource
bundles you can also use syntax to make
it dynamic so we could say instead of
saying you know email is invalid they
could say this email and like right you
know you wrote a dot blank is invalid in
that but and then you can also
international is it through a bundle
message and we'll be doing that we just
we don't have any samples because we try
to keep the samples simple
with that sorry yeah so the question is
about supporting localization and
through message bundles just and even
through the hybrid hibernate validator
and the standard ones you can provide a
message in the annotations and that
message itself can be using bundles so
it doesn't it's not just for the custom
ones but also for the standard ones ok
so the question is about using in the
JSF and also about the performance so I
mean we haven't seen issues with
performance on this there are other
things in application which we've had
performance things that we're trying to
resolve but not in the validation
we are
okay does I think that's interesting
idea and part of the discussion the talk
was to also hear ideas of what other
people are doing that this is what you
know through trial and error what found
worked for us at least the point we're
still working on it but I also wanted to
see how other people are doing like I
said more complex and interesting things
in bean validation besides just the
standard one so I would I would actually
would like to know more about what you
did and you know maybe email address
right so the validator had run but
because there was a class level
validation it wasn't tied to any of the
particular fields on the page it was
tied up I was a class level validation
yeah right they're talking about this
right so this might not be clear this
particular sample is not validating from
the UI this is if you're using the API
so it's you know our second hook into to
saving the data so the first example was
calling the validator from the UI this
is calling the validator from in this
case of sort API but
I don't think you can I think it I mean
if you if you define the annotations on
the entity then you I don't think you
can turn that off you just have to do I
think what we did which is you know
don't get to that level I think I mean
if you wanted to not have it I guess you
could define their annotations not at
the entity and somewhere else but we
wanted to define at the entity because
we wanted to catch it like basically not
allow anything to get saved even if you
know as especially as we're coding if we
forgot to do something make sure it
didn't get through and then we'd see
that every like oh we actually have to
you know provide this validation call
somewhere earlier in the stack right we
have not looked into that but I think
that sounds like a good idea yes back
there if you have a beam references
so there is also one of the standard
annotations I think is um at is valid
and if you put that on your field then
that will cascade down the validation is
my understanding
okay and what was it was called just for
the microphone it was called validator
collection okay now they rush me a
github anything else
well thank you and if you have any
further questions feel free to come up</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>