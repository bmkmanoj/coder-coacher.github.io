<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Runtime Code Generation for the JVM | Coder Coacher - Coaching Coders</title><meta content="Runtime Code Generation for the JVM - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Runtime Code Generation for the JVM</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XMY6HA7_h5Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay thank you all for coming I'm very
much aware that are very very good
sessions parallel to this session so
thanks for choosing this one and I'm
also competing against San Francisco
weather and Oracle sponsored beer we're
talking about runtime code generation
today and I'm Rafael I maintain of a
library called zg lip not the core
maintainer but I'm a regular contributor
and I'm also the creative another
library called bite buddy both dedicated
to actually this matter and what I'm
here for today is and first of all I
want to introduce you the matter of
runtime code generation I want to
explain to you why we actually need this
why this is something that adds value to
the Java platform and how you can
actually all use it for you applications
run time code generation is nothing that
needs to be very specific to a very
complex libraries at something and it
has to do with Chavez type system and i
also want to talk a little bit about
java type system in this context also i
want to introduce you how you can
actually apply runtime code generation
it's not that hard actually so I want to
go through some libraries like mine and
of course the others that are there and
basically explain some of the ups and
downs of all of these implementations
all right let's just look at an example
in the beginning to understand why we
have to deal with runtime code
generation in the first place you might
recognize this in a more abstract manner
from spring security I don't know if you
guys have worked with spring security
for those of you that don't know spring
security how does it work spring
security and has a holder clause which
contains one static filled with a user
in a way it's a more complex than a
string in spring and but it is in the
core ideas exactly that so we have a
user that is currently locked into an
hour application and then we have this
annotation called secured and what we
expect spring security to do for us is
to check if the specified user in the
annotation resembles
user that is actually locked in in the
moment and only allow the application of
a specific method if the method is
annotated so let's look at an example of
this like let's say we have to service
and we have a customer the customer
wants us to implement this functionality
so he wants to press this button when
he's logged in and delete the entire
database that's of course a very yeah
security critical functionality because
if it goes wrong if you can add some
extent trigger this method invocation in
a way you didn't expect it you have a
serious problem because all the data is
gone so what we want to do is you want
to have this secured annotation on the
method and say only the administrator is
allowed to do it but how does that work
how does how can we implement the
framework like that in Java well as an
annotation that's just metadata right
it's there but the runtime the child
runtime doesn't do anything with it it's
it's just information that we can read
out from a library like the one we are
trying to write here so we have some
promise in a way we want to take any
type or cloth and allow its security so
we want that if this method here is
called you want that in this case that
only the invocation is only possible if
the user is correctly logged in but you
guys might already know notice a problem
here well we have this framework method
that promises to take any type and this
service type is only existing outside of
the library writing so we have these
boundaries we have two jars probably we
have something like spring security and
we have our application and obviously
spring does not know about our
application how would spring know our
service we would have to call them in a
way and say like hey listen I have this
new class you have to look at that it's
not automatic that's of course not a
feasible approach and but at compile
time spring does not know about about
this is it's just reality that's
something we have to deal it with and we
only have the other way around our
service can rely on the security library
but not the other way around however
once we start a java application and
both of these libraries will be on
classpath and then our framework has a
chance to discover the service class at
runtime and basically that's the core
idea that's why we need runtime code
generation sometimes we only know about
classes at runtime but not at compile
time and of course I said before that
isn't something you can use you might
argue of course I know all my classes I
can put them into the same project but
you might have a project this is big
enough to actually yeah take out some
cross-cutting concerns like security
it's like logging like caching into
something else where you want to
basically offer the same API across
projects and then you can also use
runtime code generation I'm in a bit i
show you how all right so how can we
implement yet this feature how can we
implement security well it's it's not
that hard actually we have this admin
and that should be logged in so we just
compared to the currently logged in user
which is represented by the user holder
it's just an equality check of course we
know how to do this in Java this is
trivial it three lines of code and one
is just the brace so um we could just
put it in there but we don't want to put
it in there we want to redefine it and
we want the security library to take
care of this implementation detail so
what we can do we can actually just add
a build time instrumentation so we can
just use maven and tell me to inject
this code into our method or we can even
use a java agent to do this for you java
agent hooks into a class loading
procedure and basically allows you to
map a clause to another clause where the
original input would be this service and
the the output would be this rewritten
service and this is impractical
sometimes because of many times actually
because build time instrumentation it
takes away a lot of flexibility it's not
really run time code generation it's
it's in between run and compile time
code generation the asian is better
already but many people dislike it i
don't see really why but it takes you to
it forces you to do some special kind of
configuration because the agent must be
on the agent path not only class path
and
some tools don't support agents that
well so an alternative is to do a list
go of substitution in a way we create a
subclass and if you compare these two
does look very very similar so instead
of of basically putting this into the
method we just override on methods that
have to the annotation and put the check
in the beginning and only if the check
succeeds we call the super method but
then represents the actual
implementation so of course this is also
very feasible approach and spring
security which I mentioned does exactly
that when you configure a spring bean
then spring doesn't return you your
classes it returns you over Britain
classes where all these annotations like
transactional or secured are then
applied in code so that basically what
we before had just the intention as a
yeah a declaration is this only a
declarative programming we just declare
what we want is turned into an
implementation so we've basically face
from the metadata the declaration to the
implementation which is imperative but
can be understood by the Java Virtual
Machine okay of course this approach has
also downsides and you in a way break
class identity suddenly we have a skewed
service instead of a service if you call
get class somewhere in your code you
will probably have a problem at some
point and this is well known and well
documented if you just go into Stack
Overflow dead dozens of questions
dedicated to this divergence because the
transparency is not perfect obviously
let's do some char 101 in this context
so how does how can we apply this code
generation how does it work in the end
or why does it work it doesn't exist in
many other languages why is that well
you all work with one of these languages
I guess so what happens we have source
code and we compile it into bytecode by
code as an intermediate representation
and these compilers basically shift all
these languages into this common format
this common format bytecode java
bytecode is the language of the Java
Virtual Machine and it's standardized
and that's really good for us what we'll
see in a second and the spy code is
taking at runtime by a class loader and
is then loaded into
jvm and its first interpreted and then
it's just in time compared it might not
be that obvious in the beginning but
this is really good for us that it's
just in time Capades and the fact is
that Wendy generate code for the JVM and
that's the fact that we don't have to
optimize it and the Java Virtual Machine
is already a very highly efficient
optimizer itself it could generate
machine code it's also a sort of code
generation it's just in time computation
we don't have to take care of that we
couldn't imitate it it's like the JIT
compilers very very powerful piece of
engineering a simple library couldn't
basically produce the same results
however we work on this bike code level
and this is byte buddy it's my library I
just yeah it's a product picture it
creates byte code and by code is way
simpler than actual machine code and
even more important it's not only
simpler it is platform independent so if
we create bytecode it is supported by
any java virtual machine outside dalvik
so so Android breaks this model that's
why why we're oracle and they had
problems so I'm but the thing is we can
create classes and we can also read
classes it's a standard format so we can
go into a class see what's there we can
find okay here's an annotation and let
me just add the the imperative code we
wanted to do and even better it runs on
the same java virtual machine so we
basically we write an application and we
started then the application gets loaded
and it can rewrite itself at runtime so
while the application runs it kind of
Hans itself in its the same session so
we don't have to restart or anything the
instead that application basically
modifies itself to implement the
behavior you expected and I promise you
that any application you write any
enterprise application is built like
that and I don't think in my entire
career have seen an enterprise
application without a java ccg lip or
bite bite but not that much yet but
it'sit's rado new but any of these
libraries on the class spot okay um yeah
you might ask isn't this what reflection
is meant for you all know these
interfaces get the clear method and then
we can invoke the method
of course we could just basically offer
some sort of wrapper and we can
implement our security library by just
saying okay we have two sterile
interface and you can invoke any method
and then we will just get get the method
but I was described we have its name and
parameter types and we can check the
annotations that are by on this method
and then we basically throw an exception
if something goes wrong the big issue
with this is that this is not longer
typesafe you can pass in just any name
you can change a name of a method it
won't be linked to that one the compiler
won't notice anymore you might have an
IDE that helps you with it but in
general it's not a good idea we want the
compiler to basically verify that the
only call methods that exist and are
visible so this approach basically takes
away type safety and type safety is in
the first place the reason that we like
Java that much it's it's good for
business applications we can describe
things and if you basically do something
that's not supposed to be done then the
compiler gives us a warning all this is
taking away with your reflection API and
I'll talk about in a second but it's not
about performance it's really not about
performance it's only about type safety
and Chavez the type safe language you're
going to keep it that way okay yeah and
another thing is that yeah this is not
fail fast if we have a problem and with
our reflection approach if we might just
get a right to clear method but we
passed the wrong arguments we will only
get noted noticed the latest possible
point at the invocation well then we
generate code it will at least warn us
at class loading right when the
application starts up it will tell us
there's something wrong there's some
constraint the JVM cannot fulfill any
more so the type enhancement is really
the best approach here and other people
might argue there it's just three lines
of code right why can't we put it in
there and well in the worst case you
have to struggle testing because now
before you can run a test on this method
you have to initialize your security
context and you have to take care of all
of this and second of all this is
supposed to be an implementation detail
when you write a business application
you want to take care of what this
business application actually does
you want to delete everything you don't
want to do a security check and it's
easy to do it wrong it's really it's
easy to basically forget about it if you
change the implementation at some point
so it's really it's it's not about being
lazy here but by overcomplicating an
approach it's about a clean code alright
and yeah testing of course and then
again another argument against code
generation is this black magic hi pada
pada difficult word no native speaker
you know what I mean it's about you
don't want to mess with these things
that are intrinsic to the JVM and but
again with Java code generation it's
it's not unstandardized java bytecode is
a very well-documented format it's it's
it cannot break it's not calling
internal API to start using the unsafe
or anything it's a standard approach
it's like a compiler it's like instead
of using Java you use groovy but it's
it's a DSL 44 it's a library that's run
from an application you just delay the
creation of code to a later moment and
we notice from like javascript
javascript is a very good example for
why people like this or you know it from
any dynamic language in a dynamic
language you can just call delete
everything and on any service it doesn't
have to be this instance if we have
annotations we could just that actually
the extensions to JavaScript annotations
but if we basically add some meta data
to to JavaScript it would be easy to
implement because we could just iterate
over all the methods and just pass any
object into here where we have a method
with the same name and the Java we can
to a certain extent do the same thing
when it is the best way to approach a
problem but we still have type safety so
we get the best of two worlds with
runtime cogeneration away we get static
type safety and we get the flexibility
of dynamic typing if we use it right so
what we have here is stop typing in a
way and we can emulate that in Java and
I'll show you soon how yeah and it's
yeah dynamic languages this is a common
pattern and what we do like this
annotation thing you want to declare
something you don't want to basically
constrain to your type and we just move
the dnc essential parts to run time and
you might be surprised
how common that is it's just here's some
libraries that couldn't work without
runtime code generation I mean I
mentioned spring already how it works
with spring but consider hibernate how
does hibernate know that you call a
setter how does it know that you call a
getter that should return some lazily
initialized value well hibernate takes
your beans and overwrites them or even
enhance system it has two modes and
instead of just calling the field gather
or the field setter it calls some
intrinsic hibernate logic and it's all
done transparently to you or mojitos the
framework I have worked with recently a
lot they what they do they override all
your classes any class you give them
they create a subclass and insert empty
implementations of any method so instead
of calling the method that you actually
implement it you call something empty or
not empty because it can still trace it
of course but close to empty it doesn't
do what you expected to do and juice is
just another example for for a
dependency injection container
eclipselink similar to hibernate and the
Play Framework if you if you look into
the Play Framework at the worst version
one it get better much better in version
2 because scholar took away some of the
constraints of types wherewhere play too
was implemented in Scala buttplate play
one was a big code generation machine in
the end clover open heb wicket they all
run only because of code generation and
yea even the OpenJDK is is mainly lambda
expressions are created at runtime
it'sit's cogeneration all right I'm cool
new shiny toy and you might be yeah
tempted now to use this for everything
and that's why I have this slide and
thus next slide two things that you
please never use code generation for and
it's unfortunate that many people do and
it's actually the most popular reason to
reuse code generation for many and the
reason is that people Google things or
ask on stack overflow and and you will
discover things that were true for four
years ago so don't be surprised if I
tell you something that someone else had
told you in the complete opposite
you might be tempted to see here if you
worked with co an aesthetically compiled
language let's say you have a method
here and you compute it with some
constant value then you can basically do
some constant folding right you could
just take this value of this method and
put it in here you could generate code
for that and you might expect that your
application runs faster afterwards
because you have not don't have to
dereference this method can just take
the value and put punch them together
you might even do some more
optimizations if there's something more
on constant value well as mentioned
before the JIT compilers already a very
very efficient optimizer and code
generator it does exactly these things
and jit compiler and only the JIT
compiler should be responsible for
anything so don't mess with it knows
what it's doing and on the opposite ice
there are despite code optimizer you can
pay a lot of money for them and if you
look at the code they create and if you
look at the machine code afterwards it
comes out it's often even less efficient
because the JVM recognizes some patterns
of the Java language and yeah it's
basically knows a good way to optimize
them if you optimize the by code you
take away information sometimes that
would have needed to make an improved
version of this yeah original method is
superior java bytecode and another
popular reason to use code generation
which is even worse in my opinion is
yeah reflection and that's the smith
that reflection is slow or whatsoever
and there might be some cases where
reflection is of course slower than
native invocation but it's not connected
to to what people claim it's not about
security checks it's not about
dereferencing it's not about these in
directions the reason why people claim
that reflection is flow is jay and i and
reflection is implemented by by doing a
native call into the JVM and that's not
slowed by itself Jane is not slow what
is slow is that this is basically a
context break the JVM the JIT compiler
has this piece of predefined machine
code and which it cannot long optimized
maybe the method call is necessary if
the method call wouldn't be necessary it
would just remove it
and it can't do that with ya native
calls because it doesn't know which
method is called of what happens it's
it's native code it doesn't know about
it this is however different with byte
code and the JVM is smart enough for
does the jvm engineers are smart enough
to apply this method so they replace
after a certain threshold but default
it's 15 they replace the native
invocation with a generated method
exosome that that is exactly what what
some people do manually they do generate
bytecode to replace reflection while the
Java Virtual Machine is doing exactly
that and if you don't believe me I have
a link to my github in the end I have
wrote a very comprehensive benchmark
using state-of-the-art techniques that
really compares all these methods native
yes now that's a very good point if you
look at the benchmark we're talking
about nanoseconds here so it's really if
a native call takes 30 nanoseconds then
the reflective call might still take 30
32 and a half nanoseconds that's very
few nanoseconds it's not a good enough
reason to optimize if you do with SQL
call its its dimensions it's like
walking out of this room and flying to
to moon it's really don't don't go there
and you can you can set actually the
inflation trÃ¨s hold on the JVM and it's
by default it's 50 and so after you
invoke a method reflectively 15 times
and it's optimized the reason for that
is that in the beginning you don't want
to generate the bytecode this takes some
time by itself so if you have some
bootstrap procedure like spring for
example call some methods to create
objects and those are probably only
called once and then it's discarded for
the rest of of your web web applications
lifetime and yeah the newest type these
days shouldn't spend too much yeah but
this one we can take in the newest hype
these days is using method handles to
optimize and look at the same benchmark
I wrote it's not faster either if you
run it on a recent JDK method handles
are exactly equally fast and then
reflective coded I mean many of these
these optimization assumptions are based
on the idea that the people that
implement the JDK don't know what
they're doing because of course if
method handles will be faster than the
reflective code there would be a chance
to substitute these two or internally
and just from this percent effective and
otherwise look at the benchmark the only
reason where you can actually squeeze
some nanoseconds again is when you use
boxed types instead of primitive types
and because this heap allocation is
difficult to optimize and we talked a
little bit about us in the end as well
but it's really about boxing it's not
about anything else so if you're
basically library code applies some
boxing on the way to the method call you
don't win anything even by Method
handles its anything else is simply not
true okay so never optimized by Scott so
I hope I saw a set is clearly enough and
some used use it to replace G and I
internally but the thing is if you you
really create code to replace Jane ID
and you shouldn't have used chain I in
the first place never use chain I if you
can use something else let's do some
some very basic yeah look into what byte
code looks like and I don't want to go
through the details of byte code as
other talks on that matter if you if you
find my name and I gave a talk three
weeks ago at javas own about exactly and
how byte code works how Piper's Quebec
was implemented and the reason we need
to notice is because if we create coded
runtime there's no java language anymore
the Java language only exists on the
source code level at runtime we have to
read and write byte code so this is the
universal language of the JVM how is it
translated the method like that let's
look at the simple methods the first
thing we need to know is that the JVM is
a stack machine stack machine or don't
really exist anymore but you might
remember them from university or from
from learning java bytecode so how does
it work we have an operand stack and
what we do on a stack machine is that we
push values and we pop values from the
stack we don't do anything else so like
this method we just add one and two we
first push the one value then execute
this first instruction then we push the
second value which is this and
action and then the I add instruction is
defined to pop the first to wendys on
the stack which are conveniently the
only values on the stack and push back
the sum of both so basically in this in
between here control is hand to the
processor then dusty like runs the spit
pattern three atoms and you will read
out a returning value and we missed them
the return statement and this is yeah
basically just consuming the top value
from the stack and pushes it out of the
method so there we did it we just
implemented bytecode or a java method on
by code level as you might notice this
is not really really readable it's it's
a little bit messy to work with it's not
hard either java bytecode is not hard
many people say this now by the way it
it's called bytecode because these are
only symbolic names and those are
actually the bytes and it's not hard to
do bytecode it's very similar we have
the same type system or nearly the same
type system here the I just indicates
it's an integer and but it's still it's
still a lot of work to translate it
because once you change things this is
of course we much more concise than that
so how do we do this well the easiest
approach is to use a library like ASM
SMS maybe they're probably the most
known cogeneration library it employs a
visitor pattern where you basically can
eat a register with it and then this
method will be called in the order of
basically them if this is the method we
would get calls in this order or if you
want to write a method we basically just
visit these instructions in order and
this is where it gets messy well we want
to use code generation to employ site
type safety and with using ASM we lose
all type safety of our application if
you write this this is type safe if we
do a mistake we are told that
compilation time if you do this it's not
longer type so if you could just shuffle
these method calls around and it would
still compile and we would get an arrow
once we load this cross so a by the ASM
is extremely powerful we don't want to
use it if not absolutely necessary and
there's another API a tree API which
does a similar thing but it you
lists instead of the visitor pattern
okay so while ASM and I mentioned bcl as
well and bcl is a little bit forgotten
unfortunately SMS is a project of a
French Research Institute of lbc els and
Patrick project and bcl is not so bad so
if you know ASM have a look it actually
for analytics bcl I would I would claim
my personal opinion bcl is more powerful
and people use ASM because it's faster
but again we talked about nanoseconds
here so don't really see the argument
it's its class generation if you I think
in 10 seconds you could generate that
many classes that it will completely
blow off your jvm so it's not really a
matter of yes no it's it was very slow
in a while but just recently it's it
gets more more activity again um okay so
as I said by code level full freedom
that's great sometimes we need that
however you need to know the JVM you
need to know its type system which is
slightly different than that of Java for
example there are no boolean Stano jarno
snows short and these small types are
simply merged let me have the spec
metaphor you have to basically compute
against different sort of interface and
thats it's tedious and it requires a lot
of manual work it requires you to for
example compute stack sizes the stack we
saw before had two slots it was just
enough you could have said that jbm just
give us 20 slots would have still worked
but it would have been wasteful and
recently with java 6 they introduced
recently but with java 6 they introduced
stack make frames which were required to
do validation more efficient and it's a
good concept there's a slow level it
should class loading should be fast and
without stack make frames class loading
could take quite longer than with with
them but it's also something we have to
compute and even code generation
libraries you might remember when I
think was easy mark easy mock didn't
work with Java 7 in the beginning and it
was because there was a buck in the
computation of these technet frames it's
really hard to get right I think even
ASM they needed three versions to get it
right and they
know what they're doing normally so it's
a complex concept and we want to avoid
it and the set by code level ap eyes are
not type safe what is of course a remedy
um yeah and a little expressive so a
good thing is low of it low overhead is
always good if you get it for free but
sometimes it's just too expensive and I
exam they also mentioned that and the
OpenJDK is using ASM internally it use
that for nice one for example it uses it
for creating lambda expressions so ASM
is maybe coming public API in the end
basically to offer something that the
dotnet platform CL are offered for long
while an interface yeah ok I just I just
picked it up from the mailing list one
day that they consider it ok yeah it's
it's may be smart though because he
thinks thing is my job is very backwards
compatible a byte code is not and that
brings us or last point the versioning
in ASM is terrible it's especially from
version 32 version 4 and it costs a lot
of libraries to break because if he had
version 4 on the cloth path it would
break version 3 where everything in
version 3 was an interface and in
version four it was suddenly an abstract
class of course all the basically
interface extensions wouldn't work
anymore and the whole there everything
would blow up so until today the the
implementers of a sem recommend you to
repackage the entire library into your
own namespace when you use it and that's
painful because you need special tooling
for byte party for example air to
migrate back from from Gradle to a
maiden because cradled the shadow plugin
for Gradle doesn't really work as
expected sometimes that wasn't fun I
tell you it's never never nice going
back to something older so with all
these downsides let's get to our next
approach the next approach is the
library called Java system Chavez had a
really good idea they thought like okay
we want to express Java code and what's
a good way to express Java code well
well it's java java is a good way to
express java obviously so let's just
take Java and what we want to do it at
runtime so what we do we put it in a
string and there we go and Java says
takes these implementations at runtime
you just build them together and then it
has ADD runtime compiler that compiles
his method and you can inject them into
your classes big problem here and it's
it's really a big problem and that's why
I don't recommend anybody to use Java
steven though the ideas really go
tonight admired if you all use jdbc at
some point what's the problem with jdbc
well its strings SQL is very type so if
it's a it's a beautiful language SQL but
SQL we are java or any string interface
it's not very nice anymore because you
have to do these concatenations we just
put strings together and the biggest
problem is security it's what you have
an SQL injection you suddenly have Java
injection and Java instruction is this
verse SQL injection i can tell you
because let's say you process some some
input from a user and the user happens
to to be called access controller do
privileged system.exit or something you
then you obviously have a problem and so
you have to parse pretty pass user input
escape Java components and nobody does
it nobody hibernate users travis's they
don't do it and I don't say that
hibernate itself is a security issue but
if you have untrusted code on your cloth
path and they know about hibernate using
Java sea's they can just put some really
ugly things into your library and
obviously debugging isn't really easy
with this this can't be linked by your
IDE how would the IDE know that you set
a breakpoint in the string you can't set
us break down the string and that breaks
this model and especially with debugging
later on if you have stack traces of
exceptions they won't know where they
come from there will be something
generated something line number unknown
and that's all you get because even if
you could read it here clearly it would
disappear m
at the debugging level because it's
simply not linked and even worse you
bound to Java as a language if you are
on the boat with Scala or closure or
whatsoever and this is Java even if you
write Scala code and all the interfaces
are scholar optimized you suddenly have
to switch your language just to
implement the generated code and you
would prefer not to and my number one
problem besides security is the problem
of the compilot insane work to implement
compile and kudos two jobs just for
doing that but Travis is run by one guy
and while the Java Sea is run by
significantly more people than one one
person and of course the Java cysts
compiler legs behind Java more and more
and what you don't have these days is a
long list you don't have all the boxing
for example and trousers you don't have
yeah all the Java 8 stuff you don't have
flung de expressions and it won the all
the coin and advancement they're all not
in the project and it's unfortunate
because you have to think bytecode off
more you have to think of how is dead in
Java for because that's approximately
level where Chavez is currently situated
then additionally to that sometimes
let's think back to the example where we
call a super method what is a super
method need it needs to get all its
arguments and then you would have to
parse all these arguments you will check
to check for the names and pass them
that's not very convenient so Java syst
added some special instructions to the
jaw language and i'm not i'm not a big
API design of myself but they'll call
like dollar dollar something-something
dollar dollar and it makes them make the
code look look nice it's it's not very
intuitive all the time so by this
approach is certainly from my view and
it comes from a university it's a very
very good idea it's not completely
approach applicable in a enterprise
context so we move on to cg lab and see
chillip we're just looking back at the
method we saw before and the delete
everything method and we
implemented it and by a subclass a huge
fall back from CT Libous that it does
only support subclassing you can't
redefine methods using chi Chi lip and
all so CG leave is internally built by
SM it's just an implementation detail
but just as you know all right and so
how do we implement this this class in
CG lip it's actually quite easy well cg
lib overrides methods and delegates them
to an interim instance of an interface
and this interface is just called method
interceptor and interceptors always the
same signature basically we get an
object we get a method an array of
arguments in a method proxy so what
happens basically yeah we get a method
reference so we can read out the
annotation we can know what users
supposed to lock to be locked in its
administrator um you can get the slides
online by the way it's it's all creative
comments so you can take pictures but
yeah it's probably more convenient for
you to read anyways um so method is of
course just the reference as we know it
from from the java reflection api i'm
not so bad then a problem obviously so
that we want to call a super method and
we all know from java it's only allowed
to call a super method from inside of a
clause so how can we if in an instance
of method interceptor call a super
method well and Gigi lip has an
interface called method proxy in a
method proxy is basically a proxy for
super method calls and how does it work
well it just adds an inner class in a
way it applies in a class semantics and
exposes the super method calls where we
earn a general interface so by calling a
super method you just go into this proxy
this proxy is another class and in a
class can just call the super method of
its outer classes internally it's
implemented using accessor methods to
citizens in scala java so as we can see
here we have all these arguments and we
set basically we get an instance of this
this is just the object then we get the
method that is overwritten here no
problem I know you don't have any
arguments so we just get an empty object
array
and we get an instance of this method
proxy we defined so all good right my
biggest critique with the G lab is that
it basically discards any type safety
and yeah when one has to say it's G lip
was written in Java 11 days that's long
long time ago so it didn't have the same
nice features like annotations and and
and generics that I now have accessible
when I basically implemented bite buddy
what is in a way men dozen succeeded to
cg lip but still it's it's it's
unfixable the API is now you can't
really extend it and but there are more
issues I have with digital been after
working in a lot of open source projects
or working together with people that use
the g lip and open source projects i
basically identified some some core
problems well I have some colors here
that I should have fused before but well
ok so as I mentioned it discards all
available type information um what do I
mean by that well we have an array of
arguments we have an object that we get
we have a method proxy where we can call
a super method without knowing its
signature and we throw a throwable so
that's not really convenient that's not
what we have here we could have known
that this is a service maybe we have
another maybe delete everything is
supposed to call another method
internally and we just want to override
it we don't know the use case yet don't
be so and then we would have to cost
around and use reflection API again so
while we preserve type safety for the
users of our library by generating code
be lose all type safety inside of our
own code that's bad I'll explain a
little bit about this later when I show
you how it can be done alternatively and
but a big problem and here i just set it
reflections and so bad but i told you
that boxing is bad and we have to
boxing's here why too well and let's say
delete everything takes an integer with
some ID i don't know make something up
and it's a primitive int then we have to
box it into an integer and then we have
two boxes integer inside an array that's
to boxing sits to heap allocations and
those are expensive and so
want to avoid these and just-in-time
compiler struggles with this if you look
at machine code that is generated by
from cg lib yeah related code you will
see it as a bit that can't be taken away
and if you if you listen to the keynote
and the one where they actually spoke
about Java nine then you heard about
value types and this will probably solve
this problem so hopefully this is going
away in the future but for now if you
really have something that is intensive
this delete everything method is called
all the time because I know yeah
probably not but other other use cases
so beans for example might call the law
called be called a lot like get us from
from beans you don't expect those to be
expensive right then you have an
interface dependency what's that like we
have two method interceptor and we have
the method proxy they both define
passage Phillip so once you create a
class with Phillip this class is class
loader must know about cgt lip otherwise
you will get an arrow a class or found
exception because these these are
hard-coded and yeah delegation requires
X to the class initialization what do I
mean by that well we delegate to an
instance of method interceptor if we see
realizin and a proxy or we send it over
the wire this is gone it's a static
field where this one is in so you get no
pointer at the song long we wanted right
and we have subclass instrumentation
only so this breaks for example
annotation api's and that's a very very
popular question asked to Mookie tow as
well and Mookie to use a CG lab these
days then we try to migrate or I try to
migrate over to bite body is to have
internal discussions about how this is
going to happen and but if you subclass
something all the annotations of the
overrun methods if they're not inherited
they're gone so if you give this this
mock over to some annotation based
library that reads annotations from
methods then those annotations aren't
there anymore so that makes you struggle
when testing certain certain things and
of course we have problems with class
identity and now CG lab is considered
feature complete these days if you
bleeders basically means the code got so
bad that nobody wants to commit code any
mods just know it I mean it's it since
Java 11 everybody pushed in a little bit
here and then then we basically I spent
a week to not migrate from arms over to
maven because so many of the test cases
are so badly written that you basically
you're afraid to touch anything it's
like some some old company projects
where nobody wants to work and it's it's
and it's little development it's I think
the sauce push what three months ago it
was me commenting out a test at faith
because you wanted to make build to go
green so it's not really really good
empty are the user API it's it's yeah I
am NOT going to comment this one you
find out for yourself um so this is why
we are basically today I want to
introduce my library and it's called
bite body and this is how it works if
you can read this hello world example
and you know what it's doing I hopefully
succeed it already but let's go through
it I mean it's the conference at the
ball so first line we just create a
configuration a configuration is the
idea is by body works convention over
configuration so if you just create an
instance it basically imitates the java
programming language does everything you
expect from it but you can do some
extras you can say okay any class are
generate from this configuration should
implement some mark interface for your
use case it might make sense let me just
stop class object right and then we take
the two string method this is what we
have here we takes a method measure a so
called mature method it's a functional
interface so white body uses java 6 in a
moment is compatible to java 6 but it
can create classes of any notion can
from java 10 to java 18 it supports
default methods depending on that's
something you can define here depending
on the only class level you set if you
don't set a level it just picks up the
level of you currently running jbm so if
you run this on a JVM 7 machine it
creates a java 7 class java for machine
java for us so forth but you can do it
explicitly so here we have a method
metra you have some predefined that
makes sense like named stress aesthetic
import from from o'clock
called matches java 6 we don't have
static interface methods yet though and
then we say okay we intercepted with a
value called hello world and so when the
two string method is called obviously we
want to return hello world then we make
this class and we loaded we just get the
class load of the context here and we
wrap it I'm not going to go into details
to plow flowing thread trees but what we
do is basically we create a specialized
class loader that takes this class load
as a parent return eternity we can
inject it but this might sometimes not
work if you have for example security
enabled then we get the loaded class and
then we already in the reflection API of
Java so now we can assert that when we
create a new instance of this class and
we called to string we get hello world
and yeah you have to believe me here but
it will go green so yeah this is
basically but by buddy does that's how
easy it is to create a class fortunately
well this class like this doesn't do
much yet so let's look into something
more complex well you see it's not that
much to change but that's there's
another predefined interception method
that's called too and it's also it
basically takes either an instance or it
takes a class the drill where what
happens is that when this is the
two-string method is overridden it
basically just gets into my interceptor
class and finds a best match and the
best match of just one alternatives of
course this method here I'll talk a
little bit out how this matching works
right next example but for now let's
just return hello world this does the
same as before right but now we can do
whatever you want we can call
system.out.println say to string was
call if this is what you want or log it
or whatsoever you can create it
dynamically yeah it's it's basically
it's up to you and that's what it's
supposed to be and you see here and we
have the string return type of course
this is only an identified by you but
what would happen if you wouldn't return
string it would complain it would say
watch out we can't find any interception
method here and it will do this it's not
as good as compile-time track but it
will do this at the class creation time
that's as early
we can tell right so 31st bad match but
of course instead of letting bite buddy
do the job you can just tell by it buddy
it takes the same method Metro interface
here which one to identify and you can
for example you can just name though you
can just say returns string or yeah
anything of these okay so this is still
quite boring because we don't have
context but one thing I want you to
notice here is that we don't have an
interface this is just a normal POJO
what's not even a poacher because the
static method but it's just a normal
Java class so instead of doing an
interface we have annotations and that's
a big thing where i believe by body
really improves ozg lib and the good
thing about annotations is and few
people know that actually I'm surprised
about this over time but annotations if
annotations cannot be found on the
classpath they are ignored silently by
the java runtime so you can put
annotations in there and when we create
the method and the bite buddy class
loader knows these annotations because
they're on the same class both the same
class loader but once you basically let
this class escape into the wild if the
origin annotation which is fight buddy
specific it's not there anymore it's
just disappeared it doesn't cause you
any trouble so we annotate here with
origin and give it a method and then I'm
going to infer from basically infer from
the type of the parameter that it should
probably give you the method and you can
expect what it does here well we
intercept to string and then this will
be a reference to the object to spring
method now you can say hello world from
to string instead of before it's not
still not very useful but you get the
thing all right there are a lot of
annotations and bite body and you saw
the origin one you can get a method
reference a cloth reference can get a
string and it just describes the method
and the reason for that is that
sometimes you just want to know a unique
identifier for a method and that's
exactly what is this the string lets you
identify the method by its name and its
arguments where a method look up and I
have to limit
the this thing I said before reflective
invocation of a method is not expensive
but method lookup is really expensive
unfortunately because it was chosen to
make these method instances mutable you
know you can call said accessible on any
of juice so every time you call get
declared method while it still has a
cash inside it has to create copies of
these instances every time you look it
up so sometimes you want to avoid this
and then you get a string you can also
let by body cash it for you it's just an
annotation argument just on the side I
have a really cool thing is super method
called a super method call as the
annotations called super super call it
just gives you a runnable or a callable
a callable if you need to return value
or runnable if you don't and the thing
is what you will get here is another
generated class where all of the
arguments of the method you are
currently intercepting are basically
stored in fields with the accept types
of of this this method that you're
calling and then you don't have to box
so instead to have an array we basically
have a tuple type a2 pitaya all the
primitive types are preserved and i'll
show you a benchmark on the end it
really speeds up things you can do the
same default calls which will call a
default method if it's reachable instead
of the super method you can get all
arguments and also this one is type safe
so you can you can use sanitation on any
object it will just put the instances
they are the arguments in that fit or it
will throw neck so it will refuse to
binding if it doesn't work or he can get
one from a specific index you can get
this instance by also type safe manner
by just using this annotation or you can
get a proxy of the same type which
instead of calling the actual method
will call the super method so it's also
it's another generator class we're just
reach through yeah how do I mean I on I
considered it i might just add it it's
actually that flexible you can edit by
yourself by a very little code it's
basically everything is interfaced so
you can you can check in your own
annotations into this matter but the
thing is that some people strip them and
then you don't know you don't have
expected behavior
and they're not unique there was a main
concern you can yeah there they are
unique but you can do a lot of stuff in
the bytecode because parameters and
local variables aren't distinguishable
in byte code so you might just have a
local yeah variable and then mix those
up and it's it's it's a little messy the
Java language and the bytecode format a
little bit divergent in this matter so I
mean something I think is really cool
it's actually not that useful as it
sounds like but it's it's still really
cool um it's a redefinition I'm the JVM
has a feature called hot swap and you
know this feature is something that is
really not that useful unfortunately
because it should allow you to change
the method body of a map of any class
and without restarting a JVM and you can
get hold of this feature using a java
agent so here I expect justice Java
agents on it was initialized properly
otherwise this one will throw an
exception so we can do with this since
version 03 which is like four weeks old
we take a class foo with a method bar
then we create an instance of this class
and then we just go into by body and we
use redefine and then we say okay the
method bar we want to redefine it to
intercept the value hello world and we
make it and we use this cloth reloading
strategy and once you call bar on this
this instance it will return Halliwell's
it's that easy it's of course the idea
behind is it is to use it in mocking I
fortunately I had the chance to talk to
John rosea about how we can make this
more useful in the future because
currently i'm the problem is that you
cannot add or remove methods so the
problem is like before when i showed you
that you can call a super method and you
could do this in really fine as well but
you want to of course call the original
implementation sometimes in order to
make this possible we have to copy the
original implementation and add it we
have to basically and added to to the
class so that's adding a method even
though it's invisible yes
yeah I know the dynamic code evolution
jvm yeah no um it's actually a you tried
on the on this machine and I compiled
them basically i altered the makita
framework to allow you to mock any class
so it's it's really not much cold it
took me an afternoon hmm you know I I i
was there i catched him right afterwards
upset like i want this so but they are
Lucy so but in a moment you can do this
like a little bit but something i'm
currently working with is that's just ok
servants and you can of course uses from
a build tool for example and in the
future you see here always class
literals what implies that the class is
loaded already but internally bite body
is built that it can use with any type
description and i'm currently working
with feature that already exists and
travis's to basically read byte arrays
and create these descriptions yourself
so i work in the feature is called an
agent builder and makes you allows you
to create really really easily java
agents without knowing anything about
bytecode and still you can do anything
with them yes yeah yeah yeahs the early
examples they had subclass here instead
of redefine and then you create a
subclass if you really find you can
actually redefine DD already loaded
clause yeah you change this globally
that's why it's useful for marks for
example or the security framework and to
go back to the first example you don't
want to have to stress on sub-clauses
you want to happen on a universal level
yeah yeah yeah sometimes proxying is the
right approach but for security you
don't want this method to be called
anywhere in its original implementation
you always want to have the security
check in the best case
yeah you could now you could you could
basically put the security check into
the clause no you couldn't get around it
no chance at all so and and the big
argument against this is that it makes
Java less secure but I argue that it
actually from library site the library
said could evolve from this would make
java applications more secure because
you don't have to use all this spring
proxying by by being containment because
you can of course always instantiate an
instance of the UM proxy class and then
if you do this from from a library it's
not that that's not that hard all right
we're all mad through and here just yeah
format with a small small benchmark
benchmarks are always easy to get wrong
so please challenge the benchmark it's
on github but as you can see by body is
significantly faster especially when
it's about invocation this invocation
this is creation creation it depends if
you yeah speed in co generations always
a trade-off between the speed of
creating our class and the speed of
using the create a class so bite buddy
has a clear favor on behalf of using the
credit loss against yeah basically
creating the clock well as quickly
simply because most classes are created
at bootstrap and but you can it depends
on you can use like this is done using a
specialized interceptor and you can ya
get really good results and if you
compared to Java proxies for example
this is just twenty twenty methods a
class with 20 methods where you just
implement stops it takes five times
longer with Java proxy and I times
longer with Java stand the CG lib takes
double as much time and this is this is
micro second so it's not it's not the
reason why I should choose a framework
you should choose it because of API and
and functionality all right obviously it
doesn't work on Android problem is
Android the Java Virtual Machine is that
just in time compiled stack machine
while the decks stacked all week working
machine is register-based and justin
harm compiled I don't have anything
about regular surveys machines but it's
quite a divergence and then even worse
the new runtime Android runtime it's
also it's a good machine it's a good
implementation but it's both
register-based and it's ahead of time
compiled so suddenly you have machine
specific machine code to deal with and
it breaks the concept of at least sup a
redefinition you can still do the sub
classing of working with this in a
moment to basically but it what I do is
I take the software development kit to
enter software development kit has a
compiler two decks on its library and I
just use it at runtime it's not huge in
size but I it's impossible to find out
what the licensing is for this if I can
allowed to do this and I most certainly
not getting sued by my google /
providing open source software so I'm I
have to find out um alright that's it
thanks for coming and this is the
project it would really help me out like
it's I don't need any any specific help
of course if you want to contribute to
bite buddy you're very very welcome and
but if you find on get up spread the
word you can start that actually is is
something that helps me because people
consider the quality of open source
projects sometimes by the amount of
stars it hasn't github it's it's it's
just like that I don't hate to play
ahead to game it's like yeah I don't and
you can follow me on Twitter and I tweet
about these issues if you're interested
in that I don't tweet much but i hope
this thing's art we did interesting and
my company and that sent me here to
check out the blog if you're interested
in norwegian market where work thank you
all so much for coming have a safe trip
home and a good rest of the conference
thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>