<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON2385   Standardized Extension Building in Java EE with CDI and JCA | Coder Coacher - Coaching Coders</title><meta content="CON2385   Standardized Extension Building in Java EE with CDI and JCA - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON2385   Standardized Extension Building in Java EE with CDI and JCA</b></h2><h5 class="post__date">2015-12-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0mzd5c6oqQI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone to standardized
extension building in Java EE using jca
and CDI I've met yep pretty much
everyone here actually I think a couple
of people walked in that I haven't met
yet but my name is Jason Porter I work
at Red Hat i'm a senior software
engineer I've worked on things like same
three if you were familiar at the same
framework at all patchy Delta spike
which is a bunch of CDI extensions jboss
Forge our Killian what else a few other
miscellaneous things here and there I
dabble in some Ruby stuff as well a
little bit of groovy so I get around a
bit I'm currently working on the
developers redhat com site if you're
interested in continuing on with any of
the information that you've seen here or
interested in any further information
about things that we do at red hat or
jboss feel free to take a look all of
the sessions that we've done have been
recorded down in our booth this week so
if you missed one of the sessions from
any of the Red Hat people you can go
sign up and check out the sessions that
they were posted up on the site so you
can you can see those what I'd like to
do to today as I would like to introduce
you to John John like most of us here is
a typical Enterprise developer works
kind of your regular nine-to-five kind
of job except for when production goes
down and then he gets called at three in
the morning right we all know how that
goes I John makes use of Java EE for the
majority of his day-to-day basis oh no
nothing all that dissimilar from from
what we end up doing and of course it's
time to plan plan the new sprint and
John's been added a few more tasks to to
his workload nothing too complicated or
at least that's what he thinks when
they're in the planning meeting which
again is how it goes right you get to
get the work and then you start diving
into and you go oh crap what do we do so
what he's been doing they they have a
inventory system that everyone goes
through and they scan the inventory and
and what what they need to do he's been
asked to process the the newly delivered
inventory put that into the system kind
of thing yeah
there's a little bit of a disconnect
between the handheld's and actually
pumping it into the the backend system
so of course John's going alright this
is excellent but as is the case java ee
doesn't integrate with our technology so
what do we do for this and of course how
much time is actually in the two weeks
print really reading the docs I don't
really know what what we're going to be
doing here now I'm sure all of us here
have done something like this before
right if only java ee did blah my life
would be a whole lot easier right or
even if if my programming language of
choice or whatever did blah life would
be easier such as such as life but the
nice thing is as long as you're using
java ee we already have most of that or
at least we kind of sort of do the best
part is is that with java ee you can
actually extend the platform and it's
actually not all that complicated it's
not that difficult yeah i know i've
talked to most of the people here you're
all running java ee 6 a few people are
on ee 7 so this is completely applicable
to everyone in the room at least as far
as i understand but you may be wondering
extending the platform that's that's not
usually something you think of when when
you think about java ee right it's well
you've got the stuff that is from the
application server vendor and the specs
and that's kind of kind of what we got
so it may be maybe a little bit
confusing but stick with me that we'll
we'll work through it it'll be it'll be
good so the first thing we're going to
talk about first thing jones is going to
be looking at is going to be jca or the
java connector architecture it's it's
been around for a while we've had it in
the platform since I want to say java ee
1.2 1.3 so it's been it's been the
platform for for quite a number of years
and the best part about it is that
you've probably used it before you just
may not be familiar with it now I know
some of the people are already done
connectors but the thing that you're
you've been using Java connectors with
that
may not realize it is JMS is everyone
familiar with JMS see some heads nodding
all right JMS uses the Java connector
architecture to actually talk to the
messaging client right the messaging
client may be something that is external
to the the server maybe it's something
that's bundled with server whatever it
is however you have your your messaging
broker it uses JCA to actually talk to
it and messaging go going back and forth
on there now jca gives us a few things
the the resource services so everything
inside JMS is pretty much a resource
they call it a resource adapter it gives
us a number of services that it makes it
available to us when when we create a
new resource adapter one of these is
connection management so you can create
connections think similar to JDBC
connections or pools or whatnot so you
can create connections to third-party
applications to some other services out
there maybe it's a database maybe it's
just some sort of data store that's out
there maybe it's a SI p or some some
other third-party vendor ish app or
something like that but you can create
connections to that you can authenticate
and and all that kind of stuff one of
the other things it gives us is
transaction management so we we know
we've got a JTA and jts this builds on
top of that and one of the things
especially if you're connecting to a
third party vendor solution if they also
run transactions you can do an X a
transaction so you can have their
transaction roll into the application
server or vice versa and actually have
all those participate in either a single
phase commit two phase commit with
whatever it is depending on your
necessity for that particular
transaction so you can you can handle
transactions that way next up is
security we do have some security now of
course we're not talking kind of the the
SE eight possible security that we've
got this is built on top of kind of your
standard security model that's already
implemented inside Java EE so you're
going to be working with things like
Jess and principals credentials all that
kind of stuff but it does have security
you can't authenticate against that
third-party app or against that message
broker or you know what whatever you
have that capability to to do that
authentication and of course we also
have lifecycle management bidding being
that when you start things up you can
you can be notified of your resource
adapter being being started up being
taken down you can create connection
pools you can spin up extra resources or
whatever and of course clean up clean
them up when when you're all done you
have that ability that you can handle
all that kind of stuff in a simplified
life cycle it's it's not overly verbose
but it it does the does a job we also
have a way of doing work management
typically you know starting threads
inside of an application server is is a
no-no right the end up spawning threads
and then maybe they don't get cleaned up
the way the way they ought to we often
like to push that off to the application
server the work management gives us a
way that we can actually create a unit
of work and then pass that off to the
application server and say hey you go
give me a thread run this packet of work
it's like a runnable so think of it as a
runnable pass it over runnable it spawns
a thread from the application pool runs
the work comes back that that kind of
stuff so you don't have to worry about
managing your own threads in that way
and then of course there's also message
in flow and outbound messaging to
inbound outbound messaging as well so
you can communicate with any of those
third-party applications or brokers
whatever it may be you can also start
communication so your outbound
communication if you need to send a
message off to them you can do that or
you can wait for messaging to come in to
you as well so it's a jca gives us a lot
of services that are available of course
you don't have to use all of them which
is one of the beautiful things you use
use what you need to kind of take it all
apart
as as your situation deems necessary
let's go back to Jon Jon's been looking
at things i looked at the specification
things that things might actually work
for him okay and he he's got he's got an
idea that every single one of the little
mini devices that they go on scan the
inventory they're going to go into a
they're going to be synced to a server
that'll generate a CSV or some other
flat file format that he can use and
then he's actually going to have that
dumped out to a network share that he's
going to listen to I mean he'll be able
to process that now the there are still
some questions that he's not quite sure
about he thinks this will work but of
course listening to the file system is
something that's fairly new in Java
right we had it in Java 7 it seems God
odd saying that was new that's been
fingers but we haven't had the ability
to really listen to the file system in
Java with kind of a native Java solution
for a number of years until just Java 7
but he's he's he's got the idea but he
wants to play with it so it's a let's
take a look see what we're doing and now
I get to the fun part the presentation
right so hopefully everything works out
well we'll we'll see what goes on and
I'm going to I'm going to switch over
and do a mirrored display so that I can
actually see what's on the on the
projector as well here we go it's not
looking good for everyone those in the
back can see it a little bit small all
right let's see what we can do here
all right fine is it is that better for
you all right we'll go back to
presentation mode and see ya see if we
can make that work you know you're
always welcome to come back up further
alright this is a this is showcasing
inbound communication so we're we're
watching the file system the first first
thing to notice is that we're going to
be implementing a resource adapter I
didn't do what i want to do but we're
going to be implementing a resource
adapter there are a few things that that
you can see so we've got an endpoint
activation so when when things get
started up then we're going to be
kicking off that that process of
actually setting up the the file system
watch so that we're notified of when
files are actually created or modified
or deleted whatnot and then of course we
have the endpoint deactivation so this
this is all part of that that lifecycle
management that I was talking and just
like a good citizen we want to go
through clean up any of those resources
that we've created stop the file watches
we don't need to be notified anymore
application server will go down
everything would be cleaned up in and
life should be good right now the the X
I resources like I said we're not
actually using transactions here so you
don't you don't need it you can kind of
pick and choose although unfortunately
as this is an interface you kind of have
to at least go through the song and
dance of having the method there but
that is there start stop starting
stopping the the resource itself as
opposed to things actually coming up and
booting up and then we've got some of
the typical getter setter kinds of
things that that will be looking at you
can see there's possibly some reflection
going on we'll take a look at at that as
well
the next thing that we're going to be
looking at is the activation spec now
this differs depending on whether you're
doing inbound or outbound communication
activation spec is definitely for
inbound communication so we've got one
of these and before java ee 5 all of
these kinds of things of course it have
to be done in multiple classes XML files
all that kind of stuff we have
annotations now that that we can do that
so where we have a message listener will
get in that that class next but we've
got the the resource adapter and then
this is for all intents and purposes a
POJO it's got some extra annotations to
it has an interface but the there really
is no business logic being done here
there's nothing too special here and
this part is a little bit different so
we have an empty interface here in the
FS watcher those that have done
connectors before I want to say this is
this came out in JC a 1.6 they allowed
us to have empty interfaces before you
had to have a typical interface then you
have to implement the interface you can
now have empty interfaces which is one
of these great things that we can be a
little bit more expressive in our AP is
we're not tied to an interface we can
use annotations which is what we're
going to be doing here so you can you
can see we've actually got a call out to
to the annotations in the the create up
here in the javadoc right here and those
are not all that special not a whole lot
here you've got the the create and so
we've got create delete and modify the
three things that you typically be
seeing in a file listener anyway and
they're all pretty much the same
actually you've got a default value here
the this actually becomes what it is
that you're listening to what kinds of
files you want to be listening to the
directory was specified on one of the
other classes
and then this last part over here is go
up we've got a thread here that as far
as that the thread is concerned the only
thing that we're doing here is just
actually kicking off the service
everything else is handed off to the the
work method over here so we're going to
be dispatching events based off of the
annotation that's there and the the kind
of entry that we're getting if it's a
create or delete or modify as you can
see in the middle of the slide right
there and that that'll be passed off to
the MDB so here in the invoke you can
see right here this line is where where
we actually scheduled to work so we
grabbed the work manager from the
bootstrap context with a from the
endpoint which you're sorry the resource
adapter which is passed in at creation
time and we grabbed the work manager
create this little bundle of work and
ask the application server to schedule
that now of course we don't have any
guarantee as to how quickly when
priority any any of that kind of stuff
but we just say here's this unit of work
that we would like you to take and run
it whenever you've got time so that not
fully a sinkers a synchronous but
definitely you know whenever the
application server has an extra thread
to go run this is is when things are
going to be run we do have a little bit
of reflection on here although nothing
too too scary we're looking at methods
names parameters that kind of stuff and
then the this bottom method down here
that should run this is just one of
those things to help clean things up if
we're going to be shutting down maybe
you saw in the previous class if we're
going to be shutting down we'll just
actually break out of that that while
loop and exit the run which will help
clean cleaning things up at the end to
stop the application server so that's a
that's the the basic idea of this if
you're curious about where the code is
let's go back here that is not what I
wanted
keep changes
alright so all the code that I just went
through is available over here on github
this isn't my code actually someone else
wrote it which is great it's all open
source and you can use it so if you're
interested in what this is this is
github com / Robert Panzer / file system
watch hyphen connector it's all right
there up there on github you can pull it
down it has been tested in both wildfly
8 i'm going to be running in nine so it
runs there and it's also been tested on
Tommy that's that's as far as out of the
box anyone running anything else there
there may be a few tweaks that you have
to do maybe an extra XML file or what
not just for testing whatnot but it's
it's all there you can use that get
started and look at stuff oh wait a
minute if anyone wants to copy that down
or we can go on and you can grab it from
me afterwards are we good to keep going
okay see a heads nod the next part is
testing anyone familiar with testing
inside of an application server it gets
a little bit dicey right you end up
doing stubs mocks all that kind of stuff
resource adapters are kind of another
kettle of fish as far as that goes if
you want to create stubs for that you're
going to end up stepping out a lot of
kind of the infrastructure plumbing that
the application server gives you so
we're going to take a slightly different
approach with this and we're going to be
using arquillian to test who's familiar
with our Killian see a few hands okay
that's good right about right about half
now one of the things that are Killian
does for you is it actually runs your
tests inside the container which has a
nice benefit of actually running in the
same environment that you're going to be
running in production which is great and
of course I mentioned earlier I'm
writing a book with my good friend Alex
over here so we're co-authoring this
book are killing in action by Manning
it's available via meep right now and
Manning if you're interested in more
about our Killian go check it out buy it
use it all that good kind of stuff
so our Killian eases pain when you're
testing inside of a container again I
said it runs in the container you can
run things in in a container that's
already started up you can have it start
a container some of them it'll even go
far go so far is downloading the
container starting it up that's what we
call a manage manage container where
everything's taken care of for you let's
let's take a look I actually do have
this running in in wildfly I have a
separate instance running so I'm not
actually using a managed one and that's
just for debug purposes that we'll we'll
take a look at that and we'll switch
back so you can we can both see the the
code and the tests we want to be over
here the first test we want to look at
is this is it over there I don't know
that's all awesome
hmm
let's go see what we can get over here
go away there we go all right although
that is not the test we want the test
hey we have a test all right here we go
this should be familiar to you in that
it's a message-driven beam so those does
that are familiar with Sheamus this
looks very familiar now you'll notice
that in the message driven we actually
have an activation config and we've got
a directory that's going to be the
directory that we're going to be
watching and then the property value is
of course the the name of the directory
there were the location of the directory
that that you want to look at what we've
got here so we do have a little bit of
CDI going on right here simply for
testing purposes although remember that
it'll come in come in handy hi in a few
slides we have a message-driven beam and
those annotations that we had so we I'm
not using the modified here but we do
have a create and a delete so we're
looking for file creations and also file
removals so deleting files and what
we're going to be doing when one of
these is called just like in JMS so you
kind of think of these as you're on
message events but we if you remember
that this FS watcher didn't have any
methods that you needed to implement so
we're basing this solely off of the
annotations here so any annotation that
has any of those three create delete or
modify our what we're going to be
calling and all we're going to be doing
here we're going to be firing off a CD I
event that's injected for us the event
service is injected and we go and fire
off a new event based on the file that
we see is going to be created and then
the the notification type so create
modify delete that's what it is and the
just for completeness that file is
really simple just a pojo tells us what
it is that we're doing nothing special
here so we can go through and we can run
that those if it's going to let me let's
go through run that I've run this
previously just in case stuff doesn't
work right so you can actually see that
is green but we'll go through and run it
right now so what the what this is going
to be doing we're booting up everything
and just a minute you're going to start
seeing the output from the application
server right there so you can see J
bosses is actually communicating to
jboss things were running and i'm
debugging right now so you can actually
see we are debugging so I have my
application server setup in debug mode
so that you can actually go through and
debug the tests and see see how
everything goes we'll skip that for
right now and just watch things run we
got tests were test paths and all of our
tests are green now as far as our
Killian goes we'll take that will take a
look at these tests and I'll explain
things as as we go a little bit if I can
keep my cursor up at the top okay the
first thing to notice with arquillian
now this is aj unit test but the the
thing that the first thing that
differentiates this from a regular j
unit test as an arkonian test is that
we're using a different runner so this
run run with annotation up here at the
top is telling j unit to go use the the
arkonian runner then the next thing is
this deployment annotation here well
what we're doing here and this tested is
actually fairly contrived and you have
to go through a lot to actually get it
up and running but the we call these
micro deployments and what you do with a
micro deployment is you create just
what's necessary for the test to run and
our killing will take that it's actually
going to build up these archives so
whether this is a jar an ear a war or
are and any of these things it's going
to build them up using Java code
take that and then move it over to the
container do a deployment run the tests
that are included in inside the
deployment run those tests listen for
all the executions and then take those
back create the report and return that
back to to j unit now it's a little
oversimplification but that's that's the
the overall of what's going on here so
this this first part we're going to be
creating a jar out of our our classes
that are going to go into our R &amp;amp; R R is
very similar to an ear or a war it
contains jar files and optionally has
some some additional metadata whatnot
the you can add to it so we're going to
be adding classes here to to this jar
all of the classes that that we're we're
used to seeing or all of the classes
that make up the the RAR are create
modify delete Watchers threads adapters
and activation specs then we're actually
going to build up there are there's not
much there we just add at a library to
that then we create an ejb jar for
simplicity so that we can actually use
CDI and then so we can also register the
the roar fought the sorry the there are
we can register the resource adapter so
we've got a manifest resource and also
beans XML for CDI purposes we take that
jar and another jar which actually
includes our test the that's that's in
there often times in our killing test
you'll see that you don't add the test
itself because we're actually building
something up that's going to be deployed
as an ear we need to do that so that
everything is packaged properly and
things are run correct correctly it
finds everything that kind of stuff so
we've got our test that's going to be
run in there and that also includes a
bean xml file for CDI then we create our
ear so we we add our rawr and we add our
ejb jar as well and then also our
library including our test so our
killing takes all of that all those
modules
the Java code creates this ear for us
and then we we kick that back out to our
Killian and our Killian takes that talks
to the server actually does a deployment
of the archive and runs it our tests are
not that complicated but we do have a
few things so we've got to be before
part 2 the 2 this test where we're going
to be setting things up and just make
sure that things are actually running
thread dot sleep to actually give it
some time to to kick things off and make
sure everything's up and running all of
our tests are going to be running in a
specific sequence which is one of those
things you're not supposed to be doing
in the unit tests right but we're
actually actually relying on creating
and deleting files and we don't want to
go and delete the file before we've
actually created it right we we are
doing something a little bit different
from what you've seen we're using a Java
util concurrent cyclic Berg barrier to
actually give us the ability to run
tests quickly without doing more thread
dot sleeps this will say basically block
the thread until it's called by
everything that needs to so as long as
we've got our essentially the yields are
called on the lock then then we can
continue so we go through create a text
file just temp files nothing special
here and then we wait for everything
that happened we create a PDF file and
then we also go and delete the the test
file now we do have this little bit here
this little CDI bit where that the file
event that we saw a little while ago
this is observing that event so we can
we can actually listen to events that
that are pushed off from that MDB and
we're going to be listening here so that
we can actually test to see if we got
the the correct mode and also the
correct file or if anything happened of
course we can exit and throw through the
exception and test test will fail so we
can actually see that if we we've gotten
to wait here so if we go go through here
and run this all again
if I actually have it set up to debug
we'll find out in just a minute yep so
we're waiting 10 seconds for our barrier
to actually hit any kind of there
waiting for the barrier to be hit again
so in after 10 seconds if this isn't
going to be hit well actually an
exception and you can see that the test
actually does fail and we don't have to
wait a very long time just that that 10
seconds that we said in the weight part
where we're waiting a specified amount
of time forward for things to continue
on I think we've been about 10 seconds
so let's take a look and that was that
other breakpoint we'll just keep going
and I'll test pass so I get I didn't
wait long enough or I was too early one
of the 20 actually know what we could
wait right here will you do that let's
try that again run it again
we're inside the the CDI event right
here you can take a look at the file
event and this first one should be a
create so we've got mode 1 which is if i
remember right get mode yep create is
one we could have used in enum but you
know whatever but we can wait here for
for that barrier to actually hit and
wait for the exception to happen let's
see what happens here click click and
last time I didn't see a pop that says
our test run yep so that this first one
BNC down at the bottom of the screen
right there so we actually do have an
exception this is a concurrent timeout
exception because our barrier didn't
receive that that a wait call within
that ten seconds now one one of the nice
things about this I did mention that
this is all running on on a server as
you can see in over here this is wild
fly I know you're not going to be able
to see that in the back but this is
wildfly running in a separate process
that you can take a look at and and do
that I was running in a separate process
solely for the the purpose of debugging
as the tests are currently set up it'll
actually go through and download startup
wildfly all that kind of stuff but that
is one of those things to be aware of
when you are using our Killian to make
sure that you've got your your
application server running in debug mode
if you want to debug your tests unless
you're running client-side tests because
your tests are going to be running in
inside the container and that very often
is different from the JVM that your tat
that the Ides running in so make sure
that you've got a remote debug
connection up up to your server so you
can do that are there questions that
people have had up to this point sure
yes so you're you're using my own play
as well okay all right so the question
just to repeat for everyone you're
experiencing where it's restarting the
server every time you're running your
tests and you'd like it to use something
that's already already managed right
okay we can take a look at that now that
is I'm not gonna find that where I want
arquillian does have a little bit of a
configuration that you may need to do
now the thing that you're going to be
looking for for wildfly is this property
right here allow connecting to running
server if that's set to true default is
not true so if that's set to true then
if there's already something running
it'll go find that pick it up and use
use that
from the eddy yeah oh it does it most
definitely does I could run them through
through mavin if I wanted to although it
is nice to stay inside the the IDE as
long as possible keep that feedback loop
as tight as possible you you can I'm I'm
not obviously running I IntelliJ you can
do the same thing from eclipse from
NetBeans any of the addys really really
all it is arquillian is being invoked
from j unit and it's running a server so
as long as your IDE runs j unit you're
good to go or test ng if if you prefer
to you use test in G or Spock or some of
the other testing libraries that are
killing and integrates with as well
further questions from anyone sure sure
so the the question was about doing
these uh these deployments and that's
not what I wanted that's not the class i
wanted i want to be over here so all of
this code right here where we're we're
creating deployments oftentimes is you
want the smallest you want to create the
smallest deployment as possible to test
what it whatever it is that you're
testing now in this case we we actually
had to build up a couple of jars and an
ejb wars maybe a little bit easier if
you need to build up a an ear then
you're going to be running into the same
kinds of thing you you can actually have
it run run your build if you want if you
want to do that and and use those it's
not really recommended because then you
end up running through the whole build
step the things that we've done
especially in the Delta spike project is
we've got a bunch of these already built
up you know over over time we've built
them up added them to utility classes
and those just return archives and then
we'll add remove things as as needed
depending on the test ultimately it just
comes down to actually building it we
don't have any any kind of magic sauce
or anything like that for for building
micro deployments sorry
right okay it's right yeah so there are
things out there but ultimately it just
comes down to building it okay I'll I
don't have any questions or at least
unless someone else has anything else
yeah sure yep
I did have some questions earlier in the
week about this kind of stuff someone
was asking about communicating with what
was it I don't remember the service but
they exposed some rest endpoints
basically i'ma the question was is does
jca help me in that aspect I you could
do it that way ultimately if you're just
calling a service that exposes some sort
of web service or something like that
you can do it but it may not be be the
best for you you see these kinds of
things used a lot if you're integrating
with a third party via like a wire
protocol or something like that if
you're going to be integrating with SI p
you could integrate with twitter or
something like that but if you've got
like a wire protocol that you need to
use and JC is going to be your best bet
for that I'll but ultimately if it's
just like a REST API yeah probably not
the greatest thing but nothing's
stopping you yep sure
yeah yep yeah JC would definitely be the
way to go on that one is if they if
they're exposing some way to connect to
their system and it's a two-way
connection JC is going to help out with
that a lot for thick clients whoo
mmm nothing's immediately coming to mind
you maybe you could use this in a thick
client so if you've got a jca
implementation for example at Red Hat we
have iron Jack amar that you could use
outside of the application server the
trick is going to be actually doing the
bootstrap of jca and getting that all
done but if you can do that then there's
nothing stopping you from using it in in
a rich client for example like if you
had a swing app or a javafx app or
something like that you could definitely
do it you've just got to make sure to to
actually read the docs and figure out
how to bootstrap jca yeah further
questions yeah
okay so the question is do we have to
use a message-driven being for for
communication and the answer is no you
don't I'm doing inbound communication
which is slightly easier outbound
communication and two-way communication
includes a little bit more code but it's
not overly complicated what you'll end
up seeing is you'll you'll register that
in the application server at a jindie
location you'll inject the the jindie
resource and then actually communicate
that way
so one one of the will go over here and
see if we can get a new that's going to
be really small but we'll figure it out
Adam bean if you're familiar with him
yeah that's that's not gonna work for me
Adam bean has a bunch of connecters on
his website one of them is called the
file bucket and that is a two-way
communication actually storing stuff out
to the file system you know which isn't
all that great but it does demonstrate
in a fairly easy manner how you would
end up doing stuff like that
I that all depends on how you're going
to be using it if it's used in the
single application then you can deploy
inside of an ear or an application
server will allow you to deploy your or
a RAR to it itself and then then you've
got like a Djinn dlookup to actually get
it similar to what you'd have if you
were going to be registering an external
message broker that's not part of your
application server same process yep
sure yes they can contain native code
yep you're going to run through all the
same kind of stuff to you know register
the native code and whatnot but yeah
again further questions from anyone no
all right we will go back to ya we'll go
back this slides and not that one
there we go
key changes
there we go okay back back to John now
John's been feeling really good I use
about halfway through his sprint things
things are good he's gone through we've
seen the the file connecting and able to
actually process that that file its
that's done so he's feeling really good
about things until of course the the
boss comes comes in and the inevitable
so this is great we're really looking
forward to it we need something else
right as the what he's been tasked with
is that they need to actually add some
some jmx metrics to the the file file
processing and want to know how many how
many files they've processed what new
inventory is that that kind of stuff so
that not not the hardest thing but again
not the easiest thing either so of
course John's thinking this is wonderful
but i want to write less code not more
code so how how else can i extend java
ee and do less code less maintenance all
of that kind of thing the the answer
that is of course CDI that allows you to
again extend the platform in a standard
way so that you can add all these these
kinds of extensions to your to your
application now I know we've we've said
or there there are some people familiar
with CDI right I get a show of hands
again okay most of us are there people
here that have done extensions
themselves okay so this will be new all
right and I've got about 15 minutes so
we'll see if people want to go into more
depth after afterwards I know we've got
something going on in about half hour
after the presentation but we can talk
more so when one of the things that CD i
gives us is it gives us a life cycle for
building extension points the the life
cycle looks like it's complicated and a
long chain but it actually isn't too bad
the what we have here the the color
scheme here red is 11 event blues happen
multiple times and greys are things that
the application server does itself so
what you've got when CDI starts up
you have your start your deployment from
your application server and then fires
off that before beam discovery now every
one of these these steps these the kind
of bluish green and the the red color
you you can listen to those via CDI
events and you can add or remove things
before being discovery we can actually
add new beans to the system beans that
maybe you are excuse me are coming from
a third-party jar that does not have CDI
enabled or if there's maybe some
synthetic beans that we want to create
on the fly or whatnot we can add those
into the system and CD i will pick those
up after that with the application
server goes through in scan z archive
and we receive notifications of every
annotated type so those are going to be
things like CDI beans ejb s md bees
entity beans anything's an annotated
type so it's got an annotation up above
it at the class level will receive
notification of that then we can go
through modify some things we get an
after type discovery so after that's all
done we know we're done there then we go
through into a beam eligibility check
from the application server and we're
notified of any injection points targets
attributes on beans beans themselves
after all those things all of those
things are done we want to if we want to
go through and modify and any of those
types add new methods that kind of thing
producers and observers are also given
to us that that we have and each of
these have their own payload that's
that's available I'm not showing it now
it's all in the documentation but we can
go over more if we would like and then
we can add observers we can add
producers we can modify some of these
things we we then have an after being
discovery and after deployment
validation so we can we can go through
and check things to make sure everything
is the way that we expect it to if
things are not looking okay we can throw
an exception and actually abort the the
deployment right there then we enter
that that state where the application
runs and all of your typical CDI events
or injections like that kind of thing
happens and then of course right before
the application shuts down we're given a
before shutdown notification so if we
need to close out any any scopes if we
need to shut down any connections clean
up any threads temp files and any of
that kind of thing we're we're given
that are there questions so far about
the overall process of CDI events or CGI
extensions okay at the the next thing
that I'm going over is the Apache Delta
spike project which is a library of a
myriad of different CDI extensions I if
you're getting into CDI extensions it's
a great place to look at and to learn
how how to create those we have
extensions that do all kinds of things
all the way from exception handling to
data entry to know what else we have
things to help authors create beings
create new types creating scopes
processing injection points all that
kind of stuff so it's it's really kind
of the Swiss Army knife of CDI
extensions when one of the things that
it allows us to do is that we can create
jmx beans with with Delta spike through
just just a few annotations we'll take a
look at that quickly and run through
that and we'll see how how it all plays
a plays out as far as that chain of CDI
events that happens at the startup
Oh are we gonna play this game on me
again it looks like it
ok
intellij is being very slow maybe it's
because I haven't restarted my computer
for a while but what we have here as
soon as everything starts back up this
is going to show a jmx beam that is done
using CDI so one of the things to take a
look at is that we're starting off over
here on where's my cursor this line of
code right here so we have this
annotation here this is an mbean this is
a delta spike annotation and we're going
to give it a description and the the
version that just was recently released
151 you can add things like types and
object name and all that kind of stuff
things that you would use you expect to
see in in jmx means so we get we
annotate a POJO as an mbean and then we
also have this jmx managed that we can
put on types and also methods so that
those will pop up in in your typical jmx
console and then because we're we're
also a CDI beam and you can see where
we're applications cooked right here so
this this will run the for the duration
of that that deployment we also get
things like injection points with with
CDI and we can also listen to events all
of that kind of things what what we're
doing here is MMB an extension another
this one is a little convoluted but it's
not too bad so you can see here this
method right here the in it observes the
before beam discovery event from delta
spike and what we're doing here delta
spike has the ability to actually turn
off CDI extensions so we're just
checking to see whether or not we
actually need to run this or not so
there's not a whole lot there although
the process being right here so we get
notified of a new beam that's that's
been found or created or whatnot and
then we can go through actually find the
annotation type get the object and we'll
we'll run through this register object
method which is a lot more code
but this is actually going through and
doing doing that part of actually
turning it into a jmx beam so we don't
have to worry about creating any of the
the extra interfaces or the
implementations or whatnot it's just
that pojo and delta spike is going to go
through and do all of that kind of magic
for us I just based off of solely off of
that that annotation or any of the other
annotations in the class so we're
setting type category properties and
name just just as you would figure for
any any gmx beam and you can also scope
scope these so we've got to get a check
to see what what the scope is here if
it's a normalized scope any additional
qualifiers from CDI and going through
and registering things so that we can
actually process jmx and notifications
all that kind of stuff all that's built
in through through this process of CDI
and what it does for us and the last
these are all private methods I'm pretty
sure yep
so there's not a whole lot to this one
as far as that CD I livecycle those the
last one that we have here is a before
shutdown and this is going to go through
and actually clear out any of those jmx
beans remove them from from jmx and be
able to shut things down so all of your
your extensions are going to include so
they're going to implement extension
right here this is the this is the Java
X enterprise inject SPI extension i
doesn't have any methods for you two to
implement so that that's easy and then
there is also a I just lost my words
there's a meta f red registry that you
need to do that includes the the name of
the extension and that's all you need to
do as far as creating extensions the you
implement the extension add the the meta
in free source to it and listen to any
of the the CDI events and then you can
go through and modify create remove
update all of those kinds of things and
we're getting close to time so I'm not
going to actually be demonstrating
John's code that he came up with
although you can see based on the test
that we had before you can see how we
were actually using CDI to process send
off that that event in the test John and
be doing something very similar to do
that in his mbean he would be firing off
the the event listening to it in the jmx
beam updating counts records with
whatever it is so that the the admins or
whomever is watching that that jmx
console can take a look at that
and we'll go back real quick just finish
off slides and then answer any questions
that that people may have okay or at
least that's the plan here we go okay
John's finished all of his work and he's
excited he's actually finished a little
bit before schedule so he's wondering
what's next and I've got I've got about
four minutes for four questions so we'll
field two or three questions and then of
course any images that I've used her up
there so I've got like I said I've got
time for about two or three questions if
people have them or we can listen to the
cars outside yeah
yes yes in the book the question was if
we're going to have an hour killing cube
chapter yes we are oh do we have it done
alex is writing that one Alex are we
done yet nope alright not yet we're
working on it okay so if there aren't
any any questions I'm here for a little
bit longer if you want to talk about CDI
or go more in depth but thank you
everyone for attending and I hope it was
helpful for helpful to you and enjoy
your time here at javaone and good luck
with any of your connectors that that
you create or CDI extensions thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>