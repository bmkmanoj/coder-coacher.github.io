<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Bridging the Gaps to Deliver a Robust M2M Solution | Coder Coacher - Coaching Coders</title><meta content="Bridging the Gaps to Deliver a Robust M2M Solution - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Bridging the Gaps to Deliver a Robust M2M Solution</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fB4-MCB5Kuc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you for taking the time to come to
the presentation we're going to talk
about m2m solutions specifically
bridging the gaps and what it took us to
deliver a robust end-to-end solution
with the java platform so what I'd like
to do is start with a brief history of
the sunspots platform will then talk
about how we use the sunspots hardware
to create a vertical solution around
monitoring shipping containers in the
process of doing that well we wanted to
build an end end software solution using
Java that would leverage the hardware
platform and also explore some of the
challenges in building a complete MDM
solution but the challenges I want to
talk about today fall into two areas one
our general challenges that are seen in
the iot space as well as some challenges
we saw in developing on Java ME the
wrap-up of this is we were able to
create a sensor platform that sits on
top of Java ME specifically geared
towards a vertical solution but that
also provided horizontally scalable
components to be able to address other
other verticals just a quick question
any developers in the room so JSP that's
been out
JSP this is yes this is part of the
Oracle Java sensor platform though we're
no longer calling that the CMD yes yes
exactly and again if you have any
questions feel free to let me know
midstream we don't have to hold them all
till the end of it yet so I'm gonna be
leaving cool too it's not hungry but
it's going to be so much not a problem I
noticed the presentation is up against
Larry Ellison's keynote of 130 as well
so we'll move through this general
disclosure I'm going to talk about some
things that we built that sit on top of
Java ME that did not does not
necessarily mean that Oracle is
committing to ship any of that as
product so standard legal disclaimer
anyone familiar with the sunspots
platform tiny little bit so I actually I
brought one with me the sunspots
platform was an arm 9 based platform
that ran a Java ME compatible vm it
basically had a sensor board processor
board radio on it batteries and local
flash storage the key was it was
entirely programmable in Java when the
project was started back around two
thousand six ah it was a bit unusual to
be able to program java on devices of
this class and so there's a quarter on
the slide for reference but this is the
actual sunspot device if you look at
just the censor board and the main board
broken out apparently my sensible or my
main board wasn't walking but they're
both about this size so the platform was
fairly well accepted I would say they
were probably over 300 different
projects that we had seen research
researchers pick this up universities we
worked a lot of oracle partners then sun
partners at the time to do different
projects if you go to youtube and look
for spots spaa you ghts you will find
youtube videos of some of the
things that people did with sunspots we
chose the misspelled version because if
you look for sunspot on youtube you tend
to find the celestial phenomenon so how
do you create a vertical solution with a
research platform well what we what we
wanted to do is find a problem that
variety that required a variety of
sensors so that we could kind of stress
the platform that would benefit from
having on device intelligence there are
lots of sensors today little processors
all they do is admit data well when you
have a full vm to work with you can do a
lot more so we wanted to be able to push
that capability we also wanted to look
at something that actually had value and
wasn't just a solution for solution sake
so what didn't have a good solution out
there today again this was also done as
son was being acquired by oracle so we
wanted not just an interesting java
device solution but also something that
stressed the end-to-end challenges what
we came up with was after talking to a
variety of people shipping containers
why over 20 million containers in
existence 200-plus million shipments a
year interestingly and this is directly
from partners less than one percent of
those are actively monitored and the
result is billions of dollars in Los
interestingly you can think of theft is
one of the most common turns out they
even lose these over the sides of ships
and they go floating the ocean never to
be found again now unfortunately the
electronic short out so we haven't
solved the problem finding the ones that
are floating but we can tell you where
they disappear so we wanted to build the
vertical solution but also keeping in
mind that the platform and specifically
the software we're going to build on top
of Java ME wanted to be horizontally
scalable to other applications
and as a result of the work that we did
I don't have one here today but we
actually built a separate board used for
asset monitoring so it was a little bit
more generalized so we started with the
spot is a complete system we leveraged
the main board and censor board
separation through that we were able to
do interative designs on the sensors and
then finally put the whole thing
together in a single solution what does
that look like well we have the sunspot
whoops we have the whole spot which is
broken out into the main board so
there's a processor in a radio and then
the censor board which had LEDs some
buttons accelerometer temperature sensor
a variety of things that this is
actually a full-blown arm9 it's the st
9200 i believe so it's a full arm nine
core the spot that you're looking at
here if i recall actually has um so it
was a mega RAM and 4 mega flash but
again the beauty was we had a processor
board that we could start development
development on with the VM and iterate
through the censor board because we have
a connector here that mates the two of
them together so the first iteration
actually looks a little bit more kind of
Frankenstein and she can tell it came
off the lab you have capacitors are kind
of haphazardly soldered on except this
was a dork oil sensor that we created
in-house basically inductance check
against the metal to see whether the
door was closed or not different radios
we played with so here's an Iridium
satellite module GPRS radio
communication SIM card but the nice part
here is we could just take the spot and
made it right onto this complicated
sensor board and as we wanted to do it
erations we just did rate on the censor
board and we still had application folks
moving forward doing their development
next iteration looks a little bit more
cleaned up getting closer to production
here we've actually come closer
to the final set of sensors we're going
to use to do intrusion detection on the
container and we've taken the components
that aren't likely to change for example
the radio technology and integrated it
and here in this highlighted area you
can see we've taken all of the
technology from the spot which was a
standalone item we've designed out the
pieces we don't need so basically reduce
cost of manufacture and integrate it
flips and drop it right in that little
spot and my dot seems to have gone away
I'll use this one so this is what the
end product looked like but the end
device and I brought one here you can
actually pass it around if you want to
get a little closer look took the cover
off so that was that was the hardware
design and again because the spot was
running java we could do a lot of the
development right on the little research
devices in parallel with doing the
hardware development so what we end up
with is a container monitoring device in
a form factor that can fit in the door
of a container specifically in that
external channel you can see on the
right hand side oh there we go this
column here is actually a set of
antennas because as you might guess
shipping containers aren't exactly RF
friendly when you try to put in
monitoring devices that are can
communicate so the little slot that you
see in between is where the door seal
slides in so the antennas are on the
outside of the container and the
electronics are protected inside the
container so the key is we ended up with
a set of sensors that can do intrusion
and location monitoring of the container
antennas and communication modules to
get that data back to the data center
and a java-based platform to do all of
the local logic for intrusion detection
angiographic processing
so now we have a hardware device you
need a solution this is where it made us
look at the end to end how do you get
data from a device to the data center
and what are those challenges we found
there are a number of challenges that
are faced by all Internet of Things
developers some of the technical
challenges included communications we
think of Internet of Things we think of
internet-connected we think a lot of
wired and we think of Ethernet well the
reality is a lot of these devices even
though they may have Wi-Fi are actually
duty cycled so they're not up all the
time you can't just put a web server on
them and expect that web search web
server to answer at any time even if the
device isn't sleeping if anyone has ever
looked at what goes on with a GPRS
connection like a cell phone very often
in in this current ipv4 world you end up
basically in somebody's net so you're
behind a protected IP address which
means you can't get there even though
somebody the device can get out to the
network so that posed some interesting
challenges with a device that was going
to be running around free in the world
how do you communicate with it also how
do you encode your data we're talking
about battery-powered devices the more
you transmit the show basically the
shorter your device life and when you're
in the middle of a shipping container
you can't somebody send somebody down
three levels to change the batteries
mid-trip being a Java platform we were
looking at flexibility and being able to
use the application in different
scenarios part of that is being able to
change out the sensors so with things
like the device API you have a certain
level of access to a device but how do
you abstract that such that you can
replace temperature sensor a with
temperature sensor be and from an
application perspective not have to be
making too many changes so we'll look at
some of those issues again we talked
about the networking issues you know
their global addressing issues there's
life in a protected Network even if
you're not in a protected Network you
have firewalls to deal with good
applications design
to protect against connections coming in
they're more likely to make connections
out and finally something that hadn't
dawned on us when we started the project
not all transports are created equal not
only do you have different band widths
the deal with but when we started
looking at iridium we realized that the
cost went from a few cents per kilobyte
to dollars per kilobyte so that in
itself was a an interesting motivator
for how you manage the transports and
how you manage sending your data when
you have multiple choices in putting
together this specific solution it
wasn't as simple as just saying we can
put Wi-Fi on it because we had to be in
some fairly hostile environments you
could be on a train in the middle of the
country you could be on a shipping
container carrier in the middle of the
sea so for flexibility we chose to go
with two different communications
mechanisms GPRS and iridium we looked at
others the original spot actually had a
personal area network radio we could
have chose to use that as well it didn't
seem to fit this application as well
data transfer challenges we could have
used HTTP / HTML we could have done our
own binary encoding we actually
experimented with that for a while but
that ends up being more code you have to
maintain we could have done something
application specific but again that to
me just starts pushing the problem to
other levels so we wanted something a
little bit more generic we looked at
encoding that could then be used over
different transports because again if
you start using transports that only
support small payloads for example if
you wanted to do SMS you have to take
that into consideration as you build
your higher layers so that posed another
set of challenges finally standards ah I
do a lot of work in the standard space
and the thing that I like to remind
people is the best part of standards is
there are so many to choose from alright
the downside of that is if two people
don't choose the same standard you're
never going to talk to them so we ended
up with a situation where even with
something as simple as
look at the personal area networking
space 80 to 15 dot for a lot of you
might know that is zigbee well zigbee is
a proprietary standard there's also a
set of internet standards out of the
IETF called 6lowpan and ipv6 it's on
that same radio so you can say I do 15
dot for but if you do the zigbee version
you're not going to talk to me so this
was another another set of standards
challenges we had pick your standard but
then you have to be careful about being
married to the whole seven layers of
that standard the mix and match doesn't
doesn't necessarily play well so I OT
developers have a set of challenges Java
ME developers we found also have a set
of challenges thankfully they didn't
seem as daunting specifically Java ME i
think is very good that presents a set
of abstractions like the device api and
like GCF that allow you to build an
application and then start making some
changes underneath what we found we were
missing we're necessarily a higher level
of extra of abstraction that allowed us
to add intelligence to a transport for
example without modifying GCF so we
looked at some of the bigger tasks that
we wanted to accomplish that fit a sense
of framework applicable to container
monitoring that could sit above Java ME
we also wanted to separate the concepts
of message queuing and message transfer
because unlike using GCF directly where
you have to open a connection you manage
that connection you send date over you
close it we were in a little bit more
dynamic environment and so we wanted
people to be able to put transports
underneath our application without being
required to go in muck with the
application to change how you might
deliver data over the transport so for
example if you were to stick UDP
underneath what does that mean if you're
trying to stream data so having an
adaptation layer and abstraction allowed
us to have some more generalized
communication tools so what does that
platform look like
so the rest of the talk will cover in
two pieces I'll talk about some of the
things we did in the sensor space to
provide abstractions on top of Java ME
and then I'll talk about some of the
communication specific abstractions so
we're moving along here so what were the
keys we wanted to integrate individual
solutions so that you could pick those
abstractions and move them to other
applications if you wanted to so again
we're building a whore vertical solution
for container monitoring but we don't
want to rule out other applications so
each abstraction is kind of a hole in
into its own and doesn't necessarily
depend on though it works with the other
abstractions we wanted an overall
architecture that supported always
connected and limited connected devices
this goes back to solving that problem
we talked about with Nats and the
difficult the difficulty in reaching an
internet-connected device for some small
value of connected and finally we wanted
to make sure the services could be
reused so what does that abstraction
look like well if we break it down into
three pieces we have a device piece
where most of our abstractions live
because they sit on Java ME we have
protocols that we use to push and pull
information from the communication
gateway which kind of becomes the hub of
all activity and then we have the back
end which is a set of rest interfaces
where applications live for example the
database will pull messages out of the
message store and make the data
available for other applications so
within the abstraction layer we fit in
our security our data encoding and our
retransmission strategies for delivering
messages successfully to the
communication gateway the communication
gateway can then buffer things which
allows our sleeping notes to wake up on
their own schedule and pick up data when
they need it or when they're able it
also gives us a nice clean line for
multi-protocol support because being the
Internet of Things we want to use IP
everywhere we can but that doesn't mean
that IP is the only radio technology
we've already managed to mention zigbee
and in this particular project we used
iridium while iridium can be gateway to
a UDP based transport you end up then
inheriting the the inherent
unreliability the you part of UDP which
isn't always the best way to go so it
turns out the iridium folks offer an
smtp service where you can actually have
each of your little 270 byte packets
mailed to you which is you get little
email attachments that have binary data
on them yeah but the nice thing is it
adds the reliability back in because
they have a reliable handshake to the
satellite reliable handshake from the
satellite to the ground station and then
at least being smtp based you said on
tcp and while we all know email does
occasionally get lost it tends to be the
exception not the rule so if we take the
engineers drawn three bubble diagram and
we apply it to something that might look
a little bit more familiar if you've
been to other Java ME presentations or
IOT presentations this week the Oracle
vision for IOT you have on the left
gather and enrich happening over on the
device you have communication mechanisms
that send things back to a gateway which
interestingly enough looks like our
little middle bubble and then the
majority of acquire and organize and
analyze live on the back end so this
diagram which was done about four years
ago three to four years ago
interestingly looks like what Oracle is
from now promoting as the inventor of
things so as a research group we felt
very satisfied that we were apparently
on the right track now what we'll do is
we'll look a little bit more at this
part because being part of the Java ME
embedded track I think this is where a
lot of the interesting stuff happens so
if you look at the way we built our
smart node we have on the bottom the
hardware that we passed around
we have Java ME as provided which has
some low-level drivers in it the two
layers of most interest will talk about
here are the sensor framework and the
libraries the libraries are where we
build in the system level abstractions
and we try to insulate the developers
from the specifics even of device API or
a GCF and then we have the sensor
framework which really is where the
intelligence lives in that's going to
handle our message queuing some of our
message transmissions the device logic
for in this particular case the
application is an intrusion based
application monitoring shipping
containers location and intrusion and so
that logic will set up in the framework
but again is generalized enough that it
could be used to monitor anything not
just shipping containers so we'll look
at the use of multiple sensors that
generalized interface what the goal of
the message payload definition was and
then demonstrating ways that that is
showing how that is extensible without
having to modify Java ME or without
having to modify the application
significantly so what we did on the
sensor front was instead of dealing
directly with the device API and mating
that to the application we put a layer
in the middle that defined what a
generic sensor might look like and so if
you look at the eye sensor definition
that we've created you can see some
housekeeping things like a self-test and
it is healthy which kind of let you
probe the device the keys here really
are allowing you to get a value
interrogate the sensor for its name find
the sensor ID associated with it and
find the number of channels that that
sensor addresses now by channels you can
think of something like an accelerometer
which might have three axes so you'll
have different sensors so you might have
one sensor object but you might have
multiple sensor IDs and that channel
little channel handle here lets you find
out how many of those that you can ask
about likewise you might have multiple
temp
your sensors on a device depending on
how widespread your your network is
because we built on the spot technology
it is not currently implemented but
entirely possible to use the node that I
the large note I hand it around for the
container with the addition of a radio
to use remote temperature sensors and as
a matter of fact I didn't point it out
but there is actually an atmel Zig bit
radio on that module it's just not
currently used in our in our application
so having an eye sensor interface is
great because now you can actually talk
to something that is a generic sensor
you can get its value we don't impose
any particular constraints on the value
other than they have to be int now what
that means is at layer 7 of your
application protocol you have to have
agreement on the device and on the back
end what that integer is going to mean
first of all you could have something
like a temperature which isn't actually
an integer so you have to scale it you
need to know you're scaling factor on
both ends and you need to know what
units whether you're talking about
Fahrenheit Celsius Kelvin so there are
still challenges as a framework you can
only provide so much we're providing a
conduit for the data there still has to
be end end agreement on what the data
means your personal opinion that's where
the one of the biggest challenges today
is we can argue about protocols and
encoding formats all you want but until
you get somebody at the application
layer on both the device and the backend
to agree what you're sending will always
have challenges and I think that's going
forward for the Internet of Things one
of the big challenges today so we took
the eye sensor interface and build the
that isn't a typo I intrusion sensor ah
in our project we were using I for every
I star for all our interfaces so the
nice thing with the intrusion sensor
interface is it allows us to set a
threshold to be associated with a
particular sensor adapt that threshold
and you'll notice we pass in temperature
humidity because we found out some
interesting things about sensors
especially things like door coils which
do inductance readings they're heavily
affected by temperature and humidity so
allowing a sensor to adjust its internal
readings based on external data became
critical we also have interfaces for
monitoring intrusions and checking
whether something is actually in an
intrusion state so what that allows us
to do now as a developer developing a
new sensor by implementing to this
interface the application of the sensor
developer can implement the logic
required for their specific type of
sensor and still have it plug into the
generate framework that we've created
without changing the application what
that means is I simply I've simplified
this fair amount but what it boils down
to is with a simple loop of all the
enabled sensors we just call check
possible intrusion in our framework and
any sensor that gets plugged in through
a small addition to the library code to
add the sensor interface and a small
change to the application to add that
sensor to the list of enabled sensors
and you've now extended the framework
haven't changed the JVM only only in a
small way have we updated the
application so the extension happens you
connect the hardware you do an
implementation I mean you can't really
get around in a hardware world adding
new hardware without doing a little bit
of development I mean that's just the
state of where we are today and again by
using eye sensor and I intrusion
layering on top of the device API we're
going with basically all standard
interfaces to minimize the work that the
developer has to do communication side
the part that's that's near and dear to
my heart so we talked about the
difficulty in finding or reaching a
device that only intermittently
connected there was an even higher level
issue that we found it very quickly
which is we're all used to quote
addressing a device as
an IP address or a hostname you know
everyone everyone hit by now yeah
probably even your grandparents have
seen dotted quad addresses at some point
they may not know what they mean but
they've seen them well the reality is
what if we have an Iridium only device
well it has no dotted quad address so we
realized we needed to create as part of
that abstraction a separate addressing
scheme and our communication gateway
then became also a kind of a
multi-protocol version of ARP if you
want to look at how do you resolve
addresses so our gateway in our device
have mechanisms for mapping a unique
globally unique identifier which in our
case was just something that was
assigned at manufactured time to a
transport specific address for
communication again we push that down
into the transport development so that
only new transport developers actually
need to worry about it as an application
developer in the framework you just have
a globally unique address communication
is handled below that communication
gateway gives us the mail boxing for
push-pull and again you'll see as we
look at the next layer the intelligence
for choosing between transports gets
pushed below the application so that you
can simply plug in New transports define
their characteristics provide a hint to
what your preferences would be and let
the framework manage which of those are
used so the generalized message format
that we you that we chose on again we
didn't want to create our own encoding
because that just causes us to take more
code space especially again burning Java
ME if we wanted to run multiple
applications multiple midlet on the
device why have multiple chunks of code
we also found that in this environment
communication failed frequently so we
wanted to be able to separate queueing
messages from actual delivery it also
happens depending on what you're
monitoring if you know you're at sea you
don't you may want to monitor every 15
minutes for temperature
but unless something anomalous happens
you don't want to send that all the time
you want to buffer the data when using
GPRS when the ship comes in you may end
up with a lot of data you want to be
able to pump that over a single
connection and amortize the cost of
connection setup and all of the energy
spent to get more data off the device so
by separating queuing and transmission
we gained we gained a lot of
efficiencies and finally what floated
out of this was a layered architecture
where you had devices sitting on the
bottom transport layers with that use
standard GCF additional logic on top to
manage the interrelationships between
those GCF transports and a generic
messaging format on top of that that
could be handled by the application but
not necessarily constrained so the main
application of the basic model for
communication the application queues a
message it tells the communication
handler it wants to send something and
at that point the communication handler
does all the work the application can go
back to its normal schedule of sampling
and adding messages to the queue when
the queue is empty the communication
handle goes to sleep and waits to be
called the next time if the
communication handler is invoked by the
main application but knows that there
are communication failures and it's not
going to succeed it can quietly ignore
them and conserve the energy that would
have been wasted with repeated network
access so the model breaks out where the
container application doesn't really
change when the underlying transports
change all of the work that gets done is
it the framework framework layer in the
message store or the main logic of the
communication handler or through the
implementation the extension of the
abstract transport manager class when
adding different different network
transports and then finally a small
amount of driver work again because
we're adding a physical device in this
case there are serial devices they sit
on the new arts of the of the arm nine a
small amount of work that goes into the
libraries again
we encourage anyone who's going to put a
library on the bottom to just use GCF to
do the actual communication since it's
just the serial device so we chose
Google proto buffs to do our encoding
odd reasons I can tell you the big
reason we did some of our own encoding
for starters if you've done any work in
protocols and data encoding and
transfers serialization is just a royal
pain to deal with making sure that
you're reading things out the way you're
reading things in can be very prone you
have to create your own schemes you have
to make sure that your bite types line
up simple things like if somebody
accidentally uses little-endian instead
of big endian you can be chasing bugs
for ages so Google proto buffs gave us a
really nice flexible means with a
somewhat high-level ideal for describing
the data and it just works you know
quite frankly uh why reinvent the wheel
when you don't have to so what we do is
we create all our messages using google
Pro buffs the messages you end up
getting wrapped as an event type if
you've used / debuffs you notice that
kind of as long as you know what the
first thing you're decoding is you can
keep looking inside to see what's left
so by having an event we could wrap any
message with a simple header that
include that global unique ID of both
the source and the destination timestamp
information for for logging as well as a
fairly opaque payload least from the
transports perspective the event builder
is passed in so that the message store
can add some platform specific data to
that message so we track for example
what cues things went through and that
allows us on the backend to determine if
messages got lost we have sequence
numbers but a basic example of how our
application uses it uses the proto buffs
we just have a sensor data item we
create a builder throw a few values into
that we add the battery element into the
actual
sensor data object and then in this
particular method we would return the
actual built object the method calling
this would be creating the event to be
handed off to your communication handler
so the application that does the queuing
creates an event by getting the data and
then we just queue it and our
communication handler is equipped to
handle a set of cues we've done this
specifically for as a sensor framework
we currently support 2 q's it can be
extended the idea was an event queue
were somewhat urgent items for example
geographic information you always want
to know where things are even if the
amount of data might be trailing things
like intrusions you want those to go to
the head of the line you don't want to
get 200 innocuous temperature readings
and then find out two hours later that
oh by the way the container had been
broken into so the messaging framework
the message queues allow for this I'm
going to give up allow for queuing
either basically priority messages or
bulk data and then finally the
communication handler is invoked when
the application decides it's transmitted
time we call the communication handler
we say initiate transmission and then
the application gets out of the way in
the communication handle it does the
rest of the work so as it empties the
data queues the communication handler
decides which transports it's going to
use if a transport fails it marks it as
such if it has network access it empties
the queues fairly straightforward but
it's never that easy because something
always happens yeah the cell tower drops
the call satellite goes out of you or in
our case because we're battery-powered
device if you those of you
do hardware in the room might have seen
that too huge super caps that's because
we don't want to draw directly off the
batteries because it will deplete the
battery life too quickly when you try to
do things like GPRS or iridium
transmissions so we end up doing burst
communications by charging the super
caps when the device is idle and then
feeding off those super caps to do
transmission what that means is it's not
uncommon if you've backed up a lot of
data you frankly just run out of juice
so the communication handler determines
why I can do it why a transmission
failed and again can mark the device as
such so for things like GPRS if we fail
if the tower was just unavailable we
might want to get back on the network in
five minutes and try again well if we
ran out of power we know we don't want
to try for at least 45 minutes because
that's what it takes to get a full
charge and unless we have urgent data
waiting there's no sense getting on the
network just to send part of the part of
the data so all of that logic as you add
a new transport can be handled in your
extension of the transport manager class
and the communication handler will
automatically pick up what those back
off durations are for each of the error
conditions basically what we just
covered you know transport manager is
the key to adding all of that logic to a
generic basically basically GCF
transport extensibility if you want to
use the framework and add something like
a low-power wireless radio you would
simply create something that implemented
I message transport that use GCF or the
device API or whatever your hardware
device needed for communication that in
turn is one of the interfaces that
transport manager implements so you
would then extend the abstract class
transport manager to add anything
related to back off and error handling
once that's done the only change at the
application as we do for sensors where
you would
to the active sensor list you would add
it to the active set of transports in a
prioritized list and your transport
would now be available to the rest of
the communication framework with the
small caveat obviously as a
communication infrastructure there needs
to be something on the Gateway that's
going to correlation that where you
could it's not just sent by William
purpose I keep urs worse than iridium so
let me summarize the question for the
audio or for their recording so your
question is we have different types of
cues for different priority information
and we have the communication handle are
also being able to prioritize the
transports is there any link between the
two of them not at this point but that
is something that we discussed it it
became very apparent that if you've
collected so in this model I'd like to
think we were brilliant in that we have
GPRS for terrestrial land based
communication and iridium for at sea the
unfortunate part of that is you're not
always the top container on the ship you
end up on the bottom of the ship you're
not going to get line of sight to the
sky so you're not going to have
everybody and communication you're going
to get to the far end of your
destination and you may be put somewhere
that you don't have GPRS coverage we
did consider moving forward it would be
nice to have for example a bulk data
queue that says anything put here only
goes over the cheapest transport for
some you know definition of cheapest is
defined by the application or the
developer but that doesn't exist now it
was definitely identified as an
enhancement that would that would pay
off for this but again the beauty of it
is the application doesn't really change
and we've decoupled things so that the
application can do with the application
needs to do and the communication
framework handles and ensures message
delivery so kind of trying to put a bow
on the presentation as a whole what I
wanted to share with you today was first
of all the flexibility of the spots
platform and being able to take a
effectively a hardware problem and make
it as much of a software problem as
possible so with the spot platform we
could do a lot of the application
development in parallel with hardware
which for those of you do embedded
systems development very often you know
the software people are chomping at the
bit waiting for the hardware because you
just you know you have to be able to
code in your target platform using Java
ME on arm you know we were able to do
the majority of our application
development without having without being
dependent on the actual hardware because
of the spot hardware flexibility we were
also able to prototype different devices
different i squared C devices or
different uart based communication
modules in parallel while other hardware
modules were under development we talked
a little bit about you know some of the
IOT issues and the Java ME ME II issues
and really the thing that we found was
the way you solve these problems really
are through abstraction you know Java
gives you great methods for oration same
methods overloaded definition great
mechanisms through things like
interfaces
and abstract classes where you can build
a certain set of intelligence in and
still give the developer control over
that Java ME provides a lot of the
low-level interfaces that we need but at
the same time just like we've taken on
the Java SE side and simplified a lot of
things like socket connections with HTTP
server sockets we wanted to bring a lot
of that to the embedded space by
creating the sensor framework that would
allow you access to the Java ME
prevented primitives but be able to
provide some value on top of that or
hide them all altogether if we if that's
what you preferred and finally what I
think I've demonstrated here is that
we've built an end end solution in our
case for container management we have a
device that sits in a container reports
data back gateways to process the
messages we didn't talk about the back
end at all but we have applications on
the back end that store the data in
Oracle databases use standard oracle
application frameworks like ADF to pull
the data out and display it so we have a
true end-to-end solution sitting on a
framework that can be extended to do
other asset monitoring type not
necessarily intrusion based solutions
the thing a lot of people want to know
then is ok sounds interesting how do I
get it the unfortunate thing is I can't
send it I can't send it home with you
what I can tell you is the artifacts
that we've produced about the hardware
designs and the software framework have
gone through oracle internal processes
and are now with our java engineering
services team they're the folks that do
a lot of the embedded porting work
working with a lot of manufacturers the
two consumer devices so they have these
artifacts and are available to bring in
an engagement to do either something in
this vertical or helping apply the
platform to other solutions also very
recently the entire engineering team was
reorganized into the Java develop the
core java development group as part of
the Internet of Things initiative so you
know our goal certainly our desire it
was one of the lead engineers I can say
we've learned a lot on the IOT space and
we'd like to bring a lot of that
experience an expert and knowledge and
battle wounds and really influence the
Java platform as the roadmap Java ME 8
or Java 8 is pretty pretty solid and
right around the corner but either by
influencing core platform or by building
software on top that adds value to the
Java ecosystem both on the device side
and the back end because I think there's
a lot of work to be done in a gateway
space those those of you who have seen
the affectionately titled big red slide
that has the we have we have part of it
here
you'll have to figure give me I'm my
windows impaired
so the the simplified version of the IOT
slide the IOT team within the Java
development group looks to contribute
across this whole solution space from
the device to the mid-tier and to the
back end so at this point i want to
thank you for your time and attention i
really appreciate considering i know
Larry Ellison was giving a keynote at
one-thirty I appreciate you taking the
time to come out and share some time
with me any any questions
so right now so the question is how can
you get access to this right now it
would have to be through an engagement
with the Java engineering services
organization this isn't an item on the
price list that can just be ordered or
package that can be downloaded from the
internet the actual of the Sun SPOT a
platform the research platform is
available through the Oracle store you
can actually buy a kit it will have to
two of these devices with the full
sensor board and one device that is just
the main board and the radio because we
have some demos that do personal area
networking between them so you can
actually do development on the sunspot
platform excuse me but the actual the
sensor framework is only available
through engagement with the Java
engineering services folks
any other questions no thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>