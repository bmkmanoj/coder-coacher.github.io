<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Fifty New Features of Java EE 7 in 50 Minutes | Coder Coacher - Coaching Coders</title><meta content="Fifty New Features of Java EE 7 in 50 Minutes - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Fifty New Features of Java EE 7 in 50 Minutes</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nA6-8A2Acfg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Aaron Gupta I work for Oracle
and my name is Antonio and we shall
would work for April but I'm a
consultant all right
and we as I like to say get ready to
drink from firehose this is 50 tips and
50 minutes give you complete breadth of
the Java EE 7 technologies in here
hopefully we will stick to the minute
schedule like a feature on a minute so
oh it may be overwhelming but we're here
post the session feel free to come and
talk to us
yeah it's quite it's quite dense but
it's only based on 87 stuff so it's much
easier if you know a 6 because it's only
new things on e7 and actually we're
gonna try to cover most of the specs of
e7 and just give you you know all the
new goodies in each spec we so this is
an architectural slide of all the
specifications on e7 and we're gonna go
from left to right starting with all the
common things on e7 and then JP a and so
on and so forth ok let's go let's go
CDI 1.1 so we went from one point zero
to one point one there is it's funny
because there's not a lot of new things
in CDI per se but CDI has been going to
all the specifications
oh you see as you'll see later so see
the eye itself went from a one point
zero to a one point one a few new things
but not that many
so one thing is as you know in a six you
need AB in XML file and that triggers
CDI and everything is a management so in
CDI 1.0 if in your class path you are a
business dot XML all the poll
a turn into management in CDI 1.1 you
can be a bit more you can have finer
control on that so as you can see
underneath the bins XML file has changed
so on the adder so as you can see it's a
1.1 and on the other you have this new
element called bin discovery mode if you
do be in discovery mode equals all that
means you are the same behavior as CD 1
CDI 1.0 meaning all the bins all the
poles and managed beans but you can also
go annotated so that means only the
beans that have CDI notation so decorate
an interceptor binding scope or
something like that CDI beans or none
you can say I don't want CDI to discover
my pojos and turn them into management
and if you say bin discovery equals all
that means all the poles are turned into
managed beans what you can do then is
vetoed a few bins so you can say they're
all turn into managed bean except this
one except that one so you are this new
granite asian in CDI 1.1 which is vetoed
so you can veto one class or as you can
see in the slide underneath you can veto
a package
another speck that is common to most of
the specifications in a seven it's been
validation again it went from one zero
to a one point one so the new thing is
you can put a constraint on method on
method parameters but also on return
types that's something new so as you can
see on top you can even put that in a
constructor so public card validator is
the constructor of the class and the
parameter is an algorithm and you can
say this is not know so when you create
a new when you do an instance of this
class and if the algorithm is now being
validation will throw an exception and
as you can see underneath we apply the
same thing to a method so a constructor
method and now and as you can see we put
a constraint on a parameter the credit
card but also on a return type a so true
so being validation 1.1 darian doesn't
bring any new constraints so you just
have the same good old ones you know now
not know past future min Max and so on
and so forth you can use them in
constructors and methods and you know as
the API has been going on for four years
now you can create your own constraints
and put your own constraint on a
constructor a parameter or a return type
so your eye has to get used to to that
we put in van rotations everywhere
before it was mostly on attribute in
classes now it's some constructor
parameters and return type so sometimes
it can add a little bit if you have a
main
rameters in a method and of course you
can put more than one constraints
contract and it's in the Javadoc sorry
yeah and the good thing is you know what
you have this at document ated you know
annotation in the j yeah in the jdk that
can be in the Java doc so a Java doc now
now becomes more readable you know the
contract while you read the Java doc
interceptors quick history interceptors
we're in ejb 3.0 then in Java EE 6 they
were extracted out of the EJB specs so
it was aspect per se you know it was
interceptor 1.1 mostly because the
interceptors could then be used in
management in CDI management
well this spec has been updated in 1.2
and something that quite a useful that
we just saw in bean validation is now
you can put an interceptor around a
constructor and behind the scenes that's
what being validation does so you know
what the bottom you have the good
all-around invoke around method now
we've intercepted 1.2 you can intercept
constructor call ok
again back in Java EE 6 in CDI CD I
brought the interceptor binding so it
was you are the interceptor spec the 1.1
CDI 1.0 well when we put them together
there's something called an interceptor
binding in 1.2 because there was
something missing at the time was how do
you pre-pre up pre or with God English
can be tricky sometimes
how can you order much easier okay you
order intercept prioritize interceptors
binding that wasn't possible in in CDI
1.0 and interceptor 1.1 so now we have
this annotation called prior priority
and you give it a number from 0 to plus
plus and you can say this in this
interceptor will have a priority 10
meaning it will be between 9 and 11
okay that's how we can order now
Interceptor bindings and as you can see
at the top there's constants so we can
put an interceptor before the library or
during the application and so on and so
forth we lease with this numbering if
you spin up your now you
Manitou executor or I'm going to take an
executor and let it create my damaged
threads manage you still an opposite or
unable or a colleague oh let's take a
look at it what are we introducing as
part of concurrency completely builds
upon the standard TDK design principle
you know executors in Java EE we have a
manager so just basically leveraging
everything from Java util concurrent
package there was a default manage
executor that exists for you so you can
say you know what just inject the
managed executive service for me just
using add resource in an annotation once
you get well that's one way of course
you can get the default execute or using
the jittery look up as well so injection
and gently look up both of them work
very well if you want I want to define
my custom sorry if you want yeah now if
you want I can also put the executor in
my WebEx enough you know you want to go
the traditional route then you put your
way back in the web.xml you define this
is my gin rename and this is my executor
this is a standard name and then you
refer it in your application again
resource and Jen you look up both would
work now manage executor is one part of
it by which you can get your own threads
managing scheduled executor so in Java
and JDK we have scheduled executors by
which you can spin up tasks at a certain
delay or certain number of times that
you want to execute now you have a
managed scheduled executor so literally
in any Java EE component you can say I
want to have a managed scheduled
executor just like our manager busy
cuter you can use add resource or Jindal
look up to get handle on your manager
schedule executors and then start
scheduling tasks so for example here I'm
accessing using jinni lookup all I'm
saying is context our lookup
this is my default manage scheduled
executor service once I get it
and just like my manage executor is can
also be defined in my WebEx enough
simple samples over here
once I get my executors I can say a
schedule then I can take my call 'evil
tasks so this is a callable or you can
also say my runnable tasks and then you
can start defining Oh start executing
this task after five minutes five
seconds of delay so you say in five and
then you say in seconds
similarly the first execution of the
task is after two seconds and then run
it every three seconds after that so you
can build a complex design pattern which
you're well known of in Java SE land as
well now manage execute or manage
scheduled executed is one part of it in
addition you can also have a managed
thread factory so you have completely
controlling exactly how your threads are
going to be generated so once again we
have a default manage thread factory
here you can say add resource I don't
even need this name actually because in
Java EE 7 says if you don't specify a
name there is a default factory that
will be injected for you so once you get
to manage thread factory either using a
tree source or using jinni lookup then
you can start creating new threads you
know thread factory dot new thread and
you give it a my task now my task is of
course run above and whatever your
business logic is when you say thread
start it starts running because it's a
manic thread you have a capability where
it can say oh is a thread really shut
down right now so you know there is
additional capability that is available
to you as part of Java EE 7 in that
sense and the last piece of information
in the concurrency space is contextual
proxy so yes you can create your threads
you can create your executors let's say
you want to create a random tasks and
start passing some processing context
information to it or jendi transiently
or security context information to it so
you can start specifying that contextual
information to that task any random
tasks this need not be a thread or
whatever it is ok so here for example I
can get
contact service this is my runnable task
ok Here I am saying okay I'm going to
create a contextual proxy once I create
a contextual proxy I get a runnable over
that you will hear itself and then to
the executor which is available to me
this is a standard Java SE executor to
the executor when I submit the proxy
this is running in a completely managed
environment so just at standard Java IC
design principles all of those are now
available in a Java EE managed
environment for you JPI 22.1 so you see
now we going from the bottom our
persistence and will go up into the
service so JP a 2.1 there's a few new
things one of them is the schema
generation those of you who use agile
JPA 2.0 hibernate eclipse link open JPA
they all gave you the possibility to
create a schema you know DDL files from
metadata but not in a standard manner so
in JP e 2.1 you have these new
properties on your on your persistent
dot XML file called Javitz systems so
that's all the standard properties of
JPA dot and then you have a set of
properties schema generation database so
it creates in-memory database schema
generation scripts so it's going to
create a DDL script either create an or
a drop file and as you can see at the
bottom there's also a property which was
used in the hibernate but in a
non-standard way is now in JP 2.1 when
you deploy your application you can say
Javitz dot persistent dots sequel load
script so now when you deploy an
application you can run a script so
that's the perfect
you know the the perfect way of loading
data in your database in a standard
manner if you create the schema if you
create the database in in-memory well
let's go a little bit further JP a 2.1
allows you to have indexes so in JP a
2.0 you know if you have an ID JP a will
create a primary key and hopefully an
index on your prior on your primary key
same thing when you have a join on your
foreign key now you you can say well
this is a book entity and I'm gonna
create an index on the on the ISBN so
when you look at the DDL file now you'll
have create index on you know : blah
blah blah again new in JP a21
unsynchronized persistent context until
now
persistent contexts are the lifecycle
sticks to the transaction so when you
begin and commit at the end of the
commit the persistence context is
flushed you also have the you still have
you also have the extended mode okay so
it can expand through many calls to the
database so a system context can I
either the lifecycle can either be
transactional or extended now you are
this new keyword which is synchronized
so the abscissas the persistence context
in is not enlisted in any transaction
you have then to use the method joint or
transaction so it actually joins and
then flush to the database so that's
also something new and something that
we've been waiting for a long time
is a simpler way to call a stop receipt
you know we all have and databases we
store procedures if we don't like them
or not they're there and so now there's
a nice way to call them so either
through annotation you know as you can
see the name stop procedure query that
works small is the same like the name
query in native query but also you have
an API so you can go entity manager
create a prostitute query or something
like that
so here you create a store procedure
well you give you the name you know the
name in the database the parameters in
and out and you can call easily store
procedure in the database JTA 1.2 well
for those of you who have read the
specification well first of all well
done because it's a tough one
it hasn't involved since 2001 so there
was JTA 1.0 then 1.1 there was a minor
update in 2001 and then nothing why
because the transactions have always
been in a JB area so the container the
EJB container was hiding all the
complexity and delegating to JTA which
is a very robust and stable API well it
has evolved in in 1.2 because now we
have created this notation called a
transactional I know the spring lovers
will say well we had this a few years
ago yes well we have it now you should
have
should have joined the party into the
JCP a few years ago and give us this
idea anyway
so now you can take a managed bean so a
servlet a rest endpoint a POJO not just
an EJB and add this annotation and your
POJO your servlet your resting point
will be transactional and then it relies
on the mechanism or the EJB so you see
here my transaction is required but like
the EJB
you are the requires new support
mandatory and so on the good thing as
you can see then the you know exceptions
in Java are messy so in EE they are
messy too now the good thing is you can
say look this being seve as you can see
it's a rest endpoint this bin is
transactional and if you receive a JMS
exception rollback if you have a SQL
warning do not roll back and behind the
scenes it's implemented as a CDI
interceptor so you can see we have the
CDI spec the Interceptor 1.2 spec
working hand-in-hand with JT a win 1.2
so let me emphasize the importance of
this annotation once again this is
exactly how rod Johnson and the spring
fanboy has made fortune but now we have
it in Java EE 7 so effectively you're
getting your container manage
transactions in a POJO
outside and egb container EG bees are
not complex you can just put annotation
on a POJO and they are becoming all that
they're giving you all that benefit but
if you really want you know I don't like
EJB is just for my mind lock you have
that transaction now in Java EE 7 by
which you can get all that functionality
as well and another thing in JTA
1.2 is this transaction scope in CDI you
have the request scope the application
scope the conversation scope well this
scope has been implemented as a CDI
scope so again specs working
any an end and the lifecycle of this
being you know the book being at the top
as the lifecycle of a transaction the
beginning and the commit and your beam
will live there with a transaction scope
EJB 3.2 then well not much as appened
from 3.1 to 3.2 the idea was to take
some services out of the spec as you
could see the transactional but there
was little bit in pieces one was for the
stateful being you know a stateful bean
passivate they states and activate names
they stayed well now you can say I don't
want the entire passivation and
activation so now you have a boolean you
can say true or false another thing that
has been you know in EJB 3.1 is a
synchronous calls and scheduler you know
the timer service it was in the EJB fool
we brought that to the EJB light so for
those of you who where of aware of EJB
light we've hadded
more we have did most things so an a
synchronous call will work in a waffle
you know in the EJB light so again
that's new
JMS 2.0 like JTA the spec didn't change
for years and years and years and
actually it's quite a you know released
it's it's quite good I don't know if you
all know JMS and if you have in your
head the amount of code to send a
message and receive a message well now
things are much easier we still have the
connection factory ok the Google
connection factory and we have a method
that creates a context context that
gives you a JMS context and with the JMS
context well you have access to the
entire API so you can do context dot
create a producer send a message to a
queue so in one line of code you can
send a message with the context you can
create a consumer
and receive the body which is a string
but it could be an object from a cue and
you know in 2013 it's the fashion of alt
fashionable to have the fluent API you
can do stuff like that
you take the context and you say I
create a producer I set the priority or
the message the time to leave a delivery
mode dot send the message to the cue so
now we can do things like that in
Jamie's tube we use the auto closeable
of Java 7 so you see in the try block I
have the connection factory I create a
context and I don't have to close it
because it implements the auto closable
interface so that's also that's
simplifies a lot the code in Java EE 6
we had the data source definition so
that was really good with one annotation
that you could put anywhere in a beam in
an EJB you could define a data source
we've pushed that into GMS so now as you
can see on the top instead of going to
the admin console of GlassFish in jboss
in creating your factory and so on and
so forth you use an annotation in JMS
connection factory depth definition and
you define a factory and again you can
do the same thing for queue or for topic
so you deploy this bit of code and
container will create JMS factory and
definition for you thank you so
something to highlight here is for
example typically when you give your
archive for deployment you have a
deployment script that is associated
with it now create this JDBC resource or
create this JMS resource etc now all
that code could go as part of your war
file itself so you can put your
destinations definitions datasource
definitions in the war file and say what
this is my archive this is my deployment
script use
and if you can hop back here for example
here in the GMs context you don't even
have to do connection factory context
CDI what we have a core context
programming model here so you can just
say inject my context this is the
application manage JMS context you can
also have a container of manage JMS
contexts in which case you just say at
inject JMS context and container takes
care of for you all right now in servlet
you know this is a very traditional do
get method of a servlet when you are
doing input-output in a servlet then
this is how you do it traditionally so I
said essentially you say from the
servlet request get me the input stream
you can read from that you can continue
reading from the input stream in a for
loop until you get minus one now minus
one could be of different reasons
the client has stopped sending data
which is good the client forgot to send
data you keep getting data in the
connection times out and there are other
reasons by which you can get this minus
one now this is sort of a greedy
behavior we don't teach our kids to be
greedy that's the same principle we
applied with Java EE 7 sharing is good
you know I keep telling my five-year-old
that's the principle we're applying here
so we are using the standard suspend and
resume design pattern so the idea is on
the server side if you have data you
tell it that the data is available then
you have a callback which says ok I'm
gonna go read the data that callback
really is my read listener similarly if
you are trying to write the data then
you have a write listener so you tell
the server in a while the processing is
going on that thread is suspended for
you and then when there is data to write
you call the write listener it gonna
write it back to the client and then
gets the job done so we've introduced
two new interfaces read listener and
write listener and in the real estate as
I said there are method which says on
data available or on write possible
those are the callback methods that are
being called to actually do the data
read and write so essentially in my
async servlet for example I could easily
say on the input stream just set the
read listener in the read listener you
have actually implemented the data where
you are saying
how I'm gonna read the data okay we're
gonna talk about WebSockets a little bit
later but essentially the way WebSockets
work is it uses standard HTTP protocol
and in HTTP defines a mechanism by which
you can upgrade the protocol from
existing HTTP to something completely
different a completely different
protocol in WebSocket that's called as a
connection negotiation handshake and it
goes to WebSocket but now to enable that
you know in a servlet 3.1 we have added
a standard API so today WebSocket is
just one use case you know if you want
to build a new different protocol on top
of TCP this is your way so you can say
I'm gonna add a new HTTP upgrade Handler
I mean that's that's how at least we
have done it in the WebSocket
implementation of GlassFish so we say we
have a WebSocket upgrade Handler that
exactly knows how the WebSocket protocol
works we do the connection negotiation
handshake parsing of headers all that
and then it takes over so essentially in
connection I have an input stream and
output stream you can see this is a very
basic level protocol but extensions are
completely defined by what you care
about in servlet if in a web.xml if you
have any HTTP method if you have none of
the HTTP methods being expert being
available like they have security
constraints define them as they are all
safe none of them can be involved or at
least they with the default security
applies but here let's say I have a
method which I max which are URL which
is being exposed or say which is saying
ok HTTP cat is available but that is
secure but everything else is exposed so
because only get is protected here
everything else is exposed so what we
have done is in servlet 3.1 we have
added a capability we can just add a
single element call as deny uncovered
HTTP methods by adding that simple
element over there what you're saying is
fine get is secured get is my you know I
mean I have my security credentials not
shown on the screen but they're in the
web.xml
by adding that element what you're
telling the servlet 3.1 runtime make
sure all other methods are not
accessible so that means put post delete
none of those methods could be called on
the servlet if you want to call them
make sure you explicitly assign security
to them so this is again going to a
tighter security model so little bits of
pieces lots of improvements in all these
minor technologies WebSocket to me is my
is sort of my favorite technology in
Java e7 this is where I've seen the huge
attraction part of headers you know
folks don't know about WebSockets so
they want to learn about it and which is
cool you know I think you want to be
associated with cool technologies you
don't wanna be asleep with legacy
technologies like spring so stay cool
this is the church and state kind thing
you know you can convince me don't worry
the biggest advantage of WebSocket HTTP
traditionally is chatty you know the
number of HTTP headers that needs to go
back and forth between a client and
server one second is one directional
that means the client sends a request to
server server processes it and responds
back so there is nothing from the server
side that can be initiated and the third
problem with HTTP is when you are making
a request to the server side for e to
request there's a new TCP connection
being established so establish a TCP
connection and establish the HTTP
connection senders chock-full of headers
and when you get the response back
teared all that down now send another
thing the whole thing repeats all over
again that's exactly where WebSocket
come in handy WebSocket is full duplex
that means client to server server to
client and it's bi-directional and they
can send messages to each other
independent of each other so there is no
request response design pattern per se
client can send to server and server and
server and then server can just send one
message you correlate them to make a
request response and the best part about
this is this is over a single TCP
connection you take an existing HTTP
connection upgrade
to WebSocket as I explained earlier and
once it's WebSocket that's it everything
all the connection and that TCP
connection kind of stays as your
pipeline and then you can push messages
back and forth from client to server in
that piece very powerful for real-time
application highly scalable because of
the way of the architecture because
WebSocket is a very lean protocol now
how do we enable that in Java EE 7 again
pure voodoo suppose you're driven
programming model take a POJO so public
class chat server I put that single
annotation over there server's chat and
server endpoint I give out a URI where
this is the URI where my endpoint is
hosting then I have a method my business
method and on that method I put a
notation called as at on message by that
what I'm saying is hey this is a
WebSocket endpoint once it's receiving a
WebSocket payload this is the message
that should be dispatched and I'm saying
my first parameter is string because
WebSocket can send string data and
binary data so this is the message that
should be called when string data is
being received and the payload is
automatically gonna inject it into my
string parameter so I get my whatever
text message is being sent into my first
parameter and see how I'm going through
and the second parameter by the way is
the client that is sending the request
so what I'm doing over here is I'm
saying ok tell me all the open sessions
add this server iterating through them
and broadcasting my message so literally
if you count the number of lines they're
about six lines you have a fully
functional chat server fully functional
chat server and six lines of code now
just one class no deployment descriptors
nothing the UI may not be fancy but hey
you can always make something fancy but
this is a fully functional code by the
way we also have life cycle callbacks so
let's say you want a little bit more
control on who's connecting when they're
connecting then you can start putting at
on open on closed on error kind of
annotations on your methods and then it
gives you a little bit more detail what
is the client that is connecting what is
the client that is closing so you want
to maintain
own life cycle life state all that can
be done now we also we have a server end
point that I talked about because but I
said WebSocket is a bi-directional
protocol so not only there is a server
end point but there's a tonight end
point in a typical web application your
client and client so to say is you will
JavaScript API which is the web socket
API which is render done by the browser
for you but if you want to do a web
socket endpoint using Java then we have
the annotation for you called as client
endpoint and once again the programming
model is very simple so instead of
server end point you say client endpoint
of course the client endpoint is not
listening at a URI because it is
connecting to a server endpoint but it
allows two directional or bi-directional
communication between client and server
of course I need to kind of bootstrap my
client so I'm going to say container
provider give me the WebSocket container
and then connect to so-and-so server as
soon as you connect then your lifecycle
callbacks handlers are engaged the
client is connected the server is
connected the two are peer and then the
conversation is happening between the
two we talked about the annotated
endpoint sometimes people need lot more
power in their application and that's
exactly what is given to you by
programmatic endpoints so in this case I
don't have any annotation all I'm saying
is take a class make it extends endpoint
so this is my programmatic endpoint and
in that case I'm just getting a single
method literally call as at on open and
at on open again session is my client
that is trying to connect optionally if
I want I can configure my endpoint you
know I mean I have lot more control over
how my WebSocket is going to behave how
I want the connection handshake to work
you know what headers are coming in what
headers are going out do I want by
default for example if a client request
comes in a new instance of an endpoint
is created and used to serve the
endpoint do I want to change it to a
single instance of endpoint a shared
instance of WebSocket endpoint all that
configuration can be very easily done
using my endpoint config parameter over
there and then finally when I'm sending
a request back or if I'm taking a
request n I can either take it
synchronously or asynchronously so the
message handler is registered I can
either make it whole or sync or I'm an
async so you can get synchronous which
is whole and async which is a sync
Handler and of course you have a string
and a binary implementation of both of
those this is an example of what I was
talking about earlier how I can
configure my endpoints so I can provide
an implementation of my configurator
over here and in the my configurator
there you go so I can see what my
endpoint instance looks like I can
modify the handshake these are standard
methods that are available to me so here
for example I can make a single instance
of class serving all your client
endpoints and that's entirely possible
now
WebSockets sends natively sends binary
and text data which is good
but in in your WebSocket endpoint is
that how you want to deal with it do you
want to get a string every time and deal
with the string and do the processing
and parsing everything I hear no and
that's exactly what we like because the
idea is you want to deal with your
domain objects so and but we like design
patterns via geeks so and the way we
handle that is we have this concept of
encoder and decoder so the encoder and
decoder are again just blink same simple
classes all this is I am a string
encoder I'm a binary encoder or I'm a
string decoder and a binary decoder I'm
going to take this I'm going to take
your string payload and convert it to
your domain object and vice versa and
then on your endpoint you specify my
decoder and encoder so in this case for
example if I look at my chat message on
my chat method then the payload is not
strength the payload is chat message so
the idea is my encoder is taking the
string payload converting it into a chat
message and that's how I am dealing with
it so kind of makes your code a little
bit clean instead of taking a string
here and converting it into a chat
message that's called as a separation of
concerns design pattern
here is a it is a tentative
implementation of my decoder so I could
say my decoder implements be coded or
text and I'm converting into a chat
message I'm decoding a string returning
a chat message and there is a method
called as will decode so you can specify
multiple decoders and so you're getting
different kinds of string data they can
have multiple decoders which would the
first one which says will decode true
which I actually kick in and convert to
your type similarly I can do encoding as
well
now expression language now that's
another specification which has been
existing into the java ee platform for a
very long time but we took it out and
made it as a separate specification
because this is very very useful by
itself and the idea is when every time
you're using a web door XML for example
you know anytime you write in for now I
mean within the quotes you put English
text expression over there
but take an example of bash for example
you know we will talk about batch in a
second but in batch XML for example you
can put a name of the beam over there or
in beans or XML you can put our in order
in a JSF page for example or XHTML page
you can put expression language over
there how does it get render that gets
rendered by Al so the idea is you can
upload that concept make it more
generically applicable now I can have a
il processor so in your own application
for example you can define a
configuration file and your real
processor would know how to handle that
EAL expression so you take that evil
expression you do the resolution create
the beam or do CDI injection or whatever
you want to do with it but the idea is
in your own configuration file you can
have own il expressions and you define
the meaning and the rendering of all of
it by yourself so here for example I'm
saying I'm creating a new processor and
then I'm defining a new beam on the île
processor the new name is new employees
Charlie Brown and
you can do the evaluation so you can do
all sorts of evaluations here
another fun aspect is this is one area
where the al speckly has worked very
closely with the JDK 8 team so you can
even have lambda expressions as part of
you know if JSF is rendering if JSF is
using EF 3.0 to render your pages you
can actually put lambda expressions
right there itself that's me okay well I
think see that's the good thing about it
that's what i meant by in the beginning
drink ready to drink from the fire hose
we build the slides but either one of
can give any of the slides JSF faces
flow now typically when you build your
web application you have a few pages say
you know I want to go not shopping cart
so I'm gonna enter the details whatever
I enter in that first page based upon
that I'm gonna show you the second page
then I enter the details in the third
place in the fourth page so on so forth
now up until now if you are using JSF
for that application you are on your own
to how to package those applications you
define your own conventions you define
your own packaging etc but now in JSF we
have added this concept of phases flow
nothing new a lot of knowledge coming
from Apache phases flow ADF flow and
other technologies but the idea is it
defines a standardized way by which you
can package your application so for
example here I'm saying in my web app
directory so if I think about it as a
maven application so in my web app
directory I have a flow one directory so
that's my flow one in their flow one
just a convention that we are following
if you're having flow 1 dot XHTML
that's sort of your entry point to the
flow and then you can define click on
this bar and go to this page you use
your default navigation all of that in
this case I don't have a dash float or
XHTML file which is ok I think this is
not in the flow right now
it's not just French keyboard I think
this is it was not very happy we're not
in the flow okay now here for example in
my flow - I have a flow - float or XML
so as I said there are conventions that
are available for you by which you can
say this is my entry point and this is
how I'm going to go through it if I
click on this button go here and so
forth but you can override all of that
convention using declarative flow - -
flow dot XML my GlassFish server is
trying to update itself don't do that
please right now okay
that's bj7 oh never never happened with
us so fast so anyway you can define how
your flow should look like in terms of
entry point exit points and return
points all those nodes could be very
easily defined declaratively over here
we also have an annotation if we have a
sample for that oh there you go so this
is my entry point the convention is over
here and then here I have my declarative
now if I want I can define the flow
programmatically as well so here once
again we have a CDI annotation called as
add add flow definition it's a CDI
qualifier basically you put that
annotation over here it's a produces
annotation and then in that define flow
method basically what you're saying is
how I'm going to define the flow entry
point exit points return nodes all of
that in addition we are also adding
something new colors flow scope so
transaction scope was the first scope
that we added to Java EE 7
we've also added flow scope what that
means is the life cycle of the beam is
tied to a flow if you are in a flow the
beam is active if you are not in a flow
the beam is not accessible or is passive
very effectively so the biggest
advantage of this is really not just you
know having this annotation but a
standardized packaging by which you can
package your flow as a jar file and ship
it to a different war file
and all of that functionality is
available right there instantly we also
have a flow local storage and extended
expressions over there another new
concept that we have introduced in JSF
2.2 is called as resource library
contract now JSF 2.0 make big
improvements in terms of how you can use
XHTML and CSS in truly enabling MVC kind
of architecture you know your view is
purely XHTML and CSS model controller is
all backing Java EE components now with
the resource library contract what you
can do is you can take your look and
feel' package it together as a jar file
and again it's a complete module so you
can for example in this case in my app I
have index blue dot XHTML and index red
dot XHTML and in addition I have a web
enough labor contracts library one dot
snapshot jar that's it in the jar file
which could be supplied to other
projects as well I have a Mara M
contracts directly something new that
we've introduced to JSF 2.2 there is a
blue and a red directory and then in
there I have my specific style sheets
and templates so the idea is in the
index blue and index red I can just say
contracts is red then the background is
all red so I say it's contracts is blue
and the contracts is all go so once
again you can package your look and feel
they will cooperate to look and feel
whatever you want across your apps and
bundle it in your file and the third big
ticket item that we added as part of JSF
is html5 friendly markup now think about
it you know in html5 we have added a new
element by which on an input text you
can say a type the type could be tell
which is a telephone number or a number
or an email or an age or things like
that now the way JSF works if you
specify that on an H :
input text which is essentially what
gets translated to my input text Jeff's
a runtime says you know what you're
adding an attribute that neither my
nor my UI component understand I will
ignore that attribute and I'm gonna not
convert it to HTML and send plain HTML
back well that's not html5 friendly so
we're not really leveraging html5
features over there so what I can do now
is I can say P colon type P is a
namespace prefix you can choose whatever
namespace prefix you like P is the
namespace prefix which is in the past
true namespace and that's a standard
namespace defined by the JSF
specification so the moment I say P
colon type equals email the JSF runtime
says I don't care what this element is
I'm just gonna pass it through as it is
to the user agent so the generated HTML
for you in this case is type equals in
love now the browser does all the magic
for you in that case and the browser
says hey you know what
this is type equals email I have the
html5 components define exactly what
type equals email means so I'm going to
do the right set of rules and I'm gonna
apply that I hope you're not using
Internet Explorer as your html5 browser
but I hope you're not using Internet
Explorer as your primary browser last
but not the least in JSF we have also
added just like you know finally date
picker got added to JavaFX
we have added file of behold this is
2013 and we added file upload to JSF
simple h : input file we point it to
poggio B and click on a button and the
file gets uploaded the way is connected
remember file so it's all connected to a
multi-part element back in the day in
the servlet so for example if a backing
beam is a servlet then you can say load
everything you know using a multi-part
message and each part or multi part of
the multi-part message can be
accordingly processed the serialization
of the file is still up to you because
it gives you access to the data that is
coming across
I have a sample for here yeah so you
have the part over here so for example
here it says file upload beam this is my
file upload beam and it says file I map
it to a part and then you just have
access to the stream that is available
to you and you serialize it to the disk
so one very missing feature in jax-ur is
1.1 was the client api it would allow
you to create a rest endpoint not to
consume it so now we have this new a new
API you see you take a client builder
you create a client with a client you
target a URI that will give you a web
target and with the target you request
either XML JSON and so on here I do a
get you could do post put or delete that
will give you an invocation and you
invoke this invocation and that will
give you a response 2013 we love fluent
API so you can write things like that
you can try and build it dot new client
dot target and so on and so forth
that does it get and return the response
but the gate can even take a type as you
can see at the bottom get string and
that will return a string so that's
something new we have seven minutes to
go jax-rs also gives you a synchronous
asynchronous client call like ejbs and
so on and so forth
now you can you have the async api
method there and it will return a future
like a synchronous in EJB and at the
bottom once you are this future you can
do a get ok
that's Java SE 5 stuff but it can also
have a synchronous call on the server so
here I can create a new thread and
resume this thread at the end so if you
have a long processing
rest endpoint you can do it in a
separate thread sorry I'm rushing a
little bit message filter it's a bit
like interception and so on and so forth
so you can filter either a client
request or container request so on the
client side or on the container side and
you implement either the client request
filter or the container request filter
you get a request context and like
interceptor you get the context you can
know you know which method is indicated
the URI you can change the parameters
and things like that
just like interceptors but on the Jack's
arrest side entity interceptors again
like in the web sockets where you code
you encode and decode that's the same
idea so you can either intercept inbound
stream or outbound stream and marshal
your your entity so an entity in jax-rs
is the is the body of of your rests call
okay so here I implement the right
interceptor the meaning that when I
receive when I receive a stream a body
an entity of a rest call zip it okay so
it's the same thing I can encode and
decode Marshall and Marshall same idea
a brand-new spec jeez on P so G's on
processing it's a bit like juts P you
know
xml processing so it's a 1.0 and like
Jax p it's quite a low-level api so you
have something like an object builder so
to create a JSON object you create an
object builder and as you can see you
can add nodes so add the ID equals 1 2 3
4 the date etc etc and I can create
another object
you know how Jesus is like XML you know
in a hierarchical mode and you build at
the end so you have you have actually
you know your G is an object you also
have a puzzle so again very low level
because here you take you take a JSON
file you have a JSON parser and then you
pass each event so if I receive an ID
then I trigger this event if I receive a
date then I trigger the discipline it's
a very low-level API
I've heard that in Java EE 8 we might
have a G's on B so like the jags be
something that will do binding between a
POJO energies and stream this one is a
very low level to do things fast on
energies and object we have five minutes
to go let's go so batch processing you
know everybody is familiar with the
basic concept finally you know I think
it took them about what 15 years of
VMware to finally start contributing
something back to JCP and this is
definitely one of the big contributions
you know where VMware was very actively
involved in GSR 352 now in Java EE 7 we
have first-class support for batch
processing true batch processing the
concept is you have a reader a processor
and a writer reader is the one that
reads from a stream processor is the one
that processes the data and then it
gives it to writer for aggregation and
then the writer when it's ready is going
to just write it out to the database or
whatever stream you like okay now the
whole programming model is driven by my
job XML so I have chunk as my processing
style and then I'm saying my reader my
processor my writer my reader says read
an item using JP a processor says take
the item you just read
convert it into maybe an account which
is my GPA energy object and then finally
write it up which is basically giving me
a list now chunk is the primary
processing style in addition you have a
Bachelet processing style as well where
you can do one and half tasks like
upload the file or send an email or do a
file transfer okay in the batch
processing itself just like spring we
have lots of concepts of listeners you
can have a step listener a chart
listener a job you listen our listeners
a lot different levels that can be very
easily incorporated there are interfaces
the abstract classes values to me keep
the programming model really simple and
yet make you powerful and effective you
must skip through this one
this is powerful now you can take a job
and you can say I want to split up the
job I want to run it into multiple
partitions I have a multiple core
machine I want to make sure that it runs
across multiple cores so let's say you
want to read a million records you can
say I want to split it up into four
different codes where my first core is
doing one to first quarter million then
quarter million to half a million and so
on so forth so you can split it up you
can literally define a partition so for
example you can say the plan is to have
two partitions and what the start and
the end values are you define the
properties and those properties are then
read accordingly by your readers and
writers I think they're opening the door
that means they want to kick us out
something else that we also have in
batch is how we can create workflows do
this step next and this next and based
upon the exit status of the job this is
the next step that you want to follow so
you can clearly create complex workflows
as part of the job XML itself yeah this
is showing the split
another example of workflow now Java mil
and GTA maybe we'll just talk through
that now in Java male this is again you
know from 1.4 to 1.5 the main
improvement over there is how we have a
simple annotation a lot more poggio
driven annotation that is given to you
so for example you can define a mail
session definition over here you can say
what your host is what your properties
are and then you can inject that session
assets once again simplifying your
deployment stuff you don't need to
create all those sessions etc by
yourself well I don't know anything
about this now just to finish you know
as a whole
Java 7 is trying to simplify things we
were talking about the default data
source so now you can look up a default
data source and it's so different that
you can even know name and same thing
happens for the Germans Factory and so
on and so forth so I think the entire
message of Java is 7 its make things
easier and more portable and if you
haven't tends to it quite yet you can
buy a few books</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>