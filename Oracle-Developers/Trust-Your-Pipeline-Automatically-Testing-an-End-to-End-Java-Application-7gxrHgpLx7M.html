<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Trust Your Pipeline: Automatically Testing an End to End Java Application | Coder Coacher - Coaching Coders</title><meta content="Trust Your Pipeline: Automatically Testing an End to End Java Application - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Trust Your Pipeline: Automatically Testing an End to End Java Application</b></h2><h5 class="post__date">2017-10-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7gxrHgpLx7M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello
to tree hi hello it looks like it's
working
so welcome so so we are the what's
prevents you know we are we are in
between now and the JCP party right so
so the so who is coming through the JSP
party yes so there's some invites here
if you're anyone wants to invite some
disease P party just can out I'll just
put here in the first chair I'm not sure
if it's to available for people should
get out there I'm just gonna put here
for anyone onto this P party invites
just coming here I'm hoping that you can
just bring this in and in get in the
party but the party starts exactly in
the middle of our talk right so don't
don't leave for the party okay stay it's
take to the end all right so we're gonna
talk a little bit here about testing and
pipelines so I think yes okay lots of
people walking around you see good thank
you okay right so yeah so what since
everyone is walking around let me anyone
else you know one here get one here one
here alright okay one more alright so
yes okay just get yeah
yet Sam get one here okay thank you
alright okay if you don't if you don't
didn't get one sit down with someone
that has one and go to the party you
know anyway okay Brasilia start right
yes all right so let me start you know
before before we start talking here but
let me let me ask you this whole
discussion here is about testing in pipe
pipeline so who here is already have a
automated pipeline okay about half of
the room most more than half of the
roryd it has an ultimate biplane so
who's already more or less yes okay
alright so you already have an ultimate
backline but right so who here is
already you know you don't have to do
anything you it's automatically goes
from from your your code repository to
production doesn't need to be you know
just commit and go to production not not
like this no the hope
the pipeline does everything
automatically okay that's a dream for
someone's okay that's good all right so
who here has already does this really
automatically right to you
you know you commit your code and
eventually shows up in productions are
you doing anything alright just a couple
of people and they didn't they didn't
leave their hands up and for long enough
so that so they're not so sure okay
that's okay that's good and so just just
a quick thing here your land is looking
for that camera and she asking your
phone number so yes okay good all right
okay all right so okay so so we're going
to discuss this the pipeline is in the
one the reason why most of you have an
automated pipeline and then we don't put
things in production automatically is
usually because we don't trust right you
know we don't trust what we're doing and
instance we don't trust what we're doing
the last thing we want is that something
that we don't trust shows up in
production right and so that's the whole
objective for us here is talk about you
know how we can how we can trust this
this this whole pipeline right and one
interesting thing is that you know every
time we try to talk about automating of
tests what happens is everyone so who's
doing a web application here grab who is
in a mobile application here right so
who's doing up the cage that has no
interface okay a few of you people right
so api's mostly cool right one of the
things so the guys that they're doing
api's and it has no interface it usually
don't have that problem but every time
we have an interface an application what
is the thing that we love to do is say
well I can test interface right because
it's a testing interface I'm testable
application that's great right so so
basically what happens when we do this
is that we end up you know putting a lot
of test to do the interface and and then
we kind of ignore the rest of the test
because we're test the interface anyway
right
and the big that we have there's there's
three things that test and needs to do
for it should be you know
remember we have we want to trust right
and to trust our suite of tests need to
do three things right first of all it
has to give us fast feedback if you have
a suite of tests it doesn't give you
fast feedback what happens you don't run
it right or even worse you run it but
you run infrequently or sometimes your
tests you start running and take several
hours or several days for that test to
run and then when it comes back the
result in you know you see oh that test
failed oh but that was code that I did
last week all right change it so I
ignored it you know I just ignored the
results right so it has to be fast
otherwise those things happen the other
thing that has to be is it has to be you
know repeatable it has to be you know
how to trust that when he fails it fails
when it misses it misses right and a lot
of times we need to you know because if
you'd have a test run one time it works
you run around time he fails every time
he fails you say oh yes it fails from
time to time so don't worry about it so
you can order tests right so you know if
you have a test like this then what
happens is that you you should remove it
from from your suite of tests because
it's just kind of preventing you from
thinking about and the third thing to
your test our test has to be is it has
to help us find where the problem is
right because you know you have a test
something failed and if you don't know
what it is you say oh that's his codes
right it's not mine is his code so you
know he worries about it right
so we developers were very good at
throwing the problem to someone else
right so you know so because of those
three things when you only focus on
testing on the interface that's the
interface fails on those three
three-card cry tears right because
interface test is very it's it takes a
long time it's very hard to do it takes
a long time it's it's no it's it's
resource consuming its time consuming so
you don't run it frequently enough and
so you know if you put a lot of tests on
the interface that's notthat's fails the
second thing is that interface test it's
very flaky right so you know sometimes
you run it one time in there's a tiny
delay of milliseconds delay then he
fails if it doesn't have the mean
lazy works right so you're always unsure
if the tests really failed what was a
network problem was something else you
know so it's very it so it doesn't work
around this and the third thing that
tests that that interface has happens is
that every time you know once something
happens you have no idea what what got
went wrong right there's so many things
going on in your softer that you know if
the test fails was the database what is
the you know what's the network was
something else a good except with this
if you do let's say you we create a bug
on the login screen all right so you
users cannot log in a hundred percent of
your interface that's gonna fail and
you're like oh man the whole thing is
downright the databases problem there
has promised the the API has our prime
number no it's just it's just one little
component that's failed because it's
very hard for you to find out what's
going on right so that's why instead of
you know so that's why when you talk
about trusting our codes we have to
think much more than interface test and
it's very natural when you don't have
trust in our application that we're
going to put a lot of tests on the
interface right and and the end result
is that we actually make it worse
instead of better right so that's why we
have to talk about more than just
interface test we have to have a whole
pipeline of tests right and so to talk
about this I have here on expert on
testing and aleeah's it's you know his
is a guy from Brazil that's right that's
why I have the Brazilian flag over there
but aleeah's is Ana specialist of
interesting that's what he does for a
living he only works with testing
testing comes in in constituting of
large companies in large code base about
testing and he is the he's the
coordinator of the test tracks of server
important events in Brazil so with you
aleeah's Nogueira thanks
you know the brewery is the most
important person about chopping Brazil
so thank you
by then okay right so try to be easy
with me because I'm a tester another
developer and I'm a developer really
well I love it attests at the test out
of my life engine up to now so we're
going to talk about first about
different test levels so we got a lot of
different test levels this one it's call
it that's not pretty pretty good in the
screen but this is a test pyramid what
this test parents do we have on the
bottom of the parent the unit's tests so
we have in the middle of the pyramids
while you call services with components
integration in the API test and bottom
of the parent the web or mobile UI tests
while we have the unit test on the base
of the pyramids
can you guess why because this is yes
it's pretty fast and if you find a final
bug on the unit's test you'll be really
fast to try to make the back working for
you and you can spend less money try to
fix it isn't it but if you if you find a
bug in UI it's gonna be hard than it
you're gonna spend more time in more
money at least ten times it's call it
Mayer's root stink by the mayor's rules
so we can also create some tests not in
UI and not and use tests that can be
done for for nowadays about API tests
about Microsoft's tests you need to
trust your micro service and Microsoft
is the base of the between the your
backhand and your UI UI what everywhere
if you use on mobile or a button or web
and you need to focus in these each
levels and unit about code coverage and
aesthetic analysis
it will be more faster to find bugs and
you search layer you need you must to do
steps mocks and service tests and you a
test you can do a lot of timing
automated tests in UI perspective and a
visual regression testing to see of your
front end will broke with some button of
some different colors some different eye
things on the on the screen on the user
perspective so if you're gonna so so the
reason you know so every time you you if
you don't really want to trust your
application you know you need to have
tests in all those little those layers
right because if you just focus on on
the interface layer for example then you
know you have all these problems we're
talking before and and soap so base what
we're gonna show you guys here is how
you can you can use tests and all those
layers and in these layers it's all the
time ultimate I'll just I'm motivated
what's right
into incest it's all about end-to-end
tests you start in the unit's test and
you want to stop on the UI this is
include end-to-end tests yes and to home
and test we can put in the this
parameter into entering tests and which
type of tests we can put into our code
base and your pipeline this is a gel
test quadrants we supposed to work with
agile methodologies see most of
companies so we're gonna start all the
time about testing on units testing
components test that's the first egg for
the q1 and after we gonna work if the
testers or somewhere in the our team to
do functional tests or some kind of
touches that need to be functional like
start test prototype is own examples in
this functional tests we need to focus
on at least and the three main things
the hep path I'm do all the things right
and on the under user interface I need
to this one I need to do the sad path
the things that can wrong and I need to
guarantee that it's gonna be wrong and
this perspective if you try to fuel some
inputs that are required you don't feel
it and you use to be to also do the
alternate paths three types of tests in
the frictional test is a lot of tests
but it's do it and after we have the q3
the most important thing here is about
user acceptance testing like let's
suppose we found a startup to sell fried
tickets what is the most important
function on my act for example let's
read gas
I will sell tickets Oh needs to
guarantee I continue sell tickets so I
in the user interface I supposed to have
try to find dates so you feel with two
dates and airports and how many tickets
I I will you have to buy after probably
are you show the all the flights I will
select one and the next screen I will
show how you can pay it and put my
personal data and after you get a
receiver its decline it or it's okay you
can flight tomorrow so the most
important thing user acceptance - means
do all these steps ok and the functional
I will do like you try to fry a date to
put the I will go today and we will come
back tomorrow or will come back
yesterday it's not allow it the net it's
more functional test as user acceptance
testing
and the q4 you have some tests that that
are not all the time doing or our
pipeline but you need to put in your
pipeline you need to put in your test
code base about performance testing
security testing your the ility testing
there's a easel and I want to six about
ility testing about some kind of testing
we don't go all the time with our code
base with your pipeline you do perform
stats in it if I run a my pipeline to
get a feedback and I have perform
station probably two takes too long to
get my feedback but it needs a must run
performance test in one once per week or
whatever you guys want to run it okay
you have a lot of different test types
to putting our pipeline here so with
this we need to get some insights on
your pipeline about machines and about
how we can execute this in a wave way in
a mobile way en1 microservice ray so we
need to meet mid servers for integration
tests for service tests for API tests we
need to get machines from execute a web
test with the Firefox Internet Explorer
doesn't that's not a web there's not a
web browser but we use it and we need to
get some devices to execute in UI
perspective for mobile you need to have
it in kinda trace on the doctor machines
it's a pretty good and
clown device on promise on whatever or
with your real devices or real servers
on the honest on your site so basically
you know we have we have those two
different views of testing right so one
is the test quadrants that's that you
you have all those possibilities of test
for you and and which one is it's it's
the best for you to use and on the
pyramids basically we have two a the
idea of the pyramid is that it allows us
to think about well if you're doing a
you know unit test we should do a lot of
those tests because they run very fast
right we're gonna do a UI test we really
have to focus on just the very few use
acceptance tests right so so you have to
take a look at both the quadrant and the
pyramids to actually decide how many of
the tests you're gonna do because
otherwise what happens is that if you
don't think about the pyramid you kind
of end up creating for example very few
unit tests and lots of UI tests and then
what happens that you get into all kinds
of trouble to enable these in the dev
ops way we need to talk about a
continuous delivery continuous delivery
has one principle that's a three
principles one of this is a continuous
testing so we need to post QA or testers
together working with developing
operations we know we know about that
but a few examples we can do this
between development and testers or QA we
can automate builds and apply automate
testing as well between QA in operations
we can automate the testings in get a
continuous feedback from the operations
create some scripts to try to realize if
your application is running out green
off it's it's not runny before is acute
all the tests and between operation
development automated provisioning from
some machines some cloud device some
clouds servers
okay so we have to
create some interactions between all
these three people the developer the QA
and operation to try to start a real a
real pipeline with tests okay yeah and I
think that I think that the most
important thing that we we all want is
sector to create this automated pipeline
every time we talk about DevOps and it's
it's it's so really the the the way to
implement DevOps is to create this
automate pipeline right because they're
Pappas's it's a mixture of of
automations process that will help you
from development out of h operations and
so you have to get have involved people
from from both sides actually make this
happen but really what we want to do is
actually add to this pipeline to the
DevOps pipeline everything they need to
be done for our koats you get from from
from development all the way to
production so we're gonna focus here on
the specific steps of the the passing
pipeline so so inside of your pipeline
you're probably gonna have you know
beauty application you will package your
application you're gonna deploy
application different places there's
lots of steps you're gonna do and then
we're gonna focus here on the steps for
the testing right so probably you guys
have a pipeline in your code base so we
need to put some testing some testing of
testing in your pipeline so we have here
all the levels of testing is starting
about unit testing and following by
integration testing service doesn't I
can be translated by API testing
backstop C testing acceptance testing
functional testing sometimes functional
tests come first about acceptance tests
but here we try to figure out if my in
my startup if it is I cannot sell
tickets why you can run functional tests
with I know that I cannot sell tickets
but I'm not I need to first try to
figure out if all my user perspective is
running greens when well okay so for
integration tasks we need to marks
things to get a faster feedback from the
user perspective and from the test
perspective in the service test we need
at least four different levels for API
test for rest apps of our Microsoft
starting first one is the smoke test and
it's just points to my API it's ugly
it's HTTP mm it's okay
and contract as I need to send a get a
get or post and I will come back with
JSON and we've returned with a string an
internal objects and a try to figure out
if the contract if all this those
properties it's okay it's not a it's all
that oh oh it's all there or it's have
some more that they can not figure out
before someone has a lot more
information and I cannot see it before
and I have the functional testing that's
I came asserts that's all the data
returning with my API it's okay and
acceptance that I will create a test
suite with all this the scenarios for
example try to buy a ticket before the
user interfaces with this services okay
after we have disciplines testing yeah I
will do is mock the essence with the
most important test that I have in the
flight tickets by flight tickets and for
fortunate assets basically this the high
path they set paths and alternate paths
all all this last two I which we need to
run in parallel execution they are
really really slow to the cutes
comparing two service integration on our
unit tests so it's wrong it's faster in
a Perl execution with some servers some
browsers different mobile devices we've
how the integration test from functional
tests I need to do non-functional tests
in yours levels
not not in your pipeline all the time
but I need to put that to the cute
sometimes and for for creates this all
the test coding base I need to put some
screenshots to validate that I passed
the I pass all the tests and I can
guarantee that there is acute it logs
reports data management is sometimes I
will automated a data management as well
I not put some hard code hard coded
sightings onto my code base so I needs
to run without my IDs on Maya being bank
account is the same it's a bad thing if
you're putting in the test code base and
I have two parameter out of the
parameter parameter eyes at all the
things to get like I can point my
website to a local sites for a testing
server or for a production server so
it's really easy but sometimes most of
the developers and testers forgot to
change this output it's in the
parameterized way and so so you can see
that there's a lot of tests you can do
to get trust on your application right
in and when you look like this and say
well there's a whole lot of work that I
need to do but that depends on on how
much trust you need to put your
application in production right so a lot
of times when you're just starting in in
you know you today you do some kind of
like quick test before you put in
production so he start to automate you
start to put more and more of those
tests until you get you know the level
of trust that you that you want right
and so and there's a there's there
several tests are very easy to start so
to do so for example smoke tests are
just kind of say you know is it runny
right so those are like you know very
very easy one so you can you can start
with those just to have initial any
tests that you push it lets that's one
interesting thing about tester of course
when we talk about all those kind of
things all of those possibilities it
looks like well I'm not gonna never
gonna do test then because it's so many
things to do but if but whatever think
you have you do more that you do today
you get more trust in application so
intense is a cumulative thing right the
more
as you do every time you run them you're
gonna get more trust right so by
starting to do those things it slowly
you you're gonna get more and more trust
in application so we have a tool box
that are going to show to you some free
tools first will be the register it's
for the testing for the API Stanford API
testing for mix framework services
following by selenium webdriver it's a
well-know browser automation tool and
after the appian that's a like selenium
but for mobile devices okay and I'm
gonna show a life code about these
crystals so we have a little example
here about our pipeline I don't not go
shown to you about inside and Jenkins
inside and circle CI I would just show
to you how to use it with tools and you
can put easily in the your pipeline so
we have a service test acceptance test
in functional tests with this three toes
okay so basically basically we're gonna
do now so so what we're gonna do now is
actually show all of these things
weren't running and you can see that of
course it's a small placate but you can
see that there's not a whole lot of
things they need to do to automate all
those kinds of tests and and and in
sometimes even if you do you know just
just by as I said before just by
implementing a few things
it improves you how much you trust in
your application and and then you can
keep adding more and more things right
so a good strategy would be for you to
do one of one test of each one of those
and then keep adding it to your software
until you you have the the level of
trust that you need
here I have a rash assurance that's
really easy to use
we're sure that works with the Gherkin
style given Maidan so all the things you
need support in a given wind anyway so
like the insert person given I have the
content type like JSON and the body a
new person you are a senior so when I
post person then I get stat coach 2001
it's pretty easy
yes that's a smoke test right you just
say it's okay yes right so not testing
too much but these we call it a smoke
test we just insert a person and get the
stud codes it's it's running okay it's
all green okay these are our is mocha da
a smoke tests so in the lead in delete
third person and get person I test
basically the stats codes here
okay I just don't care about the data
right now after I need to do some
functional testing so you go to show you
it's running on the end point my local
host in the this base path so now I will
like a gutter person by IG I will start
a person first we forgiven when n style
given I have the content type D so with
a post me Haley Elias when I post person
then and stretch the ID because I need
to first create a person to after try to
get or try to deletes try to alter the
previous person
so after when I get person with the data
G that was created then content type is
JSON and the body name is equal Elias
and the address is RS and the hobbies
automate tasks and the start codes its
mm that's okay this is my test this is
my assertions it's why the magic happens
if you go on agreeable I'm going read on
your tests it's the same for the others
the test here in third person is the
same delete person is the same but I
just change some assertions in some
stats code here it's pretty easy isn't
it you can test a lot of micro-services
with these two with russia shreds
we're starts a good question I have a
back end here running in a Java spark
it's already running I have an API here
with my with a database so I have the
server running now with the old API here
can read it yeah if you register
shirking keen wit swagger into the magic
yeah
and after that's it that's any questions
about what assurance no sorry King hero
tradition yeah it is supported but he's
just education away so I don't have it
here it's fully supported taking shorter
ization management cookies okay
how you start a server I said here is
that manually just to show the you the
codes how can you use pressure to put
your pipeline okay after we have the
yeah the thing the thing they're not
showing on the demo is is the whole
process of the pipeline itself I so yeah
three products so this so those are the
tests but that that would be inside like
a Jenkins server for example that would
deploy the application and everything so
so we're just kind of running and just
showing the test itself for the web
interface I have here unscripted with
selenium webdriver there's a pretty
verbose but they're pretty easy to
understand and I have a front-end here I
will do first test model model test
creates a person like Bruno address SP
hobby Java that's working pretty good so
I will do the same with the the
descriptive with selenium so first I
need to download some driver about the
driver they're gonna use not after all
the drivers are all the open sources
they have some kind of code that's not
open so I need to get like a translator
between the my codes in my Rio browser
let's call it browse called a driver for
selenium so I have the chrome driver
from the Google Chrome execution I have
the Google Chrome here with selenium
webdriver all the insulin webdriver
start with starts within webdriver class
so when I stand she ate with the any
browser Chrome browser Firefox browser
international Sparta browser
I get the all the counter of this
browser so I can get the page that you
access after I need to try to find
elements in my web page to try to
manipulate it try to send some
information try to get information try
to click on the buttons so for this I
need to inspect my elements like this
Add button
in the brows inspector and I gonna show
here I'm gonna see here if this button
has an ID and has a class and has a NJ
click so all the web elements that has a
ID is a good idea because I can find my
ID that's sometimes not changed
sometimes change but I can get the
element and try to find this like a
driver find element for me that element
is by ID add and clicking it but in this
line as I'm user angularjs interface so
it's supposed to be some synchronous
requests when I try to add someone they
screen the screen not change just I'm
show up like a pop-up shortened like my
Moritz and HTML tags here so when it's
to wait for anything in the next screen
to try to get another field and try to
fill it because selenium doesn't doesn't
care about if I have a synchronous
requests or not they just running as
fast as he can so I need to tell
selenium wait for some time wait for any
button or any requests or any message
and after you can continue and after
right after I post all this information
like that the same way drivers find to
me an element within some IG or some CSS
selector or some names or some x-factor
and other weights of find elements in
the web I can after
but some assertions to guarantee that is
running okay okay but let's run in this
script
you're gonna see and then you go nuts
I'm gonna see but not order we're here
pretty fast script and it's over here
down here
it runs seven seconds it's not so fast
but you try to run again you know so
that's that's an interesting thing right
so you have one test that took seven
seconds right when you run on unit test
you sometimes you hunt you you run
hundreds of tests in one second right so
you know that's that's the thing we're
talking before about the interface test
is a lot slower than then you know it's
fast here in one test but you know it's
a lot slower if you're doing like a lot
of them and for mobile testing I have
the same app the same user interface but
for an Android sorry call it a Pew if
you it has has the same API that's there
selenium has so the is the same creator
but the little difference here is I'm
gonna test as a UI advise mobile device
so we need to tell to a pew which mobile
devices it is here I have an Android
running in the Android emulator with
this previews app install it with this
package named detective name and I have
it here
running on genymotion it's the same we
have on the the web because they're
using API to get all this to things so
to make it happen
it's here above it's same as selenium
that a previous show to you and Driver
find by elements find elements by ID'd
and clicks and get taxed in what the
difference here is about the ages and
how can expect some ideas or some
components in a mobile device I need to
get UI Automator viewer and androids
and now I can inspect all these
components
like Bruno like this button and I can
see the no details about research eg the
class package the content description
and all the same way with I haven't
researched a DA view get it because it's
my ID and to round this are we gonna use
the appian on like in the NPM package so
a paean session over right it's run a
server here to try to connect with the
device between my code I will close my
application
you're gonna run
or mobile script it'd take a long time
because you know emulators take much
time to is equal to automated testing
and of course we're doing ours
of course we're doing the emulator here
but the exact same test you can run on
the device or in themselves right but
you can also hire cloud services that
will provide you you know hundreds of
different devices you can run the same
exact same code on on the cloud own
device there on the cloud so you don't
have to manage the devices themselves if
you these actual lawton running because
he don't see it the presence of the ID
the fab button that's this Add button so
let's try to run again you can see it
all the time in the emulators in a real
device he's supposed to not happen and
so that's another example it's good that
happened because that's another example
so you see that he run the code and
failed and then he's just running the
same code again right and he might work
right so that's that is the problem of
the UI test right even in a simple
example like this sometimes the UI test
works sometimes it doesn't and and if
you rely a lot on the UI test what
happens is that you know the developers
gonna say wow it didn't work this time
but he worked it last time so that's ok
I don't need to change anything and in
fact there might be a code problem it's
really flaky so it's all green but took
it at least 37 seconds to the kids that
a lot of time yes you know so one test
run 37 seconds so if you if you if you
rely you know there's some people that
kind of they want to create that instead
of creating thousands of unit tests they
create hundreds of of UI tests and then
in the ends you have a big problem
because even hundreds of tests are gonna
take a long time to run and they're
gonna be flake like you just saw here
and and the end result is that you end
up not trust in your
the pipeline at all because of those
things and how I can put all those codes
in the my pipeline my real pipeline I
can just create a test suite and put all
the class to execute one by one so in
the this for API test I gonna turn
around first my smoke test my smoke API
test that we points to the get or post
and return some stats codes functional
walk API test
I have markets my API first to execute
to oh it's all green
so again runs the production or running
data server and after the function of
API is the same from the mobile or the
web tests here I can have suite classes
with add pairs on other person in the
room pairs on the complete suite for
accrued application first to after to
try to do the functional tests like it
try to not feel all imports interact
saving the person and the same from the
mobile suite so I can put this all these
test Suites in your pipe in our pipeline
easily and brandi's with without some
problem so if I already have a problem
you figure out in our pipeline with less
pain okay
okay is it
yes oh please go back to there
now as you can see we create some
scripts and run it to make sure that
pipeline will make real so we can put
and Jenkins our circusy I in any CIA
tools all those does in the easily way
all we have to do is create and test and
and know about these tools and start
using these tools and as we said before
you can start right you know just by
adding one of each one of those those
tests in each category you already get
more trust and then you can iterate in
every new version of you know you you
can add more tests and then the more at
you know the more tests you adds well to
limits right you know you you add enough
tests that they give you confidence and
then you can really put this whole thing
to on an ultimate pop line and then you
can then you can get you know from
comets cheap production out totally
automated with trust right because any
of those tests we will would would stop
your your application should go into
production with application instead bugs
okay okay so we we're not gonna have a
lot of time this is one question I might
we have some time somewhat for one
question but you know all the source
code for for this example is available
on the github and also you know we are
we're doing Lea's is gonna do like a
more deeper dive on on to this
discussion here for testing in a
buttercup we couldn't go back to Brazil
we're gonna do a webinar where are we
gonna kind of have a lot of time to
answer your questions and see your
problems that you are having in your own
you know our own project so if you want
to if you want to have access to that
you know you can come to code for life
it's a list of we have a series of
videos about career there and aleeah's
are gonna do a webinar on code for life
about testing so if you want to join
that you can just join that site right
there
okay so anyone has any questions like
one one question one minute we have one
one minute no questions okay everyone oh
there's a question right
right
so so his discretion was you know if you
should clean up the data right insert
data and should delete the data right
you need to do that it's it's about the
data data management on the whole
pipeline you need to get all the data
clean before the secret testing or
create some strategy to clean up all to
use or reuse some data in your pipeline
strategy for database testing we have to
be unit there's a great tool I use all
the time
Java fakir not for database testing will
create some data without just input the
data in the code it's a very good one
the last one it Java faker yes Java
faker faker faker a fake
yes so on that on under on github there
is the list of tools and there's a step
by step that you want to if you want to
run this yourself okay all right thank
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>