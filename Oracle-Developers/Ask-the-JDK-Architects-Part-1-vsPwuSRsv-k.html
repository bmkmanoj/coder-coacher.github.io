<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ask the JDK Architects, Part 1 | Coder Coacher - Coaching Coders</title><meta content="Ask the JDK Architects, Part 1 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ask the JDK Architects, Part 1</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vsPwuSRsv-k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">first pool will tell you who we are just
in case you don't know my name is Mark
Reinhold I've been working on Java since
1996 which is probably a sign of some
mental disorder I've done a lot of stuff
I keep doing stuff I am working on on
project jigsaw and and a bunch of other
related things at the moment Brian my
name is Brian gets the architect for
java language and core libraries and I I
did most of the architectural work for
for lambda and Java 8 and now I have the
distinct pleasure of looking at the the
far down the road features for after
java and I and the value types and
specialized generics over our values and
primitive Xand other really cool stuff
so John Rose JVM architect I've been
doing dynamic languages since the middle
of the 80s but I had to switch from Lisp
to Java in 1994 and I'm unbalanced glad
that that happened and since then you
may have heard of something called Sun
misc unsafe we're still trying to get
rid of that yeah that's that's me and
also inner classes and jsr 292 invoke
dynamic and other stuff like that I've
been bouncing happily around in the Java
ecosystem since 94 and Michael Vince
that I've been working with JVMs and
Java sins 2002 Akkad guy and now I've
shared custody of the JVM architecture
to get it with John I guess there are a
variety of other other other people in
the audience who are also arguably JDK
architects so we might drop on them
Marcus for assistance that needed
especially if they're sitting in the
front row okay so as I said this is QA
here's here's slide number two you can
ask questions in two ways you can tweet
using that hashtag assuming the Wi-Fi
holds up although it seems to be holding
up this week or you can ask in the
microphone and if you're if you're near
the front I will walk over to you if
you're near the back I'll ask you to
walk up because it's far more efficient
for you to speaker your question than
for one of us to try to summarize it
okay GUP have no questions okay dun dun
dun how long is this cable would you
finish those idea about ra objects from
keynotes would you finish your ideas
about array objects from the keynote so
the background on the array objects is a
initiative loosely titled arrays 20
which has multiple multiple branches to
it if you look in project Panama you
will see of OpenJDK you'll see the
beginnings of discussions about new
array interfaces that's one of the
prongs of arrays to do is basically
figuring out what the natural shape
today not in 1994 but today is that what
an array ought to look like and it has
much more bulk style capabilities than
individual element access that's the
theme so there's this very new language
called APL that gets it right
anyway so that's that's part of the
story another part of the story with
arrays is allowing the JVM to create new
kinds of arrays that give it a certain
amount of flatness there again hardware
today does not prefer to use lots of
extra in directions and pointer chases
when it accesses data structures so
arrays if you look at how hardware wants
to work with arrays they ought to be
flat and indexed by simple linear
address calculations so the JVM if you
want to see an example that look at the
JVM language summit presentation by
guilt na that's that's a that's a sort
of a concrete proof of concept of these
flattened arrays of in one particular
instance so we're we're prototyping that
in project Panama although you won't see
any code on that right now another
aspect of new arrays is arrays that are
not necessarily all in managed memory
that can be projected outward into the
native heap and that's very important to
if you work in a system where your data
is being managed by C code and not all
by Java code and I'm thinking of a
database type things like Hadoop in
those settings you need an array which
is safely manipulable from Java but can
be projected out into some big buffer
maybe in a mapped file somewhere so
that's and I haven't said anything about
operator overloading and I don't intend
to because I'm not sure yet how to
salvage the existing array syntax but
the semantics are all very extensible
and that's the vector we're working on
right now
ria fiable types
so this is a question that comes up a
lot is when are we going to have reified
generics and I sympathize with a
question III when people ask me this I
try to dig into why is it that you want
real file types and it's quite
remarkable the percentage of time that
the answer is some version of because R
is your silks and people have this
pervasive idea that a ratio sucks and
that reification is better and the vast
majority of them cannot tell you why
they think it ought to be done this way
instead and so that kind of gives us
pause about the you know the value of it
there are there are there are a couple
of reasons why you might want to be able
to have reified generics one of them is
deserialization frameworks you were
deserializing from XML or JSON two
objects this is a very common common
case where people want reification
another is the interaction with arrays
are arrays a razor covariant generics
are invariant so you can't have a razor
generics without you know without
breaking type safety and so you know
that that's another rough edge but if
you look at the costs we're not
convinced that the costs are you know
that are really worth the benefits but
what we do think is worth the benefits
is being able to do generics over
primitives and over value types so
ArrayList event where the backing store
is not an array of boxed integers but an
array events and that gets you better
memory density better locality and
generally not forcing the you know the
programmer to make trade-offs of
convenience against performance and so
we're very interested in doing that and
that is a form of reification because if
you specialize ArrayList out you know to
end that specialization is effectively
reified but we're not actually sure that
erasure is as bad an idea as everybody
seems to think it is and certainly if
you ask architects for other languages
like fiber to ask martin odor c or dirty
what I should do about reification he
would say please don't do it I love
erasure you know and there's a lot of
other languages that run on the JVM that
are totally uninterested in having
java's wild cards baked into the M
semantics for quite good reason so you
know it's easy to say reified types are
great look C sharp has them um you know
shouldn't Java have them erase your
socks when even a fix that mistake blah
blah but we're actually not convinced
it's a mistake and so what we'd rather
do is look at the the things that you
can't do with carnet race generics and
address those problems and so like I
said one of the biggest the biggest use
cases for reified generics is
civilization frameworks really what you
need there is better type literals
that's a lot easier problem to solve
than than reified generics similarly you
know the real performance problem that
people care about is having boxing
forced on you if we can solve that then
we don't maybe we don't need it so
that's a that's sort of where I am from
a language perspective I know John do
you have further perspective on that
from the BM side well to carry on a
conversation in the hallway just before
this someone was asking me about why why
you don't have reify types and it seemed
to me that the part they really wanted
was for serialization like you said and
and that requires a better type token
mechanism which you can sort of see
inside the VM and you can accidentally
get to it through some parts of
reflection but maybe what we need is a
first-class way of getting a type token
period yeah did you want to follow
yeah that's the yeah that's yeah yes
that's more about boxing sucks that's
dust-up people have suggested that we
should get rid of every primitive life
in the jaw language and do it small
smile is everything I want to I want to
follow up on the on the boxing comment
because basically what we have is boxes
that are objects and so people I have
actually heard rumors of people maybe
after midnight synchronizing on integer
boxes yeah right so the the if you treat
a box as an object then you remove any
hope of optimizing it because suddenly
it becomes something it has to be
tracked by the by the compiler that was
a language decision not a JVM decision
to Uniqua Phi the first 32768 so right
all right hey guys right now at last I
yeah hi I take responsibility on behalf
of my company
but what we need is a new kind of box
and that I want to give a work in
progress name to that I want to call it
a haizen bucks because it's one that
appears and disappears it will depending
on how you look at it and that will be
the box that can't be forced into object
behavior the vm will will prevent you
from doing it as opposed to allow you to
do it once in a million and therefore
right now you don't get any of the
optimization even if you're not the ones
in a million case so the highs and box
would basically be a ghost when you're
trying to pin it down as an object so
it's time to cook some highs and boxes
questions on twitter will the Java
plugins survive the shift from plugins
to html5 and the trend towards plugged
endless browsers that seems unlikely
browsers don't support plugins it's kind
of kind of looking like the end of the
line isn't it another question what is
the coolest thing coming in Java 9 that
you are excited about well I'm biased so
I'm not going to answer that all of
these guys give their answers they're
less biased than I am
alright mark I'm setting you up here I'm
pretty excited about the jigsaw
reorganization of the source code well
well gee John glad you mentioned it in
fact we did that just a few weeks ago
and i think the the most interesting
thing and the thing that has you know
some of the most you know potential to
do something in 9 and do more in 10 is
the introduction of link time
optimization possibilities so you know
java has historically only had the
opportunity to do make make compilation
decisions at static compile time when
you run java sea and at run time when
the dynamic compiler kicks in and for a
lot of things static compile times too
early and at because you don't
necessarily know what you're linking
against and runtime is too late and as
part of jigsaw we're introducing a
linker which has the possibility to do
whole program analysis at knowing what
versions of what other modules it's
linking to and be able to do things like
inlining statically across modules and
all that and i think that's that's
something that has a tremendous amount
of potential I'll pitch for the fact
that we are is significantly improving
on and will obviously be doing this for
a long time but improving on the garbage
collector side of things as well so it's
everything from big oops some work some
significant part of that work was
started in seven already and has
continued in eight but I think we're
making actually good leaps now in terms
of stabilizing and getting g1 to the
point where it's really competitive so
both big heaps and low latency short
pours times or even pulse miss which is
the same thing holds true though it's
it's work that is going to happen some
party 9 but you know follow up in 10 and
beyond as well that that work is never
done that work is never done right okay
well nervous there's always more garbage
live questions
and if I understood correctly then with
chicks oh and these internal calls to
for example unsafe for going away I'm
wondering because I maintain why I'm
yeah I'm a member of a mocking library
and we kind of worried about what are we
going to do in the future because
without unsafe allocate instance or
without access to reflection factory
basically we can pack in so I'm
wondering if you have plans for that for
the future so unsafe is a double-edged
sword there's a lot of cool things that
it does and there are certain libraries
that absolutely need it and then there
is an awful lot of libraries that use it
that have absolutely no reason to be
using it and we did a we did a search
across maven central and discovered that
something like some ungodly percentage
of of modules out there depended
directly or indirectly on unsafe
including things like JSON parsers so
clearly while a useful tool it's been
overused and so we're sort of sort of
starting on a program in nine which we
will continue over over multiple
versions to create safe equivalents of a
lot of what's done with unsafe we're
starting with the highest likelihood
one's the ones that show up the most
often which are the you know memory p
can poke building on the machinery
introduced in seven with method handles
we're introducing a similar thing for
data Cold War handles where you still
get all the bounds checking and no point
of checking and type checking that you
that you want but it's the almost all of
that just toys away and the optimizer
optimized it away and you get basically
raw metal speed with full safety once we
have that we're going to migrate over
all the JDK code to use that and we're
going to start the process of
deprecating those methods and unsafe the
second biggest chunk of methods and
unsafe that people use or the ones that
you mentioned for serialization and
deserialization we have a design you
know on the whiteboard for what are we
going to do for those applications we're
going to provide a safe API
44 object serialization frameworks to
use and then once that's out again we're
going to start taking away the unsafe
folks so it's not all happening tomorrow
but the future is is written if you want
to hint as to what we're thinking you
can look at my blog entry called larval
objects in the vm it's a little out of
date but the idea is to be able to
safely create create objects that cannot
escape until you're done initializing
them okay oh thanks hi everyone this
question I hope at each each of you will
answer there's there's an old saying
that an architect knows when he's
finished not when there's nothing left
to add but when there's nothing left to
take away so if each of you had one wish
what would you take out of Java either
the language or the vm anything whatever
your whatever you want invoke special
call me call me serialization you to it
ah we can have two votes for
serialization two votes for
serialization three serialization why
it's brittle it's a it's it's been a a
fertile source of security
vulnerabilities it expose it exposes the
internals internal design of classes in
ways that wind up you know binding you
to your internal representation or
ungodly hacks to pretend that you're
preserving preserving your internal
representation over time the whole
transparent transparent cereal is
serialization oh it's just easy just
serialize your objects thing it it's a
fantasy III know if no practical
programming platform that has
transparent serialization this man has
made it work well it is always is just
always a trail of tears did it was a
mistake sorry it violates some of the
the fundamental principles of object
orientation which is that construction
should establish an object
with its invariants intact and
serialization allows you to create
objects that do not do not appear to
respect their at variance and and as a
result you you write code based on the
assumption that the the constructor has
properly guarded the variance and you
you know you find yourself exposed to
objects and states that you never
expected to find them in so it's just
way too leaky when I did the initial
work on JJ sr 292 with method handles
and invoke dynamic I said well if this
is going to be a way to patch bytecode
we need Method handles to emulate every
single byte code and that led through an
exercise of finding out which byte codes
could be emulated the answer was almost
all of them and then there's a few that
it just could not be expressed in a
clean form which made me start to view
them as code smells so invoke special is
one of those monitor enter monitor drugs
if there's a small number of byte codes
it just ought to have been done some
other way and if I if I really want it
if I could get my wish and in invest you
know a whole wave of brain power in the
byte codes I'd try to get it down to
about ten byte codes instead of the
current 200 I think my vote will be sort
of naively on the fact that you can
synchronize on every single object that
affects a lot of how we implement the
JVM and from a user perspective
understand that it's an awesome piece of
functionality that you can do this but
it does limit our flexibility a lot so
it's sort of tied to both i'm going to
say what you said and also the fact that
value types is actually addressing some
part of that problem as well and so on
so we're sort of moving it we're working
on it but yeah mark barkas where would
you get rid of finalized errs oh yes my
other favorite
what did what a broken idea okay hmm
Dave a proper phantom references which
we don't have today but we might have
soon yeah if I finalizar is just another
another fundament fundamentally broken
idea okay another question in the room
or if you more piled up on twitter could
you step forward please and speaker
question this one's for you Jake jigsaw
osgi jigsaw knows GI what about them
what does jigsaw taking for most giant
what does jigsaw leaving out so jigsaw
is leaving out almost all of Austria
eyes I suppose if you if you if you want
to relate them in that way jigsaw and
osgi are very different things and
jigsaw has never been meant to be a
replacement for osgi I take it you're
familiar with osgi okay so so what is in
osgi there's a module framework there's
a security framework there's a a dynamic
services framework there's there's
there's a whole complex life cycle model
where where bundles can come in and be
activated and later leave and be
deactivated all all of this stuff that's
great if your application needs all that
stuff how many applications need all
that stuff mmm not many it turns out so
you know osgi had you know it'sit's
ultimen problems it's I've always been
impressed that osgi salts as many of
those problems as it does so well while
being built strictly on top of the Java
platform right osgi didn't have the
ability to change anything in the vm or
in the runtime system to support
modularity and they've done a fantastic
job of coming coming up with the model
that works on Strictly on top jigsaw is
not a replacement for osgi post jigsaw
there will still be applications that
that Nino is GI and osgi will work just
fine on top of jigsaw in fact
yet one could imagine the an osgi
runtime being delivered as oh here's a
jigsaw module but and then once it's
running it does the whole osgi thing
with its class voters the way it always
has maybe it can relate to jigsaw
modules as needed but you know there's
not a not a competition here so jigsaw
is meant to solve some different
problems you know first off we need to
be able to modularize the JDK you know
the entire java SE and eventually any
any platforms to do that we need
capabilities that aren't in oh it's GI
for example to ensure security we need
strong moral boundaries those are not an
osgi because strong module boundaries or
something you can only get by asking the
vm to implement them for you and of
course the osgi couldn't do that so
they're they're different things they
will cohabit harmoniously when needed
then that's kind of the relationship
that we see to answer your question ok
another question in the room from
someone who hasn't asked
have you thought of having static fields
for specialized for a specific generic
type so that for each like say a list of
in you could keep track of counts better
this list of something else I'm not sure
I follow the feature you're suggesting
it say you have a static data member
that keeps track of information about a
class or fight with a generic type so if
I want to keep track of separately list
event was his list of people how many
have you know like account things like
that any static information presently
the type array you end up with just one
of the static types of solar parametrize
types so you can effectively do that
yourself today by having a map that's a
keyed by type and you know whose value
is the you know the type specific value
and then there's actually a mechanism in
the jvm was to starting the class
libraries that does that a little bit
more efficiently it's called class value
and so if you're really concerned about
performance there there's a faster way
to do that but I don't I don't given
that that's something that's so easy to
do in user code it does I don't yeah so
so more generally so there are millions
of potentially worthy language features
and for every one of them you can easily
easily imagine oh I could see how that
would be useful in this situation I
could see how that would be useful to
this this this constituency and the
problem is that unlike library features
where you can shovel lots and lots of
features into a library and if no one
ever wants to use the core of a library
it doesn't bother them bother some
people but for the most part it stays
off in its little corner and then
doesn't bother you that's fine but with
language features they have a tendency
to interact with each other and so we
have a strong incentive to keep the
number of language features minimal and
in particular to stay away from the
super niggly little special purpose
features because invariably they will
interact with some other feature that's
added later so
you know features like we would rather
focus on large general-purpose features
like generics or lambda or value types
which enable broad ranges of use cases
rather than special-purpose features
that that are useful in some specific
case but o in the aggregate make the
language more complicated
yeah so so so in general every every
language feature even a big feature
election erics is going to have its
limitations at the at the margins and
it's very easy you know to say all right
well you whip this for and you stopped
here but but couldn't you just go one
foot farther because then it would the
boundary would include my feature
instead of exclude my future but then of
course you move the boundary one foot
out and there's another feature that's
just six inches over the boundary and
somebody else the guy in the row behind
you is now saying oh you know if you
really just moved it one more foot then
it would include my feature this is this
is an endless game of whack-a-mole so
you know there are I'm not saying that
the feature is silly what I'm saying is
there are millions of potential language
features that many of which are worthy
some butcher stupid but many of which
are worthy and that still doesn't mean
that we can even consider doing them and
so we have to say no and relatively
aggressively to 99.9 percent of the
proposed language features because
otherwise it will be pearl and we're
very mindful of the fact that the
languages grow over time it's very hard
to reduce their size and so every
incremental feature is potentially
putting you on the road towards being
parole and you know uh that's it's a
cautionary tale this is the second
question that has come from a pain point
that that relates to the reification of
compile time types a compile-time type
is something like list of string or list
of person a runtime type is list and so
that's that's already been explained why
we do that but it's also helpful helpful
to think that the JVM is not just a
model of the java source code semantics
it's it's own thing it has it has its
own focus and if you leave out the many
details of the java source language that
are irrelevant to actually executing the
program it means that occasionally you
run into these corner cases where you've
lost the information you thought you
might want it but the JVM can be more
efficient and it can expand in other
perhaps more useful ways if it doesn't
have to track every
detail of the Java source language and
that's that's the that's the sweet spot
we've come to and that's why we have
JavaScript and Jay Ruby and other
languages running very happily on the
JVM because the JVM has become something
more of a multi-language platform the
cost of that is that there are times
when it isn't exactly the Java machine
that you that you wished for okay
question from Twitter are there any
plans for immutable collections so I
like immutable collections the Bagwell
collections that have been adopted by by
Scala and by closure are quite nice
they're not as fast as everyone thinks
they are they paralyze better than our
existing lock based mutable collections
but they don't quite paralyzed as well
as you think they do either so you know
we took a good look at the the immutable
collections that I've adopted by other
languages the algorithms are very pretty
there's you know there's good
implementations of them but our feeling
at the time was not quite ready for
prime time and and so with a little bit
of regret we said all right we're going
to wait a little bit longer see what the
the algorithms research community comes
up with and see if there is something
better coming down the pike that offers
the performance of Java users expects
with the benefits of you know of
persistent immutable uh you know kept
collections that you know you don't have
to worry about locking and you could
freely hand out you know references and
all of that that said there's a lot of
good stuff in the pipeline about
immutable aggregates so well you know
what one of the what I was talking about
on sunday before I was so rudely
interrupted by the jackbooted security
thugs who dragged me off kicking and
screaming
was are you you're not talking about me
is about value types or value objects
where you know java the java type system
is fairly simple you've got primitives
you've gotta rays which are
heterogeneous aggregates with identity
and you have classes which are
heterogeneous aggregates with identity
and it's the with identity part that's
problematic and so what value types is
about is allowing you to have
user-defined your programmatic
aggregates that don't have identity that
can be treated as values by the vm that
can be passed you know in registers or
pushed on the stack don't have to be
allocated on the heap that can be packed
into arrays without dereferencing etc
and this is something that we're quite
excited about so just because the answer
was an unfortunate gee we'd like to but
not quite yet on immutable collections
doesn't mean that we're not you know
really really excited about the value
that more immutability and reliable
immutability brings to the programming
model you'll notice that in the current
java api is there are weak notions of
immutability that where you can say on a
collection making it make a
non-modifiable version of this thing and
that's not the same thing as immutable
because it can change in the background
and so forth but the style in java
currently which could be changed but it
would be expensive to change is that
aspects of limited behaviors such as
immutability or non resize ability are
not present in the type of the object
there present in the behavior of the
object so we have exceptions that get
thrown you know illegal operation
non-modifiable things like that forget
what the exact exceptions are but
they're like no pointer exceptions if
your code is correct you never expect to
have them happen so the one way to
combine what we have today with that
style of behavior based immutability and
behavior bates restriction by the way
restriction is good because it lets you
optimize right that's that's the bit
that's the point of many of these
restrictions such as removing idea
d11 idea that we're playing with right
now is retro actively putting a freezing
mechanism on classic java arrays this is
like a small epicycle on a raise to 0
it's it's a salvage job on a raised 11
dot 0 and the idea is to have the vm
able to mark an array as ok i'm done
creating this array it is now in mutable
for real you will get an error if you
try to change it and compilers can
optimize the loads from this without
worrying about simultaneous stores so
that's the sort of a retrofit and it the
reason we're looking at it is it's well
one of the reasons is it's likely to
play well with our existing collections
as opposed to make us have to build a
completely new hierarchy of types ok
quite question the room well all
questions are there a live question from
the room sorry in strategy to lodge JSON
because in Java EE plataforma that you
have a elaborate UJ stone and the booth
not compatible is not make sense to me
let me see if I can interpret so java ee
7 has a jason avi and there's there's
currently a JEP in OpenJDK for a
lightweight json api and they they might
not be compatible that's true they might
not be compatible Brian you Anna yeah so
any library design involves a certain
amount of trade-offs and a certain
amount of assumptions about who are you
writing for and what are the use cases
that you care about its etc and you know
the the Java EE communities and the java
SE communities while they have some
significant intersection they also have
some significant divergences and
assumptions so there were you know a
number of aspects of the design of the
uh you know the json api for java ee
that we failed was ideal for them and
not necessarily the best thing for our
users and so we didn't want to simply
say well there exists another one out
the ecosystem so we'll just use that we
wanted to make sure that what we
delivered as part of java SE was right
for java SE developers and that might
not have been the same thing so a
Twitter question if you've been
following a log on Twitter they're quite
quite a few questions now I'm not taking
them order i'm doing a subjective
judgment of what I think might be more
interesting are you going to upgrade JP
da to jdk 8 feature levels people know
what JP da is the Java platform to
burger architecture well you're you
asked the question right so do due to an
oversight you could also say you know
due to lack of time we did not manage to
get support into the debugger API you
full-on support for lambdas and static
method ever started to fall methods so
that was too bad but we are we're
actually planning to do some time around
oh I think you know februari or march we
will do for the first time in a long
time we will do a maintenance review of
the java SE platform specification and
one of the main goals of that review
will be to add a few things needed to jb
da so that the buggers and ites and
whatnot can grok lambdas and default
methods properly so yes i'm happy to say
there is a plan for this and it will be
it will show up in some appropriate java
8 update release I I think it's slated
for a you 40 which should be out in the
March or April timeframe so yep working
on it ok live question
so since you've been accumulating a long
list of features over the past couple
decades 99% of which you're rejecting
and you've identified a lot of things
that you'd like to have gotten rid of do
you see at some point you're going to
create like some new language like out
of the jpg running on the JVM platform
which would be like maybe different set
of features of you know that you know to
throw away some of the old stuff that
you don't want and maybe have a
different set of features because you
always have this trade-off between you
know when to create a new language and
when they create the complaint I
complexity to the existing language when
do you want to stop like you know at
some point the complexity of Java is
going to grow in and parole me be a
really bad example but you've got C++
and you've got Scala now that they seem
to be hitting their you know complexity
limits to where added value what new
language features is going to be
outweighed by language complexity so at
some point do you see like kind of
forking off a a new JVM language it
might be driven by that like accumulated
experience philosopher blockage I think
it's safe to say that all of us
entertain that fantasy on a regular
basis yeah that would be a lot of fun
with it we'll all will all give give our
answers my answer is yeah that'd be a
lot of fun the the critically hard part
of that would be bringing the entire
ecosystem along for the ride I think
it's probably possible but it would
require a great deal of planning and
forethought and we'd have to be
convinced that the destination is really
the right place so so in reality the you
know there would be you know if you
don't know what you what you want to
call this you know Java prime it would
have to coexist with Java as we know it
java java as as we we'll know it over
the next 10 years would have to co-exist
for a while don't have to be a clear
migration path there would have to be
tools it would be a boatload of work I
the scallop migration thing is well it's
a good first start I think but yeah I
you know any any language any platform
as you said you will eventually reach
its complexity limits i I don't know
exactly when we'll get there with Java I
I don't think it's the next five years
it's almost certainly within the next 15
or 20 I you know I one of the reasons
why we're so conservative about what we
add is because we know that at some
point you're going to hit that
complexity ceiling and we would like to
not accelerate that point any more than
necessary and so we'd like to believe
this may be one of those fantasies that
you tell yourself so you can go to work
in the morning that you know we are
being very careful and disciplined about
the features we add in the hopes of not
accelerating the complexity curve it
does seem possible that certain
particularly unpleasant features might
be able to be deprecated over time we
haven't really you know we haven't
really attacked that at the language
level although at the library level
where you know we've shown some the
willingness to do that but you know the
reality is it's easy to say that oh you
know job will be great if you took out a
B and C but if you pulled some of the
nine million Java developers I think
you'd find the sets of a B and C that
each each each one of them suggests as
the best candidates for removal are
probably almost completely disjoint
right I mean it's pretty easy to find
you know people who will commiserate
with you on whether you know you think
checked exceptions were a bad idea but
you know for every feature like you know
like serialization there are people who
can't do their job without circle is a
shin and could not imagine a world in
which she is civilization have been
taken away and and so you know the
actual reality of figuring out what is
you know the new sweet spot of features
is surprisingly hard
the challenge of Java the thing that we
come to work to do is to improve the
system while maintaining maximum
compatibility with all of you guys
thoughts about how Java is in other
words you everybody in this room has
spent a lot of effort learning java and
learning the job environment and that's
what makes an ecosystem people willing
to spend time to learn and learn it and
so that the are the default for for us
is to continue to add features but add
them in as non invasive away as possible
so like with with value types that's a
fairly profound change in terms of the
code generated but the the language
changes we're looking at to do value
types are quite small by design and
replacing a replacing Java with another
language is is the kind of seismic event
that happens once every two decades so
it's kind of hard to model how that
would look like so so Eric your put your
point is it wouldn't it wouldn't be a
full replacement it would be a
coexistence in that case there are you
know probably about 300 languages that
coexist on the JVM right now so that
that gets to the multi-language vm play
which were invested in and i hope to see
you know I I like some of the other
languages on the vm besides Java but
java's it's going to be a while I think
before we see any of those start to act
like they're replacing Java although if
you look on open source metrics you see
that javascript is a pretty important
language so you know it may be that that
the JVM will run a lot of JavaScript
loads in the not-too-distant future I
don't know OSAA escrip tis about as old
as java and and has as many warts yeah
more it's about as full of features that
you'd like to have removed
if not worse ya know just add that I
think is no with the jvm perspective on
this i guess so i think we've reached
the the complexity level we have on the
JVM i'm glad to say that we are now
actively trying to remove things
deprecated things to remove them and
make room for new features light value
types for example and the both good well
the good part for us is that hard as it
is still because people expect the JVM
to behave in certain ways it's at least
obviously easier because it's it's more
wrong time than it is your your you know
hard-coded program that you wrote in 95
and still expect to work so it's an
easier job for us than modifying cutting
out parts of the language itself but
it's still hard to evolve things in a
you know slow enough so that it doesn't
revolutionize everyday but still make
room for things over time okay John
mentioned compatibility like to use that
opportunity to answer another Twitter
question after the second time for this
particular questioner are or will
deprecated api's ever be removed to trim
the JDK that is n releases past when
it's deprecated time for a breaking
change deprecation as well has a long
and sorry history it's another thing
that's John's fault originally but it's
but it's it's abuse was very much not
John's fault so did John spearheaded the
introduction of deprecation in Java 11
which was released in early 1990s 7 for
those of you alive at the time and and
the intent very much was to have a way
to mark an API as hey this is something
you shouldn't use because we intend to
take it away at some future time it's
all Bluff
well that wasn't the intent that wasn't
the 11th let me finish and then you can
say something that wasn't the intent so
the you know the early days of Java in
the Java team like you know like the
early days of many large software
products was rather chaotic there was a
lot going on there was there was there
was not much not much in the way of team
of team discipline the in the graphic
side of the house the AWT teen rewrote
the entire AWT event model in one dot
one because the the event model in 10
was irretrievably broken they also
adopted a bunch of new a new naming
pattern that fit in with the javabeans
conventions since Java did not have
properties at that time still doesn't
have properties now sorry you know
javabeans works by recognizing certain
patterns you know get foods have food
and so forth in in their in their
rigorous approach to this they replaced
a bunch of existing methods such as the
show method in java.awt component they
deprecated that and suggested that
instead you invoke setvisible and pass
it the true value and hide similarly was
the inset visible false numbers for
compatibility they couldn't they they
couldn't remove the hide and show
methods so setvisible actually looks at
its argument in invokes one of the
others that way something they old
subclasses continue to work so lots of
methods in a WT and were deprecated and
one dumb one this caused immense pain in
the developer community we heard about
this for years and years and years do
you know it don't do that there we have
there was there was actually no reason
to deprecate those things there was
never any intent to remove them so it's
become a fairly standard question at
conferences for us in the job team may
be asked what are you going to remove
all those deprecated methods and the
answer is that well except for the ones
that are out that are really radioactive
we're not going to remove them because
that would break code for no good
a part of the problem is deprecation was
you was used in two ways one for really
dangerous stuff that eventually we did
take away a thread not stop is the
classic example and others prefer stuff
that is just not preferred so for four
years now and I've been talking with
with Brian some others on the team about
this recently for years now I've been
thinking we need another tag we need
deprecation lights my national name for
this is denigrated you can denigrate an
API give some advice well you know it'd
be better if you use this other thing
over here but you can keep using this
and we don't intend to remove it because
you know all those methods in ada awt if
we remove them lots of things would
break so we're never going to remove
them you know the occasional radioactive
thing that sneaks into the platform
after some time we recognize that we
will remove it going going going forward
going going forward we actually do
intend to remove more stuff and this is
one is yet another thing that the jigsaw
will enable one of my colleagues likes
to say that nobody's asking for jigsaw
as such and he's exactly right but
people have been asking for all all
these problems to be solved and jigsaw
it turns out solved solves a bunch of
them another is the ability to shed
things from the platform over time you
know korba it was it was the hot stuff
in in 1996 not so hot anymore do we
really need it maybe not let's let's
deprecated that module in one release
and just remove it in the next that
would be you know engineering energy
that could be applied maintaining that
could be applied to do I think much
better uses so that that's my little
story and deprecation you would add
anything that so I did just just just to
add to that I think was really
unfortunate that the that the tooling
support never really emerged for
supporting the the sort of soft use of
deprecation that mark described i think
the intent was uh there would be tooling
to help you migrate your source code
gradually from the old stuff to the new
stuff and then you know the eventually
there wouldn't be any code that that
used the old methods and it would be
easier to
to get rid of them that never actually
happened there there were a couple of
ideas that are early on that tried to
offer migration support for that but it
never really caught on and that's kind
of unfortunate because it would be nice
to be able to evolve a library and
provide tooling support for the users to
migrate from whenever the old way is to
whatever the new way is to accelerate
the transition drawn any last words
regrets well when it was a javadoc tag
there was at least the intention that we
followed by a paragraph saying what to
do instead it's it still is a drug
addict ugh and we have those we have
those paragraphs as a design rule for
building the Javadoc when we turned it
to am an annotation then we sort of lost
some of the wealthy the intent was to
use both the annotation and the tag use
the tag for the documentation and the
annotation for the actual thing that in
itself it was a controversial design
decision at the time but it is it is
what it is what we need is a deprecation
that has some teeth to it so I well my
hope is to turn deprecation into real
teeth give it real teeth and replace
many of the currently deprecated uses of
deprecation with you know denigration or
any or whatever we want to call I think
it should be college yet coos or should
be called denigrated or impeached or
impede you yeah we could bike shed over
the name you know for hours but yeah
it's it's deprecation light you know
recommended that you don't use this but
it's not dangerous if you do alright
another live question anybody from the
back of the room would like to walk up
and be brave this cable is only so long
and I don't know break it alright so
with the latest release of Java 8 you
guys implement the default interfaces
sorry default methods for interfaces
which kind of takes you closer to
getting multiple inheritance so the
question is that are you planning to do
anything more in that space to go like
make the leap and actually have true
Alton arrogance on a platform
you gave me too easy and opening so Java
has had multiple inheritance from day
one it's had multiple inheritance of
types what default methods adds is
multiple inheritance of behavior the
reason so many people have
post-traumatic stress syndrome
surrounding multiple inheritance has to
do with multiple inheritance of state
and so having had the you know the the
good luck to watch somebody else make
that mistake ahead of us we're able to
say well we're not going to do that so
many of the things that are unpleasant
about multiple inheritance of state like
diamonds don't show up in multiple
inheritance behavior so for example with
default methods diamonds are not a
problem now languages that have been
built since Java have moved in the
direction of traits for multiple herons
and we did spend some significant effort
trying to figure out whether interfaces
could be migrated to be something like
traits and the problem you know what we
ran into was how do you resolve
conflicts the way most languages resolve
conflicts with traits is through
linearization and we could have done
that in Java but it would have been a
very Unzaga thing to do and so we
decided that the the benefit of the
incremental expressiveness was not worth
pulling the rug out from under people's
20 years of mental modeling of how Java
works and we decided to stop where we
did now that said you can use default
default methods pretty much like traits
in a lot of ways and as long as you're
mindful of what the limitations are you
can get quite far with it so I think
given the you know giving the existing
language model I think we found a pretty
good compromise but of course you know
if we were starting from scratch we
probably would have done something
different and that's fine it's telling
that job that Scala 1 dot 12 has a plan
of record to use default methods to
implement some of their trade behaviors
which means that the the vm is
multilingual enough and again as I said
before having it the vm not be hardwired
to some very
language model means that it's more
applicable to multiple languages I hope
so I hope it gets more polyglot all the
time yeah okay just a few minutes left
so if you don't know they're doing part
1 and part 2 part 2 is half an hour
after this session and so we'll take a
little break and then we'll be back so
if you still have questions you can come
back or stay here whatever here's a
question on Twitter which I'll ask and
then try to answer with like a friend
access modifier in the Java language
we're thinking about something like that
in in jigsaw so friends at the low level
I mean they're probably other people
walking around with post-traumatic
stress syndrome from from C++ friends
but thats just extremely extremely low
level but in in the jigsaw module model
that we've developed which has been
informed in very large part by then by
the problems we've encountered in
modularizing the JDK itself we do have a
concept that's a little bit like friends
but it's at the module level so in the
JDK there are of course many internal
api's of any internal api's the
developers use and they shouldn't but
leaving that aside there there many many
internal ap is that we would like to
export from one JDK implementation
module to another we don't to make it
available everywhere so in jigsaw
there's there's a concept of module on
what module has some number of packages
in it a package can be exported to any
other module or it can be exported only
to a specific list of named modules and
that that export control and the access
checks implied by that export control
are done deep inside the virtual machine
by essentially the same mechanism that
keeps private methods private so it
really is it really is a tight
connection so it's not full on friends
where where you can say oh this class is
a friend of that class and therefore can
share its internal state or something
but it's it's friends at a higher level
but at least it lets you get some of the
same effect when you've got modules that
need to share some internals without
exposing to
22 all bottles in the world what those
internals are so that's that's as much
of friends as I suspect Java could ever
tolerate any anything more would would
risk certain death okay I'm looking for
another quick question why can't we
create an array of generic type so the
reason we can't create an array of
generic type is that we can't it would
violate a promise that the generic types
is to make so generex are implemented by
erasure and the compiler inserts casts
in various places and we actually make
quite a strong promise about this which
is to say if your program compiles with
no uncheck warnings and no raw warnings
then none of those casts that are
inserted by the compiler will ever fail
so because a razor and they are
covariant and generics are invariant
creating a generic array would allow you
to subvert that promise without
triggering one of these warnings and so
it would it would undermine a critical
safety guarantee that that's made by by
the language okay I just got a tweet
from dr. deprecated or himself dr.
Deborah Gators in the house somewhere hi
Stuart stand up get you have your
uniform on yes Stuart is dr. Deborah
cater and and he has a talk an entire
session just on deprecation tomorrow at
3pm conference session six 377 be there
or be deprecated
alright it's five o'clock we're going to
take a short break and we will resume
again at five thirty thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>