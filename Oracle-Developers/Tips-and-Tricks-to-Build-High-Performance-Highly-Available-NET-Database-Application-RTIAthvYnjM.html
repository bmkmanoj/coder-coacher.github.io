<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tips and Tricks to Build High Performance, Highly Available .NET Database Application | Coder Coacher - Coaching Coders</title><meta content="Tips and Tricks to Build High Performance, Highly Available .NET Database Application - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tips and Tricks to Build High Performance, Highly Available .NET Database Application</b></h2><h5 class="post__date">2017-08-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RTIAthvYnjM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay hello everyone thank you very much
for coming to my session today we're
going to go through a very in-depth
technical session on how to get good
performance from your.net applications
particularly when they use databases so
there's a lot of details here and I
don't really expect you to digest it all
during this session but the video will
be on YouTube and hello out there on
YouTube and on top of that we'll also
have the slide deck available for you
however the demos that I do obviously
will not be you'll have to watch the
video if you want to see those again now
if the slide decks don't show up when
they're supposed to we do have a you can
email me and ask me for them that's no
problem
we also have an OTN dotnet site that you
can see on the link on your screen up
there and that will also be a source for
getting these slides so with that let's
let me just promote my next session
because they gave me two sessions this
time twice the twice the pain I guess
but no at four o'clock I'm going to be
doing a beginner session so probably if
you're in here you're probably already
using dotnet on a daily basis but if not
I am going to be doing a beginner
session at four o'clock where I kind of
start from the very beginning and watch
it through all of it now even if you
have done quite a bit of net development
before I am going to have a heavy focus
a heavier focus on the cloud in the
second session so if you're curious
about that you could come to that
session as well so that's at 4:05 next
door all right so what are we going to
talk about today well first of all we
work with developers all the time and
even the really good ones there's some
trouble spots there's some some blind
spots that people hit and they're
actually not that big a deal but if you
know about them it'll save you a lot of
pain later in terms of getting good
performance with your application so
I'll talk about the areas where we see
where you should focus to get good
performance and furthermore there's some
things you can do that are very easy
that will give you good performance so
we'll talk about that as well
and
the second part of the session will move
along to high availability with dotnet
apps and what does that mean first of
all what's the definition of that and
also what can you do to make your
database app highly available so with
that let's move right into it I'm going
to be continually going back and forth
between these slides and the codes so
you don't I don't bore you to death with
monotonous speaking so there's any
plenty of chances for my demos to blow
up and what keep things exciting and I
know how it is I've been out there
before so so don't worry I'm going to be
going back and forth back and forth back
and forth so the first thing that we'll
talk about is probably the most
important thing to pay attention to when
you write a dotnet application using a
database and that is your use of
database connections because that by far
is the most expensive thing you can
probably do in your application
establishing a connection from scratch
can take on the order of seconds and
that pales in comparison to just about
anything else you do in your app so you
have to pay attention to connections and
furthermore a lot of applications these
days connect/disconnect connect
disconnect all day long and so that that
points us to probably the number one
best practice of them all which is to
make sure that you're using a connection
pool in most cases and not just using a
connection pool what is a connection
pool let's start with that well what in
case you don't know what a connection
pool is is it's a set of pre established
connections where the hard work has been
done the connection has been made and
they're sitting in a group and you just
borrow one when you need it and you use
it and then you give it back and then
you don't entail the cost of
establishing connection with all the
deck costs now when you think about that
you have to say to yourself well how big
should that be do I need 10,000 of them
then my database administrator will come
yelling at me you know do I need five of
them but then when people log in in the
morning to check their sports scores
that the site goes down because that's
not enough so how do you figure out how
do you figure out how many connections
you need in the pool
and the answer to that is to make sure
to do monitoring so a lot of connection
pools that are out there
offer you the opportunity to inspect and
see what's going on and you should
monitor your connection pool under a
live load to make sure that you're to
make sure that your connection pool will
stand up to the heat of a real work load
so since my experiences with Oracle when
I do give examples a lot of times I'm
going to be heavily waiting on the
Oracle site but a lot of these things
exist in other databases that are out
there so for example Oracle has a data
provider it's called Oracle data
provider for net OTP net for short and
so our connection pool you get one when
you create a a do debt net connection
object an Oracle connection you
automatically get a pool by default
because we know everyone's going to be
using them so we just give them one by
default you can turn it off of course
but we do give you one so we have we
have connection string options like you
see their minimum pool size maximum pool
size and lots and lots of others
furthermore we also have the ability to
inspect the performance we have
performance counters that are integrated
with performance monitor the let you see
how many connectors are in your pool and
and and and how many of them are being
used etc so let's take this it's just
chance to jump over into the live code
and see if we can make my demo blow up
all right so I have C alrighty so I have
a gotten an application here let me just
get a little more screen size okay so
the first thing that I'd like to point
out here is that in order for this to be
a database application I need to be
using a data provider so I'm going to be
using the Oracle data provider for net
in this case it's Oracle managed data
access and you can get data providers
from nougat so if you're not familiar
with nougat which I'm sure you are you
can just use the integration with Visual
Studio and you can you can download them
directly from the NuGet it's a
third-party resource that has all these
different
software including Oracle so in this
case I'll just search on Oracle and lo
and behold you can see that there is our
data provider so it's very easy to get
started and grab our data provider
furthermore I'm adding it to the using
clauses up here so these are the classes
I'm going to be using all right now it
just turns out that I am going to be
using a database that's in the cloud so
in order to do that I need to find out
what my IP address and instance name is
for my database so let me exit out of
this VM here and just go to my my cloud
instance here so let's open up the let
me go to the database side ok dashboard
this is where the network becomes
critical they put me wire on wired here
so I'm not totally subject to the whims
of the Wi-Fi but we'll see how it goes
here all right
well so far so good and it's pretty easy
to spin up an Oracle cloud Oracle
database cloud service I did it in about
five minutes
but if you take a look here whoops go
back here
all right I seem to have jumped around
let me go back database cloud service
alright here it is there it is okay so
if you look down here it's a little hard
to see because I don't have the zoom
feature outside of the VM but that is my
public IP address IP address and there
is my database name pdborcl so I'm going
to be connecting to that from my so just
remember the numbers 83-61 I'm going to
be connecting that now from my
application now if you look at the
connect string that I'm using you'll see
that that doesn't look anything like
that that's localhost 999 what's going
on here well the answer is in order to
connect to well there's a couple ways
you can connect to a database cloud
service but one of the most common ways
is to use an SSH tunnel which is what
I'm going to do here so I open up putty
which is the windows way of doing SSH
and I've got a pre-loaded set up here so
you I think I said to remember 83-61 so
there's that that's where I'm trying to
go now let's look at the SSH tunnel and
you can see that I'm forwarding port 999
on my local host to the IP address of my
database and 1521 which I didn't show
you but is the standard port for achill
it is listed on that page I just want to
make sure you know what's going on here
alright enough of that now let's take a
look at this application so you said
that by default you get a connection
pool and I happen to actually be
customizing that pool quite a bit here
so as part of my connection string
pooling is true that's actually default
I don't have to do it but I'm doing it
for description purposes and also a
minimum pool size and maximum pool size
I'm setting all right so now if I go
ahead and run this app I actually have
to run it to be able to to show you
performance monitor because performance
monitor it needs the app to be running
of course it's getting an error because
I didn't open up putty let's go back in
here
okay let's try that one more time I may
have to add the IP address for this
connection let's try it again
see if it'll work now it's working all
right let's try it again okay so I guess
I didn't have putty running properly now
we have a sesss HD tunnel now I'm able
to connect and I'm in the middle of the
application I've created a connection
and I've opened it so let's take a look
at performance monitor okay so right now
the default performance monitor metric
is processor time I'm going to delete
that and I'm going to show you what what
Oracle offers for our data provider so
I'll say add and scroll down to the OD
p.net manage driver there it is so these
are a list of some of the things that
you can add to performance monitor to
get an idea how your pool is performing
you can see how many real hard
connections it's doing to the database
you can look at how many active
connections I'm near being used how many
are free and this will give you an idea
at a given point in time how your pool
is performing and you can do similar
things with other database pool vendors
but DeYoung the key here is that is that
that's extremely important that's an
extremely important best practice all
right
okay so I'll just show these slides so
that you know what I did I kind of
included a link on these slides in case
you're curious of how to set up the
desta state tunnel we actually sat down
and wrote out step by step walkthrough
on how to do it so I put a bitly link on
there when you get the slides you can
click on it but this just shows you how
to set up the CSS hl2 our database and
just in case you want to do that so
moving along to other connection pool
related connection related best
practices if your data provider offers
it it's useful if you have connection
pool tagging so what is connection pool
tagging well think about the kind of
things you might need to do with the
connection when you pull it out so one
thing you might have to do and a common
thing you might have to do is to change
the language character set you know you
may be Japanese users may be Spanish
users may be a US America users English
users and you don't want to have
separate pools for all those because you
know that that adds up to a lot of
connections it doesn't let you manage it
properly so something like caching pool
tagging what lets you do is you let you
tag a connection after you set the
session on it you set the session the
Japanese you can say this is Japanese
connection set the session to German
this is German connection set session
English is the English connection and
then you can go to the pool ins I just
want whatever Japanese connection you
have in half and then that will save you
the trouble of having to get it reset
the session which is another round-trip
and it will save you a lot of time and
performance and then if your pool offers
connection pooling connection load
balancing that's a really great thing or
ODP dinette offers the ability to take
metrics coming from your cluster so you
have a bunch of different instances for
the database that the database will send
information to each client saying you
know these are the nodes that are the
least heavily heavily used so you might
want to use them and so what we'll do in
what ODP dotnet we'll do in the oracle
connection pool is if we hear from the
cluster that this particular node is
likely used we'll
more of them in the pool kind of
load-balanced for you so all you have to
do to turn that on in the case of Oracle
is to set load-balancing equals true in
the connection string this is just an
OTP net dirty yeah well no the this
particular example is strictly for ODB
net I but but they're similar for this
is more of an enterprise type feature if
your database has clustering if you have
a lot of different clusters a lot of
nodes then something like this would
take effect but I'm just giving you this
example because it is something that
would make a big difference if you have
right right yeah yeah no not fine Oracle
actually actually has the same thing
with the database with all of the with
global data services where metrics from
Golden Gate Data Guard and all that also
come across to all the clients and tell
them things as well and I'm actually
going to talk about that in the last
part of the session and I'll hold all
questions to the end after this because
I'm really short a time not only give us
45 minutes again believe it no no it's
not your fault all right
so the last thing I think I'll mention
about connections or maybe the second to
last thing is if you happen to have the
ability to put the connected pool on the
database side that might be worth
looking into
because especially if you're in a
situation where you've got a lot of
Millett ears and maybe they're lightly
used do you really want to be sucking up
you know 20 50 connections for each one
of those middle tiers to have a
connection pool if you share the
connection pool on the database side
we've seen incredible scalability with
some of our bigger customers so the
Oracle has something called Oracle
database resident connection pool which
is which meets that requirement and then
another really basic best practice
another really basic best practice that
anyone can take advantage of is to watch
out for lingering connections so now
this can mean just a an accident a bug
in your application
where you put a connection object or a
child of attention object at a scope you
shouldn't have and it stays open too
long so you have to pay close attention
to open connections and they make sure
they we really want them to be beholding
a reference to them but that's actually
not the biggest problem that we see I
mean most people eventually find
problems like that one of the worst
problems that we've seen over time you
need extremely heavily used applications
is that the garbage collector does not
keep up with dispose with with getting
rid of connection objects or child
children of connection objects and part
of the reason for that is is the garbage
collector is set up to treat an object
each object with kind of equal respect
but the problem is the database has a
lot of resources that are sort of hidden
from the garbage collector all the way
to on the database side as well so the
cost of not garbage collecting a that
not garbage collecting right away is can
really add up picking end up with things
like out of memory errors or running out
of cursors on the database side things
like that so you have to be really
careful of that one thing we recommend
and it's kind of annoying but it's a
good practice to get into is - it's to
explicitly dispose all of your objects
or to use the using clause on all
objects that you're using so that when
it comes out of the scope of the using
clause it is immediately disposed so I
in this example I was showing you
earlier at the end I have I just want to
show you this annoying little text this
people get annoyed with me when I tell
them like do I really have to do that
like well you know so here we are doing
disposed to supposed to dispose you
don't have to do it this way you can
just set up a using clause whenever you
use an object you can say using and then
give it a scope and then when you fall
out of the scope it'll get disposed
if anything goes wrong with the screen
be sure to let me know because I can't
see it okay
another really important a really
important thing to be aware of is the
importance of buying variables so does
everyone here know we're buying variable
is and probably but sometimes people
don't and it's actually a very simple
thing that can lead to very high
penalties so let me just waste your time
briefly to give this a plug because it's
so important so what happens on a
database is if you present it with a
sequel statement select star from
employees where employee number equals
10 it has to parse that statement and
then it has to plan how to get the data
for that statement now what happens is
if you kind of take the naive approach
and you just create a string that
literally has that 10 attached to the
end of the where clause you just say you
just concatenate equals 10 on the end
that's fine this data bit Davis will
parse that just fine it'll do the work
to get the plan but then when you come
back and you say all right now give me
that with Department number equals 20
it doesn't realize that that's the same
statement or it may not realize that
that's the same statement and so I'd
have to go through that parse again it
has to go through that plan again so
when you're dealing with a relational
database it's really important when
you're going to be doing something like
that to use buying variables so bind
variables you put like a colon depending
on the database colon and the name of
the buying variable or a number and then
you set up that parameter object in a
deonette and you feed the value to the
parameter object and then whenever you
want to change that value at the end of
the sequel statement you just set the
parameter object to a different value
and now when it gets to the database the
database says all I've seen that before
and it doesn't do the work a second time
so make sure that you use bind variables
so let's take a look at example code
that I had up there's actually doing
that so if you take a look I'm
establishing an open connection okay and
it's a select country name from country
we're country ID equals : country ID and
this is pretty much straight a do that
net you can use this with any database
provider but any case what you can see
happening down below and like my help
there is tooltip is blocking me but you
can see that I'm saying okay at the end
of my where Clause I want the value UK
from my country ID instead of
concatenate UK to the end of my query
I'm going to set up a parameter and then
I'm going to set the value of the
parameter to UK and then execute and
that is how you use a by a variable okay
so along the lines of bind variables
since you know now that the database has
to do this work the database caches that
work it I'm going to hold questions to
the end it caches that work and so then
another key point of performance is how
many of those statements and which
statements get cached
so if you have the ability to control
that you should definitely look into it
so like for example if you're doing the
same five sequel statements over and
over and over again you want to make
sure the database doesn't just age those
out just because you haven't done them
in a while
you want to try to pin those on the
database side if at all possible now
this varies depending on the database
vendor in the case of Oracle we just pay
attention for you we kind of monitor
what you're doing and we just tell the
database oh we need 15 of these cached
you can turn that off of course but we
typically by default we will look at it
so you need these 15 cached because
you're using them all the time and we
tell the database and you don't have to
think about it but for other databases
you have to actually set the value or go
to the database and set the value all
right so now let's move on to data
retrieval so obviously we've talked
about connection that's the big one
buying variable is a very big one now
the next area of focus is how are you
doing data retrieval because obviously
too much data can be a problem too
little data can be a problem so what you
do really depends on your use of the
data to optimize you have to kind of
know your use case
so using ODP net is an example but
there's corollary to this with other
database vendors we have something
called fetch size which you set to a
number of rows actually you set it to
bytes but we let you take we give you
the byte count for a row and you
multiply it by that so you say I want a
hundred rows at a time I want a thousand
rows of your time or my networks really
slow and I don't need much data let's
just get five or whatever you have
control of that you set it so let's take
a look at how that works
all right so um let me go down to where
the fetch size is set okay so I have a
demo here where I'm setting the fetch
size twice and then kind of fact doing a
measurement of of the difference in time
now this is a little contrived because
in the first example I'm setting it to
just one row which is ridiculous you'd
never do that but you know I just want
the easy way out I want to get a nice
example and then later on I'm going to
set it to a hundred rows where's my
tooltips blocking me there we are
so you can see I'm saying fetch size I'm
setting up a data reader which has the
sequel statement in it and I'm setting
the rows size on it then I'm saying
execute let's go ahead and run this and
see what kind of difference it gets
as expected it's a very very big
difference it's not quite that big or
even close to that big from normal
values but it's still it's still greater
than 10 20 % of performance so you
should definitely look at fetch size as
an example as a good location to get in
tune your performance another area of
focus that you should pay attention to
are large objects okay what are large
objects lobs they're called sometimes
but that's things like image files that
you have in your database documents that
you have in your database things that
take greater than typically greater than
whatever the largest text data type or
numeric data type or sorry binary data
type that your database allows so an
Oracle that would be varchar' to which
it varies depend on the character set
but it can be you know four thousand
characters to you know thirty-two
thousand characters four characters and
then binary so most databases have a
special data type called blob for binary
large object club okay and different
databases have different amounts of
tuning available to you so again I'm
going to later I'll talk about Oracle
but I'll just list all the possible
tuning options that might be available
to you and you should try to take
advantage of these depending on your use
of the object so first thing you have to
do is think how am I going to be using
how am I going to be using this data
once you've figured that out then you
can you have different options you can
retrieve whenever you retrieve a row you
can just retrieve a pointer to the lob
you can not retrieve any lob at all and
then later if your application you need
to show the image or show the document
then you can go get it is that what you
want to do maybe I don't know the other
thing you can do is you could just
inspect the header of the document look
at the talk text document or header of
the binary file you could download the
entire lob with every single row that
comes in if that makes sense and
furthermore you could you could
manipulate lobs using sequel or PLC oh
sorry using sequel or stored procedure
logic if that makes sense and
some cases it really does for example if
you're moving a lot from one table to
another you really don't want to bring
all that data down to the client and
push it all the way back up if it's
going to stay at the same so you can use
in a lot of databases you can just do a
sequel operation that just copy to the
pointer of that lob from one column to
the other and some databases allow
random access so searching through the
lob so you have to figure out how you're
planning to use it now in the case of
Oracle our command object has initial
lob fetch size so if you set that to 0
we just give you a pointer to the data
we don't bring any data down with each
row if you set that to and then if you
do that then we have Oracle Club and
Oracle blob classes that handle
returning pieces of that as you want
chunks of it finally if you return
negative if you put this value at
negative 1 where we turn all the data at
once in the case of Oracle and other
database vendors we support updated
insert the leads of blob columns to copy
them to other tables and it just copies
a pointer ok more about data data
updates so if you're using data adapter
there's something called update batch
size so if you're making changes to a
data set which is an in-memory
representation of a table what typically
happens you make a bunch of changes and
then you want to you have the option of
either flushing them once at one at a
time or flush all the data once up to
the database so probably better to do it
in a batch if possible in the case of
Oracle if you're familiar with PL sequel
we create an anonymous PL sequel block
and we put all the updates in that and
we send that in one trip okay so
retrieving data from the database so if
you're using a stored procedure and
bringing back a lot of data a lot of
times an array will do a really good job
of bringing that data down however for
different database types different array
types have better performance than
others I know in the case of Oracle for
example there's only one array type that
works well and that's called an
associative array you formally known as
an index byte table if you're an
old-timer
with Oracle but we also have other other
other types of arrays B arrays nested
tables they do not perform at the level
that you would want for a lot of data so
the first thing is use arrays but use
performant arrays so find out from your
your database vendor which array type is
the right one to use also array binding
so update table insert value know this
value you could do that a hundred times
or if your database supports array
binding you could just bind an array and
it'll do the equivalent of 100 updates
but in one round-trip by by passing in
the bind variable which is a set of
values that go into a where Clause so if
you have the ability to do parameter
array binding and by all means do so so
let's take a look at an oracle case the
here let me part of this demo so I have
a stored procedure here called second
called my it's a package actually called
my package C packages let me show you
what it's what it looks like alright and
this is simply by taking in one array
and outputting another array and then
it's kind of scrambling the contents of
the input array and this is using an
associative array so I'll show for those
of you who are curious I'll show you the
definition of that associative array
which is hopefully it will come up here
should be right here there okay so you
can see that it's a defining Oracle as a
what we used to call an index index by
table so table of our chart 20 so now
that you know what we're inserting into
let's look at the dotnet code for that
so scroll down here okay so I'm setting
up the call to my pack my stored
procedure and I've got an input array
and an output array both our types Peele
sequel associative array I scroll down
the blue ones input ones output the
input value is sending in Oracle code
2017 output value is null and then the
array has three elements and they're
varchar 20 so the maximum size is 20 so
20 20 20 for each of the bite sizes
there's a little bit hairy but the point
is that this is the best way to get data
out of Oracle at least when you're using
a stored procedure so you need to know
how to do this all right
so okay let me go ahead and run to the
end and you can see that it it
rearranged the the text that we had to
2017 Oracle code exciting all right
and if you can use store procedures you
can offload some of the work to the
database so that's that possibility the
database vendors I know sequel server
does Oracle does allows you to basically
execute the sequel statement in the
stored procedure and then return a
cursor back down to the client side and
a cursor is just a pointer to the result
set and so that could take some of the
workload off and allow you to decide
when you want to fetch that data back
down by fetching from those cursors so
in the case of Oracle we have a ref
cursor clef that you bind to a stored
procedure output variable case a sequel
server it kind of just materializes in
on the client side you don't really have
to bind to it but the bottom line here
is it gives you flexibility and allows
you to allows you to control when you're
bringing the data down so I do have an
example here shows you how this is set
up okay so what I'm doing is I'm
actually not using a store procedure
where I'm using a peel sequel block but
it's the same concept so inside the
anonymous PL sequel block I'm opening up
three cursors and then we're going to
execute that that block and we're going
to bind three parameters to it and each
type is defined as oracle DB type ref
cursor and then the really interesting
part is once you execute that this
becomes part of a data reader but the
data reader actually has all three
cursors inside of it so what you do is
you read from the first one when you're
done with that you say next result you
read from the next one next result read
from the next one and you get all three
of those cursors that way
and I get some output and now moving on
to some of the really low-hanging fruit
that you should probably take advantage
of if you can caching so caching is very
important it basically if you can take
advantage of it it can make a tremendous
amount of difference in performance now
there are some considerations and you
need to do before you think about
caching and again caching is storing
results on the client side instead of
having to go to the database to get them
all the time you store the results on
the client side so what kind of
situations is that good for well one
case is mostly read-only tables very few
rows are being updated and don't use it
for situations where the data is
changing a lot and the reason why is
there's a lot of the maintenance that
has to go on to keep the cache
up-to-date so once you start updating
the data too much then the data it kind
of eliminates the benefit so what you
want is you ideally you want to cache
that is maintained by the database in
other words the databases is controlling
the cache in some way and the reason for
that is the database already knows when
the data is changing and it can easily
notify the cache and say that data has
changed that data has changed if your
cache has to ping the database a lot
well that kind of removes the benefit of
having the cache so on the dotnet saw on
the Oracle side the probably the easiest
low-hanging fruit for you to take
advantage of is something called client
result cache so this is a free cache
that you get automatically just by
turning it on and we just piggyback off
of network traffic so anytime I ping
those to the database or an update or
select we basically ask the database as
anything changed and then we update the
cache and we guarantee that the we
guarantee that the cache is consistent
and it's only available visible to the
people who are allowed to see it
and then there's client continuous query
notification which I'll talk about in a
second and times ten in-memory database
so client result cache
all that you really need to do is to add
a sequel hint to the query and turn have
your DBA or turn it on on their database
side now they can turn it on so that
every single query ever executed gets
cache but that's not how people usually
use it so typically you will have to use
a hint unless they turn it on for
everything so the sequel text in your
statement must be the same the buying
variables must be the same in the sequel
session settings must be the same to use
the same cache different sessions with
with those same user settings can share
that but different users will never
share the same data
another type of caching that you can
take advantage from Oracle is called
continuous query notification so
basically the bottom line here is you
build the cache you control the cache
and this is the way for you to get
notifications you can register a query
with the database and you can get
callbacks to.net that say that query has
data that has changed and then you write
the cache so if you look here you create
an oracle dependency which is a callback
and the oracle command has the sequel
statement in it you send that over to
oracle and then oracle starts monitoring
the sequel statement and what it'll do
is if the data would change it sends you
a notification and it doesn't even use a
database connection it actually uses
something that all oracle clients
already have which is a messaging system
we just send a message back to the
client you can disconnect from the
database itself we'll send a message
back saying that data has changed and
it's this row ID that's changed and then
you can just go and select that one row
and update your cache so you can write
the cache yourself that's the idea here
and the last type of cache is a
enterprise level cache that you may have
available to you probably don't but it
depends it's called times 10 it's a very
very fast database that's in-memory that
sits in front of Oracle the main key
here is that we do have an Oracle data
provider for dotnet that knows how to
connect to it so you can use the same
code to connect to times 10 instead of 2
Oracle and n times 10 sits in front of
the date
but this is more of a buying decision
than whoever bought the database will
decide it's not really at the
development level okay now I'm going to
move along to application high
availability so what is high available
what is high availability mean so the
kinds of things that can go wrong in an
application application include many
things including for example the network
can go down it can burp it can have
problems you can end up with connection
requests hanging you can have the
situation where services stop and then
start again
and your connection hangs or you can't
connect
I mean basically what ends up happening
is you get yourself in a situation where
you're getting flooded with errors
connections are bad the user experience
is terrible so high availability
addresses these kind of things basically
what happens is an application that is
highly available handles database and
network failures transparently you can
as a developer there's things you can do
we do a lot for you on the database side
but there's things that you can do to
your code to handle failures graces
gracefully so the key feature that
Oracle offers around this is called fast
application notification so this is the
database telling all the clients what's
going on and so you don't if you're
trying to connect over tcp/ip and you're
hanging you don't have to wait to hear
back to know what's going on the
database database turns around in
contacts you through another channel and
says hey we got problems over here and
node B don't come near it that kind of
thing so there's a lot of different
things that fan can tell you a lot of it
is taken care of automatically you don't
have to do anything
one is a node down plan down note up the
the the workload on a node all right so
one of the biggest uses of this in a
normal situation where there's not a
disaster going on is called plan
so what happens here is the database
administrator or the IT person wants to
bring down a machine or the database and
what they can do is they can use Oracle
to send out a message saying ok we're
going to be planning an outage we're
going to have an outage at this time and
so what happens is a fan sends messages
to all of the clients that are
subscribed and says ok we're going to be
coming down in this amount of time and
so in the case of OTP net if you set hae
events equals true in your connect
string the connection pool will listen
for that and what will happen is we'll
just slowly start decreasing the use of
those connections so you know if we you
know if we know that nodes going down
then every time someone returns one to
us we'll throw it away we won't we won't
reconnect data guard which is a running
back up instance of your database has
something similar so if you were
planning to switch from your primary
node to your secondary node because
something's going on with the primary
basically it will send out notifications
ok we're starting a switchover so then
ODP turn that connection pool gets that
message and so there's different things
that go on here that can help you in
this scenario so there's something
called server's free location connect
timeout which you can set and what will
happen is if you happen to know it takes
about 90 seconds to failover then what
we'll do is we won't return anything if
someone asks us for connection we'll
just block will sit there and then they
don't get an error they just wait it's
better than getting an error in most
cases and then by the time that that
wait is over
presumably the secondary database has
come up and then they just go right
along and connect and all they noticed
was 90 seconds of delay they didn't get
an error they didn't have problems so
that's with with them with the data
guard this is one of the options and
then from the networking side as you
know there's Oracle has a TNS names file
which is a list of connected connection
aliases and you can set it up so you
have multiple
and connection aliases and it can go
through each of them trying to find one
that works now in the case of a data
guard switch over that can take some
time so we give you some control we have
retry count and we have retry delay that
you can set up in your connection in
your Tina's name that Ora and so this
will say how many times do I go through
the list before I give up and how many
times how many seconds do I wait after I
go through the list before I start and
try again and so this gives you some
more control over how long your client
will keep trying so now as we talked
about data guards planned switch over
and we talked about planned outage but
now let's talk about nodes going down
unplanned outage okay so if a node goes
down and you have fast application
notifications set up we will send a
message directly to the connection pool
saying hey node B is down don't use it
anymore so the idea is we don't want a
whole bunch of bad connections sitting
in the pool just waiting for someone to
ask for it and get an error message so
what we do we do the obvious thing we we
clear them out we stop allocating them
and we empty out the connection pool
with bad connections all right so now
let's talk about what about work that's
being done so if you happen to be doing
non transactional work just reading from
cursors there's something called
transparent application failover there's
actually several different things that
Oracle provides to deal with the issue
of what to do about pending work so I'm
going to talk about three of them so the
first one is called transparent
application failover so what this does
is if you're in the middle of like
walking through a query paging through a
cursor and now all of a sudden the node
goes down it can reconnect to another
instance that happens to be running and
it can reposition you at the at the
point that you were at when you're
reading the cursor and then you don't
even have to know that anything happened
that's called transparent application
notification and transparent application
failover
another one and this is really cool it's
called application continuity now if
you're using Oracle in the cloud you
will get this because all the databases
up there are now 12 - this is some of
these features are fairly new but
application continuity takes it a step
further so this now deals with
transactions so you're met you're
changing data etc you're changing data
and you know there's some concerns here
you know what do I do
is it ok to to recover from that
situation and to the best that it can
application continuity will basically
recover for you and replay all the
things that you've done with the
database including updates the leads
everything
it's totally seamlessly to the
application it'll reconnect to another
instance replay updates replay delete
everything and you don't have to do any
coding now obviously this has limited
situations where it will works what
we're adding to it by day by day so
there's some cases where it won't work
but if you can use application
continuity you get a whole lot of stuff
for free basically it does a whole lot
of work for you but you can use other
things in context with it as well in
conjunction with it so in order to take
advantage of application continuity
obviously pooling ASP equal true but you
get that by default an application
continuity equals true needs to be in
the connect stream so this requires a
database 12-2 and ODP done at 12 - but
that's what's in the cloud all right so
the last feature that I'll talk about is
kind of gives you the most control of
all of them so if application continuity
doesn't quite do what you need to do
there's something called transaction
card transaction guard does what it
sounds like it lets you know it
basically prevents you from if you're
doing an update into the database and
then the database crashes you don't know
did my update commit should i resubmit
that well I end up with duplicate data
yeah you don't know the answer to those
so what transaction guard does is he
keeps track of all that and lets you go
back after the crash and say the deck
did that transaction commit is it safe
to trust
replay that transaction and basically in
your own code you can decide whether or
not you want to replay a transaction so
the way it works I'll just skip right to
the code here but you have in the
exception when you get the exception
that the error has gone down you will
get some information such as is
recoverable you know can I do anything
about this has the transaction Oracle
logical transaction committed did it
commit and basically you get to decide
based on that information whether you
want to replay that can replay what you
did or whether or not you know this is
not a safe situation and you can't so
this gives you the most control over
what to do when you have a live
operation on database and the database
crashes okay so that covers application
continuity again database goes down
Network goes down you don't know the
status of your of your running
transactions and what do you do so by
taking advantage of those things you can
have the most control over the
experience of your end-user
having a good experience by having as
much information as possible about
what's going on with your transactions
and being able to replay them alright so
that's it basically but let me just
promote a few things here I already
showed you how to use SSH to connect to
the database cloud service and the next
session I'm going to be doing I'm going
to be using Windows compute with Windows
2012 r2 where I'll be pushing up some
dotnet applications you know networked
willing but any case we also have a
white paper if you can't make it to that
session we have a white paper that shows
how to set up I as web server how to set
up web deploy and basically how to get
it all going with Oracle Windows compute
so if you're taking advantage of some of
the the free credits that Oracle is
offering you can try that out and then
extra data Express cloud service uses
something called wallet to do
authentication so we show you how to set
up a wallet instead of an SSH connection
for exit data cloud service
so thank you very much for coming out I
hope to see you at my next session at 4
o'clock where we'll be doing a beginner
session and if you have any other
questions please feel free to email me
check out our Twitter account and our
OTN page so please see you at 4 o'clock</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>