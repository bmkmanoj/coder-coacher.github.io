<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Best Practices for Managing Docker Versions | Coder Coacher - Coaching Coders</title><meta content="Best Practices for Managing Docker Versions - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Best Practices for Managing Docker Versions</b></h2><h5 class="post__date">2017-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MqsG9-HEcTw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right okay think we can start so let
me just state it again thank you so much
for being here at 8:30 in the morning I
have no idea how you did it but I really
appreciate it I mean I have to be here
but you could just you know sleep so
yeah thank you very much
I hope it will be a worth of your sleep
hours and 8:30 means rules if some of
you fell asleep that's fine I like how
you are lined up at the fire exit route
to you know to take off that's fine as
well but I really hope you will stay
because we're going to talk about one of
the most fascinating topics versioning
what can be more fun than that at 8:30
I'll do my best so um my name is burrow
I'm developer advocate with Jeff Rock at
J bar on Twitter I already tweeted about
you so you should follow me so you'll be
able to retweet it's wonderful to read
what about you and yeah I'm developer
advocate with Jeff frog we do great
software we do great t-shirts if any of
you didn't take your t-shirt yet our
booth is downstairs you should go there
take it is short and also hear more
about what we do because I'll try to
keep it very light on on the Jeff rock
side and more on the darker side to the
idea this morning yeah so we might still
have some t-shirts left I I hope so
so just to try and wake you up a little
bit we will start with show of hands so
the rules are very simple you vote and
you keep your hand up until it no more
applies to you okay so let's start who
heard about docker okay hands up hands
up who can do the tutorial or think they
can do the tutorial okay still most of
the hands up very good
who actually tried to do something with
docker POC okay still the majority and
who uses an in production this is where
you take your hands down ya know so what
we have like what about 10% maybe 15% of
the of the hands up and that's a picture
that I run this poll on every docker
talk that I do for the last two years
and it steadily increases but we're
still very far away from who's is in
Java in production all of you right
that's that's my point so the question
is why don't you use docker in
production and there are a lot of
different answers and one of the answers
is it's great technology that's very
hard to trust and it's very hard to
trust because it's another very opaque
level of abstraction that you're really
not sure what's going on and it kind of
will feel a little bit scary
working with docker so what we're going
to try today is in improve your trust in
docker just by a little bit by
understanding how docker versioning
works and how it should work and see
some patterns on how you should work
with it and how it can increase your
trust in in docker now why I'm here from
j-rock talking about docker um
regardless of what you think you see on
this picture it's a hug because we love
docker so
I am we managed binary files for the
last more than a decade in various
shapes and forms and various tools and
dr. image is something that we know how
to deal with and we created the first
docker registry before there was no care
registry and we generally have very deep
relationship with docker of the
technology so and I think we know
thinking too about how to manage docker
images and this is what one of the
aspects when this talk is about so there
are two hard problems in computer
science cache invalidation naming things
and off-by-one errors as you probably
know and today we are going to talk
about naming things because versions are
naming so docker does make it better
naming things with docker it's even
harder than naming things in general but
before we are talking about that
well versions who cares about versions
and why we care about versions that's a
very interesting question so let me ask
you something how many of you know which
version of Chrome you run in you're on
your computer one to two hands
guys you are geeks
okay how about which version of browser
you use in your phone no one right yeah
so versions are kind of going away we
have this notion of continuous update
that we get new versions every time and
we really you remember a couple of years
ago you for sure knew which doesn't
browser did you are right but not
anymore
but still this is I asked you as
consumer side I spoke about browsers
because you are consumers a browser now
how many of you know which versions you
run through your pipelines and in
production when you actually produce the
code everybody right so we have been as
authors of code care about versions
although our consumers might already not
and we care about versions because we
want to answer three basic questions
what we have in hand I look at an
artifact and I need to know what it is
right what I should promote or demote or
or do something with and what runs where
I have tons of environments
production staging I need to know by
looking at some metadata by looking at
some Bill of Materials what runs well
right that's that's obvious that's
something that we know about so pipeline
automation and orchestration versions
are what we carry through those
pipelines traceability right to express
what we actually talk about and then
maintainability knowing what is there
and how we approach now all those I
really hope are all news you do it all
of you for years and why white deserves
even talk because as with all things
docker
different inversions as well not only by
name versions are todd's but only but
also by the semantics right so those are
a couple of examples versions which look
completely different from what we kind
of used for so you can see here we have
this docker build with this version
which is kind of timestamp on when it
was built and then we have a completely
different scheme here 1.0 release we're
going to talk about all that
so docker version is actually part of
the doctor name and that's why we're
talking about actually naming not
necessarily purging
now docker is like an onion it has a lot
of layers with the top layer be a little
bit different from the layers beneath it
just like onion and tags are actually
related to a top level of docker image
which is the manifest file manifest file
is a descriptor that tells us how docker
layers construct layers by the way like
onions construct a docker image
construct one artifact of docker so in
manifest we will have the list of all
those we will know that this docker
image has three layers operating system
frame would end our application and this
one reuses the operating system in the
framework but have another application
and it has its own manifest so versions
tags actually refer to manifests and
that's important we are going to talk
about the importance of that later and
let's just take a look of which versions
do we have so here we have 1.0 and these
start relates to this manifest but also
1.0 beta another version refers to the
same file now this is something unusual
we are used to one-to-one relation
ship between an artifact and version not
only a release version can be only one
of those but also an artifact have one
version with docker it's different
because you can aim lessly retag the
same manifest the same image adding more
and more versions remove not removing
all the tags and that's exactly what we
have here now
tags are weird because they are mutable
and dynamic my image 5.0 can relate to
some image and I can retake this image
anytime I like also the latest who was
bitten by dr. latest version latest AG
in his okay those are the same people
that use docker in production which
actually makes a lot of sense right well
when you look at the version named
latest you're like I know that means it
means latest and it actually can mean
anything it can be latest it can be the
latest of last week or it can be just
someone named it latest because they
felt like so latest is a very
problematic version because it is it is
a tag like anyone else I can I can I can
put here any other string but also
docker treats it differently when you
try to pull an image or running image
without specifying the tag docker will
look for latest tag and as I mentioned
it can be anything this is very
confusing so let's look an example to
see this dynamic nature of a docker of a
docker image so that's the same you we
will travel with this image all through
this talk we have the operating system
layer the framework layer and the
application layer so here I have that's
my image
with the tag 5.0 because I feel so
yesterday it was built of OS layer 1.0
framework 2.0 an application 2.0 and now
the same image that refers to the same
layers can actually refer to different
versions because those tags can be
changed automatically without changing
the name of this version now this is
horrible and a lot of people will
suggest never ever we tagged a version
with we tagged an image with the release
version and again going back to all our
experience as software engineers that
suggestion makes a lot of sense because
the release is releases release once we
have a stable version we never change it
because maintainability because every
time we go to the same version we have
to be sure that we will get the same
artifact so I'm going to convince you
that it's not the only case I'll try to
build the case for latest and other
mutable tags and the case for latest is
convenient promotion so what is
promotion promotion is moving artifacts
physically or virtually or by metadata
from one silo from one repository from
one environment to another right we take
our artifact whatever it is and we take
it from development to QA to staging and
then to production between different
repositories
now how do you express where the
artifact is now how can you say by
looking at the artifact oh I know this
one is running through Kalina mutable
tags of docker is a very convenient way
to do so right I can have one image and
retag it by some naming convention when
I promote it through different stages it
will be 1.0 dev when it's in development
and then same image will be 1.0 m QA
when it will be to be in QA etc etc
that's comfortable let's make a lot of
sense and more so if you build this
promotion by moving the docker images
from registry to registry well each when
each registry represents the environment
you will have two retag them because
name of the registry or host of the
registry is a mandatory part of docker
image so here that's example of Jeff
regatta factory obviously but you can do
it with any other drug or registry
probably was much more pain but
eventually you can what do you have here
inside of the factory are what we call
repositories but by in terminology are
registries we have the dr. dev local dog
head of testing dog at the stage staging
can dr. prade local all those will be
different registries as for for for
docker like docker sees them as
different registers and when we promote
the images from one registry to another
they are going to change
the tags anyhow anyhow because we have
to return right so let's say five
thousand relates to dev and then five
thousand one relates to testing and five
thousand two relates to staging
every time we move the the docker image
from what to another we will run a dog
attack command changing the name
changing the tag from four thousand two
thousand one and then from where
thousand to five thousand to honor so
this part already expresses the place in
in our pipeline and this is how mutable
and dynamic tags actually help us to get
the creep on our pipeline does it make
sense
good so this is what we have right and
we can have the same manifests the same
image you recognize it by now going it
was called dev and now it is called QA
and then it will be called release
that's exactly this that that's what is
going to happen with this tag now I
don't know how many of you actually
tried to build a docker potion pipeline
by using docker registries
anyone yeah okay so first of all you
should and second of all if you know how
docker registries work you should tell
me now well this is absolutely nuts
because we tagging requires pooling an
image we tagging that and then pushing
it back right docker images are not the
smallest files that you have and if a
promotion you need to download it retag
and upload it that's kind of a
problematic way to do it but it really
depends on the tool that you use if you
just use an
docker registries in terms of daughter
distribution or daughter trusted
registry that's the only way you can do
it but if you use other tools again for
example I have the factory this
promotion happens by REST API you don't
need to download any artifacts you just
make an API call that will retag the
image in artifact or itself right so not
only I'm at the point why dynamic tags
are useful we also provide a way of way
of changing those tags and making them
dynamic very easily now I'm going to
switch hats now I want but let's say and
build the case for immutable tags
immutable tags are critical for
traceability as I mentioned earlier when
we look at the tag when we look at the
version when we look at the name of the
artifact and it is a real artifact we
always want to make sure that we are
dealing with exactly same artifact it's
exactly the same docker image because
otherwise you know people come from
production and say you have this docker
image and it misbehaves and you're like
ok let's take a look at it oh it's
latest it means it can be anything I
have literally no idea which docker
image it is so for traceability I have
to know I have to have version that
correlates to an image in a one to one
method I need to track it back to the CI
server when it was built and then track
it back to the source from which it was
built which will probably won't be the
source it will be a bunch of other
artifacts that you stuck into your
docker image but from there you will
take it forward for further
investigation so what do we have for
traceability
and you know what let's play another
game before you all fall asleep drugger
aside how do you name your artifacts to
provide traceability version of the
artifact okay but but how do you trace
the new version artifact to the source
anyone puts a giver vision into the name
of the artifact yes we do that we
shouldn't but we do how about anyone
puts a build number as a version of the
artifact
sure why not and for what most of us I
think do how many of us actually relate
to the product version when we name our
artifacts that's exactly what you
suggested right a real version also
build timestamps we do that a lot in
actually in previous in one of the
previous slides you saw an example of a
docker image tagged with this timestamp
now all of them are good if you ask me
my personal favorite is the build number
because CI server creates your artifact
this build number this build is the
occasion in which this artifact is born
so relating it to the build makes
actually the most sense now from the
build you can trace it further to the
get commits etc etc and from the build
from a composition of built eventually
your product will be combined but build
have intimate relationship with an
artifact so versioning get after the
build makes them all sense at least for
me but any of them is are good and this
is how you build res ability with any of
those you can take the artifact
and you can be sure 100% that you will
always get the same artifact and as you
can trace it to the places that you need
to trace it someone unlocked the door
oh now I'm doomed okay all right so the
question is which one is better and and
I really hope that I managed to build
the case for both of them and the answer
is let's compare them okay
so static versus dynamic tax and here we
have those examples we have the static
we have the dynamic which is better so
static todd's as we mentioned are
assigned at image creation in the CI
server that's why built numbers are so
awesome and it reflects the metadata of
the artifact that traces the tag to its
build and its content dynamic tags
reflect an image as you use it
right the current latest good version in
a certain scenario I look at my staging
repository and I can take the latest
staging and it will be the last good
known staging right and wanted for
example a trustee or any other boon to
version is a great example of this
dynamic versioning right the boon to
interrupt you that we take today trustee
is what 17 1704 I don't know whatever so
the version that you take now is very
different from the version that you got
when it was first released but what it
means is that's the latest good known
Ubuntu trusting whatever it is right
that's the idea and and latest as one of
the examples doesn't mean that this
artifact was always latest
or will be always latest this latest
actually means that in this point of
time this is the latest good known
artifact that you could use for your
purposes that's confusing because we
didn't use this notion heavily so far
and it's kind of love and hate
relationship right so versions Express
the promotional state recognizing
something that didn't promote well is
very easy right we moved the latest from
this image to the next one and we didn't
promote this one it's garbage I don't
need it anymore it didn't make it to the
promotion and it's not latest anymore
cares about it and of course the
downsides are consistency every day I
have another artifact by the same
version and traceability if someone
comes to me with an artifact in hand
versioned latest I am completely
clueless of what we have in our hand and
as you might guess by now I hope the
answer is we should use both
I have this artifact that during the
creation will get a static version again
this is a timestamp
build number is good get revision is
good whatever makes you comfortable with
and then I will add another tag to the
same image that will express this
dynamic State which is true for now and
in this example it will be the latest
good image of the version 5 for now
probably the next build will produce
another one if it will pass all the
previous stages but for now that's the
latest one so double tagging actually
achieves this purpose we create and push
every image with the static tag and then
we create a second dynamic time for the
same image if that's appropriate it's a
kind of a symlink that you have in most
of modern package managers using your
computers right so if you take a look at
home brew homebrew will install your
browser your Chrome under a certain
version but it will also create a
symlink
to just latest browser and when you fire
up your browser you will go by the same
link and will always get the latest good
version of your browser regardless of
the hard version that is hidden
somewhere so tag name is not traceable
because it's dynamic and tags might have
moved since the client pulled and then
you can use commands like dog inspect
that will give you a checksum
that with certain fat but with real
church will find an image for
traceability what I mean by that is the
same scenario that I love to use you got
docker image which means behaves in
production and it's called latest that's
true the same image has static version
but how do you get to it
there is no command in docker show me
other tags of the same image because
tags and images are completely
disconnected but if you have a checksum
search in your registry you can get a
checksum by using docker inspect you can
search by this checksum in your registry
and you will see how many results for
any given image too early no to thank
you very much of course you will get two
results one will be the static version
and the other will be where you actually
started your search in a dynamic version
right so now I built my artifact and
it's called
production latest and that's a dynamic
tag it only got it
when I decided that this image is
worthwhile going to production but I
also have a static image a static tag
for the same image that was assigned
once during the creation and they point
to the same image so searching by this
image will reveal both pads and then
here I know exactly I have this static
tag I know which version it refers to I
can go to my CI server to my geet and
trace it down to whatever I need to
trace it
now here is another question if I tagged
every image with the static tag how do I
know which top I don't need anymore
which started with which image it
anymore let's take a look so here I have
the same image that you already familiar
with tagged twice that's an image and it
was tagged with the date with the
timestamp and also it was latest one
better right because it promoted from
dev to be the latest good beta in some
point of time and then it was promoted
to be the latest good production in some
time so now it has three different tags
the same image and it's the same with
this one we have the checks that we have
the the date the timestamp and then we
have a dynamic tag now let's say I want
to delete one of the one of the tags
what do I mean by deleting the tag let's
talk about the orphans orphans are
another problem with docker if I changed
my tag during promotion what happened to
an image that was never promoted I
created an image
I gave it a static tag that's a good
thing
and then I promoted it from dev to
staging but it never made it to
production it never got the latest good
production tag it is stuck in staging
because it didn't pass some checks
so what happens is that they lose their
dynamic version they will never be
latest production because they didn't
deserve to be promoted to latest
production they are kind of orphans and
we actually know those guys again from
the other types of our software
development they are de facto the
snapshots of docker think about
snapshots in Java all those artifacts
that were built but were never promoted
to a real version what do we do with
them
we clean them up right they are useless
we keep some because maybe we will need
to rollback but in general every
artifact repository have a snapshot
cleanup policy keep the last three of
them keep the last ten of them but we
need to get rid of the old ones
so in docker images result versions are
those snapshots now as I already
mentioned and that keeps biting us again
and again with docker block your files
are rather big and if you don't clean
them up you have those Dockers snapshots
those images that stuck in some of your
registries in the pipeline without
having the latest version of this
registry they are a big problem so here
is an example a lot of versions and all
those knowns are images without versions
at all
now although storage is cheap and this
is what we like to say to ourselves and
especially our vendors
have to say to us that storage is cheap
it's not infinite and we would really
love to have this snapshot cleaning
policy implemented in docker now let's
see how it's possible and how it works
and we will start with a deep dive on
how docker registers work in terms of
cleaning up the images so we'll start
with the official docker registers
dogger distribution and docker trusted
registry and we will try to understand
how they work so they are checked on by
storages and well it's actually doggy
trusted registry is built on top of
docker distribution so it's actually in
the core the same product all right so
it's actually the story about dr.
distribution so it is checksum based
storage and that means that if we have
multiple tags that point to the same
image they don't take any other space
when we do a copy of a tag we don't copy
the the layers and the image they don't
take any additional space but it means
that deleting the tag does not delete
layers from the storage right because it
might have another target the points to
it it's like Java heap it means it needs
to be garbage collection collected now
we can go and delete the layer but we
need to be very specific about which
layer we want to delete in docker the
identity of the layer is implemented in
shut to check sum we need to go to this
checksum and say delete this and then we
can actually delete the files now the
tags are deleted when you reap push with
the same tag so if you have now in you
image that gets this latest
the previous image loses this latest and
that means that they are without tuck
the manifest even the manifest file
remains and you need to manually clean
it right so delete it tag we cannot
delete all those because it has two more
tags right doesn't make any sense
we shouldn't delete those but if we
delete by using this shot tool when we
delete this manifest what happens to
this guy so we deleted the descriptor
that tells us that this layer is a part
of an image there is no other image that
uses this layer none right there we have
only two this one uses one two three
this we don't have anymore those who are
used by this guy what about this one
it's not getting deleted we will get rid
of this one this one stays now what will
delete it is a garbage collection
process which doctor tries the registry
and dogger distribution actually has
it's required to delete those layer
result manifests and this is how you
clean up space now the problem is that
this garbage collection can be only run
on demand and it is stop the world
garbage collection not for periods of
the collection but through the whole
collection process itself if you gather
the nasca enough garbage and if you have
a lot of images this can take hours and
days in which your registry is not
operational at all because it does that
and if you want to understand the scope
of the problem
Google up some rants about docker and
file space you will hear fascinating
stories people run out of huge storage
spaces because they never knew they need
to run garbage collection this is pretty
much an implementation detail right
that's your definition of fun at 8:00
8:30 in the morning but you're special
people most of people don't care about
this stuff and they run into these
problems right so this is how it works
now you can fight it but again you need
to do some very interesting trick you
need to delete the layer before you
actually delete the tag by hitting the
shot tool of the layer itself you search
for it in the manifest you delete the
layer and only then you delete the
manifest itself definitely not common
knowledge well you can also not
out-of-the-box has nothing to do with
docker kind of clean up the registries
by finding the layers that doesn't have
any mention in manifest burning this
simple command I see you don't take
pictures because it's obvious you'll
just come to your desk and run it fair
enough
now always rant about docker
distributions was of course a build-up
to show you how it probably should be
done and of course it is probably done
in zero gravity Factory right so the
bottom line is you don't need to care
about it anymore
we do the garbage collection
transparently behind the scenes
immediately after we discover a layer
doesn't have any references we delete
the manifests that are not referred to
any tags we delete the layers that are
not mentioned in any manifest and
deaf you just don't care about it it
just works we have the API that I
mentioned earlier in which you move
artifacts between the registries
immediately in the backend in the
artifact or itself and we of course will
do all the cleanup of the old stuff as
well so we generally don't think about
any of those and you can as you
configure maximum amount of snapshots
that you want in Java in your repository
you do the same with you do the same
here with with docker you can say this
image I don't want to have more than 10
tags on it if I have more than 10 orphan
tax tax without being promoted to latest
just stop removing the old ones start
removing the old ones and this is how it
works right so we delete the dog the
manifest will be deleted we will find
that there is a layer that referred to
none of the existing manifests and we
delete that as well same here we delete
the manifest by char to know through the
tag and we have an orphan layer it will
be kickdown as well so it's all
absolutely transparent to you right so
we deleted that
please get new we deleted that please
get me off this one so I have two
minutes and that's a good time to recap
it was a lot of very down-to-earth
boring details dynamic versions are good
for promotion you know exactly the
position of the artifact and more
importantly you can refer to the last
good known artifact in any step of your
promotion
give me the latest QA I need to test it
boom you have it you don't need to find
which one of them actually the latest
good one static versions traceability
you need to look at an artifact and say
yes of course I know when it has the
build number it correlates to a build
number in Jenkins this is it double
tagging now okay and the Rita
moving between artifacts and changing
the knowledge about the latest good in
QA to the latest good in production
should be done without pulling and
pushing that's because doing that
doesn't make any sense
and of course all on reference objects
both the manifests and the layers
themselves should be garbage collected
immediately without taking up your chip
but still costly space so that's the
thing and with that i'm jabari on
twitter that's the time to praise Jeff
welcome shownotes is the very
interesting page in which I will post by
the end of the week this slides the
video and the links to all the technical
material that I spoke about you will go
there you will see Oracle code you will
see this talk there and everything will
be there also we're hiring and me
personally I hire I look for a developer
advocate if you want to be here like 8
a.m. completely nude after working for a
presentation the night before and then
get the old rainylin rush to speak with
you wonderful people come to talk to me
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>