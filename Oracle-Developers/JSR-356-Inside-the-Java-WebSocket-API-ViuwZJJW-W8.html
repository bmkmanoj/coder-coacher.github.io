<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JSR 356: Inside the Java WebSocket API | Coder Coacher - Coaching Coders</title><meta content="JSR 356: Inside the Java WebSocket API - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JSR 356: Inside the Java WebSocket API</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ViuwZJJW-W8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to this talk on the Java API
for WebSockets I'm Dani coward I work at
Oracle and I was the specification lead
for the this the first version which is
what I'm going to talk about so everyone
seen this this week that protects Oracle
legally from me saying dangerous things
so I think I don't think I'm talking
about the future at all which is nice
for a change in these talks and talking
about things that we've done and is
shipping and you can get today and I
don't think I'll really talk about the
future so let's make that go away so I
made people laugh at the safe harbor
statement and it's a real achievement
alright so I'll do a quick introduction
on just the WebSocket protocol and talk
about what what they're for and then
most of the time I'll be showing api's
and I have a bunch of demos and
applications to show you that hopefully
will you know take you through
everything that this API can do so the
roots of WebSockets are you know trying
to wait make websites more interactive
websites that have you know people
sitting in their browsers looking at the
the homepage or the newsfeed or they're
you know they've just posted some photos
on Facebook and they're all sitting
waiting for those little red red marks
to appear to make everyone excited so
servers want to push out this
information to browsers even when users
are not doing anything with them so over
the years probably over the last ten
years technologies have grown up to
overcome the limitations of HTTP which
is a request response technology so you
know by its very nature doesn't allow
the server to push information unless a
client has just asked for it with
techniques like polling long polling
sometimes opening to connections one for
fetching information and want to listen
in for
the server pulling information back
frameworks have grown on top of this
like Ajax and comet - you know perhaps
formalize or make these easier to
program - but really they were just all
band-aids on the basic problem of HTTP
being a request response protocol with
no inherent notion of safe server push
so it was really wasteful because there
were all these open connections waiting
for information to arrive even if there
was no information that was going to
come so that didn't really work terribly
well
so then WebSockets is this new TCP based
protocol that sort of piggybacks on the
the same TCP framework that HTTP uses so
the idea was it would fit well with you
know today's proxies and servers
intermediate servers and so on it's a
fully bi-directional messaging protocol
and it's aimed to solve this problem of
servers being able to push out
information to web clients it's part of
it's probably the biggest piece of html5
I'd say the biggest API and there's a
w3c defined JavaScript API so from a
browser you can write little bits of
JavaScript that can listen in for
WebSocket messages coming back from the
server and it's been quite quickly
adopted since it finished it was about
two years ago now so there's this
website called can I use comm and it
tracks adoption of technologies and one
of them that it tracks is WebSockets and
I know this is very small so I'm going
to magnify the relevant part on the next
slide but what this table is showing you
is going back you know multiple versions
which of the major browsers have
supported WebSockets
so we go back 25 versions and you can
see that Firefox and Chrome were kind of
the early adopters and
if we magnify the line that is today
which is I think what we mostly care
about is that you see you know the
columns are the different browsers and I
think they're ranked by their their own
methodology for working out which is the
most widely deployed or popular and you
can see that all the major browsers up
to iOS Safari support it today in their
most latest versions and then Opera Mini
and Android a kind of the Android native
browser holdouts but pretty much all the
browser's support WebSockets today so
this I think means that if you're a web
developer or interested in web
development or you have a web
application this is certainly something
that's fairly safe to to work with today
and for those holed out browsers or
legacy browsers you can always fall back
to those existing Ajax and polling
technologies it's a technique that a lot
of people are doing so they can reach
everybody it's developed by the you know
in the JCP as is usual for Java API s
here are the folks that collaborated a
number of them already had pre-existing
Java API is for WebSockets so in a sense
a lot of what we were trying to do was
to you know bring all those api's
together so that was one API instead of
lots of different API so it meant we had
a lot of expertise as well in how to
represent this protocol as a Java API
and then since we completed it the web
socket API of course is standard in Java
EE 7 so all the EE 7 implementations
support this API that I'm going to be
talking about we filed a you know we
filed a jab I think they're called now a
feature request for SE 9 so maybe we'll
see the client side of this API pop up
in Java SC maybe even the server side I
don't know parts of it so then of course
in GlassFish 4
which I'm sure you know you can download
today freely this is supported and it's
not the only implementation of course
our own implementation project at Oracle
is called tyrus so you can follow you
can see an open and open-source version
of it there too so the basic idea of
WebSockets then is you establish one of
these special TCP connections between
two peers and then you send messages
backwards and forwards and you can send
a message backwards and a message
forwards at the same time because it's
bi-directional and then when you've
finished your conversation you know it's
bit like a phone call you you say
goodbye and you hang up and that ends
the connection and it tears down the TCP
connection and that's that's it it's
fairly lightweight so here it is when
you establish the connection you know as
a developer of a WebSocket you don't
really need to know this stuff but I
think it's interesting to know more
advanced to use cases sometimes need to
know this interaction so the first thing
that happens is the client that wants to
establish the connection sends a
specially formulated HTTP request called
an opening handshake request and then
the server looks at it looks at the
parameters and then it sends back some
kind of response that is either you know
no or yes with these conditions and
thereafter you are then connected so
this is what the handshake request looks
like again as a developer of most
WebSockets you don't really care about
this but it contains the URL for the
WebSocket WebSocket endpoints and map to
URLs as we'll see it contains it uses
the HTTP upgrade mechanism to request
that the server upgrade the connection
sort of logically upgrade the connection
up to WebSockets from HTTP it might
contain some other qualifying
information then the server you know
might check the the clients credentials
out might look at things like sub
protocols or any special extensions the
client has requested and then this is a
a successful response that notifies the
client that it's then ready to establish
the TCP connection and then you're
connected WebSocket events so once you
are connected then WebSockets unlike
HTTP which is just you know hello I want
something here you are goodbye there's a
bit more of a lifecycle inherent in the
protocol so once you're connected the
first thing that happens is that both
ends get this open event and then the
next thing that happens is one or other
of the ends of the connection will say
something will send a message of some
format that will talk more about then
maybe the client will send another
message and another message maybe
finally the server will respond this
servers a little playing hard to get I
think errors might be generated on the
connection they may be maybe more
network level errors or they may be
errors generated in the message format
maybe the message is too big for example
so an error event is another event in
the life cycle of a WebSocket more
messages it might be not not be a fatal
error
so more messages may be sent and then
finally one or other party will say
goodbye just like a phone conversation
and this will close the connection and
everyone will get disconnected so that's
the life cycle a little richer than HTTP
so now let's turn to them that you know
we've sort of understood maybe a little
bit about how the protocol works let's
look at the fundamentals a lot of ideas
of the API the Java API for WebSockets
so it all focuses around the idea of an
endpoint and this is the piece of code
that as a developer you will write that
will handle these lifecycle events will
generate messages will listen to
messages coming in
you know we'll push new news to your
Facebook newsfeed and so on so on the
web server here we have a Java WebSocket
endpoint and then really there are two
there are two main deployment scenarios
you either have a browser client
connecting in and if a browser client is
connecting in that usually means that
you have a web page with some JavaScript
using the w3c JavaScript web socket API
and that's that is the endpoint on the
client side or you are working in a rich
a rich client - rich Java client for are
using a swing GUI or JavaFX in which
case you have a Java endpoint using this
Java API to have the conversation with
the server endpoint so the central idea
the central component in the API is an
endpoint now to create one of these
endpoints you I do one of two things you
either use an annotation to take a
regular Java class and turn it at the
class level into an endpoint and then
use method level annotations to handle
the different events and we'll see all
this or if you prefer a programmatic
approach maybe you don't like
annotations maybe you are thinking of
building a framework on top of this API
where you want more direct control you
can take a programmatic approach and
subclass and one of the API classes
which is funnily enough called endpoint
and mostly in the two approaches you can
get the same functionality there are one
or two extra things you can control in
the programmatic API but mostly they're
equivalent and endpoints can either you
know reside on the client side which is
you know a phone or a desktop in which
case what makes them a client as they
the endpoint is connecting to just one
so
or these end points can live on a web
server in which case they're ready to
accommodate requests from multiple
multiple clients so that's in the
protocol is there's really very little
distinction between a client end point
and a server end point but once you come
to deploy them you're either sitting in
a browser trying to work out how to
connect to a website that has endpoints
or you're writing the website expecting
multiple client connections from
WebSocket endpoints so oh here we are
so we'll do a demo so here we are I'm
just going to show ya a lot of versions
of this was actually last year's talk
which was awful so here's here's the
code of hello world of WebSockets which
is now I'm in Chrome I mean the Chrome
browser here which supports WebSockets
we know that because we saw three slides
ago and there's a little piece of
JavaScript embedded that's going to open
up a WebSocket connection back to
GlassFish running a Java endpoint that's
just going to bounce back the message
that the client sends to it so here's
the the message hello Java 1 and when I
send it
then I'm dumping out the output just on
the on the page really here and I sent
the message hello Java one and then
irises got sent to the server endpoint
which just bounced that message straight
back at me over the WebSocket connection
so let's just look a little bit at the
code get the right presentation back up
and it's not that one either it's this
one let's look at this let's look at
these very basic WebSocket endpoints
here's the one that that demo actually
uses on the server side so the classical
echo server that's I chose that and what
it does is it uses this annotation app
server endpoint which contains in this
example just the path attribute the URL
that it publishes and that's how clients
are going to connect to it it's like
it's telephone number or its address and
then it has one method this echo method
which is annotated with another of the
annotations from the web socket API the
@ on message annotation which says
whenever there's a WebSocket message
then I want I want this method to handle
it so in this case the echo method
whenever there's a text message that
comes in from a client the
implementation is going to pass that
text message into my echo message and
the return value of this method is
treated it's kind of a special
convenience case it's treated as an
immediate reply to that incoming message
and that's what we want in this echo
case it's often the case that the server
will they synchronously send messages
and I'm going to show you all of that
but just this very simple echo cases is
very simple to see then if you prefer
the programmatic approach if you don't
like annotations or for whatever reason
you like you feel safer extending
classes then here's the equivalent code
but in programmatic form so it's a
little more involved as you might expect
here we're extending the endpoint class
and there's one method on endpoint that
you have to you have to always implement
when you override endpoint it's the on
open method this is the method that's
called back
when the WebSocket endpoint receives the
open event which is the first thing that
happens once the connection is
established then what happens is the the
session which represents the WebSocket
connection is passed in and from the
session you can see well actually I
should say the first thing you can do is
to add a message handler to the session
to the connection so this is the message
handler dot whole string which says
whenever a text message comes in
I want this message handler object to
handle it so the one method on that
interface that you have to implement is
the on message method and will then
whenever a text message comes in this on
message method is going to be called and
you can see if you see my pointer here
know inside the try/catch then from the
session we can get hold of something
called the remote endpoint which is
where you can send messages back to the
client will see lots more of this and
you send the message you bounce the
message back so fairly straightforward
but you know degree more more degree
more of boilerplate than the annotated
version then if I wanted to write a rich
client then you know I thought I'd show
you the the Java client in so if I
wanted to swap out that browser for a
Java component instead of running on the
client side then I could use the
analogous at client endpoint annotation
which turns my Java class into a client
side web socket endpoint and then in
this this case on the unopen method as
soon as the client becomes connected we
want it to send a message to the server
so we're intercepting using the at on
open annotation that connection
established event and then we're sending
by getting the remote endpoint from the
session the message over to the server
and then just to show now we've sewn all
four annotated programmatic client and
server
this is the programmatic version of that
yes can we do questions at the end
because there's a there's a risk that I
might answer the question later in the
presentation and we'll save them all for
the end so let's see we did the
lifecycle I have got it switched up in
these slides here okay so you remember
the diagram that showed the different
the different events here this is a
listing in the first column of the
annotated event intercepting annotations
so at unopen you can use to decorate a
method that you want to get called when
the connection is first established the
app on message annotation is called when
a message comes in when you want a
method to handle any error conditions on
the connection or when messages arrive
you would use the @ on error annotation
at on close to intercept the closed
event and then in the second column you
can see the analogous methods on the
endpoint class that you would override
if you wanted to intercept those events
in a programmatic in the programmatic
endpoint so this is actually wrong
because this should be on error I should
make this a competition because I have
some books to give away but you've
missed your first chance to win a free
book but there'll be other chances later
so in a programmatic endpoint you
override on open to get the open event
you register a method message handler if
you want to intercept messages there are
lots of different kinds of message
handlers that I'll show you if you want
to intercept
to error events you override on error
and if you want to over I intercept
close events you override on clothes so
I have another demo here which I'll show
you the code of this one this will show
you this life cycle actually working
let's see here so again in this example
I have a browser client with some
JavaScript inside it and then on running
on the server I have a Java endpoint
which is going to intercept all this
different lifecycle events and I'll let
me just show you how it works so the
first thing I do is open the connection
my traffic lights goes green because the
connection is now open then the client
can send messages it can send a band of
bad message a message that the server
cannot deal with in which case it goes
amber or orange for the Americans here
and then I can either have the server
initiate a closing the connection which
I just did then and then the server has
remembered that the connection was alive
for 29 seconds or I can go back and
reopen the connection or I can have the
client initiate closing the connection
either end can hang up first in which
case the client close the connection so
let's take a look a little look at the
code here so what I want to show you is
the server side component here let me
get rid of this is that visible
it's that readable okay so my class name
is lifecycle endpoint again this is
running on the web container so I'm
using the app server endpoint because
this is a server endpoint I'm using the
at on open and at
to intercept the open event when the
event opens I get a hold of this session
object which represents the live
WebSocket connection and I store the
session actually as an instance variable
here I put the start time and a little
user dictionary we have on the session
and then I send a message back to the
client saying i just opened the second
lifecycle event that this intercept is
every time the client sends a message
this method when getting a message is
called and here we are we're passing out
the bad message by looking for xxx which
is kind of ironic think given that an
Oracle employee that was at the the club
and charged it on his Amex I guess he
should have used WebSockets or something
and then otherwise if it the message
contains clothes it sends a message and
closes the connection and otherwise it
just returns that it processed the
message so that's handling a message in
various different ways then if something
goes wrong on the connection I want this
when something goes wrong method to be
called and I get what gets passed in is
the throwable that represents the
problem that was caused that the error
condition was which I can interrogate
and find out what happened and then when
it's closing I want this when closing
method to be called and I just say
goodbye let's see the yeah and that's it
so you can see that you've got lots of
freedom to name the methods what you
whatever you want the kind of parameters
that kept passed in the session object
is a critical object here because that's
the place where you you get hold of the
remote endpoint which allows you to
reply back to WebSocket messages so you
can see once you've got a reference the
session object you can send the client a
message at any time it doesn't have to
be as an immediate response
so that's the lifecycle example let's
return to the slides now let's turn to
basic messaging so there are lots of
different modes of messaging ways to
send different formats of messaging in
the websocket api so I'm going to I'm
going to show you all of them actually
so you'll know them all the way to send
messages however you send them and in
whatever format you're sending them is
by using the remote endpoint interface
so this is available from this session
object which is passed into these
lifecycle methods that you you know you
either subclass endpoint and get them
there or you use annotations and you can
get always get the session object so
from the session object you get a hold
of one of these remote endpoint
instances which is the representation of
the client and you call one of the many
send methods on the remote endpoint so
that's always the way that you send
messages except in the one particular
case for convenience really if you want
an annotated method to always return
immediately some kind of message it
might be in this echo case which is
because that's what the method is
supposed to do or it might be useful to
acknowledge receipt of a message because
the WebSocket protocol itself doesn't
guarantee delivery of your messages you
may know that your message has been sent
and that nothing bad happened during the
transmission but it's no guarantee that
the endpoint at the other end of the
conversation actually received that
message so sometimes useful to use this
convenient style where you actually
return a value from the method to
acknowledge receipt of a message that
can be a useful programming style but
usually and especially when you are
initiating a send
not in response to something the client
did you will use the remote endpoint and
one of the send methods on it so here
are the main ways to send a message
synchronously on the remote endpoint so
if you want to send a text message just
as a whole string this is good if it's
just a short message then you would just
use the send text method if you want to
send it in over the bind in the binary
framing in the WebSocket protocol you
can create a byte buffer an i/o byte
buffer and call the send binary method
then something that really grew out of a
couple of the implementations of the of
WebSockets in Java before we did this
Jess are many of them had this way of
sending you know string in chunks using
this send text where you send a part of
a string and then a boolean to say is
this the last bit if it's not the last
bit then there's another bit coming or
at least one more bit coming and same
way you can send binary data in
fragments using this same mechanism it's
a kind of Poorman streaming yes yes oh I
shouldn't say poor man then for you can
send things using blocking the
traditional blocking api's some people
prefer it this way some frameworks you
know that turn java objects into
particular formats of strings and binary
use these pipes this this way of
exposing the pipes this blocking method
so we expose that way too and then if
you've got custom objects like you've
got customers or Apple objects or
developer objects that you've created
you can send those to the only thing
that you have to do is you have to tell
the implementation how it's going to
decode your sorry and
code your object your Apple object or
your customer object into either a
string representation or a
representation of it as binary data and
I'll show you that next so these are the
ways you can send thing as whole strings
byte buffers a kind of streaming
metaphor here and then blocking i/o and
then any custom Java object and then
equivalently on the receiving side when
you want to receive messages there are
two ways you either use the at on
message annotation and then write a
method that decorates and and that's
where you get the message from then or
uou implement this interface from the
api called message handler and then you
register it on the connection on the
session and those are the there's you
always listen for messages using one of
those two ways
so analogous to all those ways of
sending messages all those modes of
sending messages you can receive them in
all those different ways as well so if
you want to receive a whole string then
write a method that has a string
parameter and decorate it with at on
message and the text messages will come
to you as a string object or if you want
to handle the incoming messages by
reading them from a Java dot IO dot
reader then write a method that takes a
reader as a parameter and decorate it
with annotation and the same with if you
want this incoming streaming idea then
write a method that has a string
parameter and a boolean parameter and
the method map message will be delivered
to you in in chunks like that same with
binary you can get a whole byte buffer
as an input stream or in fragments and
then also analogously if you have a
developer object an apple or customer
you can elect to receive messages as
those objects but again you will have to
provide this time a decoder
object and register that with the
implementation to tell it how to turn an
incoming native WebSocket message and
instantiate one of your developer
objects from that so then if you're in
the programmatic camp where you like
doing programmatic endpoints then the
message handler listener interface that
is that you're going to implement comes
in a variety of different flavors
so the message handler has various sub
interfaces that allow you to elect how
you want as a programmatic endpoint
developer to receive the messages so
again as a whole string a string
fragments as a reader as a byte buffers
partial bytes as an input stream or as a
custom developer object provided you
register a decoder so these decoders are
configured either on the annotation so
decoders for incoming messages you
implement the decoder interface which
handles the convert which was where you
put your conversion code and then you
register it on the endpoint or if you're
a programmatic endpoint developer you
have to build an endpoint config object
and register your decoders and encoders
on that config object and then the
container will know which conversions to
make as messages are going backwards and
forwards so let's take a little look at
the encoder and decoder hierarchy of
classes for encoding this is where
you're sending messages the encoders
that take your custom objects to sum to
the binary representation are encoded
binary and here the parameterised type T
is the type of your developer object so
you have a customer object or an apple
object and you want to encode that as a
binary as a byte
to send then you would implement encoded
binary dot what did I say Apple or
customer and similarly if you want the
binary stream you would in you would use
that encoder and so on for the decoder
family it's symmetrical if you want to
take your Apple and make sure that every
incoming text message is converted into
one of those Apple objects you would use
the decoder dot text dot sorry brackets
Apple and so on so you have a lot of
flexibility if you want your application
only to deal with developer level
objects and you want to kind of rise up
from dealing with strings and binary
data all the time so let's take a look
at that in action so here I'm going to
show you a group drawing application and
this one I'm not going to use a browser
I'm going to start up a swing
application which uses a yes that one
which has client a client endpoint
inside it so here are my two drawing
windows the idea is this is some kind of
group drawing board and I've got two
clients you know that are using this
drawing board and when you draw on one
side you get the kind of paler version
of you know what's going on on the other
side you can change shapes you know that
kind of thing and what's happening is
that on the server there's a server-side
web socket endpoint on each of the swing
clients in each of the swing clients as
a Java client endpoint every time you
draw on the drawing board the client and
point sends a message to the server
saying I just drew a Red Square and here
are the dimensions and the server
quickly gets a hold of all references to
all the other Connect
clients and sends them all the message
saying someone drew a red square of
these dimensions on the group drawing
board then the client endpoint on each
of those connected clients receives that
message and says oh I'd better draw one
of those so we can all keep our group
drawing broad in sync so all the
messages are WebSocket messages and what
I want to show you in the code here is
that I am actually using three different
ways to send and receive these messages
let's look first at the client side so
on the client side sorry on the server
side again I'm using the app server and
in point this is kind of the fundamental
thing we always do do then the the
method of interest here is shape created
and it has the @ on message annotation
which is saying every time a message
comes from the client give it to this
method and this time I've elected to
receive my messages as a Java IO reader
so here what I'm trying to do inside
this method is create at one of these
higher level drawing object which says
it's a Red Square of these dimensions
from that reader so I'm kind of doing
this encoding by hand this decoding by
hand in this case and I have you know a
special class that that is doing that
decoding then I get hold of the drawing
object and then from this drawing object
I'm going to formulate another drawing
object which is the one I'm going to
broadcast to all the other connected
clients and it's mostly the same it's
still a Red Square it still has the same
dimensions except I think I fade out the
color I fade out the color you probably
noticed that when I was showing the two
screens and so on and then once I've
created the object I want to send out
I'm calling this end drawing method
let's take a look at that which is going
to broadcast it to all the other
connected clients here it is send
drawing and I have this representation
of the drawing now as an iterator and in
this case I'm using the send text with a
partial string for each chunk of the
drawing as an iterator and then the
boolean whether this is the last chunk
or not and that's the way I'm sending
the drawing object as a sequence of
strings here back to the client so that
looks rather involved especially for
sending a red square so let's look at
the client side version here I've used
the wonderful encoding decoding
mechanism of the web socket API to sort
of radically simplify the code on the
client side where on the client side
whenever it receives a message from the
server
this drawing changed method is called
and it selected to receive it as a high
level drawing object this time I'm a can
do that because inside the client
endpoint annotation I've declared my
drawing decoder which has the code that
can take a string and bring it up to one
of those drawing objects and similarly
when the client notifies hey I just drew
a red square in this method here when I
get the remote endpoint and calling the
high-level send object method and
sending the drawing object not a string
or a binary representation and you'll
notice at the top that I have a drawing
encoder It's Made questions at the end
we can always I'll show you path mapping
that might answer it and we'll come back
to that if it doesn't alright so back to
the
configuration and sessions so this might
start to answer that question but I'll
make sure that we do before the end so I
talked about the session object
representing the connection one obvious
question is well how many session
objects are there there's one unique
session object for each connected client
to that endpoint and I talked about the
endpoint config object that contains the
you know the list of encoders and
decoders it contains the path to the end
point which we will see there's one
instance of the end point config for all
instances of that end point now in this
in the program model the end points that
you create the container will stand
instantiate a new one for every
connected client so you get a new
instance per connected client if you
have ten clients you have ten endpoint
instances all with the same endpoint
config so the reason we did it this way
was that what this means is that we can
guarantee that the container the
WebSocket container only ever has one
thread calling your endpoint instance at
a time so you don't have to worry about
concurrent threads entering your
endpoint instance at any one time there
is a mode is a kind of an advanced mode
if you use the endpoint config where if
you want to have a singleton instance
and you want to handle multiple you know
messages coming from multiple clients in
the same instance you can do it that way
that's like the servlet model and then
you have to program for concurrency you
might have ten ten messages coming in
all at once but the default mode is that
there's a new instance at the endpoint
every time a new client connects this
makes for a simpler programming model so
the key objects here session represents
that connection with a peer there's one
instance of the
connection per connected pier and then
one useful feature is it has of this
property bag for keeping application
state that's specific to that client and
I'll show an example of that next then
the other key object here is the
endpoint config this holds all the
configuration information the encoders
the decoders the path for example
there's one instance per logical
endpoint so if you have an endpoint and
a hundred clients connected there's one
instance of the endpoint config this too
has a property bag and because there's
one instance per logical endpoint this
is a good place to store application
state that's common to all your
connected clients not just to one of
them you can also sub subtype endpoint
config and add your own behavior if you
wanted to you know do some expensive
thing like initially it and initialize a
connection to a database you might want
to subclass here and have that code
called prior to any of the clients
connecting so just to show those two
ideas of the endpoint config versus the
sessions let's take a quick look at my
chat application this is kind of one of
the canonical WebSocket applications
because chat is a very server push style
application and chat is here
and I'm not going to spend a great deal
of showing you a chat application but I
just want to show you a couple of things
dear
not so much space okay so I'll sign in
as me here and I say hi there but
there's no one in the chat room so
that's very lonely so let's have Jim
sign in as well over here so I'm showing
this is Safari and chrome just to Ram
home the message about adoption go away
Danny yeah
so I'll go away so you know a couple of
things to notice one is that each window
has its own notion of the user each
there's one user per window
but there's one global state here which
is the chat transcript because that's
the thing you're going to show to
everybody so let's just buzz back to the
presentation here because I wanted to
show you where where you can keep that
state here actually this is you know
showing the instance state when I've
signed in on one window is Graham and
then the other window sally has signed
in so the logical endpoint is the class
that is the chat server which has the
app server endpoint annotation then each
time a new client connects in a new
instance of that class is created one
for Graham and one for Sally
representing each connection as a new
instance of the session object one for
Graham one for Sally and then the way I
designed this sample the username is
kept within the session in that property
bag but the chat transcript I'm actually
storing in the endpoint config so you
know this is in j2ee did Java EE so you
know you can easily use EJ bees to
backup this kind of global application
state but it's often convenient if
you're not in a j2 environment if you
want something lightweight just to have
a good place to put global application
state common to all endpoints and also
an easy slot to put application state
to one particular client I don't have to
speed up a little bit I showed you all
the synchronous messaging you can also
send messages asynchronously a create
synchronously that asynchronous the
asynchrony here is that message
transmission may take some time so in
the synchronous methods the cause all
block until the message is transmitted
there are a number of ways of sending
things asynchronously so that you don't
have to wait for the message to transmit
before your call has finished this might
be useful in GUI programming this might
be useful if you're sending very large
messages you don't want the the thread
in your application to be waiting on a
large message to be sent so instead of
the remote endpoint basic which is where
all the synchronous send messages are
you would use the remote endpoint async
and the modes of asynchrony are you can
send a message and receive straight back
a new token current future object which
you can then cancel you can interrogate
whether the transmission has completed
on art or the second mode is to send by
completion where you pass in a callback
object and then when they your send
message which returns immediately but
when the message is fully transmitted
you get called back saying that the
messages have been completely sent or
that there was an error I'm not going to
show you that sample because we don't
have time there is another even yet more
how could there be a more advanced way
of sending messages but yes there is
some containers implement is this
technique called batching where if you
send you know five or six messages out
to a client instead of that sending each
one one at a time
it will batch them up into a nice big
batch and then send them all at once so
this is what this diagram is trying to
represent on the top we're just sending
each message one at a time
on the bottom we're sending them in in
chatting in larger batches larger
collections of messages this is useful
for high frequency applications that
send messages at high frequencies lots
of messages going within a very short
period of time it's much more efficient
even the lightweight framing of
WebSocket has some overhead so it can be
more efficient to sending this way the
good news is if you don't care about
batching you never need to worry about
it as a developer but if you do happen
to be running on an implementation that
does support batching you can take
advantage of it by switching it on so
you set this flag set batching allowed
on the remote endpoint but then if you
do allow batching then you have to be
ready to take care of the case when you
have sent through messages but they may
not have actually been transmitted
because the batch wasn't full and in
this case we have this flush batch
method that sends whatever Zinn the
batch even if it's not full so you can
make sure that the attempt is made to
send all the messages
so that's batching path mapping this is
how the this is the anatomy of a
WebSocket URL the client is trying to
connect into an endpoint that's running
on the web server the web server has its
own host name fab apps comm and then
it's been deployed the endpoint is
deployed inside a regular War file with
context route what my web app and then
the endpoint path that you saw in all
those server at server endpoint
annotations is foo so when you add all
those three things together you get the
whole URL to our website now there's two
kinds of paths foo was just a simple
example but there are two kinds of paths
you can either use a partial a relative
URI
like foo or airline seating up data or
something else in which case the
implementations use an exact match
policy on incoming requests to match to
that URI so if your endpoint is map to
foo only an incoming request to foo will
match it nothing else will match it and
then you can't have two endpoints map to
the same URI in the same app because
that would just be confusing for the
container to know which one to map it to
and the second type of mapping you can
make is to a URI template so we limited
the kind of URI templates to level one
for those of you who know about all
about URI templates so here are a couple
of examples slash travel slash mode as a
variable and then there's a match on an
incoming request if the the incoming URI
is a valid expansion of that template so
here are some examples on the slide I
won't go through them in detail but this
is a useful technique if you want to use
the paths to somehow parameterize the
application maybe you want to do member
level gold silver bronze and have that
as a path parameter and then from within
the endpoint you can access these path
parameters using an API or we have a
special annotation to access the
expanded parameters so this can bring a
lot of flexibility into mapping
endpoints security for everybody who
knows the servlet security model the web
application security model this will be
very very familiar because WebSocket
endpoints a map to your eyes in the
specification we simply took that model
and said everything that applies to a
web resource today you know in EE 6 for
servlets and jsps and JSF components
they are WebSocket endpoints because
they map to your eyes as well they're
protected and limited in the same way so
therefore you can
require that to access a WebSocket
endpoint all your users have to be
authenticated using one of the standard
EE mechanisms you can limit access to
the WebSocket endpoint to only users in
certain security roles and you can
require that the only protocol you can
access a WebSocket
endpoint by is an encrypted one using
WSS so those are the sort of three
fundamental things you can do just as
you can for other web components I have
another sample but I think we're going
to buzz to the end here so you can see
here for those of you who've handwritten
these web XML files painfully but this
is to give you an idea that here the
example is a stock trading account I'm
using a security constraint to say that
only authenticated users can access the
account information and only the ones in
the customer or Prem premium customer
roles can do so and their access must be
encrypted I can make sure that the home
page index.jsp on the fifth line is only
accessible over SSL I'm using basic auth
to access this website and I have two
security roles customer and premium
customer so let's see and today there is
only one book that covers the Java web
socket API and it's really incredible
and I wrote it and there's a big box
full of them at the Oracle note the book
store down in Moscone so if you're
interested it covers you know all
aspects of the API it's wonderfully
written and I'll be there tomorrow at
1:30 and if anyone can remember
something that I said then we I think we
have a dozen free books to give away so
if you feel like it drop by
you know mention one of the samples or
something come and say hi and you'll
you'll get one of the free books so just
to finish it's in GlassFish for we've
got some WebSocket examples sample code
that you can look at straight in in
GlassFish they added to the the
excellent EE tutorial a little section
on WebSocket programming and tyrus is
the implementation project to see what's
coming next
so thank you all it's if there's time
for questions please ask questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>