<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Project Jigsaw: Under The Hood | Coder Coacher - Coaching Coders</title><meta content="Project Jigsaw: Under The Hood - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Project Jigsaw: Under The Hood</b></h2><h5 class="post__date">2016-09-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Vxfd3ehdAZc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone to the fifth of the
five jigsaw talks project jigsaw under
the hood quick poll who has been to all
five some a small number of hands okay
so people have fought okay yes yes yes
so people have this is a serious
question people have been picking and
choosing when we've had a sequence of
jigsaw talks people have been picking
and choosing which ones to go to yes
okay interesting we all we have another
five-star we have 25 * attendees at the
front I think you've probably been to
all five one of them twice up a now
you're in the fifth one let's go with
them ok so anyway my name is Alex
Buckley I work in the Java platform
group at Oracle and this is the deep
dive behind the scenes under the hood
what's really going on with class
loaders in jeddah canine that tries to
explain some of the some of the
statements you may have heard in other
talks talking about the the jets that
are in jdk 9 sometimes some statements
are made that seem to be a bit confusing
and i hope this talk will explain what's
really going on so in jdk nine but it
stand alone so i still need to introduce
that in jdk nine the main feature is the
module system the let's code be more
reliable and maintainable we've used the
module system to turn the monolithic JDK
into the modular JDK that is breaking up
the RT jar file inside the JDK into
dozens of reusable modules jdk 9 also
has small enhancements to the Java
language and somewhat larger
enhancements to the standard labors plus
Javadoc gets a search box and JDK via J
shell includes a ripple at last round of
applause I can I can hear
in my head ah so project X or is a
project led by Oracle in OpenJDK it's
the container for all of our work
building a module system and
modularizing the JDK we're standardizing
the module system in the java community
process through jsr 376 and we're
standardizing the structure of the
modular JDK in the java community
process through the umbrella jsr for
java SE 9 so when you use JDK 9 you're
always subject to the rules of the
module system that's what's under the
hood and it's what most of this talk is
about they'll touch on some aspects some
of the impact of the modular JDK in near
the end this talk has four parts the
first part explains how the module
system works with the java language and
vm to improve the reliability of your
code the second part is really about
migrating to modules the third part
explains what the module system is
fundamentally capable of beyond what you
can express in the java language and the
fourth part is about the road to jdk
nine and some of the things you should
watch out for while traveling on it so
first part everyone knows the hierarchy
of accessibility in the java language
and vm it's simple to understand easy to
use and strongly enforced by the
compiler and vm but it has a big
weakness the only way to share code
between packages is with public but then
you're sharing with everyone it's not
surprising that package friendship in
one form or another has been requested
many times over the years one goal of
the module system is strong
encapsulation to allow a component to
declare which of its public types are
accessible to other components and which
are not the lines in italic are the
levels of acts
ability in Jerry canine connected with
the module system reading upwards you
can arrange for public types to be
accessible only within their module or
accessible within their module and two
other specific friend modules or
accessible to everyone as was injured he
ate so as usual migration drives a lot
of our thinking we want to make it easy
to place an existing package into a
module and immediately give that package
the benefit of strong encapsulation we
don't want each and every public type in
a package to have to opt-in to strong
encapsulation so public types in a
package are not accessible outside the
module by default that is public on a
type declaration no longer means
everyone can access the type what
happens if someone tries to access a
public type that's not accessible here's
a slightly aging but very interesting
example from glassfish 4.1 at the time
of screen grabbing it didn't start on
jdk nine because the vm through an
illegal access error I don't expect
you'll be able to read the the ring text
but it says illegal access error class
Khamsin enterprise security provide a
policy rapper in unnamed module don't
worry about that yet cannot access class
Sun security provider policy file in
module Java base the point is that the
class sons security provider policy file
is declared public but since it's a jdk
internal API it's now accessible only
within the Java base module sorry
glassfish you need to find an
alternative security API
in jdk nine modules are first class
program components like classes and
interfaces here's the declaration of the
java sequel module that contains JDBC
it's in a file called module info java
in a directory named after the module
javed or sequel the compiler treats this
like any other java file and translates
it to module in photo class which you
can put in a jar file as normal we would
call that a modular jar the package
hierarchy exists in the same directory
source java sequel as module info java
so module effort at java is outside of
all of the packages in the module that's
because it's the job of the module
declaration to say whether a package is
strongly encapsulated or not it's easy
to get strong encapsulation for the
types in your packages don't mention the
package in the module declaration to
allow other modules to access one of
your packages or more specifically the
public types of your package just add
and exports clause as I said you can
export to all other modules as is
happening here or you can say exports to
to give access to only your friend
modules at compile time Java Sea
prevents code outside the Java sequel
module from accessing the public types
of any packages in it except for those
three packages listed you get the same
compile time error as when you try to
access a package private type from
outside it's packaged in J decades and
then at runs if you somehow built the
class files by hand at runtime a runtime
the vm throws an illegal access error
like you saw with glassfish if you try
to access the public types of anything
except those three packages let's dive
into the vm more deeply traditionally
accessibility in the Java platform is
about who is doing the access and what
is the public protected private flag on
the target class at runtime the vm uses
the class loader of the accessing class
to find and load the target class
and then the vm checks the flag public
protected private of that target class
now because the vm relies on class
loaders people can create loaders that
only know how to find and load classes
of certain packages in effect loaders
can isolate one package from another in
the top picture class PC is trying to
access class QD the loader for PC knows
to delegate it just just bear with me it
knows to delegate to another loader for
any class in package Q such as QD only
when that other loader has found loaded
QD can the vm check its flags to
determine if it's public enough for POC
to access it now in the bottom picture
the loader for PC has no idea where to
find package Q so no access to QD is
possible from PC technically this isn't
a failure of accessibility since the vm
never actually gets to load never gets
to check the flags of QLD instead it's a
failure of visibility QD is invisible to
PC because the class loading couldn't
find QD still the effect is quite
powerful if the class loader of the
accessing class cannot find and
load the target class then it doesn't
matter if the target class is public
it's effectively encapsulated so whoever
sets up the class loaders sets up this
effective encapsulation the thing is
though that encapsulation based on class
loaders is not strong encapsulation
sadface it relies on packages being
carefully apportioned into different
loaders but that isn't how the JDK has
ever worked most code in the JDK is
loaded by the bootstrap or platform
class loaders while code on the
classpath all of it is loaded by the
application class loader spinning up
lots of loaders for all of this codes to
try and isolate it and to try
encapsulated would be a compatibility
nightmare and in any case there is no
actual isolation you can circumvent
class loaders by getting hold of
references to java.lang.class objects
which you can always do for any object
and then once you have a class object
the class loaders are irrelevant and
it's impossible to stop references to
class objects from being passed around
strong encapsulation is about being able
to prevent access even if the accessing
class and the target class are in the
same class loader such as the
application class loader and even if
someone is using core reflection to
manipulate class objects so let's assume
that multiple modules are somehow mapped
to the same class loader can clasp you
see in module X access QD in module y
another goal of the module system is
reliable dependencies to replace the
brittle error-prone classpath mechanism
with a means for program components to
declare explicit dependencies on one
another so in order for PC to access QD
not only does module y need to export
package q but module X needs to somehow
explicitly depend on module why the
formal name that depends on is
readability readability underpins
accessibility in the Java language and
vm in 9 the accessing class PC must be
in a module that reads the module of the
target class that is reads module why
and the module containing the target
class must export its package to at
least the module of the accessing class
so accessibility is a two-way street at
module X reads module y a module y
exports this interesting package q to at
least x
note with these arrows that
accessibility is independent of class
loaders I don't need to talk about the
class Otis on this slide just like
accessibility was before the module
system this is important for two reasons
it means accessibility works at compile
time when there aren't any class loaders
second it means you can reason about
accessibility based solely on the
requires and exports clauses in module
in photo Java files there's no need to
worry about which class loaders will
come into existence a runtime in fact
the exports part of accessibility is
fairly straightforward packages either
exported or it isn't but on readability
there's more to say when you depend on a
module you depend on a hopefully
coherent set of packages that are
exports that's its surface in some sense
those packages are the interface of the
module inside the module hundreds more
packages may sit strongly encapsulated
not exported not for you waiting to help
implement that interface and more than
that when you depend on a module um you
indirectly depend on all of the modules
it depends on for example if you depend
on the Java activation module in the JDK
with its 35 classes then you indirectly
depends on the Java desktop module in
the jdk with its 5835 classes if the
watchword for JDK 8 was functional then
for JD k9 the watchword is transitive
you should think in terms of the set of
modules needed transitively by your
application that is the indirect
dependences can be as important as the
direct dependencies let's see how
readability models this I'll use an
example of readability from the graph of
JDK modules the Java sequel module that
holds JDBC requires the Java login
module that exports the package
java.util logging
this requires Clause means that code in
the Java sequel module can access the
public types of Java util logging such
as logger you can see that some code in
the JDBC driver manager class on the
left is newing an instance of lager fine
what if it was the API of the Java
sequel module rather than its
implementation that wants to use the
logotype in other words locket is in a
method signature a public method
signature author of a public interface
in an exported package so what if that
API wants to refer to the logotype
rather than some method body so here the
JDBC driver interface wants to return a
logger let's look at this through the
eyes of an application module that uses
JDBC my app in order to use the dry it
to call that driver method that returns
a logger the my app module not only
needs to read the Java sequel module but
also the Java logging module which
exports logger it would be a pain if the
developer of my app had to remember to
say requires java logging when using a
particular part of the api of java
sequel sadface there's good news the
java sequel module can take on the
responsibility of remembering look at
the java sequel module it now says
requires transitive java dot logging the
word transitive here means that anyone
who reads the java sequel module also
reads the java logging module for free
the my app module no longer has to
bother with requires java logging
because it reads java logging thanks to
reading java sequel happy face this is
called implied readability and it's very
powerful it's powerful because it lets a
module be refactored without breaking
consumers for example suppose that Java
logging
has some auxiliary packages that we'd
like to start shipping in a separate
module log extras stuff in it some
exports the Java logging module can say
requires transitive Java requires
transitive log extras so that my app
which already implicitly reads Java
logging also implicitly reads log extras
my app would be unaware that this
refactoring down the stack is happening
it just says requires java sequel so in
essence this model of readability
supports downward decomposition any
module you read can be decomposed by its
author into new modules and readability
of the new modules can be recovered with
a requires transitive clause in the old
module so you can see that the the
definition of reads one module reading
another is recursive a module X reads
another module Y by requiring it
directly with a requires clause or by
reading some third module q there's the
recursion reading some third module q
where q says requires transitive why and
now that X reads why why can say
requires transitive for some other
module and X will read that too now be
careful once people require your module
explicitly you can refactor it downwards
as much as you like but you cannot
delete it there's no way for a module to
stand in for another module by taking
its name as an alias if someone requires
X and X is deleted then the module
system won't starts I said earlier that
the exports part of accessibility is
pretty straightforward the packages
either exported or it isn't but it's
actually a little more subtle than that
here are some of the exports of the
java-based module exporting a package
means that anyone can compile and run
against its public types and their
public elements
there are dozens more packages in Java
base that aren't exported no one can
compile against their public types even
if you make a class file by hand that
refers to a public type in a non
exported package it won't run this isn't
just compile time trickery the VMS doing
it as well but still that's all
accessibility in the Java language in
VMware the accessing class and the
target class are known static leads it's
in the source code of the bytecode what
about accessibility with reflection
where the target class is only known
dynamically we think it's very important
that exporting a package like Java
security yep there is for static access
to be programmed against does not mean
that anyone can reflect over the
internals of that package because if
they can they will here is a stack
overflow question from July 2016 someone
this is reven take a picture of URL
someone was using set accessible to
access a private field in the class Java
security key store the purpose of the
class Java security key store is and I
quote a storage facility for
cryptographic keys and certificates if
ever there was a class whose private
fields should be inaccessible it is this
one now the Java security package is
exported so you can code against the
public type key store in its public
fields and methods not so that you can
reflect over clicky stores internals
ring code I love the the first answer
how ofter updating I something's not
working how can I fix it you solve it by
not fiddling with private data members
of other classes first answer so just
exporting a package exports P does not
allow reflection to access the
non-public elements of the package the
non-public types or even the
the non pride that the non-public
elements in public types so I said again
if you obtain a class object for a non
public type in the package you can still
list its members but you cannot call
gets or sets on its
java.lang.reflect.method.invoke type
similarly if you somehow obtained maybe
someone passes it to you a Java Lang
reflect field object for a private field
in a public type you cannot call get or
set on it and even calling said
accessible won't help if the author of
the module really wants to allow access
to nonpublic elements via reflection
this can be expressed with exports
privates and that then allows reflection
to work as it did in jdk 8 private
members of public types can be accessed
and public members of non-public types
we don't officially call it weak
encapsulation but you can think of it
that way the bottom line is that strong
encapsulation is even stronger than the
powerful reflection capability is
traditionally offered by the Java
platform it's up to the module author to
choose strong encapsulation and if they
do via a plane exports as we do in Java
base there is no way for another module
to break in the module system API does
not allow one module to augment the
exports of another module reflectively a
module can only X can only augment its
own exports via the API so said
accessible behavior now depends on the
module authors choice of how a package
is exported
and of course for Java security public
types no problem public methods in those
public types no problem code against
them but private things inside you can't
touch them there is a question there are
lots of questions but I will take them
at the end thank you accessibility used
to be a simple check basically for
public or same package at compile time
and around time in jdk 9 accessibility
is the mechanism for strongly
encapsulated module internals
accessibility relies on readability
which can be direct or implied and
accessibility is enforced by the
compiler VM and reflection in line with
the module declarations part 2
everything so far has been about named
modules modules explicitly declared with
a name in module in photo java what
about jar files on the classpath that
don't have a module in photo class file
they seem to be in a world of their own
to keep the model of accessibility and
readability consistence we introduce the
unnamed module all classes not in named
modules are in the unnamed module it's
as if pay for it everything on the
classpath is in one big module and
because it's the module we can ask two
questions what does it read and what
does it exports what it reads is simple
every named module all of them as if by
magic for free this means anything
exported by a named module can be
accessed by code in the unnamed module
you can turn a jar file into a named
module by adding module info doc class
and putting the jar on the module path
when named modules are found
jars left on the classpath will not
realize that anything happens they can
still read those named modules that's a
huge help for migration the next
question is what the unnamed module
exports before that though we should ask
who reads the unnamed module remember
our goal in the module system is
reliable dependencies we believe very
strongly that named modules should not
read the unnamed module out of the box
it would make a mockery of reliable
dependencies to let named modules depend
on the arbitrary content of the
classpath so you cannot write requires
unnamed or requires classpath in module
info java there are no reads edges going
out to the unnamed module this seems
like a huge hindrance for migration
because any jar you turn into a named
module can't access the jars left on the
classpath the answer is automatic
modules you can take a jar say guava yah
and move it from the classpath to the
module path that turns the jar into an
automatic module that's all you have to
do an automatic module is a named module
declared implicitly rather than
explicitly its name is derived from its
jar file name in obvious ways placing
guava jar on the module path gives an
automatic module called guava as before
whenever you see a module you should ask
what does it read and what does it
exports the automatic module guava reads
everything in the JDK and the unnamed
module it's as if it says requires
unnamed now the hindrance to migration
is gone you can turn a jar into an
automatic module and it can still access
the jars left on the classpath we asked
earlier what the unnamed module exports
the answer is all its packages
in ju najar and glass fish jar and
hibernate jar precisely to help code in
automatic modules which read the unnamed
module and it's a it's a full power
export as well you can reflect back in
because an automatic module is a real
named module another named module can
require it suppose the my app module
says requires guava so there's a reads
edge then from my app to guava what does
an automatic module like guava exports
that's easy all of its packages
including for reflection so my app can
access all of the public guava types and
reflect over it no problem my app could
even say requires transitive guava to
transmit its dependency on guava up to
its own consumers so that anyone who
reads my app would read Wafaa for free
even though guava is an automatic module
so by moving a jar from the classpath to
the module path you get an automatic
module that lets you start building up
your own graph of modules it's not
necessary to wait for every jar on the
classpath to be modularized by its
author before you start developing your
own modules that require it so there are
three kinds of modules explicit named
modules like java sequel automatic named
modules like guava and the unnamed
module aka the classpath and the key
point is there is lots of readability
for free to help with migration and
since the readability underpins the
accessibility you then get a lot of
accessibility as you had on jelly aids
loaders and layers
I said before that strong encapsulation
is independent of class loaders this
means that the model of class loading in
jdk 9 the model of class loading in jdk
9 is unchanged the mechanism of loader
constraints for those of you who have
been reading the vm spec is unchanged
the notion of runtime packages is
unchanged the java.lang class loader api
is essentially unchanged class loading
doesn't change in jdk 9 in addition the
actual class loaders the actual objects
in jdk 9 are the same as in jdk aids
there is the bootstrap loader there is
the platform loader used to be called
the extension loader too confusing call
it the platform loader and then there is
the application loader which loads
everything on the classpath all on top
of the vm traditionally the vast
majority of JDK classes were defined by
the bootstrap loader critical JDK
modules such as Java base still have
their classes defined by the bootstrap
loader for non-critical JDK modules it
is important for security to move their
classes out of the bootstrap loader if
possible modules in the bootstrap loader
run with all permissions which is not
ideal from a security perspective those
modules can only be D privileged that is
run with fewer permissions if they're
not in the bootstrap loader so in jeddah
k9 all the modules containing Java EE
technologies such as Java goober have
been moved as well as the JDBC modules
Java sequel and Java sequel rosettes
their classes are now defined by the
platform loader frankly moving a module
as big as Java cawber 1831 classes and
31 exported packages is no small
accomplishment the D privileges were kid
self of specifying the fewer permissions
will continue for many years
the application loader is then
responsible for everything else a number
of JDK tool modules such as JDK compiler
have their classes defined by the app
loader all classes in modules on the
module path whether they're in a modular
jar or in an automatic module like guava
are defined by the application loader
and all classes on the classpath in
traditional jar files like jo nijar and
glass fish jar are defined as before by
the application loader a couple of notes
on compatibility first frameworks that
delegates directly to the bootstrap
loader to find JDK classes might break
on jdk nine because many jdk classes
aren't there anymore frameworks should
use the new class loader method get'
platform class loader which returns a
loader guaranteed to provide visibility
of exported JDK classes second the
application loader whilst there still is
one the object itself is no longer an
instance of URL class loader frameworks
that assume it is in order to hack via
so accessible into its add URL method
sadface will break on jdk nine the only
supported way to dynamically extend the
class path is with the class path
attribute in jar files or with the agent
API and java.lang instruments now you
may be wondering where the module system
itself lives in all of this it's
important to realize where the module
system isn't traditionally a module
system was simply Java code that acted
as a factory for class loaders it
created loaders that defined classes
found in some modular artifacts and then
those load is delegated to each other in
accordance with some kind of modular
imports and exports as I mentioned
before there is then some encapsulate
for classes because those loaders a B
and C can hide classes they can isolate
classes from each other a module system
that does this will still work on jdk
nine because class loading hasn't
changed but the module system in jdk
nine is quite different the module
system in jdk nine is not a factory for
class loaders but rather a conduit a
transmission mechanism that allows
modules to be communicated to the vm
whoever creates the class loaders is
responsible for using the module system
API to transmit module names contents
dependencies and exports to the vm
that's how the vm knows enough to
enforce accessibility it's also how the
core reflection API can enforce
accessibility since core reflection is
based on vm provided class objects you
can think of the java launcher as
creating three loaders and doing the
transmission down to the vm for modules
on the module path you can see why we
wanted the module system to be
disinterested in class loaders the JDK
has been factored into dozens of modules
but it's class loading architecture the
shape of the class learning architecture
hasn't changed encapsulation is provided
by trouve e.m level accessibility not by
class loader based visibility so the
module system doesn't need to mandates
one loader per module it can handle
multiple modules per loader just fine
that's what the picture shows you'll
recall that I talked earlier about the
unnamed module as a vehicle for
compatibility strictly speaking I was
referring to the unnamed module of the
application loader in fact every class
every class loader has an unnamed module
if the vm sees a class being defined by
a loader and the vm
associate that class with a named module
that was transmitted down earlier then
the vm treats the class as being in the
loaders unnamed module as you might
guess the vm always allows access to
public classes in an unnamed module this
means this all means that every class
every class is a member of a module even
classes in the jar files on the
classpath j unit jar and glassfish top
jar are members of a module that it's
actually the it's meant to be the
seventh box in the vm on the right and
if you have a class object the get
module method will always return a
sensible module object the module system
introduces the concept of a layer to
associate class loaders with modules a
layer is a family of class loaders that
together serve to load classes for a
graph of modules logically the java
launcher defines the boot layer
consisting of the three familiar loaders
it's the boot layer that associates the
java base and java logging modules with
the bootstrap loader the java sequel and
java korba modules with the platform
loader and so on so a layer is created
from two things graph of modules and a
function that maps modules two loaders
on the left is the graph from resolving
the JDK j-link module which contains the
jailing tool for building runtime jeddak
8 images just an example of a module
graph on the right is a lambda
expression mapping some of the modules
in that graph to the bootstrap loader
and the application loader creating a
layer informs the module system about
the packages that will exist in the
program and the modules they'll come
from this is a great slide to take a
picture of hint hint
the module system passes this
information to the vm so that when
classes are eventually loaded and
defined the vm knows which module a
class belongs to and what that module
reads and exports it's like the vm has a
shadow copy of the module graph that it
uses when checking accessibility between
classes now because of how class loading
works the module system must enforce
certain constraints on a layers module
graph and on a layers mapping from
modules to loaders let's talk about the
graph first last chance to take a
picture and slide at the back very good
Oh bit more or more okay this is the
graph of modules in jeddah k9 what do
you notice about it it's a dag exactly
the same arts that came from over there
last year I remember so such a precise
answer okay it's a directed directed is
a directed acyclic graph no cycles this
is the first and biggest constraint on a
module graph it's taken almost a decade
to detangle the tens of thousands of
classes in the JDK to the acyclic and
relatively sane state that you see here
we'd like to keep it that way in fact
one of the motivations for investing in
modularization of a code base is the
knowledge that once completes there
won't be any backsliding into the ball
of mudd's the cyclic dependencies allow
we're not the only ones who think like
this java application architecture is an
outstanding book about modularity in a
section titled cyclic dependences the
death knell it says excessive dependence
is about but cyclic dependencies are
especially bad
it goes on to say generally speaking
cycles are always bad however some
cycles are worse than others cycles
among classes are tolerable assuming
they don't cause cycles among the
packages or modules containing them
cycles among packages may also be
tolerable tolerable assuming they don't
cause cycles among the modules
containing them module relationships
must never be cyclic this book is from
years ago nothing to do with the Java
module system but this is good advice
let's turn to another constraint on
module graphs the second constraint on
the module graph that's going to be the
foundation of the layer is that a module
must read only one module that exports a
package of a given name if a module
could read more than one module that
exports p as x is trying to do here in
which module would P be accessed there's
no answer the module graph is just
broken so we defend against that only
module graphs which obey this
constraints and have no cycles can be
turned into a layer that's really what
we mean by reliable dependencies
dependencies are reliable when a module
can access only one version of a package
at a time there are no split packages
like you get when multiple jars on the
classpath contain potentially different
versions of the same package now you
might be wondering if it's possible for
X to read version 1 of Y while at the
same time another module reads version 2
of why after all X and the other module
would each read only one module
exporting p the answer is that it's not
possible because it can only work safely
in certain scenarios and outside those
scenarios it's not clear that supporting
it out of the box which is to say in the
Java launch
the one that creates the class loaders
it's not clear that supporting it out
the box is worthwhile but you can all
ask for questions about that in ten
minutes time recall that a layer
includes a module graph for which we saw
two constraints and a mapping from
modules two loaders the main constraint
on the mapping is that if different
modules in the graph have a class called
C then those modules must be mapped to
different loaders this is the
fundamental limit in class loading a
class loader can only create one class
called see more conservatively we say
that if different modules have the same
package not just class then those
modules must be mapped to different
loaders of the layer the mapping from
modules two loaders has another
constraint that's not practical to check
though because it concerns how load is
behavior on time it's that the loaders
must delegate to each other in
accordance with the reads edges of the
module graph the reason is obvious if
module X reads module y then in order
for X's classes in one loader to access
wise classes in another loader X's
loader must delegate to wise loader just
just to find the classes even before you
can start worrying about access as their
name suggests layers can be layered when
a graph of modules is resolved it's
actually resolved against a parent layer
then when the graph helps to create a
new layer the new layer picks up the
parent layer this allows a graph of
modules to have dangling references that
is requires clauses for modules that the
module system will find in a parent
layer during resolution on the Left
resolution has set up not only a reads
edge between mott between modules in one
layer the horizontal one but also a
reads edge between modules in different
layers constructing a tree of layers in
this fashion is the job of a
framework like an app server or a test
harness layers give frameworks
tremendous freedom to organize modules
at runtime without upsetting the
frameworks traditional use of class
loaders it's like the invoke dynamic
instruction from jdk 7 away for
framework developers to interact with
the vm to reify information about the
shape of a program let's look at one
scenario where layers help out layers
are how the module system supports
multiple versions of the module here an
app server has created two layers on top
of the boot layer on the left the Hadoop
player reifies a module graph with guava
version 11 and jackson version 1 and on
the right the JavaScript layer reifies a
module graph with guava version 18 and
jackson version 2 each module graph is
well-formed and mapped to loaders in a
sensible way but the modules in the
Hadoop layer are not aware of the
modules in the JavaScript layer and vice
versa but please note this is all thanks
to a framework creating the Hadoop and
JavaScript layers the java launcher
doesn't create layers like this all it
does is resolve the module you give on
the command line then map everything in
the resulting module graph to the
application loader in the boot layer it
supports only one version of each module
the reason is to avoid the nightmarish
problems that occur when multiple
versions of a module or indeed any jar
casually come into contact with each
other it's really only safe to use
multiple versions of the module when a
framework like an app server is in
control the takeaway is this just as
modules wrap up coherent sets of
packages and interact with the VMS
accessibility mechanism layers wrap up
coherent sets of modules and interact
with the class loader visibility
mechanism it'll be up to frameworks to
use of layers in the next 20 years just
as they made use of class loaders in
javas first 20 years I urge any
framework developers watching to open up
the JDK 9 Javadoc and look at java.lang
module configuration and
java.lang.reflect.method.invoke then
control the relationship between modules
a graph of modules and the class loaders
and assuming class loaders respect the
module graph that is they delegate
sensibly the system is safe by
construction there are no cycles or
split packages zooming all the way out
here are the three key points there is
strong encapsulation of modules by the
compiler vm and core reflection there
are unnamed and automatic modules to
help with migration and the whole system
is safe by construction no cycles or
split packages in essence the module
system is a seat belt not a jetpack if
this reminds you of the rationale for
generics 15 years of more than 15 years
ago your rights writing a module
declaration makes your code more
reliable and maintainable much like
writing a list of string rather than
lists you always knew that your list
held strings and generics let you to
know that you always knew that a package
was not for general use and modules let
you to know that it's no coincidence
that designing a practical module system
and modular rising the JDK has taken
approximately as long as designing the
pragmatic generic type system and genera
fiying the JDK there's still a long road
head although the module system is
conceptually simple there are changes in
jdk 9 that probably won't break music
but might break framework code and I'd
like to go through them quickly there
are three areas of incompatibility in
jdk nine connected with the official
definition of java SE first we've
removed six methods from the packages
java.util logging and Java util jar
their signatures made the Java base
module depend on the Java desktop module
and no one wants that this removal was
announced in the umbrella jsr se8 in
2014 in addition we've removed to a WT
packages that were never supported on
the right there despite being in the
Java namespace very sad face second the
Java EE types shipped with the JDK are
not accessible by default this means
korba Jack's be jax-ws the Java
activation framework and the JD kaise
subsets of the Java transaction API and
the common annotations API the types are
physically in the JDK image but their
modules are not read by the unnamed
module of the app loader if you're
writing a module no problem just require
java koerber or Java XML bind or
whatever but if you're running code from
the classpath you need a command-line
flag to activate the EE modules third
the version strings reported by the
system properties Java specification
version Java VM version Java VM
specification version etc have changed
code that looks for one dots at the
beginning of the string will fail on jdk
nine because the version strings begin
with nine there are then three areas of
incompatibility within the jdk nine
implementation first we've slimmed down
the Sun misc package some miss gun safe
is still accessible but some misc base64
encoder and some misc base64 decoder are
gone
one thing you can do today is run the
Jade EPS tool that came with jdk 8 over
all of your jars it'll tell you if
they're using unofficial classes like
some misc bake 64 encoder and then
recommend official replacements like the
java.util base64 class introduced in jdk
8 seconds many jdk internal api's are
not exported code that tries to access
even public types in the sun net www
package or sun security x509 or Khamsin
ork apache xerxes internal jacks p I
could go on will fail with an illegal
access error the only way to regain
access is with a command-line flag third
many internal aspects of the JDK have
been overhauled such as the layout on
disk and the implementation of the three
class loaders code that assumes there's
a file called RT jar or tools jar in a
particular directory will fail on JD k9
scripts that try to patch the JDK with
minus X boot class pass / p for pre pens
will fail on jdk nine and as i mentioned
before code that assumes the application
loader is instance of URL class loader
or that assumes all jdk classes are
defined by the bootstrap loader will
fail on JD k9 the module system itself
tries hard to support migration but it
takes only one unmaintained library to
prevent migration to jdk 9 if that
library can't migrate because it's using
something in comms on all / patches axes
internal checks p then nothing on top of
it can migrate to being a module either
in this regard modules are unusual they
suffer from a tragedy of the Commons
whereas most big features like generics
or lambdas let people opt-in at their
own pace without needing to wait for
others last slide as i said the single
best thing you can do to prepare for
jetty canine is fire up JDK 8 and run
the Jade EPS tool which analyzes
dependences it can tell you if your co
or code that you rely on will be
affected by the changes in 9 please try
the JDK 9 early access binaries on
java.net the module system has been
present and active doing the
encapsulation for the JDK modules since
March twenty sixteen plus the J depth
tool in jdk nine is more accurate than
the one in jdk 8 everything you ever
wanted to know about the module system
including much of what I've said here is
discussed in JEP 261 I cannot emphasize
enough how much valuable information is
inject 261 there's also JEP 260 which
defines those JDK internal classes to be
exposed in jdk nine and JEP 223 which
defines the new version strings
beginning nine dots and JEP 220 which
describes how are ter has gone away and
finally JEP 200 gives an overview of the
JDK modules but if you've already read
JEP 261 there won't be any surprises in
200 and with that at fifty-six minutes
thank you very much
and we will take questions I think we've
got become to 15 minutes someone has
been charging their iphone no wonder it
went so slowly everything was so if you
have question please come up to the
front we cannot hear you if you stand
where you are I promise we're not making
it up we can't hear you so if you have a
question please come and use this mic
here is it a different question than the
ones you've asked before yeah it's
different so one thing that I've always
found odd in tomcat they try to prevent
classloader d-league's by knowing out
all static fields when you unload a web
app I'm assuming that won't work anymore
it will work if they do the right thing
how do they make that happen because
they're loading the classes the Tomcat
if if the web app is itself a module but
all of its classes are loaded by tom cat
tom cat is a deity it can rewrite module
declarations on the way in it can choose
to export to just to itself by the way
or to one of its modules any packages it
needs to reflect over although whether
it actually needs to do what you've just
said sounds like an optimization that
you may not need on its mike on yeah
there's also a specific list of issues
in quotes that Tomcat has with the JDK
and where it's gone into the JDK and all
doubt fields and things like that many
of those issues have actually already
been addressed and in fact over the last
couple of bills there are some specific
fixes in the JDK specifically for these
type of issues that Tomcat and ran into
thank you that actually the maintainer
zuv Tomcat I think Mark Thomas in
particular has been proactive in
actually finding these issues and
sending bug reports
the person who had a question there is
left so that was a successful strategy
yes what is going to be the fate of
shaded jars and uber jars where's Robert
oh it's right behind you a question for
me them I don't know ask the maven the
committer say someone it's not only a
maid problem it's about sharing it about
correct creating the uber jar and there
you have all the classes just inside one
jar so you have lost your encapsulation
so I know that mark has one thing about
that only his issue list so which is to
wait for an answer a life or a proposal
for it
ha no more questions ah ok please Wow
we've really raised the barrier to entry
is very high so no one has questions
anymore can you give an example i canna
site you have here what would manage
like the this Hadoop layer this
JavaScript layer Tomcats I mean it it's
hard to get across how disinterested we
are in class loaders if you're a
framework that spinning loaders today it
all still works v you can even know you
can even load classes from modular jar
files if you're if you're all the
framework and you're ignoring the module
in photo class file ok that's your
lookout but if you want to respect the
modular dependencies and encapsulation
that the web app code itself write it up
to the container to not ignore module in
federal class files to load them and
when you load them the whole point is
that a module says not only would
exports board it depends on and
hopefully tom cat will be able to call
the module system API to resolve those
dependencies and spin up a small layer
with exactly the same class though does
it had before but with the classes of
that loader now known to be members of a
module the module to load a mapping told
to this new layer so the the graph of
class odors will look the same at
runtime if you could visualize it so
someone else a part of us is do you
export resources then to or do they
follow the same rules yes there are some
rules about which resources you the
exports keyword is for pentax package
names this is a good question it doesn't
you don't specify resources like that
but they are mostly ex the useful
resources are exported for reflective
access which is how you get to them
right yes so Julie in like a you know
sometimes you put resources in a like
the same names places your package
others
I don't just kind of like invention so
does everything now need to be in a Java
package I know oh no no you can still
have your resources in Metron and what's
the rule for whether they're exported an
arts if there if there are namespace of
maps to the package then there has to be
exported if you've been in top-level
packages that are certain that are in
top-level directories aren't really
packages like meta-inf is not a valid
package name then they've just continue
to be be able to locate and access them
as as you always did all right just
under two exceptional yes there's in the
updated proposal there is a specific
exception for doc class files because
there's many many to you toons need to
access class files so they just worked
can I just say one thing just about the
layers on your first first party a
question is it doesn't actually require
a sophisticated app server to use layers
is actually many tools might even may
actually use layers as well so for
example the Java C compiler loads
annotation processors that are deployed
as modules in their own layer the
jailing tool can has it has a plug-in
interface you can actually deploy and
plugins as modules and and they will
actually be loaded into their own layer
yeah thats its parented to the boot lair
so there's many many tools okay we're
all done</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>