<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Device I/O API in a Nutshell | Coder Coacher - Coaching Coders</title><meta content="Device I/O API in a Nutshell - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Device I/O API in a Nutshell</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fDOl_E-SOOA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let me try use myself i am sure Gina's
Arkin from java me and by the team and
I'm a technical leader for a device I
reputation for this platform this
session about device io implementation
it's I did we will speak about these
details but maybe before we start let me
check how many of you guys takecare take
a look at Java me sdk before or maybe
programming and embedded platform oh so
what am I i see that familiar faces with
already visited some embedded sessions
I'm just remember we want to remember
that we just release it a couple days
ago binaries for cave 764 platform which
devices country limited memory it's
about 300 bites kilobytes and of course
you can try also rather beep i release
let's be supported for about one month
and this allows you to try not only
writing code for is the key but also
running kitten or real devices but let
me start with bit of a history device I
all framework was really is a few years
ago and his form its initial name or
device access API it receives the major
update during eve motion in 8 release it
receives the support of Java your
backers let's allows us significantly
improve its framework robustness and
reduce complicity of
audiences and drivers parte 1 and in
this year's its join it open GD key
project and in the open G geeky now you
can find the common part let's share it
between Java me in Java easy and linux
implementation of device I on that
should be working the ocean on every
line Atlantic platform that's running
con em processors in usually a device I
of frameworks was support was supported
tone supported only a limited number of
devices like what the most demanded
devices like gpio in tight integration
circuit bus and SPI bus and then it's
it's evolution mostly driven by our
customer and for them we added the
number of devices like 80 comments pulse
counterparties month later and memory
muppet input/output devices and not so
many of them but we are continually
looking forward to add new peripheral
streets is required by market or by our
community why this session was created
and because well device I oh it's just a
thin layer between the Java applications
and native dryers where it possible and
it's differently not rocking rocket
science it's just make some kool
transition from the java application to
make a dryer and you can imagine that
nothing to speak about it but every
bleep implementation of the driver
forever
for platform that we make a port of java
ee for as a some specifics what we have
to speak about in this session one of
the specifics thats maybe not
interesting for big java java see that p
rates on gigabytes of ram but a job in
eve was specially designed for memory
constrained device and interesting point
is that such devices usually has no in a
memory management unit and every
platform integrator has to deal with a
problem then where they should decide
how much memory they give for java
application and how much memory daily
for interior action is peripheral and in
most cases it appears that the most of
the memory is given for java and only
maybe 10 or 20 kilobytes if you speaking
about devices with a few hundred
kilobytes of memory is left for the
native operation and this results in
very in very interesting situation let's
pick let's take a look at very simple
example it's a just open SPI bus device
and try to send some data and receive
some data from it from initial point of
view there is nothing to speak about and
to worry about for application developer
but if you try to run it on for example
k 74 64 device boom we got out of memory
exception what's the problem is is that
even if you can control a creation of
the buffer to send and receive in you
even if you don't receive
bring out of memory exception the worst
case is that you will receive inside
this function why so again because its
memory constrained device by this code
you create a buffer inside the Java hip
but you remember the drivers required
native memory and our framework will try
to convert these buffers into the native
in stone age I put two to provide it to
the driver and of course on them
situational field is a limited number of
native memory you will get out of memory
exception here okay if you eat just if
we aware and try to run of memory
management and try to run 2 2 2 minus
negative operation with nature drivers
by our hands and try to create allocated
by the direct backers let's introduce it
in a trees even if you pass this part of
code we can get here problem why I
specially selected SPI device because
it's protocol allows to send and to
receive data simultaneously in
synchronous manner and that causes a
problem that we call other lapid buffer
you see that you need for for for this
protocol you need a data to be
constantly shifted to provide it to the
batter to make its clock source to run
and kicking and to to make the data to
be read from the in from the device but
if application developer provide not an
advocate for to fit as a whole
transaction there is no boyfriend no
nothing to send specification does not
speak about this situation and
implementation may may decide to
allocate a new
is a big affair just to fit to satisfy
that goes the clock generator and of
course we can get this in this situation
we can get out of memory exception again
what why this situation is so bad
because application developer may not be
aware because he feels like death may
think that if for the battles
reallocated and resides on the native
memory nothing can happen but it's
embedded wart and you have to wear about
you have not to be aware about your
application logic but also about how
your application will interact with
device as I say replication me because
it's not contradict replica
specification allocate new new buffer to
fit as a packet to write and to extend
it to to make the clock generator works
Indian ticking but not our Java nib and
implementation we decided to make it
more smarter we use a new interface
let's call it transactional to separate
adata what we are going to shift into
into the device in in a manner that the
clock will be always ticking and we use
we use the battle is already available
for example here we can separate the
single transaction into the serious one
for example we can separate the first
part could be just writing a number of
bytes the second part would be right in
Canary link and the third part would be
only reading and the field part we can
use the same backer for the writing to
make the clock generator reading is it
it's done already inside the framework
so the
java me handle this overlapping buffer
wisely situation wisely yet the
transaction is not at ideal tool for
this one because where is the platform
where the transaction implemented in
very strange Manor for example if you
get if you run this code on the
Raspberry Pi devices or on blue platform
as far as remember you can get as a
strange results for example if you try
to reach the back you can get a number
of read byte equals two lanes and the
backer would be absolutely empty you
have no you will not get any data inside
this buffer even more if you try to make
a dozen or hundreds of native apparation
inside the single transaction you can
get out of memory exception why so
because the transaction interface is not
optional as far as i understand it's
speak leet is going to introduce update
for the specification in the next
release where it would be optional but
right now giovanni for pi should support
this interface for every hpi devices but
the driver on the on the linux platform
does not support runtime or real-time
data exchange inside the single
transaction this means that the data
actually shifted to the device when only
transactional and function is called but
and before these everybody that you
prepare it for for the native operation
actually it's it's pointer and size
store it inside native memory and this
qui that's where this pointer they store
it come
Suns a native memory and if platform is
memory constrained you can get a problem
of memory depletion native memory
depletion and out of memory which may
cause your application is shut down be
shut down because if application is not
aware out of memory exception so what is
the best solution and what is the best
practice for application developer to to
Gil to work with device io on different
on the embedded war first of all put
everything in in your control memory
management its users of transaction
everything should everything should be
taken care by application developer for
example use direct buffers only because
drivers are supposed to be used only the
native member that is not affected by
garbage collector for particular devices
use transactional interfaces just to
avoid memory allocations to reduce
buffer allegations and for every
platform you are I nakhon try to read
manual try to read how particular
devices implemented on these devices per
particle prefer editor peripherals
drivers implemented on this device again
like on Raspberry Pi you can get
situation where transaction is not very
useful for because it's delays and Nate
evaporation until end of effort and end
of transactions
the next topic is about a performance
performance again the Java me is a
design for lightweight devices and
usually driving me runs on bare metal
devices various aware where there's no
absolutely underlying operating system
so its design it in a way that it uses a
single the single thread for the wall is
need and of course its support trading
see there are different threads running
in in parallel but it's used own
scheduler and only one javathread can be
executed at once how does it affect us
this means that our old native goals
should be returned it immediately I will
show you later how how does it really
implement it and because the native call
should be returned it immediately you
cannot receive from this call a result
of the operation and to check this
result java ee pulls every amount of
number number of milliseconds for a
result of native operation i put here
the default period 1 10 milliseconds
it's actually not not right not every 10
milliseconds a peephole happens the
scheduler the scheduler when it's
performed context teaching of trade
system forth between between threads its
checks for the pole so this time could
be less than 10 milliseconds or even
more it could be more than millisecond
because garbage collection can camp its
own job but it's not
it's not cover it in our topic but
everything by the developer who works is
a java should be aware about garbage
collector in their programs so it's just
a diagram what happens we have a single
negative thread in speciation speaking
some bare metal bare metal system it
suggests a cycle as single single CPU
cycle that executes for inside the vm
meat and you see that that the trade may
start I owe this IO would be utilized a
three separate rate if with an
underlying platform supported or just
maybe set up a DMA transfer for if its
support next scheduled reveal calls as
the next the threat that's available and
start very quickly pull for applicator
for I or operation result and if it's
done the thread that will initiate the
separation you'll be a schedule it to
run as you can see where is the gap
between apparition and the Federation
and when as the thread start to run
again so how does it affect us as a
device our implementer and for and what
how does it affect applications
developer who utilize the device I own
first of all it's absolutely impossible
it is wrong words not absolutely and in
most cases it's impossible to reach the
maximum throughput designer by cpu
manufacture for corresponding
peripherals let's why some sensitive
error for protocols or peripherals may
be may function
incorrectly for example if you try to
implement more buzzer to you on top of
you art garbage collector may prevent
you from dealing with the small amounts
that is required for this protocol and
of course a PWM basic motor control
devices they shouldn't be implemented
and may not be implemented by device
Iranian this Java me quick with Evans
the for example gpo interruption they
may be lost and of course and by the
developer should be aware application
design and even more the platform
integrator should gear about this
problem of problem of garbage collector
and specific of Java me trading system
so what is the best practice for
application developer to use device oh
and achieve the maximum throughput for
is for its application well the best
situation is would be to run
applications let's use only single
thread and pre-allocate all resources
it's its startup to prevent garbage
collector to happen this allows the
scheduler to wait in coming in all
incoming Kevin's for that for
asynchronous nature Federation and the
seventh would be proper processed by
application virtually immediately or the
last the last I personally don't like
this Nessus it would be used to double
buffering well let's just example what
is a single threaded applications let's
means that when applicable
threadstarter synchronous operations the
schedule will put a wall vm to sleep and
wait in chi minh calvin and this when
the seventh happens the trade will be on
locating to continue to run the gap
between end of operation in start of the
nature threat actually already depended
well it's it's it's any new i can say
the real value value because it's
dependent the platform but it's in this
case it's really meaning and double by
frank its feature introduced it in 8
release it's a feature that allows you
to use a couple of buffers for a single
operation for example when applications
start a native operations it's provided
two buffers when the first buffer is a
field at orix hold the even tis going to
back to the applications and while the
second batter is in front of the native
of course in this case see to the
second buffers and while the second bar
first is in process application has a
time to fill the new background process
or process that data from the second
batter from the field matter of course
for these keys to make the gap between
even in the time when tread start to
work again it's a it's better to full
best practice guide and not to use some
some second thread that may prevent even
be purchased by scheduled to start in
you to start to start the trip to to
practice incoming current ok
we have completed the memory management
and performance the fourth case that is
not describe it well of course in the
specifications is configuration if some
of our or some of you who read the
device I specification know they may
know that we support to type of device
topologies one of the static list such
devices open with number 8 IE or names
sting that's presented a string and open
to pelagic the static list is is a well
it static list let's maintain it by
platform integrator it's usually support
contains the number list and
configuration for peripherals that is
going here to be safe to use and present
on the platform that the platform
integrator it provides for for use in
opposite the open topology is a way
where application and we're about which
devices they may access to of course as
the devices maybe they they may be
absence on initial version of the
platform and later be headed by device
user through the hpi or I squares he or
you are and such such such devices are
accessible through device config
instance class because the open topology
um is quite good described it in the
speaker sophistication I will not stop
on this but i will take a touch only a
static list because it's not it's not in
specification and its implementation
cific in Java platform we are storing
configuration inside device API config
file that's a JSON formatted it's farm
at you it's contains may contains two
big parts as configuration itself and
default values the mandatory part is
only configurations it's a consist of a
number of subsections each subsection
start is the device idea that is reused
this device manager with device type
actually it's optional device name and
then number of parameters that are
required to open to discover and to
configure and necessary devices and to
simplify life of platform and integrator
where we provide a default sections
where for particular devices you can
provide set up a default value for
parameters that's required for
application for example in this example
there is no Direction parameter and it
would be taken by device manager from
default section as well as mode but the
trigger trigger is present here so this
is a it would be taken from main
configuration what's necessary to know
creating this static list implementation
does not check device IG this means that
the creator of the static is just has to
be aware about it see every device that
you should be unique device type format
is actually the shortening name
offer device type taken from the
specification for example where GPIO pin
dot jpg protein is a judge short'nin
name of specifications GDK you geppu p
in japan open let's mean that we thought
to part with just a meter to just to
make the names shorten and the mandatory
parameters should be named exactly as
it's named in corresponding device
configuration I mean that a trigger
device number pin number why so because
Java we need doesn't have serialization
and for every device type that we
support were created a special factory
let's take years that reads this
configuration parse it and fountain
necessary parameters and provide it to
device manager this Factory has a spoof
has a specific name created from device
type add these special prefix and suffix
and just as example of invalid device
configuration as I say that parameters
should be absolutely should have the
name should have the name of solute as
its described in these specifications
that mean for example pin number the
first p should be the small small small
p that trigger for example the the
trigger by specification can be can have
a default value minus one is by spec is
chris pointing to default value and
added some strings with name is a
diamond
to reduce memory consumption it's
recommended to avoid to put some
unnecessary data like a commentary or
may be unnecessary parameters inside a
configuration white because the wall
list is parted by very simple
configuration but the data historic
inside the hash table and this those
hash table could be large enough if you
put some unnecessary data so about
watchdog why look is very interesting
species it's and it's required for
controlling application workflow but on
the platform it used to be only single
instance of the watchdog specification
speaks about the virtual nature of
whitewash doc in the device our
specification but it's allows a
different different way how's this the
virtuality goes to wedge dog in Java ME
embedded implementation we decided to
use a separate isolate if you if you
know what is the isolating the COTC
virtual machine it's a it separate
instance where application can run
isolated from other applications they
absolutely can cannot share a data and
we decided to use a separate such as off
such as a late for the web native wedged
up manager and every wedge watchdog
that's created for application they just
a client for the physical watchdogs
manager and when application opens a
watchdog with the same AG the instances
would be shredded inside the same
application but every application has
the different instances for which dog is
the same age AG it's not it's not
covered inside the specification so why
I put attention on this because we some
we get a response from our creating who
doesn't understand this conception and
as well as myself online courses
somewhere was a question about how wise
dope wars and does application which dog
a watchdog is a part of the platform
let's control it as I say control it
application workflow that's means that
way an application setup was up for some
period of time it's say it's say that I
guarantee that I will ping you watch dog
in 10 milliseconds if I doesn't if I
then restart the wall platform so it's
it's it's required for controlling a
situation with the dedlock's if some
outstanding native operation blocks the
wall vm and something happens is a
memory or I don't know is a very fair
else in this case if pings is not going
up if I have a big physical wedged up
manager that doesn't get in from
applications it's just restart the wall
bore through the VC physical version
because we have no access usually the
application doesn't provide access to
direct way how to force application have
to force a bore bore to reboot a Tory
boot except by
wedged oh and the hidden physical wedge
of manager in separate oscillate also
gives us the ability to restart if
something happens of course is a wedge
dock manager itself if even if
applications running crack correctly if
something happens with manager the wall
plate phone it would be rebooted
actually that's all about divisive
implementation on Java me I especially
put put attention that its specific of
device I want imitation Java me if even
if we put some cotton in gtk now it's a
child of java ee inspired by drawing me
it's a feature goals from Java EE
specifics of course openjdk would be
view contingencies evolution as a
separate project and maybe we put
additional efforts to utilize a feature
of Java Sea like separate negative trade
pair Java trade but right now it's a
it's a child of Java me its design
especially to take care about memory
constraining device and design
especially to take care about Java ME
embedded trading systems if you take
away few goals too if you go to open the
Dickey project it's quite easy to find
it in main project and download source
code you will see that for example every
important Claire functions consists of
22 funds taught two parts one name is a
start suffix and not one name it with
the finish suucks is designed especially
to handle a requirement of single
threaded virtual machine
yeah questions I'm not from actually
cotc I know that I speaking about we
actually to generation garbage collector
it's where is a young generation for
objects that's quickly created and
disappear it in short time and where is
a long term and section where store it
object that could be handed which should
be alive for a long time of period no no
no no opposite to java sea with his
perfect garbage collector java me
garbage collector walks in the same
trade so when it's worth the wall wart
stops nothing happens so that's why i'm
aware about the gap between end of
operation and beginning and coasted
violent partition because because not
only because of another trade is running
but because the garbage collector may
happen since this time and may takes a
really long time we have we was once we
was asking by our customers why they get
a very long response i I don't remember
what what was the details the customers
ask us why the application so slow is
uart operations it appears that they
created a number of small objects that
fuels hips up her hips with a number of
hundreds of thousands of objects and of
course
the garbage collecting garbage
collection happens very frequently and
the the gap between and the trade not
such as applications a response for the
events start became very very slow and
the truth put for the you are reduced in
compression is for example Java
implementation or native applications
for the same platform when I speak of
course it's actually tunable on on by
application platform integrator it's
just default well to 10 milliseconds but
this time is achievable only when where
is pure java trevett separates you know
is no operation is negative traits as
means that you if you have two trades is
a similar oh yes yes and as i said very
build the skill already sees them in not
every 10 milliseconds yes it's a
corporate cooperative just practice yes
yes sure
okay that's all I also recommend you to
visit sessions it's not mine sessions
regarding let strangers not in this
slide sure every speaker should submit
its presentation or Java one in Java one
website Oh as far as in the still
tomorrow will be session about how to
create applications is a device I owe to
be handled by us owner of openjdk device
I oh yes gender EG and as for understand
tomorrow maybe or when thursday it will
be another session about how to port
open GD key implementation to a
different platform so i recommend you to
visit it may be very interesting for
because the java when we are going when
we open source it in some way device I
oh we open our implementation the java
implementation as well that was close
and now we waiting for response from
community about what we can what we can
how can we how can we improve our
implementation because if something
going to be added to open GDK if it's
very available if we get its it you're
going to bed it to java me implement
as well so thank you for attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>