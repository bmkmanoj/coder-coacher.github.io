<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Prepare for JDK 9 | Coder Coacher - Coaching Coders</title><meta content="Prepare for JDK 9 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Prepare for JDK 9</b></h2><h5 class="post__date">2016-09-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eU8hCCjGSbE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon I'm my name is Alan
Bateman I'm giving a talk called
prepared for JDK 9 if you're looking in
the content cut and catalog you may have
seen it it's actually Alex Buckley
supposed to be speaking that was just a
bit of the mix-up with the names so one
my left here is actually Alex Buckley
and beyond him is mark Reinhold they may
help with some questions at the end so
before we get into this presentation I
just want to say that this is not a
presentation about all the cool features
and the big long list of jets that Mark
showed in the keynote this is not about
all the new things in JDK 9 this is
instead a talk that's focused on the
implications of the changes in JDK 9
particularly around the the strong
capsulation of the the JDK internal
api's which a lot of applications and
libraries have been making use of over
the years there are a couple of small
features in JDK 9 that I want that help
with the migration and help with
interrupts between JDK 8 and 9 that it
will spend a few minutes on towards the
end of the presentation but for the most
part this is about the implications of
JDK 9 so before I start I guess I would
be interested to have some idea from
this audience as to how many people in
this audience are tracking the features
and the changes that are going into JDK
9 okay so there's a couple people and
I'm curious first your hands as to those
that have actually downloaded the JDK 9
early access bills to try things out
similar number of hands okay here's the
strange question who has concerns that
there are changes in JDK 9 that might
break their existing code or the
existing applications a couple of hands
okay that's that's that that's fine that
this is what this presentation is about
one thing before I get into this is I
should explain is JDK 9 is still a
development it's not going to ship until
or plan to be shipped in 2017 there's a
lot of things that are still changing in
it there's nothing that is final yet so
when I'm talking about and some of the
changes
maybe that'll be where it is when it
finally ships maybe there'll be some
differences so just bear in mind that
it's not final yet first thing just to
get into this present into this
presentation just says it's the first of
five presentations that Alex and I are
doing at JavaOne this year and the rest
of our talks after this one are very
much focused on the modularity and the
all the features around around modules
in the JDK we're repeating four of these
and I'll have a slide at the end with
the the times and locations of those so
you can see what we're talking about on
when it's on I want to go through a
couple of background slides before we
get into the metres presentation and so
first is just some of the background for
what the goals for JDK 9 and project
jigsaw are so at a high level what what
we're trying to do is is make the Java
platform and Java see a lot more
flexible and scalable and allows get to
the point where there's a lot more
reliable and compact deployments so
deploying runtimes in the cloud or on
embedded systems we're trying to get to
the point where we have a more more more
secure and maintainable platform when we
talk about security we're talking about
encapsulating this very much the
security sensitive and internal api's
and within modules and for
maintainability having these strong
capsulation and encapsulating the
eternal api's will make things a lot
more maintainable for the JDK it'll also
make it much more maintainable for and
for libraries and for those using
libraries because a lot of libraries and
applications are making use of internal
API api's in other libraries maybe
knowingly maybe unknowingly
so having modules will get us to the
point where things are a lot more
maintainable we want to make it easy to
construct maintain deploy and upgrade
large applications and that's both Java
C applications and eventually in the
future Java EE applications we and
importantly we want to move towards
improving
the situation with what's called Jar Jar
Jar hell and which we have with the
classpath today so we'll go a long way
to improving the situation and with with
modules in JDK 9
and finally there's what we're doing at
modules we'll actually go and enable a
lot more performance improvements in the
future so I want to start by going into
some of the categories of api's that you
have and with the Java platform we all
know the Java dot star and Java X dot
star api's so we use java.lang object or
javax.swing jpanel or something like
that these are standard Java SE api's
they're they're tied to the java
community process they get defined there
they're supported and documented api's
we all understand those there's a bunch
of other api's that are always a little
bit confusing that we call them jdk
specific api's these api's are typically
in the at least historically have been
in the comm sun namespace if you go to
the the the documentation pages you will
actually see a number of documented
Khamsin api's for security for
management and for a few other areas and
in recent jdk releases these jdk
specific api's have been in the jdk dot
something namespace because we have we
have since we're no longer sun we have
moved to and we're now an open JDK we've
moved to defining these JDK specific API
is in the jdk namespace rahdert and Comm
some there's a whole bunch of other
internal api's that are also in the comm
some namespace sometimes you'll see the
word internal in the package name and
it's pretty clear that this is an
internal package others are not as clear
so there's always been confusion around
these then there is the Sun dot star
namespace most people will know that if
they see a Sun dot star API that's
probably JDK internal there has been Sun
dot star api's all the way back to jdk
1.0 so this is this this is a this is
captures a one of the pages from the
documentation from jdk 1.0 1.1
mark dug this out I think for Java one
last year to to show the page where
there was a warning about using Sun dot
star ap is the date on the bottom for
those that can't read this I forgot to
bring binoculars it says 1996 at the
bottom of the page if I was to read out
what it's what I've highlighted in red
it says that the Sun dots are packages
are not part of the supported Java
public interface a program that directly
calls any API and Sun dot star packages
not guaranteed to work on all Java
compatible platforms so there has been a
warning in the documentation for almost
20 years about not using Sun Deathstar
api's in JDK 6
this was actually enforced by the
compiler so it actually emits a warning
if it attempts to compile code that's
actually using any internal EAP is but
my guess is if I pull the audience's a
lot of people will not will not have
seen this warning are they will ignore
the warning which we're all guilty of
doing it's just a couple of things about
general compatibility policies before I
get into some of the real slides is is
is that a high level if an application
is only using supported API and it works
on a particular release then it should
work on the next release and that's even
without complete compiling us if I have
something on JDK so I've compiled it
with JDK 7 it should run on JDK age
without recompiling assuming it's using
just the the supported api's this has
been the compatibility story for the
most part of 20 years and it means that
a lot of people can actually preserve
their existing investment because they
know or they have some confidence that
things will just work on the next the
next release the JDK tries
what does not promise and is never
promised to and that it won't break
applications that are using internal
api's and incompatible changes in
supported api's tend to be confined to
major releases sometimes with internal
API is there is dirt there's breakage
across other releases and what paper key
people try when they're working on the
JDK try to take into the into account
the possibility to people are using
those api's there is a policy that was
established a couple of couple releases
back to allow supported
guys be removed and this is this is not
something that's actually being used all
that often and it's only something that
happens with significant advance notice
for Java c9 we are proposing to remove a
small number of deprecated methods and
we will see those later in the
presentation just a couple of points
about managing incompatibilities and so
managing compatibilities is all about
judging risk and impact and a lot of the
time we're trying to use real data when
trying to judge whether where something
is an incompatible change and what the
impact is there are many times where we
have run a done static analysis on
thousands or tens of thousands of
projects in in maven Center for example
to get some idea about API usage so a
lot of data is often used when trying to
figure out whether to make a change or
not when there are incompatible changes
we try to communicate early and often
for some of the changes that we're
talking about for JDK 9 we've been
actually talking about these now for
almost 5 years and the things I'm
talking about going to be talking about
that are that are proposed to be removed
are things that we had planned to remove
a long long time ago we deprecated them
a long time ago in preparation for
moving to modules and JDK 9 when we do
incompatible changes is that we try to
make it easy to understand how tools and
code will be will be affected and a
couple of people put up their hands to
say that they're testing out the early
access bills that is really the time to
during the development of major release
to actually defined these
incompatibility issues and early on
there are times when we may make a
change we may not realize what the
impact is but well we get feedback and
we get grumbling from people that are
trying out the early access release to
point things out that we may not have
actually spotted so having that kind of
feedback with the early access bills is
very very useful and and often as well
when making changes we have system
properties or we have other command-line
options to retain
they are restore the behavior of old
releases and if you look at them every
major release of the JDK in the
documentation there's all the system
properties or other little knobs to be
able to restore and retain all behavior
and finally we write lengthy migration
and release notes I don't know how many
people actually read them but there's an
every single major release has an
exhaustive list of release notes that
document all the compatibility issues
that we are aware of okay at a high
level these are some of the incompatible
changes in JDK 9 and the important one
that I'm going to spend most of the time
on is the first one which is
encapsulating most JDK internally api's
I want to talk a little bit about the
binary structure of the JDK and a couple
of things that have been removed and a
couple of other other changes and also
the version change which turns out to be
quite a significant and issue so I'm
going to start with a data point which
is which is based on on analysis that we
did last year on the usages of JDK
internal api's so this graph here is
based on an analysis of about a hundred
different libraries and some popular
open-source libraries and a couple of
proprietary applications that we have
that we are able to get our hands on so
running some static analysis on this we
get some idea of which of the JDK
internal API s are actually being used
the way this graph is is structured our
sorry showed is this is that the
internal API are plotted on the x-axis
and the usage count is on the y-axis so
looking from the left we can see that
based on this static analysis there's a
hundred and twenty five usages of some
internal API and there's just over a
hundred usages of oven of another
internal API and we can see that there's
a big long tail here this goes over on
this corpus of of code that was that was
examined there was over 700 different
internal api's that were used
so I'd I don't know if anyone would like
to guess what the most popular Sun dot
star API that was used by this this code
base that you are this this group of
libraries and applications that you
haven't seen does anyone want to give a
gaze I hear someone said unsafe well
that's that's quite a good guess but for
this for this group of libraries and
applications it turns out to be some
miss base64 encode er was the most
popular one use and Sun Sun miss gun
safe wasn't wasn't too far behind if we
were to go down to the third one it was
actually some misc base64 decoder was
the third most popular one use one thing
just to say about base64 is this is that
we did finally after almost 20 years
introduce a standard base64 API in Java
C ace finally so based based on this is
there's a categorization of internal API
is that was put together and I'll go
into and few minutes to talk a little
bit about how this is documented in JEP
260 and what we can do when we look at
all of these usages of internal API is
we can essentially put them into two
buckets there's the non-critical api's
which is which is really the api's that
are not really used by anything there's
no evidence that they're actually being
used also in this Bacchus would be the
internal API is that are really just
being used by convenience someone
happened to find that there's a very
useful Sun that's our API so they make
use of it there's no real reason to or
critical reason for it then there are
the critical API is some Muskaan safe
being the most obvious one it's not
possible to to write your own Sun
Muskaan safe that is outside of the
platform and there's a small number of
other critical internal API is like this
so in JEP 260 sir JEP is is jdk
enhancement proposal is it's it's it's
it's how features and and other big
changes and significant changes in open
JDK are actually tracked we have JEP 260
than they're all numbered I should say
it proposes and this is what we have in
our current rate okay now in Bill
is encapsulate all non-critical internal
api's by default remember non-critical
internal api's are those are no evidence
that they're being used or they're just
being used for convenience we
encapsulate all the critical internal
API s which have supported replacements
in in jdk age or Java SCH so if there's
not if there's really a supported API
and there's no reason to use this in
turn this critical internal API then
there's no reason why it should be
available for widespread use in nine and
then the final one is do not encapsulate
the critical internal API s like some
Sun Muskaan safe and have the complete
list from G up to 60 in the next slide
instead what we want to do is is
deprecated them and and then plan to
remove them once there is a supported
API available for them anything using
these using these api's will also have a
workaround via the command line and
other means as you will see to be able
to still get at those api's when you
really need to so Jeff 260 as it stands
at the moment lists the following as
critical internal API s and Sun Muskaan
safe which is critical to a lot of low
level access and high performance
libraries we have the the signal API
which is related to just two signal
handling and reflection get call our
class now that is widely used by logging
frameworks there is a new stack walking
API which was done as part of JEP 259 in
for Java C 9 and and eventually we would
hope that the the logging frameworks and
other usages of this API would migrate
there then there's a Sun reflect
reflection factory widely used by
serialization frameworks because it
provides some features that that you
need to be able to for example
instantiate objects without running the
constructor things like that so just
back to the data that we had in this a
couple of slides ago and so this is
about a hundred different products and
this actually puts labels sorry colors
on the internal api's that are actually
you
here and so that you can see how it
relates to the categorization in the
last two slides so when I look down
through this and I realize the color
it's hard to maybe differentiate this is
those that are colored in orange if you
look at the second one down son Muskaan
safe that's the critical internal api's
purple which is quite a few of them from
the Sun miss base64 encode and decode or
near the top are the good examples
they are non-critical api's and there's
a supported API for them there was never
really any reason to use make use of the
JT case and turtle and version and
anyway I'm Green are non critical and
non Sam but supported in nine that's a
very small number of categories where
when we looked at these internal API
usage realize oh these ones should
really have been supported api's so
there's this these are w3c dumb XPath is
that was a case where we weren't we
weren't doing the right thing in terms
of providing the aligning it with the
w3c api's and then read is no
replacement sorry there's no date a lot
of these are just they're used for
convenience how do you find these usages
so just back to poll in the audience a
minute is how many people here have
heard of the J DEP stool okay maybe I
see about maybe 10 10 hands here the J
depth stool is a tool that allows you to
do a static analysis on your libraries
and applications to see what ap eyes are
actually being used what their
dependencies are that tool is in JDK H
we put that tool in as part of of
preparing the platform to move to
modules and strong capsulation in the in
the future it's really really useful
with with an option called earth the
option is named - jdk internal I would
have example in the next slide and that
allows you to quickly see whether you
have any direct dependencies on JDK
internal API s you can quickly run this
and point it at your jar files or your
application and it will tell you if you
re making use of any JDK internally
P is C Robert Shelton the in the
audience there he's written a maven has
a plugin that actually uses J tips so
you can actually incorporate it into
your maven projects and so they can
actually report I think and actually
fail if you're making use of JDK
internally api's so this is very very
useful so I'm going to show a couple of
examples and I'm just I've taken four
first start one of the the GlassFish jar
files and just to show what the sample
output is when you run J tips - JDK
internals what you're seeing here is a
printout of a number of Sun dot security
that's something ap eyes that are being
directly referenced by code in this
security jar file I think what's
happened here is is that there's an
internal framework within the within the
security security library code that that
is being used used here what's happening
is is pointing out that scum son
Enterprise comm IOP security something
something something is making as a
direct reference to Sun security util
object identifier this is possibly an
extreme case this is possibly being used
for for convenient use but it gives you
an idea of what the JDK internalise
output produces the other thing at the
end is is is that JJ tips has a little
mapping of old historical internal api's
to new supported internal API so in this
case if you'll read down at the bottom
of the slide it suggests changing your
references to some security X 500 X 500
named to Java security off X 500 X 500
principal because that is a supported
API anyway the main thing is this is
this very very quick youmu jdk age to be
able to just run this tool and see
whether you have any dependencies on
internal API s so now that we know that
this just this just this glassware jar
file has is making use of internal API
so what happens if I were to run that
code with JDK 9 we will see
it actually fails at wrong time with an
illegal access error ignore the detail
of the error it's essentially saying
that some code in this console on
enterprise security something-something
is trying to access some security
provider policy file in module Java base
ignore that we talked about Java base
later on in the later talks and then you
see stack trace and it's essentially
telling you it's it's it's it's it's a
warning maybe it's fatal
with glass this year that you're trying
to make use of internally api's I said
earlier on that you would have got a
compilation error with JT case from JDK
6 an words if you try to make direct use
of internal API s now you've got the
runtime enforcement and with this
stronger enforcement at compile time to
this gives you an idea of the
implications of strong capsulation and
encapsulation of the JDK internal API s
now let's look another of an another
example I'm using a slightly older
version of Gradle 2 for those that are
tracking Gradle and I try to run the
kemal compiled Java task I've
highlighted in red that this is failing
could not create an instance of calm
some tools Java C API
Java C tool that's it not not a huge
amount of information there but Gradle
is actually quite good in that you can
you can give it a stack trace option on
the grader command to give you more
information so getting a failure here
and if we run with the stack trace
option we get a little bit more
information we get a stack trace in this
case it's a legal access exception if
you if you know your X if you know your
errors and exceptions in the Java
platform you know that the static
reference failing with an error
equivalent work or reflection is is an
exception because core reflection does
the same access checks as as the virtual
machine so here we have some core
reflection usage in in in this older
version of Gradle that's trying to make
use of an unsupported API in the Java C
compiler it's failing at at runtime so I
realize when you see these for the first
time is these scary exceptions
just look scary but you don't panic I
said earlier on about about the result
was going to be a workaround and that
workaround is we start with the command
line version of it so for the four going
back to the GlassFish example I can get
the existing version of GlassFish to
still run by giving it a bunch of
command line options that tell us that I
want to break encapsulation and really
really get at these api's so out of the
box I cannot I cannot compile I can't
run and make use of these internal api's
and but I can still get existing code to
work via this command line option I'll
explain the details of what this means
in a few minutes now I don't like to
pick on on things beginning with G and
in the case of GlassFish there was
actually an issue that's already really
tracking this issue so that this old
code that's using some but security
classes will assume get fixed in time so
back to the option that I just showed a
few minutes ago and the format of this
option and so then the name of the
option is - - ad exports so one of the
other things and you may see this in
some of the other presentations today or
this week is is we've started to and add
new command line options in JDK 9 that
are the new style in quotes so they're a
bit more verbose in the UNIX style and
the sort of uniquely JDK style options
that we've had in the past so in this
case it's - - a - exports because and
all of the new options by the way are
are in this style the value to this
option is is as has three parts to it
the source module package and then what
the target module is if you come along
to the to the talks later today about
modules you can show how we've migrated
what was the monolithic platform into a
nice graph of modules the core module in
the system is called Java base and
that's what this one I'm specifying here
is the name of the module then the
package name of the internal API that is
being used and then Who am I going to
give access to ignore the detail of what
all named is
if you attend the modularity talks that
we're going to be doing today and
tomorrow and Wednesday then we'll
explain a bit more about what what this
means in fact Alex is under the hood
talk and goes through a lot about what
this notion of unnamed module for now
just assume it means the class path in
other words I'm giving I'm exporting the
Sun security provider package so that
can be used by code on the class path
that's a simple way to to read this
discuss command line we also in our
early access Bills have a way to do this
via the main application and manifest so
in the in the main application jar file
you can take responsibility for and
making use of these internal api's by
declaring in the manifest that exactly
like we had in the command-line option
so that's all I want to say for now
about encapsulating internal API so I
want to move on and try and get through
some of the other things are the big
changes in jdk 9 right so what I want to
talk about the binary structure of the
JRE in the JDK when I mean the binary
structure I'm essentially mean it's
layout on disk the fact that we have a
bin directory
RGH are tools that you are these are
things that you would have seen in the
JDK and the JRE releases going back
several years we're finally getting
around to looking at this layout on disk
so this is actually disruptive change of
tools I'll talk a little bit about about
that in the next covering of slides with
many motivations for finally reexamining
these dis layouts on disk when we move
to a modular runtime what's happening is
is that we're going to completely blur
the historical and distinction between
the JRE and the Gerry plus tools that we
call the JDK it marks keynote we saw he
created a little runtime that only had
one module or a small number of modules
this is another runtime there is the the
the existing are the long-standing and
runtime image layout does not lend
itself to doing this kind of blinking a
whole bunch of modules together
and producing your own one time image
other motivations are things like the
zip format we've been using the zip
format as the basis for jar for a long
long time it's not an efficient way to
store the platform classes it's we have
had so many different startup and other
performance issues related to jar files
in our TVR especially as the platform
has got bigger and bigger and bigger
over the years and so it's finally after
20 years time to revisit this old format
there's lots of interesting things we
can do around performance and when we
reexamine and this so all of these
changes we went into em in - jdk age 39
back in late 2014 it's a disruptive
change for tools so disruptive change
for id's compilers and so on as part of
this we've introduced a supported way
for these tools to be able to access the
contents of the image so this is the
first time we've had a supporter way for
tools to be able access the class files
and resources so this is useful so a lot
of the tools have already migrated to
making use of this particularly in early
access form there's still some tools
that haven't haven't got there yet just
looking at it the old historical format
this is JDK 8 you can see there's
essentially two levels of directory at
the top level you've got the bin
directory where you'll find tools like
Java and Java C within that you've got a
runtime and there's also a Lib directory
we defined tools that you are in they're
going down the level you will actually
find another bin directory with copies
of the same tools and a Lib directory
where you find you would have found our
GTR and a bunch of other jar files in
there there's other jar files they all
have they all have history as to how
they came into into being if you if you
start digging into the Lib directory you
will actually find a whole bunch of
other interesting files that some of
them are supported configuration like
for example the security policy file
there's other there's other
configuration files in there you're not
really supposed to change those because
if you do then the JDK won't start up or
the misbehave and so
on we've never been clear as to what
what's the what's the configuration
that's intended to be so be edited
versus versus versus configuration that
shouldn't really be edited because it's
going to break things so the new format
that we have in JDK 9 again as I said
since since one of the AE since late
2014 removes that one level of directory
it's very very simple we just think of
it as as a as a only three interesting
directories in it the bin directory as
before where you'll find the Java launch
or java java c RM ID all of the other
interesting tools that you'll find in
there a kampf directory which is where
all of the configuration that is
intended to be edited is moved into this
this is where you'll find the security
file this is where you'll find the
things like the properties to configure
the management agent all of these things
that you want to be able to edit are in
the one place everything else is in the
Lib directory in some format that
possibly will change over time in the
case of the class files and this is
within the JDK we've put them into a
completely lock to Mai's format that
that will change over time but is very
very useful for the JDK in terms of and
startup and other performance things
that we want to go into so that's all
I'll say for now about the the runtime
image this is primarily in implications
for for tools rather than in most
applications I mentioned about removing
some deprecated methods so these are six
supported Java dot star methods that
we're actually removing you probably
don't recognize these or most people
won't recognize him these have been
removed since the first build of JDK 9
and I'm not aware of any bug reports
which suggests that there's not too many
people that are reusing these these have
been deprecated since since age and they
were flagged for removal so as part of
modulized in the platform which we
talked about in the next talk a little
bit is these are the six that were most
problematic and had to be removed in
order to actually get to the nice module
graph that we show on the next talk
there's some extension mechanism have
been removed and the standards override
mechanism hardly ever used originally
intended for app servers that are
replacing and upgrading some of the
components in the in the JDK and the
extension mechanism again this this
hasn't been widely used it was very much
a mis feature and but essentially it was
a way that you could actually don't jar
files into the runtime image and have
them mean you have a bloomin visible at
compile and run time so not to these are
not too interesting the next one might
be kind of interesting so I want to show
you a jar file on the classpath in GSR
three or five jar assume this jar file
has a couple of annotations in there in
the package Java X dot annotation I
guess any one that most people may even
recognize these not nullable off off off
off often used for defect detection in
applications these annotations are in
the same package as the so-called common
annotations the GS are 250 GS or 250th
and defined annotations so now what you
have is by putting this jsr 305 on the
class path I've got some annotations in
Java X annotation that are part of this
other one API and they're loaded at
runtime by what's called the platform or
in the past the extension class loader
and then I've got the these these other
non notable nullable and so on on the
class path that are loaded by the
application class loader this is a
little bit strange what I've got here is
a split package problem I've got some
some classes are part of the platform
some are on the class path this is just
one of a couple of api's that are highly
problematic and the transaction api is
another one Java C defines a small
subset of the transaction API the reason
it does that is is is part of supporting
transactions with with with korba Java
EE
defines the full transaction API another
potential split package problem things
really go downhill when you start
looking at corba the core vendors the
app servers typically will upgrade and
overlay a bunch of support for
additional and OMG standards so what has
been proposed and what has been in JDK 9
for some time is that the modules that
are shared with Java EE and by the way
everything here all of these problematic
packages they're all things that are
typically upgraded by Java EE they are
not resolved by default now we haven't
talked about modules and resolution or
anything for now just when I say these
modules are not resolved just just
assume that the types in the transaction
API in any of these other six that I've
listed here they're not visible by
default
it will appear as if those types do not
exist you get a go class that founder if
you try to run code that makes use of
them we have documented in jet 260 a
write up as to the rationale for this
I'll read it out number one to avoid
unnecessary conflicts of popular
libraries that define types in some of
the same package like we saw in the
previous slides and number two to make
it easier for existing application
servers to migrate to JDK 9 application
servers often override the content of
one or more of these modules and in the
near term they most likely do so by
continuing to place the necessary
non-modular jars on the class path so
this is if you're using any of these and
there's six of them here and you don't
know the module names because we haven't
showed them yet when we will in the
other talks is we have organized these
these modules that are overlapping with
with Java EE into six modules Java core
which you have a transaction Java
annotations common job activation Java X
is our java xml ws for the web services
in java xml bind for the for the binding
api's again we don't panic here because
we're always thinking through and what
options you have to keep the existing
world going
it's very simple on the command line if
I'm using CORBA and I can continue it
will continue to work exactly as it did
in JDK 9 by just using this option
called add module add modules Alex just
pointed out that I've a typo here this
is this should be plural modules so add
modules Java corba what that does is it
essentially adds that module to the set
of modules that should be resolved as
start of existing code that uses coral
will continue to work with this option
for the App servers not really the most
applications it's possible to deploy an
upgraded version of CORBA as a module
and you just use this upgrade module
path this is like the the module
equivalent of the endorsed override
mechanism that is that I mentioned
earlier on mostly only interesting to
the app servers it's also possible
because there are because the these
modules are not resolved by default I
can actually just throw this on the
classpath there's no split package
issues so there's a couple of possible
workarounds for this this type of issue
if you're making direct use of these
api's one final thing just to say on
this is this policy of not resolving the
e modules by default is very much
something that we're dependent on
feedback on so we need to see over the
next couple of months and whether you're
whether this type of a changes is
disruptive or not maybe this set of
modules should be just we will actually
see this is being in JDK 9 for quite
some time there's been very very little
feedback on us what it's possible that
not too many people making use of these
api's or trying things out okay a couple
of other things are interested in
changes in JDK 9 I'm not going to spend
time on them today is is the application
the extension class loader which is
renamed the platform class loader are no
longer instances of URL class loader
we've had a couple of cases where
there's existing library code have been
making the assumption that the
application class loader is an instance
of this type and blindly casts to that
type and then of course because this is
completely changed in JDK 9 they get a
class castex
action more details on our routine
object 261 on that there's a couple of
options are being removed like the
ability to override or prepend to the
blue class path the reason is is the
blue class path as we know it really
doesn't exist in JDK 9 and it's all part
of moving moving to modules and the
system properties associated with that
have been removed as well I want to
quickly go through a couple of other
things and the version skeet stream chip
223 surprisingly this is probably the
most disruptive change that we've have
had in JDK nine so far and the JDK 9
versioning scheme has historically been
confusing because I read from the gyp
this is again and the chip in its
motivations has a little write-up which
release contains all of the most recent
security fixes is a JDK 7 update 55 our
JDK 7 update 60 it looks like JDK 7
update 60 is 5 releases later than
update 55 so therefore it must include
more security fixes that compute that
that conclusion is incorrect these two
releases contain exactly the same
security releases security fixes
security releases based on the previous
minor version are odd numbers
incremented by 5 r by 6 if necessary in
order to keep the update number odd
always being confusing this is the
proposed new version string format
you'll find all the details in Jeff to
2023 the simple way to summarize this
slide is after 20 years
we're finally dropping the leading one
changing the version and scheme has an
impact on system properties and this is
where it's been quite a disruptive
change there's a lot of code out there
that reads the Javadoc version property
and parses it and so this one thing just
to keep in mind if you have any code
that is dependent on the version see
what I haven't gone through today in the
in this slide is visit there's a new API
prefer for Java C 9 and it's called
runtime dot version you can actually
call one time that version and returns
you a version object that M allows you
to introspect the major minor and other
things about the about the version
number very very useful so I've been
talking about disruptive things I just
want to spend a few minutes on things on
an honor to features that I think are
interesting and when you start looking
at at migration from 8 to 9 and these
are the DS are described in 238 and 247
238 is multi release jars 248 is
compiled for older platform versions so
because so consider this scenario I'm
making use of internal api's but there's
a supported API available in java c 9 so
maybe maybe you're making use of our
handles so you don't have to make use of
some of the lower-level api's may be
using making use of the the old internal
XML API is for serializer or catalog and
and there's a new catalog API and 9 my
application well I really wanted to work
on a time when you need to build it on
ease and then run on age or 9 so this is
a common scenario particularly
particularly when you're we're talking
about 2016 and JDK 9 is and isn't isn't
going to be released into 2017 so I need
to be able to do this kind of scenario
so one feature in JDK 9 and
is multi release jars the jar format has
been extended to allow multiple job
release specific class files to coexist
in the same archive I'm not going to
spend a huge amount of time on the
bullets today but it's something to look
up and it's very very useful feature so
if a multi release jar file has in its
in its manifest a natural beaut named
multi - release that has a value true so
it's a boolean and then has a section
meta INF version / than the version
number in this case nine and the classes
and the resources in that section can
override what's in the top level or base
section so if we were to study this
example we can see that we've got there
to help produc classes in this jar file
in the top section we've got comic
neistat's internal helper class and down
in the meta-inf versions nine
there's also another calm acne stats
internal helper class when you run
online the bottom one will be used when
you run an eight the one in the top
level our base section will be used so
in this example and I'll run it just as
the main application jar for the moment
when I run at an eight we can see that
calm acne stats internal helper loaded
from the top section our base section
online is loaded from the meta-inf serve
INF versions this is very very useful
when you're trying to do this migration
from internal api's to and supportive
api's immediately when you start
thinking about oh now i've got to have
jdk age and the jdk nine in my build
environment in order to do this I want
to make aware of one other one other
change our third feature in jdk 9 which
is the ability to confer the compiler to
target old releases we've always been
able to do java c - sourced at target
seven or eight and then give it a boot
class path
okay that means I have to have another
JDK on my system if I'm on eight I'm
going to target seven then I have that
mom I'm going to Jade gate for building
I'm targeting seven in order to be
ensured that the compilation is
consistent I can do that all now at one
step in in JDK 9 I can do Java C - -
release whatever my target release is
and it's equivalent to their source -
targets that new class path with only
having one JDK on the system so this is
really really nice with JDK 9 in my
built environment I can compile to six
seven eight or nine without having
multiple J decays on my system so that
compiled multi release jars provides a
great way for actually moving away from
internal api's and building applications
that run on different versions of the
platform believe there is a talk
tomorrow on maven - that will touch on
on some of the support for for these
features so I wanted to start wrapping
up and so a couple of things to start
thinking about move for for jdk 9 the
most important thing that I've that I've
shown in this slide deck today is the J
tips tool very few people put up their
hands when I polled the audience earlier
on so there's there's not a huge
awareness of this of this tool to do a
static analysis on your libraries and
applications it's a really really good
tool to quickly identify whether you're
using and any JDK internal API s so
that's one thing to to be aware of the
version change as I said has been highly
disruptive a lot of open source code has
been catching up and over over the last
six to nine months I have no doubt
there's a huge amount of other code out
there in applications that's parsing the
value of Java dot version and isn't
going to get the right answer with nine
so that's something to check out
primarily for tools but maybe you've got
this already is this is that we've had a
lot of code that has assumed there's an
RTR it starts looking for jar files in
the JDK Lib directory or Jerry Lib
directory because it needs to find
miles this is all change as I said
because it's a new layout in JDK 9 what
are things to be aware of is is some
people did put up their hands at the
beginning is there are weekly JDK 9
early access bills so that and we're
working on modules we also do a jigsaw
early access builds on a regular basis
as well there's always early access
bills to download and try out I pointed
out a couple of the things that help
with the migration the multi release
jars and compiling to old versions
that's also worth checking out more
information so we're working on the
module system and the module and and the
modular JDK for JT t 9 this is all being
done in open JDK under project jigsaw
there's the links to the project page
and the mailing list early access bills
for JDK 9 or early access downloads is
there the Jade EPS tool has its own wiki
page that Amanda Chung has been
maintaining that is a useful page to be
able to see a quick list of internal API
is versus supported ap is that would be
better API ste to use I've also included
some links to and the JYP's that I
talked about towards the end of this EM
session I'll come back to this slide in
a few minutes but just just advertise
the other sessions that we're actually
doing here I said this is the first of
five sessions that we're doing Alex and
I are back in no sir
I'm back here 2:30 about introduction to
modules the two of us are back here
later in the afternoon to do advanced
Alex then has project under sorry the
services and projects under the hood
tomorrow and then we have repeats for
the sessions are actually repeated we
also have a hack session on Wednesday
first thing in the morning and I think
they're all mostly even this room or
next door
so back to the links and I think we're
done we've only got a few minutes for
questions but if you want to ask some
questions please go ahead we may have to
take some of the questions outside after
if we run out of time
you have to shout
okay I didn't quite catch all of the
question but I think what you said is
this is that there some some libraries
are having problems with nine because
they're using internally api's okay so
and all I can say is until they migrate
away from those API s we have some ways
to mitigate it via the command line
options that I showed that that that's
really our our solution for that at the
moment
right so the question is is with multi
release jars does it imply multiple
source trees I think and I think that's
a that's that's that that's a really
good question so the the multi release
jar feature doesn't prescribe a source
layout for for that what you would have
to have some way to be able to support
that sorry Robert is this something
you're going to talk about okay you're
sitting actually beside Robert Schulte
whose leads maven and people give me
giving a talk tomorrow and I think we'll
cover this everyone is prepared that's
great okay okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>