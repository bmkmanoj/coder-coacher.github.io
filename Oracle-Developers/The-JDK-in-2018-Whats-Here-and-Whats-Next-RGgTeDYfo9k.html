<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The JDK in 2018 What's Here, and What's Next | Coder Coacher - Coaching Coders</title><meta content="The JDK in 2018 What's Here, and What's Next - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The JDK in 2018 What's Here, and What's Next</b></h2><h5 class="post__date">2018-03-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RGgTeDYfo9k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay I think it is time to start we have
45 minutes to talk about the JDK in 2018
what's here and what's next I'm going to
catch you up on what's new in the JDK
since JDK 8 came out in 2014 now we
released JD came 9 last September JDK 10
today and JDK 11 will come this
September so we started this year on JD
King 9 and we'll finish it on JDK 11
then two more releases in 2019 what
you'll see with these releases is not a
new lambda sized feature every six
months but rather a steady drip feed of
various features of various sizes one
release might have many small features
and no big features while another
release might have one big feature and
no small features some of you might run
every release in production after say a
month of testing others may upgrade
every year that is every other release
still others may stick to commercially
supported releases and upgrade only
every three years that's why it makes
sense in this presentation to look at
the broad sweep of JDK 9 10 and 11
before I go any further I'm going to do
another straw poll who here is running
Java 8 in production most hands seven
and six at war hands and seven that's
interesting okay
oh I'm gonna talk about fire all I
should have checked jet ek9 anyone
running jelly King 9 in production
no hands ok so I'm gonna talk about five
things a Java platform module system and
modular JDK factory methods for
collections all that is for JDK Narine
I'm going to talk about local variable
type inference in JDK 10 in more detail
all that in the keynotes and I'm going
to trail a feature that might be enjoy
BK 11 so the Java platform module system
in JDK 9 after many years of effort we
introduced a module system into the Java
platform the module system is a big deal
because it enables modular development
all the way down a java language and the
java virtual machine understand modules
very deeply so that the applications you
write and the libraries you consume and
even the jdk itself can all be developed
and tested and packaged and deployed as
modules with clear api's and well
protected internals making everyone play
by the same modular rules has great
benefits for reliability maintainability
and security so what is modular
development it's all about reuse in
object-oriented programming the unit of
reuse was traditionally the class Java
has wonderful mechanisms for promoting
reuse of a class inheritance for reusing
behavior interfaces for reusing
abstractions separate compilation
dynamic linking and access control down
to the level of individual fields and
methods and Java has had method classes
since 1997 so it's possible for a single
top-level class to encapsulate a vast
amount of functionality but of course no
one tries to cram an entire application
into a single class any real Java
program will consist of multiple classes
in multiple packages programs are really
packages not classes and now we see
programs with dozens or even hundreds of
packages once your program is that big
the Java language kind of gives up there
are no abstractions in the language to
help you reuse multiple packages or to
control sharing between them the only
way to share code between packages is
with the public modifier but then the
code is shared with everyone it's not
surprising that packaged friendship in
one form or another has been requested
many times over the years so a package
is a great way to organize classes but
most people wish there was a way to
organize packages to modules let you do
that the module is a set of packages
designed for reuse this is a
long-overdue building block in the java
language modules record the structure of
your program so that the packages you
wants to be reused and can be reused
while the package is you don't want to
be reused and not to be reused a program
built of modules will be more reliable
than a program built from a loose set of
packages in jar files that can access
each other freely and that share
internal API is public with the outside
world
in other words programs and modules is a
module that everyone will become
familiar with Java base it's the
foundation in Java 9 and above or every
Java program just like java.lang object
is the root of every class in blue are
the packages of Java base intended for
use by code outside of the module these
are its exported packages in red and the
packages internal to Java base they can
be used by code inside the module but
not by code outside the module these are
its concealed packages a module is
declared in a new kind of file called
module info Java it gives the name of
the module and its exported packages and
so by exporting the java.lang package it
means that the public classes of
java.lang are accessible from outside
java base
a package that is not explicitly
exported such as homeland son crypto
provider is concealed its public classes
are not accessible outside Java base so
this is the first important feature of
modules strong encapsulation a module
isn't just a set of packages it's a set
of exported packages and concealed
packages
this means that access control is more
powerful in gdk9 and later of a ninja TK
8 j TK 9 and later you can arrange for
public classes to be accessible to
everyone or only to other classes in the
same module or accessible to classes in
the same module and a limited set of
friend modules so if you're looking at
the public modifier on a class
declaration it no longer means that
everyone can access the class access
depends on whether the classes module
exports the classes package
since Java base is a module let's reuse
it with the module of our own is the
simplest possible program in a package
the packages come example hello let's
declare the module thoris at the bottom
there's a module in philip java file and
for sake of arguments
let's export the comic sample hello
package with the exports directives now
you're probably wondering as many other
things how the hello world module knows
that it has a package called comm
example hello after all nothing in the
package nothing in the say hello class
seems to point to the hello world module
it's up to the tooling to decide during
development which module each package
belongs to in practice the right he
takes care of its and create a modular
java application you're asked the name
of the module then every package you
create will be part of that module
if you run java c by hands button right
then java c figures out which module
each package is in
that's why module in vltava is in the
SRC directory at the same level as the
common directory the roots in the
package hierarchy now the benefit of
relying on tooling is that it's really
easy to place an existing package in a
module and immediately give that package
the benefit of strong encapsulation we
do not want each and every class to have
to opt in it's a strong encapsulation by
declaring the module it belongs to that
would invite errors such as classes in
the same package attempting to join
different modules that that would be a
big no-no one more thing the say hello
class obviously imports the java.lang
package I didn't show before because
it's implicit but that that import is in
every program your rights now usually
you don't think about this asking where
is java.lang imported from now you might
say the answer is obviously Java base
because you told me a minute ago the
Java base exports for java.lang package
and you're right in this case but in
general how does the compiler find
arbitrary packages that you import
should it search the file system looking
for modules which export the imported
packages or if multiple modules exports
the important package if we intends to
reuse the Java base module by importing
its packages actually since we're
writing a module ourselves we must
document a fact this is the second
important feature of modules reliable
dependences a module isn't just a set of
packages it's a set of packages that
reuses to packages exported by other
modules so the HelloWorld module
specifies that it reuses the Java base
module with a requires directive and its
module in photo Java this means the code
in the HelloWorld module can imports
any of the packages exported by Java
base
if code in hello world tries to
concealed by Java base and even the
public classes of those packages are out
of bounds it's like when you try to
access a package private class from a
different package the compiler gives you
an error and at runtime you get an
illegal access error it's the same thing
here if you were to try to import con
some crypto provider or touch any of its
classes I'd like to say one more thing
about that module in photo Java file
that declares a Hello module it's really
important to understand that a module
exports packages for reuse it requires
modules the reason is due to an old
software engineering principle the unit
of reuse is the unit of release the
principle is ultimately about separation
of concerns you reuse someone's code not
by copy pasting it into your own source
tree but by depending in some way on the
black box artifact we released by
someone else now in the Java ecosystem
there's no question the release is the
jar file that does not change with
modules a jar file simply carries the
module info dot class file that was
alongside ordinary class files we call
this a modular jar so when someone
releases a modular jar for the hello
world module its reused by someone else
writing requires hello world in their
own module info Java the reuse er Enif
it's from an explicit come here an API
consisting of precisely the exported
packages just the one in this case the
releaser benefits from strong
encapsulation of con sealed packages
they were done here but maybe there are
they're not shown even if there is high
coupling inside the hello world module
there's loose coupling between modules
that's another good software
engineering principle if you want to
learn more about the module system and
ways to actually do modular developments
then I highly recommend this book Java 9
modularity that came out concurrent with
Java 9 last September let's turn to the
jdk itself 20 years ago the Java
platform was small just a few hundred
classes and the organisation of JDK 1.0
was not a problem but every year the
platform grew bigger and now is tens of
thousands of classes a JDK 8 was huge
and worse it was monolithic now in
reality the Java platform is about 25
separate frameworks a swing UI framework
crypto scripting multiple XML processing
frameworks and so on
there is no reason these separate
frameworks have to be tightly coupled in
one JDK download and it's actually an
impediment in developing the JDK the
overly tight coupling raises development
and testing costs which turns into
slower platform evolution and the larger
the surface area of your platform the
more difficult it is to secure plus it's
an impediment the monster the monolithic
jdk to a lot of users both those who
want to run applications on smaller
devices and those who want to run more
instances of their applications on large
systems even if you only wanted a part
of the JDK you had to take in jetty
canine we took the monolithic jdk and
broke it up into a few dozen modules
there's java base which everything
depends on and which depends on nothing
itself the various frameworks into their
own modules logging xml scripting
desktop which you can require not
require as your needs dictates
near the top there's a Java SE module
which has no actual code in it it just
has dependencies so you can say requires
Java SE and be guaranteed to have all
the standard modules available now it's
worth mentioning that merely finding
these module
which might be obvious in hindsight with
a tremendous engineering efforts you'll
find in your own code the decoupling a
monolith is much harder than building a
loosely coupled system from the
beginning
the good news going forward is that the
discipline imposed by modules prevents
all of us from accidentally recreating
the monolith now because the JDK is not
a monolith it's possible to create
subsets that suit your needs
suppose your application in green needs
JDBC and the Java activation API that
means it needs the Java sequel rotor
module and the Java activation module in
orange
in turn they need further modules if the
watchword for jdk 8 was functional and
the watchword for JD canine was
transitive
what matters is the set of modules
needed transitively by your application
the indirect dependences are just as
important as the direct dependencies if
anything in orange is missing your
application won't start up what you can
do is create a custom Java Runtime
containing only the modules that your
application needs either directly or
indirectly
we do this with the J link to it
generates a Java Runtime that looks like
the jdk just smaller you run your
application on this runtime using the
java launcher that is generated for you
as part of that runtime my runtimes such
bins - Java now note that your
application does not have to be a module
itself you can specify the module that
it needs with the command line flag -
jailing you'll see I've specified Java C
charoset enjoy / activation
question how do you know which modules
to include in your custom runtime answer
for Jade EPS tool it analyzes your class
files and jars and figures out which
modules they need
let's go back to the modules of the JDK
it is important to realize that various
technologies from Java EE have
traditionally been included in the JDK
not just in app servers in JDK 9 and 10
the list of Java EE modules includes
Jack's P jax-ws Java activation common
annotations and CORBA yellow in JDK 11
these modules will be gone we must
emphasize that done eight hundred
thousand lines of code gone the Java EE
modules are disabled by defaults and JDK
nine and ten if you run your application
on JDK nine and ten nine or ten and you
get a no plaster found error or a class
not found exception this is probably the
reason these EE modules are disabled by
default now there is a command line flag
to enable the Java EE modules in nine
and ten but they're not there in eleven
so long term you need to use standalone
versions of the Java EE technologies
we're now wondering where to find
standalone versions of the Java EE
technologies we documented your options
in great detail everything you ever
wanted to know about this - everything
was documented in jet 320 this is Java
enhancement proposal 320
so let's discuss another aspect of the
modular JDK the strong encapsulation
applied to JDK modules
a lot of tools and libraries try to
access parts of the JDK that are meant
for internal use only now it'll take a
while for tool and library developers to
move away from this practice so JDK 9
and 10 allow access to JDK internals
temporarily
however they print a warning when it
happens and there's a command line flag
to avoid these warnings but you should
check with tool and library developers
about how to deploy on JDK 9 and 10 we
may also find the tools and libraries
fall over because they assume the Java
version string begins with one dots on
five on six one seven one eight and it
doesn't make it's not one night it's
nine dots some tools assume that the JDK
lives in a file called RT jar some
libraries assume that the application
class loader is an instance of URL class
loader these are all implementation
specific assumptions that are wrong on
JDK 9 and later so again please check
with two library developers about the
versions of their tools and libraries
that you need to run on nine and ten
okay now get back normal service is now
resumed will now come back to Java code
there is a question which I'm going to
have to take at the end I'm sorry let's
look at a new API added in jeddah k9
factory methods for collections other
collections have changed quite a lot
over the years they've added support for
new language features such as generics
and lambdas they've gained support for
concurrency and popular classes like a
realist and half map have been rewritten
several times for performance but the
core collections API the list interface
was set interface a map interface
haven't fundamentally evolved since 1998
so in JDK 9 we added factory methods to
list set the map their convenience
concise and they returned space
efficient implementations they also
promised space and performance
improvements from use in the JDK itself
they're almost everything is called off
based off set of map of to instantiate
an instance of this set or map now these
off methods are declared as static
interface methods will call the since
JDK 8 you can put code in interfaces
with default methods and static methods
and JDK 9 you can also have private
methods in interfaces to help out and
help avoid your default methods getting
too long
examples of lists of and set off are
less verbosity now an important property
of these methods is that they return
unmodifiable collections there's no need
to wrap them with collections on
modifiable lists or collections on
modifiable sets being unmodifiable means
that any attempt to add set or remove
elements throws unsupported operation
exception and we think this is a good
thing because it means you can pass your
private collections some other code
without fear of accidental modification
also it's often the case that
collections which are initialized from
known values are never changed so
unmodifiable is a better defaults for
modifiable and of course unmodifiable
'ti is one step towards immutability and
freedom from data races
map of also returns and unmodifiable
collection are far more readable by
allowing our keys and values to be
passed in line it saves even more code
in this list and set counterparts now
when you have more than ten entries in a
map all the key value pairs would be a
little unreadable if they would if they
were passed without any structure for
the component to check so you use map of
entries rather than map of the map table
of entries is a ver Arc's method but it
takes mapped on entry objects which you
can obtain for maps new entry method
that's another static interface method
on that I already said that the
collections that are returned by these
factory methods are unmodifiable but
they have other interesting
characteristics - let's talk about nulls
it is widely believed that allowing
nulls and collections back in jdk 1.2
was a mistake and no collection type
introduced in java 5 or later has
allowed nulls the obvious reason for
this belief is that nulls in a
collection allowed null pointer
exceptions to surface everywhere the
less obvious reason is that nulls are
useful as Sentinel values in API is such
as map gates and I've got computes
they're also useful as Sentinel values
for optimizing implementations so when
you use the factory methods nulls are
not allowed as list members set members
map keys or map values if you pass a
null to a factory method it'll throw a
null pointer exception and fail to
create the collection
let's talk about duplicates when you
pass values to a factory method it's
probably a mistake if you have duplicate
set elements would you pick a map keys
now ideally this will be detected at
compile time but the values you pass to
a set off and map to off don't have to
be compiled time constants so the next
best thing is for the factory method to
fail faster run time by throwing the
legal argument exception finally let's
talk about the iteration order for set
elements for map keys now for habits for
the hat implementations the order of
iteration is officially unspecified
however it's usually consistent for long
periods of time and over multiple JDK
releases and unfortunately that means
all the dependencies can inadvertently
creep into code and then lots of code
breaks when the JDK changes the
iteration order for performance for
security reasons so a collection
implementations returned by set off and
mapped of make the iteration order
predictably unpredictable
it'll be stable within a running JVM it
will change from one JVM run to the next
but the goal is to toughen up user code
to prevent inadvertent dependences and
have bugs flushed out in development
rather than production this is all along
when not long winded way of saying all
sorts
now to be clear all of this only applies
to the collection implementations
returned by the factory methods no
existing code depends on their iteration
order for pre-existing implementations
are like hash sets the iteration order
is the same as before if you really want
a specified predictable iteration order
use link patch sets and linked hash map
explicitly will break at last we come to
a JDK 10 feature under 20 minutes left
that's fine
local variable type inference will you
all in the keynotes let's look at where
we use type inference today generic
methods and parameters of lambda
expressions most if not all of these
cases removing the type information
makes the code easier to understand not
harder because the original was already
redundant you can see calling a generic
methods you don't need to supply to type
arguments with the diamond operator in
Java 7
you don't need to supply the type
argument to new with a lambda expression
you can omit the parameter type or the
lambda formal
also emitting type information isn't
just about avoiding redundancy in Java
rate type inference can handle generic
method calls that are nested and changed
this is the secret sauce that makes
api's such as streams so easy to use the
cool chaining just works no one is
bothered that the intermediate types
from stream and filter so stream block
and in stream and the type of the lambda
parameter e don't appear in source code
those types are relatively minor details
now it wouldn't be redundant to split up
this call chain with intermediate
variables of type stream block and in
stream but it would certainly add
clutter so given the past uses of type
inference have been winners it seemed
reasonable to consider new contexts for
type inference we were looking to avoid
redundancy minimize clutter and allow
minor details to be emphasized
that's why JDK 10 introduces type
inference for local variables the VAR
keyword bar tells the compiler to infer
the type of the variable on the
left-hand side based on the type of the
expression on the right-hand side this
is static typing without the ceremony
it's not dynamic typing the type of
string list and stream are both known at
compile time and they do not change
after they're declared and I mentioned
in the keynote this is one of the most
frequently frequently requested features
from developers coming to Java from
other languages Scala c-sharp and C++
have this Java is late to the party
because we like to look at how well
features work in other curly-brace
languages first what we saw for local
variable type inference is that once
you've got used to it it's hard to live
without C sharp developers make this
point very forcefully when they come to
Java now I said that var is a keyword
but technically it's not it's a special
kind of type known to the compiler so
you can still use var in method names
field names even local variable names if
you want just can't use var as a type
name
our works with all kinds of local
variable that includes the loop variable
over for statements and a resource
variable in a try with resources
statements in all cases
there must be an initializer on the
right hand side in order to use var on
the left hand side it's not good enough
to assign the local variable on the next
line because that is a slippery slope to
action of the distance where an
assignment is made far from the
declaration now that's not the end of
the world but it certainly trips up
someone reading the code an even worse
kind of action at the distance would be
multiple assignments to the name
variable someone reading name equals Bob
might think the type is inferred to be
string I suppose there's a later
assignment to name this time involving a
regular expression pattern now you
probably do not code like this but maybe
you know someone who does common things
it's important to reuse local variables
now if the compiler you might say why
can't the compiler just find both
assignments to name these are all these
local variables so it's all in the same
method body and why can't the compiler
just compute the least upper bound of
string and pattern that would be the you
might think well great so that would be
object and so the type of the name
variable would be objects wouldn't be
great but maybe it'll be okay however
what the compiler would actually infer
for the type of name is this string and
pattern and comparable and serializable
that is a real type in the Java language
it's an intersection type but it's
almost useless in the real world
by the way multiple assignments to a
local variable also mean it's not
effectively final so it cannot be used
in a lambda expression
bottom line here is that action at a
distance with local variables is bad
idea
declare local variables where you need
them and initialize them immediately
delay their initialization and don't
reuse them that then makes type
inference work smoothly if you want to
use var and it gives you more
flexibility if you want to capture the
variable in a lambda expression and it
makes the method body more readable or
round
okay so we're going to write the
initializer immediately few more things
to be aware of first the initializer
cannot be null because that would let
var in for any class or interface type
at all and that is they'll be useless
second the initializer can't be a lambda
expression or an array initializer they
both need an explicit type on the left
hand side in order to infer their own
type which they then use to validate the
body of the lambda expression all the
values in the array initializer in
addition you're probably wondering if
you can use a diamonds operator in the
initializer you can but the type in
third won't be very good let me leave it
to that
making the inferred type you might be
wondering if var will infer a more
precise type than you would write
yourself as an ArrayList whereas you
might choose to declare it yourself as a
list generally yes it's better to
program two interfaces like list and two
classes like a list after all if the
class adds public methods beyond those
in the interface and the public methods
are really implementation details and
your code using var can become addicted
to them now that's a problem but it's
more the fault of new than a var if a
library makes its classes widely
accessible and doesn't provide any
mechanism for instantiate in them so
that everyone uses new then the library
deserves blame for adding arbitrary
public methods to its classes on the
other hand if a library conceals its
classes and makes objects available via
let's say factory methods that return
interfaces but no one will use new and
var we'll revoir will infer an interface
now let's connect up to something we
said before bear in mind that public eye
was historically the only way for a
class to grant access to its friends and
related packages that's why a class
might be starved full of public methods
to help its friends rather than to
implement a popular interface but with
modules library owners have a new
technique for controlling access public
classes can be placed in packages that
are exported only to friend modules
while interfaces can be placed in
packages exported to everyone there
isn't been no chance of the classes
leaking through to client code and it
means that var can infer interfaces from
the factory methods such as missed off
in the exported interfaces now as I said
earlier some people freaked out at the
loss of type information tell me which
is more important than reading this code
the type of a local variable or its many
more often it's the main because that's
what you need to see flowing through the
method body a type of the local variable
is often just an implementation detail
that gets in the way of seeing the flow
and the name usually encodes some
information about the type anyway hence
my conveniently chose if you choose
reasonable names the resulting code is
often more readable with var than with
explicit types and avoid repetition
between the type and the name and the
brevity of var increases the prominence
of the main
these factors why var is only for local
variables where the use of the variable
is close to its declaration var is not
for fields and it never will be
fields API elements used by code some
distance away from the field declaration
the benefit of explicit typing for
fields is obvious the Javadoc for a
class wouldn't be much help if it said
var for all the fields you have to look
at the actual field declarations to
figure out the type inferred from the
initializer and reading someone else's
initializer is no fun and if it changes
then the inferred type changes to this
kind of instability has no place in an
API so var var is not allowed for fields
the same logic explains why var cannot
be used as the return type of a method
it would make the return type dependent
on the actual return statements in the
method body
walk'n var be used in the formal
parameters of the method the method has
no idea who calls it so there's no way
to infer its parameter types
one final thing about that it says
nothing about mutability the choice of
making the variable final or not in
reality
local variables usually do not need to
be final they are immune to data races
they are the least important place that
we need immutability the only reason
that anyone thinks of a local variable
being final because they want to capture
it in an anonymous class since JDK 8
that scenario is insignificant because
lambda expressions can capture
effectively final local variables where
you don't type fi nal anymore so if you
are wondering where the final var can be
spelled vowel in the interests of
encouraging immutability the answer is
known now we need help with immutability
these fields but that is a whole other
feature for a whole other JDK
if you want to read more about var I
recommends Java enhancement proposal 286
if you scroll through it and read it
very carefully to prepare you will find
a link to an email from Brian gets where
he discusses the design of this feature
the interesting thing to realize about
this email is that it's from December
2016 discussing in this email two
surveys that we ran to gather feedback
on var we're literally thousands of
people responded and still read the
comments a Survey Monkey we started
discussing var even earlier chapter 86
was created in March 2016 this shows
that even if we're shipping the JDK
every six months the features that you
get in a release taken much longer than
six months to come to fruition you are
not getting more features than if they
ship the JDK up in two years but you are
getting greater predictability when we
say a feature is going to be in there
pretty sure it's going to be in
that's right in four minutes and 40
seconds with a small fun feature and
that stands a good chance limpid of that
way of being JDK 11 raw string literals
as you know traditional string literals
are quite limited if you want a
multi-line string you usually
concatenate a bunch of string literals
together with plus if you want double
quote or backslash characters in your
strings you have to escape them and if
your string contains logically
delimiters then you might need a painful
combination of escaping and
concatenation with this sequel statement
we got lucky because the only delimiter
it's using internally our tactics and
single code characters but if it had
double quote characters in it we'd need
to escape them
Wall Street literals are much more
powerful you can spread a raw string
literal over multiple lines its
delimited with backticks so you do not
have to escape double quotes or
backslash characters and if your string
contains backticks no problem you just
changed the delimiters of the raw string
literal to have more backticks
than the string itself you do not change
the string in any way think about that
you can put anything in a raw string
literal even Java code that contains raw
string controls and you never need to
escape it's the only escape syntax
occurs outside of the string and the
boundaries so you can read the string
forgetting that it's in a container
there's a bunch of new methods to help
process the multi-line strings that are
now easier to write with Austria fuels
for example there is trim indent to
remove space in the left margin and trim
markers to remove known markers and
either edge and there's also lines these
are all new methods on string there's
lines which returns a stream of
substrings extracted from the string by
line terminators as you can see it works
on strings derived from traditional
string literals that escape the line
Terminator with backslash n as well as
strings derived from raw string literals
Oh what's here is JDK 10 watts Nexus JDK
11 I invite you to download JDK 10 you
can get it from get binaries from Apple
JDK you can read about local variable
type inference and depth JDK 11 early
access binaries are available too
we have like I say already removed the
Java EE and call the modules and we are
working hard on prototyping a range of
language features I've talked about raw
string literals also maybe switch
expressions search for jets 325 and 326
to read more about that and with that
thank you very much we have one minute
for questions there's lady here with a
question oh yeah
the question is if you save our name
equals Bob can you later on same name
equals for know the type is inferred
based on the initializer exactly is if
you save our name equals Bob it's like
saying string name equals Bob if you
later on a sign an on string 2 name
it's a compile-time error it's all
compile time it's very good this is all
static typing there is nothing dynamic
bar is morally a shorter version of what
you would write yourself notwithstanding
the comments I made earlier about
interfaces and implementations any other
questions one more about 7 seconds each
the question is Nassau is Oracle's
modern implementation of ECMO scripts it
is use two modules in JDK 9 I believe
it's still there in JDK 10 so nothing
has changed as far as the song goes one
more question
your application code almost certainly
is Java 9 and 10 safe I very much doubt
you are using some miss con safe to find
class I very much doubt you are hacking
via reflection into concern crypto
provider like people on Stack Overflow
post questions about doing the libraries
that you use pretty much all of them do
that kind of thing and I cannot say to
you that they will run on JDK 9 I wish I
could and will probably need to upgrade
your spring your j-unit your hibernate
your maven your eclipse and so on to
versions that are nine aware they mail
mean this is not to do with modules they
may or may not be modularized they may
or may not have support for your
application be modular eyes that's a
much longer effort but just to run
online and avoid those errors you will
probably need that's why they check with
the tool and library developers which
versions are nine ready and most of the
big fibers and frameworks are now I
think that is all we have time for
because it's it's yep we're over time
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>