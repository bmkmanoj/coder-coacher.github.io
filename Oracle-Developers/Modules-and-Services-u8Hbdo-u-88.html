<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Modules and Services | Coder Coacher - Coaching Coders</title><meta content="Modules and Services - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Modules and Services</b></h2><h5 class="post__date">2016-09-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/u8Hbdo-u-88" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so thank you for coming this is modules
and services my name is Alex Buckley I
work in the Java platform group at
Oracle with mark and Allen this is the
fourth of five modularity talks at
JavaOne the fifth one is I'm also doing
project jigsaw under the hood in this
room
I believe 4:30 today so modules and
services this is this is going to be
very interesting because this is an
aspect of the module system that we have
never talked about in public before it's
been documented in public there's an
implementation but we've never actually
presented on it or explained the
backstory of how you can use it so
before I get started I would like to do
a straw poll who if I said met rim slash
services who wouldn't know what I meant
a few happy 15 hands ok 2016 hands good
um who if I said java.util service
loader who would know what that is
actually a few more heart that's
interesting a few more hands who know
about the service leader API then the
measure of services that drives it ok um
who has built an application that calls
service loader ok probably the same
hands a little bit a little bit ok so
even in this remain a minority so that's
good so I often say that modules are
quite different than language features
like say lambda expressions lambdas are
about the shape of programs in the small
individual for loops turning into method
calls with lambda arguments you can
reshape a program to use lambdas really
without anyone noticing modules are
about the shape of programs in the large
we deal with classes and packages and
get bigger from there if you reshape a
module it's quite likely that other
people will notice and although modules
are expressed in the Java language they
are in some ways outside the language
they define architecture more than code
I say this because services are the
purest form of architectural
construct offered by the module system
there's something you have to design for
very explicitly it's possible that in
your daily work you will never come
across services but you're here now so
let's talk about three things what
services are what they can do and how
they work behind the scenes so what
services are when we talk about modules
we typically talk about two things
module dependencies and package exports
Java desktop is the JDK module that
contains AWT and swing as you can see it
expresses a dependency on the Java XML
module so it can access all the public
types in the API exported by Java XML
and it exports the java.awt package so
that anyone who requires java desktop
can access the public types of the
abstract windowing toolkit api so the
coupling between Java desktop and it's
its dependency Java XML is very tight if
Java XML isn't found at compile time
then Java desktop on the slide can't be
built and at runtime
if Java XML isn't found then no system
depending on Java desktop can start
since desktops dependency on XML would
be unresolved there's another kind of
coupling between modules that is much
looser it's so useful that we've built
it into the module system it involves
one module requesting and implementation
of an interface that's blue you're going
to be seeing a lot of these colors and
other modules providing implementations
of the interface for example in real
life the Java desktop module can request
an implementation of the print service
lookup interface while some other module
outside the JDK
print lib has some class that implements
print service look up at runtime code in
the Java desktop module can call a
simple standard API to obtain an
instance of print service look up the
instance is of class fast prints in the
print Lib module from the print live
module but Java desktop does not require
print Lib this means Java desktop can be
resolved by the module system even if
print Lib is not present also print Lib
does not export the package that
contains this fast print class fast
prints the class is not an API that
other modules should access directly
other modules should invoke methods of
fast print only through the print
service lookup interface what do the
module declarations look like it's very
simple Java desktop the requester uses
print service lookup and print Lib
provides it with fast prints print
service lookup is the service type the
service type is usually an interface but
it can be an abstract class or even a
concrete class if you really have a need
for that fast print is the provider
class the provider class must be a
concrete class that implements or
extends the service type and declares no
args constructor we say that Java
desktop is the consumer module and and
print Lib is the provider module notice
in Java desktop is very interesting your
scene requires takes a module named java
xml exports takes a package name
java.awt and uses takes a type name Java
X print print service look up three
different properties of a module three
different keywords three different kinds
of arguments
in print lib the provide statement takes
to type names one for the service type
and one for the provider class that's
implementing it this provides Klaus is
the modular equivalent of a file called
Metron slash services slash Java X dot
print da print service lookup that lists
com print lib fast prints if a jar has a
module info dot class file as print Lib
would then any files in Metron services
are ignored the module declaration wins
now just to clarify there's no
dependency injection going on here if
your module let's say o Java desktop if
you say uses s you use some service type
and you have a field of that service
type then it's not the case that an
instance of that type s is magically
assigned to the fields you have to ask
for an instance of the service type
explicitly as Java desktop will on the
next slide to obtain an instance of
print service lookup code in the Java
desktop module employs the service
loader API introduced in Java SE 6 the
key method in service loader is load
load takes a class object representing a
service type print service lookup class
as long as Java desktop says that it
uses print service look up the load
method returns a service loader object
capable of yielding instances of that
service type now there might be more
than one provider module for print
service lookup which means more than one
provider class each instance that
service loader yields of the service
type is of a different provider class
helpfully service load the service
loader object service loader implements
iterable so you can for each your way
through the available instances of these
provider classes looking for one that
you like in this case Java desktop hopes
to find a print service
implementation that offers some kind of
specialist print service involving a
dock lever I don't know what that is but
it's a thing on print services if
printer if service loader yields no
instances of print service lookup or if
it did but none could offer this
specialist dot flavored print service
desired by Java desktop then Java
desktop decides to return some default
print service object now this code would
typically live in a static method of the
service type so that print service
lookup is its own factory before JDK 8
interfaces couldn't have static methods
so most service types were abstract
classes but now that interfaces can have
static methods its more common for the
service type to be an interface and
still offer a static factory methods
such as this at this point everyone asks
if service loader finds all provider
classes that implement print service
lookup and yields an instance of each
one how does Java desktop specify that
fast print is my favorite implementation
of print service lookup alternatively
how does the print live module specify
that my class fast print is the best
implementation of print service lookup
trust me on this the other question
everyone asks is about ordering how does
Java desktop specify that it prefers the
fast print implementation of print
service look up to this net print
implementation at the bottom but it's
happy to run with net prints if fast
print is not present now bear in mind
that provider modules usually like print
live a net prints usually don't know
about each other so they can't
reasonably be involved in selecting or
sorting implementations the consumer
module Java desktop is obviously the
right place to do it
but this discussions around this quickly
leads to complicated schemes that
including code provider preferences in a
module declaration
now we're trying to keep the module
system simple so the answer is you don't
specify a global preference for provider
classes at least not in a module
declaration instead the basis for
choosing one provider class over another
is application dependent it's a choice
the consumer module has to make by
inspecting the properties of available
provider classes and by properties I
don't mean reflecting over their fields
I mean calling methods of the service
type on every instance of a provider
class recall that Java desktop calls the
get default print service method on each
instance of print service lookup and
that makes further calls on the results
to decide if the instance is acceptable
the consumer module should not be
concerned with the identity of the
provider classes their private details
of the provider modules in fact we
strongly discourage provider modules
from exporting the provider classes
because if they're exported it
encourages to peep it encourages people
to code outside the interface and
directly against the provider class at
which point you've lost the benefit of
loose coupling so my advice is to think
of the service type as a slightly
coarse-grained selector a service type
should offer enough descriptor methods
about the quality of implementation for
a consumer module to select the best
provider class for an instance of the
best provider class in our example so
far the service type print service
lookup is a proxy for the real objects
of interest there may be many instances
of print service lookup on a system each
one representing many instances of print
service but able to offer a default
print service to consumers in another
scenario
the service type might directly
represent an object of interest in this
example actually the print service
interface offers possibly a rich enough
set of descriptor methods about flavors
and supported things that it could
perhaps in itself be a legitimate
service type how much abstraction you
design into your service type depends on
the application
the main factor is how heavy the
ultimate objects of interest are for
example if the nature of a print service
at the bottom if the nature of a print
service is that instantiating one might
be slow perhaps because a provider class
might be expected to scan the network
looking for printers the module was
called net print earlier then there's
value in print service lookup instances
to act as proxies or wrappers that
decide whether a print service instance
is actually available but if the nature
of a print service is that it's cheap
and easy to instantiate then the value
of print service lookup as a service
type is diminished it's very interesting
to look at the service types consumed by
the Java desktop module these service
types in blue yep that looks brilliant
in blue are proxies or factories or
wrappers if you prefer print service
look-up is among them the type next to
it stream print service Factory is the
same deal and looking at the top you
would call methods on instances of input
method descriptor in order to find the
instance that offers the desired input
method and you would call methods on
instances of image input stream SPI to
choose one that can best convert your
data to an image input stream that will
be the ultimate object of interest the
Javadoc for the five SPI types near the
top even says the intent is that it'd be
relatively inexpensive to load and
inspect all available provider classes
these classes may then be used to locate
and instantiates more heavyweight
classes that will perform actual work in
this case instances of imagereader image
writer image transcoder image input
stream and image output stream the
service types in brown are not prop C's
but rather the classes for the actual
objects of interest while MIDI device
provider in blue is just a proxy for
obtaining MIDI device objects MIDI file
reader in Brown is real business logic
to provide a class for MIDI file reader
knows how to obtain a MIDI sequence from
a file the bottom line is that the
service loader API is agnostic about the
granularity of your service type which
has the happy side effect of keeping
quality of implementation details and
provider preferences out of module
declarations at this point you're
probably wondering where did the service
types actually live a service type is
just an interface in a package in a
module that package will almost always
be exported from the module so that
other modules can require the module and
access the service type so the service
type is very widely exported it's in
fufu is not a consumer module or a
provider module foo is just the guy
exporting the service type for people to
consume and provide then a consumer
module needs to access the service type
for its uses clause and for the code
that employs service loader to get
instances of the service type a provider
module needs to access the service type
for its provides clause and for the
provider class that implements or
extends the service type in general
there can be many consumer modules or
many provider modules for the same
service type
a consumer module will say requires and
uses while a provider module will say
requires and provides the arrows look a
bit complicated when they're all drawn
out but browsing the source of module
declarations makes it pretty clear what
the service relationships are if you
skim the JDK module summary it's very
easy to see which modules are consumers
with uses and of what and which modules
are providers with provides clauses and
of what that's a major advance over
grapping for service load or load calls
and wondering which jars on the
classpath have files in Metron slash
services all that said it's not
mandatory for a service type to be
defined in a different module than the
consumer modules and the provider
modules in the JDK it's quite common for
a module which defines and exports a
service type to also be a consumer
module for that service type for example
Java desktop exports the java.awt mSpy
package so that other modules can
implement the spi types and act as
provider modules and Java desktop uses
java.awt mSpy input method descriptor to
be able to get instances of those types
of those provider classes many
well-known frameworks in the JDK such as
logging file system and date/time
support this kind of customization via
provider modules that is to say the JDK
modules will will use their own service
type that's then provided by a
third-party it's also relatively common
in the JDK for a consumer module to also
be a provider module for example Java
desktop uses print service lookup and it
provides an implementation in the form
of Sun prints print service lookup
provider this allows the method in Java
desktop that returns print services that
the code before to be assured
that it can always return at least an
instance of some default provider class
ultimately you can see that a single
module such as Java desktop may contain
the service type and the user's clause
to facilitate the code employing service
loader and provides clauses to specify
one or more provider classes I mentioned
earlier that a consumer module should
choose an instance of the service type
by calling API methods on it rather than
reflecting over the provider class
however it's sometimes useful to ask
service loader for the provider classes
themselves not so much because you want
to reflect over their methods but
because you want to defer creating
instances of the service type to support
this use case we've introduced a nested
interface in service load I called
provider when you call service loader
load to get to get a service loader that
that implements iterable you can then
obtain a stream of provider objects and
filter by provider class to your heart's
content
then as shown near the bottom it's only
when you call get on a provider object
that an instance of the service type is
created that's up to you
a quick note a quick note
it's not really that quick but it's a
quick let's say it's a quick note on
documenting services when a user's
clause in blue appears in a module
declaration it's actually describing an
implementation detail of the module
rather like a requires Clause the
modules employment of service loader to
find providers of the used service type
is not part of the modules API in the
way that exported packages are however
it's quite likely that the modules
behavior depends on whether any provider
classes are found and if so what their
characteristics are it's usually
necessary to document the consumer
modules expectations both on provider
modules and on higher-level modules that
require it so a user's Clause isn't
quite as private a detail of the module
as a requires clause similarly when a
provides Clause appears in a module
declaration it's for the benefit of
service loader not for anyone requiring
the module now there are certainly
scenarios where provider modules are not
of general interest such as where the
provider classes implement a service
type that's not widely accessible but
usually the author of a provider module
will want to document something about
their provider class so rather than
relying on the app in pulled out tag
introduced for Java doc in JDK 8 Java
doc in JDK 9 supports two new tags at
uses and that provides that allow
consumer and provider modules to
document their service relationship
so that's part one service relationships
our first class in the module system
programming against service types means
that provider classes can be
encapsulated and many jdk from'
frameworks build on services and are
customized with them let's move on
it should be obvious that services let
you plug in implementations that weren't
known to your program at compile time
for examples that show that I recommend
the Java 9 modularity book available in
early access at the O'Reilly bookstore
in the exhibition hall is sander here
sander
he may even if you go there at 1:30
today sign it for you one thing that's
not so obvious is that services are
actually the key to encoding a number of
sophisticated relationships between
modules that might otherwise appear to
be unsupported by the module system in
particular I'm going to talk about how
optional module dependencies are neatly
encoded with services as an example
consider the Java scripting module in
the JDK it offers an API to evaluate
snippets of code at runtime there might
be many implementations of scripting
languages capable of evaluating snippets
written in their own language such as
NASA on that Oracle's implementation of
JavaScript or groovy or JRuby etc how is
the Java scripting module meant to
depend on them it seems like we need a
way to say requires optional so that
Java scripting reads whichever modules
are available and if none are available
that will be okay the module system
would still start that seems like it's
what we need the trouble with a requires
optional clause other than the fact that
it's an oxymoron is that it only makes
sense when the Java scripting module has
already been built but suppose you're at
compile time
what if source code in Java scripting
refers to a class in one of these
optional modules either JDK scripting
nass horn
groovy script engine and that optional
module isn't present at compile time
it's not acceptable for a Java compiler
to proceed when it can't find classes
referenced in source code nor do we want
to relax the java language with some
form of loose dynamic typing now you can
get a bit further if you never refer in
source code directly to classes and
optional modules and instead you access
them via reflection but that's a very
painful programming style it was how you
had to code on the Java ME platform when
different devices implemented different
API is it doesn't scale the proper way
to program against zero one or many
modules is with services services
introduced a level of indirection by
means of the service type you can
mechanically translate an optional
module dependency at the top of the
slide to a pair of non optional
dependencies on a module which exports a
service type this decouples the number
and identity of provider modules from
the consumer module which is what
optionality is all about and if there is
one slide in this presentation that I
would encourage you to take a picture of
it is this one though many people did
but this this is this this is what
services are all about to be honest
consumer module provide a module service
type indirection
everyone is loosely coupled consumer
module the consumer module is tightly
coupled to the service type module so is
the provider module but the consumer and
provider modules don't know about each
other
that's optionality since Java scripting
is a jdk module it won't come as a
surprise that it's not only the consumer
module but actually also the home for
the service table at the top the Java
scripting module both uses the script
engine factory interface because it's a
consumer module and actually exports its
package and then further down the group
Nass horn and groovy modules in this
example each provide an implementation
of script engine factory the module
system discovers their role as provider
modules during service binding which I
will come on to a little later
now code in Java scripting can employ
service loader to get instances of
script engine factory and call its
methods without worrying where the
implementations come from script engine
factory has many descriptor methods that
let provider classes describe the
quality of implementation of the script
engines that they ultimately offer which
language is being implemented the
version of that language how long the
snippets can be all that kind of stuff
the Java scripting module explicitly
does not say requires JDK scripting as
horn or requires groovy script engine in
fact if you look closely you'll see that
those modules require Java scripting
because that's where the service type
lives in this example but of course the
service type in theory could be
somewhere else in effect the way that
you get optional dependencies is by
inverting them
so that's a short part to service
relationships are the way to encode
module dependencies services give
they're not just loose coupling but
better separation of concerns between
the consumer module and the provider
modules and services are almost always I
mean this should really be obvious
service is almost always a better choice
than messing with a reflection and class
for naming your way around the world and
then seeing what the methods are etc I
mentioned service binding let's talk
more about it you might ask DARS the
module system really need to be involved
in the consumption of service types and
the discovery of provider classes
weren't we just okay with service loader
or on se6 well it's for two reasons and
they should be pretty familiar by now
first services interact with strong
encapsulation just because a module has
a provider class that implements a
service type doesn't mean that the
provider class is widely accessible in
all the examples we've seen a provider
module did not export the package where
the provider class lives that means
there's no access to the provider class
from outside the provider module you
can't new it even if you have an
instance of the service type obtained
from service loader and you called get
class on the instance you still can't
manipulate the instance through the
provider class your code can only access
the instance and reflect on it if it
really wants through the service type to
support this strong encapsulation of
provider classes the service loader
mechanism actually has to break strong
encapsulation it needs to instantiate
non exported classes of arbitrary
modules with provides clauses the
service loader mechanism is part of the
Java base module so it has superpowers
that let it instantiate provider classes
even when not exported
second the module system is responsible
for checking that a module whose code
employees service loader has declared
its dependency on the service type with
users this is part of our reliable
configuration story in general we think
it's good practice for a module to
declare how it interacts with the
outside world
so in particular we think it's good
practice for a module to declare that
it's going to use a service type this
explicit dependency on code outside the
module typically that the service the
service type will be in the different
module is also needed to let the module
system know that it must look for
provider classes at startup and so we
come to the heart of how the module
system supports services suppose your
application consists solely of module a
which contains exports and uses the
service type I at startup the module
system search is the module path and the
Java Runtime image looking for modules
which say provides I with something this
matching of users to provides is called
binding now I'm fond of saying that
while the watchword in JDK 8 was
functional the watchword in JDK 9 is
transitive you all know that a module
relies on everything in the transitive
closure of its requires clauses with
binding the transitivity takes on a
whole new character that's because a
module relies on everything in the
transitive closure of its uses clauses
to when the module system discovers that
B provides the service type used by a it
tries to resolve B that means since B
requires C that means locating C
obviously B can only work reliably as a
provider module in fact
module at all if C is found B requires C
and if C is found its own implementation
may use another surface type so then the
module system should try to discover D
in effect a relies on B and C and D even
though a doesn't require any of them now
you might be wondering if C is not found
then B would not work reliably
we all understand that so why not just
forget about B as a provider module just
unbind be from a we could do that but
it's pretty bad that someone has
presented B on the module path without
all of its dependencies like C so in the
name of reliability the module system
does not ignore B and move on to another
provider if there is one it stops that
sounds a bit negative but it makes for
very reliable execution after the
binding has been completed let's see how
this works from the beginning there will
be more slides like that with pictures
assume there is one route module a the
module system creates a module graph by
resolving a's requires clauses clauses
assume that a requires M and the M
doesn't require anything except of
course Java base having resolved a and M
the module system proceeds to bind
services for them by inspecting their
uses clauses let's say this results in
modules B and n being added to the
module graph B and n each have their own
requires clauses which the module system
resolves let's assume B requires C which
just requires Java base and let's assume
that n requires o which just requires
Java base
having resolved B and C and N and O the
module system proceeds to bind services
for them by inspecting their uses
clauses
this results in modules D and P being
added to the module graph D and P would
each have their own requires clauses but
let's assume we're done at this point
the picture would be more complicated if
there were multiple provider modules for
any of the service types or if there
were more modules pulled in via requires
but in a way none of this is more
complicated than the dynamic linking
that the JVM does for classes it's just
that modules make their linking goals
explicit with requires users and
provides clauses let me go back to this
picture before we try to resolve B and n
rather than be requiring C and n
requiring o let's assume that B and n
just require Java base so we're done
with the requires so with no more light
blue requires arrows to add the module
system proceeds to bind services for B
and n by inspecting their uses clauses
it might be that B and n are not only
provider modules for I and J and maybe
they don't require anything but they're
also consumer modules binding B and n
results in E and Q being added to the
module graph via service binding enq
each have their own requires clauses as
well as their own users clauses but
really this time let's assume we're done
what we've seen is that
configuring a module graph involves more
than just resolution of requires clauses
all the way down in general every module
can have requires clauses users clauses
and provides clauses the basic process
is to resolve all the requires clauses
of some set of route
Jules then bind uses to provides
resulting in more modules then iterate
with the new modules serving as the new
set of root modules eventually no more
modules will be resolved for requires or
bound for users for maximum reliability
we want to do all this once at startup
being able to perform resolution with
binding well in advance of execution is
what lets us if we choose link modules
into a Java Runtime image and optimize
references between byte codes in
different modules and it means fewer
surprises at runtime for missing modules
in line with our goal of reliable
configuration so speaking of linking
modules into a runtime image we found
that services need to be handled
carefully who here has heard off the
j-link tool in other words who here was
in the keynote quite a lot people in
principle the j-link
tool that combines modules into a Java
Runtime image performs the same
resolution and binding steps as the
module system at runtime but experience
has shown that people building a Java
Runtime image usually want the smallest
possible number of modules in it people
were very surprised when j-link
performed service binding that pulled in
apparently irrelevant modules due to
service relationships for example
running j-link for module a could result
in module Q being in the Java Runtime
image that surprised people so as a
result jailing actually does not perform
service binding by default as a
pragmatic matter if you want to provide
a module to be included in your Java
runtime image you need to specify it to
Jaylin
with the command line flag this will
cause the provider module to be resolved
than anything it requires to be pulled
in but then its own uses Clause users
clauses will not be bound to providers
so you might need more command line
flags again that sounds a bit negative
but but it fights bloat in your Java
Runtime image which if you're running
j-link you probably care about a lot
nearly there
let's just finish by talking about
migration for a moment recall that
everything on the class path in jdk 9 is
treated as being in the unnamed module
also recall that the unnamed module act
like it requires all named modules in
the jdk image and on the module path
that's for compatibility for services
the good news is that the unnamed module
with a bunch of jars that are found on
the class path is a provider module
during service binding the module system
scans the meta in services files of
every jar in the class path to see what
the unnamed module provides when a
consumer module employee service loader
to get instances of a service type
instances of provider classes in jars on
the class path will be returned
alongside instances of provider classes
in modular jars on the module path and
modules in the runtime image the fact
that some provider classes come from the
class path is completely transparent to
the consumer module you might recall
that we believe strongly in reliable
configuration and not letting named
modules depend on the arbitrary content
of the class path however in the case of
services we think it's ok to expose
provider classes from the class path
because the consumer module always has
to be prepared for and select from an
arbitrary set of probe
classes if the unnamed module is
actually a consumer module that is code
on the class path is employing service
loader then again it's transparent where
the provider classes come from they
might come from named modules on the
module path or in the runtime image or
from jars on the class path the unnamed
module implicitly has an infinite number
of users clauses so it's permitted to
get instances of any service type such
as those provided by named modules
finally this slide is deliberately messy
to make a point that migration is messy
recall that you can move a traditional
jar from the class path where it would
be in rent to the module path in order
to make an automatic module like guava
on the slide from the point of view of
services an automatic module is very
much like the unnamed module first like
the unnamed module an automatic module
reads all other automatic modules plus
the modules in the Java Runtime image
plus the unnamed module for
compatibility those are the light blue
yep light blue arrows this means an
automatic module is likely to read any
modules which export service types
that's always always always the first
step seconds like the unnamed module an
automatic module has an infinite number
of users clauses those are the dark blue
arrows this means an automatic module
can employ service loader can call
service loader to get instances of any
service type and the provider classes
can come from the class path the module
path and the Java Runtime image third
during service binding the module system
scans the Metron services files of
traditional jars on the module path to
discover what each autumn
module provides those are the purple
arrows the bottom line is that for
services whatever worked on JDK AIDS
should just work on JDK 9 no matter how
code is arranged into explicit modules
explicit named modules like Java based
Java sequel automatic modules like guava
and the unnamed module so I talked about
service binding an iterative process
that augments the module graph service
binding is impressively agnostic to
explicit automatic and unnamed modules
and it's also somewhat orthogonal as an
issue to linking together a Java Runtime
image so in some service relationships
our first class in the module system
with users and provides services give
not just loose coupling but better
separation of concerns stronger typing
and service binding that makes all this
work is agnostic to explicit automatic
and unnamed modules that that's all
there is about services let me broaden a
little bit and talk about JDK 9 in
general the best the single best thing
you can do to prepare for JDK 9 other
than attending all these excellent talks
is to fire up JDK 8 and run the jaidev's
tool which analyzes dependencies it can
tell you if your code or code that you
rely on will be affected by changes in
jeddah k9 such as encapsulating some
types in the JDK please try the JDK 9
early access binaries on java.net the
module system has been present and
active in these binaries since March
2016 plus the Jade EPS tool included in
JDK 9 builds
is more accurate than the tool in JDK 8
two years later everything you ever
wanted to know about the module system
is discussed in jet 261 I cannot
emphasize enough how much valuable
information is in jet to 61
there's also jet 260 which defines the
JDK internal classes that are actually
being exposed in nine jet 223 which
defines the new version strings
beginning with nine dots and jet 220
which describes how our teacher and
friends have gone away
finally jet 200 gives an overview of the
JDK modules but if you've already read
yep 261 which of course you will have
done there won't be any surprises and
with that thank you very much questions
which should be asked from the
microphone or we can't hear because all
the people are making lots of noise is
that
hello hi so earlier you talked about the
situation where there's a partial
compliance with the service right so a
depends or yeah so a wants service is
provided by B uh-huh
but B cannot be fully resolved right
this one yeah so not clear to me what
you meant by the module system stops
because it could be another one II that
provides that service and it can be
resolved yes so so I for simplicity I've
only shown here for any users provide
ivanishin pairs there could be many
provides fuses so it might be the in
addition to be providing i some other
guy provides i and that other guy has
all their dependencies resolved in it's
all greats but this provider be that
were happens to have a lot of
dependencies such as see someone forgot
to put C on the system right so the
question is should we at that point say
okay well B B's dependencies couldn't be
resolved so let's just forget about B
just forget unbind it and just
continuing having bound some other
module to interface I you saw how
iterative this process gets if you ever
think of if you if you dream of
unbinding things you're gonna have to
unwind a lot of previously bound and
perhaps optimized references between so
ultimately all this users and provide
stuff is just set up for a bunch of
invoke interface and implements clauses
so if the question is why don't we just
unbind B when its dependencies fail it's
in the name of reliability who put B you
should never have a module on your on
your module path whose dependencies are
not fulfilled something has gone wrong
it's stupid if B is on the module path
but C isn't so it's not a good thing to
say our B's here but someone forgot to
put its dependencies along with it so
we'll just unbind be perhaps recursively
I mean it gets pretty complicated I
wouldn't say I wouldn't say it's country
I mean yeah well this is the thing I
know I know what you mean but but if B
is on the system without it's hard
requires I mean if B is the thing this
is a great story if B has no further
deposit if this is the thing you know
it's very requires clauses are very
natural things everyone can imagine the
hard by Russians remaining
the hard resolution of classes and one
module two classes in another as long as
they're exported like my very first
slide is great but it's so brittle it's
so brittle and automatic modules help
move towards your requires clauses
working because at least you've got a
target if you're writing a module you
need to require something and automatic
modules give you something but they're
still brittle and then you bring users
and provides into the picture and you
have to work out what the interaction is
and you can see how how complicated it
it gets you can imagine the enemy really
module a is depend is is relying in some
sense on module P a mile away so
simplicity is always the name of the
game but I'm glad you're asked this is a
very philosophical question that I'm
really glad you're asking because this
has been in Chickasaw for some years and
these module dr. I pull them all of them
out of the JDK module summary I don't
need to make up examples it's great you
can go to the open JDK project page for
jigsaw click module summary you'll see
the users and provides clauses so
keeping it all manageable is is a pretty
big goal some sense what I'm hearing is
if we didn't have the legacy issue of
you know older models of then an idea of
world that started off with Java nine
huh we would have probably done away
with hard requires and gone only with
possibly in Java in in a future version
of Java in 50 years time you might
imagine all dependences this okay you
are right but the java that we have in
this century yes what you're really what
you're really saying is the dependency
injection should be standard in the java
language new the new keyword is
injurious because it binds you too close
to a class there has to be expert have
to you down depend on rather than proach
rather than programming to interfaces
and i think i and i and you would all
agree on that
okay thank you hello in so a question
about the way around optional
requirements and the fact that you
instead just say i require a provider
and then i interrogate no no you require
the service i require sort of a service
factory and then i interrogate it to say
hey are you the one I'm looking for
are there concerns about security that
come about from that where I would like
to depend on the Nashorn scripting
engine but I don't want to say that I
require it directly no I I mean but then
I'm gonna look and say are you the
national scripting engine someone else
can come along and provide the script
engine factory and claim to be that and
is there any way to defend against that
no it's it's all you know what's the
walls the statement it has never been it
is it it has never been difficult in any
pro it has never been the least bit
difficult in any programming language to
write bad programs
so the service loader API there there's
no signing going on here there's no
identity of there's no stride entity of
a provider module that gets exposed
through service loader okay service
those a lot load is how would you
describe it mark pleasingly
straightforward
thank you another another aspect of this
though is that we there's been this
assumption for many many years that if
you if you have access to the class path
or the module path when an application
starts then well you better be trusted
because you can put anything on it so
defending against a situation in which a
module path has some you know fake
adversarial you know that not Naza the
thing that's that's pretending to be Naz
horn but is actually evil that's not
that's not an attack scenario we're
worried about we have to trust we trust
whoever's putting the module path
together don't we put models on there
that they trust you know the real
Security's the security concerns come in
when you're when you when you're loading
untrusted code off the internet from you
know and an applet or whatever or you're
letting you know application wire files
in that you might not necessarily trust
completely then the security manager
comes to play and all this other
mechanism but this is pretty much
orthogonal to that okay good thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>