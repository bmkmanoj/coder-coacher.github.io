<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java Flight Recorder Behind the Scenes | Coder Coacher - Coaching Coders</title><meta content="Java Flight Recorder Behind the Scenes - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java Flight Recorder Behind the Scenes</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jIxLwkdtBLc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome we're going to discuss Java
flight recorder behind the scenes my
name is Stefan Larsen I'm the
serviceability architect at Oracle and
by serviceability I like to mean all the
tools and api's that make it possible to
see and manage to JVM so it's a wide
array of things all from debuggers to
jmx to how we do heap dumps the command
line tools and even how we internally
handle core files and tools to to debug
core files and I have to show you this
but not for long so Java flight recorder
it's a tracer and a profiler which shows
detailed information about the JVM as
well as the java application running on
top of the JVM it's built into the JVM
to be as non intrusive as possible and
also have access to as much information
as possible from inside of the JVM
typically flight recorder can run in two
different modes one is the more classic
profiling mode where you start a
recording and then at the end of the
recording you get the data back and you
can visualize it in a UI the other mode
is an after-the-fact kind of mode where
information is stored into circular
buffers continuously and then once you
see a problem for some reason you can
dump this data out and you have now the
information leading up to the problem
that's where the name comes from flight
recorder we first release this in 7u40
about two weeks ago and despite what it
says on the box we are now going to open
up the box and take a look inside it
so there's a wealth of information
recorded by flight recorder from both
the JVM as well as the java application
so for example we have everything about
garbage collections we have not just
that a garbage collection happens but we
have the time for it we have all the
internal phases of the garbage
collection how long threads are being
stopped for garbage collection how many
references there were all that kind of
detailed information is available same
thing with synchronizations of normal
Java locks if you're blocked on a lock
we record that as well there's
information from the compiler on which
methods get compiled how long time it
took and when that happened there's CPU
usage for both the Java process itself
as well as the the whole system we
record exceptions when they get thrown
where and from what place there's IO
information so you can see if you're
blocked on Io for some reason either
file IO or socket i/o if you're waiting
for a connection somewhere but there's
also a sampling based profiler built in
which so shows you where you're spending
your CPU time so every now and then we
stop threads we take a sample and we
then visualize that information since
flight recorder is designed to be
running it at all times in an always on
mode it's very important to keep the
overhead down so typical overhead that
we see in benchmarking is around two to
three percent although it can be very
hard to measure and it also depends a
lot on the application that you're
running but often i think it's not very
noticeable in production environments
you can also turn it on and off in
runtime and when it's off then it's zero
the reason we can make it so cheap is
that much of the information that we
want is already available inside of the
JVM and there's no cost or very little
cost in just
posting that information recording it
for example the garbage collector it
already knows all of this data
internally so it's built into the JVM
itself the core of jay far that means it
can easily interact with other
subsistence of the of the JVM most or I
wouldn't say most of the code actually
about half of the code is in C++ and
half of the code is written in Java
which is more supporting functionality
it's about twenty thousand lines of code
total about half Java half C++ I talked
about the two modes so the usual mode
for doing profiling is on demand profile
you typically use Mission Control or you
can do this from the command line as
well you connect to the JVM you ask it
to create a recording once the recording
is done it's transferred back to the UI
and you can visualize it there when you
start a recording you can easily
configured how much information you want
to capture so if you want to have a
larger rope or if you if you want more
overhead and are willing to take a
larger overhead you can add more details
to to the recording but when it's done
the overhead is gone Mission Control
provides the powerful UI for visualizing
the data where you can see the data you
can correlate it you can plot it over
time and dig into it in many different
ways in the other mode after the fact
mode the data is recorded into set of
circular buffers and once you were your
monitoring system detects that there is
a problem in in the application you can
dump out the data that you've stored in
these circular buffers and now you have
the information leading up to the
problem instead of as usual you detect
the problem and then you start digging
in
and start recording information and and
that may be too late so I'm going to do
a quick demo of how you start a
recording and take a look at it inside
Mission Control I hope everyone in the
back can see this I don't know how to
make it larger but unfortunately this is
what Mission Control looks like when you
start it yeah on the left you see the
processes that are currently running on
the system I started with the program
here called GC which is the one we will
be looking at we start a flight recorder
but flat recording by public clicking
here except it didn't really work think
I need to restart Mission Control jamesy
and we wish for the best
maro I have the GC application I think
this might be the problem maybe
no connection refused to house restart
the GC application as well I mean what
could go wrong when you do demos live
stop
start the GC application we wish for the
best it sees it there you go thank you
so starting a recording you can give the
recording a name if you want you can say
how long time you want to record say 30
seconds in this case and you can select
how much data you want to record there's
a lot of more detailed settings you can
do here i'm not going to go through them
but essentially you can drill into very
detailed settings and say exactly what
information you want to have included we
started recording and what happened now
was that Mission Control connected to
the JVM told it to start a recording and
we can see down in the bottom or the
people up front can see in the bottom
that there's about halfway done with the
recording once the recording is done
it's going to be transferred back to the
Mission Control and open up in the UI
we'll just have to wait for that to
happen I could cancel the recording and
I would do the same thing
so here's the data back in in Mission
Control at the very top we see an
overview of the whole recording the red
bars here indicate where there's
information in time in the recording we
get some summary information about the
recording and here's a little graph of
CPU usage and heap usage for this little
program we see the the GCS as they
happen but it's a very uninteresting
little program I was running so I have
prepared another recording which has
more data in it more interesting to look
at so we'll open up that up as well so
this recording was done on weblogic
server using the metric demo application
and show some some more details now we
see the CPU usage is more interesting to
look at we see that the blue is the JVM
cpu usage and the orange is the total
for that machine there's looks like
there wasn't anything else running on
the machine when we did this we can
switch over to see he pees heap usage
CPU usage we see the heap growing over
time and all the fuzziness you see on
this line are all the garbage
collections that that are happening we
can also see some information about the
JVM we see all the command line
arguments we see the version we see
system properties for the process all of
that kind of information is recorded as
well if we switch over to the memory
view and take a look at garbage
collections in more detail this graph
shows us that if you can see the blue
line is heap heap usage and these red
bars represent the garbage collection
poss times so we can see over here that
we have a very long past time about
can almost and down here we have a list
of all the garbage collections and we
can sort on the longest pause we see one
that has a 944 millisecond pause and for
that select the garbage collector we can
collection we can drill into detail here
about we can see all the different
garbage collection faces a long time
each one took this can be very useful to
to kind of identify why this garbage
collection took so long we also see the
heap usage and the permanent generation
usage if we switch this to show us the
reference objects so that's Java lying
ref reference objects a weak references
final reference soft references we have
a graph here showing them we see there's
a there's a big spike over here and if
we zoom in to Dan and we can kind of
flip back and forth between the garbage
collector view and the reference object
view we see that these typically
correlate and that could be the reason
that we saw the garbage collection time
being so long here about one second is
the the amount of reference objects that
were on the heap at that time so that
just shows you some of the use you can
have all this information we can also
switch to the code view and this is
where we see the profile the sample
profile of the application in this case
we see one method here having about half
of the samples and clicking on it we can
see the stack trace for for that for
these samples
we can also see exceptions we see
there's about 300 exceptions of a some
parser look ahead success exception that
doesn't sound like an exception but not
my application on the thread view we we
can see at the bottom here the number of
threads over time we can see thread
dumps taking regular intervals during
the recording something you can
configure how often you want this to
happen digging into a lot of the details
we have the events list at the bottom
which shows all the here's a long list
of all all the events as they happened
it's it's every every piece of
information that's available in the in
the recording we can also graph them
over time something like this so we see
here one line for each thread and we see
where there's something happening we
zoom in on on a thread here we see for
example this red part here is that
thread being blocked on a Java monitor
so trying to take a Java lock and being
blocked on it we see the stack trace
when that happen I think we also see
which thread this is actually holding
the lock at that time
and so as you can see there's lots of
detail in here there's it's a very
powerful you I to dig into and correlate
information I'm not going to show you
all of the these things in I hope you
can drill into it yourself there's a
very good online help facility inside
Mission Control what I am going to show
you is how to create a recording from
the command line instead of doing it
from inside the Mission Control for
doing doing that you use yeah so there
is some memory overhead for for the
process where you record the data but
after the recording is done it sells out
to a file and then that file is
transferred back to Mission Control and
it and the memory footprint of the
process you were recording is not
affected after that sorry yes we can do
that as well we have some question at
the back
right so the question is if if you can
do this remotely which was kind of the
same question I had in the front here
but I didn't repeat it yes you can
connect over jmx to do this so it works
remotely as well yes you can do it on
the fly you have to i'm going to show
you a little bit later do you have to
pre configured at the am that you want
to record you have to enable flight
recording in it you don't have to start
a recording but you have to say that I
want this to be possible in the future
so for record I'm sorry another question
can you compare recordings currently no
but it's high on the wish list so to
create a recording from the command line
if we already have a JVM that's running
that we want to record we use the J
command tool if you don't if you're not
aware of it J command it by default just
lists the processes that are available
but you can also ask a process for
example the GC process for detailed help
what other commands are available so we
see here that there are a couple of
flight recorder commands and for example
there's a j4 check command if we if we
run that against our process we see that
there's currently no recordings running
but that we can use JFR start to start
one so J far start a one minute
recording and I want to save it in the
file name gcj far it has now started
recording and we can check that with a
check we see a recording running and
once that has finished the data will be
available in
the ad GC JFR file we can actually stop
the recording prematurely and if we
check back now there's no recording
running but we have one created here on
the file system it's 128k that this
little recording of course the size of
the recordings can vary widely depending
on how much is actually happening in the
application and how much data you have
have enabled
so so you can compress the recording and
that essentially does a zip of the file
but it has some overhead because we have
to do the zip in in terms of CPU usage
overhead so usually if you're not
constrained by a disk space then I
wouldn't recommend using it you can
always zip it afterwards I mean it's a
it's a file you can zip it you can
transfer it somewhere else on zip it and
open it in Mission Control if you want
sorry yes but so it's a trade-off right
you trades file system access to 4
processor usage I so so I I did right
when I you see the cgc here that
represents the the process I want to
talk to I wanted to talk to GC program
that's the name of my program I i I'm
sorry I kind of glossed over that so
yeah no sorry when I when I listed the
processes here I can I can either
specify the the process identifier or I
can specify the main class name it was
just simpler to write decedent to write
them sorry okay so that's the end of the
demo part wanted to move back to slides
I'm going to discuss a little bit about
some configuration options and then
we're going to look at the
implementation details so here's the the
the most important option is at the top
unlock commercial features plus flight
recorder you need to specify that in the
vm that you want to connect
to and create recording otherwise JFR
won't be enabled unlock commercial
features yes this is a commercial
feature it's free for development but we
charge for it in production don't ask me
about the price don't know anything you
can start a recording from the command
line when you start the jvm with the
start flight recording option or you can
you do it later with Jake man or of
course from Mission Control as we saw
there's a ton of other options that you
can specify on the command line I'd like
to refer to the user guide or reference
guide for for this but typically for a
for recording you if you have have you
have a recording that isn't time bound
that's running forever so to speak you
can specify the maximum amount of data
you want to capture either in terms of
age of the data so you can say I want to
capture the latest 20 minutes of data or
you can say i want to spend this much
this disk on this recording so i won't
spend 2 gigabytes of disk for for this
data you can also tweak some other
things like the maximum stacktrace depth
its defaults to only 64 frames but you
can bump that up to 2,000 frames if you
want you can say that you want the
recording to be dumped when the JVM
exits otherwise the data is lost for
that particular JVM other some logging
if you're having problems with the other
options maybe that will help there's a
repository path here the repository is
where j far stores its temporary data
while the recording is being created you
can store that somewhere else if that
makes sense by default it's in the temp
directory a recording can specify
exactly what information to capture as I
said there's currently about 80
different events that can be captured
each of them have around three different
settings so there's a lot to be
configured if you really want to
otherwise we have to
preconfigured settings default setting
which provides us much information as
possible while keeping the overhead down
to minimum there's also profile setting
with larger overhead but also more
information you can configure your own
favorites for this in Mission Control
there's a UI for saying exactly which
events you want to capture you can also
run many different recordings at the
same time on the same jvm it's useful if
you've set it up to have a continuous
background recording but you also want
to do a little profile recording now and
that works great the only caveat is that
if you have multiple sessions at the
same time each one sees the union of all
the settings so if an event is enabled
in one setting or in one recording that
all the recordings will see that event
during the time that recording is
running that's just to make our
implementation a lot simpler because
while we're already capturing the
information why not just dump it out for
everyone you can filter out later if
you're not interested in seeing it so
inside the JVM and every subsystem and
the JVM has instrumentation calls in it
so the compiler the garbage collector
the runtime we all provide data to jay
far there is also a java api that
provides information from java
applications the data is stored in
threadlocal buffers once these fill up
they are transferred to a global buffer
and then eventually they end up in a
binary file format on disk the whole
thing is managed over jmx as we talked
about earlier so that's what Mission
Control uses to connect to the JVM and
start a recording inside of jf are the
most important concept is the event
everything is an event so an event is
some piece of information
that we want to capture at some point in
time and this is the memory layout for a
for an event it's got a header and then
it has the payload and the payload is
what's specific for the event so a
garbage collector event has a different
payload than a compiler event for
example in the header there's there are
fields for the start time of the event
the end time of the event the thread
that happened on and optionally the
stack trace of the other event yeah
technically yes supported no as I said
there is a Java API but we don't support
it we don't document it yet that
certainly something that's coming there
are three different kinds of events
there are instant events which captures
some piece of information at a single
point in time so for example a thread
starts there are duration events that
captures a timing for something like a
garbage collection which ought to start
time and an end time and then request
able events which is something happens
with a certain frequency like capturing
the CPU usage every second for each
event we also have a some metadata so
not so every event has a name it's got a
path there are they are organized in a
hierarchy and it also has a description
and the same thing goes for every item
in the payload the payload items can be
any data type but they also carry
information about the name of each field
description and a content type which
describes the content of the data
speaking of content types this describes
the semantics for that value in the
payload we use it to correctly describe
the data in the UI so that Mission
Control knows what to do with this data
for example if the value describes the
number of bytes Mission Control could
discrete
just display that as four megabytes if
appropriate if it's an address in memory
displace it in EXO decimal if it's
milliseconds you can see it in
milliseconds or if it's a large value
maybe it this place is a seconds instead
so digging into the cold and hot spot
this is what you do to to define an
event there's a little snippet of XML
you have to write that specifies the ID
of the event some these are them the
metadata for example the label is what
shows up in Mission Control later if you
look at that particular event it would
say javathread sleep and the value is
the payload so in this case there's only
one payload item field called time which
is in milliseconds and that's the time
that the thread requested to sleep the
XML definition is preprocessed into c++
classes so once you write the code in
hotspot you use this c++ classes we see
here this is the JVM on the square sleep
function which is what get called when
you call thread dot sleep in Java we
create an event we do the actual sleep
then we set the payload item and then at
the end we commit the event and once
it's committed it's part of the JFR
stream and now it's available in the in
the recording a slightly more complex
event thread Park part of the yo you to
concurrency package this event has three
different fields in the payload and it
records the class that we parked on a
timeout and the address of the object we
parked on slightly more complex code to
record that event but following the same
pattern we create the event when we
create the event the constructor takes a
timestamp we have an if statement here
for checking if we really should commit
this event because we don't want to do
all this work inside if statement if
we're if the event isn't in a
at all but otherwise we set the payload
items to class the time out the address
and then we commit the event and now
it's part of the j4 stream this is what
thread park would look like maybe in the
recording the gray things here are when
the thread is that thread is being
parked and if you drill down into
details for an event you would see
exactly those payload items that we
talked about start time end time the
duration what class we were parked on
how long it took and the stacktrace when
thread park was called so how did these
end up in the recording the first step
is recording the events in threadlocal
buffers let's to avoid as much
contention as possible because there's
lots of events being created once a
threadlocal buffer fills up its
transferred to a global buffer still in
memory in the JVM there's some
synchronization happening there but
hopefully not all threadlocal buffers
fill up at the same time so there won't
be much contention on that
synchronization and then when the global
buffers fill up we spit it out to to
disk and the disk repository is
organized so that we can have a circular
view of it we have little chunks of
information we can delete the oldest
information and keep the newest
information in there because we record
so many events so much data it's
important to filter the data as early as
possible so we don't end up with too
much information in the file that's why
you can enable and disable events before
you start the recording you can also
specify threshold for for events so if
this event takes shorter than a
specified time we won't even record it
we'll throw it away typically if if
you're being blocked on a on a lock for
a very short period of time you don't
care about that information but if
you're blocking for a long time that's
very important
you can also enable and disable the
stack trace for each event the capture
of the stack trace that saves a lot of
space and some overhead if if you're
worried about that and you can also for
some events you can specify the
frequency how often you want to do a
thread dump for example the file format
is self-contained everything that's
needed to parse an event all the
metadata is stored in the same file that
means that if you add new events to the
two hot spot you don't have to do
anything in Mission Control you don't
have to change anything in the in the
code or do some configuration but it can
instantly read the information from the
file because it's all described in there
the file is the file format is designed
to be fast for riding out data we don't
want to cause any problems for the JVM
when it's writing the file and it's a
single file it has no definition so no
dependencies on anything else you can
grab that file transfer it to another
computer open it up in Mission Control
there if you want to do that so creating
something like flight recorder in a
dynamic runtime such as a JVM is has
some problems for example we we can't
leak memory in any way we can't
aggregate information for forever we can
certainly not keep references that keeps
the garbage collector from doing its
work it's also dynamic so that class has
come and classes go same thing with
threads they come and go all the time we
can't depend on a class being along or
being around forever so we're going to
look at some of the problems that causes
and some of the solutions we've come up
with one problem we have is that many
many events reference a class in some
way and if every event that contain if
every went that reference to class was
actually stored with the class as a
class name as a string in the event we
would waste a lot of space the solution
to this was to come up with
class IDs so every class now inside of
the JVM has an extra field because
called the ID of that and what we record
in the recording is just the ID of the
class yeah yes yes I can I can totally
see the usefulness of having a class ID
for other people as well and I think
that's something we should look into but
so far it's only for J far exactly
I'm coming to that I'm glad you asked so
the IDS that we have they need to be
part of the file as we as you just said
we need to write out this map from id2
to class name but the first problem we
run in run into is that the classes are
unloaded at any time so we can't wait
until the end of the recording to store
this information out instead we we would
want when a class is unloaded we store
that information for that class at that
point in time next problem we have is
the size on this class list for the
first thing is many classes are loaded
in the in the jvm and it's it's forever
increasing the number of classes but we
only reference a couple of these classes
maybe probably not all of them so to not
write out all of the class information
we tag a class when we first touch it
from from JFR and we store that tag as
you can see at the bottom here as the
lowest bit in the trace ID we looked at
earlier that's why it can't be available
to anyone else because we use not well
we reuse that data structure for other
things as well so far we could use a
another bit for storing that so now when
we want to store out the class list we
only store their classes that are that
have this tag in them that have been
tagged by jay far but over time many
classes will be tagged and the class
list we'll just keep increasing so the
solution here is to reset the tags every
time we write out the class list so
every now and then we will dump this
list of classes and we will reset the
tags and then new data after that point
we'll tag the classes again and then we
will write out the new class list later
on so we call this a checkpoint when we
write out the class list and a recording
can have many of these lists or classes
over time but they only there are
classless only valid for the data
immediately preceding
in the file yes I think it is
no it'sit's this is a JFR terminology
checkpoint I know that there are other
usage of same term we should have come
up with something our own so the class
list that we just described is actually
just a special case of something that we
actually call a constant pool internally
if you are familiar with the bytecode
specification you you know one of
constant pool is but we use the same
technology that I just described for
classes for methods for threads thread
group stack traces and strings as well
so we have this these little look-up
tables for all of these things and as I
said a checkpoint is created at regular
intervals in the recording it has
everything that's needed to to parse
recording up to that point and so it
includes both these constant pools as
well as the metadata we talked about
earlier which describes the thread or
sorry an event and describes the payload
of that event so you can actually parse
the event there can be many checkpoints
in a j4 file but each checkpoint is
anyway self-describing or self
referential briefly touch on some
optimizations we've done so typically
JFR takes lots and lots of timestamps
taking a timestamp is kind of expensive
not to say it very expensive if you take
lots of them please and not only do we
take a timestamp for every when event
that we store we usually take two one at
the start and one at the big and one at
the end and we discuss the thresholds
earlier so many of the time stamps we
take we actually throw them away after
because they were just a short amount of
time so we actually throw away the data
that means even more time stamps that we
do so we won processors where these are
available we use the CPU invariant TC
tsc instruction to take a timestamp
and keep them synchronized across
sockets each event stores a thread stack
trace but it doesn't actually store the
stack trace itself it's the only stores
an ID of a stack trace we have a pool of
stack traces just like their constant
pools for classes because stack traces
are repeated quite often typically the
same event will have the same stack
trace quite often in a recording so
that's a way to save space in the
recording and if you are familiar with
jrockit you would recognize flight java
flight recorder as being the j rocket
flight recorder previously some of the
things we've changed our we've added
more information for i/o events so we
now record a file path and the socket
address we didn't do that in jail rocket
we have added information for exceptions
there is now a reverse call trace view
in mission control so you can start from
the top of the application you can drill
down and see where you're using cpu in
the and the other way it's much easier
to configure a recording from inside a
Mission Control you can create these
templates of what information you want
to want to capture as I mentioned you
can configure this stack trace depth you
can do that in jail rocket but most
importantly there is lots of internal
JVM differences between J rockets and
hot spots so for example the garbage
collector works in a different way and
obviously that means we record different
information for garbage collections so
it's not it's not exactly the same
information that we capture if you want
to find out more a couple of URLs I'm
sure the presentation will be available
some fun some somewhere afterwards I'll
wait for someone to snap a picture
anyway there's lots of information to be
gathered here what I really want you to
remember these two options without them
you have no access to flight recorder
you need to specify them on the command
line before you start JVM unfortunately
yep correct yes yes yes you can
obviously in if you look in the hot spot
source code you can see all these probe
points and the other parts of the like
in the garbage collector you can still
see the pro point and if you run an
openjdk compiled version you can have
that information dumped out to standard
error like a logging see the information
is kind of there but a lot of the more
advanced features that's that's internal
for JFR I'm not part of openjdk
so so yes if you enable it there will be
some memory overhead we will create the
thread buffers for example the thread
local buffers and I can't remember
exactly how large there are they are but
it should be in the documentation what
the default sizes you can tune that if
you if you want to have them smaller but
that's the only overhead you get for for
a name it's a bit of memory yeah you
said filtering on packages of classes or
anything to record events for my company
classes so the question is can you set
up filters and only record information
for certain packages Java packages and
no you can't we record it for for
everything I don't know if maybe we
should provide more filters it's a it's
difficult to know if that adds more
complexity to the hot path now we have
to check for list of packages instead of
just checking a boolean if it's enabled
or not so it might not be a good idea
you can filter it later inside the
Mission Control you can filter out
everything else then what you want to
see ah sorry yeah yep
so the the max size and Max time
parameters today mean that we use more
memory or less memory or are something
like that so and no they don't use more
or less memory inside of the JVM they
just control how much space on disk here
you're using so if you say I want to use
lots as based on yes we're going to use
more disk space but otherwise not yes we
had something yes
how do you justify more thing jbm but I
come to arrive
how do I justify changing the JVM for a
commercial product we can I don't know
if I need to justify that it it has been
reviewed in the open process that change
as i said earlier on the question there
we would like to make that exposed to
other people as well of course we could
have made a much more complex
implementation so that that change for
example would not have been part of the
OpenJDK not sure anyone would have
thought that was a better solution to to
it yes over there is there any alerting
mechanism in Mission Control yes Mission
Control is actually two things are there
are two parts of Mission Control one is
visualizing flight recorder data what
we've been looking at today the other
part is a jmx console which shows you
live data coming through jmx from from a
java process and in that part there is
an alerting mechanism you can set up
triggers like if the CPU usage is higher
than ninety percent for more than 10
seconds then please send me an email or
something like that yes yes
so that's a good question let's start
with the visual vm jconsole and Mission
Control which are the big things I mean
there are lots of command line tools and
I'd love to make it a more coherent
story for those as well and we working
on that so currently visualvm is an open
source product fraud project that we
bundle into the into the JDK and
internally to oracle there's not a lot
of resources assigned to that project
but there are some jconsole is an ass
also open source and the source is part
of OpenJDK internetu oracle there is no
one assigned to well I am but I'm not
working on it that much Mission Control
is not open source it's a commercial
offering and we have lots of people
working on it for obvious reasons one of
the things I mentioned in my talk
yesterday was that we're thinking about
deprecating jconsole moving that out of
the OpenJDK project to its own project
will still be available if you want it
you can just get the source and compile
it it's all java code it's not that hard
to compile it but just because making
the story a bit simpler about what the
tools are yes
okay so I said that a JFR was
sample-based but I also showed the
instrumentation I'll start holding up so
yes it's sample-based for the CPU
profiler but for gathering information
from the JVM it's not sample-based it
it's something that we are thinking
about adding actually to the
instrumentation is sampling of the
instrumentation if you can think about
combination like take take the garbage
collector we don't we don't want to
record every garbage collector but only
every tenth garbage collection it's not
very good for garbage collection but for
other events that are very high
frequency could be good to to do that
kind of sampling of the instrumentation
but it's there's something I was talking
about this for the CPU profiler where
every now and then we stopped the Java
threads we take the stack trace we
record our information so you get
yes so for some events it make sense to
reduce the sampling like for the
profiler you can it's I think it
defaults to 20 milliseconds that we
sample that and you can change that
frequency if you want to have less
overhead you can increase it if you want
have more details and some of the other
informations like CPU usage I think we
record every second you can play with
that as well oh yeah thread thread dumps
yes that takes a lot of overhead so you
can I think the default there is just to
record one dump for every recording and
you can change that if you want more
information or you can disable it if you
want less without
yes yeah you can you can configure it
that way there are different events
different kinds of information yes oh no
no no it doesn't reach a save point so
it just stops them yes without save
points and then it tries to make sense
make sense of the stack and sometimes so
it's very defensive defensively written
if it can't make sense of anything it
just stops and doesn't care about that
thread moves on to the next one get call
trace yes it's still in there has it
ever been part of documentation ok cool
ok they use similar paths yes it's not
exactly the same thing but yes
yah our local paper as a no into the
bhagavata his they follow performance as
the recent second is that you have
josh's unit a tree
so the first question was that elaborate
way we have of caching first things in
thread local buffer standing global
buffers and then to disk is that in an
optimization or a performance overhead
reduction thing yes it's it's it's to
reduce the overhead as much as possible
make it the data flow faster through the
system or with less overhead through the
system the other question is what
happens if the JVM crashes to that
information well it's part of the core
file but there's no information to
actually get to it we're thinking about
writing tools that can dig out that
information from a core file and and
create a recording from that but we
don't have that yet theoretically yes
not sure I want to do that not from a
debugger yeah
send me the core files yeah that'd be
great yes yes correct well thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>