<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Easier Messaging with JMS 2.0 | Coder Coacher - Coaching Coders</title><meta content="Easier Messaging with JMS 2.0 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Easier Messaging with JMS 2.0</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tiobrhtQ364" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you very much for coming to this
talk on JMS 2.0 or James to point naught
as I say as I call it but I don't think
the word I've been told that the word
naught isn't used very much in the
United States so you have to bear with
me
it means zero so I were Oracle where I
work on the JMS team working on both
GlassFish and WebLogic but more
significantly I was the specification
leads developing JMS 2.0 which was the
latest version of JMS which was released
in June this year not long ago as part
of the Java EE 7 platform I'll be
showing you how to use the new features
of Gemma's tip on naught and how a make
how this new version of German makes it
easier to develop applications that use
JMS for messaging
I'll also be telling you about some of
the other features of Gemma's 2.0 please
read carefully this disclaimer from my
employer you'll see quite a few times
this week and I think the joke is that
it means basically you shouldn't believe
a word I say I'd like to start with a
quick advert for a off session
I'm giving jointly with another member
of the German expert group John Hammond
tomorrow at a +5 just in the room next
door and that'll be an opportunity to
give feedback on this new version of
Janus and to have a discussion where
about what possibly should go into
future versions of Gemma's but today I'm
here to talk about what we actually know
I'm pleased and proud to say we now have
which is a new version of the Java
Message Service so let's just remind
ourselves what JMS is but basically it's
a Java API for sending and receiving
messages in enterprise systems it's an
API like obviously all the Java
specifications which has again like
other specifications it's got many
competing what many implementations
which have both effectively are
competing
and there's two variants of it there's a
variant which is basically part of Java
itself
so designed to run in Java environment
but possibly unlike some of the other
Java specifications it's also defined
deliberately to be used in purely java
SE non sort of Java interpretations and
there's some subtle differences between
the two which I will mention from time
from time to time there's certain
features are available in one
environment or not the other they're
essentially they are the same API they
obviously they're the same products and
they're the same so essentially the same
API yes I just mentioned just a few of
additional features you get when running
in Java EE obviously Java EE gives you
lots of other features but things like
transactions mister driven beans and
some new injection features that I'll be
talking about the Serge Amos is an API
it's just worth remembering it's not
itself a messaging system you know you
need the implementation to to have that
and it's not my practical as well it's
purely an API Java API that that you use
when you're writing your applications
I said Java quite a few other quite a
few messaging systems have other eight
other language clients for them
C++ readin HTTP outbred of things like
that but gems itself doesn't talk about
that gem is purely concerned with the
Java API and it's covered and it's its
focus is has always been and it remains
the time being an API for writing
applications it's not an API for
administration or management or
monitoring though all vendors offer
features in that area but the
specification of the standard feature is
aimed actually making the application
itself portable by using a standard API
okay quickly where did we where we come
from to get Germans to point naught well
Jamis has been quite a long established
standard it's been around for since
Dorothy in the last century like Java EE
generally but perhaps unusually the last
version of JMS was in 2002 11 years ago
and
it's very likely so it's one of those
when situations where I didn't have to
ask people that last last year I don't
have to ask people which version of JMS
they're using because people until June
people would basically all be using
Jamis 1.1 genis wants one put on a very
successful api with dozens of
implementations both open source and so
close source you know from the large and
very small vendors but now we've got
Gemma's 2.0 first update for over a
decade launched the actual process to
create gems to point naught was launched
a little over two years ago through the
Java community process as a Java
specification request and it was
released in 2013 this year as part of
Java 7 as its earlier we say it's it's a
the first implementation that you can
actually try out and use is open message
queue which is the gems provided within
GlassFish the Java EE 7 application
server but I know that there's other
implementations now the specifications
being published there's other other
vendors and developers are producing
implementations as we speak so let's
talk about gems to point naught and
what's new in it well I hope the title
of this whole session
shows that the basic goal of it is to
make it simple and easy to use but
that's not the only thing it's happened
in Jerez tip or naught there's there's
some new messaging features I mean
there's been no updates for ten years
there's a bit of a backlog of requests
for that and some sort of non-functional
improvements with this better
integration with Java EE there's some
slight with which I'll go through later
and inevitably there's some Corrections
and clarifications compared with what's
there in gems 1.1
okay so now going to focus on the
changes we've made to Jamis made in
Gemma's - point naught to make it
simpler and easy to use and just want to
say in making Gemma simply used to use
we've adopted a sort of twin-track
strategy because this is a standard
we've because it's a standard we always
have constraints in what we can do
because you just simply can't you know
there's all there's thousands and
thousands of applications out there
already using JMS 1.1 and you don't want
to break them when gem when they move to
Germans to open or you know you don't
require applications sudden being
rewritten to move Germans to put not
what that would be sort unacceptable and
that would sort of be breaking the
backward compatibility guidelines for
requirements for Java EE application
generally so that's been a constraint to
watch how it can be made simpler and
I'll be talking just in the moment on
why it needed to be made simpler but
essentially the twin-track strategy is
to improve the existing API in a way in
a more in some modest areas in ways
where it doesn't break compatibility but
there's always a limitation to how much
you can improve an existing API so
there's also a new API made available in
gems 2.0 which we're calling the
simplified API which is designed to be
simpler to use and it basically it
requires fewer objects and I'll be
talking more about the objects that it
that it uses or the interfaces that he
uses so big so basically the big new
features I'll be talking about today are
these new objects these new interfaces
that you can deal with they're
simplified these are JMS and another new
feature I'll be talking about is the
ability first time to be able to inject
basically effectively gems connections
into your application if you're running
writing Java EE application that again
will just remove the amount of code you
need to write there's a danger of
sounding slightly negative I just like
to explain why I'm talking about
simplification all the time why did you
miss one point one need simplifying
well this isn't code that long dust and
I just like to just go through this as
an example of not too much detail of how
you use the JMS 1.1 API just to send a
single object and just this example it
could be a session bean it could be
servlet
I think perhaps a session bean perhaps
think about that though it could be the
what it shows is generally the same in
sort of knowledge Java applications but
it's just really just look through that
to me
yeah well it's a Java EE application so
right the top there's two lines where
the address or sanitation is used to
inject CMS connection factory object and
the JMS queue object where at your
connection factory object I mean these
are both familiar concepts to people who
use Jamis 1.1 and connection factory
opposite the starting object that is
used to create connections and the queue
object because there's also topic
objects obviously represents the JMS
queue to which you want to send the
message but the the main thing I'll just
wants to show you there in the body of
it is the code to actually create the to
send the message and I think the main
thing is want to preserve is it's
actually quite a lot of code just to
send a message so let's just let's just
quickly just go through it so to send a
message you need to create no fewer than
four objects which have some highlighted
in red here and the code that you use is
Beit is essentially boilerplate code and
I think you perhaps heard in the keynote
yesterday that you know in other areas
of Java
you know there's often too much
boilerplate and it gets in the way of
you know keeping your application simple
and in this case you have to create for
objects send a message from the
connection factory that you've injected
you need to create a can connection from
the connection object units create a
session from the session object you need
to create the message producer and since
we are sending a strip our position have
said that the purpose of this method is
to send a string as an object to do
German
that's partying as the parameter which
is called payload there and but since
we're sending a string what in GMS the
way you send strings is to create a text
message so there we are the fourth line
in red is the code to create a text
message that wraps the string payload
and then we've got all the objects in
our hand that would actually call the
send method to actually send the message
it's not complicated it's just a bit you
know more ponderous so only when you've
created those can you actually save the
message and perhaps I'll just but plus
I'll just go back quickly and even when
you've sent the message you not done yet
because you've then got to close the
connection after use because a
connection is a limited resource so you
have to remember to connect to close it
and in that case you put it in the
finally block just adds more clutter and
last but not least is you need to
remember that all these objects are
defined to throw gems exception which is
a checked exception so you need a cache
block to do something with it or else
you need to re throw it and quite often
in these this cases you
jeromy's exception is such a
general-purpose exception you don't know
what to do you know it's not there's no
obvious way in which your applications
can can predictably recover from it and
save something something that's you
could just throw an exception to the
calling method or you can just log it so
let's just talk about just one or two
specific points that the basically I'm
going to say with having it didn't it
needed improvement don't spend too long
about that but let's just look at the
parameters to look at the codes that
creates a session from the connection
I've got two parameters are boolean to
specify whether the session is
transacted or not and an interest flag
to specify how incoming messages
obviously we're not receiving messages
here but you still need specify the
second there's also a second parameter
which ostensibly specifies how they're
acknowledged so in this case it's just
set to false so non transacted and auto
acknowledge however in this we're in the
session beam by default session beans
are transacted they have an it they have
a judge you know a java re' transaction
running and the specification if at the
eb g ej b trip on one specification does
this new defines in a java application
the parameters both of them to create
session or ignored so so both of those
are completely misleading parameters
there but even if you were in a java
java SE application and they weren't
ignored you've still got basically two
parameters which are actually not
independent of each other and
essentially if the basically detail is
is that if you set the first parameter
to true which says you want to Java SE
local transaction then the second
parameter is ignored anyway so again the
API forces to you in from both EE and se
to clutter your code with parameters
that are actually ignored and which is
you know you just take for granted when
you do it but it can be very confusing
to the sort of uninitiated do you look
at this code and thing ah look at that
look at that you might think it's using
alt acknowledgment you know it's not
transacting cuz it's as false but no
that's not true at all it's you know
that in that example its uses
transaction so very confusing
potentially and yes this is just the
clothes and the exception handling which
I've already talked about so that's just
looking Jamis 2.1 Jamis 1.1 so how could
we have made this simpler so let's just
start by looking at a few small
improvements that be made to make these
the existing API essentially the API
I've just seen easy to use in Germans
two point lot as I said I'm the need to
maintain backwards compatibility limits
the scope for change here so these are
quite modest improvements but the first
one is those are parameters to create
session that I explained neither tidying
up with existing through the three
methods here the first one is the
existing method which remains text two
parameters are boolean to specify
whether the sessions transacted an
integer value which is only used when
the session is non transacted and which
specifies which of three possible
ignored methods should be used so that
makes four possible
options in total that's transacted
that's you know when it went transacted
is true then all the other parameters
when tracted is false acknowledgement
mode can have one of three values Auto
acknowledge Jeep so okay acknowledge or
client acknowledge it does really matter
with II what they mean but you basically
have four total sort options so there's
a new method that's takes one parameter
that's now being added into Germans 2.0
which takes a single parameter which
basically combines those four options in
a four in a single four value constant
and there's in fact the same content
that already exists session dot
transacted session dot multi knowledge
and the others so very simple but it
just simply makes the API reflect
actually the options available and the
last method is a parameter is a is a
version that's not only parameters at
all now essentially that's just there to
avoid the need to actually lie in the
code and the past in params that can be
ignored
in the case of Java EE so if you're
using Java in Java EE trunk and you know
that there's a Java EE transaction so
the parameters are going to be ignored
so you you can use a no argument version
and then the reader won't be misled by
parameters that are going to be ignored
you can use that in Java SE in which
case it'll just default to
non-transactional an acknowledgment so
just a very minor modest improvement
another monster modest improvement is to
make it simpler to close your code close
your connection after use about all the
objects your if to use I don't know how
many people here are now using Java SE 7
but it introduced a new feature Java doc
Jane 12 that language ought to closeable
which basically is a feature of the you
know Java SE 7 where if you if an object
implements that and basically defines
one method clothes which cautiously all
these methods already do but if an if a
method if an object or interface
implements that then it means that you
can close it in a new syntax called a
tribe of sources block
I did so can people say who's familiar
with a tribe the sources block do I need
to explain it so okay so few people are
it's quite a simple of a powerful
feature that's been added to Java 7 and
perhaps I should say that Java EE 7 and
Gemma's 2.0 - both of them require your
app your code to be compiled using Java
SE 7 compile a compiler but it means you
can create your objects which
implemental to closable in a new type of
sun block in a try construct where the
code in red which is basically
surrounded after the try you've got
round brackets rather than braces which
you know which you didn't have before so
that's the difference is I mean the main
body of the block is just below in the
braces and it got finally block at the
end and you've got a catch block at the
bottom but this new block this new I
don't know what it's called to them
actually the the block in red between
the round brackets basically the idea is
if you create objects that implement all
two closeable within that block when you
come to the end of the sort of main
block then the sort of the JVM will
automatically call the close method on
all those objects in reverse order for
you say no matter having a hat
no matter which way out of the block you
can't throw an exception or whether you
just you know do a clean exit it'll just
call closed for you so basically it's
just as smart it's just a sort of
convenient way to avoid having to have a
finally block that calls closed on the
connection and those other objects at
the end so it's just simply tied up your
code and there's actually a little bit
more to it than that in that it's not
just saving you the ability of to put
it's not just saving you the bother to
actually have another line of code to
the finally block called closed it
actually adds some additional features
which I went into go into because it's
not specific to JMS to basically allow
that any exceptions that are thrown
during the clothes stage to be sort of
wrapped care to be wrapped purply and
and thrown
because one of the problems when you're
in a normal I didn't get you before but
if you if you're normally creating
creating a connection in us in the
tribal in an ordinary trial an ordinary
try block and then you have a catch
block which catches an exception then
you want that to close the object close
the you know when it when it when you
get both in the case of exception and in
the case of just north of completion you
want to call close but what happens if
the reason you're going through the
close the sore finally block is because
you had an exception then the close
itself will fail and of course close can
throw exceptions so quite often the the
exception thrown when closed fails is
actually blocking the original object
there is the original exception that was
thrown that caused it to go into the
finally block at all but basically if
you're using a try of their sources a
lot the two accepts are neatly nested in
in one another and basically it's just
much simpler so so deal here then is is
that the new all the new Jamis objects
all the existing Jamis objects now
implement auto closeable which means you
can create them using a try of the
sources block avoids you having to
explicitly have clothes and just say
very few lines of code and that's that's
all it is and i should say these changes
making a method alter closeable is these
methods alters was completely back in
patter ball in the sense of these
methods already had a closed method so
it's not to change so well those two
features really summarized just the sort
of minor minor improvements the existing
API so let's just get on to the more
interesting things which is the
simplified api so yes for more
significant the reason we needed to add
the simplified api was to make it
possible to make more significant
improvements than those very modest
piecemeal improvements at before so a
new api was added which we call the
simplified api so let's just go straight
into an example of the use of the
simplified api to send a message so
basically this is the same as doing the
same thing as the previous example just
simply a method in session being again
let's say takes a string parameters with
the method and it's sending it in a text
message
and I think before we go into detail I
think I want you to notice there's just
less code now you can argue about
exactly how many lines of code you
should count but in the spiritual
example we have 13 lines of code before
and now we've got five so let's just
look at this in a bit more detail so as
before we've got a method which takes a
string as i said and sends it as a
Jonah's message we in a java application
so you can use the APIs or sanitation to
inject the connection factory and
destination objects so so far this is so
far the first four lines there's no
change but what's new then well first
all you notice we've got to try with
resources block again but in the tribe
the sources block the the first part
where we create the resources we're
creating a new object here from the
connection factory we're creating not a
connection but a new object called the
Germans context as this new objects in
German took one dog which you can think
of as combining a journalist connection
and the JMS session into a simple single
object okay then the next line of code
sort of in the black we're using its
credit produce our objects don't
actually save in the field or a variable
and then we're calling send message on
that to send the send message now you
notice that you're not actually creating
a message object a text message here
what we're doing is were passing that
that variable payload straight into the
send method so say we not really have so
we've not actually had to create a a
text message here I think it may be
obvious now that Gemma's context like
those other the other existing JMS
interfaces implement sort of closeable
so again we can use it in tribal sources
block which means that even though it
needs to be closed after use we don't
have to explicitly do that we can just
let the essentially the runtime
environment just call closed when we
finished with it and the exception at
the bottom we've still got an exception
handling here but it's important to know
that the actual exception that these
methods throw is different
whereas JMS 1.0 on all methods call
throw a JMS exception
in the simplified API all the meta
thrower JMS runtime exception and what
that mean and that the difference
between the two is that a JMS exception
is a checked exceptions which you always
have to to catch or declare in the
throws clause otherwise the compiler
won't compile it whereas the Jemez
runtime exception is a subtype of
runtime exception which basically means
you don't you're not forced to actually
create a catch block for it if you don't
want to so it just adds a bit more
flexibility to whether you actually just
want to explicitly caches at a
particular level or just leave it to you
know the calling code to to handle okay
Jana's context then the core of the
simple API let's talk about this in a
little bit more detail as I said it can
be thought of as encapsulating a Germans
connection and a session though if
you're you I talked about connection
session all the way through these
concepts are were that in there still
exists in Germans to inaud but if you're
using the simplified API you never
actually have to deal with connections
or sessions you would you deal with gems
context objects and you create a gem as
context from the connection factory
using a new method create context on on
the connection factory the connection
factory itself is effectively unchanged
but it's got some new methods and what
and since you're creating effective
implicitly a connection the session you
can specify all the parameters that you
use when creating either a connection or
a session so in this example we are
passing the session mode you know which
is the fall for value integer to specify
you know the acknowledgement mode
whether it's transacted there's all this
also very interesting passing using
username and password which you you know
if you're using that version of create
connection
Jamis context uses system resources
because it holds connection so you need
to close it after use which you can do
by either just explicitly calling close
or you can create if you created in a
try with resources block close will be
called for you and the final new feature
of Gemma's context which I'll come back
to is the fact you can inject it using
that injecting an annotation
into a Java EE application which saves
you which saves you the actual need to
actually answer
she ate it well we've just jumped slides
rather quickly just whoops
oh good
so yeah here are a few more things we
want to know about like to know Gemma's
context because of Jonah's context
remember create effectively creates
holders connection accession now in the
standard API okay the word standard API
is what I'm going to use to relate
essentially the the what we might call
Janice one font one API the standard API
is better connection and session and mr.
producer and missus consumer it's in the
standard API you're allowed to create
multiple sessions objects from the same
connection was in the simplified API you
can do the same thing but what that then
means is effectively you're you want
several gems context all with different
sessions inside them but all the same
connection now just the AP we just
provided an API to do that which is
effectively to create one context from
another context so what that'll do is it
created Gemma's context using a new and
used creating new Gemma's context using
the same connection as the the one you
creating it from but it'll create a new
session and just reminder the reason
you've got you might want more than one
session on the connection is that a
session is single-threaded
basically so if you want several threats
rebel threat several threads processing
messages from the same connection you
need to create multiple sessions on the
connection and in this and if using
supervised api integrates multiple jams
contexts effectively from the same
initial gems context and finally what
can you do with the gems context well
obviously use it to send and receive
messages and you you you use it to
essentially crew created Gemma's
producer objects to send messages and
James consumer objects to receive
messages ok jammers producer then this
is the the new menu interface and the
certified API to send messages now this
actually is deliberately intended not
well in fact all the API is intended to
be recognizable to people who use the
huge MS it's not so rad although the
methods of methods and interfaces are
simpler it's not intent it's almost
deliberately intended to be recognizable
so you know you should be
I mean nobody would be having any but
nobody familiar with Gemma Swan from one
should have any particular difficulty
picking up the concepts because they're
there they're the same context the same
concepts of Jonas so Jenna's producer in
many ways you can be used in a similar
way to the existing message producer
object in the standard API but the
difference is that the jammers producer
is defined to be a lightweight object
that you can create freely and still
throw away which you normally wouldn't
want to do with a message producer but
it's deliberately intended that you can
just create it on the fly basically and
used to send a message and and then put
another one usually send another list if
you want to do and the reason to do that
the reason defined is lightweight is it
just means you can you can solve this
because all the set of message all the
methods that actually do set set fields
on the Jamz producer return the Jemez
producer object so you can basically
chain them together essentially using
sort of method chaining pattern yeah I
said it's best to think of a Janus
context is you can think of a gems
context as containing a message producer
now the gems context you can think of as
holding you should think of the gems
context is holding mr. producer and the
gems context object is just holding a
bag of properties that will be passed to
it when you actually want to send a
message so okay that's let's get an
example so the first example here is
actually using gem that's 1.1 API to set
various properties so it's deliberately
various delivery option delivery
delivery options basically before you
actually send the message so in the top
example we're creating a mess producer
object we're setting delivery mode to be
non-persistent we're setting pride to be
one the time to live to be one second
and then we're sending it that's
typically how you do that with gems 1.1
Jamis to point naught the idea is
because these methods are structured to
allow you to first of all throw away the
Germans producer after use but also
because they allow a method chaining is
you can just basically crate but you
then call a chain of methods to actually
set the the these three parameters in
one in one line and then you can just
forget about the Germans producer you've
created so basically it's just designed
to allow you to write more compact code
you don't no point in that second
example you've actually had to save the
gems producer in the field
I mean available even so another feature
of geminus producer is that it offers
you a way to in fact all the all the
things that you might want to set on a
message you can also set on the message
producer so you can use it to set
message properties which are the moments
you have to sit on the message itself
and you can also you the Germans believe
to set message headers which again at
the moment you have to sit on the
message itself and you can continue to
do that message object is not changed in
this API in this respect so what that
means then is that in the first example
where we're creating Amos we're creating
a message producer and we are creating a
text message and then we set a string
property foo on the text message and
then we send the the message and gems to
point naught we can actually do this all
in one line by using a new method set
property actually on the producer object
so you create the producer you set the
property foo to bar on the producer
object and equals send and then what
that does is it basically the send
operation will basically copy the
property out of the gems produce it into
the message before sending it you might
think what's the point about that other
than just allowing you to write it all
in one line and the the reason that we
these disparate the reason this previous
slide shows you that you can send
message messy all that all the
properties of the method of the message
actually on the producer why are you
doing that the reason is is then it
allows you just to pass the payload
directly into the Germans producer to
send to the send method to send it so
let's just look at these in turn the the
top method is
is very similar to the existing method
to send the message you pass in
destination and you pass in the message
object they can still do that however if
you've got a if you want to send a map
message an object message by text
message or a bytes message you'd
actually have to create the message
object you can simply pass in the
welcome and payload or the body just
directly into the send method and and
obviously one of those four methods will
be executed you know picked up off
compiler and it'll just and what a GMS
will do is it'll automatically create a
message the appropriate type set its
payload it's Balti to be that the map
you know the the serializable object if
it's not just object message or the
string is text message or the byte array
if it's a byte mitzvos message it'll
automatically set the payload well it
will also take all the message delivery
options that you specified in the dermis
producer and send those set those on the
jet on the message it's just you've just
created and then eventually it'll and
then and then well not eventually then
the next thing we'll do is it'll send it
so basically what you're doing is you're
sort of put is a lot of the methods that
to pre configure the message we're
moving on well moving also are available
on the Germans producer which and which
then allows you not only does or chain
of methods chain these methods together
but it also allows you then just
appallingly the myth the object payload
the message payload directly into the
send method
so therefore not only allowing you a
single line of code with lots of things
going on but it means you don't have to
create the message itself okay so that's
sending messages so let's just talk
about how use the sent file API to
receive messages so in this this is the
area in the simple API which is probably
simplest most similar to the standard
API to remember that in the in the
standard API in German Swan 21 to
consume messages you create a message a
message consumer object well in this
apply API you create a Germans consumer
object which is spell vet fairly similar
and like in JMS 1.1 and standard api you
can either having created the Jemez
consumer object you can either receive
messages synchronously by calling
of three receive methods this one is
receiving a method with a timeout of one
second 30 seconds and it loves the block
until the message is received or until
that timeout is reached
that's just like existing JMS or you can
receive messages are synchronously by
creating the Gemma's consumer and then
setting a message listener a callback
method on it Messer listeners just
unchanged so the so it's very it's the
same basically they're the one
difference is that these methods now
return a different exception than the
previous than the existing API if
they're a runtime exception rather now
as checked exception functionally the
biggest difference is that the
connection is started now I imagine a
lot of you familiar with JMS and the
thing about the thing about using JMS in
Jamis 1.1 is that when you want to
receive a message you need to always
call connection dot start before you
before any messages will being delivered
and I don't know about you but the I
think one of the single most common just
silly mistakes when trying to receive
messages and Jeremias is forgetting to
start the connection a number of times
on user forums and that I've been
involved with these people say I've
currently know I've done all all I've
done what I think is all the right code
I've created that you know measures
consumer I've called receive and I know
there's a message on the queue because
it's some tool tells me it is but
there's no messages or I think what's
getting wrong
and almost without looking at the code
sample you can say have you remember to
close the start connection so we thought
okay let's get rid of that line of code
and that course of sort of simple
mistakes by saying that if you using the
Jemez consumer to receive messages then
the connection is autumn at least
started for you so basically it means
message delivery will start immediately
it's configurable because if you there
are cases when you might not want that
so you can tell it off so we just a few
moments ago I talked about new methods
that allowed you to send a message
payload or message that body directly
without having to create a a message
object there's some similar
privileged methods when you receive mist
that there are some equivalent methods
you can call when you sieving methods
synchrony that allows do something
fairly similar so but just the first
three there are the sort of familiar
methods orange as Jeremiah's consumer to
receive a master synchronously that's
receive which especially blocks
indefinitely until mister arrives
there's received the time out and
there's received no way which doesn't
wait at all but the three new methods
which we've called receive baldy baldy
is the term that Jamis uses to
traditionally to refer to the payload of
the message and essentially what these
do is if you that they're they're the
same sort of quiver lence there's no
time there's a blocking receive there's
a receiver the timeout and receive no
wait but the difference is is if you
know the type of the object you're
expecting to receive then you can call
those methods you have to pass in the
type and then it will return to your
application and object the actual polo
directly of it with a knob as an object
of the appropriate type so if you know
that you have a got an example yes so if
you know the the object the if you know
that basically the cue has text messages
on it then and all you want is the
string payload then you can you call the
method receive Botany pass in string dot
class which is all of the details of
generics requires you to do and then
that returns a string object for you you
know there's no commerce required there
you may remember I haven't good example
here blue remember that if you want to
do if you want to do that using Jonas
1.1 then you have to call receive the
receive method it returns you a message
object Montano returns you an object of
type message which is of generic super
type you then it would need to cast it
down to the appropriate type a text
message so you still need to sort of
know what type it is so you might magic
answer to a text message and then you
need to call the appropriate get a
method to get out the payload so did say
these these new receive body methods
basically allow you to just combine that
in one line of code without the need for
an explicit cast now it's just a little
downside of this is that because this is
basically you've got one shot to get the
message
and because it's returning the payload
directly then there's no way you can
actually you never actually see the
message object now in this when
receiving messages you might actually
want that if you want to actually query
the message properties or headers so if
you want to see the message properties
or headers then don't use this just use
the existing API existing methods the
receive methods to return the object is
their method the message object itself
but if all you're interested in is the
is the payload itself the body itself
then this basic is a slightly simpler
way to do that
now what I would have those methods I
just told you second to go were four
synchronously they messed us on their
methods on Gemma's consumer to
synchronously receive a message body
directly but what if you want to receive
messages asynchronously the on message
interface basically gives you a message
object so and anybody who's written a
messages nor now you also used to have
to say in slightly ponderous spoiler
plate code and that of casting the
message to an appropriate type like text
message or vice message and then calling
a method to get the payload out and in
fact this example this example shows you
the the way you use the way you used to
have to do to the top in fact this is
all the synchronously receiving the base
you've got a message object then you
have to cut and you want to get the
payload out then you have to cast it to
the appropriate type what you have to
know what type it is you have to cast it
and then you call a method like get text
or get object or get bytes whatever to
get the actual body out now to simplify
if your if you actually do have a
message object in your hand and you want
to get the payload out like in that
example or because you've used a message
listener then there's a new method get
body which allows you to come to
basically get the body out of a message
or an object of type message without
having to do that cast and without
having to worry about what method to
call if you just call get body on the
message it could be and it said you know
any message I need any type because this
is a method on the super type and just
call call get body and pass in the
expected type you know again string or
or a byte array or a serializable
I mean you or if it's a map message if
it's an object message usually pass in
the serializable type that you're
expecting you know your application type
and then it will basically automatically
return the an object of the same type as
the body so again it's it's code that
just saves you about two lines say do
you have an explicit cast and saving
explicit call to you know remembering
which of the appropriate methods you
need to call to get the body out so you
know these are all fairly modest simple
changes which you might think
individually Earth sort of
inconsequential but they all together
combine to basically reducing amount of
code you need to write and then finally
on Jonah's contexts the perhaps it's
time to talk about what what's actually
on the most significant new features of
Germans to point naught because so far
I've been telling you about how you
credit Gemma's context using connection
factory to to create a connection and we
we say these are some application
managed connect they're Gemma's context
because you need to create them and you
to close them well if you're in the Java
EE web or EJB container you can also
inject Gemma's context objects directly
there's no need to create a germs
context no need to close it you just use
at inject to inject the Gemma's context
you de specify the connection factory
you want to use and the the container
the the application server will
automatically look up this connection
factory for you and use it to create a
Gemma's context your code just simply
has to use it and at the end of the
transaction this is a Java EE feature
the Gemma's context what does it closed
automatically for you by the container
so there's no need for a try with a
source block
there's no need to cool clothes there's
no need for a try of the source it's
blocked to implicitly tell it when to
close the container will just close it
for you when the transaction ends now if
this is essentially its intended to
bring to JMS a lot of the simplicity of
that people who use JP areas and other
people who have used the job assistance
architecture but that has a concept of
injecting an entity manager objects
which is just a handle on the database
into your code by using an app system
context annotation and again that that's
something that has a transaction scope
which means at the end of the
transaction the the cilenti managers
closed cleaned up for you this is
intended the Germans equivalent is that
you can you know use it is that you if
you just want to do some JMS activity in
your in your java application you just
inject this though we've got slightly
more standard @inject annotation just
keep it simple and then you need to only
to worry about it it'll just you just
got JMS resources in your code and you
can just use them to send obscene
messages and then to worry about its
lifecycle or how to close it or anything
like that you just you just use it
there's a few more variants on it which
I don't think I'm going to go through
but you can specify more information
about the object you're injecting by
using a number of other annotations but
this'll save time I'm not they go to
those I think I've just overshot there
yes one last point about injection then
as I explained that at the end of the
transaction you remember have by default
in in any JB's for example at the end of
the transaction and that effectively
closes the connection for you so the
slightly bigger deal here is the engine
is these objects are injected in the
same way that CDI managed beans are
injected and context dependency object
condors in context and dependency
injected objects so they have scope and
in the JTA transaction which is the
common case is the scope of the injected
journalist context is the transaction
and transaction scope is a new feature
in Java EE well in CDI the version of
CDI that's in Java 7 there's a new
there's a new CER scope called
transacted scope and this is used for
injected gems contexts but if there's no
transaction then we still want to scope
we still want to allow you to inject
gems contexts and so if there's no
transaction the scope is the request
where a request has a specialized sort
of meaning at CDI and doesn't you know
it's not just defined in HTTP requests
basely there's another scope there's a
there's a definition of the pointer
which is closed
so basically I just want once you
understand that injected objects at
basely CDI objects injected germs
context dr. savetti CDI object that have
a scope just like any other object
you've injected using CDI and and as
basically all I really wanted to say
about the simplified API is it simple
and I just want to just put it into
context
relative to the other api's here
slightly embarrassed me then is in
Janice we've actually got for api's and
I think that just reflects the fact that
you've got an AP if you've got an API
that that's sort of 10 years old that
you can't change and you want to
simplify you you can't lose the old API
you have to create a new one and this
isn't actually the first time people
have tried to simplify JMS because back
in the dawn of the century Jamis 1.1
itself was a simplification of the
previous version Germans Germans one
point naught which introduced those met
well Keuka nation factor EQ connection
topic connection Factory those met those
objects on the right which which were
essentially they were the first first
objects to be active find in JMS 1.0 and
they were affected deprecated Jamis one
by one replaced by a saw the unified API
so I haven't talked about those at all
because they're still there but
essentially you should think of them as
deprecated so I mean some of them have
the feat new features that we've added
to the simplify to the standard API
because they've inherited but
essentially they're unchanged so
basically think of them so we've
basically got three API is really we've
got the so these legacy API from Jamis
1.0 which will be there forever but you
don't have to use and I'm sorry you've
been people have been discouraged from
using them for over a decade now but
they're still there then there's a
standard API which is essentially the AP
at the AP are the people have been using
for last decade which still stays that
that is slightly simplified and it's not
going away it's going to be there
forever effectively so it's still there
and then the descent of our API which is
known to be a complete a complete
replacement of the standard of the other
API is so you there's so you've never
call it simplified it's got the full
capability of the older API
but it's intended to be simpler and easy
to use and it has this new feature of
inject supporting injection now we're
learning a little bit wrong a little bit
later here so I'm just going to go
through now some of the new messaging
features that we've added to Gemma's 2.0
I mean the main feature of so the main
focus of gems tip or not was simply the
super file API but there wasn't there
was opportunity to add a few more as a
messaging related features you know
think do with the API to it and there's
one two three four five are just like to
quickly go through before we finish so
I'll go through fairly quickly because I
just want to let leave leave just a few
minutes to ask any questions but
basically deliver lead delivery delay is
a new feature that allows the
application to schedule the future
delivery of a message so basically
there's new methods on message producer
or gem is produced so this is a feature
that's available in all the api's where
basically you can pass in a lot of
delivery delay which is basically a
number of milliseconds and what it's
basically dafuq saying is don't deliver
this message until that time has arrived
so basically if you want to send a
message to the gems provide us then it's
persisted it's all safe and secure you
don't want it to actually be sent on to
a to the receiver until tomorrow you can
specify a little bit early now this is a
feature the lot of existing gems
providers already do but in a sudden on
but that put a non-standard so basically
this is essentially trying to
standardize a feature that the vendors
have already realized is important and
useful to applications but just allow
you to do it in a standard way so the
API is actually very similar the API to
message expiry but it obviously it's a
defying a different thing so delivery
delay another new feature a synchronous
send this is a way to well perhaps the
way to explain is to talk about a
synchronous send normally if you're
sending a certain message to the Gemma's
provider the sort of the deal is is that
you call your application calls send and
then that and what happens then when you
call send is the generous provider
itself that you know the implementation
sends a message to delete some remote
server where it's persisted
and then Ana knowledge mint comes back
to tell the clients that you've it and
then but while you're waiting for the
acknowledgement to come back from the
server the actual call to send will
block and wait and then when the
Longinus done which means it's safe to
persisted and you can be sure it's sort
of safe it'll then which the send method
will return so the basic the basic
contract the basic contract is is if you
call send once in is received you know
it's been persisted now what an async
send us was is basically says you send
the message and you want and it returns
effectively immediately without waiting
for the without blocking until
acknowledgments receive directly from
the server and as instead what happens
is if served immediately and then when
the acknowledgement is returned from the
server to say it's being sis today FLE a
callback method is well basically an
asynchronous callback is invoked on a
new object we've defined called a
completion listener which you pass in to
the send method so basically you call
send passing the message passing the
completion listener object and it said
they'll return immediately
they'll sent message returned
immediately and then when it's persisted
it will invoke the completion listed to
tell you it's been say persisted safely
now why why would you do that again it's
a feature that a lot of existing a Jamis
providers already support and it's
purple essentially just is to well to
allow your thread that's called it to do
something else while it's being we're in
iraq while it's while it's waiting to be
acknowledged so basically you could
think of this is a performance tool if
you want persistent messages and you
still want a high quality of service but
you don't want to perhaps want to send a
whole lots of messages and you don't
want to each one to block until the
Englishman's returned so basicly it's a
performance feature and this is just a
completion listener interface it's this
invokes when the acknowledgement is is
returned if there's a method called on
completion where it actually passes the
message back to you and this if
something went wrong it will call on
exception ok just quickly going through
the new features another feature is that
there's a new there already is a message
property that's defined in JMS called
gemma sex delivery counter and what this
is is this tells you how many times the
message has been redeliver basically
this is all about how to handle messages
well poison messages messages can't be
consumed for some reason need to be
redeliver you know James the moment
doesn't define what happens if it's sort
of a bad a message keeps getting sent to
a measure listener and it's throws an
exception and they're the gem has
provided sends it again because it does
doesn't know what to do with sort of bad
messages so the idea here is it's just
by by allowing the client to know how
many times must have been received it
basely allows the application to its own
dead message handling i mean they're
possibly if you you know not another
possibility would be to define a
poisoned message handling as part of the
dermis api but this is a halfway house
which actually just makes it easy for
application do it self or possibly a
framework to do yourself another feature
which i'm just going to just touch on
quickly because it's a it's quite a it's
quite a complex thing that i want to go
into too much detail but essentially JMS
to point north allows you to have
multiple consumers on a topic
subscription if you remember i just
remember how topics work in Jamis 1.1
and in particular what the term
subscription means you can think of a
subscription rember topic is obviously
jeremy sees pub sub concept and you can
think of a subscription being like a
queue which receives a copy of every
message it's been sent to a topic a
subscription can be durable or non
durable if the subscription is durable
then it's sort of long lived now
persisted names and will continue exist
even when the consumer goes away or
subscription would be non durable in
which case it's shortly short-lived it's
not cystic and will be deleted it's less
reliable will delete it when the super
goes away and in both cases though
there's a basic restriction that each
subscription can only have one consumer
so what Jamis well the problem with only
having one consumer on durables on a
subscription in in general swamp antoine
is basically that meant it wasn't
possible to write remember that remember
that only each consumers a single
threaded thing it basically meant that
you could only have one thread
processing messages from a tapa
subscription and that you know that
actually limited the limited the ability
to write scalable applications that
handle messages from a topic so you only
have one thread so that's if you're not
using mtv's so what Gemma's tip or not
does is introduces new shared
subscription which you well in a new
feature we've called shared
subscriptions it's specially new type of
topic subscription which can have
multiple consumers at the same time
which are defined by a name and this
allows the work of processing messages
from a top description to be shared
amongst multiple threads multiple JVMs
so if you want it ascends
high-performance currents processing on
messages concurrent processing and
messages from a topic subscription you
can use a shared subscription I'm not
going to go through the API but there's
a new methods called Alex Jamis 1.1 API
there's a new methods basically create
shared consume and create shared durable
consumer to create show subscriptions of
the both cases you you specify name
because you want to identify the name
subscription so I think just looking at
the time I think that's probably all I
had time to time to talk about so I just
want to finish I'm just going to jump
through two
it's just quickly summarized then is
what I have told you about then is
what's new in Gemma's to point naught
okay the focus on this has been
simplicity in ease of use the new
simplified API the James context object
support for injection of objects into a
JMS java ee container there's also a
small number of new messaging features
which we've added as well of which the
most significant one is the one I just
mentioned last which is multi-threaded
topic subscriptions there's a few other
features including delivery delay and a
synchronous send which I also mentioned
I didn't have time to talk about better
integration this is like a standard
thing and more improved configuration
and of course may improve as inevitably
some clarifications and corrections gems
to upon autism vaporware it really
exists exists in it's a release standard
it's now there you can actually download
and read it if you want to and you can
try it out in the first implementation
of it which is open message queue five
point naught which of the gem is
provided within GlassFish if you want a
full java application server so you can
download it right now
and try it out depending on whether you
want Java EE or justice or standalone
JMS from those sites and there's also a
website which I manage called Jamis I've
inspect of Java at net which contains
lots of other useful links about gems to
porn or about
you know articles of describing this in
more detail I think we've actually
almost done but it's anybody Oh what I'd
perhaps I would I will I will say is
just give a quick I'll ask for any
questions we've just got a quick time
and I'll just but that's such an advert
for the Boff again any quick questions
well it's up to the reliability of the
application service decide I mean it's
just this exactly the same reliability
is with mess with any other any other
system message so the you know if the if
the application service designed to see
if it's been persistent you've restarted
yes it should be delivered
remember the delivery delays like a
minimum time to deliver it it just says
you don't deliver it before a certain
time but you're allowed to deliver it
afterwards so in a sense there's no
deadline it can deliver deliver it very
late and it's still sort of valid okay
I'm sorry I think that's probably all
the time we got to so but I'll be just
next door tomorrow
talking about GMS two point well get
your receiving feedback on gem is two
point and also talking about what's next
after this so hope I'll see some of you
tomorrow so thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>