<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON8371   The Story of Traits | Coder Coacher - Coaching Coders</title><meta content="CON8371   The Story of Traits - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON8371   The Story of Traits</b></h2><h5 class="post__date">2015-12-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VdBkw9TU_u4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to this session on the story of
traits my name is Venkat Subramanyam
we're going to talk about traits and
we're gonna use three different
languages in this presentation we're
gonna look at Java a little bit look at
Scala what are the things we can do and
then a little bit about what we can do
in groovy as well so let's get started
I apologize for people who are on the
blind spot right here behind the pillar
so you should be able to see the screen
hopefully fairly well from where where
you are so let's get started well one of
the things we do in object with the
programming is we create classes and
oftentimes classes represent reusable
abstractions and then we start extending
from it and we use classes for
extensibility so we normally take a
class and we inherit from a class and
then we say we're gonna extend this
particular functionality to add more
things and when it comes to these
classes we represent a certain
abstraction and it works really well but
suddenly we realize that we need to
really bring in two different
abstractions together and this is a
concept we often call as multiple
inheritance now multiple inheritance is
when one class wants to inherit from two
different classes now when a class
inherits from two different classes at
the first thought this seems like it's
not such a terrible thing to do because
after all a class may want to bring two
different abstractions together and
extend further on it but unfortunately
that ends up posing certain problems
over time we've had languages that
promote multiple inheritance but
unfortunately that can become quite
complex
for example C++ how many of you have
experience with the C++ Wow really this
is awesome so this is this is a group of
people with really a dark past this is
this is amazing
so with C++ of course you could try to
do multiple inheritance but multi
multiple inheritance in C++ you know
this very well
multiple inheritance they took a gorilla
it is really cute when you see it in the
zoo but you never drink it home because
it causes havoc right and it causes all
kinds of problems for you
cuz what do you normally do with
multiple inheritance well you first of
all say that let's say you have a class
old we'll call it as a and you want to
create let's say we have a class B and
you have a class C and you want to
create a class D which inherits from B
and C this seems like a really good idea
in the beginning but quickly you realize
this is not just the end this is just
the beginning and you already have a
Class A which B inherits from and you
also have the same Class A that C
inherits from and what you end up with
is this flip view of the world very
quickly in C++ and now you have this
object which is duplicated in your
hierarchy and now when you start
updating there's two different values to
maintain this becomes a really big
nightmare and quickly you realize you
don't want this so what you tend to do
then is you replace this with a little
hierarchy where you say I want this to
become more like this and as a result
what you're going to do at this point is
you're going to ask it to I don't even
know where the backslash is there you go
so you want to really say this is going
to become inheritance and then of course
you are trying to inherit your Class B
and D inherits from B obviously in this
case and so does it ignore it from C
well but the problem is when you try to
do this in C++ you cannot just
automatically do this you would have to
have defined the inheritance of B from a
as a virtue of base class and if you
didn't do this already tough luck you
can't really make it you know multiple
inheritance this is so wonderfully
called as the diamond problem but it
really has nothing to do with diamond at
all in fact diamonds are something you
would want this is not something you
would ever want so this is a formally
called as a diamond problem so when Java
came about Java looked at C++ and said
well this is a complete mess and we want
to solve it and they solve it in a very
elegant way they said no multiple
inheritance for you right so that is
called running away from a real problem
so they didn't solve it they said no
multiple inheritance for you we can
inherit multiply from interphase
but not from classes well why is that a
good idea because interfaces don't have
any implementation in them and as a
result it's much safer to inherit from
multiple interfaces but classes post the
problem well unfortunately though they
did not provide a solution but the
problem didn't go away after all the
problem has actually lingered with us
for all these time and so how do we
solve this problem let's look at an
example of how to solve the problem and
see if this actually makes sense and
maybe we can think about a certain ways
to address this let's say for a minute
we have a class let's say in here called
human and this class human is going to
have a function l what's called this
function as let's say listen so I have a
function called listen I'm going to
simply say in this case you know
listening so right there is a listen
function I've created in the human class
well as you just saw I'm not really
using any slides if you are interested
in downloading the code examples you can
download them from my website you don't
have to rush to write the URL down I'll
post it down below as well so you can
take it take a note of it later on if
you're interested so so in this case you
have a class called human and what are
we going to do with this human I can
create a human object I can say human
equals to new human and then of course
once I create a human object I can say
human dot listen and I can call that
method so that works really well but of
course the question is what does listen
got to do with the human well it's
nearly nothing to do with the human at
all so who listens yeah that's the
problem nobody seems to listen anymore
right well a person who listens we
should always ask who is listening well
the person who listens is called a
friend after all a friend listens to us
so absolutely a friend listen so humans
are often friendly mostly friendly right
I had a I have a dentist and dentist
asked me what do you do for a living I
said I'm a programmer and then a second
later their inter said what do you do
for a living I said I'm a programmer and
then she said are you sure I said why
and she said because you seem friendly
right so we we tend to do this right so
you know mostly we are friendly so what
do we do well there is one other
important friend
obviously the
called dog so I want to implement the
dog to be friendly well how do we do
that well I got a great idea here class
dog extends human well dogs don't like
it and what do we do about this well we
can't really somehow provide the friend
function with listen function within the
dog any suggestions what can we do
abstract an interface so the solution is
interface friend able how does that feel
okay so we create a friend double
interface and then define listen in this
case a public ok void listen and then
what do we do we got a friend interface
and then in this particular case we will
say implements of course implements
friend able and then we will come to the
dog class are absolutely here and will
say dog implements friend of all but
what are we going to do we're going to
duplicate the listen method in both
cases that really sucks ok how do we
remove this duplication room and solved
the problem yet create an abstract class
well now we got to put an abstract class
between the human and the dog well the
chances our dog already extends from
animal or do we do now extract a class
from it so we could say a class called
friend double our friendly impl have you
seen that before right and then of
course within this we can write up a
public void listen and then we will
write the method call listening over
here and then what would we do we will
come down to the human and we would say
friend double implementation will say
friend able over here so friend able and
equal to new well this is going to be a
abstract class so let's make it abstract
so if we make this an abstract class
what are we gonna do in this case well
we can't really use that directly maybe
we'll make this a static method I don't
know and then we can come back here and
say well we will write the method call
public void listen but in this case
we'll simply say call the friend double
impl dart listen method if it were a
static method for example we could call
that and then similarly now in there dog
also we could come down
and call that method also at least we
don't have a duplication of the
implementation we have just a wrapper
method to be available now of course
what we can do is we can say public
static void let's call it as help and in
this case we'll say friend double over
here friend abou and this case of course
will say friend double dot listen and we
can of course come here and pass the
human to it so we could say help and
then we could pass the human to the
friend double assuming I wrote all of
that correctly which I didn't so let's
go ahead and remove the animal for a
minute so you can see that you can call
the human but you can also say dog over
here equals to new dog and then of
course we could say pass the dog to the
help function and we could call it also
does this seem like a solution we have
tried before yeah so we have all done
this if this is what we are going to do
why are we doing it right so of course
we'll do really stupid things and then
we'll give it a nice pattern name then
all the trouble goes away and
everybody's so excited right and we'll
say we're using this pattern well any
time you hear the word pattern it's a
sign that the language is pretty down
weak so we have more patterns and
languages which are weak and a more
powerful languages we tend to have less
a fewer patterns and the reason we don't
use the word pattern is it just works
and it's part of the language so the
point really is if this is a way to
really approach it why can't the
language do all this work rather than we
having to create all the school well
that's exactly what traits really are so
what are traits traits is really an
implementation of the pattern you just
saw so what you do is you create an
interface you create an abstract class
you implement that interface and route
the call to that abstract class the code
you and I just wrote what is the
compiler can write that for you that's
exactly what a trade does so a trait
takes care of all of this at the
language level so you and I don't have
to waste the time and for
to write this now of course before we go
that route let's quickly talk about one
thing that Java provides Java I has what
are called default methods so what are
really default methods
well default methods are methods you can
implement with an interfaces so in other
words I can go to this interface called
friend Abel and in the friend able
interface I'm going to go ahead and
implement the listening function right
here so as a result notice I don't need
the friend able impl anymore I got rid
of that now in this case I have an
interface called friend Abel but of
course the compiler won't like it right
now it gives me an error saying what are
you trying to do and of course I mark
this as default right here and as a
result you can see now I can actually
have that method implemented within the
interface so once I have a method
implemented within the interface I'm
implementing that friend Abel interface
I can remove the Lucent method from here
and so can I remove it from the dog as
well and as a result now we don't have
to really write that silly code so you
can see how we wrote the method in an
interface now it's a little scary to
think about implementing a method in an
interface so the very first question you
may ask is wait a minute if we are
implementing a method in an interface
how in the world is diff is it different
from an abstract based class well one
difference is while an abstract based
class can have state you can put fields
in an abstract base class
you cannot put state or fields in an
interface so as a result you can only
have implementation of the methods so
here is a very common a pattern our
approach we cannot take so if you really
want to use the state what you would
actually do is you would use a an
abstract method in an interface for
example it's a 1 a property called name
I would say string name which is an
abstract method I'm going to provide in
the interface and then of course in this
case I could say over here let's call it
as get name how about that so
name plus listening so get name becomes
the state but we are postponing that to
the derived class to implement so you
won't put a field called name within the
interface you would turn it into a
abstract method in an interface and then
you would turn it on and call that
method now you can see the power of this
you can come here and say for example
public let's say a string get name and
we can return a name I'll just say Bob
here so you can see that in this case we
can have a name implemented likewise you
can come to this particular a class over
here and say public string get name and
then of course we can go ahead and
implement Oh in this case I'll just
simply say a buddy obviously you can put
variables to get to it but I'm lazy to
do that so you can see in this case you
can start implementing some of those you
know methods in this so you can defer
the state to the implementation so even
though interfaces can have
implementations now they cannot have
state and it's not a worry because you
can always route it through a abstract
method and have their derive the class
implement this is kind of like your
factory method pattern if you will so
that becomes a nice way to implement
around so with that said you're probably
excited to say yeah this is great now we
have trades right no so unfortunately
this doesn't quite give us traits
Javid pisa sets with default methods and
says here's a door through which if you
had gone you would have gotten two
trades we're not going to take you there
right
so unfortunately why so well it is not
because there is something else I expect
from a trade a trade is not just to
bring in two things but I really want to
go a step forward let's go back to
multiple inheritance for a minute there
are a couple of different problems with
multiple inheritance the first problem
is the duplication of the base we talked
about a few minutes ago
so you have a value of a sitting here in
to foreign and this was a nightmare so
the diamond problem says bring them
together but that's only half the
problem what is the next problem
you have a function in
with exactly the same name as a function
in C as well now you have a method
coalition between those two how do you
resolve it you overwrite the method in B
but that doesn't solve your problem
entirely because Y in the method in B
you call the method in B and what does
that normally do it in turn calls the
method on a and then when you come back
here you call the method on C and what
does that do you in turn calls a method
on a and now you ended up calling the
method twice on a well which may not be
really that good because if the
operation if operation is not idempotent
you would end up calling it twice and
that can cause really some nightmares so
when you have these method collisions
how do you really work with it well it's
actually very simple the way you work
with it is you quit programming in C++
right so you realize this is not going
to help at all let's go move on and we
avoided the problem somehow but that
didn't really help us well what you do
to avoid that problem is the question is
what do we do when methods collide what
if methods don't collide but they decide
to cooperate with each other
wouldn't that be really nice so I want
to call this as stackability and
stackability is extremely important for
us to be able to use traits really well
because plates don't just show up as
independent objects that kind of
randomly do stuff they often do similar
things that have to work together and
and default methods don't give you stack
ability and so as a result we cannot
really say default methods give us the
traits or mix-ins we really need
something more now talking about mix-ins
or trades I remember spending the summer
days back in 1980s reading about mix-ins
and I would always sit there and say wow
this is so cool I wish I could use that
and the language as I was programming
and didn't have make sense so I could
only read about it but it's kind of nice
to finally be able to use these concepts
so what's one of the difference between
mix-ins and traits what language like
Ruby provide you mixing and mixing often
our runtime mechanism whereas traits
often tend to be a compile-time akin
so you can use mixin and trade kind of
interchangeably but that's exactly what
mix-ins are if you're interested in
knowing water mixing is it's kind of
like you go to the your favorite ice
cream store and what do you do you get
an ice cream and on the ice cream you
can put mix-ins on top of it I've got a
son who is kind of the weirdest person I
know he would get a chocolate ice cream
and put chocolate on it as a mixin I
don't understand where he came from
anyway but but that's kind of putting a
mix in which is kind of pointless in my
opinion but in general you would have
other varieties of mix things you can
put on it well that's kind of the
flexibility you get you are having a
core class on your hand but you're
mixing in some other interesting
features on top of it that can be very
effective well let's leave behind Java
because it doesn't give us a stack
ability let's take a look at how we can
do this in Scala and groovy I'll show
you a little bit of example in groovy
and Scala but I'll go a little further
in Scala you can do the same thing in
groovy as well but I really don't want
to be writing coding both to show you
because it's gonna be pretty much doing
similar things I'll show you more in one
and he can do this in another as well so
let's look at an example of a trait that
you can use here in Scala and then I'll
show you in groovy as well so what am I
going to do I'm going to say great
friend and in this case I'm gonna say
define listen and the listen function is
going to simply say print line let's say
we'll just say name over here plus and
let's say listening so this is going to
be a little function that's going to
return a listening but what and first of
all let's just say listening for a
minute let's not put the name here yet
so if you look at this code what are we
doing we created a trait called a friend
that's all we did and in this case I'm
gonna simply start out by saying okay
for a minute and you can see that the
Scala compiler you know went through and
said okay so it's a little happy with
this so far but you're curious what does
this really mean what did we really
create right off the bat all that a
trait is in Scala is just an interface
so right now all we created is an
interface that's all we did we didn't do
anything
extra but if you put an implement
within this Scala gives you a buy one
get one free offer it uses an interface
along with the apps abstract class like
we would have created in the earlier
case so to look at this let's go to the
command prompt for a minute just to take
a peek at it so if I go to the location
where I have this piece of code I've got
this file here called sample dart Scala
sitting right here as you can see I'm
going to say Scala - save sample dart
Scala I'm just compiling that and
producing the result and you can see
there's a sample dot jar sitting right
here and I'm gonna say in this case oh
let's go ahead and say jar XF and then
let's extract that file jar file and
notice in this case it created a bunch
of stuff for us and you can see that
there's a friend dot class there's also
a friend dollar class dot class as well
and if you were to say Java P and take a
look at the you know friend in this case
all let's put a little code here so
let's take a look at the friend and take
a look at what it contains you would
notice that in this particular case it
is going to be just an interface as you
can see notice a word interface so
that's exactly what Scala does it
creates an interface for you likewise if
you take a look at what this other thing
is you would notice that in this case it
is actually a class that it created so
you can see the abstract class sitting
here so you know what Scala just did
Scala did exactly what we manually did
in our code a few minutes ago in the
beginning where we created an interface
and an abstract class to route it well
they took care of it for us so what you
and I would manually do they went ahead
and took care of it with an extra bonus
of dealing with the stack ability that I
that I mentioned so so given this let's
go back and take a look at what the
Scala code can do for us let me get rid
of the files here so back to the code we
have this little code and of course it
created an interface and an abstract
base class for us but now I'm going to
go ahead and create one more thing I'm
gonna say that this is name plus and I'm
gonna define a value which is a name
but it's a string but notice one
difference though I declared a Val over
here well in Scala Val must be
initialized but because this isn't a
trait I'm not initializing it in the
trait I'm leaving it for the class which
is going to mix in the straight to
actually implement this so I'm gonna say
class human right here and in this case
I'm gonna say a valid name and now in
this I would say extends from friend and
I have brought in the human into this
mix so now I can say Val San equals
let's say new human I'll say Sam and
then I can say Sam Dart listen and I can
call this function called listen on this
particular object so you can see in this
case we brought in this human and we
mixed in the friend and we are able to
call the listen function on it we're
using the extends keyword scholar simply
uses extends to extend a trade if you
don't extend already from a class so you
can just do this likewise I can define a
help function like we did before I can
say friend which is going to be the
friend itself and I can say friend did
not listen over here and of course I can
call help and then send Sam to that
function I can see that I can pass an
object to an interface to a function
that receives the trait as well so it
gives you the status of an interface
very quickly as you can see right here
so that is an example of how you can use
a trait very comfortably here in Scala
now I'm gonna grab this code real quick
I'm gonna copy this here within within
groovy I'm gonna define a function
called lizard right here and this listen
function of course is going to be
printing this value here so I'm gonna
just say print line and print the result
here in groovy groovy has much more
fluent syntax here just like Scala does
but I'm not using that here so I've got
to find a friend over here and of course
in this case I have a human and I'm
go ahead and say implements and I'm
gonna bring that in here into this class
right here so implements friend I can
bring that into the mix as well well
what about the name itself of course I
need to get the name property so I could
say for example string name and I could
initialize the name so I could say for
example public human and this is gonna
take a name the name and I'm gonna
assign the name equal to the name value
itself so we could assign that so in
this case of course I'm gonna go ahead
and define Sam in the case of groovy and
then of course time equals new human Sam
and I can call the same listen Sam a
function I can also define a function
here which is the friend function as you
can see and then within this of course
I'm going to call the listen function I
can try to pass the human to it as well
and we can then pass it around well
obviously in this case I'm just gonna
use friend and and pass that around so
you can see how that's able to use the
trait here and groovy so we just did the
implements in the case of groovy that's
all we did well so far so good but what
about our dog we even talked about the
dog well dog is the man's best friend
isn't it well you know if the end of a
very long day you have a very tiring day
well what does a dog do a dog is one
thing that always quietly listens to you
right so dog is the best friend ever
humans are not that friendly after all
right because if you're really tired and
you go to meet your friend and you say
you know what this job really sucks how
does your friend react to it that's how
you know who your true friends are right
and then you say well it's not the job
it's the boss that sucks and and if it's
a good friend he will say well tell me
about your boss if the bad friend your
friend will say maybe you suck not your
boss right that's how you know so but a
dog will never ever say such things so
dog is an awesome friend so how do you
bring a dog into this mix so I'm gonna
say in here into the scholar side I'm
gonna say class let's say class animal
so the animal is going to be a class val
name which is a string well that's our
animal class class dog let's go ahead
and say dog well override name which is
going to be a string and I'm going to
say extends from animal so we have a dog
extending animal as you can see right
here so that's good so far well now I'm
gonna say create an object of dog so
let's go ahead and say Val body is equal
to new dog we'll say buddy and then we
will say body Dart listen and we're
gonna call the lizard method and
similarly we'll pass
buddy to the help function well clearly
that doesn't work it really didn't like
it at all so what really happened well
that's because we didn't connect the dog
to a friend yet so in this case you're
going to say with friend and you're
gonna make the dog a friend as well by
providing this particular width value
let's fix this error reline number 10
it's not happy
so extends from animal this is gonna be
the name property so there we go so what
did we do we said class dog extends from
animal but with friend now notice a
slight difference here if you don't have
a base class you use X tense if you do
have a base class you use with if you
notice that's a bit inconsistent
that's perfectly okay because in
programming we never want to be
consistent so so this is really nice so
you can see that in this case if you
don't have a base you use extends if you
do have a base use a width to bring in
the trait so that's basically how you
bring it in so that seems to work really
well in terms of making the dog friend
friend as well so we are able to call
the methods on the dog as much as the
human we're able to pass both the human
and the dog as well to this function so
that's all working really well so that
looks great so far we looked at under
the hood how that works we extended the
trait as well how well were well let's
go a little further with this and see
where this is going to take us well
let's say for a minute we have yet
another class on our hands so the class
I'm going to create right here is going
to be a class called let's say a class
called cat so I create a class called
cat and I'm going to say in this case a
Val elf is equal to new
cat so we create a cat object and this
is going to be our cat called Alf and
I'm gonna say Alf dart listen and call
the listen method on that cat is this go
to work no it will not work why because
cats are not friendly right so in fact
you go home and the cat looks at you and
says why are you here why don't you go
back to work right well anybody with a
cat here yeah you have a cat you think
your cat is friendly to you to cats you
cat is friendly to you how do you how do
you tell him the real truth okay could
you share your cat's name with us if you
don't mind
oh you could you share your cat's name
with us one of the cat's name hmm
okay how do you spell equals new cat mi
CI oh okay all right and what's your
name sir what's your name
all right that's your name in Eve's cat
and then well sorry we need to get rid
of Alf help is Alfa's last hope okay so
let's try Dart
listen sorry we tried it doesn't work
are you really sure you seem like a nice
guy so cats are evil but your cat is
special right so by the way I just want
to for the record I want to say last
time somebody gave me an eval saying
venket really hates cats
I want to say for the record that's not
true I don't hate them that much okay so
so here is you know Miko and Miko is is
really friendly as you can see so cats
though are not friendly but this is a
special one in fact would you agree it's
one of the one of its kind absolutely
right in fact it's a very specialized
two cat that you are getting on your
hand so you can do instance level as
well not just class level well exactly
the same thing you can do here in groovy
as as well so for example in groovy you
can say class cat and of course you can
extend it from whatever you want to
extend it so string name let's say and
then of course cat name and I'm gonna
say the name of the cat so in this case
we're gonna say name equals the name and
of course if I were to create an object
of cat so I'll say define you know cat
equals new cat and you know here's a cat
and of course cat dot listen doesn't go
anywhere at all however what I can do is
I can say as friend I can ask it to
inject that in so pretty much the same
concept in GRU be used as instead of
using a width in the case of scala so
you're able to bring in a trait and and
very much the same thing happens they
create an anonymous inner class which
implements that interface for you so
while cats are not friendly that
particular cat ends up being friendly so
you can get that
of a behavior on your hand very nicely
so you can see how we are able to extend
this very nicely in this case so you can
do instance level traits as well but of
course what if you want to bring in
multiple traits into the mix well you
can definitely bring multiple traits
into the bigs as well so for example
let's say we are back here in Scala and
I want to have one more trait let's say
so I have a trait here called curious so
curious Strait is going to be let's say
this is going to have a function called
purr and it's going to you know per
curiously in this case so we'll say
equal to print line per well you can
definitely bring in multiple traits as
well so I can say for example dart /
well obviously in this case that
wouldn't work because we haven't
implemented that yet so but what I can
do though is I can say you know comma
and I can bring the curious straight
into the mix as well so we could say a
width curious and oops didn't mean that
okay cats always create trouble as you
can see okay so you can see in this case
we can bring that into the mix so you
can say with that particular trait and
with this as well and we can introduce
multiple traits whatever we want to do
we can certainly do that as well okay
great so we saw how we can bring in
multiple traits what about groobie
though well if you using groovy you
would say dark with trades right now and
then you would say for example curious
like this and that's how you'll bring in
multiple trades you don't use as any
more use with traits in groovy to mix
those in obviously if you are just using
at the class level you can just say
implements and then you can put comma
separation and groovy in the case of
Scala of course you would say width and
width like you did here and then you can
bring them in also so up to this point
all we saw was bringing in a trait we
also saw how to really mix our two
different traits together but in this
case we took a easy route because the
two plates didn't have anything in
common between them one had you know
listen Matt
the other one had a permitted so that
was really easy but what if we really
have plates that come together where
they begin to collide with each other
how do we deal with that after all so to
understand that let's take a look at a
slightly different example here let's
say for a minute that we have a class
and I'm going to say this is an abstract
class we'll call it as a writer and this
has a function called write which takes
a message which is a string so that's an
abstract writer imagine you can have
different types of writers you can have
a string writer a zip writer a encrypted
writer a file writer you can keep going
so you can have different types of
writers
well one writer is called a string
writer and the string writer extends
from a writer so wrie ter yeah that's
correct spelling and then of course I'm
gonna say override the right method and
in this case message I'm gonna take the
string and what am I gonna do with this
particular writer I'm gonna simply say
target dot append and I'm gonna put the
message into it that brings up the
question what in the world is a target
well a target is a string builder so
builder so target is equal to new string
builder so I'm bringing in the string
builder in here and brought that in and
I'm gonna also write an override let's
say in this case I'm gonna define a two
string method and in the case of the two
string I'm going to simply return that
target to string as a result from this
particular call so this is the code so
far I have so I have a writer class
which is abstract I have a string writer
which extends from the writer and has a
write method which is going to output
the content into the target and then of
course to string is going to give me
that information let's go ahead and use
this so to use this what I'm gonna do is
define a function called write stuff
which is going to take a writer as a
parameter so I got a writer coming in
and what are we going to do here I'm
gonna first of all say writer dot right
I'm gonna write
something extremely important this is
stupid and then once I write it I'm
gonna output the writer itself let's go
ahead and try this so write stuff and
I'm gonna send to it new string writer
and you can see in this case it simply
gives us that output so that seems to
work just fine so far but let's say our
problem changes a little bit not only do
we want to write this stuff in this
particular writer but there's a rule
that's a requirement that says we want
to be able to write everything into this
writer but all in uppercase well so I
want to convert these things to
uppercase and then write to the target
here's a first idea I could go to the
string writer and I could provide a
method here called you know convert
let's say convert to uppercase let's
just say we do this if I write the
method call convert to uppercase here
within the string writer what would
happen it becomes available only within
the string writer that's no fun because
we have filed writer we got you know
other kinds of writers as well oh gosh
what do we do
here's an idea let's not put it into the
string writer let's go to the writer
itself we can put it here into the
writer well that's a nots better because
we are not going to violate the drive
principle we're not gonna duplicate it
everywhere but unfortunately now we
violate the open-closed principle
because if you want yet another
converter we got to open the writer and
change it and that's a violation of the
open closed principle so what can we do
well how about a trait so that seems
like a great idea so let's see how we're
gonna use a trait for that purpose so
notice what I'm gonna do here I'm gonna
take this code I'm gonna write a trait
called uppercase you know converter and
in this case an uppercase converter
extends from well what am I gonna extend
from writer and then of course I'm gonna
provide a method here but let's take a
pass here and look at what we just did
we wrote a trait called uppercase
converter in all the
I used so far you never saw me extended
trait itself we always extended from a
trait but in this case that trade itself
is extending well this word extends
doesn't mean extents it simply means you
are placing a constraint on the
uppercase converter to say you can only
Mixon this converter into something that
is a writer so this is not a free fall
or all mix in this mixin is available
only to the writers and that's what
you're saying in this particular case
it's a weird way to say it now once you
have extended from this you're saying I
want to use in this context but how do
you really provide the right method well
notice you have the right method here
within the writer so I'm gonna go back
here and provide the right method but
what am I going to do within the right
method well remember this is the trait
so what I'm going to do is I'm gonna
take the message and say to uppercase so
I'm converting it to the uppercase but I
really need to write to the destination
because this is just a trait remember
it's the mixin remember you don't go to
your ice cream shop and say I would like
to have an ice cream with a mixin - the
ice cream please right that doesn't make
any sense you don't eat the mixin you
eat ice cream with the mix in so where
is the real ice cream at this point well
for that what you're gonna do is you're
gonna say super dot right and you are
saying I'm gonna convert this to
uppercase and then I'm gonna write it
into the super this super does not mean
super it really means it's the object to
my left now you may wonder why they
wanted to use extension super well
because these are well known keywords we
don't have to really reinvent more
keywords and that way you can actually
use the same keywords and confuse the
heck out of people so this is really
nice
so you can use super and what does this
mean not a vertical hierarchy but one on
my left so the straight kind of attaches
to this object on the right side so in
other words it's kind of like if this is
my object that Trey
kind of like a parasite attaches to the
right side and then it says I'm here
when you call me I will call on the
super right usually super this on the
top for this guy the super is on it's on
it's whatever direction right right so
it goes from right to left that's
basically how it works so it's going to
pass the dump but here comes one of the
problems
notice where the light came from the
right came from writer well whenever you
override a method what do you normally
use override so you gotta say override
for it but that brings up a small
problem as well right is not a
destination it is an intermediate
function for you to use right the super
has to provide the right as well how do
you normally say yet another class has
to implement a method what key would you
use for that
abstract so why not so you say abstract
over right now you look at this and say
huh there's a very easy way to fix it
don't think about it just put those two
words and you're done right
so that's basically what you did you
drop those to N and this says I am
overwriting the method from the base and
then this one says I'm gonna require
this other guy to provide it right so
that that's why you put these I'm not
joking you really put these two okay so
once you do this you got the trait on
your hand now I'm ready to use this
trait so what am I gonna do notice that
in this case right stuff new string
writer with upper case converter and
notice how that's converted to all upper
case so you can see the sequence in
which it flowed through so when you call
the right method it didn't collide with
each other it instead cooperated with
each other let's go through the sequence
and understand how this actually works
so if I go back over here notice you
call that right on this object you call
you pass this object to write stuff and
when you call this object to write stuff
or this right stuff do it called a right
method well remember the object has a
trait attached to it so the function
call went to the
upper case writers right method what did
it do it converted the string to
uppercase and call the right on the
object to its left the object to its
left is the string writer so the string
writer said I'm gonna take whatever you
give me which has been converted to
uppercase and put it into the target and
as a result you can see in this case
when we wrote this we were able to get
this nice conversion into a into this
particular object so far so good yes
please yeah we got to see that in just a
minute so let's take a look at that
awesome question so let's see so I'm
gonna write one more converter here well
before I write this converter I have to
share with you a really sad story I came
to know that I'm a really bad guy and
and it's really hard when you realize
eventually that you're really a bad guy
so I travel a lot
and I you know travel around the world I
mostly spend you know time with
programmers and you know programmers are
right we always speak of our minds well
I was home one day and I was having a
nice chat with my little son and I said
something and immediately he got off and
ran to his mom and whispered and and I
saw my wife saying something to him and
walking towards me and I knew I was in
real big trouble so she came to me and
she said did you say bad word to our son
I said why would I say bad word to
children and then she leaned over and
said did he use the S word and I
mentioned is word and said you mean this
kakashi
that's not the s word and then she
leaned over and said did you say stupid
I said of course I said stupid why would
I not say stupid because we say this all
the time at work and then she said I
mean I've been teaching children to have
good manners you're not supposed to use
the word stupid in front of the children
you should be very polite I had to hang
mail it head low and say I'm really
sorry I won't do this anymore
I won't say anymore stupid so so this is
when I came to know that I really should
be very careful when I talk to children
right can't use the word stupid I didn't
know this actually we see this all the
time using the word stupid but anyway
that's lesson I learned so I have to fix
this so what am I going to do I'm gonna
implement a trade for
so I'm gonna change this to a profanity
filter right and this proprietary filter
says if you come in with the word stupid
so replace the word stupid with the word
there we go so we did the know we
removed it so wherever profanity filter
says if you call I will replace the word
stupid with that word stupid well that's
great so far let's go ahead and give it
a try so right stuff and I'm gonna say
new string writer with profanity filter
and of course now if I go back and run
this what is it going to do oh did I
make a mistake so a profanity filter
that I have so trade profanity filter
extends writer and what does it do it
says replace with it and of course in
this case I'm gonna call it with the
profanity filter that's what I'm gonna
do and you can see how beautifully that
particular filter kicked in and it was
able to do the job for us you know where
I'm going with this what I'm gonna do
now is I'm gonna say write stuff but
this time I'm gonna say new string
writer with uppercase filter with
profanity filter so what am I going to
do now I'm gonna say first pass it to
the profanity filter let it strip out
the word stupid then pass it to the
upper case filter and then pass it down
to that string writer and you can see
that in this case rather than colliding
with each other they are nicely
cooperating with each other as you can
see but this also shows one thing the
functions are not colliding but the
order does make a difference so in other
words this goes from right to left so it
starts with the profanity filter then
the uppercase filter and then the string
writer so as a result what if I were to
do the following I say write stuff a new
string writer with profanity filter and
then with over here upper case filter
well remember one thing I did a little
differently here if you notice the
profanity filter we wrote I only look
for the lowercase stupid I did not look
for the uppercase stupid so as a result
this is
got to convert the string to uppercase
when you come to the profanity filter
that is not going to strip out the
stupid because it's not lowercase and
it's gonna you know get through so when
I run this little code now you can see
it did not remove it but don't worry
about it this is perfectly okay in my
domain because the other day I got
really angry and I screamed this is
stupid and my son immediately looked at
my wife and she said daddy's angry be
quiet so this is perfectly okay when
you're really angry right so the point
really is that you can absolutely see
how the chaining of these traits work so
rather than things colliding with each
other they are nicely cooperating to
fill that in this is what I meant by
stackability
and look at the power of this you're
able to take a particular object you're
able to stack on it multiple trades so
this is like taking your ice cream and
putting more than one topping more than
one mixing on it and you can put as many
as you like
as it makes sense and if you were to
look at this while we were working with
this quietly all along there is actually
a design pattern we quietly used and
anybody recognizes this pattern that's
correct it's a decorator pattern so
usually in Java
at least the older version of Java the
minute somebody says decorator you're
not going to be really having any more
fun right because it's a new and new and
new and that really becomes very you
know verbose whereas you can nicely
change this together and create a
decorator so in fact we use the
decorator pattern here by nicely
chaining these objects together to
implement it so it nicely falls through
as you can see so what did we do so far
we look you can do the same thing in
groovy as well by using the width traits
the syntax is going to be just a little
different but the concept is exactly the
same if you're using groovy already you
probably know that there was something
in groovy called mix-ins and and now
they have what are called trades and
it's time for us to quit using mix-ins
and start using trades and the reason is
mix-ins in GRU we did not stack very
well at all and and they were when they
implemented it they didn't really think
through stackability
and eventually when they came around
they said this really sucks
and so they deprecated mix-ins and
they're in the implement race I think
crates are done a lot better in groovy
than mix-ins we're done
so you want to really start using traits
and groovy rather than mix-ins
that's a better way to go as well so to
summarize what we talked about we talked
about how multiple inheritance can be
very painful the concept is really valid
but the implementations have been very
painful traits give us a way to solve
this problem in traditionally in Java we
would go the route of creating an
interface and creating abstract base
classes and the effort and time we put
in to do this well fortunately we don't
have to do because compilers do this for
us now and so we don't have to write
that silly code the compiler takes care
of it but that only takes us halfway
through we really have to really think
about stack ability as well and traits
should really nicely stack up so the
methods don't collide with each other
instead they cooperate with them and so
traits actually give you a fairly good
amount of stack ability as well and we
saw how that actually nicely stacks
together so we can start implementing
these features very nicely so this gives
us an ability to really model of our
applications in a nice way and bring in
these so-to-say aspects our traits and
mix them together as we feel like if you
are interested in downloading the code
examples there on my website I hope you
found that useful that's all I have
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>