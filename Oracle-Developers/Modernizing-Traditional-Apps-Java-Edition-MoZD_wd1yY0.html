<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Modernizing Traditional Apps: Java Edition | Coder Coacher - Coaching Coders</title><meta content="Modernizing Traditional Apps: Java Edition - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Modernizing Traditional Apps: Java Edition</b></h2><h5 class="post__date">2017-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MoZD_wd1yY0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well good morning welcome to Java one
I'm Sofia Parra thena I am a developer
relations engineer at docker and my
topic today is modernizing traditional
apps the java edition of this program
that we have so we've all had to deal
with legacy applications and we're
pretty familiar with a lot of the
pitfalls of having to inherit
applications that somebody else wrote I
mean a lot of times the original people
who wrote the code have left the company
they're no longer around and
documentation is a bit sketchy you
really don't have a lot of idea what
that what's behind this application but
it's business critical so it keeps it
running you have no idea when it was
last updated and the general just sort
of the general attitude of management is
just don't change it don't break
anything don't give us any down time
however at some point you are going to
have to move your app to more modern
architecture however there is a certain
pain point in doing that and you want
the ability to be able to transition
gracefully for us and into that position
so modernizing traditional apps at
docker we have basically three points or
three legs of a stool support this whole
program to do that we do which is
portability of security and efficiency
and we have one very basic metric that
we use in word to justify going through
a program of modernizing your
traditional application basically you
have to cut 80% of the cost of running
and maintaining that application to make
it worthwhile otherwise you know it's
all green fields new apps that kind of
stuff
so when we say our three points or three
legs of the stool supporter that support
our argument the first one is efficiency
we want to reduce the size of your
infrastructure by at least 50%
second we want to make this application
portable our infrastructure has changed
dramatically from you know deploying
things on horizontal scaling multiple
servers onto machines and now on to
containers and to the cloud we want to
improve your deployment speed to be at
least 90 percent faster of what it
currently is and we want to improve
security so you know struts people you
know seriously you want to be able to
patch things very quickly and it's 90
percent faster so you want to make sure
that you have the latest patches from a
seed from the current CVD database and
make that your app much more secure so
in terms of efficiency what we wanted to
do is we want to consolidate
infrastructure by reducing the amount of
hardware or tree machines we want to
reduce the software cost licensing for
the vm's licensing for get piece of
software and gain overall operational
efficiency and one of the ways we do
this is we take away the run book an app
run book for and replace it with a
simple docker file so for example
virtual machines often contain a full OS
instance within each virtual machine
containers just share the single kernel
in operating system on a physical or
virtual server and so what we do is
instead of using virtual machines
container consolidates the
infrastructure by at least 50%
the other part is we're streamlining
configuration management before you may
have a large run book with a number of
configurations they're often printed but
we want to do is consolidate that into a
single text file that it's called a
docker file which commands basically
everything that you need to run the
application all the environmental
configurations such as ports all the
volumes vironment variables health
checks and more the docker file can
contain all the information and enable
you to deploy your app simply this
enables a very consistent deployment
across all sorts of environments that
you may encounter
so one of the things that we do is we
simplify app configuration management by
defining the app configs all inside a
docker file for a single container or we
can use a compose file for multiple
containers or we now have a stack file
format for deploying multiple containers
in the cloud in a inner orchestration
this allows us to eliminate our
configuration drips so we're no more
we're not patching things in place
anymore deploying a new immutable image
each and every time so we can actually
take a look what's changed in the
container compared to docker file so we
have a set of tools or built around
managing those images
one of the things we do is we improve
the asset management by providing either
a public registry or a private registry
for all the images that are created this
enables us to keep a record of all the
versions by tagging each of the images
so you may run on latest but you may
have some sort of error that comes by
and then you can fall back and roll back
to a previous version simply and easily
by just using by using the correct tag
so overall we can just copy or paste a
single command to deploy an app and
define the state we have enable rolling
updates we can roll back to a previous
known container do health checks as well
and we can also automatically reschedule
containers in the event of a failure
the other leg is portability we want to
be able to deploy the app anywhere and
so we want the applications can move
across multiple infrastructures and we
want to be able to do the infrastructure
agnostic that means hybrid
infrastructures where we can have both
Linux servers Windows servers now all
working in concert together for to
deploy the application so containers one
of the great things about them is they
abstract the applications from the
infrastructure itself so often you've
hear you've heard developers go and I've
often said this myself says hey works on
my machine that's not my problem
but what containers does is they package
the code and all the dependencies
together into isolated process so all
your app configurations are just
traveling inside the same app and
they're not built into the
infrastructure so it allows you this
easy application composition from very
simple apps to complex apps with all the
security your networks storage
environmental variables and ports all
built into them and the application
already knows how to contact you know
databases which ports are available
which networks it should use
so when I talk about container
architecture beings infrastructure you
can look in the bottom layer here you
can look at use Linux Windows mainframe
we support all of those also cloud
infrastructures jws and Azur and other
public clouds and deploying that on
whatever the hell with post OS that they
prefer to use or use and on top of that
we have docker Enterprise Edition on on
that which manages all the containers
and images that you use to do your app
so all the containers have all their
binary is and libraries built into them
ahead of time and they're those each
containers immutable so they won't
change at all
so part of the portability is you're
able to go into the dev cycle build
these things into container register it
into or put it into a registry and have
a security scan of that so that you know
that the applications whether using an
app server has the latest patches on it
check for vulnerability you can move it
into your test environment and make sure
that it is working and functioning as it
should and again within the registry the
security scan will also check for the
latest CVS and anything else is going on
and then push it into your production
environment final finally pushing into
your production environment
finally the third leg of our stool is
security so we want to do is reduce the
risk profile by creating a more secure
environment reduced basically your
attack surface area and manage your
vulnerabilities so the main thing we
would do is we allow this admins to
isolate the app through namespaces and
also we want to reduce any unnecessary
access to resources through cgroups as
well we want to reduce all those risks
associated with the older code and
components as well
so the environment that doc revives and
dr. enterprise it's a secure container
run time and orchestration art
architecture there each has each it
supports cryptographic node entity
identity and also automatically
automatic mutual TLS across all the
nodes
there's transparent automatic
certification rotation you can integrate
your own external certificate authority
as well and there is the option to crypt
container to container traffic
so one of the ways we make apps safer is
vulnerability scanning and monitoring so
there is security scanning performs at
the binary level we generated detailed
build materials to provide a security
profile for each of the application
packages and so you're able to make
informed decisions perform deployment by
looking at the building materials so the
the building materials is maintained and
continuously monitored against leading
CD databases so one of the things didn't
want to lever that leverage to secure an
automated supply software supply chain
and enable a chain of trust within the
apps as they move across environments
and then digitally sign all the
containers and only run the verify
containers we know that each container
is fresh and it's guaranteed and there's
no tampering involved and we automate
that workflow with repositories that are
immutable and automate the image
production
Dockery also provides a very granule
access for users apps and nodes we want
to restrict access to apps and resources
it enables to leverage predefined or
custom roles bake that on that and we
create logical or physical isolation
between apps and teams so quick thing
about the MTA process within itself so
we have a methodology about that where
we look at an existing application we
will convert that basic application to a
doctor te and move it on to modern
infrastructure and push it into a part
of the cloud or hybrid environment will
also implement modern methodologies in
terms of using CI CD and push ink to
create the images that for that
application and then push it into a more
modern micro-services more modern
micro-services environment so the scope
of doing this like I said we have a very
basic criteria is we want to reduce an
80% reduction in costs so when we do
this we containerize will look at an
application will say well containerized
and compose just a single app and
containerize it where it's applicable
will install the Dockery infrastructure
and then go through the whole end-to-end
deployment app using docker ee and then
perform some basic testing so in terms
of breaking down the deployment savings
before and after docker we can before
you'd have to take it offline deploy do
smoke test acceptance tests go into a go
100 plus man-hours but after a modern
app deployment using dr. Yee we could
take it offline deploy Reform acceptance
tests and go and no go and we estimate
it's going to be under 24 man-hours to
be to do this so demo time
I wasn't gonna do all you know all the
all corporate you know presentation here
so um what's the trick you can read that
but okay so I'm an environment here
called play with docker which is an
online environment that you can use to
essentially deploy applications deployed
images and I've pre-loaded this just
because the Wi-Fi here is I'm not unsure
how it is but so this is just an
instance it's up and running for about
well they let you run for about four
hours
so I've pre-built a couple of images and
I've taken an image here which is the I
believe it comes from a Riley book Java
EE 7 book and they have a movie plex
image that that I use to convert that
into and dot and convert that into an
image and put it in docker so I
basically I used git I downloaded from
yet
so downloaded from github you can
actually do this yourself too as well
and run it so the first iteration those
images it was originally built on
wildfly and
so what I want to do is take that can
take that take the source code compile
it and build it and build it so that it
runs
come on it runs on a container and
fortunately it seems to frozen up okay
so I've pre-built the image
and so what I've done is launched the
image and as you can see it
automatically opens up and women play of
docker it shows you the ports that are
open here's the management port for
while flying
should show up
so the app servers up and then we'll
actually take a look at the actual
application that we built
so you can see it's a fairly sparse
application it's with JavaServer faces
is the presentation layers built on so
we want to do is we want to take one of
these functions and peel it away and
build something a little bit different
from here and so one of the functions of
it is that it actually lists the set of
movies as you can see there's just a
pick list you know just you can just
click on one of these and select it and
it'll give you a few details about it
so one of the nice things about this
particular application it was about
written 2013 I believe is that it does
have a rest interface so we're able to
exploit that to build something a little
bit different so I took that particular
image and applied since it has the rest
interface wrote a quick react client it
just peels away that once in a function
of looking at movies and providing a
little bit more information so so I did
several things to you as well in order
in addition to writing a new react
client I also moved it over from another
application server from wildfly to
Tomcat EE and this is again done all
with inside the docker file which
specifies this so I'm running multiple
containers one's going to be running
node which is when are you running the
react application and communicating to
the original application via rest and
and the other one will be the original
application running a little bit
modified where I've changed the code up
a little bit so it's a little bit more
descriptive in terms of describing the
movies so you can see it's gonna bring
up Tomcat
okay and so here's the new application I
wrote basically same set of movies same
set of movie entities except you know
added in a few new things to make it a
little bit more lively so we have what
we've done is we've peeled away one set
of functionalities away from their
original JavaServer faces app modernize
a bit use a different technology and
then deployed it to another container so
switch between that so it's just this
kind of thing that you can do in terms
of modernizing your traditional
application so that's once the first
step in terms of doing that the next
step is you can also take your existing
application and I'm using docker hub now
which is our public registry to automate
the build on mate the building of these
applications so it's I'm gonna switch to
my organization of docker samples where
we keep these and I'm going to go ahead
and create a
create an automated build for it so I
previously so you see this but I
previously linked to my github
repository to this that makes us in
order to be able to pull the code in
oops doctor samples and the repository
is called Java EE demo and we're gonna
just build one of the containers here
which is I'm going to be the movie Plex
okay and it's going to be public we'll
give it a short description and we're
gonna have to customize a little bit
because of the way the project is
structured in github we have to give it
where the actual docker file location of
dr. luke logger file location is so
double check that
let's move you pluck seven okay we don't
need this extra one when you go ahead
and create that
oops okay so we've created this now we
can take the look at the build details
you know actually we haven't started the
build at all
but we can go ahead and trigger the
build and save those changes
so if we look at the built details this
is gonna take a little bit of time its
cued up take about five minutes or so so
I'm not gonna bore you with the details
of that as it's going to build so every
time that I make a change into the code
and push it up to github a new build
will occur so you can take that from the
repository and use that with a docker
file say you know the doctor file tell
it to pull the latest image and every
time you set up the app will be there so
pretty much completes the cycle in terms
of building the application and on to a
pipeline sure
um merge images Oh
typically a project will work on you
know we use get a lot so Wilmot will
make to-do changes there whoever is you
know who do pull requests and make
changes in the code that so a lot of
projects so we work on somebody won't do
the database portion or somebody will do
the front end portion somebody will do
the backend portion and we basically
collaborate over get on that and push
the changes through github and again
once the changes have been accepted and
all the changes have been merged a new
image bill trigger the on a registry
this is a public register you can have a
private registry as well and it'll
trigger the creation of new image so
when you're going to a production
environment you can have it replace the
existing image the current image with
whatever the latest has been pushed out
yeah so that's gonna just continue
building for a while a few more minutes
so at this point that's pretty much my
presentation what we walk through is
taking in actually is that a run around
are you back there he's actually the
author of this image and the author of
the book as well mine correct yep so run
actually wrote this a while back in 2013
and he was kind enough to let me use it
as an example so yeah so the original
image that we've taken is we basically
containerized it which was built on wall
fly originally then I moved it over to
then I fit in a container and ran it as
in a container image and then from there
we took the existing image since it had
rust functionality ready I wrote a
simple rack client to pull off one of
the functions off of it and
containerized that and then ran it in to
drain it into two different separate
containers in there ultimately I guess I
could push it all into I'm not sure if
the Wi-Fi but I could push it all into a
cloud with multiple into orchestrated
swarm is what we call Oracle
orchestration and do that later but so
the point a whole point of modernizing
again monetizing these traditional
legacy applications again is to reduce
the costs and we're striving for an 80%
reduction in cost and B even will do
that so
um you all have any questions yes
yes definitely so we have to which is
darker the Community Edition which is
something you can download and it is
based on our open source mobile project
and that you can download and run on
Windows or OSX we also have dr.
Enterprise Edition which you can try out
to you as well for like a one month
license if you want to try that out for
that so if you want to run yeah if you
want to run any of these things locally
you can just go to docker and download
Community Edition to run on your local
machine to test it out
yeah
yeah sure I can take a show you really
quickly here
so um let's take a look at a quick look
at a docker file
yeah
so actually so this is the first one I
did with the wild fly we do actually a
couple of things here so you don't even
actually need your tool chain in terms
of Java or having maven locally on your
machine we actually pull down a maven
container we have the thing called a
multi-stage build so we'll pull down a
maven container as well and copy over
the source code resolve all the
dependencies based on the palm file
there as well and then we'll copy that
and then build the code as well inside
that pack inside that container and then
we take that output from the container
which is the war file that comes out of
it and we'll take a second container
which is in the second part of this
multi-stage build and will specify the
wildfly container and then we'll go
ahead and in this particular one in this
example we set some parameters we told
it to set the admin the admin page and
set the admin password there but we'll
also copy that original War file over
that and moved it over into the JBoss
wildfly and then give it a couple of
commands here we just expose the ports
basically the application part plus the
management part for wild fly and then
tell it to run so all your configuration
is in there
I'm similarly who did something very
similar for this for the Dom cat again
built it again in maven and then copied
it over use the Tomcat container with
JavaServer faces jars built into it and
then just did the exact same thing
copied over so I mean and switching from
you know whatever platform that you want
to use whether you want to use wild fly
you want to use Tomcat you know WebLogic
liberty whatever supports you know java
ee it's very simple by just specifying
the containers and all these containers
have already been scanned and certified
for the latest vulnerabilities so
they're they're very secure
hmm
this container you would probably int
you generally would want to match the
container to if to make your life
simpler
I would match its likes like 702 I think
703 is the latest actually and you can
change it to 703 if you wish so I mean
it literally is this change you know yep
and then run it again and you'll have a
fresh container refresh image any more
questions
so I a question for y'all what do you
think I mean does it answer anything for
y'all or does this do anything for y'all
Yes No maybe
like I said we're what we're trying to
do is make sure that this is a lot more
efficient in terms of older applications
legacy applications that have been built
and rather than trying to come in with a
new team and you know just doing the
whole jad session you have to keep the
stuff running and there may be a
Greenfield opportunity later down the
road but it may not be in the budget
until you know next fiscal year or two
fiscal years down before you can you can
do anything so you know one way of
maintaining this type of infrastructure
and then but still moving it to the
cloud moving it to a micro service
architecture which basically is what I
showed is pulling away that specific
little JavaScript client this in this
type of approach will not able you it is
not a perfect solution that is certainly
a solution that's worth considering in
terms of maintaining older applications
yes
in this case let's say that there is the
if the okay so what if you're in an
environment in the Dockery environment
will scan the image for will go ahead
and scan the image for you when it's in
production and so if it is not if if if
what's in the registry is failing what's
in the most current CVE database that's
coming out of nist or wherever you it'll
go ahead and say you need to patch this
and it'll rebuild you can have it so you
can configure it so the triggers rebuilt
based on the latest container that's
been built that has that patch on it and
then but it's up to you to define the
rules and how you want to do the rollout
and deploy of all the other things
because the architecture gets
complicated after a while if you're
having you know a lot of containers that
are running out there
but what we try to do is help automate
the process of you know providing the
most secure most patched image out there
that's available to us
anybody else okay
so I'm gonna go call it now and thank
you very much I appreciate it for your
coming out</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>