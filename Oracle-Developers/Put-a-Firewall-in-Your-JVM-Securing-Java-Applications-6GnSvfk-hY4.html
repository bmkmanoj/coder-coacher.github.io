<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Put a Firewall in Your JVM, Securing Java Applications | Coder Coacher - Coaching Coders</title><meta content="Put a Firewall in Your JVM, Securing Java Applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Put a Firewall in Your JVM, Securing Java Applications</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6GnSvfk-hY4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">um hi everyone thanks very much for
joining us here today my name is purty
pandurang she I'm director of client
security solutions at war Tech and today
I'm going to be discussing some of the
security problems associated with server
side java applications i'm also going to
be discussing what we think is a pretty
new approach to application security for
java that we certainly think is capable
dressing many of the problems associated
with java application security in a
pretty different way today I'm going to
be co-presenting with the same baloch
Charney st. is a vice president at
Deutsche Bank in London we've been doing
some work together to address some of
their particular security problems and
he's going to tell you a little bit more
about that himself later on in the
presentation so to give you a little bit
of background on myself I originally
started out as a sysadmin and architects
working on the deployment and operation
of large java based systems as a result
voice had some degree of involvement the
securing of those systems for those of
you who aren't familiar with wartek we
are we provide secure isolation and
containment technologies for job
applications so I'm sure there's going
to be a bunch of sessions occurring on
this week on secure coding secure
development practices focusing on how to
write secure code and the best practices
associated with writing secure code
ensuring that code isn't subject to
exploit personally I don't have a
development background so that's not
what I'm going to be discussing it's
plenty of other people who are better
suited more qualified than I to discuss
those kind of issues I'll have however
had responsibilities as an application
owner for ensuring that Java
applications is secure and it's from
that perspective that I'm going to
discuss some of the reasons why the
ideal of simply writing better more
secure code is often inadequate when it
comes to actually hosting secure systems
so app dev suck at securing your data
apparently that's a
typically provocative headline from the
register just went out last week and it
referenced the study undertaken by
aspect security those guys have got a
booth upstairs interesting guys to talk
to the study itself was based on an
analysis of test results from about 1400
developers from nearly 700 companies
across a variety of industries worldwide
and the test results themselves a pretty
eye-opening what it found that
developers failed to grasp a lot of the
basic or critical concepts involved in
secure development and security
architecture so before I alienate the
entire audience before I start I want to
make clear that I don't believe that
that is a problem where the fault of
developers themselves clearly it's a bit
of a provocative headline designed to be
clickbait and generate a bit of traffic
but having said that I think we need to
recognize the reality of the situation
recognize why are in the position we're
in and why there is this perception that
were not so keep writing secure systems
properly despite all of the continuing
data breaches all security incidents
that have occurred over the last couple
of years it seems that in a lot of
organizations security still isn't being
taken seriously enough a lot of
organizations and it's not getting the
priority but I think it deserves perhaps
one of the best most recent examples of
this is home depot this has been in the
news a lot in the last week or two over
the last couple of weeks Home Depot
disclosed a debit and credit card breach
that was occurring over about six months
of this year earlier on earlier on this
year and it was about 50 million card
numbers compromised officially making it
the largest retail card breach on record
so wasn't a problem with Java per se it
was a problem with point-of-sale
terminals but i think the sentiment
behind the quote on screen is pretty
typical of a lot of organizations we
sell hammers we're going to worry about
our retail efforts we're going to worry
about shiny we're going to worry about
release dates and security is going to
take back position to them the aspect
security study really reinforces this
issue it's next to impossible to expect
to developers to deliver highly secure
products without the right level of
training and support from the
organization so eventually get a show of
hands I mean how many people agree with
that sentiment it's pretty hard
sentiment to argue with really how many
people think that developers are getting
adequate training it's for in your own
organizations no one okay that's pretty
telling then so if we look at the
composition of a typical enterprise java
application the problem might actually
be a little worse than we think because
if we really want to secure our systems
we not only have to consider the code
that our organization is responsible for
so the code that our internal
development teams deal with every day we
have to consider all of the other layers
of the application stack as well so
superficially we might think that the
code that our internal development teams
are responsible for constitutes the
entire application but of course the
reality is that typical enterprise java
application is more than likely to make
use of a whole bunch of third-party
libraries many of which might be from
different vendors they might be from the
open source community could be things
like logging libraries things like log4j
for example XML parsing library's
database libraries and so on quite
likely to make use of a development
framework so something like apache
struts or spring MVC and of course an
enterprise java application is more than
likely to make use of some kind of
application server so whether that's
jboss weblogic tomcat and so on and of
course it has to rely on the Java API is
that are part of the JVM itself so all
of these layers
all of these components they have their
own vulnerability profiles they have
their own exploit risks they have their
own patch and release cycles that are
all different from each other and a
vulnerability in any of these layers
puts the entire application and the
whole JVM at risk a couple of months ago
sonatype released a report and their
analysis found that a typical enterprise
java application actually gives
consisted of about ninety percent
imported components and of these about
71 percent have a critical or severe
vulnerability associated with them so if
you look at the apache software
foundation website there's approximately
200 java projects listed there
everything from log4j to the cassandra
db2 or the machine search engine and
these components are often embedded
inside applications in non-trivial ways
it's not immediately obvious a lot of
the time how these components are being
used inside an application so can simply
keeping track of components and simply
keeping track of the vulnerabilities
associated with those components it can
be really difficult so with the best
development team in the world there's
code review processes the best
penetration testing processes the best
static analysis process is in place
finally ten percent over the executing
code of a given application is actually
written or owned by the organization
then there's an enormous amount of code
out there that has potential flaws or
vulnerabilities associated with a good
example of a component seems to be
embedded all over the place is apache
struts struts is very widely used to
development framework a hugely popular
but despite its widespread popularity
hasn't got the greatest reputation for
security in fact in the last two years
it's had a number of critical remote
code execution volunteers associated
with it for those of you who aren't
familiar with the terminology on screen
CVE is a unique identifier for publicly
known information security
vulnerabilities and a CBS s kors is a
scoring system for assessing assessing
the severity of those vulnerabilities
so in this case a CBS s score of nine or
ten is pretty much as bad as it gets it
indicates complete remote compromise of
an application across the wire using a
malicious or especially crafted URL so
once you compromised a vulnerable
instance of struts you can pretty much
do absolutely anything that JVM can do
so whether it's changing files leading
files opening a remote shell for further
exploit or indeed shutting down the
application itself so while most
application owners have probably have a
pretty good understanding of how they
might use something like struts or how
that's embedded into their own
application it's often not immediately
obvious how components like this can be
embedded inside third party or
commercial software next up I want to
get a quick show of hands how many of
you are running production server-side
applications on Java 8 right now anyone
one person se7 little bit more messy six
more five good four one three two one
you be surprised actually that no no an
organization is actually running some
java one in production right now a kind
of joke that java in some respects is
going to become the new cobol once you
get something alive it just doesn't die
it doesn't go anywhere so all the time
when we speak to customers and we asked
them what version of Java running the
answer is often a variation on all of
them which is pretty scary from a
security point of view the pie chart on
the screen is actually pretty typical of
a lot of the organizations that I've
spoken to you'll see that Java 7 or 8
together form less than twenty-five
percent of the deployed application
based and I think that's probably about
right in the room here
and for five or six represents about 75%
so these are versions with known
problems and vulnerably is associated
with them so the question is why why do
they persist why do people still run
java 5 or java for java 3 and
organizations there's a couple good
reasons why i think in a lot of large
organizations and we got something live
into production no one wants to touch it
there's a lot of resistance to the
introduction of risk by messing with
that application all the components that
I mentioned earlier might have version
dependencies associated with them so
library version X might depend on
application server version y which in
turn might depend on a java SE version z
so simply upgrading everything and
patching as soon as a new version is
available is non-trivial a lot of the
time so an application right also depend
on deprecated ap is that will break in
the event of an upgrade if an
application see realizes data to disk or
a database in SE 54 map and there's no
guarantees that that's going to be
compatible with se7 Foreman there's also
plenty of non technical reasons why
upgrades that occur in a lot of
organizations with limited resources
might simply be down to the fact that
new projects get allocated the vast
majority of resources and as a result
the the maintenance of old projects or
existing systems can be neglected so if
we consider all these problems poorly
written code the wide array of
components that are coming from outside
of the organization imported modules
legacy applications running on legacy
JVMs the JVM itself doesn't really help
us to deal with these issues in fact the
JVM itself as an appointee security
security checks all enforcement is
through the Java API s and the security
manager but the security manager in the
JVM are we the same things security
manager is part of the Java API s and
they're a bunch of exploits that
bypass and remove the security matter of
its installed there's actually a session
this time yesterday walking through the
anatomy of a security manager of bypass
exploit which I'm so sure some of you
might have attended but I have a more
importantly I guess for service server
side java applications most server side
java deployments at least in my
experience don't enable security manager
anyway so if the screw d manager is
compromised if there's no security
manager then the JVM of course can be
constructed to do absolutely anything so
the point is I guess the security
manager does provide some simplicity
controls which are I guess arguably
unreliable and people don't use them
anyway and the JVM provides no security
controls at all on top of that neither
the security manager in all the JVM
itself can do anything to help protect
against the wide-ranging web application
security vulnerabilities that we all got
to deal with the moment so things like
SQL injection cross-site scripting
cross-site request forgery and so on so
for those of you who aren't familiar
with wartek vortex developed a
containment and isolation technology for
job are built on top of oracle hotspot
i'm sure many of you familiar with
docker if not docker I'm sure you're
familiar with VMware we've done
something similar inside the JVM itself
so what that exposes is a facility that
we called Java containers Java container
is similar in concept to a docker
container but running inside the JVM you
can run just one container or you can
run a many of them if you want to you
can run three instances of weblogic five
Tomcats a couple of j bosses some
standalone java applications essentially
in an isolated container format on top
of a single JVM in a single heap space
so this can lead to some significant
increases in application densities same
proposition as docker or VMware as the
JVM itself then is now truly
multi-tenant so to clarify a little bit
more detail while these containers
actually represent each Java container
is essentially a completely isolated
abstraction of a real JVM each container
has its own class path class loaders
namespace environment variables heap
court and resource quotas associated
with it all code running inside a
container is essentially trapped and
emulated in the same way as a hardware
virtual machine monitor and finally
every container has its own JRE version
associated with it which can be
different to the host JVM version so
from from a security perspective then
that allows us to do some kinda
interesting things in the JVM itself we
can enforce all manner of controls over
applications are running inside these
containers so a couple of examples
during run time every incoming and
outgoing access that goes into an
application is running inside one of
these containers could be intercepted
and checked by the hypervisor those
running inside the JVM so things like
class loading could be intercepted
unchecked native library loading could
be intercepted and checked parameter
return value checks file system
operation checks Network checks and so
on null pointer checks type safety
checks and operating system access
checks all of these rule these controls
are exposed via a rules engine that's
built into the host portion of the JVM
this allows control over all aspects of
an applications behavior when it's
running inside a guest so you can
control file system operations using the
same kind of controls that you expect
from an operating system you can control
network operations in the same way that
you can control a firewall or packet
filter
but unlike an operating system or a
firewall you've caused gotta control
over Java specific capabilities like
class loading a reflection and native
library loading and so on so you might
be thinking then house all of these
different from the capabilities of the
security manager unlike the security
manager in Java security enforcement is
done in the host portion of the JRE so
the host portion of this virtualized
environment not in the containers Jerry
so as a result doing security
enforcement outside of the containers
JRE means a couple of important things
from a security perspective number one
security enforcement is version agnostic
so it's not tied to the version of the
JRE that's running inside a container
number two then security enforcement can
control any application operations
inside the security manager which as I
mentioned earlier security managers
can't do so things like the sequel
injection and cross-site scripting so
this is built into the runtime built
into the JVM itself mitigation of things
like SQL injection so this is what a
container rules file looks like rules
file itself is just plain human readable
texts no need for programming knowledge
or additional compiled classes the rules
can be updated at runtime without
service interruption without requiring
an application restart and perhaps most
importantly we can apply all of these
kind of security controls without having
to modify any application code so this
doesn't depend on modifying an
application which we may not have the
source code to anyway it doesn't depend
on modifying any imported jar file code
application server code or the JRE
version as I mentioned briefly in an
earlier slide one of the interesting
features of these Java containers is the
ability to run older JRE s on newer JVMs
so as we've seen it's often the case
that administrators have a lot of legacy
applications there in production running
old older
the middleware or on older versions of
the Java Runtime itself java containers
allow us to run an up-to-date host with
a different guest version so from a
security point of view that's pretty
important what it means the end as we
can run say a java 7 host can run a
guest container a guest application on a
job or five runtime so that allows us
then to mitigate a lot of security
problems associated with older
applications while still maintaining
complete compatibility for the guest
application so more specifically then
the application itself doesn't see any
kind of API change any deprecated call
still function any serialized objects
that when persisted to disk or database
are still exactly the same format the
application is still using the API there
was first test against so as far as the
application itself is concerned
absolutely everything is exactly the
same as it was before but from a
security perspective then we've
potentially mitigated some many of the
problems and vulnerabilities associated
with that application so I want to take
a quick look at a specific example of a
common security vulnerability and and
how we might deal with that SQL
injection despite all of the massive
data breaches and education campaigns in
the last couple of years SQL injection
it still remains at the top of the list
in terms of security problems that we
need to worry about so whether that's
the OWASP top 10 SQL injections number
one on that all sounds top 25 it's
injections number one on that most of
you hopefully because we've all got
fantastic training and supporting
organizations hopefully many of you will
recognize why the code on screen is
pretty bad idea and yet simple
programming errors like this the result
in an SQL injection frequently turn up
in applications they turn up all the
time you hope that most of this stuff
will turn up as part of code review
static analysis or pen testing processes
but a surprising amount of these kind of
errors slip through undetected in the
party or vendor code these kind of basic
errors are also present in a lot of the
legacy applications we might have inside
an organization that predate current
security initiatives so you know in 2012
you might have implemented some
fantastic new developer training and
review process but you've got
applications were written in 2005 or
2004 still in the organization it may
well be the case that vulnerabilities
and those app older applications are
going undetected so what can we do about
this kind of problem if we assume that
there will always be vulnerabilities in
our applications the usual mitigation
approach is to just throw hardware at
the problem and hope that that provides
some measure of protection so this is
all of the three-letter acronyms that
have emerged in the last couple of years
idss IPS is WAAFs and so on but the
problem with any perimeter based
approach to dealing with application
security is the lack of context any
perimeter based approach to application
security web application firewall for
example has no visibility of what
actually goes on inside an application
so if we have a look at a quick example
of an SQL injection attack the first
URLs what someone might enter into a
browser to trigger an attack the second
URL is the URL encoded version that
actually gets sent to a server and it's
that version that the second version is
what gets seen or intercepted by
something like a web application
firewall what's a web application
firewall or any perimeter based tool
doesn't see is what finally ends up in a
database so the Select statement that
actually ends up getting passed to a
database as part of an SQL query Web
Application Firewall has no visibility
of so it's that lack of context is that
lack of understanding that lack of
visibility into application logic which
is fundamental to why
think a lot of perimeter based approach
this application security are inaccurate
so inaccurate I think that quite a
number of people that I've spoken to who
are responsible for things like web
application firewalls simply leave these
tools on in logging mode only rather
than unconditional blocking mode because
the perception of risk of false
positives interfering with or causing
problems with an application is just so
high so technically the way that we can
handle something like SQL injection
inside of these Java containers is with
the help of a variable tank checking
engine that we've inserted into the host
portion of the JVM itself for those who
aren't familiar with this concept of
tank checking it's a feature that's been
present in a number of other programming
languages such as perl and PHP for a
long time and essentially it involves
the tracking of untrusted data from an
untrusted source like an HTTP query
string through any kind of string
manipulations concatenations or what
have you inside an application through
to the point that gets presented to a
databases in SQL query so what's really
critical where this a kind of approach
this in JVM approach when compared to a
perimeter based approach such as well
internally the JVM can make the clear
distinction between the code portion of
an SQL statement that's been written by
a developer and the untrusted data
portion of the statement is coming from
an untrusted source and it's it's that
ability to make the distinction between
what is code what's data what's coming
from inside the application what's
coming from outside the application is
really key to making an accurate
determination as to whether something
constitutes an injection attack or not
so just want to give you a quick very
quick demo of how that might work in
practice so I guess I'm tempting fate by
dealing with live demos so what I've got
here is a very simple badly designed
application that's a subject to SQL
injection is running inside one of these
Java containers on the JVM and I guess
this is the canonical example of sequel
injection very simply modifying the URL
so in case instead of returning a single
table from a database we're instead
returning the entire database so of
course this is just some dummy data
could be credit card data names dates of
birth health information or what have
you and what we can do with a java
container then is simply enable a rule
and I'm just going to do that now to
mitigate that now you look that it's
it's a single one line of rule you
compare this is something like
modsecurity from apache or any other
kind of web-based perimeter based
application security tool potentially
got hundreds if not thousands of rules
that responsible doing regular
expression matching string comparisons
on urls to try and make a determination
as to whether something is an attack or
not the approach we've taken then is
essentially to insert ain't tracking and
a lexical verifier inside the host
portion of the jvm itself so it takes
away that burden of administration of
dealing with something like SQL
injection attack takes that away from an
administrator and puts it into the JVM
runtime itself so if I enable that
reload these rules simply refreshing
that again takes that problem away so be
quite clear then what we've done here we
simply turned on a one-line a rule we
haven't modified any code and the JVM
itself now is
resnet sqlexception another quick
trivial example I just want to show you
and it's relating to struts and some of
you may be familiar with this struts
demo application it's the reference demo
application that comes part of the
struts package not particularly
interesting after so it just prints out
some stuff in English and Spanish but if
we post in a ridiculously long URL that
corresponds to some remote code
execution essentially all we've done
here is by crafting a malicious URL
we've injected code into the struts
application of course this could be done
anywhere remotely across the wire from
anything that has access to the
application and the way that we can
mitigate something like that is with a
different kind of rule and that in this
case is slightly more complicated but
essentially what we're doing here is we
are preventing the invocation of the
specific vulnerable method that
corresponds to this vulnerability so if
I save up my rules now and reload the
rules what I'm going to do is just
reconnect to tomcat I'm going to paste
this URL in again and nothing happens
nothing happens is good because it means
that the vulnerability has been
mitigated so interesting enough when we
had a look at the fix that came from the
apache foundation for these particular
issues essentially what they did they
pulled they pulled that vulnerable
method from the co all together
the problem is that took a couple of
weeks for a patch to be issued when you
get a patch in for something like that
has to be brought into the organization
the organization has to test it
regression testing waiting for a change
control process so on and so forth by
the time you actually bring in a real
patch for an issue like this
internalization and push it through to
production it's a best case probably a
week or two worst case probably a couple
of months before you can push something
like that live so what this is then is a
new security control the way these kind
of Java containers make possible is I
guess a new category of security
technology this isn't about secure
development this isn't about secure
coding practices not about perimeter
security this is building security
capability into the application run time
itself it's unfortunate I think that the
Java Runtime hasn't been leveraged
effectively to enforce consecutive
controls because the JVM by definition
already sees every security relevant
operation that an application does so
this is what Gartner are calling runtime
application self-protection and rasp or
runtime applications of protection
solutions what we think are ideally
placed to deal with these kind of
application security problems things
like web application screw problems like
sequel injection or cross-site scripting
that I mentioned because the JVM sees
everything applications doing it sees
all day is coming into and out of an
application sees all events affecting an
application sees all the executed
instructions any database accesses
Joseph fireman one of the leading
security analysts at Gartner is a strong
advocate of this as an emerging category
of solution I was at the Gartner summit
in washington d.c a couple of months ago
joseph gave a fairly provocatively
titled talk called farewell to firewalls
so i don't think he was seriously
suggesting that we dispense with
firewalls or a perimeter based
approaches to security at all rather he
was highlighting that perimeter based
approaches just aren't the civil silver
bullet the people thought they were
going to be a couple of months ago a
couple years ago rather and that we need
other more layered approaches to
security and run times the ideal place
to insert that so with that I'd like to
hand over to my co-presenter saying bite
of China you have Deutsche Bank to
discuss why this kind of approach to
application screw is particularly
relevant to them in a real world
environment Thank You petit that's a
great demo by the way the first time we
saw the struts vulnerability being
mitigated that sent a buzz through the
cybersecurity team and for us working in
application and web platforms I mean
there are a number of immediate benefits
that we saw from the capabilities that
are afforded by the warrior tech cloud
virtual machine so I think the best way
for me to express what these kinds of
technologies do for us and the value
that they generate is we're actually
talking about our Java hosting platform
in the bank so I work with an
application on web platform so my
responsibility is the architecture and
design of Deutsche Bank's flagship java
application hosting platforms DAP and
also responsible for the architecture
and design of the web hosting at
platform as well now adapt has some 600
business applications deployed on to it
that translates to 4,000 DAP clusters
which is over 10,000 Java Virtual
Machine processes distributed globally
and that that's back there
infrastructure if we imagine we have a
patch that we need to release due to the
struts vulnerability of zero day x
Roy the ability to actually get that
patch out and into production in time is
critical to protect the bank's
reputation I Security's a big deal for
the bank or a financial institution
we're constantly being attacked and
having to go through a whole build and
release cycle is quite a barrier to it
reacting quickly to mitigate a
vulnerability now what do want to talk
about my agenda today is really how we
take some of these innovations and
exploit them on our own platform as a
service offering in the bank and before
I can just stir this forward so that one
of the things that pratik was talking
about is securing legacy java
applications simply by taking the code
and deploying on to a war a tech virtual
machine without any code changes and
benefiting from the version of the Java
Virtual Machine on the host vm so I can
take a Java 5 application host there on
a job at seven host a host or a tech
virtual machine without any code changes
mitigate a large number of
vulnerabilities that's really important
to us because and that's something that
we've rebranded for ourselves in the
bank we call it quarantine and
application so this is even without
having to add any extra new rules or
what make exploit the rules engine that
they provide we can simply quarantine
applications that cannot be easily
upgraded decommissioned or transformed
and for a bank our size there are really
large numbers of these applications out
there when you take that statistic that
you were talking about from your 75%
java 6 5 and 4 and you scale that to
10,000 jvms that's a lot of vulnerable
JVMs on our infrastructure and simply
you know we are aware of the
vulnerabilities there are a lot of tools
that we use to find code vulnerabilities
in
SQL injection or cross-site scripting
but the amount of noise that that
generates for us it really translates
into hundreds and hundreds of man-hours
of development work getting in the right
expertise to connectivity to use a
standard patching approach getting the
right expertise into the bank to
actually fix all of these problems would
be very prohibitive economically and
probably an attempt old fashioned we
just really wouldn't resolve our risks
at all it will take too long so the
first step for us was to create a secure
legacy Java infrastructure where we
could take these applications and simply
deploy more to aluratek virtual machine
and make use of some of the benefits
that DAP provides as a as our main
platforms or main power offering to to
manage these applications in a simpler
manner a more cost-effective manner
so again I think one of the benefits of
deploying the applications on top has
offering is a once an application is
contained on that secure legacy Java
it's very straightforward for the end
users to promote their applications into
production after they've done their
testing again without any real code
changes and that can be done very
quickly I'm just one way everything can
i increase the earth size of the sizer
thanks so in summary I think this is for
the fort with respect to us securing
legacy Java the water tech virtual
machine gives us a capability of
eliminating code changes and refactoring
from the quarantine in process that's a
big economic Quinn I think the
application firewall the rules engine
that you're talking about will see that
we've rebranded that as virtual patching
within the bank and I'll talk about that
in a moment I think that it's the guest
host JVM being at a more secure level
than that so the host JVM being a more
secure level than the guest is really
important for us as well it's just a
simple way of quarantine in our apps
ultimately it's more economic rapid and
safer way and traditional upgrade
approaches especially when they're not
actually available to you so virtual
patching this is really talking about
our our way of rebranding your
application firewall internally in the
bank to address the problems around the
standard patching cycle now every
quarter we receive patches from a number
of different vendors for various
applications where is tomcat weblogic
jboss all products that are hosted on at
that platform and that's fine though the
quarterly patch updates works for us is
something that we can schedule and roll
out in a orchestrated an organized
manner the issue occurs when we have a
patching event generated by zero-day
exploit now again 600 business
applications how many of them were
actually available to that struts
vulnerability
don't know but it will be at the number
of them and they weren't just a
correspond to deutsche bank he will be
every other Bank this using straps every
other struts user so the amount of
disruption that that causes to product
roadmaps and business delivery is
actually huge and that's the cost that
most banks simply don't take into
consideration I think a lot of places
still look at patching is something that
you've got to do and the business
demands that you do it forget about the
cost you just got to do it then go to do
it tomorrow put your business
application aside for a week and change
your roadmaps if you need to do that
obviating the need for that using
virtual patching by as pretty
demonstrated simply putting a single
line of herb rules engine code or maybe
a tool free but not many that really
results in a huge benefit for the bank
beyond that not having to restart
applications I think it's a as a
platform provider with thousands of
customers in the bank being able to tell
them that hey don't worry you don't have
to go for a whole release cycle here and
you don't have to restart your
application that's exactly what our
customers want to hear and that's what
that's a real differentiator for us when
we were being held up to our competitors
outside of the bank your your amazon web
services and so on so this is why it's a
real important k plus one of the reasons
like so extremely important capability
for us to have so again if we talk if we
look at the ultimately this is a far
more cost-effective way to manage
patching of applications for newly
identified vulnerabilities which i think
is refining more and more of finally
locking down applications so when we
first started working with wartek
through a FinTech innovation lab one of
my pet pace around the Java Virtual
Machine is the difficulty to lock down
an application using the JVM itself so
things like open
sockets connecting two different URLs
okay we all know we can control memory
and to some extent CPU using the RS but
to open up sockets for example you have
to go into the Java policy for you have
to restart the JVM for the changes to
take effect the water take virtual
machine the cloud vm really gives us a
capability not just to lock down network
i/o disk i/o but but also CPU and memory
Fred's as well sockets all within the
JVM that really means there's a
middleware engineering team I can
control all of this myself over having
to cross a network boundary or a UNIX
support boundary to do this kind of work
that gives me a lot more confidence that
we can secure our own applications
irrespective of what the other
infrastructure teams have done it's
really valuable for us beyond this the
water tank virtual machine also gives us
a capability of identifying when there
are indicators of intrusion in an
application so for example if you are
trying to open socket support that we've
told you you shouldn't be allowed to
open those ports it's too we will
actually be able to generate a warning
and we sent those alerts to our security
team and act on it far more quickly
really important for us you've seen the
cross-site scripting sorry the SQL
injection capability but again the rules
engine provides capabilities around
cross-site scripting as well ultimately
all of this reduces the cost of
remediating security vulnerabilities
that we've identified and as a
multi-tenancy platform as a service
where I've got a highly dense
infrastructure a large a number of
containers running on my infrastructure
I need to be able to know that those
resources are constrained on a per JVM
level and that a rogue JVM can't bring
down my entire service which is again
another important benefit for us so I
think with that and that affects you so
thank you yes I thanks everyone for
taking the time to join us today I guess
you know if we're going to summarize
there's a couple of key points to rule
on take away from this firstly just
getting it right in code absolutely
everyone should be doing that but it's
like driving of course everyone should
be driving more carefully but that
doesn't take away from the benefit of
having seatbelts and airbags and so on
we've got a huge problem with a
potential risks associated with imported
components a typical application just
uses so much of this stuff that it's
often extremely difficult to track down
where the vulnerabilities are associated
with these things and of course legacy
older java applications they're just not
going to go anywhere we need ways of
dealing with that stuff so with that
then we really think that application
security controls to address these kind
of problems are best placed inside the
JVM it's a natural place to insert
security capability for java
applications so thanks again any
questions at all
yep don't know if there's a question I
can equip 22 oh you mean like something
like a es api or something like a es api
put out by owasp yeah ok so the position
of we're taking is we don't care so if
someone is you already using something
like that that doesn't take away from
the JVM performing its own tank checking
if we detect that there is no one
trusted data coming from the outside
world into an application then
essentially we just pass that through to
an SQL query if it is and so to answer
your questions in the runtime we would
be acting in concert or in addition to
some other kind of API like a es api
there is no clear taint process I guess
it's independent of application based
approach like ASAP i so we're
essentially applying metadata to any
string because coming from an untrusted
source and then running a lexical
verifier against that to determine
whether or not there is a SQL injection
present in that
yeah good question like any
virtualization technology essentially
what we've done is write a hypervisor
you know academically it is like I
provides there in the same way the
VMware or zenora kvm is in some cases
that could be as little as you know a
couple of percent depending on the
workload and the type of applications
running on it could be could be ten
percent yeah so don't know how much of a
very detailed technical answer I can
give you but it'll I've said it because
it essentially the technology is
essentially a hypervisor everything that
crosses that container boundary is
essentially trapped and emulated in the
same way as a hardware hypervisor is so
yeah yeah
that particular so if so that was a
particular sandbox bypass in a number of
Java versions so yes I believe in that
case that the host well assuming the
host JVM is up to date and that
particular bypass occurred inside a
guest then the host itself can play a
part in mitigating that because it has
an understanding of vulnerabilities in
older versions so what we're doing is as
we update the host we are adding
additional checks for things like this
on behalf of the guest applications
right we are oracle hotspot direct so
we're actually oracle licensees and we
built on top of that interesting
question about you know how to decouple
ourselves in that and you know
potentially we'd like to say work with
any JVM that's certainly something would
be able to look at over the course of
the coming year yeah yeah exactly so
yeah at the moment we just were
essentially saying we're we're a hot
spot we're contain rising hot spots so
we these containers RTC Kate certified
with what we're you know we're subject
to the TTC cases testing process in the
same way as any other JVMs
yeah good question so early days at the
moment so there's a couple of different
ways we're thinking about how rules work
so as hossain mentioned number one I
guess applying essentially like a
mandatory access control kind of
principle to an application as one way
of securing things right so determining
what is the behavior of an application
what's it do these are the known
behaviors will essentially whitelist all
of that everything is everything else is
essentially treated as and normally and
blacklisted so that that by itself in
determining you know what is usual
behavior and then blocking unexpected
behavior provides you know high degree
of protection so to answer your question
about you know rules for other known
vulnerabilities things like the struts
exploit that I demonstrated there we're
going to be building up libraries of
this sort of stuff so we haven't quite
food out the details of how this stuff
might be released so we might release
like a tomcat rule set jboss rules at a
weblogic rule set for example I think
though that the former approach is
probably far more valuable than a
signature based approach we don't want
to fall into the same trap as web
application firewall vendors or
antivirus vendors have fall into and you
know have a corpus of thousands of rules
there's no benefit in doing that because
it just creates all of the
administrative problems that go along
with it you don't want to be updating
rules every five minutes to look for new
vulnerabilities better to have generic
broad protection capabilities from a
small set of rules
okay so a couple of different things so
number one if if the SQL statement ends
up getting passed to a database doesn't
have any tainted data at all so
someone's coding things probably using
not enough prepared statements or
whatever the hard-coded a query inside
the database you don't have parameters
of coming from outside of the
application in that case well by
definition that's trusted because it
doesn't have any tainted data so for
stuff that is potentially tainted then
there's a process of lexical analysis on
the date on the tatted portion to
determine whether characters or
statements inside that tainted variable
will change the semantics of the SQL
statement in a way that would correspond
to an injection so essentially we've
done is we've put a full lexical
verifier for pl/sql into the JVM itself
oh yeah absolutely you know it's it's
this isn't about string comparisons or
reg axes or whatever it's doing
syntactic verification of the sequel oh
my denial service on the verify I mean
potentially I don't know technically if
the developer team would have considered
the implications that i'll be happy to
find out for you but i think that that's
something they've considered it was
how does this
so about well we were in pure iron d
mode for a number of years our founder
and CTO was interested in a lot of
purely academic aspects to JVMs
compilation techniques and so on some of
the earlier work was particularly
focused around the density and
consolidation benefits to essentially
provide same kind of benefits as vmware
but inside the JVM itself commercially
we've been around for about three years
and security is a bit more focus to us
at the moment rather than the
multi-tenancy aspects err else
the
yeah so I think of those loosely answer
that question before it kind of depends
like anything but what we have seen we
were using industry benchmarks like spec
jbb and spec jvm and so on performance
is always a kind of non trivial question
if you if you look on a single box in
isolation and we run up to performance
comparisons on that against OpenJDK or
hot spot that we might see ten percent
or fifteen percent when you introduce a
real-life environment so in other words
introducing network latency introducing
latency that might be involved in a
database for example a lot of those
performance differences simply disappear
because the virtualization overhead at
that point is not the bottleneck but the
virtuals of the network latency for
example in a real-world application is
actually more of bottleneck
I do understand oh yeah so we want to
try and you know one of the benefits of
think is this a pro 2 we we don't want
to rely on software update to introduce
fixes for CBS we want to be able to do
this as a function of the rules engine
that's built into the container so rules
themselves then it's just it's
essentially just configuration it's
texts right so we would expect that
software updates to allow us to deal
with much broader categories of problems
so something like I don't know
cross-site request forgery or cross-site
scripting would be a feature update but
mitigations for CBS and Suffolk and so
on would be treated as a rule file
update yeah good question so absolutely
from a multi-tenancy perspective class
sharing makes perfect sense right yeah
you know if you want to run 5 web logics
on a single JVM then you can of course
get a huge benefit in terms of resource
usage from class sharing that's in the
labs at the moment it someone going
testing about that I expect we might be
able to release something on that early
next year anyone else so with that
thanks very much thanks taking the time
today
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>