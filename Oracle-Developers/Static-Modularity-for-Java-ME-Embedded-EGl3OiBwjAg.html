<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Static Modularity for Java ME Embedded | Coder Coacher - Coaching Coders</title><meta content="Static Modularity for Java ME Embedded - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Static Modularity for Java ME Embedded</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EGl3OiBwjAg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we have to see you here although not too
much of you so indeed hope that you will
see something useful for you in the
presentation I'm trying will be given to
you here which is called modularity in
Java ME embedded world and I'm my name
is Roberto Skov working for Oracle I'm a
Jeremy implementation architect working
for all organs in Pittsburgh for number
of years in this jeremy industry so and
do have some understanding of what's
going on there and i'd like to note that
the information i will be given is based
also on the not finished specifications
like the new Joe any GS ours as well as
some information regarding
implementation of Oracle Java me so that
you shouldn't be raising your commercial
decision on what I'm telling you so
that's the general we are given I will
talk about modularity as a whole in
software as well as how it's applicable
to Joe anyway it's needed and what
mechanisms are available and how you
might be willing to use those and what
challenges you'll meet there and what
what are potential solutions to these
challenges so first of all I don't know
whether you know you do have
understanding on how curious about why
Java I mean is it all or 11 to embedded
business so even recently it was not
jiving it was not there and and the
programming programming language is used
in embedded in the states were like I
only see and forth languages and we at
Oracle believe that a Java and Jeremy in
particular would be helpful
in the era of embedded devices because
it allows to greatly simplify
application development cycle as well as
well put some problems typically met by
lots of application developers to the
shoulders of platform developers like us
so that still beneficial for application
developers and of course there are lots
of Java me or Java developers worldwide
so that all these people receive very
very good and easy ability to develop
embedded applications which seem to be
like a rapidly growing industry at this
times so yeah as I'm talking to Joey me
you could imagine them that I'm talking
about small embedded so it's not like
that its servers not even devices like
raspberry pi but something more more
constrained very much mass volume and
that is why very much optimized both in
terms of software and hardware so that
you don't get any additional resources
on the device that you could spare on
the other hand these devices shouldn't
be universal they are typically created
to solve one or a few tasks in a quite
quite close domain so that you should
have in order to to work that you should
have their just the right tools as an
application developers in the platform
you should captures the right tools to
do your job and of course you don't need
to write extra code and you don't need
to be to need right extra code and not
need to spend extra efforts in order not
to sacrifice maintainability performance
and to have better time to market and
coastal development so after all why
Java me and you know that Joe amy was
kind of considered not that's dead
probably
but still not very relevant in the
modern modern world well as you know
Jeremy was in a mobile times it was
monolithic it was designed to solve all
kind of tasks which could be could
appear on mobile phones it was an
application platform it was a multimedia
engine it was like connectivity all
kinds of framework and all these kind of
things and that's a very good for for
the mobile phones and steel smartphones
in this future are following just the
same direction they are universal to the
maximum possible extent however that's
that's not not right for embedded and we
are learning from the from the mistakes
and we are more making Joe any more
adequate and we think that for embedded
for the problems of embedded I list on
previous slide the answer is flexibility
so we should make a java and Jeremy in
particular flexible enough to address
just exact problems of particular
devices or particular tasks the
developers are solving and two key words
here are modularity and optionality so
seen from what wikipedia gives us for
modularity word is a degree that the
system companions could be created
separated and recombined to so
particular tasks and the molarity is
well and it is a good thing by itself
because it allows to simplify the
process of designing the application it
allows you to to work as a team or as a
set of multiple groups on a single
single task as well as allowing you by
by yourself work later on on the product
you started earlier so not not to forget
about what has been what what are the
particularities of implementation of
this kind of
things as well as simplify testing of
course because you'll be able to unit
test based on your interfaces the
maintainability deployment cause if you
platform supports modular deployment you
can deploy only necessary pieces or
update Oh necessary pieces on the fly as
well as the wall of your product and
share the functionality with other
developers and the modularity comes in a
variety of flavors I will touch some of
them during the course of this
presentation like for example dynamic vs
static static molarity you divide it
sent you divided your application or
system into pieces and you recombine
them but once you assemble some
combination its static dynamic
modularity as opposed to that it would
allow you to install different pieces on
a fly for example and change the
configuration during the runtime of your
system also modularity maybe manual when
you do everything just with your hand so
maybe assisted by the tools for example
the tools which may produce static
analysis of your code so that you see
the dependencies might be generate
interfaces for you and these kind of
things and around Joe actually there are
a number of different implementations
for for molarity concepts like osgi
famous very well-known logic jigsaw
which is still planned for the Java Sea
gtk 9 in Jeremy world there is also
concept of modularity called Li blitz
that is shared library shared libraries
concept developed originally during
meaty three times and so well let's
first consider the aspect of modularity
in the Java any platform by itself so
there what what was available it's kind
of modularity in an old normal days
there was a configuration which was
either cldc or CDC on top of the
configuration was sit in a profile which
is the typically meet p or personal
profile personal
is profile and there were a number of
optional packages optional they are
called optional because they can be well
can be present or absent dependent on
the task which device vendor device
manufacturer was solving and that JS
this particular pieces could be taken
either fully or not taken at all only
we're rarely GSR scanty consisted of a
few parts like this as 75 for example
consist of file connection and personal
information management things like phone
book calendar and all these kind of
things so the blocks of the modularity
in pre Joey me eight days were rather
rather big and apparently these are not
adequately address then that the reality
of these days reality of embedded
systems because it's really the systems
we are the hardware and requirements we
meeting these days refer to the numbers
which much less than the footprints for
example of the implementations of that
days so how the evolution roughly looks
so from CLD c 1 dot one mobile days we
are going to seal dc-8 GSR 3 360 which
is in public review now and I'm PNG or
midp profile I sorry the number is
completely should be 1 1 1 110 way it's
now edges are 361 which is micra called
micro edition embedded profile which
provides the evolutionary updates to do
that what's called profile functionality
for Java me and how molarity looks or
personality the platform looks right now
so in seal dc-8 there are actually two
two major pieces or two tube two not
major piece 22 profiles one
called compact profile which contains
more or less the same functionality as
existed before in co DC one that one
extended updated to the modern language
features but the class library is close
to what was there and there is also
what's called full profile which
includes camp compact library profile as
well as adds lots of other features more
elections new buffers also neo file API
which is sure should be convenient for
use for java sea developers because it's
really typically used there as well as
new channels and login API as well we
edited by the list API we api's we
believe we are making Java me more close
to java sea and simplify the process of
migrating the developers from a sea
world to me as well as reducing reusing
the code and actually on Jeremy booth
and emigrants you can see the example of
communication library being reused and
modified just know by binary format
between the Java me and Java Sea run in
the same hardware so indeed adding these
kind of things it's very useful however
it takes it toll so it really requires a
footprint as well as increases the
complexity of implementation of Jeremy
which sometimes is not something which
is needed so that is why we are created
this full profile which is optional so
if you run your job in the application
on device the device can contain either
compact full profile so you as an
application developers what would you do
to prepare to the situation you might be
ready to accept it might be not but
indeed you should have a mechanism to be
able to be aware of that and until they
see this mechanism is system properties
so there is a dedicated system property
called my creation that configuration
which would allow you to understand what
profile you're running on so at the
start of your application you can check
the value of this profile and do
whatever you you need or you can do to
adapt to the city
but I have to tell this is not not only
not the only option a litter at the CDC
bi-level there are a couple of other
examples like GCF which can be absent
altogether or present altogether however
some of the individual protocols could
be not implemented and that's very clear
because we're a clear white could be so
because some of the protocols could be
not relevant for particular device and
by stripping the implementations of this
protocol we can conserve enough space
and well some of them might be even not
possible to implement on the device like
for example advanced security like as a
cell connectivity might be not possible
to implement on a very very limited
devices because of just absence of space
to put the ciphers for example so that
it's optional and you can use the system
call connector is protocol supported to
understand whether the implementation of
particular protocol is supported on this
device or not your gig providing the
name of the protocol as in scheme the
scheming connector to Tobin and the
boolean flag which tells the system
whether you need the server version of
this particular client version of this
protocol also the extensions of GCF in
co dc-8 are access point mechanisms and
these are also optional excessive Airy
useful if you want to want more fine
great control over your connectivity I
so you can supply options and even
control the parameters of them
connectivity for your device like create
access like connected different Wi-Fi
access points for example or set up
cellular network access points and list
them connect to the one you prefer work
with the devices which support multiple
cellular connections like multiple sim
devices and all these kind of things in
addition new file protocol is also
optional so even though if its present
in full profile it's mandatory but the
actual implementation may be
and just because there is no file system
own device for example now that's that's
that's very we're very frequent case
external so I'm moving up to an EP
Micronesian embedded profile which is
which sits on top of cldc their
situation was even more interesting
because given the requirement of being
able to address the particular task
solved by the embedded devices we
believe that each of the packages of
almost each of the packages of MEP
should be optional and these are mostly
individually optional basically the only
mandatory package is Joe X micra dition
midlet so your application lifecycle is
always the same but they're the package
itself this one is very lightweight so
we if you are kind of dealing not with
as an application developer with agile
machine but rather as a device
manufacturer for example it's very
beneficial because you can strip almost
there anything to conserve the footprint
and leave only necessary pieces well as
I said midlet the package middle it is
very very tiny and we believe we can
include it unconditionally because its
costs almost nothing but provides a
consistent lifecycle experience for
application letters in addition to
particular packages there are number of
things which are also optional like
application concurrency which indeed was
not defined by the previous versions of
the specs now it's it's different it's
it's written how multiple running
applications interoperate with each
other but this support is optional so if
you device this targeted to solve
particular single task of course it's
not required to support multiple
simultaneous application so you don't
need to implement that also provisioning
is optional so if application is
pre-installed on the factory and then
the java runtime can meet support for
application deployment for example
shared libraries as well as security so
it might be that
embedded devices well doesn't doesn't
have security support that's in some
cases it's acceptable and its really
really helpful in terms of like
footprint and resource a salsa village
and in the upper left corner you can see
this table which is actually copied from
the specification which provides a view
of what packages depend on which
packages so you can see it's rather
rather dance there so it's it's really
not it not the trivial and well there
are terrorized dependency it's just not
seen there so of course you can you
shall read the spec in order to
understand the dependencies but they are
there definitely so as an application
developer what you can do and MEP
actually gives more convenient
mechanisms for you to prepare to the
situation first of all the same
properties as you've seen in NC LDC so
the name of the package could be used as
a key and you but by issuing
system.getproperty call you can always
know whether this package is present or
absent but even more you can describe
the dependency from the application to a
particular package a particular feature
and the the names for the features are
of course part of the spec so that if
you declare this dependency as required
level your application will not be
installed on the device which doesn't
support this functionality so you're
protecting yourself from from the from
application being deployed on there i
implement java me implementations you're
not not ready to run on which makes your
application behavior more consistent and
predictable and the third thing is
what's called user agent profile a probe
is used by the device or bubble by the
java runtime when it connects to deploy
deploy
and server provisioning server it passes
the information about its capabilities
so that the deployment provisioning
server can always know what the
capabilities of the device or java
virtual machine running on device are
and being able to provision the right
version of the application if it's
possible or just decline the request if
no mm if it's not possible to provision
the requested application so here it's
like GCF is present and you see that an
EP also defines the names for the parts
of co DC spec silly c by itself doesn't
deal with things like provisioning so
that's why they're absent there the mep
solve this problem and here's very very
complex slide you practically done it to
to retreat but it gives gives a concept
that provided there are so much possible
combinations of the optional features we
don't want to to leave application
developers all alone so although
allowing for all combinations we are
still provide the guidelines for the
device and system manufacturers of what
what combinations might look like so
starting from the minimal profile set
there when only the basic features are
required and one like it's provide a
basis on top of what which application
system developers could get the only
necessary packages and moving up to the
full profile where it's required a kind
of logic violent suggested to include
all necessary knowledge and of course
each of these profiles defines the
recommended were kind of target
footprint numbers for forum and flash as
well as typical usage of the device of
course full profile is more more
relevant to the devices vision
multifunction more close to the mobile
phones
in early days and minimal profile set is
really for the single function devices
where typically the device manufacturer
or system integrator works closely with
the application developer so that only
necessary necessary pieces of runtime
are included for the application to
solve its tasks so that was about
platform modularity but of course it's
the modularity doesn't end there because
the applications themselves should be
modular enough and here are two topics
one is shared libraries for labels from
EP three times which allow actually
application to be split between multiple
jar files multiple libraries and solve
some some modularity tasks like the set
individual packaging I knew the
deployment so that these jars could be
deployed not altogether but like not not
of them for example could be bloated
this simple the single installation
which conserves traffic for example or
as well as conserving the device space
where you have ability to share binary
pieces of the applications so that if
multiple applications depend on the same
library the classes of that library
present only ones of course not multiple
times as it was without shared libraries
well what need to say that the execution
environment for shared libraries is the
same as the crucian environment of the
application which uses these libraries
so that single lilit which is used by
two different applications being
executed in two different contexts so no
no runtime data is shared and if you'd
like to share some data you have to use
specific mechanisms like shared they're
a mess for example for resistance or
storage then you consciously
data between the different runtime
instances of your shared library on top
of shared library in mep profile is
added that concept of services which
basically originated from the service
loader concept in Java Sea and merged
with a liberal support so that it
provides your capability for truly
individual deployment of the pieces of
your system or like libraries and be
able to discover these pieces as well as
be able to use multiple instances of
implementations of the same API or SBI
so well just a trivial example there are
two CU needless use one comprised of
single midlet and another have little it
inside and service concept allows you to
use the liability to from the midlet
from a different suit and i will not
will not stop on the particular example
it's just description of how you would
define this dependency and how would you
use it in a runtime so basically it's
just the same as service load their API
from Joe AC but it's it's connected to
the appropriate provisional terms
defined by MEP so that you really in
control what's provisioned what's used
what what libraries are could be used
and what's not so that your your
behavior is consistent and predictable
so UD for k you define your replication
between the modules like shared
libraries of services but you have to be
able to let them work as a whole so if
it's shared libraries in your execution
context you refer to it like by just
making a function color it's the shade
in a class if its service it might be
able that it's run in a different
context so that you should use where you
want to use actually additional
techniques in order to do what you want
for example if your service have to be
always running collecting for example
some information and your application is
started on
land and be able to request that
information from the service to solve
this kind of tasks it's provided
autostart it's a way for application to
be registered to start when the device
starts which is essential for embedded
applications because for embedded it's
typically that application is
controlling the device it's not not
other second party it's it's really the
thing which defines the functionality of
the device as well as push which was
always there which would allow the
application to be started when it's it's
really needed depending on the
communication protocol as well as
communication protocols by themselves
it's these are defined originally by me
p 3 its stream based communication under
which what's called IMC intermediate
communication protocol my part of GCF as
well as packet based communication is in
evidence application events so that's
basically all mechanisms we can offer
you but what what would be typical
challenges because modularity is well as
good thing it simplifies your task but
it also takes it toes as tall as a
mechanism and will require you to do
some some additional things so first of
all as you definitely thought when when
read through the slide it's a
fragmentation because now as the
platform is not not that monolithic each
and every device can contain different
set of api's as well as different
applications can can move differently on
different devices so application
developers should think about it well
your interface has become more what's
called standard you're thinking about
them more of course you define them
better which is good but which take
takes it time as well as might take a
footprint because before that you might
be defining just a single method call to
to a different class now you might be
defining the interface and the class
which implements that interface and
that's something which is not not well
it's not expensive but it still costs
something and those cabins regardless
whether it's assisted by the tools or
on-demand it manually and well indeed
even I say ultimate keys of modularity
which is closed world I know whether you
been on the session related to the
closed world but we are seriously
working on this direction which is like
a model when the application is combined
with the java runtime and all
unnecessary pieces are stripped so the
school thing by itself of course so your
your application and your your system
basically becomes much Muslim and there
is nothing unnecessary that's cool
reduce footprint reduced memory
consumption all but the problem is that
if you it's not that trio sometimes to
think about what dependencies of your
application are you think that there are
no dependency but apparently it is so
that it's not noticeable task but still
you have to think about what what it
guys you're using or what what
functional calls you make or what
dependencies you declare in your jet
files for example and swell some
something about what we are doing as you
can imagine that from these slides our
gel any implementation is very modular
well extremely modeler so we have to
solve these tasks on cow by ourselves
and maybe these thoughts will help you
as an application developers for example
or if you're kind of interested in
porting or system development that will
give you an understanding of what the
complexity of the task is so taken as an
example an EP implementation now we
developed
this what we call subsystem decoupling
concept where we divided our source code
into subsystems each subsystem is
divided into libraries which have their
interfaces defiant as well as might
contain single or multiple
implementations for example on different
type of devices or different types of
well functionality dependent on some
factors like footprint or security
requirements and all this kind of stuff
and we have finis in mep right now we
have one color it in ninety libraries
with 230 implementations well rather
receive number and to deal with that
first of all we have to be able to
define the dependencies between them and
we developed a specific tool and the
language to describe the features and
the dependencies between them as well as
specific file format and user interface
to manage so that when we as an Oracle
providin system integrators the
implementation of our java runtime that
integrator could easily build necessary
configuration like using the UI to for
example so all the dependencies are
clearly seen if some dependency conflict
happens we provide the back-trace so the
integrator can understand what's wrong
but what inconsistent components are
selected all these kind of things so
it's that the concept of the thing is
actually originated from the Linux
kernel configurator tool but it's more
more powerful because we have to solve
additional cases in addition we are
using preprocessor preprocessor and we
are using not only for the C code we or
C++ code we are using it for java code
and as i mentioned when you're defining
Joe interfaces you might be tempted as
as always taught about Java language if
you define an interface you define a
gelling
face and you define if you have multiple
implementations you define multiple
classes which implement that interface
well it's not cheap basically one class
with even even three world-class
typically takes 300 bytes and one method
in class takes 50 bytes so if there are
lots of them as an hour system of course
that that numbers multiplied by big
factor and that means that you're in
trouble basically so we are using Java
preprocessor for this kind of thing
which just a simple example on the
screen so we can conditionally compile
some parts of the Java code or place the
values which originated from that
configurate of tool you've seen on
previous slide so for example the number
of simultaneously running applications
could be provisioned to the source code
during the build time so that for
example the arrays of the event queues
are allocated at the exact width with
the exact exact size to again consider
the footprint and we also heavily use
cogeneration as a way me typically runs
on the devices which allow in place
execution we are generating code from
the Java classes and we are what we call
or my zit so we basically built see
structures see a raise out of that and
we compile them with GCC and then this
these structures are actually resembled
the executable code which which is
obtained by the head of time compiler
from the general classes or for example
the heap l'image cause for system
classes we do like he bootstrapping so
that when your Java me run time starts
it doesn't need to initialize the system
classes they are already initialized and
all necessary pieces are on hip we also
generate properties that's volatile
product configuration is that what
integrator or even user can edit
to to modify that the behavior of the
system dynamically it's also generated
out of the configuration as well as
localization or some other kind of
things so well that's basically eat what
I wanted to say to you so if you have
any questions you're welcome now what we
use to process the I mean Jo
preprocessor right so basically that's
our custom tool it was went through
couple of cycles of the evolution the
preprocessor by itself as far as I
understand tis but I mean that the one
which processes the source code is based
on antenna preprocessor from NetBeans
and we are also using front-end to Java
C so we not we are not starting Java C
compiler by itself but rather we start
our java application which starts Java
Sea programmatically and provides the
hook to the function which reads the
source code so we reproduce the source
code on the fly when Java Sea takes it
no but antenna preprocessor is available
it's way it's part of NetBeans for
example hey I believe its 787 apache2
well yeah it's it's not of course not
that straightforward because there are
lots of configuration options which
shouldn't be exposed to the application
developers but definitely there are some
which wich benefit yeah so a side of
that okay it's problem shouldn't be part
of the spec anyway but it's a
proprietary solution this makes sense
well we'll think about it thank you any
more questions in this recommender it's
probably the it's a full configuration
so and there's only recommendation okay
so yeah yeah that's right but as soon
that's only kind of these numbers are
for reference actually it doesn't
necessarily mean that you're one time is
takes this guy at this number of this
number of bytes basically so for example
for minimum profile so you can one
megabyte flash minimum or recommend it
is two megabytes but our our particular
implementation we have right now on
hands it takes about nine hundred
kilobytes for for implementation of this
mineral profile set Oh actually it's
even with the what we call device access
API which is not part of the standards
yet but still so that it means that the
whole meep with the JVM with the with
that the rating system takes about seven
hundred K or something like that
so that's that's really depends on your
device for example if you take Raspberry
Pi we have implementation for us berry
pie of course that linux on Raspberry Pi
takes much more than rhythm here so
let's say it's on my reference
well yeah of course it were the simple
things like sensors I believe it will
everything will fit into one megabyte so
we as I said we have this implementation
as a 900 and we a lot 100 for their
application so because because we made
it on to fit on the device which have
only one mag of RAM or from so that and
we think that it's reasonable and that's
enough way we have samples which proved
that of course it might be even made
more constrained that depends on the
actual capabilities of a platform this
one make think I'm talking about for
example it contains lots of network
connectivity if you don't need any need
network it will be less there are things
like metal buffers tcp stick that takes
their their toll so it's it's really in
the indie small embedded world it's it's
really a kind of not not cast in stone
anywhere so you should you should
carefully either investigate or just
build the solution to understand the
capabilities or have a much historic
knowledge because it's really or
everything depends on the requirements
on the functionality you need to
implement in your device ok guys so
thank you for listening and you're
welcome still for today there are a
couple of hours the demography is
working so you can stop by and see our
I've shown this kind of basically these
these examples of modularity referring
to our team assembling from the LEGO
pieces assembling the r2d2 robot
controlled by zhiwei me and this robot
is available to show on the democrats so
you're welcome to sit</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>