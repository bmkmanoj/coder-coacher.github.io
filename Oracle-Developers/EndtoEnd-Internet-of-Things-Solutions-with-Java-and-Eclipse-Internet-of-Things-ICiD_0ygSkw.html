<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>End-to-End Internet of Things Solutions with Java and Eclipse Internet of Things | Coder Coacher - Coaching Coders</title><meta content="End-to-End Internet of Things Solutions with Java and Eclipse Internet of Things - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>End-to-End Internet of Things Solutions with Java and Eclipse Internet of Things</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ICiD_0ygSkw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everybody my name is Mike
Milankovitch I'm the executive director
of Eclipse Foundation but the reason why
I'm on stage actually is not because of
my day job it's because of my nighttime
hobby which is playing around with
raspberry pies and stuff like this and
so that's kind of what what got me here
and this is a benchmark of a well IOT is
kind of my job I work at the Eclipse
Foundation I know T evangelist so I talk
about all the cool stuff that we are we
are for doing IRT and especially in this
Cup of two days presentation stuff to do
IOT with Java so I guess we had a couple
questions for people in the room yeah
sure so actually just want to sort of
calibrate the the audience so I mean I'm
guessing everybody here knows Java and
has heard of eclipse a lot that those we
don't want to ask those questions but
how many people in this room are
actually working today trying to build
some IOT solution of any variety with
Java already well hopefully we have
something to talk about how many wish
you were working on an iOS game or
actually maybe a better question would
be how many expect that sometime in the
next year or so that's what you'll be
doing is working on some kind of IOT
solution in Java all right so you are
the guys that we really are happy to
have in the room because hopefully we
have some some stuff that's that is of
interest to you guys so just in case you
haven't heard
IOT is the next big thing
you know it's right at the very pinnacle
of the Gartner hype curve at the moment
which is just awesome because it means
there's nowhere to go but down but I
mean everybody talks about you know tens
of billions of devices you know I've
seen ranges of 50 billion to 78 billion
devices in the next five or six years
and of course the my favorite my
favorite headlines are the ones that
talk about how many trillions of dollars
of opportunity there are in the IOT
which means that you know every VC
carpetbagger in San Francisco hipster
thinks that I
to use for them so it that's that's
always lots of good fun to watch the
scramble as a new technology comes into
vogue but one of the things that is I
think is particularly interesting and I
don't think gets talked about enough is
the fact that for the IOT to be
successful just over the next six years
we need to recruit something on the
order of four million developers to the
IOT space that is a lot of developers
and so frankly from my point of view any
IOT strategy that you hear about or hear
discussed or anybody who's talking about
IOT or wanting to get into that space if
you do not have developers and developer
enable enablement front and center in
the story that means that you're blowing
smoke and one of the things that we're
very focused on at the Eclipse
Foundation is providing good quality
open source code that developers can
pick up and use in commercial products
and applications that's basically what
the Eclipse Foundation does and yeah so
hopefully over the next hour or so and
we do plan on leaving time for questions
at the end hopefully we can interest you
in some of the some of the cool
technologies we have at eclipse this
morning we'd actually issued a press
release announcing our IOT stock for
Java we are going to be and so I
encourage you to read that there's
already been a couple of nice press
articles written about it we do actually
have a wealth of interesting open source
frameworks and protocol implementations
at the Eclipse Foundation implemented in
Java we'll talk about a number of them
in this in this talk and give you at the
end some forwarding pointers to some
other talks here at Java one that are
made up of this of this software if
you're interested in this in this domain
and but today's focus is really going to
be on the sort of connecting and
managing devices so basically the big
the big blue box in the middle the
orange stuff the vertical market
applications smart home SCADA om 2m
those will leave for four other talks or
you know please drop by our booth
and find out more there already so now
pass the baton so other it work how do
you billing it an IOT solution what are
the typical parts the typical challenges
you need to address or if we are to kind
of simplify what it means to build an
IOT a connected solution at some point
you will have to manage your actuators
your sensors right whether you are
monitoring a greenhouse like we're gonna
do a later in in the demo today or
connecting an arm system want you to go
open your windows whatever you will need
to have some support in Java right to do
that so we're gonna we're gonna cover
that in this couple of the presentation
then at some point these sensors you
need to breach them to the internet
usually sensors are pretty dumb right
they don't have at least now maybe in
the future we'll see that more and more
but they don't have IP support but you
need to have some kind of what is called
gateway typically to bridge them to the
Internet and we will see that well there
are some specific challenges when it
comes to building a gateway and turn
channel a device like a Raspberry Pi for
example in an IOT gateway so hopefully
hopefully you will learn more about what
we have at Eclipse to do that then well
you have your sensors you found you
found a way to connect them to the
Internet what someone you will have you
will need to have some server-side
technology right whether it's some sort
of broker that allows your your sensors
to talk with each other or as some sort
of server side support for doing what is
called device management like you have
all these devices on the field that you
need to manage you you need server-side
technology right unless you maybe you do
wireless sensor network kind of stuff in
that case maybe actually all your
devices are just talking to each other
by using some some specific protocols
that will that we will talk about but
while it's true that at the end even
also some some technology to address the
end user the end user interface whether
you're building a mobile application a
web application some kind of IT
integration where you want all the data
to be to be consolidated for for a some
guide
we'll do the maintenance of your devices
on the field so we will try to cover
kind of all these four pillars of of an
IOT solution when it comes to the
sensors well it's actually pretty easy
you have sensors actuators you want to
use your sensors like the temperature
sensors to sense what's on the field and
actuators would be a several motor for
example that you want to tune that will
allow you to open or close a lock for
example so what are our options when it
comes to using Java for talking to
sensors well if you run java on top of
linux then there is a nice API as part
of linux it's called CFS it allows you
to manipulate directly via your
filesystem specific files that
correspond to all your GPIO write all
the pins that you have in on your device
that allows you to control an LED or
some kind of temperature sensor etc etc
you can do that directly for from my
money pinning the file API basic in Java
but what is better well it's actually a
pretty nice technology especially if you
are taking the road of prototyping on a
platform like the Raspberry Pi before
transitioning to something maybe more
industry or more recognized then there
is a pretty nice library that's called
pi 4 j that allows you to have a nice
API for doing GPIO s &amp;amp; SP is crazy these
are all protocols that you would use for
for talking to two sensors and basically
PI for J's java api c plus some native
channel
kind of libraries to do basically
obviously service stuff right if you are
running on Java ME then you also have
some dedicated API to do that
a few more words about PI for J - J it's
not an eclipse project but still and a
pretty pure pretty popular open source
project very made sure based on a wiring
PI which is the native native
implementation that for which Phi for J
is providing a Java API comes with lots
of code samples pretty pretty nice
documentation and the PI for jl world
would be something like this it's
actually pretty simple to manipulate a
GPIO using pi for J
you basically just enter in
the gpio you wanna manipulate so in my
case I want to connect an LED to pin
number one on my Raspberry Pi
I want the LED to initially be with the
high state I want the energy to be
turned on and then I basically have 18
eyes to turn the LED off by setting the
the the voltage of the pin 2 to 0 I can
wait for 5 more seconds and directly
toggle the pin so that the LED will be
turned on again so that's how that's one
example to actually use Java for
following GPIO sandpiper J is really
really a really nice library but that's
kind of the easy part I mean unless you
are talking to to come very complex
sensors actually accelerometers and
whatnot that's kind of easy part I took
him talking to the hardware one of the
main challenges is actually getting your
sensors connected to the internet
waiting to the connected to the cloud
and there's basically two things you
want to do you want to connect these
these sensors make make the values that
the sensor data available to two other
for others to consume and you want to
manage and we will see that managing the
device is the hardware that's on the
field is it's actually a tricky part and
something that many people usually
forget about they start building
prototyping their solution they go in
production basically they start shipping
devices on the field and then how do you
address software updates how do you
update the software that's running on
the field how do you do
firmware updates and stuff like that so
in terms of connecting how do you go
from being able in Java to get values
out of your sensors your PC little
actually pieces to making the data
available to the internet well there are
two very popular protocols both of them
are Qi standards co-op is an IETF
standard stands for constrained
application protocol the idea is it's
been reading and for wireless sensor
networks it's kind of HTTP over UDP
replicating all the all the nice
mechanisms in HTTP to do rest and
restful api
in proxying all that kind of stuff but
on top of UDP so as you are very
bandwidth and battery efficient and
basically with co-op what you do is you
turn your device your gateway you I
educate way in a resource that is a part
of your the internet network basically
I'm qtt would be more publish/subscribe
have kind of protocol you have the
Gateway will be will be a client
subscribed to a broker and well the
Gateway will publish messages to the
broker and other clients may be
subscribed to specific topics and they
will be notified whatever data is
available so co-op yeah it's the idea
with co-op is really building a web of
things you will have I don't know a
light bulb that exposes values like why
is what is the color of the of the light
bulb maybe some some methods as well
like if you post a co-op message on the
/on resource of your of your like palm
you will turn the light on so how do you
how do you implement co-op ready kind of
gateways or our sensors that will be
using Eclipse californium Eclipse
californium is a Java implementation of
the co-op protocol it's it basically
combined with the the IETF standard and
also comes with nice features like the
security for doing I'm sure in HTTP or
familiar with SSL and TLS well co-op is
based on UDP so the security will be
using DTLS it's TLS for telegrams
so californium actually provides the
support for that as well as all the nice
features to bridge your your co-op net
or two to an HTTP kind of server all the
tests you'd set cetera et cetera and the
californium kind of hello world if you
were to implement the californian
resource well it's very simple and we
will see that MQTT is all it's basically
as simple three place with three classes
you need to know about you will create
your server and you will register some
some some resources on the server and
start the server and basic
that's it basically just like you would
just sell it right so if I were to
implement an illa world resource well I
will declare my resource provide some
code to handle the get maybe some code
to antelope post if I want my resource
to be to be updated and then later on I
will take this resource instantiate the
resource attached attach it to the to
the the co-op server and I'm done you
want to take passed baton I have to pry
it away from him some MQTT is the other
protocol that's quite popular in the
internet of things it's actually been
around for quite a few years and but
more recently has become a it's going
through the process of being
standardized that the Oasis sustain its
body it's quite a different
fundamentally quite a different
architecture than coops so rather than
thinking of the sort of the web of
devaya devices or sensors it's much more
a sort of central broker that acts as a
clearinghouse for information coming in
from sensors so you have a broker let's
say you have your handheld device and
you wanted to subscribe to a particular
topic so you send a subscription request
to the broker saying anything that
happens on this topic please let me know
and then of course that the content is
actually undefined but it's a blur or
more accurately application specific but
then once that starts happening every
single time some event happens where a
device sends some information on that
topic then the information will be sent
to all of the clients which have
subscribed to that to that topic so it's
a very nice way to have sort of a
multi-point to multi-point kind of
conversation going on between lots of
sensors and potentially quite a few
quite a few devices that are observing
and doing something or acting upon that
that information so that's the sort of
the fundamental architecture of MQTT
where it connects to eclipse the
actually one of the very first projects
we had in the Eclipse IOT project
community was the
project which is focused on open
sourcing MQTT clients and one of the
things that's nice about this is of
course you know we're here at JavaOne so
we're all focused on Java but it is a
polyglot world out there and there are
client endpoints under the paho project
for a lot of different languages
including Lua JavaScript Python and so
on so depending on what the
implementation of the what you're doing
on the client side you can you can have
solutions through the Eclipse baho
project so just a quick sort of hello
world on what what it looks like if you
want to set up your a mqtt client with
PAHO you're gonna configure who you're
talking to or so where's the broker and
you'll notice there that it says m2m
clubs org we actually run a sandbox
server at the Eclipse Foundation so if
anybody here is interested in playing
around with with mqtt or co-op for that
matter if you go to IOT it's actually
net we've renamed it IOT eclipse org and
you can you can find sign box servers
for c mq GT coop lightweight m2m om - om
Tim and in n3 da which is another
protocol so there's an opportunity there
that if you're are learning these
protocols and are experimenting with
them you don't have to go to all the
trouble of setting up setting up your
own server so then you basically set the
callback and then you start actually
posting messages and you subscribe in
this case - I can't even read that mqtt
gateway or something like that and and
the the pound sign there is the wild
card forgive me all of the information
that's coming in on that on that topic
hierarchy on the broker side we actually
have two projects that eclipse the
Eclipse mosquito project is implementing
the broker side of mq GT in in C code
and it's very well known open source
project that's been around for a number
of years and isn't in the process of
transitioning to the Eclipse Foundation
it's based in C and has is quite
scalable so you know on the order of a
thousand clients and three Meg's of RAM
and you know we've been this is that's
what we've been running on the coast
foundation as the sandbox server for
MQTT and it's been ticking along for
actually a year or more two years I
think yeah and it's it's very very easy
to set up and administer the acquits
mocap project is a new a fairly new
project just got created and it's a JVM
for the Java implementation and under
the hood it's based on Neddie for those
who know about neti and l max dis ruptor
which is some kind of buffer ring
implementation for efficiency so we both
have a C implementation and a Java
implementation at Eclipse for for the
broker side of MQTT all right all right
well that's feel kind of the easy part
connecting connecting devices one thing
that I hopefully will be aware of and
very aware of at the end of this session
is that the tricky part when it comes to
building real like production-ready IOT
solution is the managing side of things
like the Gateway itself the device that
you're gonna use to connect your your
sensors to the internet beat an
intelligent while it's kind of CPU or
Raspberry Pi or a huge recognized
gateway that is going to be like in your
factory or something this you need to
manage you need to be able hopefully
over-the-air to change things like the
the settings that the network settings
of the Gateway right you have you're
running on the anything you have a SIM
card and some kind of cellular data plan
you want to make sure that you are able
to change the the APN settings for
example for over year you might want to
change the networking Google's the
firewall the nut and etc so that's
something you want you to be able to
address on on your gateway as well as
the applications you want yo gateway not
only to be a an intelligent router
basically IOT router for your your
sensors on the field to let them access
the Internet but you also want to have
some intelligence at the edge of the
network at on your gateway right so you
want to have some sort of framework
solution to to be able to manage your
applications you want to install
applications
you want to stop them stop them see the
logs
update them and things like that and the
sensors as well you need to have some
sort of a hardware abstraction to make
sure that the application that work on
the right are are able to easily access
things like the GPS for example if your
gateway is able to provide you with a
GPS location then that would be nice to
have an API for that right so at Eclipse
this is this is cura the solution we
have to turn in a device into an
intelligent IOT gateway that is also
going to acts basically as an an
application framework for your IOT
solutions
this is eclipse cura so this is based on
Java as well as OSGi we leverage both
the what the jdk itself personally the
modularity of with or for SGI to provide
and mike is actually going to show you
how it looks like to provide not only
complete infrastructure as well as a UI
to manage the you network settings your
the actual hardware that is your your
IOT gateway but also all the
infrastructure to develop your iot
applications so if you would like to
insert URL it's actually pretty simple
especially if you have like a Raspberry
Pi or a pickle bone black and again want
to start evaluating your your your IOT
solution using widely available open
source hardware you basically download a
given package dpkg installed package and
you you have Kirk you are running on
your computer
and you can do things like managing the
network monitoring what are the the
software bundled usgi bundles that
you're running on your pure gateway and
actually I won't spoil my team or you
can actually show that life how it looks
like on by directly connecting to the
Raspberry Pi that we have on stage I
would say so
okay so you guys still hear me all right
so first thing just end points just to
prove that this application is actually
running I'm not sure how many people can
see this but this is me switching on and
off the lights in the greenhouse
you know Benjamin be walking through the
whole thing later but this is a live
application running on the Raspberry Pi
where we're doing we're monitoring the
greenhouse and actually I think this
little green house application is
becoming the petshop of the IOT demos
for those who remember the early days of
Java I mentioned IOT is one of my
mentioned IOT dot eclipse.org earlier so
if you go there that's where you can
find all of the for example all the
sandbox servers so if you want to play
around with that stuff that's where you
go and IOT dot eclipse out org slash
java is where you can find more
information about all the stuff that
we're talking about here today and if
you want to actually duplicate this
whole demo yourself on your own
Raspberry Pi Benjamin has put together a
complete tutorial here including the
parts list that you have to order from
seed studio and the whole nine yards
just one word of warning if you're like
me and you're dyslexic and you transpose
the white wire and the yellow wire it's
not going to work luckily Benjamin is
patient with me now so and so one other
thing I wanted to show you before I get
to the Kurd mo this is also a very handy
utility from the where you can actually
sit that it's it's the paho MQTT monitor
so you can sit here with on your desktop
and monitor your application so I've
currently got it hooked up to the topics
of that we're broadcasting here and one
of the things that I can I can do is
actually publish data as well so from
the command line here I can turn the
light on and off on the on the green
house which is as you can imagine for a
debug and monitoring tool can be very
very handy if you're if you're working
on an application like this all right so
finally I wanted to talk main reason why
we're here is to talk just is to
demonstrate the the capabilities that
Qura brings as a gateway management tool
and I think when I first got this demo
actually a year ago java-- one from the
Euro tech folks that are behind the
curve project this is actually one of
the things that I got particularly
excited about because it's really easy
to get you know code in an open source
project that you know implements a
framework or implements a particular
capability but an open source project
that actually has taken care to write a
really nice manageability management
console and provide these kinds of
capabilities is actually fairly rare and
it's something that I found I found
particularly impressive so you know this
is you know the device Status page so
we're sitting here we can see that we've
you know what we are you know what
Ethernet we're on our eighth or net do
what our IP address is and so on if we
did have a GPS dongle or on our on our
Raspberry Pi we can actually have
position status down here as well for
the device itself you've got some
specifics on the device including the
software that's being updated and so on
you can here's all the the OSGi bundles
that are running on the on the on the on
the device you've got the you can
actually execute a a command here and
have it run on the device so you can you
can actually query the device through
the through the web console and one of
the things that is particularly nice is
on the on the from this packages here
this is where you can install and
upgrade the software that's actually
running on the device so to install this
green house example that we're running
here was just click here go to the URL
and paste in the URL for the for the
package that's sitting out on the IOT
out of clips org install it and start
and start next time you reboot the
machine it's running so that
now that's all pretty pretty important
if you're gonna have an IOT gateway out
there for the long term and you actually
want to be able to manage it remotely
now it comes with a number of services
and we had to configure a few of these
but I think - they just want to talk
about it so this is the green house
service this is the one that we added
when we installed the green house
application and basically that this is
the key point here is is you have to
give it an MQTT topic to publish its
data on and then the other one of the
other major configuration items is then
the mqtt transport itself we had to
configure which broker to talk to so
these are sort of application specific
settings that you would need to set up
if you are if you are using you are
using kura
so anything I forgot that you wanted me
to mention or I think that's actually a
nice transition to how you would
actually use URIs API to build your
application well you have of course all
the JD JD K code features available
under the hood right but cura
also brings you a nice API slash OSGi
services as Mike said for doing things
like accessing well the GPS location
there is a position service that you can
use to transparently monitor the
location of your of your IOT solution
and one thing that Mike mentioned and
that it's actually quite important is
everything that deals with the
communication with the cloud feed the
data service or the cloud service the
idea is that an IOT application
developer should not need to know about
what is the the MQTT broker he or she
wants to talk to that's actually better
if you just have a data service that you
can import in your application you start
pushing data in the data service and
automatically the the data service is
going to take care of talking to the to
the proper cloud back-end depending on
on the settings as well as also make
sure that for example if your network
connectivity is down because you do
wireless and sometimes this happen
then it's transparent you just thank you
data and in the data service and the the
cura framework is going to take care of
doing all the all the local caching and
stuff like that so that would be the API
so how do you actually use them and how
did I actually be on the demo so we will
see some code now you know your so the
application is actually a set of bundles
when I want to build the greenhouse
application well I want the first thing
I actually want is an OSGi service that
is going to bring me an abstraction of
what my sensors are I want to have a
service available as so they can query
the temperature or as I can update the
status of the LED so I the first thing I
actually did is declare the API of my
central service I want to have a way to
get the value of a sensor depending on
the name like I want to get value of the
temperature sensor or I want to set the
value of the light actuator for example
so that would be basically the decorate
declaration of my API right and then
thanks to PI for today because I'm
actually running on on the on the
Raspberry Pi what I want to do is
provide a specific implementation of
this service maybe on another platform
it's going to be implemented differently
right but in the in the case of my
raspberry pi what I do have is in
another bundle basically in an OST
bundle I am providing my implementation
of a central service so here I'm not yet
going to use any cura specific API it's
basically just using ifoce I want to do
I squared C stuff to read the
temperature out of my digital
temperature sensor so at some point I
guess I'm I'm
implementing the get central value
method and if I'm asked for the
temperature then I need to do the pipe
40 stuff which might sound scary but
it's basically just I'm I went through
the temperature sensor data sheet and it
says that yeah if I want to read the
temperature I need to manipulate some I
squared C registers and stuff like that
well it's actually pretty
straightforward if you just go through
the data sheet and look maybe at some PI
for J examples basically I'm writing in
a specific I squared C register I wait
for the value to be ready and once it is
then that's fine I'm I've implemented
the code for my get sense or value
service right
so that's once I have this bundle ready
I basically use OSGi to make this
implementation of a central service
available to basically to virtually any
bundle interested in manipulating a
central service and so what I'm gonna
need now is another
OSGi component you know another SGI
bundle that's going to require the
sensor service without even knowing it's
like a pipe forge a specific
implementation right I just want to to
to manipulate a sense of service to do
the MQTT publishing so what I'm going to
do now is have yet another OSGi bundle
and maybe we can have like a quick look
at how all the OSGi glue up and behind
the hood the idea is that I want my
component to do - I want to use the the
sense of service right in my component
what I want is I want to have access to
the central service to read the
temperature and stuff but I also want to
do MQTT I want to publish the data using
MQTT right so at some point I will also
require the data service from cura and
and basically once I have both these
services I am able to write my
my java code which is in the form of a
green house publisher green as publisher
gets automatically the the OSGi
framework is going to give me a green
house central service as well as the QR
tailor service and wise whoops oh that's
fun okay thank you Christ
what so once I have both these these
services I'm going to be able to
retrieve the temperature from the
central service and use the API from the
data service to publish data using MQTT
right so let's go back to the code I was
looking at earlier alright so well
basically well we're going to go through
the code quickly but basically whenever
there is a new a new value available
what I'm gonna do is use my data service
API so this is really something coming
from from the cura framework right and
if we look at the documentation it says
well this is what you're going to use to
publish using MQTT but you can see that
my code is actually pretty simple I just
specify my topic I specify my payload
which is the current temperature but
nowhere here I'm talking about the
broker right for example it this is
gonna be part of the configuration of my
application and so that's basically it I
once I do that I have the code for doing
that the publishing and what we've seen
earlier with my demo is that the
application that actually runs on pura
as several exposes several configuration
settings like what is the topic I want
you to publish on well that's actually
pretty simple to do using cura and osg
on you can very easily declare make sure
that your component as some exposes some
configuration settings and here we
leverage many OSGi standards like the
meta type for example kind of standard
and the idea is that you can you've seen
that in in mics where
web-interface earlier right for the for
the the topic it was a string right but
there was also I think another state
setting what that was is the message the
impurity message retained or not yeah
and also the cue quality of service in
gathering so the the retain would be a
boolean flag for example right so how do
you specify that your application
parameter is the string or is a boolean
well there's there's a nice way to
describe that using that the meta type
OSGi specification and you can very
easily declare that yeah QoS could be
would be a multiple choice kind of
integer zero one or two and then retain
would be a boolean and the app topic
would be a string with a default value
that would be Java 1 g/mol blah blah
blah and so thanks to all of this you're
you're not only making your application
configurable but you're also providing
automatically the the proper UI in in
the web interface for example so that's
that's actually basically the idea once
you have all your OSGi bundles what you
can do is use what maven or whatever is
you want to use to build all your jar
files and then once again you can
leverage OSGi steroids to provide a
standard meta package i would say for
all your bundles you put them all in a
zip file that is going to be the zip
file you're gonna ask cura to install
inside the gateway and thanks to all the
OS GI goodness i would say this bundle
is going to be installed in your gateway
or maybe if you don't have all the of
all the required bundles to run it
you're going to be aware of that because
you know that's kind of the one of the
advantages of OSGi if you have missing
dependency you'll be you'll be aware of
that so that's that's basically it I
think we've covered most of the of the
greenhouse demo we have basically the
greenhouse publisher that consumes the
sensor service but there are service you
we can use metadata to do to have the
nice web UI
settings thingy
yeah and how about co-op well how can I
make my my greenhouse talk using a co-op
well once you have the central service
it's actually pretty simple to add
another bundle to your solution that is
going to consume that could be another
consumer of the central service but this
time instead of using the the data
service you're going to use californium
to declare to declare a co-op resource
and actually I do have another another
bundle in my in my workspace and this
one is again requiring the the
greenhouse sensor service but I'm just
basically going to use a californium
which I have already inside my my
application here and what I'm going to
do is use the basically the californium
api's we've seen earlier right to to say
that yep I want to I want my my co-op
server to set to serve a resource that
correspond to the green house resource
and whenever it comes to getting the
actual temperature it's going to
delegate the coop get to the the gate
sensor value method of my of my
component so that's that's really like I
don't I don't know how much more modular
that the software could be right if you
if we were to add I don't know an XMPP
way of communicating the values from
from the sensors well we have the sense
of service so it's pretty easy to add to
add the functionality if the coop or the
XMPP bundle is there fine then the
functionality is going to be there if
it's not that that doesn't change
anything for the rest of our our source
software right
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>