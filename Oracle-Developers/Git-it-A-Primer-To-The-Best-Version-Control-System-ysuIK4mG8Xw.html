<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Git it! A Primer To The Best Version Control System | Coder Coacher - Coaching Coders</title><meta content="Git it! A Primer To The Best Version Control System - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Git it! A Primer To The Best Version Control System</b></h2><h5 class="post__date">2018-02-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ysuIK4mG8Xw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay the lights are really bright I'm
assuming there's some of you out there
not many but I'm assuming there's some
of you out there but I can't actually
see you Wow so we'll get started
there's still a few seats available go
ahead and grab one yeah so hello thanks
for coming to our session this is called
gedit a primer in to get or the best
version control system on the planet my
name is Stuart Bryson with me is Bjorn
roost
we'll get the introductions out of the
way go ahead Bjorn yep hi my name is Jon
I am a narrow case director developer
champion I actually didn't write this
slide so still it calls me an expert in
database there wasn't everything really
which is awesome so I have worked a long
time with Oracle databases they've up
systems right now incident doing
streaming analytics that's what I find
really fascinating right now and and I I
don't I wouldn't call myself a super get
expert but I really like using it and I
get frustrated with people not using it
at all or not using it properly and that
was the idea for this for this talk I I
work for a company called Pythian and we
are a data company we do manage services
and consulting for everything that is
data we started by doing Oracle and
sequel server but now we do the next
slide basically everything that is those
days we do big data we do machine
learning we do analytics we do a lot of
cloud migration on promises to cloud and
still a lot of the traditional database
on database work and hi I'm Stuart
Bryson I'm an Oracle age director I'm
the owner and co-founder of a company
called red pill analytics there are some
social media media avenues there if
you're interested in following me if you
heard red pill analytics and you
wondered maybe I get that reference it
is a reference to the matrix the other
co-founder to me really liked that movie
when you Nate you only get to name a
company once so why not and we like to
say that we can help you choose to see
data differently right so instead of
telling you exactly what we do we find
it helpful just to tell you here are
some of the products and platforms that
we consult in so these are some of our
partners so we do a lot of
loud implementations we do a lot of on
prim implementations as well with these
different technologies so getting right
into the presentation a little cloud
crowd participation if you if you please
anybody know who that is anyone what say
it yes and why is he relevant to a
conversation on git do we know he
created it so to the gentleman the back
you know why he created it
that's it so you want to come up and not
just give me no so really the he needed
something better for development of the
Linux kernel so Linus did what Linus
does which is he wrote it so there were
no really good version control systems
that could manage thousands of
concurrent developers commits from a lot
of different places the managed
workflows that are that were required to
be able to efficiently develop the Linux
kernel he needed something else so he
wrote it so one of the big keys to get
and what is the differentiator for it
compared to a lot of other version
control systems that came before it is
it's what's called a distributed version
control system and so this aspect was
what he needed for the Linux kernel and
then the speed as the gentleman in the
back mentioned so really speed and how
it works so I want to sort of get to the
point of what we mean by a distributed
version control system and I'm going to
compare it to
subversion though I think subversion has
has has grown in in the last few years
to be able to do distributed I'm not
positive because no one uses it but and
I don't use it but I think they have
addressed some of these areas but in
general when you when you're writing
software or whatever it is you're using
and you're committing to subversion you
have to have connectivity to the server
to be able to commit your changes and
permissions to and permission there's
usually one or two maintainer of a
repository in subversion it's a big deal
of who is allowed to to commit to it and
you can either allow people to do it or
not but there's no distribution of
access rights in this it's really hard
to keep that separate absolutely so what
what I you know I was a big subversion
user for years and one of the things
that drove me crazy is when I was on a
plane I couldn't commit right because
they have connectivity to the server so
what subversion tended to half people do
is not commit very often it also doesn't
really support branches which we're
going to talk about and because of that
is another reason people wouldn't commit
often so they usually get their code all
done and then commit it and that doesn't
do anything for anyone on the other hand
get is a distributed version control
system meaning that
everybody has the full repository
there's really no difference between
your git server maybe you host it on
github and the copy of get you have on
your laptop
they're basically equal now you may have
seen abled some things on the server
such as get hooks api's and what not bad
time for someone to be calling me but in
general the repository itself really
isn't much different and that's why it's
so fast so when you're doing commits and
you're doing diffs you're doing that
against a local copy of the repository
and that's one of the reasons why it's
so fun and then the other the other
point to again back to the having only
one copy the beautiful thing about it
being distributed is that as long as
soon as you clone your get repository or
you have somebody else clone it they are
the masters of that repository they
don't have to ask anybody for
permissions to change it for to do
anything to it
everybody can it's basil eat their own
master of their own copy or clone of a
repository and then get takes care of
collaborating and bringing things back
together which is really nice I have one
project where I work on subversion I
only have read on the access to it so I
can read the code but whenever I need to
make changes I'm sending an email with a
attached script to somebody and then I
realize oh I forgot there's still one
bug in there so than another email
another human another email and then
they put one email into their code or
one version and then I have to go back
which one that they choose and then I
it's just annoying it's a workflow
problem isn't it
well it's also a trust a trust issue I
can't for me right so first off does
that make sense does does that make
sense that it's distributed in that way
good so basically if if the server went
kaput and we didn't have a backup of it
we could easily recreate it from because
someone will have that last commit
somewhere right now that shouldn't be
your disaster recovery plan but I'm just
saying that it's easy to take your own
version of a git repo and publish it to
a new cloud vendor for instance you've
been using github and now you want to
publish it to the Oracle cloud in their
repository system you can easily do that
and have all history because all history
is in your your local copy of the git
repo so it is worth mentioning that
there
a lot of GUI tools available forget okay
so if you so if you want something a
little more graphical there's there's
maybe 50 different tools depending on
whether you're on Mac whether you're on
Linux whether you're on Windows however
for this demo that we're about to do we
we will be using the command line of get
so if you just don't think you can
stomach that or you're not interested in
seeing the command line now is that
now's the chance this is your last
chance to leave and with that we will
jump oh it will do the demo yeah good
switch over oh that looks very quick
yeah Wow
yeah just just an extra point is if the
thing these things that we demoing and
even though it's command-line it's not
very complicated it's not very very
advanced our idea for this was we to do
a talk for people that have never worked
with git or have not done much with it
so um if that is you then we hope that
you get something out of this if you've
been working a ton with git then you
probably think that this it might be
very basic but let's just see so the the
use case that we that we imagined is we
have lots of people writing any kind of
text files or any kind of code and so it
could be sequel we PL sequel JavaScript
Java code anything really or even JSON
XML anything that is represented in text
format goes really really well and get
and we probably all have these things
lying around somewhere and I just
created directory it called cool delay
and I make do that first and and we just
go through one of these files and we
just use a simple readme or a simple
notes file so let's just do this notes
or text and let's just start with a
simple hello world that's always
exciting and this just demonstrates that
people usually have these text files
lying around and then you do whatever
you do with them and just imagine this
thing would be a more advanced example
like some actual code that we're writing
or um some sequel scripts shell scripts
I mean if you're if you're an actual say
Java or JavaScript developer you
probably you know gets all set up and
you're probably using it extensively but
one of the pitches we like to make when
we do this talk there are versions of it
is that this is applicable for DBAs for
sis admins you should be versioning your
scripts you
be collaborating scripts that you should
be doing that in a version control
system not in a shared drive we're
hopefully going to make the pitch that
that there's value in it even for non
developers or pseudo developers yep so
and what are the first steps to get
started is but we have to install git in
some way and the Linux is really easy
it's a install of a get package on
Windows that said it's an installer and
a Mac you typically install what's
called the Xcode tool so the Xcode tools
for command-line that will give you that
would give you get and versions that
actually you command so I can I came on
something called get status just to well
actually let me just wind back one step
the one thing you want to probably set
up is git will track your author name
and your email and so that's something
you have to provide otherwise it will
just take the username from your
computer so the first thing you do is
you configure get to to store your name
and your email address so I just
configure this the global means do this
for all the repositories I could go
under a different alias and each of my
repositories and I just configure the
username and then there's an email here
somewhere
so I set these things things up and
we'll see where they show up later so
then I showed that if Orion get status
get starts is really the one command you
want to run all the time just to check
what's going on um you see this is not a
good repository this is just an empty
director or a temp directory with this
one file called notes or text in it and
we have to make it a good repository and
the simple and easy way to make it a git
repository is to initialize it so you
run git init which will basically create
a git repository it's giving you a hint
of what it's doing what it's actually
doing is it's just creating a hidden
directory called git which stores
metadata about things that are stored in
this git repository and this is where
your server might have a where your git
server or at least the server where you
push your changes to might be slightly
different because then that hooks
directory or and some of those
directories you might have some things
that actually fire because of commits
that you usually don't have on your
desktop but in general that and
everything is tracked within that one
dot git file in the sort of the root of
your repository unlike subversion which
puts a dot svm file in every single
directory and tracks it that way
so from here on out everything that's in
directory structure is your code there's
no overhead or metadata except for that
one directory right so it's initialized
now so you're gonna get status again it
will tell us something about which
branch is only if we get into what that
is later
it's tells me there's no commits yet so
there's nothing nothing really done to
this repository and it talks about an
untracked files so git has a concept of
files and directories it actually tracks
and by tracking it means that are
basically inside the repository and it
it just detected there's a file called
node start X lying around and it's not a
part of my repository I have to actually
add it to my repository and get status
as awesome and that usually org it is I
love how it's designed if you make typos
or if you do run stuff like this it will
actually tell you what to do with this
so it tells me there's an untracked file
if I want to add it I just want git add
and my file and that will add it to the
git repository so I just did that run
git status again and it will tell me
that now I have changed that is to be
committed it's is the so called staging
area and it's a new file called notes or
text so this file is now ready to be
committed it's still not really in the
git repository we'd have to commit it
and commit is a really really important
concept in in get to do that I'd run git
commit - say I have a habit of always
adding the - aid in this case actually
wouldn't be needed when I do this it
will open a and edit her by default it's
VI and I really like the I so that's
awesome but you can also configure which
editor it is and for this initial one I
just need an accent to enter something
that's called the commit message and
we'll talk about this actually right now
but I just call it initial commit nuts
that's all I'm putting in now hold on
there's a few things we don't want you
to add in a commit message
all right so show show some of the
things that they shouldn't go yeah so
some of things that shouldn't well it's
actually probably more sense for the
phone next commit I'm writing but okay
yeah that's what I think you do it for
the next one so this is now it's in here
if we do get status I'm sure it's clean
so it's nothing to do it's it's all good
now I edit my file again and I say well
actually this is not the world this is
LA and so I made a change if I go to get
status now it will show me that there's
a
this file and to basically check this
file into the repository I'll have to
commit so I do in my commit when I say
again and so here's an example for a
really bad commit message which would be
changed world to LA that's a bad example
of a commit message because everybody
who would look at this commit lock or at
whatever we did can see this everybody
you everybody who would look at this
will be able to get this and really
think about a 4-man expect perspective
of what would somebody who would like to
go through the history of changes like
to know about this like widen the
question are usually why did somebody
make this change why did somebody touch
the code at this point or what was the
point of doing something because as
you'll see in a minute when when Bjorn
shows you some of the other commands
it's easy to see the diff of the commit
so a good commit message is not that I
changed this word to that word it is I
changed it because for what reason right
so I updated the notes file because
we're in LA right or in a new
presentation yeah so I customize this
for the current occasion where we are
giving the talk oops that's a that's a
better commit message I'm not saying
that this is a great commitment method
but it's better like that
yeah yeah so now I've committed to two
commits maybe let's just add one more
just to make it make it fun this is just
the first thing is good you need that's
fine enough commit this again more
sample stuff and again good status will
show does should show us that we that we
clean and it is good and this is this be
the minimum that I would like to
recommend you guys do like whenever you
have and this is a best practice of I've
done for myself and ever I do with any
kind of text file these are the things I
do I run get in it and I run get commit
every now and then and we go through a
few things that this would already do
for you even though you might not even
use the distributed system you're not
working with somebody else you're not
doing anything fancy but just every now
and then adding a commit message to at
the end of the day saying today I worked
on this or implemented this or
brought over this will give you some
benefit and the first thing is you can
you can just go back in history like if
you visit this code a week from now a
month from now and you wanna see what
over the last thing I worked on is you
can run git log and get lock has a lot
of output and it talks about the stuff
that we did so it said the first thing
was the initial commit then we customize
this and added more stuff and you see
that each commit has some metadata so
first of all there's the this which is
an sha-1 a hash over the previous
commitment they did the commit hash and
then the the content that changed and
then also the author name and the date
mixed into it and hashing them together
like that basically I want to call
almost blockchain because we have we
basically this commit ID the first one
and this one and the other one depend on
each other so I I can't just go to my
dot git directory and change the first
commit because then all the other
checksum super messed up so that's the
way of tracking that and this is one of
the reasons are so fast is it only deals
in small incremental files being stored
it's not trying to store the file for
all time and multiple versions it's just
storing the deltas over time and then
whenever we whenever we do something
would get these these hashes are quite
important so one thing we can do is I
would use it so this is this last change
I did this added more sample Cemil I
would like to know what what happens
since then like what what happened and I
can just run git diff and then just pass
the the commit ID to which I want to
give so this would be a dip but I'm and
it shows me the file notes the text was
changed and this was not changed but
these two lines were added to it so
that's that's git diff not that exciting
but um but it's there and this is one of
the reasons why you would not need to
say and your get commit message put your
name and put a date which I see a lot
changed by Stewart Bryson on whatever
date there's there's no reason for that
because that's actually stored in the
metadata of the commit
so keep the messages short don't don't
try to out think the metadata and then
one thing and you might want to do is
you might want to go back in time let's
say the last change you did you have no
idea what it was good or not you want to
see your project as of yesterday so you
just run this command
checkout and pass the commit ID which
gives us a lot of text in the output and
we go through it in a bit but this will
now let's look at this they should not
have the extra text yeah it's just hello
LA so there it is then it talks about
something that's called the detailed
head and I don't want to go too much
into this but basically what it tells
you is you were brought back in time you
can look at your code now you can even
add new commits on top of this but you
really if you do that well this is
really meant more for just having a look
around I would not recommend this to
then start committing on this thing
again because then you get into some
weirdness the thing that you can do is
you can branch from this and then work
on a branch which is actually what also
happens if you just had commits to this
now so that's also important to note
sorry Bjorn that that's that when he
changed her a couple things one is first
he's never connected or communicated
with a server of any kind right so this
is a local git repository at this point
so there is value and perhaps just doing
that right so if you if you simply want
to version your own stuff and you don't
have any interest in collaborating one
with anyone at the very least have a
local git repo it doesn't cost you
anything it's free right the other thing
to really note is that as bjorn has
changed directories the files on the
file system are actually changing so as
you change sorry as you change branches
is what I should have said as you change
branches the files on your computer or
on your in your local file system are
actually changing okay so it's applying
an done applying those Delta files as
you check out different branches or
different commits so the low the actual
file content is changing as we switch
branches alright so again so get back
into the normal state you run git
checkout master which will put me back
to my latest date of the code actually I
just edit this notes and I call this
Chicago add some more text
so that this side we get commit into it
more text and now I realize that this
was stupid because we're not in Chicago
that's that's the next city I'm
traveling to so this was stupid how do i
how do i make this back and this is a
simple change but there's two things we
can do first of all as i realized its it
says chicago know which is which i find
we're wise why is this chicago who did
this when did I do this why did I do
this was I drunk when I did this and
there's a there's a command called get
blame which will show you line by line
where each line came from which commit
each line came from the file name
yeah it's notes it's notes so it shows
me that this is the short version of the
of the hash shows me that this is where
it came from this guy did it at this
time this is when the commit was was
entered and so now I see that this is
actually the the commit ID I did this
and it doesn't realize this is stupid
I can I can run a git revert because
this add some more text or also make
doesn't make much sense so I can say I
want to revert this this hash and I can
use the short hash or the long hash
doesn't really matter but I one get me
word which you basically just change it
will actually add a new commit that just
undo Stach Ange so it takes the diff and
just underpriced it if and that's the
automatic commit message for that I'll
write that I do a git status I'm clean
they do a less notes and it's LA again
so that's that's already pretty cool I
think so this is this is just a thing
you use a use case and it just gives you
the ability to annotate the changes you
made your code and we've went through
how to how to go about navigating in the
in the gig and in the commit log the
actual way of avoiding and so the one
thing I want to avoid so they said say
we want to turn this notes text into a
into a markdown document and that
requires some more changes we have to
change the changes and if you didn't
think about code there's a lot of times
when we know that we break code we know
that for the whatever you want to do
whatever future want to implement we
have to break code first and it will
probably be in a broken state for a few
days and then it might be fixed again so
we don't want to do that so and what I
see people do a lot is they either take
a note or text back up
or even copy the whole folder just to
have a backup of whatever they've done
and then they start editing something in
somewhere else and then things get very
very messy and I hate seeing that so
whenever I see a dot back file I think
that's that's wrong it's not how you
should do it and I want to show you a
better way of how you can basically
create it back up a creative working
copy that you can either abandon if it's
shit or that you can decide to merge
back into your codebase and the way you
do this in gate is use branches and
that's where there's a command called
branch which will tell me there's only
one branch it's called master and that's
the branch I'm currently working on I
can create a new branch with this
command I can say the new branch should
be called markdown that's what I want to
do and I'll go and get branch again so
there's two branches one is called
markdown once called master I'm still in
the master branch and to get it to the
other branch I run git checkout so I get
checkout mark down what put me into the
markdown branch it says here but also if
I want to get status it shows me I'm
currently working on the branch markdown
so the change I want to make is I want
to move the file and rename it to read
me MD simple change so that's the first
thing I do I move this and this is
interesting so if you do a get status on
this it will tell me it actually deleted
this file and then there's a new
untracked file there's two ways of
dealing with this I could ezio I planted
a different thing but let me just add
this by app this it's now there I do a
git commit I say start it markdown stuff
so I just deleted a file dated ink it
and created a new one the cool thing is
the the log of the commit log will still
be there get realizes that hah it
doesn't realize in this case it should
have realized it so that was stupid
that's actually good example for a for a
broken branch let's just say this was
not what I intended to show there's
actually a great example let's check out
the master again that create a new
branch so we come out called master to
get a check out - B yeah great so we
understand CH now so the actual command
to do this better would be to use get
move note start text to read me I also
notice by the way how I never renamed
the file backwards it was read me I
checked out master which renamed the
file back to notes now I create this new
branch called mass master - or they call
the master - that's a stupid name anyway
it sits there and the file is now again
it's called notes or text so do a get
move notes or text to read me dot MD
it'll actually track the track the
change so I call the change working on
making this a markdown document and now
if I do get lock it shows the whole
commit lock still right so I moved the
file it sometimes also picks it up if I
delete and add a new file I know why I
didn't here but good point so now let me
just add it one more thing and just make
this little bit more markdown me that's
a header and this is inline code and
maybe that's enough for now
format it by text so now let's run git
status it's clean but it's still on this
on this master branch let's say I'm
happy with this I'm happy with this with
this change that I've made I changed my
notes text to a markdown document and
let's check out my master and if I run
LS on this I expect this to not be
called reading you guys because this
branch doesn't have the changes yet so
in order to do that to bring the changes
from my master to branch into this
master branch as I wanna get merge I and
and git merge works in two ways
it'll always pull whatever changes you
made from the branch that you mentioned
here into the branch that you're
currently working in so this will take
the change the master to and turn them
into master that's not the only way to
do it but for a simple change like this
it works really well
in other cases I would probably
recommend to run the merge and
other direction first because somebody
might have modified master in the
meantime and whatever you merge back
might not work I might not work very
well so you're protecting yourself from
the possible merge conflict by first
updating emerging master into master 2
so that you can handle any conflicts
there then merge master 2 back into
master hopefully that makes sense so let
me just leave my my two branches here
master two so delete my branches are not
even there anymore get branch and should
mention them and I just showed you
emerge this was a merchant most merges
and get are really that simple and this
is one of the things that people that
have worked with subversion are usually
quite fascinated by because merging
things in subversion or and CVS is a
pain and the behind but this is a this
is usually really easy you get into
conflicts if you merge something and
it's about the same lines that you want
to merge and that's let's just see how
how we could do that so let's check out
a new branch let me actually produce a
merge conflict so I go get check out - B
- B of conflict I call it conflict so
anomalous new branch I do a gem of the
readme MD and I say hello let's just say
hello world again and it commits this
more inclusive and check out a master
back create maybe a second branch
taking branch exclamation again since I
much just a branch this branch off of
the initial one this says still at hello
LA and let me just add a few exclamation
marks because that's really cool things
the point across emphasized yes so go
back to my master branch and now I have
two two branches that still aren't in
master so I still don't have to change
that I just made in master and I can I
can merge them into master so I merge
let's say exclamation first that works
that's really a fast and easy now if I
merge the the one that I call conflict
its managing the same line and as long
as soon as you manage you're touching
the same lines and get get says I don't
know how you do this yes one of you just
entered exclamation marks at the end of
the line and the other one changed the
the content or the something before this
in the line but as long as the line is
not the same it will say this is this is
weird you handle this please and it will
tell you by telling you there's a merge
conflict if you do get status it will
also tell me there's an unmerged path if
I try to commit now I can't I think
why did it do work this should not have
worked this is weird anyway what you
supposed to do is not committed first
this wasn't with its resolve this
conflict and their GUI tools for doing
this if it's if it's really complicated
but lazy what it's doing is it's telling
you the head so the current version of
Master had this content in it it had
hello la with the exclamation marks and
then the other version are try to merge
into it from the conflict branch had
this text in it I have to resolve this
by deleting these weird signs and
picking one of these versions or in this
case I want to say hello world but
really make it stick so on this is my
change I have to make this change
manually and then this becomes resolved
much conflict and so that workflow was
called the feature branch workflow and
this is something I would highly
recommend for every everything that you
think might be more than just editing
one line so when you find a bug and you
know it's a typo and it's just a
one-liner thing make the change in
master but if if you have no idea what
it is and if you know that you have to
rip apart your code always start with
the branch it's really simple I remember
it's just the get check out - be or - be
branch name then do your changes and
then switch back to master and verge - -
yeah
it yeah that could be you that's right
yeah actually that is right you're
saying any any updates whatsoever except
maybe I shouldn't maybe I shouldn't do
the - I do get maybe I should not do
that anymore you can do get stage would
be the way to get around the get all
right
the other cool thing you can do with
these local branches as soon as you
don't work with other people on these
branches there's one more cool thing you
can do is and let's that's my last my
last nasty command-line thing is some
long commits story long let's just call
it in the home so now only the branch
code long and I make a change so do you
find the talk is I'm actually committing
few things added a line what I want to
do is I want to do to producing a bunch
of commits added a line it is again
another line and I do another commit and
this was the other part that was missing
so if I look at my get history now if I
get it I get lock I just made two really
stupid simple changes but in the end
this is what I wanted to do and I don't
care that these were two commits I want
to basically make them one commit and I
said earlier that all of these commits
are basically chained in a chain of a
chain of commit logs or commit yeah well
looks like a block chain also a block
chain so I can't lead change stuff
except for I can change the last couple
of ones and I can squash them together I
can do something to them this is a bit
dangerous and that it works really well
when you do it locally this does not
work and again the same as a block chain
this is just local to me I computer I
can I'm happy to rewrite the history of
my commit lock but if anybody else has
checked this code out that's not a good
idea because they might have a different
version and if you try to bring these
two together again that wouldn't work
this is why the the feature branch
workflow has you working in your own
private branch right so if you're in
your own private branch that no one else
is committing to you can do almost
whatever you
when you come when it comes time to
merge that private branch into the
master branch that's what your ins gonna
do is he's going to do it and squash it
down to one yep so I I do what's called
a git rebase and look at this there's
two commit messages this was another
part that was missing editor line I do
this - he means interactive and then re
oh this is I mix this off quite quite a
lot yes I forget that I actually have to
use this one because that's the one that
I want to go down to and then I have
these two these two commits and I can
now choose between picking them which
means just use it or I can squash it or
it can fix it up as squashing means make
them and to turn them into one commit
but conserve the the commit messages so
I'm taking the last one actually I can
rewrite this or I don't just go ahead so
this is my commit message now and it's
not the most beautiful one but there it
is and now if I do good luck these two
are now basically one commit and that
makes it easier for other people to to
maybe maybe it's a long feature that I
worked and it was important for me to
commit every five minutes because that's
how I felt but at the end nobody really
cares that all of these commits are part
of this one new feature developed so
before I merge my feature back into a
what I love you might also be working
with I might want to do this rebase all
right so that's that's basically all
these single user use cases and we
talked about how its distributed in the
beginning and to do that I want to push
this to to github which is probably them
them the most popular of the public get
repositories and there's other ones out
there there's good lab there's some the
Oracle developer cloud service which I
might have open here nope there these
are all GUI tools or online tools online
services that help you manage your your
your get and the way they do it is they
basically store a clone of the git
repository and then they have some
enhancements to it and that they allow
you to do some some things with it so
I'm starting by just going to github
where I have an account this is free and
I the Chimera apologize and I create a
new repository and I call it code la
silly simple demo I get the choice
between making it public and private
public means that everybody in the world
can read my code they can't necessarily
modify my version of it private would
mean that I can control who has to read
access to it for private you have to pay
with github public you can just do and
then you get this option of initializing
it or not initializing it and if you
remember at the beginning in it was the
first command we went the repository
that we have is already initialized so
we don't want to initialize this again
because that would not work so we just
create an empty repository that's not
initialized and nicely enough it tells
us exactly what we need to do so we have
an existing repository and it tells me
this is this is what you need to do so
do this get remote add remote is
basically for all the other remotes an
origin is the default remote and I'm
using SSH I already have my SSH key
stored in github so I run this and then
I do what's called the git push where I
push my code after the repository and
this will now create a clone or just
yeah so my repository to github and if
we go back to github and we refresh this
page it shows us there it is but all the
exclamation marks and all the beauty and
I think we should probably move ahead
quicker but just one thing or two things
I want to show is some if you click on
the file like the blame I showed you
earlier this is a lot nicer here because
it formats it nicer and it shows that
there little icon and then I can click
on any of these these things and see
what the actual commits was that was to
blame for for a change that's that so
now published my my repository my code
to github which means that I have all of
you or Stewart could could pull it and I
think that's what we want to do because
they the question now is how do people
actually work together with this right
can we switch screens please
we switch screens please yeah thank you
so this is me logged into github and on
on bjÃ¸rn's account and I can see I
haven't refreshed yet since he actually
pushed his code so now I'm going to do
that and I can see his code here there's
a couple of different ways that people
can collaborate in github you can do I
could check this out right right now so
I could grab this and actually check it
out but what I'm gonna do is instead is
I'm gonna fork this into my own account
so there are different use case there
are different reasons you might do this
one way or the other
but I want to I want a copy of this
repository to actually exist in my own
github account and pub the reason for
doing that is Stewart does not have
write permissions on my repository so
Stewart can clone it and can create a
copy of it but he cannot push changes
back so whatever commits he makes he
couldn't push it to my version of the
github repository because that's just
not set up the last thing I want is to
have code that I can't push right so one
way around that to always be able to to
be able to push code to the server
regardless of permissions is to put it
in your own account and then do will do
what's called a pull request later - for
me to ask Bjorn to please include my
changes in his into his account so you
can see I can clone it right here I'm
going to copy that
get hub really makes this easy I'm in my
directory I'm going to provide those
credentials and I'm gonna check it out -
no delay put good clone before yeah
sorry
so I'm pulling all this down and you can
see what's I'm on the master branch so I
can make changes here as well I can
let's read me now right
actually just fix the typo in the
background
and I'm gonna do a little different is
I'm going to put my commit message right
here in line okay so if you want if you
be tired of bringing up an editor every
time you you just want to specify your
changes
and then I can sorry actually I'll just
go straight from here it tells me what's
what I need to do to set up this remote
branch with the server and again this
would be nice that it just tells you you
know command doesn't work but this is
probably what you want to do so I
created the branch locally the server is
unaware of it so I need to tell it that
I actually want you to set this up on
the server as well and now so Stewart
branches now exists on my account in
github so notice I am in my fort version
of this and there's my branch and I want
to put my changes into Beorn's
repository and I'm opening what's called
a pull request and this is a terminology
that github pretty much created this
term pull request didn't exist and
doesn't exist really in the get tool
itself it's a it's a github thing really
and basically it is a request for Bjorn
to pull my changes so I'm gonna create
notice that gets already telling me it's
not going to have any any issues merging
this okay so on the server all they get
utilities and merge utilities and blame
and log utilities at github disposal so
it knows that this is going to be a
clean merge and I'm going to create this
pull request I don't have any sort of
DevOps processes running if I did have
some web-based DevOps processes build
test type things those could plug in
right here github is really good at that
and I'm just gonna let your know that I
would really like him to include my
changes
and there it is would you mind switching
the screens again please and so I would
have gotten an email now and can we
switch the screens please Hey wrong one
one more there we go there we go
so if i refresh this now and this is
what these web-based repositories to
developer cloud service that's the same
thing there's a few tabs up here and one
of them is pull request so I just
received an email saying there's a new
Pro because I can pull this up and it's
one that's open and I can I can have a
look at this just me here are my changes
so that's that and I can look at look at
this commit and shows me the actual
changes changes I can comment on this
and I can I can even if I if I said this
is not what I really want from my code I
can either just send it back to him and
say please fix us up and make it better
or I could also just clone it to my own
repository into a branch and say I
modified this myself and so I'm happy
with it
in this case I'm happy and I just say
merge it back into and then that's
that's it I've lost all I say it's
confirmed much and now it's merged it's
merged on the server so it's not merged
in in bjÃ¸rn's local cop now I want to
say that so remember we have four clones
of this repository now there's two
hundred servers on github like his fork
and my original repository his local
repository and and this local repository
they're basically all peers right there
they're they're equal and in pretty much
every way from a repository perspective
so if I do if I do this read me
this is not in here I have to run what's
called the git pull which will now talk
to the remote called origin and say are
there any other any changes and there
were changes that were pulled in and if
I to do this now it'll tell me you know
y'all some changes so that's there and
we did manage to fill 45 minutes pretty
unbelievable we have 35 seconds
according this timer so we'd be happy to
take some questions yeah
yep yeah
the answer's no that's not the right
camp so so when you either from the
tooling perspective of github right or
from your own local command-line tools
in your local repository you can commit
all day long your show and you can also
when you when you accept a pull request
using the GUI as well one of the options
drop-down options is rebase so you
should commit every point that you want
to be able to roll back in my mind
that's that's every time I write a piece
of something that works right I want to
commit so you'll see my my log history
has has commits every five six seven
minutes now when I open a pull request
they may rebase that into a single
commit squashing all of that down with
some more generic comment so that's one
I think that school of thought of commit
when you're done comes from the
subversion world where you're not in a
distributed repository system I can say
that the one the times that I regret not
having committed is its when I think I'm
not done and I think I come back to this
in an hour or so then I don't and then I
come back to it five days later and then
I want to continue work and in the first
thing I want when I'm going to continue
work is kid status and it tells me oh
it's not clean there's uncommitted
changes and then I have to remember what
was it exactly that I did last time and
then I have to come up with the commit
message and I'd rather commit too often
and especially again if you do the
feature branch workflow where you do all
your work and in branches and it really
doesn't hurt to commit as often as you
want because you can always rebase the
stuff and squash it together and do that
and I think there's there's not really
too much committing because of the
rebasing and there's rather just too
little committing and then just having
gigantic commits yep
right so that's again back to
distributed model is the there's four
version of the suppository and the
comment was that there's two step says
commit and push and the commit does only
do stuff to my local repository nobody
else will see this unless they can
either read my repository or I push it
to a central repository so again I'm
fine to commit commit commit commit and
then rebase the stuff before I push it
to the centrists actually three I'd say
there's actually three steps right so
it's on your own local branch that no
one else is working in that someone else
can check it out if they want to see
what you doing if you say hey I'm having
trouble will you check this out and take
a look at it but in general it's one
feature one branch per feature
development and one developer so you're
developing you're developing you get
commit push and then either through
opening a pull request or doing a merge
then you're also merging that feature
branch into the master that merge can be
a rebase instead right yep
yep yeah fantastic thanks for the tip it
bisect I think beginning around 200 or
so I don't think it's been there yeah
forever I think it's one of these things
that we didn't include in this
presentation because the thing is not
one of the most basic things to do but
if today you ever get to take away from
the session is go to your to your
directory that you have text files in
our code in one get in it and just add
commit messages to it then you can do
this later</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>