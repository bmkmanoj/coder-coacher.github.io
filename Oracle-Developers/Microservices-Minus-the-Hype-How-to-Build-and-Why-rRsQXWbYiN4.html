<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Microservices Minus the Hype  How to Build and Why | Coder Coacher - Coaching Coders</title><meta content="Microservices Minus the Hype  How to Build and Why - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Microservices Minus the Hype  How to Build and Why</b></h2><h5 class="post__date">2016-09-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rRsQXWbYiN4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I need to take care of the most
important part first which is proving to
my boss that I was actually here so if i
can get your picture that would be great
if you want to smile or make funny faces
it's it's entirely up to you wait yeah
that'd be good way to run so this is a
great big crowd so hey starting off or
close to starting out javaone everybody
stole you know awake and energized as
good as a week as it goes on you know
we'll see but anyway I do have stand
ends so if my voice gives out halfway
through I can tag in a couple people
here in the audience so you know who you
are and don't make break for the exit
you're stuck welcome welcome to this
afternoon session on micro services- the
hype how to build and why it's it's more
of a kind of a long-running discussion
we have about an hour here which is just
about enough time to you know touch on
several subjects and not really to dive
into any of them as well as any of us
would like but if we can get kind of
things going and the thoughts going and
the conversation going that's great
because we can carry on the good stuff
later my name is mark heckler I am a
principal technologist and developer
advocate with pivotal software I may
have heard of pivotal for the makers of
spring boot spring framework rabbit and
Q Redis greenplum huge contributor to
apache tomcat giant handful of other
things so that we like to call it a
small start-up here in the bay area so i
blog not as often as i'd like that as
often as i can at the heck was that org
by private domain i tweet all the time I
kind of live on Twitter MK heck is
anybody here on Twitter oh come on
that's it Wow okay well for those of you
who aren't on twitter i recommend you
get on twitter but other than that i'm
also a member of the slightly older and
more established social network home
email so if you if you want to reach out
to me i'm far better at responding on
twitter because again
I live on Twitter but I do check email
from time to time so by all means shoot
me an email we don't again have a lot of
time there it's there's probably a good
chance that I will cover something that
you wanted to hear not at all or that I
don't cover it as well as you'd like I
gloss over too quickly or whatever and
I'm happy to go into much deeper
discussions about anything spoken here
or not but you know again time excuse me
so Who am I well when they also have
several blogs and blog posts I've
co-authored one book already I have
another one in the pipeline I've
contributed to several others both texts
in code I love to read I love to write I
love to share i always feel like the
more we all share the faster we all
learned which seems like a positive to
me I've spoken around the world on
various development center topics thanks
for inviting me back to Java 1 i've been
here for several years love java one
always has a special place in my heart I
first and foremost I'm a developer you
know I use what works and when I find
something that works better I adopt that
when I find gaps in something that is
working or maybe gaps in functionality
that should be working i try to fill
those i'm a java champion recently
inducted and very very grateful for that
because it's recognition by the
community for contributions to the
community if any of you had anything to
do with that thank you i really
appreciate it and as i say i'm a
survivor of many monoliths i was a
for reluctant convert to micro services
because i'd worked with monoliths for
years and i could see a lot of the pros
and cons but you know there's some
comfort and what you know right so i
didn't run embracing run to and embrace
microservices but I've come to be a
convert and I'll share some of the
rationale behind that today as well
and like I say I'm a seeker of a better
way because I'm always looking for a
better way to deploy real software into
production not undifferentiated heavy
lifting as Adrian cocroft formerly of
Netflix likes to say so anyway so where
do we go from here well my goal today is
this to stay as close to a purely
fact-based discussion as possible while
hopefully throwing in numerous
interesting or amusing TV or movie
references at no extra charge but no
strawman I always kind of hate it when
people set up easy arguments and knock
them down you know sometimes the
arguments just kind of present
themselves to you but I really gonna
hate to see when people take the cheap
shots so I to avoid that but I have Hume
human I have opinions so if anybody's
goal is to find something with which to
disagree i'm going to give you plenty to
disagree with that's cool but let's talk
about it yeah let's let's talk after the
fact and keep the discussion going but
guys I'm open I'm learning everybody's
always learning so hopefully this talk
is a a thought-provoking informative and
mildly entertaining dog so this is the
goal not this the talk this talk isn't
to impress its inspire inspire to think
to consider in to broaden our horizons a
little bit so again to recap the goal is
this not this
okay so what is I'm separately with Mike
and I can't do that I love to walk
around and that's unfortunately I walk
around you're never going to hear me
today so what is our goal as developers
regardless of what you may have heard
speed isn't the gold velocity is and
what's the difference right well it's a
key looky here it's been record ball
speed is a scalar property velocity is a
vector property what does that mean well
the simplest way I like to put it is
velocity of speed plus direction so you
can run really fast and if you're
running in place you're getting nowhere
so a lot of the trade brass an article
saritas speed is critical speed speed
doesn't do anything velocity is what you
need you need speed in a given direction
so you can make progress and that's what
we all hope to accomplish right so what
actually click required so it's it's
something formative it's somewhat
informative if we're considering
microservice is to kind of know we're
considering them against or in
comparison to and contrasting so what
are the alternatives well typically the
alternative you you typically hold up
against microservice is this the mana
left and as I say that's one big app
does anybody recognize this by the way I
should have asked that earlier but
surely you all recognize that earlier 22
photos right okay good I'm starting to
think mayor's on the wrong room the
wrong conference does anyone know does
anyone recognize this okay do you do you
know which Godzilla movie this was from
or or or show
what I'm sorry no no no but no t-shirt
for you oh I'm just getting I don't have
t-shirts if i gave you a t-shirt I'd be
up here naked and that's not anything
anyone wants to see so this is from the
2014 movie so you know keep keep awake
folks there's a quiz anyway so I find it
instructive when you're comparing I'm
going to try to move this little closer
apologies for any voice i find it
instructive when you're looking at
something to try to define it to look at
its characteristics so let's start with
that the characteristics of a model f ok
yeah i need to be able to see it too
that's can you still hear me know oh
come on everybody else said yes but this
guy yeah man
I'm knackered okay keep that in mind ok
that is quieter isn't it well alright
let's try that I'll just have to look
down here ok so the characteristics as a
model typically you have one single
logical executable in the Java world
typically you're looking at a jar or a
war file god forbid and ear file
possibly even as well but whether it's
Java or something else you know maybe a
deployment bundle or directory or what
have you so with the model if you have a
lot of functionality cutting across
several different domains if you will
that are all bundled into a single
logical executable typically they're
shared data across functionality it
doesn't necessarily mean a single
database or schema but that's usually
the case and that has a lot of history
behind it typically what you see is
organizations while now I'm getting
feedback ok organizations where you have
kind of a horizontal layering right so
you have your your and it actually
mirrors your organization's has anybody
here heard of Conway's law ok excellent
yeah good friendly crowd dr. Melvin
Conway wrote back in the 60s he's still
active by the way prominent computer
scientists still tweets although fairly
irregularly but he produced a paper in
the late 60s talking about how your
systems any systems will mirror the
communication structures within an
organization just can't help it so
typically when you have a dev group and
an ops group you have things that shake
out like your dev environments in the
office environments and entering into
the ole into the circumstances of the
environment the early days of computing
were hardware and software were
incredibly expensive so you typically
consolidated everything into a single
database into a single app server and
you try to maximize that as much as you
could so you over time of course things
don't change in many cases so many times
still you have this monolith which has a
lot of different functionality bundled
into one logical executable and you're
running on a single
data source underneath it's just the way
it has evolved over time with a model is
typically changed to the flow of control
without modification of the monolithic
app is is pretty near impossible I mean
you're going to be doing some
modifications possibly to multiple
modules when then they're rebuilding the
whole thing retesting a tree deploying
it and I kind of actually got ahead of
myself to the next point modifications
to the monolithic application require
the rebuild retest redeployment the
entire app and there are tools to get
around that but they are indeed
workarounds I mean they're excellent
work arounds but it's an acknowledged
problem right scaling the monolith
requires scaling the entire model with
including modules that you rarely use I
always like to to kind of think of an
order entry system or an online retailer
system and if an online retailer vets
their customers really well they may not
have many returns but so the return
module may be rarely used but every time
you have a change to your ordering
system you're going to rebuild
everything retest everything redeploying
redeploy everything if it is a model out
with a monolith typically there's a
greater attachment or greater commitment
to a particular set of technologies
there's a language there's a platform
like an application server what have you
drivers third-party libraries and and
typically these are somewhat problematic
to employ so once they're employed
within any area within the monolith that
same library that same deployment
mechanism is used to out and it kind of
makes sense especially during deployment
but even on libraries typically if you
bring in one library to do a particular
function in one module you're going to
use that same library in all modules it
just makes sense but that also increases
your coupling to particular technologies
across the board there is a much lower
cohesion and higher degree of coupling
in a model and and this is something
that's that's always troubled me a
little bit because even if that's not
the case initially you know sometimes
people make the argument that you don't
need to break things out into micro
services in order to have
design and it's absolutely the case but
has anyone here heard of the second law
of thermodynamics yeah you know it's an
unfortunate thing that things are going
to devolve over time the best example I
can think of is is if a junior
programmer is on on call and it's let's
say it's eight in the morning in
California well let's say better yet
it's earlier than that in the morning
and and you're you're looking at the
massive amount of people who are going
to be coming online and hitting your
site hitting your applications within a
very short time and the junior dev is
told that the system's down and you need
to get it back online now let's say the
junior dev really wants to do things the
right way but it's going to take
probably several hours to figure out the
right way to do it and do it in a way
that's isolated and insulated from
touching a lot of other things or or
there's a quick fix but involves
reaching across several modules may be
digging into two or three tables that
aren't typically typically accessed from
this particular module but said dev can
get this back online in 15 minutes what
do you think is going to happen because
if that doesn't happen if several hours
go by and that systems offline Jr dev
may be cleaning out Jeff's desk by lunch
time so it's it's just a matter of
practicality amazon is is probably the
best example I can think of for byte by
pushing that and enforcing those
boundaries by creating everything in an
API first type of environment where you
you dictate that all business
functionality has to be exposed exposed
excuse me vien API and you have to
maintain that API as contract with other
microservices it allows you to to it
enforces a certain rigor upon you you
can't reach in and access data that is
controlled by another microservice
because that's your only way in right so
there is a much with a model if there is
at least even if not initially
eventually a lower amount of kehi
a higher degree of coupling across
modules failure of the part usually
quite Stu failure of the whole again a
great example of this is that data
access layer because if everything is
using a shared data store underneath and
that data store goes down everything
goes down one huge benefit of a model f
is that the mental model is fairly
complete for smaller systems meaning if
you have a fairly self-contained fairly
small monolith you can reason about the
whole thing very well and it's it's
easier to kind of keep track of how
everything is working and where where
all the bodies are buried if you will
the the problem with that typically is
not initially it's eventually again
because what typically happens if you
are told to develop a monolithic
application and it's going to serve a
workgroup or a small department maybe
even a division what happens when your
company buys another company and this
has never happened any of us right okay
yeah and then all of a sudden you're 50
users went to 500 or five thousand users
and maybe they were all in one location
now they're geographically dispersed
what now so this the romantic concept of
a very small self-contained monolith I
think in most cases is just that it
doesn't certainly doesn't stay that way
even if it starts that way so in
comparison microservices more than meets
the eye right they come together they
accomplish a greater task does anyone
recognize this okay which year quit
which movie yes yeah yeah oh wow okay
well obviously there aren't any crazy
movie geeks in it I have another talk
later this week rite throughout movie
quotes so you know if you're really
interested in you know leveling up on
your movie come to that one but this is
from transformers 2007 the subsequent
movies weren't worth watching anyway so
okay
alright so some characteristics of my
micro services excuse me I want to go
back inside typically microservices are
independently deployable and executable
services multiples of them their focus
services very focused services in most
cases they provide specific application
functionality this allows you to develop
in a way that makes sense for your
organization in a way that makes sense
for your need to provide velocity who
are needed and stability we're not
needed because again there are going to
be some modules some some business
capabilities that are going to rarely
change that may or may be rarely used so
to focus even in in some tangential way
development resources on those is
somewhat wasteful right so by breaking
these down into focus services you can
focus upon what makes sense what is more
volatile what needs to be given more
attention and developed quickly or
revised frequently control flow changes
typically in a micro service
architecture or trivial certainly more
trivial due to composition and queuing
you have a lot of things in play that
can allow you to D couple things quite
nicely and to in effect create new
control flows without having to rebuild
H they rebuilt the monolith but
certainly rebuild massive amounts of
functionality within your greater set of
functionality typically a change to any
microservices non-disruptive because
again the smaller scope adherence to
that contract if you change things
internally but you don't change the
contract that you have with the outside
world with other micro services nobody
cares you're not impacting them and
typically with the tooling that you have
the ability to swap in gradually or to
do like Bluegreen deployments and things
like that and nothing even has to notice
even consumers of your micro service
there's more effective and efficient
scaling as with velocity in which we we
can develop and iterate quickly we're
needed we can also scale what needs it
when it needs it so if if there
does everybody know what Black Friday is
okay yeah i mean is us you know but but
sometimes you say that and people look
at you really strangely but with black
friday you may have to scale your order
entry your cataloging type of modules
you may not have to scale your returns
module now a week later or maybe the
week after christmas you may but that
this allows you to scale what makes
sense when it makes sense as well and a
scale dynamically up and down so you you
can concentrate your computing power
where it needs to be when it needs to be
there standardizing upon api's and
contracts for interaction provides
opportunity for polyglot implementations
what i call polyglot plus so you can
choose the proper the best fitting
language platform locations you can
deploy things some things on premises
some things in the public cloud it gives
you the opportunity to make those
decisions at a much more granular level
then then a model if could ever do much
higher degree of cohesion and lower
amount of coupling because with bounded
contacts there's an API enforced
separation of concerns is anyone here
familiar with domain driven design dr.
eric evans okay bounded contacts single
responsibility principle you know you're
looking at creating a micro service
around a single responsibility I always
kind of find it a little ironic that
single responsibility principle is do
one thing and do it well but anyway some
of you didn't get that ask your friend
six of you anyway it's sort of like the
words hyphenated and non hyphenated
that's a bit ironic but okay okay so um
yeah some of you okay we'll cover that
later so failure is isolated in a micro
services environment in a proper
implementation who sorry up
anticipates failure because in a
microservices architecture it's it's
built around a different set of
assumptions if it's built right at all
in a monolithic environment when the
model if goes down the business stops
right I mean everything stops and
everything is focused before that
failure happens on making sure that
failure doesn't happen with a micro
services architecture you typically
assume failure because that plates
anyone here is netflix subscriber yeah
couple so on the main page that is all
microservices driven that single pane of
glass a single application and would
anybody hazard a guess on how many
Microsoft's feed that single pane of
glass somebody about 500 roughly last
count last I heard so that's quite a
handful right now how would anybody care
to guess what the odds are that any one
of those microservices is the only
instance of that microservice running
anywhere on the planet probably pretty
low so you have let's just say for
argument's sake 500 microservices and
ten instances of each that's easy math
so hope take that so that's 5,000
microservices that are having to run
together and coordinate and communicate
right why do that well because you know
that you're going to have to have a
certain amount of load capability you
also know that at some point you may
have outages you may have a network drop
out you may have an instance drop out
and that's fine because you have a
system built around the idea of failure
versus the idea of oh my god I hope
nothing fails so it's it's built into
the architecture it's assumed let's see
so where did I leave off manageable
mental model this is something that
seems a little contradictory from
earlier because with the small model if
you have a very manageable mental model
but let's go to your typical monolith
where you have a rather large sprawling
system and let's say you bring in a new
developer whether it's a junior dev or
whether it's a senior dev from another
Department another group how long does
it take them to get there
around and build the mental model for
that entire model of forever right
whereas if you if you if you hand them
responsibility for a small handful of
micro services I mean typically you're
looking at it a small amount of code a
small amount of functionality it's very
easy to spin up very quickly in a micro
services world Jeff Bezos made the
famous comment to pizza box teams and
and one of our one of our engineers at
pivotal made the joke at a recent
conference we had that we found that if
you drop a couple pizza boxes into a rim
the developers congregate naturally
around them I'm not sure that's how that
works but but it sounds good and pizza
doesn't sound bad either actually but
but the idea is that it makes sense you
have a smaller amount of responsibility
you can get your head around and grog so
sometimes at this point in the
conversation people say wait a minute
you know this sounds an awful lot like
so uh isn't this just warmed over so on
No so moving on you probably want a
little more information no check okay
well they're conceptually similar you
know and and sometimes you hear that
people say microservices what so it was
intended to be I i think the
implementation draws a really clear
distinction i throw out a couple of
quotes and we kind of dissect it a
little bit here I like what Martin
Fowler says microsoft of style is very
simpler to sew up so it means too many
different things and most of the time
when we come across something called so
it's completely it's significantly
different from the style that we're
describing here usually due to a focus
on what on ESPs Enterprise Service
bestest used to integrate and this is
another thing that i absolutely love use
to integrate what monolithic
applications so so even though a lot of
people think that's just like
microservices well no it sounds like in
at first glance and then when you really
kind of peel back the layers you start
to see it's not really that similar he
also goes on to say that the fact that
so it means such different things means
it's valuable to have a term the more
crisply defines the architectural style
that's good because
one term that people interpret a hundred
different ways here they say my
microservices is an evolution of soil
concepts the benefit that they bring of
course is that traditional so uh is not
speedy it's not agile it's very more
difficult to make changes and with
microservices the ability to make
changes with less overall cost and less
impact on the existing infrastructure is
key right it's a different approach
using with different uses of technology
so let's peel back the layers a little
bit it's just taking too long as I
clicked unfortunately it like that Wow
let's take your time I guess I need to
redo that slide okay so so uh what I
call macro services right often they're
monoliths retrofitted with service api's
and connected via heavy smart pipeline
so in a way it's more complexity and
even less nimble irony it's also heavier
the protocol the formatting of data
exchange is heavier in general you have
so which makes no assumptions about
underlying transport mechanisms you have
XML which is a little more wordy there's
also more coupled ceremony because many
if not most times producer and consumer
code is generated from wisdom so clients
are tied rather forcefully to the API
and when the API changes both backing
services and clients must typically
change in unison doesn't sound very
decoupled right the Enterprise Service
bus products usually incorporate
sophisticated facilities for message
routing coordination transformation and
applying business rules and as such any
svx turn Eliza's domain knowledge while
incorporating process knowledge which
ironically increases coupling due to the
aforementioned dumb endpoints while
decreasing it because the bus
orchestrates the processes
so it's kind of a kind of a mishmash
they're all of these points and more
make it much more difficult to scale
within a so environment with regard to
microservices the downside is there a
lot more of them I mean again just in
the little example I used for netflix
for a simple app you're looking at
thousands at least thousands of
instances of microservices microservices
are lighter as a rule they don't have to
accommodate multiple transport
mechanisms because guess what HTTP one
adhering sorry so soap typically has
things like you know support for HTTP
SMTP amqp UDP what have you versus rest
over HTTP applications from my curse
from micro services aimed to be as
decoupled and cohesive as possible
adhering to the API the contract is the
only requirement for success changes to
the micro service don't require
synchronized updates as long as the API
doesn't change I hear the difference
here I'll try to keep leaning in a micro
Service owns its own domain logic so you
get the smarter endpoints typically a
micro Service receives a request takes
the appropriate action and returns the
response rest are similar versus
something like WS choreography or B pole
or other centralized orchestration tool
pipelines whether they're rest endpoint
calls or message queues are streamlined
and straightforward so they're dumb so
to speak decentralized and decoupled I
always kind of compare it like dancers
versus an orchestra if you consider so
uh like an orchestra anyone familiar
with orchestras cat come on great you
have a conductor right in front that
conductors really critical to the
performance and he practices with the
orchestra he or she and at the time of
the performance guess where the
conductor is right out in front making
sure everything goes right okay let's
compare that are so Orchestra with our
microservices dance team so our dance
troupe
microservices has a choreographer the
choreographer comes in and works with
all of the individual dancers to make
sure that they know what they're doing
so the dancers in turn when it comes to
the night or performance dance they do
their thing they adjust to the dancers
around them in case anything goes off
off you know step but where's the
choreographer choreographers either in
the audience or maybe even in another
city maybe even halfway around the
planet the choreographer is not there so
the choreographer basically sets the
situation up for success and then leaves
the choreographer is not the bottleneck
in this situation in the system and
that's kind of a key difference so
that's how I kind of think of it anyway
so micro services are built with scaling
in mind from the beginning because
they're smaller they're lighter the
bounded context their API driven again
if you adhere to the contract
everything's good so there's always a
game there's always a loss right and
that's what it comes down to is what are
you willing to give up to get the
benefits if you are and there you know
that's definitely the case so let's take
a look at a few of them there are
trade-offs that more somewhat
contradictory welcome to the real world
depending on the priorities of the
business there's more scalability
typically you isolate high demand
modules that gives you more focus so you
can scale those more readily we kind of
talked about that there's greater
efficiency due to that increased focus
there's a greater effectiveness
typically because rapid iterations of
what I call nuggets of functionality
results in more accurate fulfillment of
business requirements if you're working
on a module and a monolith but I always
just like to ask this question if don't
embarrass yourself if you don't want to
respond but is anybody here working on a
model a thur or working in a group with
a monolith I pet my 11 ok what's what's
your what's your release cycle is it 12
months and up anybody okay we have one
honest person here that's good
There s y'all will talk later six to 12
months 3d 6023 okay that's that's pretty
good when you can have more rapid
release cycles with monoliths you just
you run into a lot of friction so
typically what you see is longer release
cycles and many times there are really
good reasons for that there have been
issues there have been breakages there
have been a lot of things that
contribute to all that but what I was
like to go back to is for for your
typical monolith and I don't have the
statistics right here in front of me but
at 12 to 18 months release cycle is not
uncommon it really isn't so let's just
say 12 that's easy one year if you're
working on a one-year release cycle and
you're trying to get new functionality
in there if you're working with a
business person or a business team to
get new functionality again how long
does that take well at the very least
let's say they got in early in your
release cycle and you've developed the
requirement you've worked up the code
you've you've gone through the whole
thing you've done the testing you know
the the unit testing integration testing
to put user acceptance testing and all
that stuff you know code freeze
deployment everything's great minimum
you're talking as a year so what happens
have anybody here on longer release
cycle model have ever had the case where
your business point of contact your
subject matter expert is no longer in
that position at the time of the release
yeah and see you're all you're giving it
away you've all been there and that
frequently happens that person is either
in a different capacity a different
department maybe even a different
company so what happens then when you
release the functionality that you work
with an or Bob so hard to get in the
system now all of a sudden tony is
taking over and Tony looks at it and
says that's not what we need at all and
was high bob was always out to lunch
what are you doing so then you get this
yeah not that I've ever worked with a
nabob of course but see you get this
this problem with requirements trip with
not quite hitting the mark so many times
when you have a you have greater
velocity you have a
or bounded bit of functionality you can
release that rather quickly right so you
can do a very quick release cycle maybe
it's a matter of a couple months maybe
it's a matter of a couple weeks so the
chances of losing that subject matter
expert and losing that velocity losing
that accuracy is much much lower because
and as as well as working more closely
with them so your your missus are much
smaller in a micro service world all
other things being equal I kind of got
off target there but I mean again we've
all lived through these things that's
why they're so funny because we've all
walked away and survived them somehow
optimization so let's see you can choose
the best language platform database for
that particular service and what's more
with the micro service let's say that
you adopt a particular bit of technology
you adopt different language that maybe
is more suitable for the statistics
that's involved in this module or a
different database platform this may be
better suited to how you're storing that
particular data for that particular
microservice and let's say it doesn't
work let's say that your performance is
one third of what it should be and
you've eked out every bit you can what
then your risk is so low because you can
rewrite the whole microservice in a very
short time you can't do that with a
monolith your risk is dramatically
higher just due to the size of it and
you'd never even consider a change in
most cases of language or platform
because it's just impractical it just
can't be done again interoperability is
higher because if you adhere the API and
access requirements obviously you're in
availability is non binary architectures
assume rapid multi-instance app
deployments has anyone heard of the
circuit breaker pattern circuit breaker
capabilities your availability is
typically much higher on my talk later
in the week actually show you that I
don't know that I'm going to have time
to show you a lot of that now that will
touch on what we can but the idea behind
the circuit breaker with a Monell if
it's either up or down typically right
so if the model that goes down what
happens well demand doesn't stop demand
just builds up so when the model if
comes back online what happens
at that point well here's your demand
here's your mana left and that's what
happens so you get this weird situation
of the monolith this up monolith is down
the monolith is that the model is down
with a circuit breaker pattern properly
implemented has most microservices
architectures incorporate from the
get-go or very early on you you start
restoring connectivity gradually so it
will occasionally once every however
many it's typically very configurable it
will try to reach out to the down
service and find it and once it finds it
it doesn't just rear out all traffic to
it it gives it time to heal so it will
slowly restore that traffic and bring it
back online to where you don't get into
this whipsaw effect so greater
availability greater independence this
is kind of fun to talk about here but
with with microservices you're typically
not strapped to a particular platform
language again we've mentioned that you
can develop certain microservices in one
language or on certain platform
different database whatever and not
others that gives you a lot of leverage
so you're not tied to a particular
licensing agreement or a particular
vendor you have choices you are in the
driver's seat again versus what your
acquisitions folks have told you you
have to use because they signed it
through your deal there's typically cost
savings not out of the box not out of
the gate not by default but certainly
the potential cost savings because again
you're not tied to a vendor or a
particular licensing strategy you can
choose what makes sense for you
technology wise license wise it's up to
you and potentially increased revenue
this is always a fun one to talk about
because it not out of the gate by
default but is anybody here tuve Amazon
a couple people okay last year Amazon's
Cloud revenues exceeded its revenues
from all other business units all others
amazon is not a bookstore amazon is not
an online retailer amazon is a cloud
services company web services AWS which
kind of makes sense but if you think
about it when it started Jeff Bezos
dictated that all services and these
were initially just to be
exposed and used within the company
within the Earth's biggest bookstore but
all services would be or all
functionality would be exposed via
services and controlled via access via
API so this became over time a very
valuable contributor to revenue very
valuable contributor to to profits so
there's a very good chance that if you
define an API if you break things out
more granularly that you can create a
better working environment for your
systems internally but also potentially
expose more of those things to partners
to customers and do so at a more
granular level try that with a monolith
because you can do that but you're going
to be going to a lot of trouble to make
sure that by exposing one bit of
functionality within your model if
you're not throwing out the keys to the
kingdom it's it's a lot more difficult
for potentially more difficult at the
micro service level again typically much
less complexity because there's a
shorter ramp up he's your knowledge
transfers and then of course control see
above I didn't mention things like lower
complexity per unit test cases are
typically run only against you know
targeted or changed modules faster
deployments due to smaller apps /
modules fewer test for their module it
just everything is faster when you're
having to test and code to this much
functionality versus this much so what
are the losses those are all great
things but is it worth it mm-hmm I don't
want to give away the fun stuff so let's
see what are the losses here we go well
there is a greater complexity at the
macro level you know make the mistake
and when you have 5,000 little bits of
functionality running around out there
it's a lot harder to reason about for us
typically there are there are mechanisms
put in place for microservices
architecture that do two things one of
two things sometimes both but usually
one of two want us to make it easier for
your micro services to interact and
integrate and the other is to make it
easier for us to reason about them and
keep control over them
a colleague of mine likes to call it the
meat where that's us you know some
sometimes you get dashboards and control
consoles that's for us that's not for
our services they can they communicate
over an API but we have to understand it
so it's a lot more complex typically
with a micro services architecture you
need better architects now here's here's
the key you may have them already they
may be in your organization but they're
operating under the constraints you're
giving them so you may already have what
you need but you don't know that yet
because they're dealing with an entirely
different set of circumstances a single
data repository for the organization
you'll give that up with a pure
microservices architecture most people
freak out on that to start with and I'll
admit I was one of them you know that's
something that you nobody likes to lose
control right and when you start having
to look at oh my gosh you know if all
these various microservices use
different data stores how do you get a
view of your whole organization how do
you get an accurate view of what's going
on it's not so much of a concern and
I'll show you why momentarily change
change is tough organizational change
architectural change it's just not easy
and it sounds trite but that's the
toughest part the people part is the
toughest part and then of course greater
complexity and i know i mentioned that
up higher it bears repeating there's a
lot greater complexity to a micro
services architecture and there's no
such thing as a free lunch you know
there ain't no such thing as a free
lunch and awful there are many are
advantages that it offers but they're
also draw back so just be honest with
yourself about that so is anyone heard
of the play-doh principle okay now I'm
really sad think of think of these the
various cans you've heard of play-doh
right
well I I seriously I've given this in
Europe and different places on your
plate as a big deal and in other places
it's non-existent so it's you know it's
cultural everything else you know
somebody asked me if I've heard of
something and if you know if it's big in
a particular place I haven't been to I
may not have so I all kidding aside you
know Plato's a big deal I like play-doh
I still have a can sitting on my desk
that occasional breakout and it's my
thinking buddy but think of these as
bounded contacts and they're bounded or
separated by different color right so
this think of this is your mana lab now
does anyone here have kids you've given
plate 02 yeah so you give them you give
them all of these colors just beautiful
and in 30 minutes that's what you have
right it's or or better yet this how do
you get that back how do you separate
the red the blue the yellow the green
you don't right I mean it's impossible
the play-doh principle basically states
that it's always easier to combine small
self-contained code or data than it is
to decouple code or to parse data and
you find that to be the case I mean
instinctively we know that when we think
about it it's just a discomforting
feeling when we first start talking
about this stuff so does anybody here I
guess is anybody here still using the
single cross-cutting database underneath
a lot of you are I know you are I mean
even in organizations that are very
forward-thinking we still have some of
those right so what do you do I mean you
typically on your production database
that's cutting across various bits of
functionality that's covering the
monolith so to speak what happens you
you run everything off of it right your
productions run off of it your backups
your reports no no in most cases or not
because you don't want to report to
bring down your production database you
don't want to back up to bring down your
production database so what do you do in
most cases you have some kind of a
backup database of secondary a standby
database is sitting there running at all
times you can offload those very
critical bits of functionality but
they're not critical to production
this is really no different you have a
little bit different way of implementing
it with micro services but you can have
event sourcing that's a it's a very
important topic there's a track one of
my colleagues is going to be speaking
with chris richardson about that at some
point this week i have to check the
schedule but i would encourage you to
take in that session kinney bastani and
chris richardson i think they're going
to be covering that very nicely but at
some at some level and some mechanism
you're going to need to maybe
consolidator or offload some of that I
say offload duplicate some of that data
in another store that's not your
production set of Microsoft's data
stores it's very similar to the pattern
that you're already employing for your
model f so you really don't lose
anything it's just a slightly different
implementation that's why I say it's not
really so much to freak out because you
don't have a single source of truth you
always will have a single source of
truth in some way shape or form so what
do I need to execute how much time do we
have here we have probably enough time
to actually discuss some of the concepts
and maybe show a little bit of code but
again I want to make I would rather be
clearer and cover this much then unclear
and cover this so let's charge forward
and see how far we get and again by all
means ping me a forward and we'll
continue the discussion so a very simple
example remember earlier I mentioned
that in any type of microservices
architecture you'll typically have some
enabling services or enabling constructs
and some of these are enabling for your
microservices some of these are enabling
for us for the meet where so if you have
going back to the netflix example where
you have 5000 instances of various
microservices i guess stepping back just
a moment is anyone heard of the twelve
factor app for the twelve factor
manifesto these are I feel like I'm
throwing out a lot of stuff at you I
have notes you know if you want to
please do you know look up some of these
things if you're not familiar with them
already and if you are please revisit
them typically good architecture
especially when you deploying to cloud
environments as we're all increasingly
doing in some way shape or form or will
be if you're not now
you typically look at certain patterns
that make your life easier that make
your code better so I always kind of
pull out a couple of those is that the
big hitters you want to externalize your
config because if you have your code
littered with configuration that creates
problems in several ways one if a
backing service changes its location
then you have to go in and rebuild your
code that's not fun it's not nimble
that's not agile so you have to rebuild
your code retest redeploy and if you
have an assistant matage that's that's a
horrible thing so you want to
externalize that you also for security
reasons want to do that kind of the
litmus test is if your boss came to you
and said we need to open source our
software today this afternoon the big
boss made the decision that of my hands
just do it could you do that without
exposing credentials could you check all
your coding to get up without exposing
credentials and risking your business
most of the kit and most of the time
that's not the case but if you
externalize that configuration if config
is basically what its key value pairs if
you break it down to the simplest
simplest mechanism you have something
that says go here and that's your
database service you're backing back in
service for your data go here and this
is where to find some other public API
you're going to call some other endpoint
so by external izing all of this you
make your code very tight very very
versatile very portable so you can
deploy that in a different location and
as long as you provide those variables
it doesn't matter it can run on anything
anywhere so by doing that though when
you get into microservices world you
start talking about if you had one
monolith it was pulling a few properties
from your environment that's one thing
that's not that hard but if you had 5000
different instances of micro services
and you're having them go out and you
know forage about for their their
configuration that gets to be a little
harder to manage so we need something
that brings those into a manageable
centralized location without increase it
without inserting a new bottle neck I
always go back to the spring cloud OSS
and Netflix oh
says because hey I work for pivotal and
pivotal has a great relationship with
Netflix but all this stuff they talk
about is open source and there are
multiple other options out there not non
hours so do yourself a favor and please
just look them up and see what works for
you and make sense but with a config
service typically you store your your
configuration settings somewhere and
serve them up to your various instances
of micro services so you can still
manage them and maintain them and
provide them you can also refresh your
various microservices via things like
spring claude boss or some other
mechanism that says hey updated config
go out and get it so you don't have this
giant push again no new bottlenecks
you're inserting typically with the
config service at rests on something
like get or SPN because hey we use that
stuff all the time to handle code well
text which code is text right well so
our properties no big difference so you
have your auditing and your version
controlling and and all that stuff built
in so typically there's some kind of a
config service there's also some kind of
a red service registry I always look at
this like a phone book is anyone you're
familiar with the antique concept of a
phone book yeah I mean anymore we just
grab our phone and say call Bob but in
the old days when you go to a new city
you'd find the silver box in the corner
point and hopefully you'd pop open the
hopefully there'll be a book attached to
the chain sometimes that was just a
chain dangling there but you know
hopefully there's a book there and it
has the pages and you can find Bob and
then you look up Bob's then we're
calling your microservices need
something similar they need a service
registry a place to see and be seen
that's really critical in the ephemeral
world of micro services because if i
have a instance of a service running
here and it dies or the network
connectivity is lost your platform
typically is responsible for maintaining
a fixed number of those based on demand
based on numbers whatever so if this one
dies it may spin up another instance
over here how is that instance found by
consuming microservices well that's why
you need a service registry so that
needs to be implemented in some way I
actually throw in a couple things here
very simply which is a quote service of
backing service this is a database
enabled
service that allows me again I'm a movie
movie and TV fan so I score movie and TV
quotes and pull those up and provide
those as a backing service to an edge
service which then can be accessed via
mobile phones or whatever and then of
course mentioning the circuit breaker
pattern earlier history is Netflix OSS
is entry into that environment for
circuit breakers and that allows me or
my edge service to continue functioning
and provide again default values or some
other value if the backing service is
offline history in particular is really
nice because it lets you stack several
or chain several different fallbacks so
you you know it's Turtles all the way
down until you get to where you just go
I give up here's some you know here's a
nifty set or whatever you want to do but
it gives you options to fall back really
quick overview of those your config
service again you basically you have a
repository you can push updates you can
notify your various instances they'll go
out and pull refresh config holding that
up just a minute here and then for
service discovery you have things like
Netflix Eureka Eureka is actually good
for a lot of other things as well
Netflix uses extensively but I typically
in my examples use it just for the
service registry and discovery
capability but each each different
producer registers with the registry all
that information by the way and this is
kind of critical when you're talking
about the micro services you again no
new bottlenecks right so if that goes
offline you want all of your consuming
micra services to have cashed that
information I mean typically you still
you know implement it in a high
availability type of situation where you
don't just have a single service
registry running instance of it running
but let's say everything just you know
falls on the floor your other micro
services should still have that
information cash and be able to reach
out to their backing services and then
when at some point when your service
registry comes back online they
reestablishing refresh same with the
config server with a client side load
balancer and it's client side again
client-side meaning your client you're
consuming microservices there's a load
balancing that goes on you don't insert
a new bottleneck for your backing
services because typically with your
load balancers on the backend that if
something goes down behind them they not
may not necessarily know they're just
funneling traffic if that goes down you
can't get to your services behind there
whereas the client side load balancing
it balancer again you have that cached
so if it's very much more survivable and
with the intelligent router sometimes
you hear have people ask how do I get
away from my model if i'm looking to
migrate from that you may have heard of
the strangling the monomyth expression
with intelligent routing you can define
routes outside of your software outside
of your mana left outside of your micro
services that are then employed to to
route traffic to route calls still to
your mobile death but over time is as
you build out your micro services
portfolio to rear out those with that
evidence to code a quick look at the
circuit breaker again typically with
your circuit breaker you have an open or
closed status but you also have a
half-open status so it doesn't
immediately slam it with traffic when
it's coming back online it gives it time
to heal properly so that it doesn't get
into the whipsaw effective of a mod 11
and then there's typically some kind of
a circuit breaker dashboard so that you
can see what's going on with your
various edge services you're backing
services this is for us this has nothing
to do for our microservices this is just
for us to see and understand what's
going on behind the scenes so we can see
when something's down we can see when
it's coming back online so I actually
don't have I just have a couple of
minutes so I don't really have any time
to launch into code so what I'll
probably do is just kind of wrap up here
and then field a couple questions and
then we can take it offline yelping the
f-word this is Adrian cocroft he just
spoke a couple months ago in vegas at
our conference come and he made the
comment i thought
is really good because I said this but
of course it means a lot more from him
monolithic apps only look simple from
the outside and anybody who's worked on
them those that's the case it's very
simple to reason about when it's one big
thing it's just when you get in and try
to appear under the covers that it
scares you micra services in for
separation that makes them less
complicated and and again the argument
is you can make a very structured model
f to where it's not as complement it
complicated but it never never stays
that way I mean even in the best of
hands it just can't it's a world we're
living so with that i guess i will stop
talking and I'll throw this out there
these are just some points typically the
examples that I go through and again
later this week I have another session
where I actually do pretty much full
live coding and I use a lot of these
things my repos down at the bottom I do
have slides and materials and stuff out
there as well but mkay hack on twitter
that's the best way to reach me if you
have any questions comments if i glossed
over something too quickly that you
wanted to hear more about again happy to
discuss it at length so any questions
yes that the question was how about the
added latency that can be an issue you
know all kidding aside that can be an
issue typically and you have certain
things that are being different
architectural styles that are being
implemented or different solutions that
are coming to bear on that now what I
always kind of go back to is in most
cases your simple HTTP rest is not a
problem in most cases we always worry
about that because of course we're
always your retrained and we were
experienced in in trying to expect the
worst but in most cases it's not a
problem now how do you know if it is and
that's where you get tools like Zipkin
where you can do networked racing across
your various microservices which also
makes you ask ok or somebody will last
well then that adds some some overhead
well that's why you have to have a good
set of tools that add minimal overhead
while giving you as much information as
possible similar to the
buying tools that are built in and baked
into the JVM so with with Zipkin or
things like it you can you can trace you
create a trade or follow a trace
throughout communication across various
microservices in your system and then
you can have spans within that so you
can establish your baseline to see okay
is 2 milliseconds okay for this or is
that large is 200 milliseconds okay for
this or isn't large and an established
allows you to establish a baseline so
that you can determine what the problem
is in a lot of cases and we've all seen
this too it's not so much a problem of
you you create new problems but you are
able to find them that you couldn't have
found as easily before so even though
you're talking semadar process
communication you can also maybe
establish some networking issues that
you realize we're there sometimes
ironically so yes
aha glad you asked that the question was
how do you handle transactions there are
ways you can do like distributed
transactions but typically what you
learn to embrace is your eventual
consistency and and I that always makes
people a little uncomfortable it made me
uncomfortable I always used to kind of
have the saying eventual consistency
means inconsistency and that is true at
its very highest level but I always kind
of go back to the model for banks and
atms and a lot of banks use eventual
consistency they use they don't use
distributed transactions and that's
because the cost is so high for the risk
involved if you have an ATM and your
wife has an ATM and the odds of you
withdrawing a thousand dollars cash on
opposite sides of town at the same exact
instance instant are pretty pretty slim
or within a few seconds again really
slim so what typically happens is they
accept a certain degree of eventual
consistency knowing that the odds of
that being gained being played are
pretty low but it allows you also to be
very agile in terms of responsiveness
very responsive in your system so you
don't have to wait for our transaction
to go through all of the various hoops
before you issue the cash and there are
many other transactions where that's
just a killer you can't wait for several
seconds or minutes for a transaction to
complete even if you could you know
extend the time outset practically you
you'd never your customers would never
tolerate it so again it's kind of a
different way of looking at it you can
with microservices do distributed
transactions it's just really typically
not recommended you do because you get
into the thing of if this fails this
fails and you're how do you get that
back because they're operating
independently of each other not just
down a chain but independently entirely
so different different can of worms but
very achievable if you change the way
your architecting your system so
yes I'll take one more really quickly to
paginate oh wow sorry typically what
you'd have to do is is in a case like
that you know where I mentioned you'd
have a some kind of a collector where
you create an external score that
aggregates that data in some meaningful
way you typically wouldn't go out and
hit your various production
microservices and somewhat yourself you
could but in many cases you're also
creating that secondary data store
anyway so I I would point you to that as
your source of truth for reporting and
things like that that would give you
that completely avoids having to go out
and ping everyone individually it's the
work is already done for you so all
right everybody again please follow me
on Twitter email me whatever it's all
good happy to talk about this at length
but thank you for attending</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>