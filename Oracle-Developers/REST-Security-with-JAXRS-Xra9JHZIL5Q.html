<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>REST Security with JAX-RS | Coder Coacher - Coaching Coders</title><meta content="REST Security with JAX-RS - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>REST Security with JAX-RS</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Xra9JHZIL5Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right I don't know about you guys
but this is my third straight year
speaking at JavaOne and this is probably
the most excited I've been to be at
JavaOne because this is the first year
that there's a dedicated security track
how awesome is that yeah all right yeah
and that's a first I have not seen that
at any developer conference especially
any developer conference this size so
from from my point of view it's really
exciting being in the security industry
trying to work with development teams to
improve the security of your
applications and we are here to talk
about rest security now real quickly
about me my name is Frank Kim I'm here
with the SANS Institute
I'm via the lead for the application
software security curriculum and I'm
also the author of the probably the most
important course in that curriculum the
secure coding in Java course now we're
going to talk about three things that
are really important for the security of
your restful services today one is
authentication two is encryption and
number three is validation and finally
we're gonna have a quick little wrap-up
towards the end sound good guys
all right so let's go ahead and get
started real quick review authentication
as you know of course is the process of
verifying an identity there are three
factors upon which authentication can be
based something that you know right this
is typically what we use for the most of
the applications that we use today which
is what a user ID and password and
probably the worst form of
authentication based on something that
you know right user ID and password that
I've ever seen the worst example of
authentication based on that that I've
ever seen is the online dating site
speed-date now don't tell my wife I told
you guys about this site but for a very
brief period of time right the online
dating site speed-date had this
authentication bypass vulnerability
where an any user an attacker could
enter any user ID any valid user ID on
the system and any corresponding
password any blank password any fake
password and would automatically allow
that person to log in right really bad
because then they can log in as me and
set up some fake dates view my dating
profile see all my sensitive messages
and so on all right so that's
authentication based on something that
you know authentication based on
something that you
have of course is probably a lot of in
your corporate environments your VPN
token your security token that you use
to authenticate to the to the corporate
network might be your badge it might be
a smart card that you use to get into a
session and so on
and finally the third factor upon which
authentic in can authentication can be
based something that you are now this is
typically stuff that we see in Hollywood
movies right facial recognition iris
scan fingerprint sensors now with the
new iPhone 5s it's possible that the
biometrics might be making its way more
to the mainstream now now how many uh
security folks do we have in the room
here quick show of hands
oh all right good number of security
folks how many have been to the blackhat
security conference before just a few
people the blackhat security conference
the the main one held in Las Vegas every
year typically at Caesar's Palace and
it's a pretty big event and as you come
in as you probably know Caesars Palace
when well Caesars Palace and in Vegas
and I was going there with my buddy a
few years back right we're going to
blackhat we're staying for the whole
week it's kind of a long time to be in
Vegas but his wife specifically said you
know what after the conference I'll come
meet you out in Vegas and we can hang
out for that last weekend right we could
go we'll see some shows and have some
fun go eat some dinner and he said okay
that sounds good so he booked the the
hotel room and hotel rooms in Vegas can
be kind of expensive especially over the
weekend Caesar's Palace is sometimes
seven eight hundred bucks a night if
it's a popular weekend it's kind of
ridiculous in my opinion but if you go
with the conference right you get the
relatively low rate of two hundred bucks
a night so my buddy he booked this room
for the extra weekend at the conference
rate of two hundred bucks a night
because his wife said she want to come
out about a week later his wife said
well you know something happened I
changed my mind I'm not gonna I don't
want to go to Vegas anymore so he said
okay and he calls up the hotel and he
cancels the reservation for that last
weekend about a week later can you guys
guess what happened yeah her wife his
wife changed her mind and said you know
what I do want to go to Vegas
right so he said okay no problem so he
calls back the hotel and he says hey I
need to I need to confirm my reservation
for this last weekend and she he said
the person on the other end the CSR says
okay well that'll be 800 bucks a night
he said no no no it's I need the
conference rate of $200 a night and he
tries to pretend oh no I never canceled
the reservation you guys messed this up
and the CSR he says on the other line
says okay hold on a minute sir and he
puts him on hold and he hears a little
click and when the voice comes back he's
all of a sudden he hears his voice
playing back to him saying cancel the
reservation right so that's
authentication based on something that
you are in that particular case your
voice right voice recognition and a lot
of companies are doing this in their
call centers to authenticate their
customers now that's a quick recap
refresher about authentication right now
what about authentication in our Java EE
applications well as you guys know all
Java EE app servers containers support
Java EE role based access control right
role based access control meaning if
you've got a manager role or a user role
you can define those as having access to
certain things and the way that you
define those is in a file like this in
your web.xml file right quick refresher
and I'll zoom in a little bit here for
the folks in the back you basically say
hey what what part of the app do you
want to protect in this case slash star
and what type of authentication do you
want to use in this particular case
we're saying we want to use our standard
form based authentication here and if
you do go ahead and define Java EE based
authentication well you set up web XML
like this and if you're using jax-rs
right jax-rs has this class this
security context class if you look at
the Java doc for this class it's
relatively simple we see three of the
methods listed on here if you've got
your web XML your app server set up to
do the authentication we were just
talking about you can call get
authentication scheme to return the type
of authentication that you may have been
using whether that be basic HTTP basic
form or client cert you can also call
get user principle which returns the
principle object
means the user ID of the person that's
already signed in and finally the is
user enroll method that returns true or
false right depending on whether or not
you have that manager or user role or
what-have-you
now if you've got all of this set up
your application might perform something
like this very little short demo that
I'm going to show to you
all right in this short little demo is
just a very basic photo sharing app it's
actually the sample application that
comes with spring security for OAuth and
this is really just to get a little bit
familiar with this app because we're
going to be using it showing it in a a
future demo integrated with some other
stuff as well so I'm going to switch
over to the VM that I have running over
here now this is a Linux based VM and
you can see that I've just got a very
simple ugly web page from the 1999 late
1990s and it's all of the links that
we're going to be using to access the
different demos little demos that we
have throughout this session now the
first one the first link at the top is
the link to the photo sharing site and
you can see it kicks me over to the
sign-on screen now this is kind of like
a Flickr right a fake Flickr this called
sparkler that we use to share photos but
you can see here that the user ID and
the password are already pre-populated
and this is on purpose right of course
you never want to show the password
itself like this but this is for demo
purposes so you see that the Marisa ID
is actually logging on with this
particular password and we want to point
that out because there's going to be
another application where Marissa is
going to be logging in with a different
password so once I go ahead and click
login right I said this is a very quick
basic demo you can see I've got some
pictures of my kids 6 years old and 2
years old down at the bottom right here
and that's really all that it is if
you've got write Java EE authentication
set up your app might perform something
like this where you've got your basic
write form based login to enter your
credentials now quick show of hands who
uses Java EE based off in their
applications
alright good maybe 10 percent or so all
right all right so if I switch back to
the slides that's all well and good
right if we've got user ID password
authentication
but under the covers right there's
actually some communication like this
going on right we've got this little bit
of JSON and you can see that go if you
go to this URL it's going to go ahead
and send back this particular bit of
data JSON formatted data now if you've
got this photo sharing site API and you
log into the app under the covers if it
does this communication that's fine
that's good
you're still authenticated as the user
themselves but what if you have a
different site another web application
that wants to consume this API as well
right well we've got some problems right
if you've got user ID and password
authentication protecting that service
well then that's fine if that API is
only used by your site but if your API
needs to be consumed by other web apps
right other mobile applications maybe
even a native app well to give access to
this API what do you normally have to do
you'd have to give that other app your
user ID and password so we can
authenticate as you to get access to
that service and in that case these
other types of applications goodwood
could potentially have full access to
your account you don't really want to do
that right no yeah you don't really want
to do that so that's actually where oo
auth comes into play anybody used OAuth
Wow that's alright a lot of people there
maybe half maybe 40% of the folks have
used OAuth and oh uh for those of you
who haven't used it it is a essentially
a way to authenticate a service and one
of the original authors of the spec
Aaron Hammer Lahav who have had some
well publicized a well-publicized
separation with the OAuth specification
itself he coined the valet key metaphor
to describe a lot and I don't really
have a nice car but so I've never had an
actual valet key but there's this
concept of if you got a nice car you and
you want to park it somewhere and you
leave it with the valet you leave it
with the attendant well you don't want
to give him the key that would could
potentially open the trunk where you've
got your computer stored in the back so
you want to give them a valet key
instead that only gives them access to
turn on the car and not actually to the
trunk itself and this is the same
concept that we have with
where you can specifically define the
authorization or which rights are
granted and you can also revoke those
rights at any time and if you need to
write you can nicely gracefully upgrade
change those rights as well now we've
got here is a very simplified flow for
how ooo arcs there are three three main
parties in relation to OAuth right
you've got the user the person that
actually wants to use the application
itself right the spec so the spec calls
this the resource owner you've got the
client right the client is the other web
application the other service right that
wants to use the stuff on the server in
this case the server also known as the
resource server is what the
photo-sharing site that we just saw the
photo-sharing site called sparkler so I
make sense everybody alright so the
client in this particular case right the
other app that wants to use the photos
is going to be another website called
toner alright that's a photo printing
site now what happens is you as the user
would first log into toner the site
where you want to print the photos right
then in that particular case once you've
logged in in step number two toner would
actually redirect you to sparklers login
page where you would log in to sparkler
directly and you might have seen this
workflow with Twitter as well Twitter
uses this for some of the other
third-party apps that you need to
authorize and once you do login to
sparkler directly in step number three
right then sparkler then returns under
the covers and Roth access token that
oweth access token is stored on the
client side the other web application
and then then you as the user are
actually just happy using the different
web based services that you want to use
make sense all right so let's see a
quick quick demo of this so if I go
ahead and log out of sparkler here go
back to my home page and go to my photo
printing site
which is the second link from the top
you see we get to an entirely different
application and the URL at the top all
right it's a totally entirely different
domain toner com if I go ahead and login
you can see right here we're again
logging in as the Marisa user right but
just for demonstration purposes the
password is entirely different
highlighting the fact that these are
different accounts so if I go ahead and
login and then I click this link to say
hey well I want to print some photos but
to print some photos I actually need to
go ahead and view the photos from
sparkler itself and now you can see
toner knows that it's not authorized to
access my photos so it kicks me over to
the sparkler right a different domain
here at the top the sparkler login with
the separate password so once I click
login now this is where it gets a little
different you can see that now o auth is
saying well you need to authorize this
third-party site toner to access my
pictures so if I go ahead and click
excuse me authorize now in toner itself
as you can see from the URL at the top I
have access to the exact same photos
that we saw before so if I go back to
the slides how does this actually work
all right under the covers via the
browser write toner we'll start that a
lot process once you click the authorize
button once you click authorize it sends
a request like this specifically to the
OAuth / authorize URI and then here
there's a couple important parameters to
keep in mind there's this response type
the code response type and we'll see how
that comes into play in a future slide
and you can see down in the lower
left-hand corner there's also the scope
and the scope is really important
because it's saying what's what access
do we want to give toner in this
particular case we're giving it read and
write access now once that request is
sent then the sparkler then will
redirect back to toner with that code
that we had just referenced on the
previous slide right newly generated
code
and here is where toner then sends to
sends this bot request to sparkler now
there's a bunch of stuff here let's take
a look at these one at a time the first
thing in the request from toner to
sparkler is this basic authorization
header and if you guys know HTTP basic
authentication it basically passes in
this base64 encoded string base64
encoding originally developed for SMTP
to send binary data over ASCII
characters you can see this base64
encoded credentials which are the client
credentials that sparkler has given to
toner to authenticate from the client to
the server under the covers right
between the two web applications
if you decode this it's going to be the
user ID colon password rad toner and
secret in this particular case so once
you've once the client toner has
authenticated to sparkler it
specifically says hey I want to use this
authorization code grant type we're
going to see these grant types more in
an upcoming slide the code is passed
back that it originally retrieved and if
everything goes according to plan
sparkler returns back an OAuth bearer
token this access token down here at the
bottom and you can see it's a really
long string that replica Lee represents
the the set the ID that toner will
always use to authenticate back to
sparkler itself and you can see down at
the very bottom again we've got the
scope readwrite it might be hard to see
in the very back here with these long
rooms and we've got this expires in
which is defined in seconds right and
now any time you want to print some
photos all you have to do to access them
is include in this request the
authorization header right with the
bearer token that was retrieved with
this with this extremely long value make
sense all right awesome so when do you
want to use a lot as we said right
ideally you want to use OAuth when
you're consuming these api's from other
third party web apps from mobile
applications from other native
applications
you could use OAuth right for all of
your internal right internal
communication service communications as
well but in certain cases it might be
overkill right if your API is only
consumed within the app itself by that
one user it's only accessible to that
user you could just use Java EE based
authentication for that and if the api's
are only consumed server to server right
you could use OAuth again for that but
you don't have to write the real benefit
of this is that you're not sharing
passwords between your applications the
passwords aren't shared stored on the
mobile device itself right and because
of those two restrictions in the top two
bullets it limits the impact of
different security incidents right what
if and we hear about companies getting
hacked all the time what if or you
people losing their devices right what
if you lose your mobile device and like
most users do they don't have a password
well if you lose your mobile device your
password to sparkler is not stored on
there only the o'a access token is so in
that case all you have to do is revoke
the access that you gave to sparkler
instead of going and changing all of
your passwords if toner gets hacked
right and all of their data is stolen
well all you have to do all sparkler has
to do is revoke the OAuth access for
that particular client and finally if
sparkler itself gets hacked
well you as the user you'd have to
change your sparkler password right and
then ideally you can go ahead and revoke
access to toner as well so that if you
when you recreate that access then you
generate a new bearer token and so it's
called goes back to this valet key
metaphor which is so very important
because you want to restrict where your
user ID and password is actually shared
across different services now o auth has
a number of versions there's version 1
which from the very beginning pretty
much had a known security issue with it
related to session fixation so
definitely don't use OAuth 1 there's one
a which has been in use for a long time
widely used and supported and there's -
2 O which is the the newest spec any of
that spec is now final with pretty good
support quick show of hands who uses
OAuth 2 alright it's a pretty good
turnout who use this one a or some
custom-built derivation
all right good a lot more moths to users
interesting cool now we mentioned the
grant types different types of 2.0 on on
the other slide in passing here now
these names in the grants type column on
the Left I find the names myself to be a
little bit confusing so I just kind of
number them and refer to them as one
through four
but the authorization code grant type is
the one that we just looked at web app -
web app and the key in this particular
case is that the user write the user
never sees the access token that bearer
token that long string that we generated
the user will never see that that stays
hidden between the two apps themselves
all right so that is the authorization
code grant type if for some reason you
have a situation like maybe an Ajax site
or a JavaScript heavy site where the
where you don't want to where you want
to where you want to share the access
token right if you want to communicate
directly from the browser to the server
well in that particular case you don't
use that authorization code that we saw
in the URL in a previous example from
the server right instead now in this
particular number two grant type the
browser the user will actually be able
to see that bearer token and so you have
to keep that in mind in terms of where
things are potentially exposed the third
grant type is basically when now all of
this the example that we saw the main
point was that you weren't sharing your
own user ID and password right exposing
that to the client toner photo printing
site service in number three right this
is why it's called resource owner
password credentials in this case your
your user credentials would be exposed
to the client itself if you decide to
use this grant type and finally this is
more for server server communication
perhaps called client credentials if you
the client the photo printing site want
to talk directly to the photo sharing
site directly right you can just pass in
that base64 encoded credential that we
saw and if you do any of these
authorization methods
what winds up happening is you get a
different access token the most commonly
used one that I recommend to use is the
bearer token that we just looked at this
large random number right you of course
like other things in your app need SSL
to protect it in transit because if
somebody steals it they'll be able to
replay that bearer token and get access
just like you did
there's alternatively a mac-based bear
to back a bear access token and that one
you don't have to use SSL because the
way that it's calculated and transmitted
it's actually it's secure withone a only
supported this Mac based access token
there are some other tokens that the
specs are being developed that are still
being worked on there's the JWT JSON web
token if anybody use that right there's
some ways to do sam'l integration as
well if you're in a large enterprise but
that was Oh wha any questions comments
on oh uh yes that's true the question
for everybody is if this if the access
token the bearer token has a short
expiration time maybe set it to
something really small why would the
server the backend application need to
store that securely why would it need to
store it at all yeah and it's true it's
it depends how long that access token is
for it's just if it's just for one-time
use then yeah you probably wouldn't need
to store it but if it's for a day then
you probably do need to store it in case
they need to reoffend ik 8 yeah alright
so that was nothing oh yes question hand
in the back I think I heard the question
is don't tokens implicitly in don't
tokens imply state said right yeah so
tokens it depends how you implement it
and that's one of the big benefits of
both is you don't necessarily have to
depends how you store it under the
covers right if all you're doing is
getting a request in and checking the
actual
value of the the bearer token in this
particular case yeah all you're doing is
that authentication authorization check
alright so that was authentication let's
move on and talk a little bit about
encryption now this is related to a
session hijacking
all right let's pretend here that you
are the user in the upper left-hand
corner and you're on some public
wireless network maybe your coffee shop
maybe here at JavaOne and unbeknownst to
you some evil hacker some attacker as
represented by the little red monitor
with the black hat on it is on that same
wireless network now you don't know that
but you decide that you want to go do
some online banking and my bank comm in
the upper right hand corner well you're
going to my bank comm all the attacker
has to do is sniff the traffic on that
public wireless network and potentially
get access to some sensitive data maybe
you're a bearer token if it's not over
SSL maybe your j session ID and by
capturing that j session ID the attacker
then can conduct a session hijacking
attack by replaying that session ID back
to the server and authenticating as you
right here in step number three so how
do you prevent this from occurring well
it's very simple all you want to do is
make sure that you've got SSL enabled in
web.xml if you've got your server
configured to use SSL all you have to do
is enable this user data transport
transport guarantee confidential to
ensure that any time you access the user
accesses a non SSL version of the site
it will automatically redirect the user
to an SSL version right how many you
have this configured in web.xml
alright good excellent
and in jax-rs again the last method on
that security context class is that is
secure method that if you do have SSL
enabled the request came in through SSL
this of course will return true now we
talked a little bit about the J session
ID and it used to be that in older
versions of the servlet specification
that there was no way to set this J
session ID to be to be secure now when
you set the secure flag
on any cookie the secure flag ensures
that that cookie can only ever be
transmitted from the browser up to the
server over SSL and this helps mitigate
the impact of potential session
hijacking risks right and in servlet 3.0
all you have to do is configure your
session ID right in web.xml like this
and it will ensure that that secure flag
is set alternatively for other cookies
down here at the bottom right you can
set it using the dot set secure method
now we've got a problem though even if
you've got SSL configured right there's
this issue right at some point in time
we mentioned I mentioned that it will
redirect the user from HTTP to HTTPS so
during that brief window of time what an
attacker can do is intercept that non
SSL communication and mess with the
response alternatively anybody heard of
the tool called SSL strip written by
Moxie Marlinspike I see a few heads
nodding
yeah SSL strip will actually seamlessly
invisibly under the covers downgrade
your connection from SSL to non SSL
thereby allowing the attacker to see all
of the traffic because a lot of the
websites that I've worked on I don't
know about you guys but anytime you get
redirected to SSL the site still allows
you to access the non SSL version right
and if you've got your site configured
like that SSL strip as I said can just
seamlessly downgrade your connection to
non SSL so to help mitigate that risk
right this is where this HTTP header
called strict Transport Security comes
into play who's heard of strict
Transport Security maybe five people all
right now strict Transport Security
basically says the first time you visit
a website and that website has the
strict Transport Security header sent
down to the browser it will go ahead and
store your certificate info on the
browser itself any other time after that
that you access that same origin that
same domain
it will automatically switch your HTTP
requests to HTTPS even if you type into
the URL bar HTTP it's actually going to
be encrypted in transit make sense all
right it's supported in Firefox and
Chrome defined in the RFC mentioned here
and you can see down at the very bottom
again these slides are going to be
online this might be hard to see in the
back all you have to do is pass in this
strict Transport Security HTTP header
with the max age defined in seconds and
for the browsers that support it in this
case Firefox and Chrome it will
automatically implement that protection
for you pretty cool right yes the
question is does that work when you have
inline SSL accelerators and the there
have been issues with this where there's
a there's large sites where if you've
got a farm of servers responding to
requests and some of those web servers
at the front end basically will have
different SSL certs and so then the
browser in that case sees a different
SSL cert if they get switched to one of
the different servers that's processing
that request right but the short answer
is yes it will work with SSL
accelerators - all right so that is
encryption any other questions yes
I think I heard the comment is that a
lot of people implement this using
Apache rewrite rules and is that not
complementary to this technique yes that
so the example that we saw in the
web.xml configuration that automatically
redirects the user from HTTP to HTTPS
yeah that's basically exactly the same
thing as doing that and so if you know
that the requests can only come in
through that particular web server not
to the app server yes it's that's why
I'm doing this they're doing the same
thing but strict Transport Security in
particular is a an extra added
protection on top of that rewrite rule
all right so then let's go ahead and
move on to validation now we all know
about input validation where we need to
do white listing potentially black
listing from a security perspective we
always want to prefer white lists over
black lists I'm not going to talk too
much about that basic validation because
I think that stuff is well understood
but just real quick related to our rest
services we want to make sure that we
use as well as we can the appropriate
annotations in this case to make sure
that we restrict the requests to post
right so that other other HTTP request
types are not accepted we also want to
use the app consumes annotation to
specifically restrict the content type
to consume well I'm assuming that we're
consuming JSON so consume JSON data that
comes into the application itself if you
try to pass in something else by mucking
with the request or passing some other
data it will actually return F HTTP 415
error code saying that the media type is
unsupported third bullet from the top
the third major bullet ideally you want
to restrict your calls to ajax if
applicable right if you know your your
call service calls are done via Ajax you
can pass in check the X requested with
HTTP header specifically making sure
that the requests came from the
xmlhttprequest object and on the
flipside on the response side you can
also check the accept header at the
accept header / the HTTP specification
is something sent from the browser to
the server that says hey
is what I'm willing to accept and before
you pass some stuff back in the response
you check that make sure that the
clients willing to accept it and only
pass in the appropriate type now what I
want to focus more on instead is not
just validating the data and validating
the types of content here but focus more
on how do we validate that the request
itself is valid now who has heard of
cross-site request forgery CSRF Wow all
right a lot of people maybe 50% of the
folks now CSRF cross-site request
forgery for those of you who haven't
heard about it is actually a
vulnerability that is listed on the
OWASP the open web application security
project top 10 list of highest risk
security issues and CSRF basically
allows me as the attacker to get you to
send a forged request under the covers
to the application and usually that
forged request has some nice benefits
some side effect that is beneficial to
me as the attacker now that's kind of a
mouthful right so let's go ahead and
walk through the standard example here
let's pretend that you're again using my
bank comm you want to do some online
banking in step number one in the upper
right hand corner you login to my bank
comm you transfer some funds you pay
some bills maybe you buy some stocks
whatever it is now you're all done with
your stuff in step number one here in
the upper right hand corner and you
decide that you want to go to a
different site right in step number two
you go to another site well in this
example here on the screen it's called
attacker comm it would really wouldn't
be called attacker comm it would be
called something like I love Java one
comm or something like that something
that you're thinking of you visit that
that site in step number two but
unbeknownst to you this site I love Java
1 comm is actually controlled by an evil
hacker me and I've put some evil drop
CSRF code on this website that you can
see down here in step number 3 now let
me try to zoom in here because you
probably can't see this in the back but
in step number 3 you can see that this
evil CSRF code is release
simple all it is is a little HTML form
right that auto posts you can see using
this JavaScript down at the bottom that
auto posts to my bank comm transfer JSP
and it's passing in a couple parameters
it's saying that the amount that I want
to transfer is a thousand dollars and
the account that I want to transfer to
is the attacker controlled account
number so when you as the victim visit
this site this HTML in step number three
comes down to your browser here in the
middle your browser sees this HTML and
it says well there's just this HTML here
let me go ahead and execute it and then
it will auto submit this form back to my
bank comm and step number four down at
the bottom and my bank comm your you
actually didn't sign off of my bank comm
because a lot of times when we use
websites we forget to sign off and we
just stay signed on to them for a little
while your browser sends this
information up my bank comm will see
this and see that you're still signed on
because your session is still valid and
then it's going to go ahead and transfer
the thousand dollars from your account
to my account and that's CSRF does that
make sense
all right so CSRF how is it related to
OAuth well if you're using CSRF to send
a forged request it turns out that many
sites right allow you to log in from
third-party well ooofff providers like
Facebook right you have a Facebook
account you can link it with another
website and instead of using that
websites login you use the Facebook
login well what an attacker could do is
automatically associate your account
with my evil attacker controlled
Facebook account which would then allow
me write using CSRF to log in to any of
your services does that make sense
all right and turns out Reese
we that all of the sites listed up here
Stack Exchange
whoot IMDB Goodreads Pinterest Groupon
tons of different popular sites all over
the Internet they were all vulnerable to
this wat CSRF issue right and this is
based on some research by a Richland
Bean he actually presented it at
blackhat Europe earlier this year I had
actually built on some prior research by
Stefan's cliff on e all the way back in
2011 and basically rich showed how using
CSRF you can associate write his evil
attacker controlled Facebook account
with any of those sites any of those
services that were previously mentioned
so to do this all you all I as the
attacker have to do in step number one
is create an attacker control Facebook
account step number two get the victim
to sign on to their the target account
that we want to hack in this example
Stack Exchange right then step number
three lure the victim into visiting I
love Java 1.com like in our previous
example that evil site that has that
CSRF code then that CSRF code would
automatically send an OAuth
authorization request and then finally
once that code runs under the covers I
as the attacker using my evil Facebook
account would now have access to your
Stack Exchange account alright this is
just a screenshot from richest research
showing how you can go ahead and get
link it up with your evil attacker
controlled account but does that make
sense all right so before we look at the
details on this slide let's take a step
back and think about CSRF in general now
the way to prevent well before we get
there you guys know when you log into a
web site and you go to the change
password feature what do they always ask
you for in addition to the new password
they ask you for your current password
because your current password and
forcing you to enter your current
password on the change password page
actually has a couple nice benefits from
a security perspective one it prevents a
passer-by attack whereas if I'm logged
into my bank come up here and I leave
the
room to go get some water one of you
evil guys can come up here and go ahead
and try to change my password but if
they didn't ask but since they asked for
my current password you can't do that
right so it prevents a passerby attack
but number two it also has a nice side
effect of preventing a CSRF attack
because the current password is
something that I as the attacker don't
know because if I knew your current
password it would be game over I would
just log directly into your account and
do whatever I wanted to do right so the
key to preventing CSRF is to include
something in the request that the
attacker doesn't know all right now how
this relates to OAuth is that well
fortunately per the specification the
specification defines this state
parameter that needs to be passed from
the client to the server and back from
the server to the client to verify right
that this request is valid because the
attacker won't know what this state
parameter is right here right he won't
know what it is to put it on his evil I
love Java 1 comm site because that's
only shared between the client and the
server does that make sense
all right now so let's go ahead and see
this in action here now I'm going to go
ahead and close my browser restart the
server and open up a new browser window
and I'm going to go to again the toner
site here now while this is coming up
there's one other thing I'm going to be
using a tool called perros it's a it's a
simple very simple web application proxy
who's used web app proxies before good
maybe 30 40 % now just real quick
web app proxy if you haven't used one
before you know normally you've got the
browser and you got the server and they
talk to each other the web app proxy
sits right in the middle just kind of
like it another proxy would it's right
in the middle usually running on your
machine and instead of the brown
are talking direct to the server the
browser talks to the proxy right the
proxy then sees all the traffic proxy
forwards on the traffic to the server
all the responses come back to the proxy
so the proxy can see all of the stuff
and then sends it back down to the
browser
all right so here we're using a very
simple proxy called perros freely
available online lots of other great
proxies out there Oh wasp as one called
zap the Zetas attack proxy my personal
favorite proxy is burp suite it's a
funny name but it's the best proxy in my
opinion the reason that I like to use
perros and demos and so on is because
it's very simple there's not that many
features in it so it's kind of easy to
to grasp the concept
so here right we're back in toner I'm
going to go ahead and click login I'm
going to log in to get access to my
photos that I want to print again and
when I click the sparkler link you can
see because I restarted the server it
kicks me to the sign-on again and now it
says authorize but before I click
authorize for our testing purposes I'm
going to go back to Paros here and I'm
gonna go ahead and click the trap tab
because I want to go ahead and trap the
request from the browser to the server
and I want to mess with it I want to
modify it and to do that I need to click
this trap request checkbox down here and
then I'm going to go back to the browser
and I'm going to click authorize now you
can see that the browser doesn't respond
immediately because of the tool perros
is trapping the request now I go to
Paris over here and you can see in the
trap tab it's been populated with the
current request from the browser to the
server I'm going to go ahead and let
this one go through and you can see
another one comes up specifically it's
got this state parameter right here that
we were just talking about on the slide
if I go ahead and change this state
parameter to some other junk value like
the string junk and then I go ahead and
unclick uncheck trap request click
continue and you can see back in the
browser right it didn't authorize my
access to the photos all right if I go
ahead and scroll over to the right it
actually threw in
options saying that hey there was a
possible CSRF attack detected because
the state values didn't match up per the
specification thereby preventing the
CSRF attack from occurring and
preventing it me as the attacker from
sending a forged request make sense all
right all right so if I switch back to
the slides here
well that was CSRF with OAuth any
questions before we move on yes that's
right that is a good that's a good
observation the comment is in Paris
there was two requests right one that I
just click continue through and the
second one that I modify and that's
exactly what's happening here that we
see on the slides is that first the
client the photo printing site sends the
first request with the state value so
then that gets sent up to the server
sparkler comm and then the server side
in the second request sends another
response back another request back to
toner and you can see this is how the
two have to match up so I let the first
one go through to establish that value
then I modified the second one to make
sure that the values wouldn't match yeah
good catch all right so what about CSRF
against other JSON based services right
we conceptually know how this works with
just HTTP with my bank comm we saw how
it could potentially be combined with
CSRF well what about other JSON services
and for that we've got an example from
this project called a wasp one-liner
anybody familiar with one-liner
one-liner is this a deliberately
vulnerable application that's intended
for demos and training created written
by John will ander who is based in
Sweden all right you can see the URL
down here at the bottom and on the next
slide here right we've got a little
quick demo before we get into some of
the details so if I switch back
to the VM here and if I go to one liner
right here it's going to take a moment
to load you can see that it's a very
simple chat application kind of a basic
twitter-like application where you can
send messages to your different
followers that are listed over here on
the right so here I can go ahead and
send a message like I love Java so much
and when I go ahead and click send right
you can see that it posts this message
for all of the other followers to see
now it turns out that this has a vault
and this is vulnerable to CSRF so if I
go ahead and minimize this I'm going to
put a couple browser windows side by
side what I is the attacker can do is I
can trick you into going to an evil
website that has some evil CSRF code to
simulate that happening like I would
send that to you an email send it to you
and I am post it somewhere try to get
you lure you to visit it we're
simulating here that I as the attacker
I'm tricking you into visiting this evil
page with dancing pigs so if I go ahead
and click this link right here you can
see how that's funny I see some dancing
pigs but if you keep your eye on the
left-hand side you can see just by
visiting that page it automatically
posted another message to all of your
followers saying that you don't love
Java you actually hate it right now if I
switch back to the slides let's talk
about how this worked
turns out under the covers the
application itself sends a a JSON
message like this to basically post this
new message
I love Java the valid message to all of
your followers well I is the attacker
instead of posting this valid JSON would
want to do a forged JSON request message
like this using CSRF instead of I love
Java of course it says I hate it and at
the very end you can see that there's
some extra data here right we're going
to take a look at why that is the way
that you get this attack to work here is
on the next slide you can see that in
our my bank comm example right we had
that simple HTML that was Auto executed
by the browser here again we've got some
simple HTML
but we specifically set the encoding
type to text plane we make it invisible
because the attacker doesn't want you to
actually see the form itself then here
in this case we've got the input field
but the input field right instead of
having a valid name for the input field
we've got a bunch of JSON as the name
alright this is a little trick to get by
this this restriction and we pass in we
post the evil message of I hate Java
here in red and we've got the at the
very end we've got two forward slashes
representing the comment because we're
past because since we're passing it as
an input field it's going to append all
right concatenate the value of this
input field which is not valid JSON so
we want to get rid of it so we add in
the comments at the end and that's what
allows us right right here to pass in
right the forge JSON request using this
HTML form because we're basically trying
to craft a valid JSON message given the
constraints of how we need to send it
via the HTML form but we make it valid
by commenting out the stuff at the end
make sense yes the comment is couldn't
we just use Ajax without this hacking
yes you could potentially use Ajax to do
that as well depending on the specific
situation right sometimes you can't run
scripts for targeting another domain
from another domain right whereas you
can send requests like this right so
that of course results in this Forge
message that gets sent up and
successfully posted to all of your
different followers now how do you
prevent this from occurring well there's
this nice project called CSRF guard
written by Eric Sheridan and remember we
said that the way to prevent CSRF is to
include something in the request that
the attacker doesn't know and this
project CSRF guard which is online if
you search for it it basically can
inject this anti CSRF token in two
different ways
number one you can use a JSP tag library
to manually put these form fields these
fields is the
that the attacker doesn't know into your
HTML forms because the key is that you
want to include as a hidden form field
this random value so when the user
clicks submit that hidden form field
gets sent up to the server then on the
server side it compares that value to
the one that it's got saved if they
match right then you let the request go
through if they don't match well maybe
there's a CSRF attack occurring and you
stop the request from being processed so
that might sound like a lot of work
right to use these JSP tags right we'll
look at an alternative approach in a
second and this is just an example of
the CSRF tags that you could potentially
use highlighted in red here right
different convenience tags for your use
but the second way that CSRF guard can
protect your application is by doing
automatic JavaScript Dom manipulation by
including the JavaScript that's listed
in the first bullet here in all of your
pages that need protection basically
this JavaScript does a couple things and
it's pretty cool implementation
it basically hooks the open and send
methods on the XML HTTP request object
as we see here now if i zoom in a little
bit right first it hooks the open method
all the open method does is it stores
the target URL in another member
variable here and then it hooks the send
method down here so that it uses the
target URL and calls a custom on send
method that is defined in the JavaScript
file so that every time an XML HTTP
request is sent this custom on send
method gets called specifically adding
two headers the ex requested with header
saying that hey it's coming from CSRF
guard and the CSRF token header that
includes the long random anti CSRF token
that the attacker doesn't know that will
then prevent you can help mitigate CSRF
from occurring against your application
so it's a pretty cool implementation
because you don't necessarily really
have to do too much other than importing
the JavaScript because once this is sent
up to the server from the
inside the xmlhttprequest call right
there's a corresponding servlet filter
on the backend that sees this and
processes it and checks for its validity
make sense
yes that's that's true the why do you
need the first one why do you need these
two headers well the first one is there
specifically to say hey was it did this
request come from the CSRF guard code
and only if it did right then check for
the value of the CSRF token but yeah all
right so let's go ahead and see this in
action if I switch over to the VM here
and if I go back and again I'm going to
go to the the one-liner
but in this case the secure version of
the application and if I go ahead and
post a message like hi Java 1 all right
you can see that gets posted but then if
I go back to the other page where I'm
luring you the victim to try to access
this CSRF attack website the dancing
pigs occurs and on the left on the right
you see that we get this error message
the response comes back because of the
code the CSF guard code filter that was
processed under the covers it returns
back a response that says hey this
wasn't a valid request I stopped it from
processing and on the left-hand side you
can see that the evil forged method
message didn't actually get posted all
right so if I switch back to the slides
any questions on this before we move on
oh yeah I saw that hand right there
first
the the question is where does the token
come from in this particular case in
this implementation the token is
generated on the server side and because
of that JavaScript that we included that
JavaScript is dynamically generated via
a servlet then that JavaScript knows
where to pull the value of that that
server-side generated token from in this
implementation it's per session you can
also configure it in this in this
project to be to be per request per form
if you want to yes
I think I heard what is I think I heard
two questions what is the current state
of this project and you know given the
time constraint we're gonna have to I'm
gonna have to take other questions after
the session here the current state of
the CSRF project is the code that we're
looking at is version 3 of CSRF guard
there was obviously version 1 and 2 so
this is the latest one it not too long
ago went from alpha or beta status to
the 3.0 status so yeah it could you
definitely investigate using that for
your applications the other comment is
well what about building some of these
protections directly into I think I
heard the specifications into the
frameworks themselves and there are a
lot of other frameworks if you look at
outside of Java Ruby on Rails Django and
so on they have the CSRF protection
built in there are some talk of
including this type of protection
automatically into JSF as you could as
you know that the specification process
takes a long time I'm not quite sure
where that is potentially incorporating
that in the process but I think
longer-term yes that the point is very
accurate is that we need to build these
things into the frameworks themselves
all right so just quick wrap up here
right just we cover three things
authentication number one right make
sure you use user ID password for
services if they're consumed by your app
look at using OAuth for other third
party web apps and mobile apps make sure
you use encryption right using SSL
ideally with the secure flag and the
strict Transport Security header and
finally validation not just basic input
validation but how do you validate your
requests to protect against CSRF itself
now here on the next slide I mentioned
at the beginning that I'm here with the
SANS Institute we've got a number of
things three things on the left on our
website just a quick listing of our
courses on the right hand side we
actually also have a booth in the expo
area if you guys want to stop by via the
booth we're actually giving away some
pretty cool pretty cool I think t-shirts
on the back is the top ten reasons you
should care about secure coding and
there's actually some tongue-in-cheek
kind of semi humorous reasons for that
so I definitely recommend going by and
getting a free t-shirt tell J who's
going to be at the booth that I asked
you to stop by he'll really appreciate
it and and yeah that's it
I my name is uh Frank Kim feel free to
contact me any time and that's all we
have for today
thanks everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>