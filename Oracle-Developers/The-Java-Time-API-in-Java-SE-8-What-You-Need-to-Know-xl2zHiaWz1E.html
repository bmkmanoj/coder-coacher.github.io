<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Java Time API in Java SE 8: What You Need to Know | Coder Coacher - Coaching Coders</title><meta content="The Java Time API in Java SE 8: What You Need to Know - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Java Time API in Java SE 8: What You Need to Know</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xl2zHiaWz1E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Oh Java products group at Oracle and I
help facilitate the work on a time API
getting the JDK so real quick overview
of the agenda we talk about the core API
subset of the API that's used for count
neutral Calvin neutral
calendars and regional calendars the
formatting and localization capabilities
and meta so tips and tricks been
discovered since the API was reduced to
Beckett March so guess our 3:10 started
actually quite a while ago in 2007 Steve
Coburn began the initiative as a
follow-on to his work on Yoda time and
paying the value from that and to bring
it into the JDK we worked through
several revisions through JCP and it's
integrated into the developer releases
in 2013 and was released in this year a
very successful project is migrating an
open-source project through the JSONP
and into JDK so just a real quick
introduction there five five packages
for Java that time that are sort of
functionally defined the core EP is
reflect the ISO calendar which is pretty
much the standard calendar for global
global operations there are types for
time States combinations of local dates
and times and sign zones and then source
of clock information so you can
customize the clocks instant which is
just a point in time with no no notion
of a calendar or months or days but it's
useful for for machine time notations
period zones second package is parsing
and formatting very powerful format or
which we'll get to see a bit later the
Java time chrono package it contains the
general-purpose API for any work of any
chronology or and also the for
additional
regional chronologies that are supported
java time temporal is a package of the
has contains a lot of framework with
youth by to provide interoperation
between the different packages most of
the time developers won't need to deal
with that but it provides the
definitions of units and fields and some
interesting extra features which we'll
talk about later and finally a small
package that provides access to the
times of information this is probably
pretty obvious just looking at the time
that the Java types and then the format
of data that they support it's also very
field oriented your month day hours
minutes seconds nanoseconds and
combinations of those things add in an
offset if you need to deal with
something other than local time local
time is what's here and right now there
is no notion of time zone or it's not a
you can't use it anywhere else but right
here it's own date time information that
adds the symbolic time zones from the
database that does the mappings and
dealing with that that's the closest
analogy to Gregorian calendar in Java
util today then there a couple other
smaller types for just representing a
year or a year in a month which you
might have and for example a credit card
expiration where you really don't need
the day or a month day which can give
you a birthday but not the age of
whoever it is which is sometime sandy
and then instant which is just a
combination of seconds in nanoseconds
since the epoch 1970 Jade every first
quick comparison between the current
Java util calendar types in the new Java
types the current API is isn't very
fluent it's based on mutiny double
instance and so there's a lot of set
operations there's state the changes
which makes it generally if you're going
to pass a calendar to another API
somebody has to do a copy if they're
gonna do any manipulations on it you do
have to worry about whether somebody
else is going to change that the object
it's not thread safe so if you have any
type of concurrency going on you have to
do that yourself
and it's sort of a one type of object
that's supposed to solve all the
problems but they're a bunch of
complexities because of the interactions
in contrast the Java time API was
designed around in immutable instances
so there's no concern about mutating
instances or the type changing its
design of the API has also focuses on
the concrete types more than anything
else so you never have to worry about
the anything anybody sub classing the
type and potentially changing the
behavior or changing the contents if you
pass it to another another library
obviously it's very strongly typed and
the types are designed to be very
specific for the uses that applications
typically have and the first point but
maybe the final point is it's a flawed
API so it's easy to write expressions
that chain together and we'll see that
how that works later the mapping of the
API the current Java util types are on
the right and the corresponding time
types are on the left the interesting
thing to note out to note is that in
when you map to Java Google time sorry
to Java the tough time API you really
have to choose a more specific type that
really fits the applications usage it
isn't just you know pick up the thing
you know something has more
functionality you need that might bring
in extra complexities though as I
mentioned the corresponding type is this
zone date/time is the closest to the
great calendar I guess one other thing
of note here the integrations four days
a week
it's amazing that almost all encounters
have seven-day weeks they've not
consistent about whether they start on
Sunday or Monday so there's some
detailed support for that one five the
month members the months are need so in
many cases you can use the games and
preferable it's an enumeration to use
the names but the they started the month
start at one weeks just a very popular
answer
so the other thing the design of the API
was and many of these things came from
joda-time for good design techniques
there are a lot of methods that are
similar across the different types and
they have a very consistent naming
pattern so a large part of methods
create some take create an object from
the parameters from methods convert one
type of object to another date and date
the date and date now type methods
create a date from some input data
Parshin format are pretty pretty
self-explanatory they convert tune from
strings or from a tooth strength get
ethics get fields out of the object they
don't do any conversions they don't do
there's no real computation they're just
also filled out with methods are an
artifact of the immutable types and
value types where instead of changing
the instance that you have all these
operations produce a new instance so but
that's way you deal with mutable
instances you have to come up with new
so you know if you have a date you might
say you know with a month of January and
it returns a new new local table
together they need to add subtracting in
the fields their methods you know set of
methods that are named appropriately in
there are a lot of those methods but
they're very natural and it makes it
really easy use both looking in the Java
doc or either an IDE to do method
completion because you can start with
the the operation you want to perform
and then the idea will show you what's
left two methods usually convert the
type that you have to some other type
there's usually a suffix on the two
methods and then methods of boot the
type that you have with some extra
information we'll see more detail about
that and then some of the most important
ones in the time is are these before
after equal methods which guarantee to
do comparisons of time on a time scale
which is a little bit different than
Java objects equality comparisons which
we'll get some more detail later so just
a quick sort overview the use of these
methods it just compares to see the Javy
hole usage on the right and the Java
dive time on the left pretty
straightforward I think nobody will
stumble over that similarly with the
setting fields you don't set fields
anymore you in Java dot time you create
a new object with the fields modified
that you need plus and minus the methods
that I mentioned before is an example of
the fluent usage where you can just
chain together the operations and of
course you will notice that this
semicolon is incorrect last minute
editing instead of copy and paste from
the IDE so so that's quick overview of
the core API and I think when you go to
use it you won't really have any
questions you'll just use it and it'll
must be pretty natural next up is the
calendar neutral API subset in the
regional calendars one of the
complexities that's been discovered over
the years and probably many of you have
discovered as well that as long as
you're dealing with sort of a Gregorian
calendar you know there's a lot of
assumptions that you've built in about
the number of months of the year days
and months etcetera when you move to
other calendars there are a lot of those
assumptions which are just not valid and
as a result if you're not really careful
you can build things you know hard code
things into your algorithms which are
not appropriate for different calendars
so a couple of notes here
you know never assume that you know how
many months are in in a year there are
some calendars with 13 months the you
know make sure you use the API to do any
kind of arithmetic you need to do if
you're gonna add days add days if you're
gonna add weeks add weeks
same with months but let the computer do
the work and the calendar avoid making
assumptions about when things roll over
at the end of the month or
things like that another one that's
probably pretty popular is the which day
the week starts on it's pretty common
but it depends on which continent you're
on as to whether it it's the same
assumption and then of course you know
the month numbers some calendars
actually get pretty weird about the
month numbering of the naming so use the
API is to do the mappings in this API in
addition to the sort of the basic date
and time functions there's a chronology
that's added to each of the objects to
support to encode and compute the things
related to a particular calendar system
so here's an example of how to program
around using calendar neutral the
counter neutral package the counter
neutral package deals primarily with
things as fields not so for example you
get you know they get day of month
instead of the get day of month func
method on the other on the ISO API but
it's still pretty direct mapping from as
a field oriented API but the sort of the
important feature is is that you need to
actually look up you know identify the
chronology before you start working with
a calendar if you're going to create one
from scratch there quite a number of
ways to identify the chronology either
by specific names and we'll see a bit
more of that later but the API still has
this fluent form so you can take a date
and set the day of the month to the
first if you want the first day of the
next month you can just set the date of
one and then add one to the month and
you're off and running the there there's
always functions in the API to get the
current date so you don't have to create
a date object and then we initialize it
this also ties into the data of the
topic of clocks which I don't cover too
much here but you can programmatically
you can identify a source of
clocks which is by default is the system
clock but for testing and various kinds
of augmentation you can actually have a
clock that computes its own its own
speed and if you saw Stephen Chin's look
zombie time discussion this morning he
had a very good use for speeding up and
slowing down time so there's a couple of
the other types the chrono local dates
and these names get a little unwieldy
but their expressive is the extension of
a local date with the chronology and
it's it embodies those concepts
similarly look local time is the same
there's time is identical across the
campus across all the count types zone I
here's an example of the zone ID that's
used to create an even longer named
chrono zone date/time which is a local
date time and a local date time and
acronym in a zone anti chronology so
it's sort of all of everything in have
all at once and then but there you can
manipulate these things these types
these values once you have them as you
would anything else with like here
replacing the time in this in this kind
of zone date time with with midnight and
of course to string produces a useful
though not very flexible output there's
a pretty straightforward mapping of the
java calendar fields to the java dot
time fields and the and the units in
java de time there's a separation
between the fields which are
placeholders in one of the types for
value and the units which are like
seconds and minutes and hours
milliseconds but for example one one
important place where the difference
shows up is in the representation of of
fractions of a second which in the api
is always nanoseconds but you may choose
to manipulate it as milliseconds or
nanoseconds and that's why there's a
separate definition between
between distinction between units and
fields so when you're using the regional
calendars there's sort of a variety of
ways to find what calendars are
available in the system there's a
chronology get available chronologies
submits back a list of ecologies and you
can see there that the jk8 supports the
iso calendar by default the islamic
calendar the Buddhist calendar Japanese
calendar and the Minang ago calendar it
is a calendar system is expensive
extensible and but those are the ones
that are built in today you can look up
the chronologies based on their names or
as you do today with the calendars you
can use this BCP locale specified syntax
for identifying a particular calendar
and a particular locale so you can
program it in a nutrient a calendar
neutral way and still have it come out
as a locale specific calendar so for
example if you're using if you need to
write an application in in the in Japan
you'll probably directly use the
Japanese date type because it embodies
the mechanics of Japanese dates and the
errors that come along with the Japanese
calendar and when you combine a Japanese
date with a time you end up with a
chrono local date time as its this is
one place the only place where generics
have used the generic parameterised by
the japanese state and here is an
example of where you took the japanese
local date/time at a particular time
zone and it returns out kana zone
date/time qualified with Japanese date
the use of generics allows you to sort
of have strong typing at the source code
level even when you're using a specific
regional calendar manipulation of the
the all the types is still by the same
set of operations
um here it meets pretty naturally as you
know plus two days using this field
oriented access part of you know an
example of the formatter
here is using creating a formatter on
the fly using this pattern of pattern
letters to create a format selecting a
particular locale and it produces the
appropriate output you could write the
same code pretty much everywhere fully
parameterized by the current locale and
not really have to express if it was a
Japanese date if you wanted to be
completely calendar neutral so there's a
way to write code that really doesn't
know what calendar it is but all the
right things will happen it's only just
a couple of other examples with the
Islamic calendar it can use the same
kind of bcp 47 syntax for selecting the
calendar the manipulations you know
there's a specific type for the date
garage date
there are probably a bunch of
interesting uses the islamic calendar is
a lunar calendar and so they I think
there are places I didn't suggest this
to Steven but if you want to know what
the phase of the moon is you can convert
a date to the Islamic calendar and look
at the number from 1 to 30 to decide
what the phase of the moon is manipulate
that convert it back to a ISO date and
extract the phase of the moon that way
you do have to worry a little bit about
the fact that it's an Islamic calendar
in that it's the beginning of the
calendar is the new moon in Mecca so you
still have to worry about how big around
the world is and how many time zones but
without other specific support for a
lunar calendar that's pretty close and
another example of using the format or
creating a format or with a particular
style and locale to produce the desired
output so a little bit more detail about
formatting and localization support this
the the API uses a concept of a builder
where you assemble it the sequence of
fields and constants within that you
want to be to be parsed or format the
the same formatter is used for both
parsing and formatting so you can create
a formatter what sort of create a format
that you want and then use it for both
parsing and printing obvious pretty
obviously you know literals can be
inserted as tokens within the the output
of the input when you add fields that
corresponding numeric values there's
control over the the width of the field
the sine sine can fall whether there's
leading zeros the textual constants that
come out of the the like the AM and PM
indicators can be localized using the
short narrow full and standalone
definitions that come out of seal they
are there's a whole series of patterns
that are also derived out of the the
locator eye from the locale for date
formats time formats and date and time
formats there's complete control over
fractions usually this shows up when
you're talking about nanoseconds and how
to print fractions of seconds
there's control for field padding both
both with the width and the character
and then there's some specialized
formatting functions for zones and zone
offsets the chronologies and an instant
they're all threadsafe everything well
sorry the Builder is not thread safe the
resulting formatter is thread safe nice
alright so this this builder pattern
enables to assemble something and then
finally created and immutable
its thread safe result so within the the
parsing is also case modes for case
sensitive case insensitive parsing
there's the ability to have optional
fields that
if the parser is running along and
starts that option will feel feel isn't
there it can essentially skip over it
ignore it
there's some interesting details around
resolving partial information that comes
out of a parser but which can get pretty
hairy there's a provision to supply
default values for fields of the field
is not actually present in the input I
don't see an example that later and
there's strict vs. lenient parsing modes
that allow accepting some inputs in
different cases where if you have a user
typing something you want to be a little
bit more lenient about their input and
since formatters are this this sequence
of field interpretations it's possible
to concatenate fragments or formatters
in one formatter into other formatters
and we use partial formats so here's an
example of using a builder to create a
parser with optional minutes and
optional seconds the starts by creating
a new date time format or builder
usually in the API there are factory
methods there are no constructors are
not exposed this is one of the few
places where if you actually are
constructing an object it's pretty much
that clear that you're going to be tight
not not immutable and not concurrent
safe multi-thread favor
so it appends here of our of the day
field that is minimum width of one digit
character maximum width of two
characters and doesn't never has a sign
as sophisticated or several different
patterns for weather signs are present
required or absent so then to give the
to start the optional part of the
parsing of the first piece of optional
start is an optional start token
followed by appending this literal for
the delimiter for the colon delimiter
and then parsing a value for the minute
of our that is always two digits wide to
make the seconds optional also
optional it starts another optional
sequence which then opens the other
literal and offensive value for a second
a minute also with two digits and then
closing out the optional the ending the
bracketed closing out the optionals and
then finally or not finally but the to
defy if those fields are not present
some value is needed to come up with a
valid time so there's a way to default a
minute of a hour and the second of
minute two particular values and I
picked these values a little bit so you
can see the result and then finally you
know it creates a formatter from the
from that builder so then you know
here's some examples of using the
formatter if there's only a single digit
like the digit 9 then the the extra two
fields are are not required to be parsed
but the default values come from this
value set in the parser just having you
know Oh 905 : Oh five still gets parsed
out to the full value similarly the
other ones that's just a flavor of the
things you can do with the with the
parser the optional stuff is primarily
in the parser if you use the same format
or for output you will almost always get
the full full format though certainly if
you have a local date as the sorry a
local time as the argument you'll always
get the floor font full format because
all the fields are there but if for
example if you had a temporal that only
had an hour in a minute then the parser
won't choke on it it'll say oh well that
field is optional and it doesn't exist
in the the date and time that I'm trying
to format so it'll skip it it won't it
won't have heartburn
I mentioned there were quite a number of
pattern letters and sure enough this
actually maybe it's worse than an eye
chart but there's a mapping for for the
formatting letters that are used in Java
format and the formatting letters that
are used in simple date format CLD are
the common language definition reference
has another set of pattern letters that
are that they define sort of
internationally and then there's some
examples of the types of format so
there's pretty complete formatting or
control across all three of the
formatting api's and you won't need to
see this until you really want to do
something tricky so one of the things to
promote the sort of reusability and the
getting developers to come along and use
the due date time api's was is making
java.util formatter which is you know
used by quite a number of applications
to do to do simple formatting of things
those that jovial formatter now accepts
the job the Javadoc time types as input
they don't we didn't augment any of the
formatting capabilities of the formatter
but it can take the job at the time
types as input so for example you can
give past that as own date time and
you'll get the same type of output as
you would have gotten whether you passed
a calendar or a date so you can convert
your application to use the come sort of
algorithmic and computational elements
of Java that time without having to
adopt the new formatter so
one piece to make migration a little bit
easier the formatter comes with quite a
number of predefined formats for many of
them are based off of sort of ISO
variants of time and local time and date
and and instance almost all of the types
have something of the form of a format
method that takes a format or as an
argument so if you know what format you
want and some particular output it's
just it's already there you don't have
to do any any work to get into the
predefined formats it just produces a
string from whatever type you're working
with so I mentioned a couple of these
things already there's several
predefined formats you also can create a
formatter from any pattern of these
pattern letters using primarily the seal
the our pattern letters and solve
document in the formatter so you can
have quite a bit of control over exactly
how you what either output or input for
parsing the the formatter has this
predefined pattern for quarter of year
so if you have either parsing or
printing you can easily get to that
along with the literals and parsing for
week numbers which isn't used much in
the US but in in Europe referring to
weeks by week numbers fairly common a
little bit more about the sort of the
fluency and sort of our strong
recommendation to dump a simple date
format and start using the Java date or
the new formatter because it's
thread-safe
it's better defined and it has all the
same capabilities since and some more
just some examples of mapping what you
would have had to do with simple date
format previously into the corresponding
formatter here it's this of localized
date and time doesn't look up through
the locale information to identify a
format style for dates that's the
sized output and time that's a
medium-sized output and then customize
it to a particular locale at the same
time in Java in Java FX was developing
for se8
as well we were working on job at a time
they got a little bit inspired to to
build a date/time picker on top of the
Java dot time API so they have a thicker
that handles all the chronologies all
the locale information and it's really
kind of cool to see an operation I don't
have a a live demo of that and since
it's just like everything else in the FX
it's customizable and its appearance and
how would some better things so that's
kind of a brief well brief maybe very
brief but broad broad overview of the
API and sort of watching the problems
that people had and the questions they
had it there were a few things that came
up as worthy of mention of things you
could try approaches you can take to
when you're using the API maybe they
should be dealt with in the future
revision of the API to make it to remove
possibility of more mistakes one of the
common pitfalls is that a date and an
instance they just don't have
information about the timezone so if
you're trying to convert it to something
that needs a time zone like zone
date/time you have to explicitly say
what time zone you mean the the notion
of if an instant is independent of the
time zone just does not have a time zone
indicator on it so but it's really easy
to to work around there actually is you
know there's this method that says
instant at zone that takes an instance
and returns it zone date/time in that
particular time zone UTC is a predefined
constant it's pretty common in that case
or you can create a zone date/time
using the of instant method with an
instant in an and the time zone but the
observation was that if you're not
really careful about being specific
about the time zones you'll frequently
get the wrong one
so this API design sort of pushes people
to be very explicit about the time zone
that they're getting and if you don't do
that if you just try to do what seems
like a straightforward operation of of
creating a zone date/time from an
instant there is an exception which
probably could use better exception text
but it will tell you don't do that
and this I guess isn't such a tip
because it has because it just works
which is the Gregorian calendar is a
direct mapping in terms of the
information that has available to to
zone date/time so there are methods on
Zone on time and on Gregorian calendar
to convert back and forth directly
without any loss of information or
having to supply any extra information
another question that came up was how do
you format durations the there's this
robust formatting and parsing package
for all the temporal types that sort of
relate to the time the timeline duration
is one which is just hours minutes
seconds and doesn't it doesn't have a
separate format a package so one
workaround for it is to convert the
duration to hour to a local time and
then use the both the parsing and the
formatting capabilities of of local time
which are very powerful in terms of what
format you want to see in the output
maybe come in handy maybe not as I
mentioned earlier the this is about
parsing of formats if you have to accept
multiple kinds multiple input from users
or in databases you might have to write
some code that we need to read through
the different formats and sort of a make
an attempt to parse each of them and if
it fails try the next one
the optional formatting support
in in the formatter makes it possible to
take the whole subsequence of a cent of
your syntax and make it be an optional
component and the parser will you know
dutifully try each one in turn and if
the format's have enough have sufficient
sort of explicit syntax the hyphens and
the slashes and the potentially colons
it'll only pick out it will correctly
parse the one that you want the one that
really matches the format so here's just
an example of several inputs and they
all produce you know partials pick the
right one and produce the corresponding
output the I mentioned the times on
package earlier I guess very
occasionally you really want to be able
look in the time zone package and figure
out where the transitions occur and what
the mapping is from the symbolic time
zone to the to the offset in particular
case a couple of times a year people
care about is when the transitions occur
for daylight savings time here in the US
the if you pick a start with the current
time then you can get the timezone off
of it from the time zone the zone ID you
can get the rules that apply to that
zone ID and then by converting the time
that you're interested into an instant
the next transition method will look up
in the database what transition occurs
after that instant of time and with the
transition and in hand it's pretty
direct to get the get the duration
whether it's usually almost always an
hour and in the US and it'll also tell
you what the what the time is before the
transition and there's another method
will get you the time after the
transition to the printable time sort of
the in reality there it's they're sort
of almost the same instant but they have
two different notations and it's easy to
check whether the duration is negative
and in this case just print out the
corresponding error messages her
messages
so one of the points that I made earlier
was about comparing date and time values
and how there's there's two two things
to watch out for the job usual sort of
Java object semantics for comparison is
sort of field by field and and this is
what you get with the comparable about
compared to you interface where in most
cases if you have two objects of the
same type it's pretty clear that the
order the fields have some order they
have individual values that are ordered
and you get sort of a natural result the
but in their places where this the
individual fields don't map directly for
example and primarily with zone with
both chronologies and with zones there's
no you can't compare a zone is symbolic
zone idea with a zone offset even though
they may reflect at the same point in
time so doing comparisons in time line
order in the particular cases of either
you know when you have zone day time or
you have different chronologies you
really need to to use the the methods or
the comparators that that convert to
instant because they those operations
normalize the effects of zone IDs and
zone offsets they deal with the
chronologies and mapping from one one
calendar system to another and of course
they're really easy to use they're just
not the same as equals or compared to
and if you ever need if you're using
dates and times within collections and
you need a sorted order to need to be
able to sort them there are explicit
comparator objects that are available
from crinel local date time in front of
zone date/time that when they're those
comparators are invoked to produce the
right you know the right semantics the
right outputs yeah
singing why are there two systems why
not just employment compared to as the
second step well for one it would be if
you look at the the sort of the
mandatory definition of what equals
means in java.lang object it would it
has to be it would break that contract
because zone ID of New York is not the
same as an offset of minus four days
right it would right so I mean it's kind
of a subtle issue and we spent in the
expert group and discussions we spent up
quite a bit of time trying to figure out
how to be consistent with you know the
contract of object for equals in
compared to and yet still providing what
seems many people the natural semantics
of time line order and they really only
comes into play in a couple of places if
you're using multiple chronologies if
you're just dealing with local time you
wouldn't notice you know you can use
equals and compared to naturally and
it's not a problem but yeah and I've got
an example of that here where if you
start out with a time which is a zone
which is in New York and you apply that
zone to the current time but then you
extract the zone offset from that zone
daytime create a new zone daytime from
the offset and the current local late
time the same local daytime if you try
to compare them they will object I
equals say they're not they're not equal
because the zone in the two different
types it actually has a different type
ones the zone offset now there's a zone
ID but if you use time line equal it
normalizes all that and you get the more
intuitive answer
so one of the other more sort of more
powerful capabilities that's added into
the Java time API this was developed
before lamda and maybe that in the
presence of lambda some of this wouldn't
be wouldn't be all that useful but the
idea that you don't know to write a
function that will operate on any date
and time value and you know give you a
new value and so these temporal
adjusters is essentially a an interface
that passes the temporal object is worth
deep in the in the framework but it
allows you to create something like a
predefined function which does the last
day of the month
it'll take any temporal object as input
that has a that has a day of the month
and it will return new object which with
the last day of that month and
internally it goes to the trouble of
getting that field finding out the range
of the field and finding the last value
for that field and then returning an
object with that with the highest
maximum value there are a couple of a
bunch of predefined temporal adjusters
getting the last so this last and month
will find the day of the week the last
day of the week in the in the month of
whatever the input is so some of these
are the computations are all tricky if
you had to do them yourself you can
write your own temporal adjusters we'll
see in a minute but some of these are
pretty handy you can also step backwards
as a previous day of the week and
there's as you can see there's previous
or same and next or same so if you need
to step forward through months or days
or days of the week there's a sort of
canned functions to do that and then
very conveniently there's the there's
day of week in month which identifies
which week of the month and then which
day of that week and is able to compute
the actual day and so figuring out when
Thanksgiving in
is Thanksgiving is here is as easy as ok
with the month of November what is the
fourth Thursday so this is all to
encourage you know both the the form and
the interface is to encou encourage sort
of creating a reusable computation on
dates and times these are all date
oriented you could create similar
functions on times and so I this is a
little bit dense but I wrote a an
example of a a custom date/time adjuster
that would tell you when the next pay
day was assuming you were getting paid
on the 15th or the last day of the month
but not on the weekend and so it goes to
the trouble of figuring out what the
next day is after this day of the
current day of the week how many days
there are till Friday
it always advances by one day but maybe
by two days to skip the weekends and
then it figures out whether it's less
than the 15th of the month and if it's
less than 15 per month then because
latches on the 15th otherwise it figures
out what the last day of the month is
and sets that as the day of the month
the desire to pay the month day of the
month but then it has to go through this
dance again to make sure that that day
doesn't land on a on a weekend so it
backs up again from home Friday anyway
just an example of if you even if you
have a fairly complicated computation
you can build an adjustor as a method
and then with with lambda and method
references you can just reuse it it's
very straightforward so finally just
since joda-time was the a predecessor of
the java time api there are quite a
number of people over times very capable
package that's used as an open source
package by a lot of applications it's
pretty straightforward and mapped from
joda-time to java that time most of the
many of the type names are the same many
of the method names are the same
a few subtleties around the definition
of period and duration and but Java time
actually has because it followed on we
learned a lot from the other time it has
it's more open it's more flexible than
Jota time is in terms of being adaptable
by application developers it includes
adjusters you can define your own fields
and units which I haven't gone into here
but you may have a use for a computing a
a phase of the moon
and it's as an extensible the calendar
systems can be extended in easier than
it it was in joda-time
so there's plenty time for questions but
a real quick summary the new API is
multi thread safe and largely because it
is most of the types are immutable it's
free to use easy to use and fluent
there's strong typing so all of the Java
doc for every types is exactly what it
does and since the types are concrete
and final they you don't have to worry
about it doing anything else we went
through the formatting and the parsing
packages for converting from strings to
to and from the various types of objects
and you can extend the fields and and
units as you needed and add chronologies
if you need another calendar there are
mentioned various interoperation points
with the existing API is both in the in
the Java util formatter and in date and
calendar there's direct support for the
four regional calendars I mentioned and
the core API may be all you ever need
because the it really does cover the iso
calendar that's used globally throughout
the world and we've got time for QA and
here's some extra resources I'll just
mention also that there's a bath this
evening at 9:00 p.m. over in Moscone
that if you have more questions but
yes there's no support in the API for
location there so no right but I think
as soon as you get into GIS you have to
have more complete support for location
and geographies and the different
projections and that's a probably
another whole API
this one's focused just on time yes
domenico information in so the offsets
were correct in the future
it's an automatic for you still we still
have to do something to get know
right so yeah so on I'm not too familiar
without that work with joda-time but in
the JDK both the existing job you know
calendar timezone information and the
times of information that's used by Java
time is the same underlying storage and
database and so it comes with the date
that information comes with the JDK this
updated using the standard of JDK what's
it called this the update our TZ updater
yeah I don't Adam a specific number I
know that it's part of regular JDK
maintenance that we keep the time zone
database pretty up-to-date and it comes
out with the regular updates that come
with a JDK we did actually part of it
this kind of a very useful exercise
working with these two API is in the UK
because we've managed to actually
Sherman managed to make the before mat
to be very compact and be shared between
the two API is that use the same data no
that's another one that I found in the
question archive about Jack be support
there is the checks we have not pursued
getting up Jack's be updated to support
the persistence form of that and ship I
would put them in the list candidate
list for nine
at the moment I have the same answer
which is we haven't pursued that
directly yet know what we did as part of
making the api's fit together these java
sequel date and time types were updated
to be compared to be mapable you still
have to provide that type and we're not
doing any automated type conversion at
those interfaces the application would
need to do that I mean all of these
types are serializable
but the serializable is their own type
not as some abstract time thing on the
wire so yes
business days businesses are a little
tricky because you can't just say it's
the weekends are not business days and
that there are actual or national you
know the national databases so no we
don't you could build in a like if I use
the tool but right we did give some
thought to that but we didn't in you
know embark on solving that problem
because it requires referring to outside
you know another database of what our
business days where and and what
database
you know what authority is there about
yeah and okay so the u.s. is great we're
being forced wrong but they're what
three hundred other countries in the
world right
but similarly you know Howard the
holiday problem is another one since
related to business date one but know a
little bit Java would like to take a
global approach to things and so it was
a big chunk of stuff we didn't bite off
that's all
right libraries that are out there that
that may be converting you know to
generate no I don't we can probably dig
around but I'm I'm not aware of that no
not that I'm aware of but I may just be
I'm probably just out of the loop
right so I haven't I haven't personally
done any performance work we did we did
make sure that it was because are
consistently quicker than java.util
calendar and date mostly because the
computations any single computation is
done is simpler it's not always
recomputing you know which day of the
week it was and everything on the in
this reference of the 3:10 org I think
there is a link to a third-party guy who
had done some comparisons performance
comparisons between joda-time and w
calendar and date and it I think they
generally bear out that these are
java.util timeless is quicker
well if you're using right if you're
using a pattern letters I think
currently it does not catch any of those
so it does create a new formatter every
time but obviously any of the predefined
ones are you're reusing the same
formatting it's probably a good
opportunity for an improvement
no I'm sorry I found that maybe I gave
the wrong impression
the there's only nanoseconds local time
is down to nanoseconds right date and
time have nothing to do with each other
right if you have a local date time you
have a date component you have a time
component oh yes yeah it's a complete
you know it's a pair so they it has
complete functionality they're just
stuck together in the type system and
you know that's one of the things I
think is another transition point was
the sort of the current api's are all
sort of millisecond based drive at a
time is basically it's its core storage
is nanoseconds and a couple of places
the API you'll foot you won't find a
millisecond method because we wanted to
urge people to use nanoseconds all right
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>