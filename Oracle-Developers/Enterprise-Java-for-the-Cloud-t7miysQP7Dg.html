<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Enterprise Java for the Cloud | Coder Coacher - Coaching Coders</title><meta content="Enterprise Java for the Cloud - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Enterprise Java for the Cloud</b></h2><h5 class="post__date">2016-09-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/t7miysQP7Dg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay good afternoon everybody my name is
rajab am from article and with me I have
the urge and Josh and we are going to be
here presenting on enterprise devil for
cloud are what's going to be effectively
a proposal for some of the things that
we want to do in Java EE nine going
forward so there's this safe harbor
statement which is a standard Oracle
safe harbor statement but along with
that I want to say that you know right
now what we are talking about here very
initial thoughts and proposals that we
think we want to take forward as part of
Java e9 it'll go through the regular
Creek community process the Java to the
java ee ee where you know it'll be
vetted to the expert groups and we made
and only when you have consensus in the
expert group it'll be really the
direction that we want to take so these
are preliminary proposals based on
feedback that you've received talking to
partners and customers and also to go to
community members I just wanted to put
that out there before we get started so
that you know we get the right side of
your feedback as you go through the
whole process of taking these proposals
forward here's a quick rundown of the
agenda so we have a lot to cover today
as you can see we're going to start off
with the proposed changes that we want
to make in the programming model and
we'll cover some of the other services
or areas that go along with it for our
using in the cloud such as state
management configuration or external
izing of configuration will touch upon
multi-tenancy and then the security
needs and will touch a little bit about
packaging an orchestration as well of
how you once you've developed your
application how you actually go about
running the application packaging and
you know different and deploying and
running in the application the clean in
the cloud but there is actually a full
talk on that that we have tomorrow Josh
and I out and Joe are going to be
presenting on that tomorrow afternoon so
for those who are interested in that
there's a talk that I have
at the end of the slide deck to show all
the relevant talks so we wanted to start
out by acknowledging that you know we
know that the programming model for how
application is applications are
developed is changing in currently and
these changes are driven by a lot of the
business needs that you have today for
how you how you package how you deploy
the applications and use them in the
cloud what used to be a typical standard
Java EE application package as years and
Wars had all the ejbs and the servlets
and other jars in it you know packaged
with tight dependencies and
configuration all bundled up in the ears
and Wars is so is starting to change and
the reason for some of the changes are
basically you know driven by the new
style of programming so you have the
micro services we have doing programming
that you have these days where the apps
are essentially divided into many many
small services as opposed to being
packaged up all in one war file or one
year file or multiple Wars and ears and
the reason why that's becoming popular
is really because you want to be able to
evolve these applications independently
and quickly and have them back delivered
in independent of heavy of each other
you also we also utilizing a lot of the
distributed computing capabilities of
cloud today so you don't even have
multiple data centers that span
different regions and zones so people
want to utilize that as well and of
course there are many new technologies
that are becoming more and more relevant
in this space whether it's how you
package it in a container the DevOps of
you know not only developing the
application but also how the operations
go on and all such requirements of off
basically the application development
cycle this also has introduced what's
commonly referred to as the twelve
factors I'm not going to go into details
of each of the twelve factors you can
find this online but how you actually
develop and and make these services
available and run on in the cloud is
basically changing how you do all your
development as well
so in short basically the cloud is
becoming the platform here for
development right you write your
application basically and the
application the way you write it today
is that it consumes services that are
part of the cloud infrastructure the the
services could be standard services or
the services that the cloud provider
provides for people to use you may have
things like caching messaging log
logging how the analysis of the log
files are done all of those I
externalized services and application
development can you essentially use all
these services in application developers
can use these services as part of their
application this also poses another
problem though or at least create some
amount of confusion there are way too
many choices for all the frameworks and
other things that you want to use to do
your application development so there's
no real standard while there are a lot
of frameworks that exist that are very
good for people to use but there's
really no standard they have too many
choices and sometimes that can be that
can lead to a lot of confusion in how
you what's the best practice for doing
your application development so that's
where java ee provides some value so if
you know java ee has been the been the
backbone of how some of the enterprise
development has done where you write to
some of the standard AP is and then you
choose and an app server of a particular
vendor to run and deploy against but it
gives you certain amount of guarantee of
what your application can have and run
in almost all environments of course if
you utilize the api's from the
particular app server then you have to
make sure that those are isolated in a
way you can package it separately so
with the shifter cloud basically the
type of applications and requirements
for the applications are essentially
changing and we want to make sure make
the micro services and cloud style of
application development be more relevant
in in Java using when you're using Java
EE and that's where Java EE 9 has an
opportunity to create a standard
platform for building
applications using the microserver is a
style of development so the same
application which we saw earlier where
we had the app deployed as war in your
files if you took that and broke it down
into many many small micro services it
could potentially look like something
like this roughly right where you have
multiple services that are written that
written separately and they all
communicate to you with each other using
HTTP two and JSON and they're all
written in such a way that it's all
asynchronous so you're not blocking on
any of there any other calls that the
applications are making essentially and
all of these could then consume the
services so all of these services are
exposed as rest endpoints and they can
be consumed by the other services and
consume services from the cloud
providers
so basically what this is showing is the
way we think that the proposed platform
architecture should be going towards so
you see that you have do you have the
typical OS a hypervisor on top of that
you have some form of container like
darker for example and then on top of
that you have the Java EE is on time and
along with that then you have other
services that you can use that span
across all of these all of your platform
all of it all of their own time
essentially like you have a security log
in or constriction and then the front
end end of the survey of the platform
itself some things like the API gateway
and the load balancer and its etc on the
right-hand side what you see is over
here is the basically the services that
you could consume from from a cloud
provider for example a database whether
it's our DBMS or no sequel database and
whether you know the other services that
you might want to use they're probably
people have seen what the technical
focus areas are going to be in multiple
talks so we want to focus on programming
model the packaging and also look at the
other areas as well for things like
configuration resiliency security so we
will try to cover some of these in the
Indus talk as well as in the top that I
mentioned we have tomorrow so let's
start off with the programming model
changes that we're thinking of so like I
said in this new model of development
you're going to have basically a lot of
rest services that are talking to each
other so we need to be able to have
applications that are distributed and
communicate with each other using rest
and JSON basically however when you do
that you end up having a lot of remote
calls that you're making as part of your
as part of the services as well that
talk to each other so there's a there's
a lot of a lot of places where things
could fail because not because the
application was misbehaving but more
because of the infrastructure that
you're running in because of network
latency or network outages so you need
to be able to handle things like outages
in your in the application self we've
also seen that you know people are
moving away more and more from the
typical acid transactions based approach
to more of a eventual consistent system
where you know even when the services
are sharing some state across each other
it's okay for them to be eventually
consistent so they're not really looking
for you know it to be an asset
transaction based system where the
transactions bands globally across
multiple services so we want to ensure
that we add support for the eventual
consistency style of programming in this
new environment reactive is another
important aspect so reactive programming
basically where everything is processed
asynchronously in a non-blocking way
along with you know everything being
processed as a stream as opposed to
making method synchronous method calls
so with the new style of programming you
want to make sure that the platform is
relevant in being able to do some of the
reactive style of programming as well
and for the resiliency part we're
looking at adding capabilities for
things like circuit breaker patterns
bulkhead patterns as well as doing
health check in in such a way that you
can make sure that the applications are
not cascading failures across the
multiple services when you have outages
for whatever reason that you may in the
security front of course you know many
of them of the new services that you
write are more and more moving towards
utilizing the more standard and Omar
protocols that people support in terms
of for authentication like wat and open
ID connect so we would like to make sure
that the platform supports has support
in the security faced as well and this
is actually a separate talk that is on
security related infrastructure so for
people that are interested in that they
should definitely look at attending
laptop as well so that's sort of a
high-level view so we will start moving
more into each of the areas as we go
through the talk of what we think could
be a portent of the proposals in
in the java e9 platform as we are
proceeding for with these GS ours so
HTTP two is now a standard so we want to
make sure that as the platform evolves
we add capabilities for HTTP two it's
essentially built on the same semantics
as HTTP one with additional things like
adding support for binary protocols
multiplex communication over the same
channel so when you have the same TCP
connection you can send multiple
requests or in parallel on the same
connection as opposed to all it being
fully request response where the
connection is just used for that
particular request in response and you
can compress headers and of course we
can also use server push which allows
you to do caching of content on the on
the client side leg and send the content
before the client actually requests it
if you want so in in the HTTP and
addressed in JSON areas so one of them
some of the proposals are basically that
you know before in in the web container
today with the servlet API we already
have a lot of support for asynchronous
processing which was introduced in
servlet 30 but we want to take that
beyond and make sure that you can
actually support HTTP two and make it
more add support for things like non
blocking and make it so that you can
also integrate with the reactor style of
programming for the web container itself
on the less than json side we have
jax-rs we're basically jax-rs has been
part of the platform and we're trying to
evolve the jax-rs as well as part of the
platform where we add support for non
blocking we updated to support this more
of the security standards and on the
client side we're looking to see how we
can incorporate things like circuit
breakers and reactive side reactive
style of programming in there in terms
of the JSON support so in the platform
we have support for both Jason we have
had support for JSON processing which is
being enhanced as part of java ee ay we
are also adding a JSON binding as part
of Java EE and as we move forward we
leave all these api's as well
as part of the Java EE 9 platform
another area of interest is basically
have to have eventing capabilities in in
the platform so what are some of the use
cases for eventing you want to be able
to handle very large amount of data that
your messages that have been driven by
things like analyzing the true analyzing
web traffic and you also for handling
things like a gaming data that you get
and in general more you know metric and
log data aggregation systems that you
want so the proposal here is to come up
with a new API that's that is basically
meant to be fact for handling of events
in in the platform in a unified way so
today we do have some support for
eventing it is distributed throughout
the platform in different aspects of the
spec so we want to make sure that we
handle that in a unified way in in the
platform as we go forward what we've
also done along the way is not only see
you know think of what the proposals are
but we're also evaluating what exists
today in the community that so there are
a lot of things that people are using
via like i said earlier on in in the
talk we acknowledge that there are a lot
of existing frameworks that are people
are using and that leads to some amount
of the confusion but we also acknowledge
that there are existing systems that
that people have been using so what you
can see here is we're basically trying
to see what are some of the well-known
systems and this is not an exhaustive
list by any means but you know things
like Kafka amazon events and then the
azure event hub and what support that
they have do they have and see what we
can leverage or bring into the platform
as we as we move forward we also would
like to encourage people from these
committees compare companies and
community to participate as part of
these specifications when they are
launched so that we can have the right
set of people in in driving some of
these some of these things in the
platform so I like you like you can see
here you know we've tried to see what
the features are above our dollar a che
and fault tolerance for
for scalability and delivery what are
the deliverables and man takes I'm not
going to go into details for all the all
the all the frameworks that exist but
people can take a look at it and see you
know dip the typical type of things that
these eventing platforms today support
we also know that there are existing
things in the platform itself so you
have JMS today right it is designed for
enterprise messaging we also have CDI
eventing support that is added but that
today is basically spans just the JVM is
released within the JVM it doesn't span
across jvms and then we have four
WebSocket protocol we have support in
the platform by the Java API for web
sockets and we already talked about
jax-rs as the API for rest web services
so here's what we are thinking in terms
of a proposal for what it might be that
we want to do for java ee nine so we
want to produce a simple event api which
will basically provide maybe some things
like you know very high-level objects
for producers and consumers that are
injectable and then also we want to be
able to do decorative message listeners
by using annotations in the API itself
and let's not forget the reactive style
of programming so we want to leverage
things like Java 9 flow since nine will
probably most likely be built on java SE
ni and we can start thinking about
features that we can even leverage from
java SE 9 when they're out like the flow
api and of course you want to make sure
that you know the various
implementations are pluggable in this
system as well let's move on to some of
the resiliency topics that we have now
that we've been talking about in terms
of adding support in the platform so in
terms of the areas of concern in
resiliency is basically you need to make
sure that you know that the distributed
services that we have are highly
available they're reliable and you i
also want to isolate all the failures so
that you don't have cash
failures when you're going through the
going to multiple microservices in this
in this in this environment we want to
able be able to do metric collection and
then react to that in the system whether
it's whether it's for isolation in terms
of resource starvation or for scaling
operations that you may want to do and
also integrate that with other systems
other parts of the system which you are
could be used like load balancer for
making sure you rub the traffic
appropriately as well so the proposal
here is really to see how we can do
things like connection and response time
out how we can handle that retry for the
transient failure so if you have failure
that happens because of network latency
how we can add capabilities for doing
retries for that caching responses on
the client that typically then like in
the circuit breaker pattern for example
so that if you hit a certain number of
failures then you can care you either
use the cash response or not make
further calls and overload protection so
you don't want to have too much of that
and then use bulk bulk head for resource
isolation in the system as well and of
course we want to continue to have the
async and non blocking approach of you
know reactive throughout the system like
we mentioned a mini a couple of times
now so in terms of some of the popular
patterns in this area you have the
circuit breaker pattern which is used
it's basically a generic way of how to
deal with failures or when you're
invoking remote services essentially so
you want to protect the resources and
the clients from having to go through
many failures and the fairies can be for
a variety of reasons whether it's a
network timeout or latency in your
network or just something else that's
happening so when the clients is
multiple failures in in this environment
what it does is basically it doesn't
make any further calls and tries to
either return the cached response it has
or basically return immediately so that
you're not cascading failures to the
client at all through the 22
the like I said the failures could be
because of either network failures or it
could be because of the service
temporarily not being available so you
could even be getting back HTTP phil
failure codes for example when you're
trying to talk invoke another one
service from another again in this we've
done it some investigation in terms of
wire the existing frameworks are so in
the circuit breaker pair for the circuit
breaker pattern you have the common ones
I hystrix we've seen fail fail safe and
we've seen the aqha circuit break up a
support that is there and you can see
that they provide various levels of
support for a sink and the reactive
model as well and how you actually
configure some of these things value
when you're in D in the when you're
writing the micro services as well so
the very initial thinking or Allah is
basically you know in Java e9 we want to
introduce some some things to do for how
you can be more resilient in these when
you start writing more and more of these
smaller services it's basically try we
want to provide annotations for defining
resiliency policies so for example you
could do on the right hand side like you
can see in some of the code you could
have a retry policy or what this is what
the circuit breaker annotation is there
or when you have well care where you
want to control the resources you can
say that what the thread count is and
what tools to use and things like that
we want to also be able to do response
caching so along with circuit breaker
and the bulkhead we want to be able to
do response caching so that if you're
not getting the if you're not able to
reach the service you can at least get
an a cached response in the meantime on
the client side and you could utilize
all of these resiliency property is a
policies that you have even to do things
like you know a graphical dashboard and
so that you can show the health of the
set of the various services in the
system so reactive program is another
area where people are starting to use
more of the reactor style of programming
there is some amount of X of
standardization done in the space so you
have reactive streams like I mentioned
earlier
we have the job of a c9 flow API as well
and then there are several other
frameworks we have we've seen in the in
the open source and other places such as
Alex Java acha reactor and spring
framework basically we want to see how
we can pull in the reactive style of
programming into java ee 9 as well when
we do all of this of course you want to
make sure we leverage sc9 and where I
think the se9 fill a flow API already
implements the reactive streams spec so
it's building on the existing standard
so you will be using flow and the
reactor streams in whatever we do for
the reactive style in this also you do
know that there are existing frameworks
that are that are there so you have RX
Java reactor acha stream and the java SE
9 flow and like you can see there most
of them have a specific architecture
most of them I actually event-driven up
with the exception of acha in this case
where it's an actor based system and
they have support for things like back
pressure you have concurrency as well as
clustering I think acha is the only one
that supports clustering currently and
in the reactor model you want it to be
asynchronous and ambreen parallel will
be able to do things like non in a
non-blocking fashion so most of these
frameworks already support that in in
the in there in the implementation
excuse me
so here also the proposal is essentially
to look at how we can bring in some of
the standard standard enhancements a for
reactive in addition to what already
exists for java a e9 right so we want to
be able to add capabilities for doing
publishers and subscriber api's we want
to make sure that you know we have
ability to handle back pressure in a
standard way in at a higher level in
java e9 programming model and all of
them all of this will of course leverage
what we have in SC 9 in terms of flows a
flow api's and in the se9 api so i'm
going to hand it over here to the reg to
talk a little bit about the state and
how we're going to handle state
management and then we have Josh cover
some of the other configuration and
multi-tenancy and security areas
Oh
anybody hi hi my name is Dee rich and
like I said I also work in Oracle
engineering and let's talk about
statement in a little bit ok so in this
action under state will talk about four
things first of all we will talk a
little bit about standard API for
supporting no sequel databases I mean
currently you know for those of you are
writing microservices and using no
sequel databases which are very popular
for managing data installing it you have
to use vendor-specific api's for those
so just take a look at how we can
address that maybe come up with a
standard API for that secondly we will
talk what if there is a need for even
higher abstraction than that I mean if
there is a need for a state management
the API which is not tied to so much how
you store state or how you access the
data store but rather you just think in
terms of constructs of state management
generally and so that's the second one
and the next we'll talk about a very
popular pattern which is talked about a
lot when people write talking about
microservices that's the sea QRS pattern
by show of hands how many of you have
used it heard it or read about it
anybody want to so not that money okay
so yeah one or two hands over there so
basically a very very brief description
of what see QRS pattern is and you know
and possibly what could we do with it
enjoy ye night or maybe not so that's
something where the feedback of
community would come in and then finally
a little bit i'll touch upon an eventual
consistency one of the techniques and
the technologies that are available
today to the developers and be again on
the intent there is to see if there are
enough commonalities between them it is
about an emerging and and if there is
such a pattern then we could if there is
room for putting forth the standard for
that so okay so
so let's look at the proposal for
managing their no sequel databases so
what's the problem here right so on the
left-hand side like you see then the
existing eastenders that we had they
were all designed for leader are DBMS is
right i mean the jpa was not designed
with this no sequel landscape in mind so
that was the biggest one of course right
so there is no single API that you can
use to access a variety of no sequel
databases that are available out there
and becoming very popular of course and
then if you do want to fit in those nosy
cool databases access to those no
security devices into the j.pierre then
the annotations and the API that you
know it's it might feel a little
unnatural so maybe we you know that's
something to be looked into and
something that we can address right and
then like I said I mean they ok pawleys
and like I said the number of diverse
neighborhoods no sequel you know
provider so how do we come up with
something a consistent API that we can
use with everything so and the proposal
going for forward is just that right i
mean let's address those issues i mean
we don't provide a consistent
programming api you know a common
abstractions for crud operations for the
no sequel databases and while we are
doing that i know it's it's we don't
want to have a grand unification api
because and you know those things are
generally tend to be leaky and you know
i don't want to hide or you know go down
to the lowest denominator so we do only
allowed to be able to go down to the
vendor specific functionalities or the
drop down to vendor specific
implementations if one needs to write
and then finally simplify the query
mechanism or when you are utilizing
these databases
so here's a picture here with a proposal
that sums up what we're thinking about
at least the Purple's thing is talking
about so at the bottom most row that you
see on the right-hand side is basically
the different database vendors and this
recipe kpi's that one has to use today
and on the row above it where it says
the no sequel category API so if you see
those are the four popular categories
that the no sequel databases fall into
the columnar database is the document
databases are the key value stores and
the graphical databases and if you
notice carefully the arrow below that
just lines up with the products that
support those styles of storage so so
that's the next row of the layering and
finally at the top we want to support
the basically a core set of api's that
are agnostic to all these no sequel
vendor implementations right and then
those core API is essentially our crud
from you know Beijing querying and
sorting and so on and some of the things
like we typically do that and
configuring your database t think that
you do with your databases and your data
essentially right so if you Italy good
to have you know standard API that you
can utilize across the breadth of
databases that no sequel to the bases
that are out there just like we have
that for the rdb MSS that are shown on
the left hand side are using jpa and
jdbc api's
and I forgot to mention of course that
rest is very important right so not to
be able to correct these databases using
eyes teary eyes as well okay so let's
see you know what does a basic no sequel
credit AP I look like very minimal right
I mean that's just up so before we move
on I like if you've been saying this
over and over again this is these are
just proposals this ideas in 20 APR that
you're thinking of putting forward and
you go go through the jrs and then you
know get feedback and then finalize them
them so don't consider them set in stone
or something like that here so yes a
basic no sequel Cody API just has four
operations right I mean let be all know
and love and hear what we see is a
category specific API that is an
extension of the card store essentially
in this case a key value store a peer
that extends the crystal and now so
which are not i'm looking at this but
thanks with you
right so if you look at this is so you
know one of the categories like
categories like we said is the key value
store so you know how it could extend
your basic crud story epi and could add
and capability and of key value stores
typically for example support the expiry
of data right so if you that can be
extended to add that capability in there
so that's just just one example of the
expired method there and saving the cave
are basically adding an object into that
story using the persist method and on
the right hand side that we see is
essentially you know how this could be
extended further to a particular
implementation that's just an example of
that so if there are you see there are
multiple implementations of a key value
store they could look like something
about what is shown on the right hand
side here
alright so let's move on see how do
these api's you know get used
essentially um so in this what we have
seen here on the example the left-hand
side is basically a user's a store
define method in an application that
extends the manga store which is one of
the databases that is provided specific
one of the things that do notice here
again is that the as an application user
you don't have to write any of the crud
operations code we only provide the
query capabilities that you on the
surface in your application and those
are basically implemented and you know
the results of the queries are obtained
from the underlying database so if you
look at those there are two examples in
here one is basically a pattern-based
where a user can define finder methods
and we can automatically look those up
to create the underlying database and
the other alternative is the use of a
query notation which could be used to
provide a query language supply query
language from the application that can
be fired on to the underlying store and
get the results from that so those are
two proposals that we could utilize so
that's how you could nap l'occasion
would define an application store and on
the right hand side you see that how is
that store used so you know you could
have BB that definition injected into
the application right there and below
that is is how you you could call the
methods that you are defined on the
definition using the injected instance
okay so that was the no sequel you know
standardization of the nose equilibria
moving on so like I said perhaps there
is an e in the land of microservices
right there is a need for in higher
abstraction of the API of anhydrous
traction for managing stay right in and
so what does that mean really right so
in the in that landscape you know they
what we have is we have JDBC API to the
JTA api's but these are not always
sufficient because you know your micro
services are managing and owning all of
their data and there are no distribute
transactions something like so you want
to even though there is a lot of talk
about having stateless services and no
state in there but there is state that
it needs to be managed and shared across
and communicated across services so
that's a problem that we have we need to
somehow sobs you need to come up with
some API that lets you do that right
most of the API is that we have today
are you know blocking in nature which is
less than ideal for micro services like
it says because we want to be able to
run all these api asynchronously or to
jive with the reactive programming model
that we are putting forth and better
scalability as in the system as well the
second or the next drawback that is this
needle what is cached and what is
persisted there are different ways of
handling those two things the transient
and persistent state is managed
differently so that sort of points to
the fact that hey maybe we need
something that does that transparently
for you okay and so we proposal
obviously the counter side is just to
you know how come up with an API that
addresses those things as an application
where r is a micro services developer
you don't have to you know deal with
those issues or go through these diverse
api's but rather cop you know deal with
the program to an API that lets you
handle all these things and what would
that kind of API look like for example
right
I mean so it could be based on some
primary key base region rights I mean
and this is again on curry any deep I
could offer you queries and aggregates
for you it could provide do events for
the data events essentially so whenever
you and entity is added or deleted from
the underlying story you know you could
as a user of the API into the register
for interest for such events and you
know will be notified obviously we have
to provide the you know yes synchronous
and asynchronous API is for that I mean
the both of them we talked about that
already this API could also let you
actually allow different kind of stores
underneath it remember even grids or the
are DBMS or even the nose equilibria so
this is sort of a little alternate to
the previous one that you talked about
but then again like I said I think these
are couple of proposals we have on the
table so and then we could go to the
community and see what what makes most
sense right all right Georgie is telling
even running out of time so I'm going to
try and speed this up a little bit okay
so let's see quickly see QRS what is it
what is the Stanford command query
responsibly segregation so this is a
very popular pattern and that's what it
is so in this most simple form SI queres
is nothing but saying that hey i want to
run my read and write capabilities on
different interfaces that's all on the
left hand side you see an interface
which is a very tip typical interface
that is used with crud operations that
we all have utilized at some point in
time right you have the query methods
and then you have the update methods if
you split it up into interfaces so
example services user service if you
split into the use the read user service
and the or the user read service user
right service one side you only have the
read capabilities on the other side you
have the right capabilities that's all
the seekers pattern is all about
essentially and in its simplest form
right so you just split the two and why
would you want to do that because they
read and the right capably or the
demands on the read and the right side
of the application will be quite
different now this is not the only way
to split those things but this is one of
the base which is talked about quite a
lot time so ok same thing in pictures
essentially on the left picture you see
I cried the interface you know there is
an interaction from the UI presentation
layer that's going through the current
service and underneath there is a data
model and the both the read and write
operations are being performed on the
same data model on the right side do you
see a picture that is yeah you know you
have two services you have the read
service which is operating on the read
model and the right sir which is
operating in the right model since you
have two services that the model can be
different underneath it not necessarily
but there could be right so this is
where the interesting stuff could happen
so what and like I said you know we do
not have much time to talk about the
whole thing but in very simple words you
know si si queres is nothing but
essentially a pattern that you can
separate reading rights and it is very
commonly talked about with top you know
with the event sourcing and and what is
in what is an event sourcing basically
event sourcing is a way of maintaining
over later state in a system as a
sequence of updates essentially right
and so it it and that is typically used
with commands domain event sanity and
stove so that that's all there is so I
know I'm kind of going fast here and
then you're introducing new concepts of
apologize if it's a little confusing but
we can ask if you have time maybe you
can be no ask questions and explain
these things further quickly so what are
commands domain events it so in the sea
q RS model
it's essentially are nothing but
commands so instead of calling an API
you know you send commands to the right
side which say hey you know date needs
to be done on to the right model and
those commands then get converted into
an event and those events are stored in
an order fashion in what is considered
to be an event store and every time
anytime that you want to build a state
of the system you one can go through the
event and build it from the recorded
events that you had in the past right
one word of caution CQ ice is not for
everybody so I don't think you know we
can just blindly apply to any system so
it because the right and read side are
split you know lots of consistency
issues can arise and so on and so forth
so it's not applicable for every
application but it could be useful for
some parts of the application and which
work which have a very consistent model
and internally and something which is
talked about quite a lot in the domain
driven design which is called a bounded
context so it it could be useful in
those and okay so what can be doing java
e9 maybe you know natively supported
help come up with the API is that could
you know help users develop a CQ iris
pattern things that can be done on the
applicant side and things that could be
done on the runtime services that the
environment could provide okay so
running out of time here so let's see
let's talk about eventual consistency
why is it important any time you know
there are micro services in application
come Eskom comprises of many many
microservices their state that is needs
to be handled you know their estate
communication happening with the objects
and so basically and there are updates
that need to be tracked and
and propagate it to other micro services
and then they'll do to the latency right
these changes may not make it to the
other end at all times so it's not
guaranteed because it's not NASA
transaction it's a weaker models it's
not guaranteed any changes that you make
are visible to you right there and then
so what are the techniques today so this
is are using to you know handle the
cases of the you know the eventual
consistency I mean basically they've
embraced eventual consistency yes that
we need a better scaling and you know
but how do I deal with the problem
essentially so on this slide is pretty
busy slide here the reference comes what
are the issues that you have and where
the data is stored and you know what
happens when you add an object to the
store and then how do you update it and
how do you okay the change is an object
and so these are the if you think about
it those are the basic functionalities
that you need right when you're talking
about state and the three columns that
we say there's a tea technologies or
three ways one could you know
communicate these object changes between
microservices right so caching is one
which is the number in memory great
messaging pattern is no one and finally
you know you could all share all the
state through a database right I mean
even though it's not the prescribed
pattern by the micro servants purists
because every service should own all of
its data but it's possible to do a track
immediately there could be used cases
where they could just simply share all
the state through a database okay so
what could we do I mean so like I said I
mean no one could the use case there is
that you know one could think of a
common API we'd basically abstract these
things away from from the application so
a simple way of you know adding objects
into the store listening for those
changes and getting notified right
between microservices that something we
could do so when you are doing this and
there could be multiple changes going to
objects which are
you know uniquely across the system from
different services so obviously and
they're arriving those changes are
arriving on services at different signs
thus leading to conflict so maybe we
could come up with an API that will help
the application will provide the
implementation for how those conflicts
resolve so that's something we could do
in the standard I know I jumped through
very quickly for the last few slides
said that so this is something what we
could I think I'm just gonna finish
there so just to summarize in terms of
state for things right we talked about
we could have a standard then no sequel
API we could look at a higher
abstraction API for state management
itself and third thing we talked about
we could have a ppi to help implement CQ
iris patterns in your services and
lastly how do we handle eventually
consistency you know fashion that is not
dependent a particular style of
technology all right so I'm going to
hand over to Joshua cook he's going to
talk sections
alright so thankfully the areas that I'm
going to go to cover are going to go
into more detail and talks throughout
the conference so my name is Josh and
I'm going to cover some of the areas
that are outside of the programming
model but are nonetheless important to
applications to support standards for
today's applications first area is
configuration and in the cloud we
primarily want to abstract the
configuration out from the application
so we want to introduce a new jsr I
believe this is going to be the ee8 time
frame this is inspired by some of the
popular frameworks today about you
tamiya delta spike Netflix arch is dark
I use excuse me spring config let's see
like I said primarily we want to take
the configuration outside of the
application we want to provide a unified
API for access to application the we
want to support multiple formats out of
the box including XML JSON properties
and we also want to as I mentioned
externalise that so it's can reside in
outside sources and we also want to
support multiple locations for the
configuration so and when you have
multiple locations then you need some
kind of ordering and this introduces the
layering and ordering concept where
higher order higher order layers will
override lower order layers there's also
a schema configuration that specifies
what can be configured in the
application as well as some of the
properties metadata the polling and
dynamic properties is from the netflix
archos model is the ability for the
application to react to dynamic
configuration changes here's a quick
example API you can see on the right
hand side there's a simple properties
file with foo equals javaone food bar
equals 9 food up our top as equals 2016
and the AP on the left you can see is
primarily string based but it also
allows you to get type specific
information
and the the proposal is that there will
be the framework have some default types
with the ability to specify custom types
yeah so the question was if that's along
lines of JSON be and some of the types
and I'm not sure of the specifics with
regard to that but the this talk there's
there's another talk that goes into more
detail with this on Wednesday so I hope
that he could have the answers for you
there's another the other areas
multi-tenancy this is something we've
seen with regard to the efficient
writing of software as a service
applications in that case we primarily
want to be able to support applications
the efficient deployment of software as
a service application so you do not have
to duplicate your entire application for
different tenants and this some of the
use cases include custom ui's tenant
specific data databases and data sources
as well as tenant specific security so
in this example a tenant context would
be key to this you can see on the right
there's an interface where the tenant
context this would give the application
the ability to access the tenant
specific information this would be
provided associated with the inbound
request and made available to the
application through the container the
tenant context would hold the identity
to the to the tenants so it can be
accessed and then the application can
use that for four different processing
in this example we show how the the
application could could use multiple
data sources through annotations that
would declare it to be multi tenant and
then they that specific information
could be used either through the
application itself or through
vendor-supplied data sources that
support multi-tenancy
in security we want to enhance the
existing jsr s so the the proposal is a
standard API for the identity store
abstraction standard API for
authentication mechanisms as well as the
security context for the application to
access the identity this would also be
40 f client registration would make
easier use of open ID connect and also
an API for the token representations for
accessing the tokens sorry if I'm going
over this a little bit quickly yes we
yes there's an existing jsr for e 8 and
we do want to enhance it the exact
specifics of what falls in de eight what
falls into e nine will be decided
another large area and i'll be going
over this area in more detail as the
packaging and orchestration of the
application in a cloud environment so
even once you write all of your business
logic with the with the programming
model standards that regime and dheeraj
went over there's still other concerns
that you have when you're when you're
deploying an application you want it to
be portable one is to define the
provisioning details how does the
application to find the resources that
it requires in a cloud environment how
do you influence service placement in
case you need to require low latency
between multiple services and how do you
effectively utilize the service registry
through service discovery in a way that
makes your application portable so you
don't have to rewrite your client calls
also you want to ensure high
availability through metrics collections
health checks so those those concerns
still represent an area where we can
provide provide some kind of
standardization so that the application
can move from environment to environment
here's a good example of a high level
architecture where your service would be
placed within a cloud environment so you
can see that multiple applications can
come in through a single entry point
through an API gateway and that can
leverage vendor cloud services such as
logging and secure
ready it can aggregate calls but you
notice that it utilizes some kind of a
load balancing or a router that can
speak with the service registry and your
services are kind of ephemeral and in
the back end and they need to be
provisioned appropriately and be able to
access each other so the the simplified
the summary of what we proposed for
standards in this area is to have some
kind of service metadata go to allow
your application to specify the
requirements that it needs the resources
how it's going to get provision in the
cloud environment maybe it needs to be
grouped with another service we also
need some kind of standard way of
interacting with the service registry
some kind of standard way of making your
client calls so that you can safely move
from environment to environment without
having to rewrite those client calls and
also some health checks and performance
checks those would be separate standards
but they would also help the cloud
environment interact with the
application and make sure that the
application stays highly available in
that environment so I'll hand it over to
receive to wrap things up
Josh thank you dear itch for helping me
with this presentation so to summarize
basically what we want to do right we
want to enhance job ie9 java ee as a
platform for developers to be able to
utilize all the new ways of application
development we want to bring the
standards around microservices and how
you build these applications and and
guarantee some amount of portability
like we said we acknowledge existing
solutions we've seen we've done some
comparisons we would like to see what we
can bring from that into standards we
would like to encourage people from
these communities to participate in the
process and help us drive the standard
and basically try to solve the store
commonly face problems that developers
are having in this space of doing
microservices style of development so
that's basically the summary so we do
have a survey where we are trying to
gather more community input I would
HIGHLY encourage all of you all to take
the survey and then there are other ways
you can help get involved as well that
we have the spec leads mailing list
which is pretty much open to people you
can join JCP if you want to participate
and all you can just pack the progress
and provide input as the milestones
become available there are a lot of
talks around job both Java EE eight and
java ee nine in this conference i just
wanted to encourage and basically put up
a list here encourage people to go view
these talks and listen to them and that
basically wraps up our presentation so
we have a few minutes I think off for
for the four questions and be happy to
take some here and then I'll be
available even after the talk for
questions we'll be happy to take yes
so yes so that's that's where the talk
tomorrow comes into picture with where
we talk more about packaging and
orchestration yes we want to leverage
modularity from Java SC 9 and you know
uses a J link to package just enough
runtime for more details on that please
I would HIGHLY encourage people to come
to the talk tomorrow they will be
available I don't know the timeframe
timeframe when they get posted but they
will be available online sorry the
question was are the slides available
online for people who are listening live
and being a string recorded so yes so
the question was the state management
and seek urs have been doing it only for
no sequel or force or for our DB MSS as
well I think it's better if you want to
comment it's it's to be determined so
early it is we don't know yet we just
maybe not even sure you want to make it
you know monetary or not it's if it will
be it will be something optional and
what the underlying store will be and
how the store could be implemented we
haven't even thought about that yet yes
yes yes yes sir so the question was I'll
just repeat the question for people who
are living listening life sorry yes yeah
so the question was there was a state
management jsr is there anything we are
trying to leverage from that because you
wanted to comment maybe you can i'm sure
yeah short answer is no
yeah no I mean that that jsr was a you
know we looked at it and and I think the
one of the things that we realized is it
was geared a lot toward session
management and you know extending the
app server for managing state for
application and the like I think the
goal for this part of the state man was
the you know API management API we're
looking at is you know slightly at a
higher level action so it's a it's a
different beast in a way hold on there's
one more question is back in the net yes
right so that's why I think the state
management API comes into picture the
idea there is to externalize state from
the runtime as much as possible so that
the server's the runtimes themselves are
ephemeral you have the state in a
separate ear and the and the containers
are running oven we have there are
pretty much immutable or end ephemeral
as they come and go razor
right so we've talked about it a little
bit there's there are different ways we
can approach this problem we can work
with CDI to see if CDI two or next does
some enhancements wait now it's not just
within the jvm but goes across JVMs we
could enhance the MSA p is where it's
more friendly for the cloud or we come
up with something that's totally
different like we showed here very
simple simplified version of that it's
to be determined it will be determined
sort of by the expert groups that will
drive the conversations all by
discussions with the in the case of CDI
if you work with the CDI expert group
for example it's too early to in my
opinion at least to answer that question
at this point yes and the programming
model changes yes over over time and so
the question is what happens if
microservices isn't relevant anymore
hopefully it'll be more than two years
before something new that changes
drastically but again we want to
basically the we want to be able to
support the cloud environment there's
nothing that's specific here that
couldn't we you know in terms of the
proposal we applied in general not just
to microservices right microservices is
a style of programming the api is that
we provide could be used in many
different ways
we've discussed did you wanna answer
organized we've discussed that
internally a little bit whether to will
enhance jpa we feel that it'll be
there'll be a lot of things that from
the jpa api that don't necessarily map
in the no sequel world so at least the
initial thinking that we have is that we
do a separate API that's basically
focused on no sequel but again it's very
early days you know these are proposals
will go through expert groups and
discussions and maybe if we create a
separate expert group for no sequel I'm
sure it'll go to in the platform expert
group so it's too early to say one way
or another at this point in my opinion
so JP is already I think there's some
amount of updates that are happening I
don't know if Linda is here yeah will is
here in there so if you all have any
additional things y'all want to say to
that yeah there are small updates
happening at this time in jp-a I will
take one last question if there is any
we are over time so if not I'd like to
thank you I highly encourage you to
attend sessions and also to take the
survey we really need your help to know
that we are heading in the right
direction at the survey so</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>