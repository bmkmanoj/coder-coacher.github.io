<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Debt and Deprecation | Coder Coacher - Coaching Coders</title><meta content="Debt and Deprecation - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Debt and Deprecation</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FLHtlAdua3Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon everyone I'm dr. Deborah
cater today I'll be talking about
nothing other than deprecation and a
little bit about technical debt so I do
work for Oracle and they put this
template in the slide deck and I
actually do want to talk to it today
because what I'm saying is just a bunch
of ideas I've been kicking around and
it's not even a complete proposal yet so
there's no commitment that this will
occur or that this will be delivered or
any changes we made in JDK 9 or even in
any future JDK all right so this is this
is really about the evolution of Java SE
now sometimes we get mixed up with Java
SE versus the JDK Java SE is a set of
specifications whereas the JDK is an
implementation and there are multiple
implementations there's open JDK Oracle
JDK and several other JDK s but when we
talk about Java C we're talking about
specifications which most people refer
to as the Java doc so a lot of things a
lot of things appear in the Java doc and
so in thinking about the history of Java
SE most people are pretty aware and have
some intuition that it's grown immensely
over the years and indeed that's true
and I'll have some I'll present some
numbers to show how much it's grown now
since it's a specification there's this
notion of specifications being normative
and officially all different parts of
the specification have equal normative
force right there's nothing in there or
there's very little in there that says
that this is more important than that
but really we all know that there are
some things that are more important than
other things and so so we're going to be
exploring that today now the platform
has certainly evolved a lot over the
years and I'm focusing mostly on the API
specifications less so JVM and JVM
specification and the language
specification but really focusing on the
API is pretty much all we've done is add
stuff and does it really is it really
effective to say okay we're evolving the
api's and we're just adding adding
adding
adding and not removing and so you know
this is a pre announcement of my answer
it's probably not effective to do that
and so what should we do about it all
right so let's start off by doing a
historical survey of the the class
laughs I should say Java SE class
libraries but I actually took a JDK and
did some analysis on it so what I did is
I took the RT jar which is almost exists
unchanged in every JDK going back to 1.0
of course that's changing in JDK 9 with
modular ization but it's pretty
convenient that it's almost all in one
place and it ran some some analysis
tools over it that I wrote basically it
collected some statistics based on the
standard packages Java Java X and org
it's like what see an org
well--there's or go Angie CORBA and
there's org dot sax for some of the xml
stuff there's actually a bunch of stuff
over in org so those are actually part
of Java SE so I've included those as
well
and so basically I counted up the number
of public class members such as methods
fields there are other things like
annotation types and whatnot the number
of public methods of public classes in
these standardized packages I'm not
talking about implementations here
they're a bunch of implementation
classes which are which are packaged
private or private and a bunch of
private members and I'm not counting
those either so I'm talking about public
features that appear in the API
specification and so if you look at the
numbers it's pretty amazing 1.0 had
2,000 features in it at his classes
methods and fields for the most part and
by Java 8 that was over 50,000
unbelievable the growth of the platform
and what's more interesting and I think
is the growth rate projected against
time now you saw there were 8 releases
or nine releases of of the JDK
but they're not spaced evenly they were
front loaded the earlier releases are
much more frequent than the later ones
and so you see tremendous percentage
growth in the early years
and it it in particular in 1.2 swing
collections and Korbel all came in so
that's that that's that steep steep
upslope for going in in 1.2 and it's
it's sort of flattens out since then but
it's still growing quite a bit and just
a couple notes here the the number of
API is in the platform grew by a factor
of 10 between 1.0 and 1.2 and then since
then it is merely doubled in size all
right so that's a quick recap on the
growth now so like I said we've added a
lot you know that begs the question are
we ever gonna take anything away so
there's this this mechanism that was
added very early on which which was sort
of a prelude to taking things away and
of course that's called deprecation and
that's why you're all here
and in fact I'm pleased to see so many
people in the room because deprecation
is it's something that we hardly ever
think about yet in going around the
conference people say you know Soho
deprecation yeah you know we really need
to do something about that so great I'm
glad you're all here because there's
there's seems like there's a lot of
latent interest in this topic so
deprecation was introduced as a formal
concept into java SE all the way back in
1.1 that was only one year after 1.0
shipped and so I wasn't working on the
JDK at that John I wasn't working on
Java at that time but clearly the
designers of that system knew that there
was something up with API evolution they
wanted to add old things and have a
process for for removing things or
declaring them obsolete or something
right and so what they came up with was
deprecation and the original deprecation
article was written by John Rose meaning
if many of whom you might be familiar
with he's still working on Java it's
great to have him still working on the
platform he's done a lot of work in on
invokedynamic
and lambda and JDK seven and eight and
he's he's he's still doing great work so
but way back when in 1996 he wrote the
original document which defines
and so it appeared so it's there's an
article there period the one-point-one
documentation bundle which I do not I'm
not sure if you can actually get the
official 1.1 bundle anywhere you might
be able to sign on to just you might
have to sign on to some oracle site to
download it I'm actually frankly not
sure
since I'm internal or to Oracle I could
get access to it but if you actually do
a web search for this document people
hack to it there's probably some
violation of some something somewhere
but people have actually posted this and
so you can find this easily and go read
it I recommend you do it well for its it
has very interesting historical
perspective alright so what was in this
right so that's a you know it's a page
or two long and some interesting things
in it and one of the things he says in
this document right off says Java 1.1
introduces many new api's some of which
superseded older ones and so uh I added
that emphasis there I think that's a
very good word because it has some
meaning that we haven't that we haven't
talked about very much and then he gives
a few reasons for for marking something
deprecated such as the API is insecure
buggy or highly inefficient and I think
there's certainly some buggy api's which
we'll talk about that that clearly
warrant some kind of deprecation or
other treatment the old API is going
away in a future release well that's
that's actually sort of circular right
so why do you know you you know market
deprecated because so that it you know
eventually will go away because it's
going to go away way in the future so so
that's that doesn't quite ring true for
me so but I think it was probably
written in a hurry and then another one
is the old API encourages bad coding
practices and it's not clear to me
exactly how that's different but I think
a bad coding practice will lead to say
loss of information or bugs in the
program so it's closely related to the
first one so there's another document by
Doug Cramer
available in the same documentation
bundle and here this is interesting
because it talks about the
sess there's some kind of process or
workflow around deprecation and
basically he says as a class evolves its
API changes but this has a problem you
introduce something new but you want to
keep the old the old thing around for a
while because that because developers
are still using it but you you don't
want them to keep using it you want them
to transition to the new API and so with
that in mind we mark the old thing as
deprecated to to tell developers that
this is an old API that something is
going to happen too and that they should
should use the new one all right so what
happens when you mark something as
deprecated so first thing this does is
it causes Java C to issue warning
and they're also hook some command line
options where you can turn warnings into
errors so if you want your if you if you
want your code base to be absolutely
clean you can cause the compilation to
stop if you get those warnings it also
effects the Javadoc output the
deprecated label is added as kind of a
kind of a special section header in the
Java doc output and something that's
that's I think quite obscure is that
there's a list of deprecated API s in
every Java doc bundle and so the
deprecated API is get added to that
deprecation also adds behavior to IDE s
and so IDs will issue warnings and will
render certain things in strikethrough
and I actually have screenshot of that
I'll show you what that means so there's
some weird things about the way that
Jeff brocation was added in one point
one it was a Java doc tag which appears
in a comment but it affected the
behavior of the compiler which was a
very very strange thing to do and
actually John roses I think John roses
document discusses that it's very
strange thing to do if you if you're
writing a compiler for a programming
language basically one of the first
things that does is to throw away the
comments so the fact that something
appearing in a comment changes the
compilers behavior is is very strange
thing to do but his explanation for that
is well we considered a bunch of other
alternatives and they were all
and so eventually this was actually
fixed in Java
se5 a new construct of annotation was
was created and so along with that
there's a deprecated and act deprecated
annotation was added so we have F
deprecated appearing in two places one
is a Java doc tag and two as an
annotation that can appear on an actual
piece of the program construct let's see
couple other couple other notes here if
you deprecated a class that has the
effect of
anything in that class inherits that and
so class method or field will also be
deprecated if it appears inside of a
deprecated class so that's nice because
if you want to deprecated the whole
thing you just mark the class as
deprecated and everything in there you
know if you if you call a method on it
that generates a warning or and and and
all the other stuff that I talked about
you know in IEDs and so forth but once
you have an executable class file
nothing changes there's there's nothing
that occurs at runtime you can use
deprecated API s and the behavior is the
same and so forth there's no absolutely
no change at all the time all right this
is gonna show you a few screenshots here
about you know what happens you know
what happens when you deprecated
something so if you look at if you go to
the top of the Javadoc tree there's this
link up there that I think nobody but me
ever clicks on which is this is
deprecated at the top and that gets you
the deprecated API list and if you click
on that what that looks like is you have
a very nicely categorized list of all
the deprecated interfaces classes
exceptions and right and so they're all
nicely divided into sections and just
because this one happens to appear at
the top of the the first section turns
out that organ ml dot sax not attribute
list is an interface that has been
deprecated and so if you go click on
that you see the the ordinary Java doc
page for an interface and it has a
header on there it says deprecated and
there's a note following it this
actually is something when you when you
put the deprecated tag into Java doc if
the recommendation is to add a
that says what the programmer should do
instead of using this deprecated
construct and so that's what it says
here so this this interface has been
replaced by sacks to attributes
interface which includes namespace
support so there's some XML much stuff
there and and so basically this says
don't use attribute list anymore use the
sax to attributes interface so it's
directing the it the intent is to you
know programmers are using the old stuff
something new comes out mark the old
thing deprecated and direct programmers
over where the new thing is pretty
sensible alright so the effect on the
compiler is if you compile a class you
get the Java C at least we'll say note
it uses our overrides deprecated API and
then for more information you have to
recompile so if you do that it's very
explicit about you know this line uses a
deprecated method and something similar
appears in NetBeans you can see in the
yellow box and the yellow tooltip kind
of thing it's basically the same
compiler warning message but also it's
kind of nice the the code is rendered
and strikethrough so it's kind of
in-your-face if you're reading code that
does that it's it's strikethrough it's
rendered a strikethrough to show that
show that it is indeed you know there's
something there's something up with this
with this code that you're using here
and a similar thing occurs if you do
code completions so if you say threat
dot and then you hit the accelerator to
pop up the menu of things you'll get a
bunch of all the things you can do on a
thread and optionally it includes the
deprecated items and those are rendered
and strikethrough so it it's nice it
tells you immediately that that that
there's something different about those
and of course that's that's that it's
deprecated all right now so great so
deprecation was introduced in 1.1 and
what's the history of deprecation in the
platform so clearly at one point in 1.0
nothing was deprecated because it didn't
exist yet and so in 1.1 a hundred and
thirty six things were deprecated so
along with the deprecation mechanism
being added 136 things were deprecated
and then over the years and over all
these releases a bunch more stuff was
deprecated so you can see that
440 API features have been deprecated as
you know all the way up through Java 8
it's yeah I'm kind of double counting
yeah so it's like saying API features
including classes and methods even even
methods contained in that class and it's
sort of you know it's it's a the
question is how you would how what's the
best way to count API s and this is this
is sort of wishy-washy but if you
deprecated a method that counts at what
at one point but if you deputy pick a
class containing a method I'm counting
that as two points because you know the
class is sort of a separate thing from a
method even though even though it's sort
of double counting but there are some
classes which contain many many many
members so I wanted to count all those
as well so but anyway so it's it's just
sort of a rough count of the number of
things that have been deprecated and so
I'm on the one hand surprised by this
and on the other hand not surprised I'm
surprised because I didn't think that
there were 440 things that hadn't
deprecated I thought that deprecation
was actually used even less than this so
I'm surprised that there's this much
used on the other hand compared to the
total size of the platform it's very
small less than 1% of all api's have
been deprecated all right so here's a
historical graph of that and
interestingly it follows this sort of
the same shape as the the overall API
growth of the platform but if you put
them on the same graph at the same scale
essentially there's the amount of
deprecation is is very very very tiny
compared to the total number of api's in
the platform and so to me this is making
the case that there's not not enough
stuff that's been deprecated but yes
questions
there okay all right so yeah well so so
okay so the questions were about taking
into account protected members so
protected members actually do appear in
the API now I might it's not actually
clear to me that interesting question is
the whether whether my statistical
methods have counted inheritance of of
deprecated things and then the other
question is about other other things
that are not part of Java SE like like
servlets and so forth which is Java EE I
believe yes I did not do I did not do a
survey of anything other than Java SE so
anyway but what I did want to do is
return to this idea of the workflow or
the process that was that was sort of
sketched out in Doug Kramer's 1.1
document which was you know some somehow
we haven't determined this but somehow
some JDK developer has identified the
need to either get rid of something or
otherwise otherwise mark it somehow and
you know in some fashion and there's
clearly need to notify developers and so
we have that we have warnings Javadoc
IDs I change behavior and so forth and
ideally developers will migrate away and
so we'll give them a grace period for
doing that so as they come out with
their new releases they they migrate
away to the they migrate off the old API
and onto new ones and then someday maybe
I think deprecated API is can be removed
so that's the ideal
No has this ever been done no so and so
that's that's the that's the answer here
nothing to our knowledge has ever
actually been removed from the Java SE
ap is now individual features have been
removed from the JDK but here I'm
talking about the specification I do not
believe that any API has ever been
removed from java SE so the way this
workflow seems to occur in practice is
ok so we do go through the deprecation
process you see that over time we have
added stuff to the set of deprecated API
s and well so this is sort of telling
ink developers to migrate away but in
practice they don't there's a lot of
deprecated there's a lot of usage of
deprecated API is out there and but
maybe the reason is that the JDK itself
has set a poor example there's a lot of
internal usage of deprecated API s from
within the JDK itself and we've we've
set a you know so so if the JDK doesn't
remove use of deprecated API why should
anybody else and we've never actually
removed anything so there's no you know
there's no in a sense there's no
incentive to remove things because why
bother right all we've done is
deprecated things and that's just to
leave them there alright so as I said no
deprecated API is ever ever been removed
but it's sort of there's this there's
this idea that there's an intent to
remove something and whenever this comes
up like in forums or on Stack Overflow
or something somebody says there's
always it plays out over and over don't
use that it's deprecated and it might be
removed someday but nothing has ever
been removed
blah-blah-blah-blah vacation blah blah
blah in practice you know don't worry
about it right so it's you know and and
its really it's really kind of a lousy
situation but I claim this this
represents technical debt in the
platform because we've you know there's
there's something there's something be
said for saying ok we're gonna create a
plan here's the plan you announced the
plan and you execute to it ok so the
plan is we're gonna deprecated this
which means we're gonna do something
with it or take it out maybe and then
all right well so so you know there we
are wait we basically haven't followed
through with with anything that's been
deprecated now if you look at the
percentage of things that have actually
been deprecated it's very tiny
percentage but I would claim it's pretty
easy to look around the JDK and say you
know this this is really all this ought
to be removed this is this is this is
old obsolescence stuff and you know use
this new thing over here so there's a
bunch of stuff lying around that perhaps
ought to be deprecated but isn't so I
think that's more technical debt so
there's a lot of there's a lot of API
technical debt floating around in the
system because of this you know we we
said we're gonna do something about
these by deprecating them but we never
have on the other hand there's this
other stuff over here that that you know
you look at it it's like wow you blow
off the dust on it it's like gee how
come this isn't deprecated well so
because nobody's paid it any attention
to this now so I've said we've never
removed anything but there actually some
some some reasons and actually sort of
good reasons why nothing has ever been
removed and removing something
represents the ultimate incompatibility
and so as you know one of the one of the
big features of Java is its emphasis on
compatibility so if you remove an API
then you you know you can't compile your
your old code against it and what's
worse is the compiler says ah you know
cannot find symbol
okay well now you have to do you know so
how do you fix that
you have to do research to figure out
you know what that is and it's also
binary incompatible if he's taking an
old class file we really really like for
old class files to continue to run
unchanged on new versions of the system
but if the method is gone
for instance you will get no such method
error and if once again you know so you
get a stack trace or whatever and you
gotta figure out you know what to do
there but also worse you have to
recompile there's no what there's
there's no mechanism for for filling in
a method that is is absent so so that is
well that is one of the reasons we've
we've been very reluctant to remove
things because it's it's it creates
incompatibilities and incompatibility
carries a high cost that is not to say
we should never remove anything but that
is that that's often the argument
against removing something because it
creates into compatibilities without
corresponding benefits and it also
creates difficulties for documentation
because how do you document something
that's not there because you want to
have something that says oh that old
thing stop using the old thing use the
new thing but if you've taken away the
old thing you know where do you document
the old thing is gone now so we have no
construct for doing that and so so
actually having the deprecated the old
api existing and be deprecated is pretty
good documentation because we have a
facility to direct people to the new
thing now so who cares if this stuff
builds up it actually does have an
effect on on them essentially on the
quality of the system the api's are
larger than they have to be and they're
more complex and it makes it more
difficult to use and I think this is
this this this this line about beginners
being confused by it is is true because
when you when you approach the system
you see a bunch of stuff there and you
click around the Javadoc and you might
say oh that looks interesting and you
start to use it and you find that for
one reason or another it doesn't work
and basically as would be you know
beginners can easily be misled by things
in the Javadoc
especially if they are obsolescent api's
that are not marked as deprecated and
there's actually a lot of it in there
and sometimes there are notes that says
well this is kind of an old class you
should use something else instead but
it's kind of buried at the bottom of the
class documentation in a number of cases
so I have some examples of of those it's
also a maintenance load on developers of
the JDK itself because there's this
stuff there and it's in the platform and
if it's tested those tests need to pass
and so if we add a new feature or fix a
bug or something over here if it
interacts badly with this old
obsolescent stuff well we we have to
deal with it so so it creates the tap it
causes the task of maintenance to be
more complex also bugs do come on in it
come in on these on these old things and
they have to be dealt with
sometimes they're dealt with by saying
yeah won't fix but sometimes especially
for instance if it's a security hole the
fact that it's in the platform if
somebody finds the security hole in it
we're gonna fix that and doesn't matter
if no application on the planet is
actually using it if somebody can
exploit it we're gonna fix it so it
actually creates maintenance load having
this old stuff around all right so I
want to go through the JDK and talk
about how it is act how deep Rakai ssin
is actually used basically the summary
this this section is that deprecation is
used in a bunch of different ways that
are inconsistent and sometimes confused
and there are a bunch of different
meanings of deprecated all right and so
in fact here's the here's the here's the
list of what I found in doing some
research and I'm a core libraries guy so
this is mostly centered around the JDK
core libraries there may be others out
there that other other usages out there
that that expand beyond these but I
think these are all different reasons
that that somebody decided to mark
something deprecated I mean if you
compare these to John roses reasons
given in the 1.1 document they're
they're kind of different but I think
the the and they're much more specific I
think John when John wrote that in 1.1 I
think he was sort of making it up yeah
they're a bunch of things that they're
much of reasons why you might want to
deprecated something and he bowing
banged out a few billet points actually
I haven't talked to him about this in in
detail so let me go through a set of
examples that talk about different
flavors of our different semantics for
or the reasons that things have been
declared deprecated in the existing in
the existing platform so the the first
and I think strongest case to deprecated
something is because it leads to errors
so it can cause your program to
misbehave or it can cause data loss and
the the classic the poster boy for this
is the the thread destroy stops suspend
and resume methods and there's in fact
this is probably the reason deprecation
was introduced because these work
initially put into the platform and
after some thought people the develop
the JDK the JDK developers said that the
home said you know we really ought to do
something about these because these are
dangerous and so this probably led to
the development to the deprecation
mechanism itself as well as big sa was
posted which is actually still linked
from the Javadoc for these methods that
explains why these why these methods are
dangerous and basically it can
unavoidably lead to unavoidable
deadlocks and data loss or data
corruption there are other things that
fall into that category perhaps not
quite as dangerous but there's some old
things like string dot get bytes and if
you remember back in 1995 or so we were
at least I was you know
characters are ASCII right and then
there's this new Unicode thing that uses
16-bit chars what's that and so well I
just want to get the bytes out of out of
a Java string and so get bytes just just
erases the high order 60 are high order
eight bits of the 16-bit char and so for
ASCII this is just fine but you know in
the modern world we want everything to
be internationalized and that will that
will result in garbage characters so
that's why this one is deprecated in you
know it it's it's anyway it's very
dangerous to use unless you can
absolutely guarantee that nobody's ever
going to feed you anything other than
ascii alright so there are other reasons
to deprecated things and so which i I've
claimed fall into a category of design
flaws so they're a bunch of things about
Java util date which is an
early early early class and essentially
there was no way to internationalize it
and so the flaws in date led to the
development of the calendar and
Gregorian calendar family of classes
which has its own set of problems but
but anyway if you look at the original
date stuff and you know anything about
date hand date and time handling you can
say oh yeah this is never gonna work so
there's no there's no notion of time
zone if you want to talk about times and
there's no notion of
internationalization and the parsing is
just all all very fixed it's like if you
want to if you want to parse a UNIX
style date great if you want to do
anything else you know you're toast so
date was deprecated because it just
didn't handle some things that that
modern systems need there's some weird
things going on with RMI my belief is
that the original original design of RM
I had the implementation spread across
different packages and in order for
those packages to be coupled with each
other you have to make things public so
that they can be visible outside the
package and so these packages talk to
each other using interfaces that were
public they appeared in in in the public
API and so they ended up in the
specification and so that was the way
that internal implementation packages
used to communicate with each other but
applications never use these if you go
read the documentation it says
applications can't use these these are
for internal purposes only and that's
that's what I would call an API smell if
you ever see something in an API that
says you know here mister application
developer here's how you create you know
update destroy or whatever oh and this
thing over here don't use that right so
so that's that's what's in there so
those are deprecated but basically the
lock is applications can't use this
deprecation has been used for
essentially what I would call cleanup
and most of that is renaming so some
stuff went on and AWT where they
reorganize some things so if you're just
oh I'm sure there's much more stuff that
there's so much stuff in in AWT I I
didn't have to you know couldn't fit it
all on the slide
but but I think there's some things
where the some some cursor constants
were moved out of frame into their own
cursor class so that's kind of a cleanup
thing there the some if you have a if
you have a list widget some things were
renamed to make them more consistent
with the collections API and and I think
this is if I don't know if any of you
are in the ask the architects session
yesterday this is something that mark
Ryan all talked about a little bit there
were high didn't show methods and those
infected sorry there are hide and show
methods and those are the original ones
and in order to make those compatible
with beans which wants to do set and get
on property names those were renamed so
to speak to set visible true and false
are false and true but the problem is
that hide and show were used by
subclasses and so it's not a matter of
simply saying that you know if you're
writing an application it's not a merely
a matter of telling people not to you
know it's a call the new one instead of
the old one they could actually never
remove hide and show because subclass is
dependent on them because a lot of sub
classes used hide and show to to
customize their behavior another reason
for deprecating or in this case undec
gating something is what I call a change
in a philosophy and this is this is a
very interesting story there's system
get n which is in there and support this
today and it is not deprecated but when
basically gets an environment you know
environment variable from the OS and in
1.0 the original 1.0 Javadoc for this
said this is obsolete do not use it and
in fact yeah it's very strange so 1.0
shipped with obsolete stuff as it was
and I don't didn't take a complete
survey of which versions this was true
in but for many many of the early
releases all this did was throw an error
so unconditionally and the rationale for
this was well III think that in the
early days of job development people
found this the the JDK developers
selves found this useful but then they
then they thought well okay the problem
with get in is that it it really it the
the variables you use with this are
inherently platform-specific so we don't
want people to use platform-specific
things we want people to write pure Java
code that is platform independent and
and the philosophy was much more
dogmatic about it than it is today
to the extent of making sure that
platform anything that had any API that
had well platform specific behavior
leaking the api's was to be avoided so
that's that's the rationale I believe
for get in to to be called obsolete even
in 1.0 but it turns out that for writing
real systems this is you know you you
really need oh the recommendation was to
use Java properties instead which I
suppose you could do that but then you
have to write a rapper that unpacks
environment variables and put them puts
them into properties and which is which
is just a pain so in Java five get end
was its functionality was restored and
oh I'm sorry it was marked as obsolete
in 1.0 and then when deprecation came
along the deprecation the deprecated tag
was added to it so it was deprecated
from one point one two - you know one
one point four or so and then when five
came out it was undated and its
functionality was actually implemented
so we it went the opposite direction for
the most things then it became a fully
supported part of the platform alright
so this is this is another one that's
pretty common which is that as things
evolve pieces of the API become
redundant so for instance here in AWT
the event system changed completely
between 1.0 and 1.1 and the way that
events were delivered in 1.0 was the
action method would be called but in 1.1
that changed to registering listeners
and so really this action method is is
no longer necessary and much
sure it's used or maybe you can maybe at
some point you could still override it
and and get events a different way but
the idea was that with the advent of the
new event delivery system the the old
style was obsolete and redundant and so
it was marked deprecated and so in RMI
any of you old hands or may remember
back in the 1.0 at one point one well
actually one point one is when i think
this was introduced if you wanted to
have a remote object you had to you had
to use RM IC to generate a skeleton
class which then you would compile a
link into your program and newer
reflective technology was was introduced
that simply made skeletons unnecessary
but all of the api's the support
skeletons are still there and in fact
all the options to support skeletons and
run using the old API s and protocols
are still there
they're deprecated but they're all still
there so there's yet again a different
usage of deprecation that I that that
surprised me this is an interesting one
although it is outside of Java SE I just
happened to stumble across this in
Google in guava they have a they have an
extensions to the set of collections and
one of the things they have is they have
a set of immutable collections such as
immutable list and so the immutable list
implements the list interface now if you
look at the list interface then it has
lots of things to get and hitter ate and
so forth which is necessary but it also
has all the mutation methods to add and
set delete or remove and so forth well
if you have an immutable list what do
you do with those methods
well since since the rule is if you are
implementing an interface you must
implement all the methods in that
interface they had to implement them all
and then have them unconditionally throw
an implement of you know unsupported
operation exception but that's kind of
unfriendly because you know if you have
an immutable list and you're working
with it and so forth
it has its own type but if you
accidentally call remove on it you won't
you won't get notified of that until you
get an unsupported operation exception
it
time so they said I believe they said oh
well we could mark this as deprecated so
that the compiler would leave you all
these nice warnings to tell people not
to do that
and so that's yet again a different
sense of deprecation so so these are not
things that are going to be removed in
the same sense as you know thread that
stopped but it does have this nice
property of saying hey you're doing
something wrong here and and you know
one of the themes of of static typing
and so forth is that instead of
deferring errors to to runtime we we
bring them back in a compile time so
that programmers can catch errors sooner
yes question yeah I think okay so the
question is about unmodifiable list
wrappers and and and having that having
those still extend the list interface
and that's kind of I'm sorry I think
that's somewhat off-topic I'd be happy
to talk to you about it length well I'll
just I'll just mention it if you look at
there's a design rationale document for
the original collections framework and
and it discusses discusses why II mean
ability is not part of the type system
and but reasonable people can disagree
on this but that was the decision that
was made back in 1.2 when the
collections came in so but I can talk to
you about that more afterwards I think
that is an interesting issue just not
it's not really about deprecation though
okay so as a doctor I have some
prescriptions to to offer so as we've
seen this this this idea of deprecation
is that sorry the word deprecated is
used for a bunch of different things so
we need to fix that and I'm gonna use
the word obsolescence as the general
concept for for this family of things
but they're really very different
different things and I think this is
sort of akin to what Mark Ryan Holmwood
- as denigrated okay so let's so what
I'm saying is we should develop a
vocabulary of words that describe these
distinct concepts that we think are
useful then look at all the deprecated
it ap is today and recategorize them
appropriately or in fact undec ativ if
if if we believe that they should not
have been deprecated in the first place
but then there are also some existing
api's that are not marked at all that we
should mark as obsolescence somehow
using our new our new vocabulary and
then proceed to remove api's judiciously
I'll get to that get to that in a moment
all right so here is here are some words
that I'm proposing I'm I'm I am
specifically not proposing any syntax
for this because we could we can have a
discussion about how whether this should
be an annotation or arguments on an
annotation and multiple multiple values
and the annotations over I don't want to
talk about that I want to talk about I
want to say at the conceptual level
before we get into that bike shed so the
first one here is condemned and I really
want to make people think about this in
terms of if you're if you're if you're
on the the staff of the city planning
staff of some city and there's some some
building that is going to be torn down
then you know maybe it's damaged in an
earthquake or something then okay it
needs to be torn down and rebuilt and
it's condemned so you read tagged it you
say don't go in there it might be
dangerous or something right so that's
that's the sense of condemned than I
want to use I know I don't want what I
really want to do is avoid now now now
you must do that I really want to stay
away from the moral aspects of of ganda
moral condemnation that's not what I'm
talking about here so condemned is to
say this is something that we are
seriously considering removing and so in
the next release or two it's going to be
gone that's what I'd like that to mean
dangerous really means what it says
that's distinct from condemned so
dangerous is that stuff like thread dot
stop or spring get bites which is if you
use this it may cause your program to
have errors and
or programmers so we like correctness
and so if you use this and leads the
errors then that's a bad thing it's
dangerous question okay so question is
is is dangerous would we would we
actually remove remove things that are
dangerous doesn't that mean the same
thing and the answer is no we actually
may decide to leave dangerous things in
the platform because there are they're
you know they're customers out there who
who might want to continue using them
despite the danger and so that's that's
a different trade-off there just because
something is dangerous doesn't mean that
it necessarily has to be removed for the
from the platform we certainly might
recommend that but if but people have
dependencies on these things so I think
removing something from the platform you
know whether or not to remove it is
distinct from whether it is it is
dangerous and so yes yes exactly
so so the comment is something could be
both condemned and dangerous and that's
true these are as an excellent point
these are not necessarily exclusive in
fact they probably should not be
exclusive so some things might be
condemned some things might be dangerous
or some things might be both condemned
and dangerous okay so another one is
superseded there's there's actually I
think this is a pretty pretty
interesting one here because there's a
lot of stuff in the platform like this
it's not dangerous
and we're we're not saying this is gonna
go in way in the next read but you know
it's there's a newer thing that you will
have you will have better success with
but we're gonna leave the old stuff
around for compatibility reasons because
there is a lot of old code there and
there's no if you're if your existing
code uses something that's been
superseded and it's working fine and
it's satisfactory you know I I have a
hard time saying we're gonna take that
away just because there's something
newer so we're gonna I would say in this
case we're leaving the old thing there
and if you're using it satisfactorily
you can continue using it especially old
binary
but if you're writing new programs I
would like there to be marking to say
you know you probably should look at
that instead okay and then something
like unimplemented like that guava
example or well they're probably other
examples elsewhere but places where
unsupported operation exception is
thrown but you want to you want to
advance that warning back to compile
time if you can do that then you mark
something's unimplemented so you get you
get a warning earlier on during your
development cycle alright so take the
existing set of things that are
deprecated and recategorize them so
that's my recommendation I would say
there are some things that should be
unde epic ated like the the AWT show hi
renamed stuff I think that having those
be deprecated is just a complete
distraction there's there's really no
reason that I mean first of all AWT is
very very old and any old AWT
applications at this point i don't think
anybody's going to go through and bother
to you know update the renaming x' and
so why bother at this point but it's it
just generates a lot of noise warnings
that swap out the more important ones so
let's just say let's admit it set
visible true is a synonym for show and
that's it right so you know there's no
there's no advantage to be gained from
changing any old programs from show to
set visible true now maybe market is
superseded I I'm not even sure that's
worth it alright so there's a bunch of
stuff in the platform today that's
that's not marked at all or it's leased
or it's not marked formally in some of
these cases if you go look at the
Javadoc there will be a note in there
that says well this class is mostly
obsolete you should look at that one
instead but if you're not looking very
carefully it's very very easy to miss so
I would recommend that these be that
these be marked as superseded
I have some details about these here
anybody use java.util observable good
congratulations you know it's one of
those things it was sort of like in you
know as 1.0 early days of
object-oriented programming okay so we
want to have a we do not have a nice a
nice way of coupling different pieces of
your system will have observers and
observables oh that's very nice well you
know observable is an abstract class
which really gets in the way of of you
know you want to have your own
implementation but if it's an abstract
class anybody who wants to be servable
is forced to be a subclass of this and
that gets them in the way of a lot and I
think the only reason was that it shares
the implementation of observer list
management which is not very much but
there are actually a bunch of other
problems with it too right what people
really want with observable things as
they want to say oh I want to listen for
changes on this but not that or I want
to I want to listen for a state
transition from from A to B but not from
B to C and there's all kinds of stuff
going on there and observable just as
changed and you know so you have to do
the filtering yourself and there are
other things too like if you call set
changed on a on and observable the oh I
forgot what the API is called but it's
like there's a you know notify observers
thing so somebody who's modifying
something calls set changed and then
that that causes notifications to go to
all the observers and there's it's it's
possible for what the this might lead
one to believe that calls to set changed
and notifications are in one for one
correspondence but they aren't because
if two different threads call set
changed then well that's not necessarily
bugged but the but they're not stacked
right so basically whether an observable
has been changed is simply a boolean so
if there are two calls to set changed
then the boolean gets set to true and
the second one says oh it's true already
so that just means a notification is
pending and eventually the notification
will go out and so the people who want
okay you may you may wonder why and know
so much about this obsolete class
well the reason is a bug came in on it
just a couple weeks ago where somebody
was complaining about this they said you
should do this and this and this and
this and this and it's like you know em
well sorry this is obsolete oh gee it
doesn't actually say that in the
documentation well that's the problem
all right so there are all these
problems with it and there are all kinds
of other mechanisms you know if you want
you know if you want you know an event
bus you need to use something else if
you want
you know maybe use beans or maybe use
you know cues you know some kind of
current queuing system if you want to
have reliable events or something like
that but don't use observer and
observable all right who here uses
java.util dictionary oh wow somebody
uses dictionary okay I want to talk to
you about that oh is it okay well yeah
there probably are okay sorry I know I'm
sorry I don't mean that I don't mean to
shame you for it or anything like that
but you know okay so so dictionary is
interesting because it's an abstract
class but it actually has no state and
no implementation so you know I I think
I think this is actually an error it
should have been an interface but oh
well and and this is completely
superseded by map and then the new
collection stuff and then there's hash
table and vector well it's really hash
table but since the capitalization is
wrong we all call it hash table but you
guys haven't heard that before oh that's
such an old joke okay but but the
interesting thing about about hash table
and vector is that they are purported to
be thread safe but there there are some
some weird features about it so so in
the sense there's the thread safe in in
kind of a naive sense which is every
method on these takes a synchronization
lock for the duration of the method but
the at least originally so they were
thread safe in that sense but they
couldn't actually be used very
effectively without external locking
anyway because if you wanted to a
typical thing you want to do with with
with a hash table is check to see if
something's there before putting
something into it so you don't override
it and and you just couldn't do that I
mean there's no interface for that in
in hash-table in fact that that's those
have been added to concurrent map and I
think actually those have been promoted
into the map interface as of of Java
eight but but in the old days yeah they
were thread safe but they didn't
actually have transactional api's that
you would really use so the notion I
would say the notion of those being
thread safe is sort of illusory so if
you wanted to use them in a
multi-threaded program you'd have to
handle your own locking anyway or you
actually take a lock or on that object
at the right time which forces you to
think about you know locking in a very
fine-grained fashion which you wouldn't
expect to have to do with something that
calls it thrills cause itself thread
safe there are some interesting ones
here I reference this bug and the
evaluator this bug is sitting in the
room right now but there's this there's
this interesting interesting deadlock
that can occur with comparing two hash
tables which are supposed to be thread
safe and the way that the way that this
works is if if you if you want to say
one hash table is equal to another first
call to equals locks the first hash
table and then it iterates over the
second one to make sure that all the
contents are equal well if you have two
threads that are calling equals on the
hash table in the opposite direction
they both want to take locks in the
opposite order
and so it's like okay uh headache how do
you fix this oh well let's see you can
do copy-on-write or you can take
snapshots or weak consistency and no
we're not gonna fix that sorry if you
really have concurrent if you really
have currency issues with something like
hash table you please use concurrent
hash map yes question
yes yeah well in fact the synchronized
the synchronized rappers have the same
problem right so again if you if you
have the right if if you if you have
yeah so if you have okay so the question
was wouldn't that same problem occur
with the synchronized rappers around an
ordinary map answer yes but if you
really have if you really have occasions
where you want to do Highland concurrent
operations on maps you really should use
concurrent hash map because that uses
none well it's interesting right so it
forces the this has bit of a digression
but it forces the trade-offs in two
different direction uses non blocking
algorithms for things but it also
weakens the consistency so the question
is what do you really want to do and
well I'll talk about that way offline
well so so the question yeah so the
question is when you call equals what
are you actually expecting to happen in
a concurrent system so it's an
interesting interesting question all
right but let's let's move on okay so
timer and timer task so I mean there the
nice little class is pretty simple easy
easy to use but they they have some kind
of difficult things to deal with it's
pretty easy to get a timer in into into
a dead state where it's trans timer
tasks things like if you have if you
have something that's fairly timing
critical things can get laid but really
the recommendation and the fact this is
in the Javadoc but it's very easy to
miss it says it it recommends using
scheduled thread pool executor which is
in Java util concurrent so I think you
know if we have this newer thing that
we're recommending use this one should
be marked superseded
date and calendar I already talked about
date somewhat what happened what's
interesting is that date has like 95% of
its of its methods deprecated and date
in prior to the new Java dot time API is
introduced in Java 8 the only use for
date was to hold
I think the like you know the the the
pure representation of milliseconds
since the epoch but all the other stuff
in date about you know getting months
and years and stuff out of that that's
all deprecated and so well especially
now that we have the new job at that
time package it's time to finish the job
with with date and also while we're at
it
calendar and Gregorian calendar I don't
have time to talk about all the issues
with those but but in fact job it on
time and it's precursor joda-time were
created to deal with all of the problems
with calendar and Gregorian calendar of
which of which there are many so so we
should deal with those I'm sorry get
time oh yeah that yeah with the new we
think the question is about you know is
there still a way to get the number of
milliseconds since 1970 oh yeah but the
Javadoc time stuff is is is really very
nice and it's it's very full-featured so
I recommend looking at it ok so a few
other things that are not about specific
api's I think we should go farther in
dealing with documentation we should
make those those what I'm calling
obsolescent api is invisible so that so
that people aren't distracted by them
and maybe you know put them in a
different tab so that if you really want
to see them they're there but they
shouldn't be in the default view of the
documentation we should do the same
thing with with IDs I actually don't
know what the default settings are but
the fact that at least the possibility
is for code completion to complete the
code to an obsolescent api is probably a
bad idea so at least the NetBeans
there's a way to disable that I don't
know what the default is if we add a
finer-grained vocabulary for talking
about obsolescence then we
should have corresponding compiler
options to say well you know I want this
class of thing to be an error instead of
a warning or I want to see the warnings
for this so there would be some need to
do that I would go ahead and actually
remove stuff about which more in a
moment but as I noted before something
that's dangerous is not necessarily
something that we should earmark for it
removal I think we need to think about
those separately and then there's some
futures kind of speculative stuff it may
be possible using the module system to
kind of move entire entire sub systems
like CORBA off into an optional module
and then deprecated the whole thing and
we've talked about that for a while
I think it's time to do that but also
for the finer grained deprecation things
it would be nice to have variations of
the modules so that with with the
deprecated are with the obsolescent
things actually gone and then have older
versions of them that have that have
them present so that you can't you know
different programs okay so instead of
having one monolithic jdk we have a
modular jdk but we could we may also be
able to have different versions of say
the base module would that have
different contents in them or things
marked differently or something I mean
though I'm just kind of brainstorming
here but we might be able to use the
module system to manage API evolution to
better effect and I am going to
pre-announce something here which is
that in fact stuff has API for the first
time api's sorry I rewind that I'm happy
to announce that api's have in fact been
removed for the very first time in JDK 9
and this is the modularization stuff in
order to break some cross module
dependencies they've actually removed
some api's and so basically it's sort of
this this notion of beens kind of
leaking into a bunch of different
packages and beans is really very client
focused and so having things in in the
base module or in the logging module
depend on user interface client stuff is
really kind of out of bounds so so they
took those out and they did a survey and
found that they were very little used
but
both programs will probably break
because of this so this change is
already in the JDK 9 development release
and the preview builds so you know
anybody who who wants to try it out can
can go do that alright so in conclusion
there are lots of obsolescent things in
the JDK and that's sort of a disjoint
set from the things that are deprecated
and so I think we need to do some
cleanup with deprecated I've outlined a
more a more precise vocabulary of
concepts that that makes makes things
that clears up the usage of deprecated
things I think we should go through and
remark or even under things that are
currently deprecated and then mark a
bunch of new stuff as excuse me mostly
mostly superseded but we should mark new
stuff that isn't currently not marked as
as superseded because we've admitted it
even in the documentation so the main
point of this though is about API
evolution and responsible API evolution
right we've added an added and added and
added and when you do that
there's going to be old stuff and we
need to say what's gonna happen to the
old stuff so it should be it should be
marked as superseded and eventually
migrated out of the platform or
something because as we look forward we
need to we need to understand what
happens at the trailing edge now
occasionally somebody will come up with
with with some some question like well
gee there's all the stuff that's been
deprecated it's been deprecated for
years we're never gonna remove all that
stuff the answer is we're not and I
think from listening to this talk you
probably understood why we're not simply
gonna remove them all because there's
there's no reason to there are very few
things that I think warrant removal and
we should remove those but that's a
small subset of the things that are
marked as deprecated today and so as a
doctor my preferred tool is a scalpel
not an axe so thank you for coming see
me on twitter i'm dr. deborah cater
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>