<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Integrating JVM Languages | Coder Coacher - Coaching Coders</title><meta content="Integrating JVM Languages - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Integrating JVM Languages</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/P-WrsNfHNxU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to the session on integrating
JVM languages my name is Venkat
Subramanyam we're going to talk about
working with multiple different
languages I'll be picky and tues just a
few here I'm going to be in the blind
spot for a lot of people around here
you're hiding behind the wall and I'm
hiding behind the wall so apologize for
that but I'll try to walk around
whenever I can best time to ask a
question or make a comment is when you
have it so please don't wait till the
end anytime is a great emperor questions
comments draw my attention i'll be more
than happy to respond to your question
so we're going to talk about integrating
JVM languages now the first question is
why why do we want to integrate
languages the reason simply is that we
have over 200 languages on the JVM they
all compile down to bytecode so it makes
more sense to mix them and use them
together especially given the fact that
these languages provide different
capabilities for us for example groovy
has a wonderful meta programming
capability so does JRuby Scala can be
used for processing XML you can use it
for a really good concurrent programming
you can use it for verification of types
for example so there's a lot of static
typing facilities that scallop provides
so there are reasons why you would want
to mix and match these different
languages a library may be written in
one of these languages but you want to
call it from some other language and how
do you want to go about using it well
for a number of years I've been giving
talks in conferences where I will talk
about using groovy our Scala at the end
of the talk I would have people come to
me and say hey that was very useful but
how do i integrate the code in Java and
other languages and I would tell them it
is simple it's very easy it works but
they won't accept it they would say yeah
but I would like to see a conference the
next year that shows how to do
integration and I went to another
conference that they told me it would be
nice to have a talk where you show
integration I would tell them it works
it's easy but you want to have a talk
regarding it so I decided to give this
talk so I want you all to know that
integration is simple and easy and it
works thanks for coming
well actually that's kind of the problem
I had because everything works and how
do you give a talk when everything works
you know it's fun to talk when things
suck it's fun to talk when things are
complex but everything seems to work so
for most part i'm going to show you how
things work and along the way i'll show
you a few things that potentially may
not work but within a few seconds we can
make it work so let's get started with a
few things i talked about why we want to
use multiple languages why do we want to
integrate well typically in an
enterprise we might use multiple
different languages and we want to be
able to integrate those code together
especially if you're programming in one
primary language then we want to really
integrate bring and bring them together
there are two different ways to
integrate 1 integration is are the
architectural boundaries we could say
the subsystem is written in one language
this other subsystem is written in
another language and may be
communicating back and forth between
them we would use such things like web
service XML JSON whatever that we want
to use that's one way to integrate if we
integrate that way there's no language
level issues it's a protocol issue that
we have to deal with another way to
integrate would be to compile the
bytecode and then start using the
bytecode and how does it feel when we do
this the way it feels is a lot like how
you would use hibernate or spring when
you use happier than screwing you don't
really think about who wrote that code
and even you assume that it was written
in Java but there but they're not that
may not be the case at all so code
written in multiple languages fields
like you're using them in this language
in a similar way to using hibernate our
or our spring so let's talk about a
number of these and see how we can go
about i'm going to show you two specific
integration today one integration is
going to be going from a language to
java like for example going from groovy
to java or scholar to java the other
integration i'm going to show you is
going from java to groovy and java to
scala so we're going to see both ways of
integration back and forth how we can
use it so let's talk about in
Gration here but in order to do this we
need an example to work with so i have a
class called a Java class and java class
has a bunch of methods over here let's
talk about how we can integrate that
from within groovy to begin with so here
is groovy code so i'm going to say
create min instance equals new Java
class now in this case we created an
instance I'm going to print that
instance out and you can see that i have
an instance right of the back what did i
do to get this to work very simple all i
have right now is i have the class
called Java class compiled already and
it has been compiling the byte code is
available in my class path that's all I
have so because it's my classpath i'm
able to create an object of your
directly going from groovy our scholar
the java should be the easiest thing to
do because this happens all the time you
cannot imagine writing a code in these
languages without using Java you know
written code so that's all I did now I
want to call this method over here how
do I call this method so I say instance
dart over here but what am I going to
call in this particular method well if i
look at this class here it's got a
method called people and i want to call
this people method what does it take it
takes names as a parameter so i want to
go ahead and call this how would I call
it I call people I'm going to pass names
to it but what in the world is names
however so i'm going to say define over
here and i say names equals well we
could say new array list and go through
all the ceremony of creating a list but
we don't have to do that in groovy we
can simply say over here for example
jack and then we can say gel and we can
simply create an object right of the bat
so simply it doesn't take a whole lot of
effort at all so all i did was i simply
created this object by saying names
equal Jack and Jill and I said pass it
to the object now this is one of the
nice things about groovy itself ruby has
the least semantic gap between Java and
groovy because almost every java code is
groovy code GUI did not go ahead and add
any new special collections instantly
enhance the methods of the collections
forest so we can readily call it in the
code without having to go through
any effort at all so that's what you saw
here I was just able to call that method
by sending the collection was right off
the bat that was very simple great
that's good so far however what about
this receive block method well the
receive block method is accepting a
block of code but what is this block of
code well the block of code is a
callable as you can see so how would i
go about calling this collar Bell code
what do I need to pass to it well to
call the scholar bill code I have to
first create an instance an anonymous
instance of the caller bill right so
that requires quite a bit of effort to
do so i could go ahead and say for
example import and then I could say java
dot util a dart concurrent dart callable
the the nice thing about importing this
is you can scare the heck of programmers
right because they'll agree what are we
doing here are we doing concurrency know
which is calling this little function
right but why is it hidden behind this
concurrent right scares the heck out of
people but then you can say new callable
and what should this take I wanted their
take an integer value over here and then
I want to implement over here a public
integer and then I could say call and
then within this method I could say you
know hello groovy for example hello from
groovy and then maybe I want to return a
certain result from here let's see a
result of two and if you notice what
this guy does he simply called the block
and returns the result so we could
receive that over here result equals
right so result equals and then I could
simply say over here I want to print the
result we received so we could say
result and we could print out the result
we received at this particular call so
that worked however this is not
idiomatic way of writing groovy code in
fact this is a very really sad groovy
code and instead of doing this we can
eliminate a lot of ceremony in this code
now what can I do let's go ahead and try
a few things we could remove this part
completely we can remove this part also
over here we could remove this part over
here and simply pass a little
Loescher to this function right about
here so notice what I'm doing at this
point I'm just sending a closure to this
function and notice how the code is
still working now what did I just do I
just took a closure and said hey you
want an implementation of an interface
here we go i'll give you a closure and
groovy says I can wrap that closure into
a implementation of the interface and
pass it if you really want to you could
say over here as callable you could say
that optional if you want to but if you
don't want to look at that it simply
worked as well so there are times we
would have to say callable but you can
try without it what did it just do it
took that one closer we created and
created an anonymous inner class on the
fly and passed it over to the code in
Java and said go ahead and use it so it
implemented the call method for us
automatically now what if this interface
had more than one method there are a
couple of things we can do if the
interface had on more than one method
you can simply send one closer and say
I'm done well what would it do it will
use that closure for as implementation
of all the methods in the interface you
may say jikes that's bad isn't it no
that's actually very good and the reason
why it is very good as because a lot of
times the way reason I try to do this is
I'm in a unit testing and when I'm in
unit testing I want to call a function
and pass an interface implementation but
in the context I don't care that this
interface has seven methods I care about
this one method that is going to get
exercised in this unit test so I can be
very lazy and simply send this one
implementation and for that method it
will use the implementation I gave and
for the other methods it uses the same
implementation but I care less because
those who'd never get called anyway so
why do you care what implementation is
for the methods that never get called in
this in the first place but if you
really want to make sure you give
different implementations send a hashmap
you simply say here is my function foo
that I want to call so foo is the first
function will call it foo one and i'm
going to say full one is going to be
this particular
I am the expression or our closure and
then i'm going to say food to is going
to be this lambda expression so you can
give multiple different closures as
parameters and then it would wrap up
this into a interface and if you one is
called on interface the first
implementation gets called if food too
is called the second one gets called and
it resolves it based on that very nicely
so that is how simple it is to implement
interfaces in the code not a whole lot
of effort at all as you can see it
becomes extremely simple and easy to
work with okay that is great so far but
let's move on to the next function we
have here what if you are really getting
into calling various different functions
in the code you know in many you're
you're trying to use groovy at work and
there's one colleague of viewers who
doesn't want you to do and and so he
starts to play tom and jerry with you
right you do something and he's trying
to do something completely opposite so
it's like what now what can you do so
you have started integrating and your
colleague is in denial that integration
is so simple so one fine morning he
comes to work and say is i'm going to
put an end to this integration business
and creates a function called death now
we know that death is a key word here in
groovy for defining functions and
variables right and so your colleague
purposefully writes a function called
deferences let's watch and have some fun
well you come along and you say instance
dart def what's going to happen it's
going to work or no what do you think I
see a few thumbs up a few more thumbs up
right well we think it's going to work
others are not sure anymore right let's
run doesn't see what happens notice how
it called it just fine no problem at all
how so well remember one of the nice
things about groovy is it's a great
language for writing internal dsl's a
character of an internal dsl is that it
requires a context so depending on the
context it knows what to do and so we
don't have to worry about it now what
about keywords
which is what keywords are called the
Mafia's right because they say here's a
keyword I chose I dare you use it right
and then they come and threaten you I
really don't like keywords for that
reason because it's got to be contextual
so in this case notice I use definite
said oh that's a very different meaning
in this context that's okay go ahead and
lets us use it not a problem so it
doesn't force us and threaten us you say
okay that was good so far but what if
things get a little bit more complicated
let's look at an example here so I have
a little languages over here so I got a
bunch of languages on my hand and their
authors so I wanted maybe this this hash
map is being given to you in there in
though in the code and you're going to
receive it and process it maybe this has
been created on that on this a Java site
so i want to say Lang's dart get java
right so we could write it like this and
it tells us based on the key value who
actually wrote it well that's great it
worked but this is groovy right and you
don't write code like this in guru be
it's gotta be a lot more concise so
let's try this one more time Lang's dart
and how about simply saying a squire
bracket and then say Java like this
wouldn't that be nice yeah sure enough
that worked really well i can remember
this is a hashmap coming from java site
maybe and then you say wait a second
that is too much of ceremony would it be
nice if we say just that that's even
better isn't it now in this case we just
walked up to this hash map and said I
want to access a property called Java
well how does it know no it doesn't have
a property called Java but because it's
flexible it's because I made a
programming it says oh if I don't have a
property called Java I'm going to look
up to see if there's a key called Java
i'm going to try value for it right and
once you start doing this you can then
say if the value exists I'll process it
that's great so far isn't it then you
clean up come along and say let's try
this one more time Alliance dart and all
there is Lisp we could try a lisp over
here let's see what it tells us that's
great knowing you are doing this your
colleague who doesn't want you
groovy plans another little problem for
you so you come along one morning and
say this plus c++ and what happened
booth why did it fail well maybe because
C++ is a problem no matter where you go
right so that could be a problem too but
but the point really is that blew up
well it blew up because there is another
concept here interfering and that is
groovy supports operator overloading
well because it supports operator
overloading it decided to pull in the
value for the C key and then because
it's null tried to increment it and then
it broke or in front of us well it's
even worse if there was a see property
right poor value would be incremented
and then we get a very difficult result
how do they deal with this quite a kind
of problems well that's the beauty in
groovy again you can simply escape it
and you can say I want to go ahead and
you know access this value but this
value totally escaped over here so I
don't have to deal with those
complexities so almost every language
has to give us a way to escape out of
these kinds of situations because a
keyword in a language may be very
offending to the syntax of another
language and we want to be able to
escape out of it so this becomes very
very convenient as you can see and even
though c plus a groupie doesn't require
keywords there are cases like this that
may interfere with other things but can
easily escape out so this gives us quite
an interesting set of flexibilities on
over hand let's take a look at how we
would go from scarlet to do some of
these things so I'm going to go back to
the people class for a minute so I'm
going to say value instance equals new
Java class one more time I'm creating an
object of the Java class here on the
groovy site I'm sorry scala side and i'm
going to print out the object itself
once again i have this in my class path
for me to use in the groove ease and in
the scholar site well I want to call
this method so I say instance dart and
what is this method the method I want to
call is a people method so I say people
and i'm going to send named Stuart but
before we do this let's examine what
names s so in Scala you would normally
say
a mames equals a list and then you would
say for example Jack and Jill like this
so that was pretty easy to create a name
as you can see but I wonder what this
value in the names are you could say for
example names and then you can get the
first value in the names so this is
going to be the item 0 for example jack
you could also ask him names and then
ask for the second value in the
collection in this case it tells you its
Jill so that seems to be working just
fine but what in the world is names so
if it's a name start get class and ask
for the class detail of this it is
actually an immutable collection in job
in Scala so now if I go back and run
this code we get a compilation error it
says you try to fit a square peg into a
round hole right it says wait wait wait
you have on your hand alliston scholar
but on the other hand I want a
java.util.list these two are different
animals you can't send this guy over
there so what do we do well notice it
did not work it gave accomplished an
error so I go all the way to the top and
I say import scholar dot collection dot
Java converters dot underscore so that
is all I did I put a little thing called
a collections over there and say I want
to pass in a scholar collection java you
know converters i'm going to call in
these converters on the fly over here
and and bring it now we know that the
instance method here is accepting a
names which which is really an object of
the list that it wants so in this case
I'm saying I've got a names which is a
list which is a scholar list but I want
to be able to pass that down the chain
into this code here in the sight of
scholar from the scholar site so Java
converters and i'm going to call this
let's look at the error what it says it
says in this case still it's a list and
a list it should say the type mismatch
let's go ahead and see if a static is
required here probably not but i need to
make sure i brought in the right import
right here so no I throw
not so it should bring in a king and a
converter assuming I called in the right
converters over here it should have
brought in the converter for me and used
it so collection so I'm not sure what
error I'm making here but they should
bring in a converter now what does these
converters do you can use the converters
maybe I can decipher that by calling a
method you could say as a Java list and
you can ask him to convert a names into
a job a list object so the converters
will allow us to go from the Scala
converter collections to Java
collections for example and then we can
call the methods automatically and then
we can pass it in so obviously I'm not
calling it properly let's actually find
out what these converters are was what
was it conversions the error error on my
part thank you spelling error so let's
go ahead and try that thanks for finding
that for me so Java conversions is it
conversions ok so let's go ahead and try
that nope alright Java convert better do
it right don't you love pair programming
come on it's got has benefits right so
what did what did we just do notice
something interesting did you notice
what I just did I'm of all the typing
mistake I did so it doesn't work I put
the import and it works how do you feel
about it well no file that under a magic
happens here box right so this is one of
the funky things about Scala is scholar
would do things occasionally that kind
of scares the heck out of you right so
this is my theory about scala Scala I
love Scala by the way what kind of
emphasize it I love Scala I love groovy
I love all the languages I love
languages however people complain that
when they programming scala little magic
things like this happen and they don't
understand it well the point really is
about this Scala is like a city and you
don't say this is a bad city and good
city all that you need to know is there
are parts of the city that you go around
and enjoy and know that there are parts
of city that you go and you get mugged
right and
is really like that and you gotta know
the good parts of scholar that you want
to go to and the parts of scholar that
you want to stay away from so you don't
have to endure that pain so that is an
example of how we just threw in an
import and it works but how did it
really do it well what really happened
here in this example is that when we
brought this in Scala actually brought
in water called implicit methods
implicit methods are like uninvited
guests they to show up without you
expecting it's like what are you doing
here oh I thought I would come and visit
you well so that's like an uninvited
guest it shows up occasionally and if
done nicely when you are expecting it
it's really nice there are certain
guests that i would love to have any
time like von trier shows up I would say
I absolutely come on over but there are
other people that I would have second
thoughts about so it's kind of the way
to think about when you know to bring
these things so that is a way to build a
system KITT be careful knowing things is
there's nothing wrong and writing the
method explicitly if that will help
readability go ahead and say as Java
list and call that method that it
quietly brought in here that's perfectly
fine ok so we brought that in that seems
to have work what about this receive
block method while we can call that now
let's get rid of this point here so
we'll say instance dot receive block and
what am I going to pass through here so
new java dot util dart a concurrent dart
callable well in the scala syntax you
put a squire bracket rather than an
angle bracket so in this case i'm going
to say integer over here and i'm going
to go ahead and implement that method so
define call equals and then i'm going to
simply say let's make it a string that's
a little bit more fun so i'm going to
say this is cool and i'm going to get
that as a result so result equals and
i'm going to just put that into a result
object and then over here i'll come back
and print the result out so that we can
actually see the result after the call
so you can see how it did call the block
such as calling block which is from the
Java side we return to school in the
Scala code and then it comes back
through the Java code and we just
printed it right here and we saw that
right right right there now what about
calling a deaf man
well let's go ahead and try that so i'm
going to say print line in start deaf
actually i just call in start deaf and
I'm calling the Deaf method and what
does it do it says identifier expected
but def was found similarly there is
yield over here that I'm going to call
and when i call the Ile de method that
fails as well why because it is treating
those as keywords your colleague sits
there and keep smiling now it's like yep
now I've accomplished right well not so
fast you can escape out of that as well
very quickly in other words any language
that really wants to survive in an
ecosystem where multiple languages exist
there's always escape route for these
things and you can escape out of it very
nicely as you can see here so not a
problem similarly you can use a depth to
get out of that as well like I mentioned
earlier the integration between the
languages and Java is extremely trivial
and there's not a whole lot I can talk
about in terms of going from these
languages to Java because it simply
works so I'm going to switch gears and
talk about going from Java to these
languages which is where some other
challenges would creep in any questions
or comments before we switch gears and
move on to that integration so far so
good all right so how would i go from
these other languages to these languages
well let me kind of summarize a little
bit about what we're going to see before
we jump into the language that probably
is going to cost you the most effort is
Java to scala integration and the reason
is Scala has done some really
interesting things that don't quite jive
very well to our expectations when we
program in Java like I mentioned earlier
this groovy has the least a semantic gap
between Java and gluey so most of the
time calling into groovy code from Java
is not difficult at all but I'll push
the boundaries a little bit and show you
a few cool things there as well so let's
talk about start with Scala first of all
so to understand this I'm going to bring
in a little Scala code but before
I do this I'm going to be writing Java
code now so right here i'm going to
start writing Java code right here and
what is the Scala code I want to work
with well the Scala code I want to work
with is right about here so it's called
a scholar class so let's go ahead and
create a scholar class so what am I
going to do first of all new scholar
class save it into an instance right
here and I want to print out this
instance right here on the Java side go
ahead and run it you can see that it was
able to create an instance in printing
what did I do to make this work the very
first thing I did to make this work is
the Scala class has been compiled into
byte code using the Scala compiler
scholar c compiler just like how we
compile java code using java see you
compile Scala code using scala c and
glue be code using groovy see so I
compiler to bytecode that byte code is
in my class path in addition to the
bytecode being in the classpath you need
one more thing in your classpath which
is the Scala library jar that's all I
have in my classpath the class path to
where my bike code is and the class
practice Scala library our job same
thing with groovy if you want to use
groovy classes compiler to bytecode have
the bike coding class path and have the
groovy jar in your classpath that's all
you have to do great now I want to go
back here and I want to call this thing
called people so how would i call this
people so i'm going to say over here
instance again so instance dart people
and get your google up and ready he's
already there waiting for me right i'm
going to you know fall into the trap
again but what am I going to call here
what I want to call names one more time
but what in the world is names well I'm
in the Java side so list off int string
over here called names over here and I
could say a raised art as Liz and I
could create a list of these names again
we'll say Jack and Jill over here so i
created these two objects and then what
do I want to do now that I have these
objects on my hand well I want to pass
this to the code and so I do and notice
in this time it complains that it cannot
accept the names why again the same
problem on the other side isn't it it
says he wants a scarlet pipe where
here you have a java jdk collection no i
cannot send it how did we solve this on
the on the scholar side you first type
it three times wrong and you have
somebody help you out right so we could
try the same thing we can short-circuit
a little bit we could say over here for
example import and then we could say for
a minute scollard art collection dart
and then i could ask for the java
conversions darts star and then i could
bring in the you know static import for
all of those right so there you go and
maybe you just start for a second and
said would this work now because I
brought an import now this is Java still
right so I didn't do that quite so what
do you have to do now well you say job a
conversions dark so Java conversions and
then I'm going to say as Scala and
whatever the type you want to convert it
to in other words all that we did here
was use the very famous adapter pattern
right that's what we did we adapted the
implementation of this class to the
other interface and as Java scallop a
buffer simply gave us the adapter
pattern on our hand so when I run this
code you can see it was able to call
into the Scala code and then get the
results so not too bad right so that's
what we did it here on the Scala site
now the next thing is I want to call the
block of code and what is a block of
code requires c-block require it
requires a closure a lambda expression
and so the first thought would be hey
how do i send this over so instance dart
and then i would say receive block well
my first question was if this guy
receives a block in all versions of Java
I would have to create an anonymous
inner class and call it hey in Java 8
it's a lambda expression can I just pass
it in unfortunately no and the reason
it's no is because Scala receives what a
scholar really receive at this point if
you take a look at what this guy tells
us notice it receives a function 0 and
function 0 is an interface but it's not
a functional interface it's an interface
with mulch
pull abstract methods in it in Java for
using lambda expressions those have to
have one abstract method not many
abstract methods so if scala changes
this to all the methods being default
methods except that one method we can
easily pass a lambda expression here but
until that happens we got to do a little
bit more work so what am I going to do
here i'm going to call this and send a
block over here what is this block i'm
going to pass over here so i'm going to
simply say block and this block is going
to be new and i'm going to create an
object of abstract function 0 that comes
to rescue what does abstract function 0
do it's like the other you know misused
adapter name where it provides dummy
implementation for all the methods in
the interface in this case I'm going to
say string over here return a string
from here and I'm going to simply say in
this example I'm going to say I'm going
to return from this code what do I want
to return let me make sure it's actually
returning the right type over here so
this one is a block T so I guess that
should be fine so what am I going to
return here I'm going to simply return
how about this right so that's all I'm
going to return from in this particular
call so once I returned this call that's
kind of funny he's complaining that i
should use an abstract function 0 no I
will not ok so that's an example of how
I can pass that now once they pass that
into that and it's going to give us a
result of some kind i'm assuming so
return whatever the block is going to
return so i can store that our way here
so i could say for example this is java
again so i'm going to say this is going
to be the result i receive back and then
i'm going to output the result we have
been given back from the call so we can
run that so you can see how we went from
Java to calling the method in Scala that
takes a reference that's good so far
right now that's great but let's this
increase this a little bit further there
is a function called greet in this
object I want to call the Greek function
that shouldn't be too hard at all so
let's go ahead and call instance dart
greet and and send the greet a call to
the greek method so this is an instance
method so I call it on the instance that
work just fine
and finally there's a receive util
method now notice what the received util
method receives it receives say you tell
where the util is a trait in Scala what
is that great at rate is at the very
offset a trade is just an interface so
if a trade has only met the Declaration
it goes directly to a Java interface on
the other hand a trade can have
implementation as well notice in this
example my uterus rate has one abstract
method and one implementation the method
one is implemented method 2 is left out
so how does this work well scala will
create a where any time you create an
inter at rate it creates an interface
but if you create a trade with a method
it gives you a buy one get one free
offer it creates an interface and the
class to go with it the code will be in
the class and the method will be the the
declaration will be in the interface now
what is an interface interface is
changing in Java until java 7 your
interfaces cannot have method
implementations in Java 8 you can have
method implementations and interfaces
right so what's an interface in Java 7
up to Java 7 well my definition of
interface is it is something that says a
lot about what it'll do but it never
does anything kind of like my boss right
so that's what an interface really is
well so because interfaces cannot have
implementations oh what's that recorded
I'm in trouble ok so the point really is
because interfaces cannot have methods
you cannot really have implementations
in them so Scarlett took the light route
said I'll create an interface in a class
to go with it this is a smart idea as
long as you program within Scala but the
time you have to program this in Java it
becomes really hard well ok it's really
hard because we don't know what to
expect once you get expect this it's not
that hard because you kind of get used
to it right so how does this really work
so let's get back to this code and see
how we will use it so i'm going to say
instance dart and i'm going to say
receive block over here
and what should I pass to this block
well i'm going to say my util that's
what I'm going to pass what in the world
is my you tell my util is a class i'm
going to create and so right here well
actually it's created right here in the
class so my util is a class i'm going to
create as an inner class there you go
and what is this going to be
implementing I want him to implement
that you tilt right so this is going to
be received util rather than you block
so to receive you till there we go so
I'm gonna send out util let's override
this method there you go we have these
implementation but remember one small
detail and that is there is already an
implementation of method one and we
don't want to re-implement it but on the
other hand there is no implementation of
method to and we do want to implement it
so we could say over here my
implementation for this but for method
one I shouldn't do that and what should
i do instead I should use this other
class I mentioned about what is that
other class well in order to see where
that other class is let's go to the
command prompt for a minute and look for
stuff so if i go to the bin directory
where i have the stuff and if you look
over here there is the util that is
sitting nicely here you can see but
there is also a utils dollar class isn't
that wonderful there's a class named
util dollar class this is awesome isn't
it right so this is a way to make sure
nobody understands what we're doing so
now in this case I want to call that
method how would I call it well you till
and notice it doesn't show up here why
because the IDE looked at it and got
scared and ran away and said I won't
even bother showing this to the poor
programmer so you take a courageous both
step and you put a dollar and then you
say class and then the ID says what are
you doing right so you just ignore the
ID continue further and then you say
method 1 and then you say this at this
point turn down the volume because your
ID is going to make noise like you never
heard before right and then you just
call it and put put blinders on don't
look at the error message if you are
doing ID
interment development this is not for
those people right so this is for people
who would just go beyond and say I'm
gonna go try it well we did what did we
do we said I'm going to create an you
know go to this object which is the
other class that it creates on the side
and call it and give it the context
object I want to deal with and you can
fire up the method and notice how it
worked so I picks a bit of an experience
and and patience to be able to do this
but not too difficult at all as you can
see well that's great so far we did that
what is the next thing I want to do
after doing this the next step is to see
if I can call this method called a
single tendered greet so I'm going to go
up over here to the singleton and call
the Greek method how would I do this
well that should be pretty simple isn't
it so I go back over here and say a
singleton dart greet and let's say hello
over here and call this and how sweet
that is that worked as well what's a
singleton as in Scala Singleton's are
really done the right way remember what
a singleton pattern us it's a pattern
you took about five minutes to learn and
a lifetime to master well they said
because singleton is so hard to get
right we'll make it a first class
citizen in the language so all the
methods we would write as static methods
now go into singleton in Scala so we
don't have to mess with instance methods
and static methods in a class nice
separation of concern in Scala I really
like this in Scala but having said that
I call the singleton method it worked
really well but notice Scala class is
looking the same like a singleton so
this is a singleton also but not
entirely true this is singleton but
notice it has the same name as another
class name so in other words a singleton
is a singleton or a singleton which has
the same name as a class name is called
a companion object now this is a
companion object and just to make life a
bit more interesting I have an instance
method called greet and static method
called greed now in general you would
agree it's not a good idea to have a
static method and an instant method with
the same name right now so do give the
same name
static methods and instant methods and
more methods if you really hate the
people you work with otherwise give good
names but just to do what this can
happen well how things could go here
hide us it'll give it the same name over
here let's get back to this guy and say
I want my sample class over here so
let's say sample Scala class dark and
notice the beauty of this you stare at
it it stares at you and there is like a
little stale made going on here right so
at some point you have to say all right
you when I'm going to go look on the
disk and see what's going on right ID
always wins as you can see right so
because we don't have enough patience we
got to get work done so what do we do at
this point well we realize if you really
want to get to this you have to go back
and look at the distal little bit to see
what's available so one more time do ALS
and notice there's a scala class but
there's also a scholar dollar class so
we could use this dollar class what does
that do well i could go back over here
and say scholar dollar dot but that only
takes a little bit down the rabbit hole
now we have a module dollar and then
wonderfully sitting there comfortably is
the beautiful Greek method hello greet
right so how beautiful it is right and
then you call it from there and you can
see that it's able to work so that's how
you reach a method which is deep down
when it's a companion object so you got
to take a little bit step now the
problem is this a lot of times
programmers may freak out when they see
code like this best time thing is not to
show it to them right otherwise it
increase the health insurance cost of
your company so don't go that route you
know keep this integration minimal in a
different layer and so they don't have
to endure the pain of these things so I
think we've completed talking about
going from Scala to java to scala we
looked at using the object we looked at
using their trade we looked at using the
closures now it's time for us to see how
we can talk to groovy so before I go
that route there are a couple of things
we have to do how do we really make this
integration easy I have to say that
integration works most of the time and
the time it doesn't work it is not too
difficult to make this work there are
three things you
currently need for integration to go
smoothly the very first thing i would
highly recommend is a really good cup of
coffee or whatever is your favorite you
know caffeinated beverage that is very
very important because it's going to get
very frustrating it keeps you going the
second thing you need is a really good
knowledge of both the languages you're
trying to integrate if you're
integrating javed groovy you should know
java fairly well you should know groovy
fairly well when i say you should know
the language well i'm not talking about
how many a pee-pee eyes you know it is
that you should be very comfortable
reading the source code of the language
and you should be very comfortable
running java p minus c and digging into
the bytecode and it's a lot of fun
reading the source code on the bytecode
if you don't know what to do on a friday
night that's a great opportunity right
there right so by reading this bytecode
and and and the on the source code of
the language you get to learn quite a
few details that we don't get to learn
just by using the API most of the time
so I said we need three things what are
the three things I said coffee is one
thing knowing the language is extremely
important that helps a great deal that
way we know how to work with these
things and the third thing you need is
an ability to sit there and say if that
is what this bytecode says it wants what
can i really send over here and you must
be willing to fight your way through and
get it work the worst thing you can ever
do when it comes to integration is
complain you never complain during
integration you just work around right
that is the most important thing then
you can have things working very easily
so let's talk about groovy right now so
to understand how this is going to work
I'm going to push the boundaries a
little bit here let's aim groovy class
over here and I'm going to go back over
here to the code and I'm going to create
an object of it sonu grube class let's
soar the instance over here to the
instance variable and then what do we
want to do now instance dot people and
when I call people what does it say it
wants it says it wants an object that is
extremely helpful isn't it right it's
like cool it wants an object
what does it mean really well if you
really look a little harder over here
you will notice it says names notice the
s over there that means it's plural
isn't it come on isn't that easy easy to
understand well okay let's be fair if
you are writing code in groovy to be
called within groovy it doesn't matter
but if you're going to be writing code
that should be called from another
language I highly recommend you start
putting type information in your groovy
code this is one of the benefits of
groovy is it's a dial you can turn all
the way this way are the all the way
that way you can say I don't want to put
any type information no here is a time I
voluntarily choose to put type
information because that's going to be
helpful so go ahead and modify that and
say this is going to be a list of string
for names are lists of people for names
what have you right so you can do that
but I haven't done that here so what am
I going to do I'm going to simply say
names over here order the worldís names
I'm going to create a local variable
which is going to be a string of names
and I'm going to simply go ahead and
create this into our raised art as list
and one more time here let's go ahead
and create Jack and Jill over here and
pass it down and we can see how easy it
was to pass it down and use it so that
is an example of how we can call the
people method which was taking a
collection now comes the next
interesting part we have a receive block
now what is received block really do
well let's go ahead and call the receive
block method so instance dart and i'm
going to say receive block and receive
block what does it want well it is
expecting what does it say here so let's
see what the intelligence tells us oh it
was object that was helpful again so
what can I do well this time you're
going to say all right I'm going to go
look at this code it doesn't help but
you know what this is really you know
that it's a closure ok great it's a
closure which means I got to create a
closure object so you could say closure
now what kind of closure am I going to
create well I could create a GUI lang
the closure and once you create a groovy
line closure you can pass
close your instance an anonymous
instance and say why don't you go use it
you could do that right but if you go
that route you want to implement a
closure but how do you know what to do
with it well like I said you have to be
willing to read the source code and you
have to be willing to read the Java p
output and if you do that you will
eventually come to the point where you a
little light bulb goes in your mind and
you say AHA this block really is
blog.com so in other words a call to a
closure is nothing but an invocation of
a call method this is purely a groovy
syntax sugar where when you call a
method on a closure directly they turn
around and call the call method for you
once you realize that you tell yourself
our hive that is what it really is doing
well then why don't I do something else
all that it wants is a call method well
if all that it wants is a call method
what kind of object has a call method
already a callable that's correct so we
could go back over here and say new
callable and we could send whatever we
want to send let's say a string over
here what is that guy expecting nothing
so whatever we return is good so
callable we could do that and then we
could implement the caller will over
here we could do that right but then you
say wait a second how can you send a
callable when that guy is expecting a
closure well that's the beauty of groovy
groovy is dynamically typed once you
understand that and the light bulb goes
your mind and says wait a minute if that
is true what other object can have
callable how about an object why not so
you say new object there's got to be a
reason why they have object right and
then public string call and return how
cool is that right and I'm going to
simply store that away as a result in
this call so let's go ahead and save it
away as a result and I'm going to
finally come back
and say output the result so what's
going to happen I run this code and
notice how it worked like a charm you
say wait wait wait how could you send an
object when a closure is needed in Java
if you call it it would slap you silly
and say how dare you call me go back sit
down and give me this interface but
glory is so happy you called it right
and it doesn't give you these details it
reads you like a guest in the house
right it doesn't push you around and say
don't put it there don't put it here
you're like fine I won't ever come back
to your house here you feel at home
right and they treat you nicely they
don't say you shouldn't have done that
it's okay sweetie we'll take care of
this for you right let's do something
much more fun that is the beauty you see
here in ja in the integration you can
just pass anything this is called
designed by capability insert resent by
contract right listen by contractors you
go somewhere and the guys in you know
black suit greet you and say hello it's
like oh dear this is designed by
capability you sit in starbucks have fun
talk about stuff and get stuff done
right so that is kind of how it feels
like that okay cool so that is great so
far we were able to call it nice hey
what about this call with params let's
push the boundary a little bit more well
no no worries this guy is going to take
a parameter after all so we'll say in
the value and then I'm going to simply
say how cool is that we even got and
we'll say even got and then we will just
output the value out so go ahead and run
this code and you can see that it says
we even got to so you can start
receiving parameters as well very nicely
and you can see how that worked so far
so good you say all right all right this
is all good but I want to take this one
more notch app in groovy i can do
metaprogramming i can have methods that
come to life at runtime what about those
methods huh I want to call them from
Java and it's a time for lunch no
actually it's easy it is intimidating
when you think about it right base let
how could I call dynamic methods once
again you have
you kind of know how the languages
behave so let's try this so let's see
understand to understand what that means
let's take an example here i have a
class over here the class i have over
here is called a person plus so class
person now what does this person class
have what I'm going to show you is done
in groovy gorm Gradle all these tools
use this capability of synthesizing
methods at runtime so define work and
what them does work method I'm going to
simply say working over here as you can
see however i can say over here Sam
define Sam equals new person and I can
say Sam dot work and you can see when I
run this code it called the work method
but i want to say Sam dart sink and i'm
going to say Sam dart run or 10
kilometers or 10 miles depending on what
you want to say but when i run does
notice it fails why does it fail because
those methods don't exist if you look at
gorham and grails and tools like that
they synthesize methods what is method
synthesis you can inject method into
classes but injecting methods is so 20th
century it's boring synthesizing methods
is on the fly you implement something
like command pattern you say hey object
I want to teach you a little way to do
something and from now on I can call
that method on you and I want you to
work with it so this is very powerful
model how do you implement method
synthesis notice what I'm going to do
now I go back to this code and define a
method called method missing and then i
create a string name and arguments and
then within this method I'm going to say
you called you called this dynamic
method and then I'm going to specify the
name of the method with and the
arguments you pass to me with the joy in
as you can see here so notice that we
said you call this dynamic method with
the name and this so when I run this
code you can see it called those two
methods how did it do that well method
missing is called the mother of all
methods it says if you don't find your
method come to mama I'll take care of
you right so it does
is the call at runtime for you when you
make this call so this is nice isn't it
so we call the method called work which
is already available but we call a
method called sink and run now clearly
in the code you would implement logic to
decide whether this is a valid method or
you have to reject it with an error
right so that's groovy coding problem we
are interested in integration today not
how to implement metaprogramming in
groovy that can be for another day so
the beauty of this is how do i integrate
this so far so good so we saw the power
of groovy unleashed here we can call
this meta programming let's get back to
this person class and see how we're
going to use it so I'm going to go ahead
and compile this this code right here
that I want and I'm going to push this
over to the files so I can bin file I
can use it so now we are ready to play
with this so how do I use this let's get
back to this code for a second and i'm
going to say over here I want to use
this code obviously so let's go ahead
and create an object of person so new
person and now that i created a person
object i'm gonna save it away here as
same like we did the other time and i'm
going to say Sam dot work over here and
we are calling that pre-built method
called work and you can see it printed
working yeah that was easy right now on
the other hand i'm going to say Sam dot
and we have a stalemate one more time
right it shows you what it has and you
say no go further there are dynamic
methods in there look deeper and the
compiler says are you crazy right
there's nothing in here we don't see
anything in the bytecode level so what
do they do we don't know what's
available what's happening well this is
one of the things we are at the compile
time right now and at compile time those
methods don't exist they are purely
synthesized on the fly and how do you
get to a method that synthesize on the
fly from the Java side well remember the
wise words of David West in computer
science we can solve almost any problem
by using one more level of indirection
so the level of indirection is why
should we mess with this here give the
job to the right /
in to deal with and who is that right
person gooby it's of so you go to GUI
and say hey look I want to call this
method I know you have it but I can't
see it could you please run it and
remember what grube does to you treats
you like a guest so as that itself it
says sure why not so how do we use this
so what I'm going to do here is I'm
gonna call a function called use person
okay that's a very dirty name for a
function sorry but gotta be usually may
be utilized person okay I don't know you
if I get it you's person alright so i'm
going to send the person object to it
great and what should I you do within
the use person method well i'm going to
say groovy object now what does gloomy
object gloomy object is the mother of
all groovy objects and this is the base
type that every guru object implements
an interface that every query object
implements so what am I going to do with
film here I'm going to simply say
instance dart and i'm going to call this
interesting method call that invoke
method that's a level of indirection i
was talking about and i want to call
them at the call sink and I don't have
any parameter to pass to it so I'm just
passing a null to it and when you're
going to run this now you can see that
it says you call this dynamic method
called saying it is that simple like a
promise in the beginning of the session
everything just works you just need to
know what you have to use right and it's
intimidating not because it's hard to do
it's intimidating in fact this is the
model of the story the simplest things
in life is the most difficult thing to
do because we are looking for something
very very clever and and hard and
sometimes a simple things are the hard
ones to look for please oh it like you
asking can I call method missing
directly i would highly recommend not to
do it and the reason is method missing
is one way to do this and there are
other ways to really inject behavior at
runtime somebody could inject it
externally and not even on the object
and and so gooby has a wealth of ability
to do meta programming and by
short-circuiting to method missing we
are not enjoying polymorphism we are
saying i know that is the method i want
to call which defeats the purpose we
probably don't want to do
I thought I had somebody else ask a
question over here please can you not
use our reflection this is one thing i
love about java programmers they have
relentless hope right this is good right
well the answer is sorry you cannot
because reflection api again examines
the class this has to go into the
metaclass but but good question
definitely absolutely that's the way we
learn by asking these questions but
that's the reason and that's the first
thing i tried as well so that's nothing
wrong with doing that at all but it just
wouldn't reach far enough then I say run
over here new object and what am I gonna
pass to this guy I want to run 10 miles
or 10 kilometers over here what have you
and run this code and you can see how it
was able to call that dynamic method yes
please is Sam a groovy object yes it is
pretty hip as you can see right here
absolutely because it's a person is a
class i wrote on the groovy side right
about here yes yeah this is a groovy
object in fact we could query him and
find out what kind of object he is so we
could say output over here and say you
know instance dot get class and find out
what its classes and then we could
examine the interface and stuff like
that from it as well so we could say for
example instance dard get class dot get
interfaces and then we could see what it
probably doesn't give a whole lot at
this level but we can dig in further and
see it yeah it is a groovy object
because we created on the other side so
so what's a lot of the story the model
the story is integration just works
there are some rough edges we have to go
through but I'm not come across a
problem that I could not solve with a
good cup of coffee by my side so it
works and we have to dig in a little bit
in a few places push up little
boundaries and as you can see we can
even call dynamic methods extremely
simple and easy to do so there is
absolutely nothing to stop us from
having the pleasure of using these
multiple programming languages on the
JVM and choose what makes it make sense
I've given time please go ahead
performance for integration itself or
the other languages themselves the
bridge the bridge is not going to be
really a problem at all but depends on
what bridge we are crossing in the case
of ja
they had sorry Scarlett they have the
adapter so there is a bit of an
adaptation that has to go but fairly
simple but that brings up a good point
you don't you never want the interaction
to be too chatty in the first place
anyways so as long as you cross the
boundaries not so too frequently it
shouldn't be a problem but i would say
for most part you wouldn't have a
problem at all but like any question
performance i would say prototype it and
if it performs adequately enough for you
that's all we care about so so it's very
easy to implement but you have to test
out to make sure it serves your specific
needs if you want to download the code
examples here please do so from my
website the URL is given a right below
here I'll in fact scroll it up so you
can see it on the top I hope you found
this useful thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>