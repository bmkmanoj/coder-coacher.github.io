<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Enterprise JavaBeans 3.2 with Examples | Coder Coacher - Coaching Coders</title><meta content="Enterprise JavaBeans 3.2 with Examples - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Enterprise JavaBeans 3.2 with Examples</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lPVea8JcRWQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is marina vodka and I'm the spec
lead for this release for the spec
update and with me is David Blevins who
hides himself behind the computer he was
an expert group member and sometimes
very active
otherwise he will tell everybody about
himself when his time comes so our
agenda the our agenda for today is the
list of new features and improvements
and examples and we will briefly discuss
what didn't make it into the egb spec so
egb 302 is obviously update to 3.1 how
many of you are using eg b31 features
Singleton's oh okay so you're up to
speed on what's going on so you know
standard simple light powerful it's
demanding Enterprise requirement this is
the first time everything was in the
open so we learned our ways and
sometimes it was better sometimes it was
more complicated to be all in the open
by GSF they 45 3 4 5
the java.net project allowed for anybody
to listen to live expert group I think
we lost my voice
users Elias received all communications
from the expert group Plus whoever
subscribed to that could ask their
questions provide the input and we have
JIRA issues still there it's functioning
users Elias is still functioning and
year I was a kind of a place to file all
your wishlist things what do you want to
see in the release quick recap of
the features message driven bean got an
excitement and health we hope it's an
excitement enhancement and everybody
will be using it and give us feedback
stateful session beans go to
improvements support for CMT
transactions in lifecycle callbacks and
ability to disable persuasion we
simplified rules for designating
business interfaces for local and remote
bills several small API enhancements in
timer service and security and
embeddable Achebe container we defined
egb api groups this is something
interesting several features became
optional we removed unnecessary
restrictions we actually clarified a lot
of things because we had time and oh you
guys don't see the the bottom of the
slide so we tried to better line between
specifications in the platform
so for GMS specific specifically GMS -
always a big change so we you know
stayed on track and documented support
for required configuration options and
your api and whatever GMS required from
us - to be specified in the MDB area we
did for the interceptors it was not a
big change kind of technically but it
was a big revamp of this back we merged
did anybody come to the interceptors
talk today so we merged two places into
one interceptors was specified in the
interceptors back and the insidious back
different interceptors but still
interceptors we merge them together and
created you know the the interceptors
back but that meant a GB specific stuff
a GB deployment descriptor I went back
to the eg be spec CDI work knowledge
stick its existence but we
that we added requirement that eg be
actually requirement is you know again
acknowledgement that eg B's being CDI
Malaysia beans can have injection
constructors and stateful session beans
will be destroyed the remove method will
be called when the CDI context is
destroyed for transactions JT added CMT
sub transactions to CDI manage pins and
will look to how eg B's can play with
that and we figure out they can't I mean
you can start transaction and a GB and
called transactional CD ID and you can
start you know CMT transactional and CDI
bean and ecology be but you can't place
you at transactional annotations on the
eg B's that would be an error and the
last the last bullet that you don't see
on the slide is jax-rs alignment jax-rs
and the previous version was saying that
eg B's can be jax-rs component and a GB
spec was silent about that so we said
yes even from achieve a perspective
that's the right thing to do so features
and improvements in details this is a
teasing slide because the David will be
talking about this in detail this is
very high-level just an announcement
about the MDB change that it cuts off so
it says m DB with no methods
messagelistener interface which is a
marker interface that adds possibility
to strongly type metadata and apply
metadata to methods and parameters in
addition to just clause itself but wait
for the rest okay stateful session being
CMT transactions support in stateful
session being so Singleton's were added
in the previous release and singleton
had CMT transactions on lifecycle
callbacks from the beginning which
everybody thought is a good
and then if you you know logically it
comes to stateful session beans that
also have a state and might want to if
not read then write data in pre
passivate and pre destroy their state to
the database transactionally so it's an
opt-in know to break backward
compatibility because by default
stateful session bean callbacks execute
in unspecified transaction context which
means whatever happens so it continues
to be whatever happens but you can
request transactional support by
specifying explicitly transaction
attribute requires new own the lifecycle
callbacks defined in this state session
B not on the Interceptor somewhere but
in the session bean itself ability to
disable passivation some like it some
don't like it we put it in so
preservation of stateful session beans
might be tricky because if passivation
fails the beam is destroyed and if it
holds state it might not be what what
you know it might be okay maybe not and
the other thing there are the reason for
that was in cases when the bin holds a
lot of state and when you write it down
down it's being is not being used that's
fine
but when the beam is accessed and you
need to read it all back into the mid
state you can see a substance you know
real delay in access of the bin so those
who were having this problem requested
this feature and we added you can opt in
into actual opt out of the passivation
by specifying preservation capable force
in stateful annotation or in the
deployment descriptor the downside to it
is that passive beam passivation is used
by most containers to do fellow and the
containers are not smart enough to
understand what exactly did you mean so
if you meant no
to passivate it means not passivate so
failover will probably not be supported
for such stateful session business API
changes time of service API go to change
one and you method it cuts off
everything so this thing says get
old-timers get all active timers in the
same AGB module okay and that's
important it's not in the same
application the same it should be module
but it is a big step forward from what
you had before only time out being could
call its get timers so if you want to
see all timers in your module you need
to know which being has you know is a
timeout bin and ask each that each of
those been for its timers so now we have
not really okay you can see that so the
other thing was that timers will not
allow to be accessed outside of its
owning timeout bin which is also kind of
a strange you can get a timer from a
bean
but you can't do anything but that you
need to pass it back to the bean to even
ask for the next time out so we removed
that restriction and now you can call
any idea on both egb timer and timer
handle and you know do even cancel be
careful but you can do call Council on
it as well okay I'll go change the
resolution
okay so technical interlude
what was that 10 20 by 7
isn't it well run yeah that's what we've
had yeah
do one to the smaller yeah yeah that's
what we're on so I don't know why this -
alright
just oh yeah so that's oh no we're fine
yeah okay so the previous one now you
can read you know if you're still
curious to read what it was saying okay
good because this is this would be much
more difficult to you know just read for
security there were two changes to align
with the sort of container
changes for security want to add a
container provided shortcut special
security role name star star which means
any authenticated color independent of
the actual role name so you don't if you
if your code only cares that the color
logged in correctly and such and you
don't need to know the exact names
that's a very good thing to have if your
application I mean the idea was that
probably close to zero applications do
that but if there is a small chance that
your application has its own star star
role then that will continue to be used
then this shortcut will not exist and
the second change will also
simplification before that you would
always need to have a runtime descriptor
to specify how you're all named Maps to
your own name map can be used and the
change was that security rules defined
in deployment descriptor or in rules
allowed annotations are implicitly
declared you you don't need that extra
layer of interaction unless you really
want it embeddable egb container got a
very useful improvement because we now
ec7 requires as a seven so we utilize
the outer closeable and instead of all
this long closed stuff you do try with
resources and you're done we also
clarify talking about clarifications
what happens when egb can embody balaji
be container closes it cancels all time
of non persistent timers and it cancels
all pending I think methods those that
are running would probably finish but
those that didn't start the would be
canceled and it releases all the
resources API groups this is okay now
bear with me this is a little bit you
know more theoretical so eg be light was
introduced in the previous releases part
of the web profile and eg be light is
this small subset of feature that is
always available now we heard you know
questions from developers and from the
container providers can we add support
for MOT jeebies to EG be light and the
answer before was no it was all or none
right either EG be light or EG be foo so
MDBs can we add MDBs 2gb light the
answer was no now the answer is actually
yes we define the list of groups with eg
beeline being the first one of them that
you know eg be light must be there you
can't as support to any group without
each of you like being there what the
groups are clearly defined and they can
be added on top of eg be light the
container providers are not required to
do that but they allows to do it and
according to the rules so everything in
the group need to be supported
all-or-none for example you know 303 Oh
remote 300 includes remote a sink your
system eg be timers is a separate group
can be added as is MD DS can be added by
the connector must support message
endpoint and inflow and GMS MDBs can be
supported if JMS provider is support so
there are very specific rules and
eg be light itself got to obvious
additions local are synchronous because
remote are not part of the eg be light
and non-persistent eg be tremor okay so
if you go to the runtime environment in
the eg be spark the groups are like a
big table of groups so 2 dot X for
example includes Interop so to ask
somebody you know our containers to
provide you 2 dot X support means that
the container must provide the interrupt
I'm switching to you are you ready
you know how to switch you will just
replace it
just put it on top
so David will do the example part okay
let me get the resolution worked out
that's not the right preferences it's
really fun when people are looking at
you make mistakes yeah it was twenty
seven sixty eight or twelve eighty seven
sixty whatever resident whatever
abracadabra okay I hope the code is
gonna be readable I might maybe should
maybe should have picked a smaller
resolution but yeah let me do that
because always have to zoom everything
and that takes time more than this okay
60 mm-hmm
better that's much better okay so as
marina mentioned we did a lot of work on
the MDB area and the interesting thing
about MD B's is actually have absolutely
nothing to do with message JMS at all
crazy huh
raise your hand if you knew that already
yeah there's two people in the room so
here's what happened is in EJB 2.0 MD
B's were added and they were in fact
exclusively tied to JMS and then we as
vendors wanted to slip out all swap out
our JMS implementations and then the
details of how you do that become a
question
and so in EJB 2.1 MDBs were extracted
and abstracted from JMS and in the
middle they added the connector
architecture so now effectively MDBs
became connector driven beans but we
didn't bother to rename them or tell
anybody or do anything with it so they
came forever became forever locked in
with with with JMS and so there actually
has been the ability for the last you
know eight ten five were long egb 2.1
was ago several years to implement beans
they're consuming data incoming requests
from any source so you could have
incoming requests so as long as you had
a connector that implemented that
protocol you could then have that
connector be sending that data to beans
and making invocations on there so you
wouldn't have to use HTTP for example if
you wanted to expose something to the
world
you could be consuming email straight
into your java ee server and have an
email driven bean you could have an ftp
driven bean you could have a jab or
driven be an SMS driven bean all these
things are possible
however the few of us who understood
that this is possible
still didn't use it because the API for
doing that was rather crippled so we
attempted to fix this for EJB 3.2 and
and we did so we weren't able to take
advantage of it platform wide yet but
ee8 will very likely be doing that but
let me just show you how things exist in
your current platform if you're using EE
6 what I'm going to show you is possible
so this is MDB as it exists today so the
contract of how MDBs work or effectively
connector driven beans is you have a
connector which is a jar or our files
what it's called and that's provided by
some third party or perhaps by you but
if it's by you whatever you implement
your MDBs just as you would and the
downside of this whole MDB thing these
days is that you need this thing at the
top right you now have your activation
config which specifies which things you
can pass into your JMS implementation
and what parameters it's capable of
understanding alright so there are two
really big problems with this one it's
loosely typed so string int how many
parameters does my JMS provider allow
and what are the types of those
parameters
nobody knows read the documentation
because that won't tell you so it's
loose it's loosely typed not strongly
typed so you can't use int boolean and
so on so forth word that would make
sense the other one is that we're using
an annotation to effectively do name
value pairs so this is probably the
worst implementation of an annotation
that ever existed it was fine when we
were doing ejb 3.0 I was on that expert
group so I'm blaming myself as much as I
am complaining you know we missed the
opportunity because obviously an ejb 3.0
we made JPA and there was a huge effort
that took so much time
energy and then we were focused on
simplifying stateless stateful beans we
did MDB simplification but we didn't do
it that well so we ended up creating
basically name value pairs in annotation
this could have been an attribute of an
annotation and then this could have been
very strongly typed value so this was
not possible though because of the way
that the connector architecture
interacts with the underlying container
so here is a typical example of a
connector should you want to write one
which I really hope that you do because
it's actually not that complicated when
you create a connector you need
something that implements resource
adapter and effectively it has some
pretty understandable methods the names
are not as intuitive as they could be
but going the wrong way on the zoom
right okay so this is little small but
but this method I'll tell you it's it
says start that's when the applet that's
when the server is starting okay
this method that's stopped that's when
the server is stopping this method is
called endpoint activation effectively
means hey
deploy this beam and this deactivation
hey undeploy this beam that's all you
got to do what you do in between time is
totally up to you so writing a connector
is pretty darn easy
you need this plus a little bit of XML
the XML is not complicated
here's the XML fairly small so some
boilerplate you say what kind of loosely
type properties do you support and
what's the default value of them and
then you have to say here is the
interface that I'm exposing to the beans
and actually this is part of the problem
and something we're fixing have fixed
here's the interface I'm exposing to
beans for JMS it's messagelistener but
you could actually have made your own
interface and then your developers would
implement that interface and then you
simply invoke that so you would start
deploy the app and then you would get a
reference effectively to the bean and
then you could call that being as many
times as you want then when the
application is under ployed you're
notified you clean up whatever thing
that you've created and then stop very
simple so and then here's also a little
thing that it's the activation spec and
this is sort of an irony is that
activation spec was a required part and
what happens is that under the covers
that little hash map that we have of
name value pairs comes into this Java
Bean so the container will construct a
Java Bean that's strongly typed with
getters and setters and it will take the
strings and munge them into this Java
Bean hand it to the connector and the
connector will well then you get that as
a connector implementation and that's
how the developers allowed to pass
information to you as a connector
through this little Java Bean so the
connector was dealing with strongly
typed data but the developer wasn't so
it's a little bit limited I'll run this
little example this is a temp this is a
fictitious kind of connector it I
shouldn't say fictitious it actually
works but it's you know not entirely
real-world so
so this message urban being is being
being driven by the telnet protocol so
the connector will start a telnet server
inside the Java EE server and then you
can connect into the Java EE server
process and execute commands now the
practical application of it as the way
it exists now is rather limited because
you were forced to specify what
interface you wanted and what the
methods of those were so the implication
of that is that instead of having actual
useful methods almost everybody has you
know the one do and I mistyped it but
and I yeah you know I can't type input
come on
there we go that's what happens okay
this is the way this would probably have
existed should there would there have
been an actual connector for this is
that you would had one big do everything
method and then that would have had to
have been the interface that she would
have implemented to do all of your
commands right yeah oh yes thank you and
please I forget and so please there we
go you're welcome thank you for asking
please continue to do that because it
doesn't make any sense if you can't see
what I'm talking about okay so this is
how the servlet API looks like this is
how the JMS api looks like and basically
the wake-up call was how successful
jax-rs is is you could do everything
that you can do with jax-rs
you could do with the servlet it just
would take you a whole lot longer
because you have to do all the pulling
of the data out of the header parameters
all the casting and parsing of you know
make this string into an INT all this
plumbing and this is the way we consume
JMS currently is I'm going to send you
hey I'm gonna send you an object message
and we'll know what's in it but our code
is going to just accept object message
so I'm gonna pack it all in I'm gonna
give it to you and you're gonna unpack
it all and use it and that's one big
thick fat layer that could go away if we
were to simply open up the API so that
connectors could be implemented in this
way and so effectively that's what we've
done
so this says MDB tomorrow but it should
be changed to MDB today and that one
previous one should be MDB yesterday but
okay so with the new API the connector
is allowed to have a interface which is
a stub now we considered just deleting
the requirement for the interface at all
but given the timelines of getting this
into EJB 3.2 that was simply not enough
time to rework the connector
architecture enough that we could just
eliminate
this interface but for now we are saying
if you have an interface and there's
nothing in it what we're gonna do is
we're going to give the connector
implementation not a beam proxy that
implements just this interface we're
gonna give an at local beam style
so in EJB 3.1 we created interface list
beans right beans without interfaces in
which case you just have a bunch of
methods in there and then anybody can
invoke them and so now we're extending
this capability to the connectors
themselves so here we're saying this
being beans that implement this
interface are using an API that the
connector will know how to understand
and we will give the connector
effectively something that's like a
local bean proxy it will implement all
it'll be a subclass of devine and have
all the same methods and so now instead
of having one big do it method the
connector is allowed to do very
expressive api's and same or jax-rs
style fashion and so now we go from the
legacy single invoke do anything method
to a very annotation driven style API so
here we go we have a fictitious again
working a telnet connector and the
telnet exposing the connector is
exposing an API to the application of
its creation so you as a connector
developer can make any kind of API you
wanted so so here this connector says I
want you to annotate your methods that
are going to be commands with the at
command annotation and you give them a
name and you can have options to those
methods and then go ahead and define as
many of those commands as you want in
your MDB and will invoke them so now
we've basically taken jax-rs api's style
of design and applied it to basically
anything you want because you are
allowed to write connectors and deploy
them into the servers they can start
threads they can have sockets open to
the world and so effectively what can't
you do at this point
it was it's it's rather unlimited so I
think I actually started this in the
other want to make sure I don't have a
running okay so if we run this yes so at
the at the life cycle events you have
start/stop and you have deploy done
deploy inside the connector at the
deploy phase the connector is basically
given the beam class so you as a
connector developer will have a start
event and you'll have a deploy event at
the deploy deploy event you can see the
entire beam class see all its methods
and you can read the annotations that
are yours and decide how you should run
that beam so you can create your own
very expressive api's to do whatever you
want
expose those internally to your
organisation so if you like you have a
platform team or something like that you
could either platform team create the
connector create the API and then you
develops can be let loose to use your
API to consume anything from anywhere
alright so this thing is startup a
telnet server inside our Java EE server
okay I need to
okay there we go so I just logged in to
the Java process so if we saw before I
have these commands I've get set list if
I go help
that's a built-in command that my
connector decides to offer because it
gives a little registry of all the
commands that have been been created and
I say set message to hello Java one
that's not grammatically correct but
that's okay
missing a comma let's eat grandma let's
eat comma grandma okay Oh again there we
go oh I forgot to give a parameter get
yes yeah okay there we go there we go
so if I type get then I can't don't up
commands cuz I didn't implement that get
message hello I mean the point here is
not that getting and setting something
so amazing it's that it's that we took a
client that's not a Java client and we
connected to the Java server over a
standard protocol and we're executing a
being using an API we wrote that being
is an EJB can have transactions can have
CDI injection can have kPa support
interceptors decorators can send C
events it is a beam in every right as a
stateful stateless everything it's all
the functionality of a circle it as well
except now you don't have to shovel
everything over HTTP anymore and you can
create these these api's yourself and
you know as an example of the dynamic
'no stat that you can do let's add
another method here we'll just call it
and then we'll go ahead and rerun that
this time grammatically correct with the
comma in there so that's down here Oh
what's I had a running already okay I
had thought I shut it down but
apparently not okay now we'll reconnect
say help and now we see greet and of
course we execute it and bam so now
there's so many things that are possible
with this I mean if you wanted to
consume email from your server why
shouldn't you be able to do that and why
shouldn't you be able to write a little
API that's very like I say jax-rs style
you know you got your email subject and
you've got your headers in the email
those could be passed in as at header
per am inside the method arguments and
so on and so forth
you could have an SMS you don't take the
jabber implementation that's out there
for various you know talk protocols wrap
that up into a connector make yourself a
tiny little API throw that in your 7
server throw that into the cloud and now
you're a sub messin into your servers
inside the cloud and you don't need to
ssh into an actual physical machine I
mean the the interest it's it's it's
perhaps less interesting if you look at
it from a traditional Enterprise
perspective where you have access to the
box but now we're in a cloud environment
where you don't have access to the box
so being able to access that server in
your own way using your own api's and
your own is a very huge benefit because
that's going to work in any platform
that the cloud platform that supports C
7 it's it's cool it's really neat you
know I I hope that something like this
you know gets very widespread usage and
and much more evangelism and awareness
because we as a you know an industry in
Java
we do everything over either JMS or HTTP
those are the only protocols that we
understand but there are so many really
well written clients out there that are
not Java clients that could connect to
our server is that our Java servers and
do all the work I mean like I said we
just used this you know a telnet client
sassy client we didn't have to write a
really awesome new Java wrapper around
HTTP and then run that Java wrapper on
our command line to get messages into
our server to get commands into our
server we actually just Telenet it into
the server we cut a layer out we don't
need to have our developers install or a
little client front-end we don't even
need to make the client it's it's neat I
think we can do a lot of fun stuff with
this this example is up on github it's
currently under my my little user
account so it's at its deep Levin's and
github but if you just search for you
know I'll just show you the page so you
can like take a snapshot or something
there you go that's the project so all
this source code is there and it runs
just as is it as it is and so the
hardest part about writing a connector
is not knowing what you need to do and
if you have a little example that you
can start with that works that's the
easiest way to to bootstrap the thing
but I really hope that we come out with
like a plethora of really good
connectors because there are Java
implementations of various protocols but
they're just not used it's quite so
prevalently like apache james implements
smtp server in java but I don't know
that it's necessarily heavily used but
if it was wrapped up into a connector or
deployed into whatever cloud platform
you want you could now start consuming
email directly into your java programs
there's you know like I say the jabber
server which well allow to use adium
Google chats whatever the heck you want
to chat and have on the other side Java
process listening but again we don't see
these in EE servers and then we don't
see them in the cloud or environment so
they become toys so now we could
probably promote these things and and
get them into more prevalent use I don't
know what we she's got more slides and
then so that's that's it for this we're
gonna switch back to two marinas slides
but but look for more stuff like this in
e8 because now we'll be able to
basically go back and retool the JMS API
yeah go ahead
yeah well so so here's the here's the
kind of neat thing so say you're on like
WebSphere and you wanted to use jetty to
consume messages HTTP messages wrap
jetty up as a connector deployed on your
server and then there you go so that you
know I you could actually just pick a
different HTTP layer if you wanted to do
that but yeah you could have WebSockets
I mean
like there are a million protocols out
there so you could have all those
protocols go straight into the server if
you wanted to you could do all the stuff
and like I said I show a command line
API because it's not asynchronous so you
can do synchronous calls with this it
does not have to be only asynchronous
stuff anything yeah yes so here the
value that it provides is that the MDB
itself is a being created by the
container and has all the functionality
of any other EJB it's a top-level
citizen so it has the full functionality
of getting us it a transaction user
transaction injected it to it what's
that yeah MDBs basically are any
lifecycle being exactly exactly at this
point there's very little difference
between an MDB
and the session being and so the
interesting thing is like for example
when jax-rs came out it was sort of like
an addition on top of some server
containers but in the very early days
you couldn't do like certain kinds of
dependency injection because the jax-rs
container didn't make it happen and you
had like kind of integrate these things
together yourself on the platform that
you were because the jax-rs implantation
didn't just make this cool neat api and
actually had to instantiate the
endpoints and then call them and things
like that where this style if if this
had existed when jax-rs was being
thought of they would have just made a
connector and they would have just
called the beans that the container
created and then all all that would have
just been there from the beginning and
so it took a while to add that stuff in
later on and there are still sort of
weird compatibility issues you find and
servers a little bit but now this kind
of thing would be if you wanted to just
make a new API you wouldn't have to
make a whole new container environment -
you would not have to make a you know
I'm going to instantiate beings with
this constructor and call these setters
and I'm gonna have this post construct
callback you don't have to do any of
that all that comes for free let the
king let that ET server do that you just
handle the wire transactions come for
free the connector API actually also
exposes security so if you wanted to get
security concepts involved in the
picture all this is a beautiful part of
the connector API it's been an
underutilized aspect of Java EE for a
really long time and hopefully now that
we have an ability to really have modern
api's it will just really thrive and
because one person who writes a
connector and gives it to somebody else
out of work on their server and so the
connectors become a primary asset at
this point
and em being is a jmx specific concept
and MGM X basically is something you can
look up locally or communicate with over
RMI only so could you send email over
JMX no I mean I mean yes you could you
could send data to a server that sent an
email route message but you could not
actually communicate smtp over JMX it's
it's like could could could I kick send
an email over HTTP it's like yes you can
write a trick to do it but you're not
actually using the SMTP protocol and the
same thing with JMX is you know you
could effectively write little JMX
connectors with that but again that
wouldn't be something you could stand
learn standardly to package in your
application and deploy this is something
you could actually standard leda package
in your application and deploy so if
they support if you have a drone a cloud
platform that supports like GlassFish or
whatever or tommy's which is what i like
to work on you know you have this
capability standardly and let's need so
this is continuing with improvements
this is actually changed not so much in
the GB container but egb hub lifecycle
callbacks and the lifecycle callbacks
before the change in the interceptor
spark required the boilerplate code so
that they do not throw checked
exceptions and it's because actually
invocation context proceed declares in
its you know so in occasion projects
proceed declares an exceptional that's
why you need to have eh exception and
rapid into the runtime exception and
interceptor spark said that you now can
have a generic type you know message
signature return object
that will be ignored for lifecycle
callbacks and it allow you can put
throws exception in the method
declaration you are not still allowed to
throw any checked exception from
lifecycle call boxes just to remove this
try finally from the this one catch
exception yeah now you can do the same
thing for invocation types we simplified
rules for designating local and remote
business interfaces so originally in
previous version if you say stateless
and they being implements one interface
is it okay cool if it is one it's a
local business interface but if it is to
let us know what you want and it doesn't
sound right I mean if one of them has
dedication of their own then yes you
need to do something about it but why
you know if you can did you know I
understand who why can't you understand
foo and bar so we said okay eg B
container is smart enough to do that so
now you if you say a implements foo and
bar then both of them I mean all of them
that you have on the list become local
interfaces and the same thing for the
remote so instead of this you know
before you need to say it is Ramon bean
because by default it is a local so now
it is also but if you know if you say
remote and none of the interfaces and
are designated by any means then they
will become remote so MDBs
and quickly yeah we removed unnecessary
restrictions so this you know
prehistoric thing of can't use I would
always said you should you should
exercise here using Java or package
because your files might in in the cloud
might not be there might be shared
between you know in the class that you
need to understand what you are doing
but because most ro
you are accessing files we remove that
restriction current class loader get
resources stream you know such a nature
of things to do you can't do it without
current class loader so the restriction
to access it was remove you still can't
you know define your own big losses but
and I mentioned this eg be timer and
timer handle optional features this was
like the first thing with it into X
entity builds CMP BMP bins and Jack's
RPC endpoints are truly optional
containers are not required to support
them but talking about those egb api
groups to dot x entity beans is a single
API group so the container is not
allowed to provide partial support no
you know BMP only know if they Pro they
must do or all or none and Jack's RPC is
obviously its own group because there is
no connection between the two what we
didn't do and why we that was my pet
peeve the first one interrupting thread
of execution not you know killing thread
but interrupting fluid of execution of a
sink method we ran out of time to do
that
but that would have been the right thing
to do more pruning people were saying
let's pull more and more and more from
the GP sprockets all old stuff it's not
that easy to prove because intro to that
X with Interop are very interconnected
and Interop is something you know not
only EG bees are involved in this so
when we move this request to the
platform the platform expert group said
it's too early to do that if Interop is
too early to do it we can't prove to the
X views separating services from the
components so this is something the
probably the future of eg bees words
were they're going that egb services
transaction was started this time and it
was not easy we thought oh it's you know
so simple we just take it and you know
make it available you can't just take it
it is part of the Java
xyg be packaged and and you you know who
is jeralds don't allow a Piero's don't
allow to take you know to split a
package you can't take part of the
classes from a package you're part of
the interfaces and say ok you can you
know do this part and not that part but
this is definitely for you know where if
you you know give me a crystal ball
where jeebies are going they're going
into separating services from the
component model future alignment with
the other specifications we're
definitely not done timer service more
tea yeah yeah locking your time of
service security there's a big effort to
streamline security around all of the
platform so maybe that will solve that
problem and we're almost on time so in
summary we improved MTB and stateful
session beans simplified enhanced
existing features and try to better
aligned with other specifications all
these links are still valid you can you
know download this pack
go to the project projects to running
JIRA still running and users mailing
list is still running so if you have any
questions about this perk or you know
suggestions for the next version of the
spec definitely subscribe to this Elias
and send emails me being from Oracle I
need to put this safe harbor in a
statement and we're done so we have like
five minutes for questions if we have
any</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>