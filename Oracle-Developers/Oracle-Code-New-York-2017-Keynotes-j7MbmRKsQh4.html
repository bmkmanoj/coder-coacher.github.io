<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Oracle Code New York 2017 Keynotes | Coder Coacher - Coaching Coders</title><meta content="Oracle Code New York 2017 Keynotes - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Oracle Code New York 2017 Keynotes</b></h2><h5 class="post__date">2017-08-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/j7MbmRKsQh4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">developer talk about computers
micro-services Java Java Nene JavaScript
in that vault and mobile we need cool
demo with its robotic arm can just like
an algae workshop hands-on labs good
speakers the roots Douglas Crockford add
in the end about Chris riches
and we're gonna get really big let's go
global all around the world what the
Mary doesn't feel your most radius here
we're gonna call this thing called
developer world now no first code or
codes moral code
or suppose
all right good morning morning everyone
thank you for for a calming subsided to
be here in New York we had great shows
in San Francisco in Austin and now here
it's on get my clicker it's a different
conference for developers by Oracle with
developer community engagement community
speakers we have non-working speakers so
you're going to have a very good
perspective of how cloud development is
is happening the world today these are
like the kind of trends that we look for
to cover an incident for you and for all
the other scenes that we are going to
the events like 20 cities around the
world if you want to if you have the
opportunity to be in a city that where
you have this disease happening you
might have a different content and you
try to make sure that we get as much
content as possible from all these
cities and put put online for you also
to consume and without further notice
what I like to welcome on stage Chris
Richardson our first keynote speaker
this is being live-streamed so uh people
online watching on YouTube thanks for
watching and please welcome this vision
to great thank you um so it's good to
see a lot of people here so this is my
talk on on the micro service
architecture and really the goal of the
talk is well just firstly to precisely
define the term micro service
architecture I'm going to in the talk to
describe how it is in fact an
architectural style and I'm going to
explain what that means why it matters
and then I'm also going to outline some
of the challenges that you will face
when trying to implement the micro
service architecture for your
application and provide some pointers on
how to address some of those challenges
but before I get into that a little bit
about me so I live in Oakland just
across the bay from San Francisco so
like like a whole bunch of the
Oracle people in the room I am on West
Coast time and this is super early for
me I actually got my start in
programming back in the mid to late 80s
building Lisp systems so you know list
being that early functional language
with all those brackets I worked on
compilers and garbage collectors and the
like eventually ended up programming in
Java and my book pojos and action came
out gosh 11 years ago kind of like a
lifetime ago and then back in 2007 I
started tinkering around with it's
really obscure service known as Amazon
ec2 like weird that a bookstore would
would offer that and just totally blew
my mind and I ended up creating a
startup called Cloud Foundry the
original one and that that name lives on
because Cloud Foundry was acquired by
SpringSource right before SpringSource
was acquired by VMware so I ended up
being part of all of that for four and a
half years and these days I pretty much
do everything related to micro services
so I do consulting and training and to
help companies adopt the micro service
architecture I'm also creating a
start-up where we're building a platform
to simplify the development of business
applications that use the micro service
architecture now we're looking for
people to kick the tires so go take a
look and and I've sort of ten years ago
on by and I recovered from the trauma of
writing my first book so I'm doing
another one on on the micro service
architecture and if you want to know
more after this talk about my more
online content go to learn micro
services dot IO and there's collection
of just all kinds of stuff there anyway
the talk so first I'm just going to have
a brief refresher on software
architecture I feel like that is not
something we'd really talk about
explicitly these days in terms of what
architecture actually is and then I'm
going to talk about the monolithic
architecture and compare and contrast
that with the micro service architecture
talk about how the micro service
architecture really is not a silver
bullet and there's a whole bunch of
downsides and a whole bunch of issues
that you have to address when and but
when using the micro service Arc
Heckscher and then i'm going to finish
up by quickly talking about one specific
topic which can be a huge headache how
to manage data in a microservice
architecture or more specifically how to
do transactions and queries because
that's really quite different okay so
let's talk about architecture lots of
different definitions out there but this
is sort of a classic one so it's like
the software architecture is a set of
structures things components and four
elements and relations that you need to
reason about a system so it's kind of
like this thing that you create in order
to be out a reason about it a system
discuss it you know describe it share it
with the stakeholders make decisions and
so on so kind of a lot of words so sort
of more concisely you could say that
architecture is a set of elements of
some form relations or relationships
between those elements and then they
have properties or even more simply it's
a bunch of boxes and lines right so that
you know so that's kind of a sort of
brief definition of architecture so it's
sort of high-level structure of your
system turns out that architects oft the
architecture of a system is
multi-dimensional so in the same way if
you think about the architecture of a
building you know not only is there sort
of the structure of the building the the
bricks the woods the steel the concrete
but that's only one dirt one perspective
there's also the electrical architecture
the plumbing architecture the mechanical
architecture and so on and so depending
on your perspective who you are you have
a completely different view of what the
architecture is and so therefore in
order to describe the architecture of a
system you actually need multiple views
and each view is actually a collection
of elements and relationships or boxes
and lines which have properties and the
classic model for describing software
architecture is the four plus one view
model just out of interest who here is
heard
heard of that because it's sort of any
it's kind of curious because it's sort
of some kind of a while ago anyway so
basically the four plus one view model
is really four views the logical view
implementation view process you
deployment view plus a set of scenarios
to animate those views so the logical
view is comprised of classes and
packages so that's basically concerned
with the functionality for the elements
of the classes and packages and the
relations of the relationships between
those classes inherits inheritance and
associations and the like and so that's
sort of the functionality so classic
object-oriented model then there's the
implementation view where your classes
are packaged up in the modules like jar
files and then those jar files are
packaged up to form some form of
executable component which in the Java
world would be a executable jar or war
file or heaven forbid an air file and
there's relationships there are the
dependencies between those modules and
then there's the process view which just
describes the process architecture of
your system so it could be a bunch of
Tomcats database servers you know just
pip processes and then the connections
between those elements are actually in
two process communication and then
finally you have the deployment view
which is really the machines that your
processes are running on so today those
are invariably virtual machines
interestingly this used to be called the
physical view but you know sort of
infrastructure today is heavily
virtualized and the connections between
those components are sort of the netlist
of the networking element and then
finally you have the +1 those are the
scenarios that whichever derived from
the stories and the use cases that
animate the views so they could be
sequence diagrams and so on so we've got
all these four different or in total
sort of five different blueprints that
collectively describe the architecture
of our system and then another concept
is an architectural style
so once again there's a lot of analogies
in the real world right where buildings
often conform to a particular
architectural style Georgian Victorian
Art Deco and so on get a great bunch of
pictures if you google architectural
style and that really just kind of
defines the components that you can use
and how those components relate to one
another and so classic example of an
architect of an architectural style is
the layered architecture and that
organizes the elements of review into a
set of layers but it would be with
constraints so each layer has to have a
well-defined set of responsibilities and
also one layer can only depend on the
layers below it or possibly just the
layer immediately below it if you have a
strictly layered architecture so that's
an example of a start of an
architectural style there are many
others pipes and filters and later on
you're going to see how the monolithic
architecture and the micro-service
architecture are examples of styles so
what who cares why does this why should
we care about architecture well it turns
out that if you look at the requirements
for an application there are really two
categories of requirements there are the
functional requirements right which
really define what the system does and
requires deep knowledge of the domain
and then there is a non-functional
requirement there's you know software
quality attributes or the illah T's and
that's where architecture matters you
can implement a given set of functional
requirements with almost any
architecture it might be difficult but
you can do it and I'm sure many some of
you in the room are working on systems
that are basically big balls of mud and
you know that you can still kind of meet
the functional requirements right but
other aspects of the system the
non-functional requirements could very
well not it could end up not being met
and there's a huge list of function on
functional requirements so I have a few
of them here you know the usual ones
maintainability security scalability
reliability and so on but the ones that
are
particular interest to the first four on
this list that's not to say you know
obviously scalability security security
and reliability don't matter but the
first four are particularly interesting
because they determine how fast you can
develop your software and if you think
about sort of the environment today
right businesses want to innovate faster
you know they're under increasing
commercial pressure there was CEOs lie
awake at night worrying that some
fast-moving Silicon Valley company is
going to disrupt their business they're
going to get Lubert or Netflixed and so
what that means for us is software
developers is that we have to build
better software faster we actually have
to do a much better job of keeping up
with the needs of the business and
develop software in a much more timely
way and that software is likely to be
much more complex and the ability to do
that is directly determined by the
quality attributes of our architecture
in particular we really have to reduce
lead time minimize the amount of time
from a requirement being defined to that
code that implements the requirement
actually being running in production or
being delivered to the customer and we
also need to significantly increase the
deployment frequency so no longer is it
ok to do a release every month right or
every week we really should be releasing
many times a day you know the net effect
is we should be practicing continuous
delivery which is sort of one element of
modern software development we also
ought to be organized into small agile
autonomous teams but then there is this
architecture piece because that really
does determine how successful we can be
a continuous delivery and so on so
that's that sort of a brief recap on on
sort of some architectural concepts so
then let's go to look at the Mart is a
monolithic architecture versus the micro
service architecture so if I look back
over the years that pretty much every
Enterprise Java
application that I've written yeah
starting back with I get the EJB one 20
21 can remember back that far
um that's forgotten them you know so you
know I built applications that from a
logical perspective were nicely layered
and nicely modular but you know when it
came to the actual for the
implementation of them all all of those
components would just be packaged up
into a single executable so to speak a
single war file or a single ear file and
deploy it on a server like Tomcat so we
go from a logically layered and modular
architecture to that's just
blob of stuff it turns out that this
monolithic architecture is simply an
architectural style that structures the
application as a single executable unit
so it's sort of a structure it's an
architectural style for the
implementation view of our architecture
and it turns out that this is not
necessarily a bad thing if we're
building small applications a monolithic
system actually has good quality
attributes it's actually easy to
maintain it's easy to evolve and test
and deploy I think we can all look back
you know when we started out on a
project everything was easy right we
could get stuff done quickly but the
problem you have is that if you're
actually successful your application
keeps growing right we don't just sort
of write the software and stop
development we keep adding more code so
this small monolithic application just
keeps getting bigger and bigger and
bigger yeah and then if we're even more
successful then the team will keep
growing and growing and growing so we go
you know many products start off with a
small team of just like three people but
given enough time that team will just
end up being huge and we might split up
into sub teams working on particular
two specific functional areas but you
know over a course of say ten years you
know which is well even just five years
you can go from a tiny team working on a
tiny application to a massive team
working on a massive monolithic
application and almost invariably
what will happen is that you end up in
what I call monolithic hell just kind of
shares is actually this is a the Pyramid
at Giza which is actually a beautiful
structure but it is really big right so
you end up in the situation where
basically all aspects of development are
incredibly painful you know even just a
simple fact that this monolithic system
is just simply too complex for anyone to
understand it's also extremely likely
that the internal modularity is broken
down as a result of that because no one
really understands what the structure of
the system is so it's sort of too big to
understand it's probably going to take
an incredibly long time to test and
deploy and so basically any sort of
notion of agility just becomes
impossible and your development just
gets slower and slower and slower and
you end up failing to sort of meet meet
the needs of the business and then
what's worse is you know for a
long-lived application you end up being
locked into the technology choices that
you made at the start of the project not
because it's simply too expensive and
too risky to rewrite it to use a more
modern technology and so you know every
so often you can run into couple
organizations that have that have an
application that's from this built using
sort of ancient technology I mean one
company I ran into they started off
state they quit like ten years ago they
quickly worked up a demo that was so
successful they started selling it and
then you fast forward ten years and
they've got a milli
half lines of code and half of that
would store procedures and I think
that's a really common scenario where
you know you're out you basically end up
outgrowing your architecture and then at
that point it's difficult to maintain
you can't evolve it you can't test it
you can't deploy it in Welli in a a July
and you end to end up being in this
world of pain and I think I don't think
it's exactly inevitable there are a few
exceptions to this rule but I think for
it you know the odds are that eventually
you will outgrow your monolithic
architecture and end up in a world of
pain so the solution of course is to
adopt the microservice architecture and
there's a bunch of words on this screen
but basically what the microservice
architecture is in a nutshell is it's an
architectural style I kind of like the
monolithic architecture and it
structures an application as a set of
loosely coupled services so in other
words we functionally decompose the
application into a set of services and
we want to do it in a way that they're
loosely coupled and then not only that
these services want to be organized
around business capabilities or which is
somewhat of an elusive you know the
definition of that is somewhat elusive
but sort of business functions as
opposed to technical sort of functions
so if you think about what a business
does you know this is kind of in the
realm of business architecture a
business has a set of capabilities so I
can online store it can it takes orders
it will manage infantry it will manage
deliveries and there's likely to be and
also do marketing and sales function if
you're an insurance company you're going
to have capabilities like kind of Clint
like application processing claims
processing under well under right
and so on so these are all sort of
functions that a business does and you
can identify these capabilities by
analyzing sort of the structure of the
organization identifying what areas some
particular P groups or people have
expertise in and that will help you
define what these capabilities are and
then you can just you can basically map
those capabilities into a set of
services and so that in a nutshell is
the definition that micro service
architecture and what one interesting
characteristic of this definition is
that I really didn't talk about size
right and it's not because size at some
level is really secondary I mean later
on I mentioned some constraints on the
size of of a service and this highlights
one of the problems with the micro
service architecture as a term because
the first thing you hear is micro right
which kind of suggests that these
services should should be tiny which is
which is why you know over the years you
see people saying well a service
shouldn't be more than a hundred lines
of code you know that comes up once in
awhile or a thousand lines of code it
shouldn't take more than two weeks and
it turns out that I think that that or
actually another one is it should be a
single rest endpoint I've seen that with
that one as well turns out that all of
that sort of confusion results from the
term micro service and so in a sense I
kind of think of the micro is being
silent and you really this is just a
service architecture instead of a micro
service architecture and you know
ideally it would have been nice to have
called a service-oriented architecture
except except that that has such
terrible connotations because of the
direction that sower went in where it
became heavily vendor driven apologies
to any companies in the room that has
solar products
but in it or you know another term would
just be distributed architecture right
but went on minutes from a marketing
point of view those terms would not sell
and I think this microservice
architecture really from a marketing
perspective was brilliant it just kind
of led to a whole bunch of confusion so
so so you know in terms of what what is
a meaningful yeah what would be the
scope of a service right so it has to
implement meaningful business
functionality and that you could throw
in words like cohesive single
responsibilities and so on but it should
be should do something that is
meaningful to a business person and then
it should also be capable of being
developed by a small team and this is
one of the really critical things right
like and if anyone's been on a project
where there's like 20 people on a team
right you can't really have an effective
meeting with 20 people you know your
daily stand-up will be quite unpleasant
right and there's sort of a whole bunch
of reasons why a team should be small
six to eight people or even less right
and so later on I talked about it's a
little bit more whether it should be a
very tight alignment between your
architecture between your services and
the teams that can desert will develop
them so the idea is that each you're
going to have teams and each team is
responsible for one or more services and
so that will constrain the size of your
service and then also from a development
perspective the lead time through your
service time from concept to deploy code
should be small and the deployment
frequency should be small should be
virtually should be very high and those
are really the constraints on sort of
the scope of a service and then that
sort of leads to a second thing right
where I think of micro services as a
short as the term micro services as a
shorthand for the phrase micro service
architecture
it's just sort of a you know condensed
way of saying that and as I described
the microservice architecture is really
an application architecture is an
architectural style for your application
and so even though the term
micro-services sounds like you could
just drop the ass and have a
microservice in reality that the term
micro-service is not particularly
meaningful and hence that the title of
my talk you know we're talking about the
architecture of a system and so
therefore it doesn't make sense to say
things like we can use an user micro
service for this or can we use a micro
service for this or is this a micro
service right it does it's not even
though that the terminology wouldn't
makes it sound like those things make
sense they're not particularly
meaningful questions and so micro
service is all here is an architectural
term and they always and it's the
structure of your system and not so much
to do with an individual service what's
interesting you see people out there
promoting their micro service framework
and more often than not it's actually
just simply a RESTful API framework or
something like that so something to bear
in mind there really isn't such it's
really best to not think of a micro
service so you know here's what it is
the online store sort of restructured as
a set of services so you could imagine
having services like a catalogue service
a review service and order service and
so on so each of these sort of business
functions gets implemented by a
particular service then there's what's
interesting is each service will have
its own private data which in a sense is
having its own private database so you
multiple services could share the same
database server but the key thing is is
that the data for a given service is
is encapsulated by that by that service
which actually has a huge impact on how
you do transaction management inquiry so
that sort of the structure of the
backend set of services with their own
private data and then there's a whole
bunch of front-end stuff like that
sitting in front of them is an API
gateway the axis of facade and so on to
the various clients in your system so
you're basically taking what was what
had previously been just your monolith
and you have broken it up into a set of
services and then when you do this you
now even though your system is large and
complex your quality attributes are
still quite good and that's because for
the from the perspective of a developer
who's working on a particular service
they're sort of world is a lot simpler
they have this basically ace much
smaller application that they're working
on yes they have to conform to
particular api's you know they have to
implement a particular API that and then
they might consume the api's of other
services but their universe is a lot
simpler and so they're able to easily
maintain their code you can easily
evolve the technology stack which is
huge a small service is essentially a
much easier to test and a service by
definition is independently deployable
of any other service and almost always
because a given service will it will
basically be a process you know
regardless of whether it's packaged up
inside a virtual machine or packaged up
inside a docker container it can be
scaled independently as well so I should
say that sort of scalability is really a
secondary goal of the micro service
architecture the primary goal is to
accelerate the velocity of software
development by tackling complexity so
you then end up in a situation where in
an order to practice continuous
deployment you know the micro service
architecture ends up being a key enabler
of this architecture
because service is a because you end up
with an architecture that's testable and
deployable that directly enables
continuous delivery and also because
another key part of continuous delivery
of a small autonomous agile teams the
fact that you've broken up your
architecture into a set of services
means that each team can now own their
particular service or collection of
services which enables them to
independently develop tests deploy and
scale their services without having to
coordinate with any other teams so ends
up being a really key enabler of
continuous delivery and deployment of
complex systems and then the last point
you know benefit of the micro services
architecture that I want to stress is
that it really does enable you to evolve
your technology stack and that's because
you know these services aren't necessary
unnecessarily micro but they're not huge
either so that means that if you're
making major changes to an existing
service you can just throw away the code
and rewrite it using a more modern
technology and certainly when you're
starting a brand new service you can
also just pick an entirely new
technology stack so it just lets you
incrementally evolve your technology
stack one service at a time which is a
lot a lot more practical I mean it's
very every time you're starting a new
service the developers could actually
pick that what they think is the best
technology for that service it doesn't
actually matter provided that the
service implements the required API
right it could be node underneath it
could be Haskell it doesn't actually
matter I mean obviously from an
organizational point of view you need to
have some kind of governance but you
know there's a lot more freedom and then
the key benefit it lets you evolve
evolve your technology
and then also it lets you sort of
experiment with new technologies in a
safe way so you know for instance you
know you've decided that while we're
going to experiment with go Lang's
right because golang is cool Google uses
it and then you actually you write a
service using golang and then you decide
that well you know i think i much prefer
more a higher-level language right this
sort of c4 that 1990s version of C
doesn't really work for me right and so
let's use nodejs because no js' is cool
right so you're sort of in this world
where you can experiment with new
technologies and if they don't work it's
not a huge disaster yeah on the one hand
you've implemented eight a service using
some technology that you do not want to
keep but it's not a massive multi-year
development effort that you've just sort
of wasted you've got the cert you've now
have a service that you can eventually
rewrite using some using a technology
that you prefer so it's a safe
environment to learn experiment and sail
safely okay so that's sort of the
benefits of Micra services you know for
large complex applications they're
almost always a good choice I mean
there's a whole bunch of fine print when
they might not be the best choice
because for the reasons I'll get into in
a minute but it's really important to
remember that you know in software there
really are no silver bullets so this is
Fred Brooks he wrote you know mythical
man-month
classic textbook on sort of software
engineering back in the mid-70s and
thirty years ago he get he gave a talk
and wrote a paper saying yeah there's no
silver bullet you know that's sort of
another set in other words there's no
perfect technology which is sort of
ironic so I feel like we as developers
are constantly chasing the latest shiny
bullet right still shiny silver bullet
convinced that oh if we just pick this
technology everything will be wonderful
but in practice every and we sort of
follow the Gartner hype cycle and all
that but in practice you know every
technology has downsides and that's
certainly true of the microservice
architecture um you know what's
interesting is from the perspective of a
developer their world is a lot smaller
and it's a lot simpler but on the other
hand you're now developing and operating
a distributed system which is just a lot
more complex and you don't want to
underestimate the complexity of that so
even from a developer point of view you
think you know in a monolithic
application when you want to invoke a
module that's just a method call you
don't even think about it whereas in a
distributed system you now have to deal
with inter process communication you
also have to deal with partial failures
that service you invoke might not
respond in a timely way and you have to
deal with that very carefully and then
as I showed this your data is now
scattered over multiple databases and
encapsulated behind api's which
dramatically impact how you do queries
and transactions testing can be a lot
more complicated especially interesting
the service is smaller so it's easier to
test but that service might have to
could very well have dependencies on
other services and so how to effectively
test it can be a challenge good news is
there are strategies for that and then
also deployment is a lot more
complicated before you had one
application and yeah you'd run multiple
copies of it in production for
availability and and throughput but now
you have many where you've got
effectively an order of magnitude
possibly more many applications that you
have to deploy so in other words there's
many more moving
that have to be deployed managed
monitored and so on so it's a lot more
complicated in other words the good news
is though that there are you know today
there are runtime environments that
automate this for use whether that could
be a docker base orchestration solution
like kubernetes or docker swarm or a
path like cloud foundry so yeah so
there's a bunch of extra work that you
have to do but the good news is there's
a bunch of solutions to that but it does
mean that you really have to ask the
question you know our micro service is a
good fit for my application you know do
I have a problem with development
velocity that results from having a
large complex monolith and so therefore
would refactoring into a micro service
architecture actually solve that problem
for me is it worth the the added
complexity and then also once you've
decided to use the micro service
architecture there's a whole bunch of
sort of design issues that you now have
to deal with like how do I break it up
how do I deal with in a process
communication how do I deal with service
discovery how do I do testing so on and
so forth so it's sort of a non-trivial
undertaking so to help with it and the
answer to these questions is that is
that it actually depends there isn't
just one right answer to these questions
you have to evaluate the trade-offs
carefully and so the hell without one of
the things I've been working on for the
past couple of years is a micro service
pattern language so it's a collection of
patterns that solve problems in the
micro service architecture but it's a
little refresher on patterns right so
you know we will probably all heard of
the Gang of Four book that's a
collection of object-oriented patterns
but in general a pattern is a reusable
solution to a problem that occurs in a
context and that's really important
because it says that in one context you
might solve
program one way and in a different
context you would solve it in a
different way
you don't just blindly apply the same
solution over and over again and not
only that the structure of a pattern
provides an incredibly useful format for
describing a technology or describing a
solution because it has a name right
which is useful to refer to it makes it
easier to discuss the pattern you have
to describe the context the situation
within which you're solving the problem
you've got to describe the problem you
have to describe the various forces or
issues that you're trying to resolve
within when solving that problem
and they can be conflicting you also
obviously have to describe the solution
right and then there's two elements that
are really essential one of these is the
resulting context what are the
consequences of applying this pattern
and I'm going to talk more about that in
a minute
and then there's also this notion of
related patterns so patterns are can be
related in one of two ways a pattern can
be an alternative solution to this
problem so in a sense the monolithic
architecture and the microservice
architecture are alternative solutions
to the same problem of like how do i
architect my system so the pattern
format requires you to actually say well
you could use this pattern but maybe you
should go consider that one so it forces
you to consider alternative and then not
only that the other kind of related
pattern is well when you apply this
pattern you not yet this is in the
resulting context there's a whole bunch
of issues that you have to address but
here are the related patterns that will
solve those those problems and that sort
of driving that you're going to see
driving the structure of the entire
pattern language so if you like think of
the microservice architecture we write
it up in pattern form you know it's its
resulting context will definitely listed
that
sets about how makes development a lot
easier but it's format forces you to
describe the drawbacks which is really
key
you know today whenever we talk about
technology we tend to actually ignore
the drawbacks and just treat everything
as a silver bullet the pattern format is
an antidote to that and then it also
forces you to describe the issues that
you have to address so like on that
slide where I listed all of them there
was like a whole big long list of
questions those are actually problems
that result as a consequence of applying
the micro service architecture and the
pattern language has patterns to address
those so you know so this is the actual
pattern language which I'm sure is
almost impossible for you to read I
can't even read it on my screen here but
if you go to microservices dot IO you
can see the much more readable version
of this but there's several different
groups ah this monitor is easier for me
to read um but there so there's a core
pattern so Mike monolithic architecture
versus versus micro-service architecture
and then all of the other patterns are a
consequence of applying the microservice
architecture so in other words they
address issues that arise when you apply
the microservice architecture so they're
a deployment pattern so as I mentioned
deployment is more complicated so there
are multiple ways of deploying services
there are IPC patterns am I going to use
messaging am I going to use RPC it all
depends there a trade-off
there there a discovery pad so if you
want to make an HTTP request to a
service you have to know the network
location of a service instance that's no
longer easy to that's not sort of
trivial in a modern architecture so you
need a dynamic service discovery
mechanism so there
of their patents to do with the public
interface to your system the most
popular one of course is the API gateway
pattern there are patents to do with
observability how aren't you know you've
now got this complex system where
requests can hop from one service to
another how on earth you actually figure
out what's going on so that you can
diagnose shooting and so on so there are
a bunch of patterns around that such as
distributed tracing and log aggregation
what else do we have
Oh testing patterns that let you test
services in isolation so strategies for
basically simple fast and reliable
testing and then there is a whole set of
application patterns that are primarily
about how to deal with date with
distributed data management in the
system and there's some other ones in
there as well like circuit breakers for
dealing with partial failure and so on
so that's sort of the pattern language
and that can act as a guide to enable
you to a decide whether you want to use
the micro service architecture and B
whether and then if you do how to solve
all the various problems that you're
going to encounter at that point and
enable you to make much better design
decisions so so that's the pattern
language so they're sort of remaining
time I want to talk briefly about one of
the key challenges in the micro service
architecture which is how to manage
distributed data in this application and
as I mentioned you know one of the key
aspects of the architecture is that
services don't share data their data as
in table um if you're using a relational
database as in tables is private to that
data you can think of it you know in the
same way that a class it's filled to
private to it and it's sort of
considered a design smell if one class
access
the fields of another another class
right fill it so your data should be
private so in the online store you're
going to have an order service it's
going to have its order database
containing the order table and other
ones of course likewise you have a
customer service containing a cust with
a customer database and a customer table
and those two services do not directly
access one another's data they can only
go through api's and it mate it and you
know as I mentioned earlier that that
they might be using the same database
server or they might or in theory they
could also be using completely different
database servers as well so there can be
you know quite so that they can be
incredibly decoupled but that creates
some interesting problems especially
around managing transactions so if you
think about why do we manage you know
why do we use transactions in our system
and it really is to maintain data
consistency and another way of putting
it it's a way to enforce invariants or
business rules so you could imagine in
the online store maybe there's a
customer has a credit limit so this rule
has to be enforced at all time so when
the system wants to create a new order
it actually has to verify that that this
new order will not violate the
customer's credit limit so it sounds
trivial right in a monolithic
application it really is you simply
begin a transaction you find the
existing orders you find the credit
limit you make sure that the new order
won't exceed the credit limit and then
you insert the new order into the
database and you commit the transaction
and what's really beautiful about the
asset transaction model is even if there
are simultaneous transactions that are
trying to create orders for the same
customer these transactions will be
serialized and happen it logically
happened one after the other
and it will ensure that this business
rule is violated at all times and we
just kind of rely on that you know in a
sense that sort of like oxygen we just
assume that this capability is there but
if you look at this in the context of
the micro service architecture right
orders and customers are in different
services you can't directly access them
in this way just you know from a sort of
straightforward transaction not only
that because they're in different
services in order for this to even
attempt this you would need a
distributed transaction that's spanning
multiple services and potentially
multiple databases but then it turns out
that for a bunch of reasons you cannot
use for the distributed transactions in
a modern application you know what with
just the practicalities of that the cap
theorem and also the fact that it is
sort of simply not fashionable right to
use - two-phase commit in modern
applications and so it's sort of like
what if we can't use traditional
transactions how on earth do we maintain
data consistency it turns out that the
solution instead is to use and
eventually a derivative and eventually
consistent approach known as sagas so
instead of a distributed transaction
that's spanning multiple services
instead you use a saga which is a
sequence of local transactions where
each step of the saga emits an event or
emits the message that then triggers the
next step of the saga and by you of
using a sequence of transactions the
data will eventually become consistent
assuming no other updates are happening
in the process so that's sort of the
sort of the more modern way of managing
transactions is eventually consistent
event-driven sagas and so the way this
would work in the online store is a
request comes in to create an order it
would create it would actually create an
order right away with
doing any validation publish an event to
say I've created an order that would get
reprocessing us which would reserve
credit info and in the customer and then
amid an event indicating the outcome of
that credit reservation either it would
be a credit reserved event or a credit
check failed event which would get
consumed by the order service which
would then either approve or reject the
order so it's sort of like eventually
this business rule is enforced it turns
out it's a much more complex programming
model in a sense that the order is
created and hence visible in a in a in
what you could consider an incomplete
state and that that can make the
application a little bit more complex so
there's some chatter sort of it's more
challenging from the developer
perspective but it's the way of
achieving consistency in a modern
application so there's one little
wrinkle in this which is actually the
subject of a whole other presentation
but in order for sagas to work you need
to be able to reliably update your local
database and publish an event and if you
think about the classic way of doing
that in an enterprise java application
you would actually use a distributed
transaction involving your JMS message
broker annual JDBC database but we can't
use that so in order to sort of even do
it at a low level perform this operation
atomically and reliably we need a
different mechanism there's a variety of
probe approaches but the one that I'm
sort of super interested in comes from
sort of the field of domain driven
design and it's known as event sourcing
where instead of having separate State
and message publishing all there is of
the event so we actually persist each
domain object as a sequence of events
that when an order is created an order
event
is inserted into the event store which
makes it available for publishing and
then when the order is approved we
insert an event which also publishes it
and this and then when it shipped we
insert an order shipped event and this
is the only sort of this is the source
of truth for the state of our domain
objects in in the system and it's sort
of combining basically a message broker
in a database into one I said it's like
subject of a whole like hour long talk
on how this works but it's it's a super
promising technique so that's how you
maintain data consistency event-driven
sagas and then implement your business
logic using events or thing so the final
thing I want to talk about really
briefly because I think I've run out of
time is how to do queries like you want
to find recent valuable customers write
trivial query in a monolithic relational
system but in this in a micro service
architecture you can't do this because
those tables are in different services
and then what's more if you've used
events or thing a trivial where Clause
like this isn't actually easy because
you don't have a column with the current
state you just have a sequence of events
in the database and so the solution is
to use an approach known as CQRS which
sort of once again kind of comes from
the domain driven design well to some
extent and the idea is basically is for
all of your queries you have met you
implement a materialized view that is
easily queryable so it's basically sort
of denormalizing and your data and you
and you use the stream of events that
are coming out of your business logic to
keep the view up-to-date so in a way
it's a generalization of using
elasticsearch on the alongside a my
sequel database
to implement text search queries except
that we're sort of keeping that with the
generalization of that and we're using
events to keep it up-to-date in near
real-time so you end up with an
application architecture that looks like
this where you have numerous views each
one is supporting a particular kind of
query like if you've got a REST API and
you just need to hand back globs of JSON
you might use MongoDB if you're using
text search you could use elastic search
if you're doing graph searches you're
using neo4j and these data stores are
all kept up to date by subscribing to
the stream of events that are coming out
of your business logic so once again
that is the subject of a whole other
talk but it encouraged you to go check
it out so anyway that's my talk so in
summary right like the goal of
architecture is to satisfy
non-functional requirements the
monolithic architecture is great for
small applications for the micro-service
architecture it's extremely likely that
is to be a good fit for complex
applications you can use the micro
service pattern language to decide to
sort of guide your decision making and
ultimately you're going to end up using
an event-driven architecture to deal
with transactions and queries so anyway
thank you for listening
I hope that you found it useful and if
you want to know more here's some
contact info so thank you
thank you so much Richard so um just one
thing um we're gonna have Prince
answering questions over reddit so while
we have the ask me anything series on
reddit and 1 p.m. today
uh sorry 10 a.m. Pacific yes 1 1 p.m.
today creates will be online on reddit
so if you want ask any any further
questions if you want I mean you can
just find him at the event and in the
lobby similar and asking questions we
don't need to use technology the
community okay exactly
but for the folks watching the live
streaming you can just go online and
read it in the ask Chris any other
questions of it there um so for the next
keynote I'd like to welcome our meet
slavery we also have stood on the wall
that we'll be talking about Michael
services and api's and chatbots
so thanks thank you thanks really good
morning everyone thank you for spending
the day with us I know it's a lot of
commitment so appreciate that I just
like Chris I'm also from the Bay Area so
I'm also trying to keep awake and almost
felt like I was back in computer science
lecture and one of my universities so
it's very good to kind of have that kind
of a conversation so thank you again
Chris so what we wanted to do in this
talk was to give you an idea of what we
seeing from the developers perspective
what kind of technologies which are
evolving and what are things which are
changing as we move forward to building
the modern application so the goal is to
really talk about how your life as a
developer is changing and I do believe
that the it is really exciting time for
developers today when we were building
applications many many years ago a lot
of technologies which we would have
liked to have but not available in 15 20
years ago but over the last four or five
years the technology and the stack as
well as the choices have evolved
drastically you talk about things like
containerized applications we talked
about micro services we talked about
chatbots machine learning AI a lot of
buzzwords but
a lot of real related technologies also
available now which you can really
leverage and start using very quickly
and easily without having to write and
build everything from scratch so I think
the choices you have as well as the
opportunity to kind of build
applications very quickly and easily has
really made it very useful now as we
move forward so what has changed for a
developer and this is really I mean you
look at the left-hand side this is
really how we used to build applications
many many years ago and it's still kind
of common in many many areas as well but
going away from a hard-coded
elements for example where you have to
really write very difficult applications
to more dynamic assembly where things
can happen much more gradual quickly
much more easily with blended
experiences so the application you build
doesn't have to be only in one channel
but set up the multi-channel kind of
application build one's deployed in many
ways 12 to 18 months development cycles
now moving to zero time cycle our
development cycles with continuous
delivery continuous integration as well
as being able to really dynamically
assemble applications and deliver them
very quickly as well
centralized teams so the hierarchical
teams where you have a big engineering
org really building one application one
kind of layout and everything together
to more distributed teams we have
engineer's pretty much distributed and
they can really collaborate and work
easily and quickly together without
having to be in the same room or same in
one a same place and still deliver
applications much more easily right so
it also be having to have ability to
have different preferences so we have a
lot of engineers and developers who
would use different stack different
tools and they can still build an
application which comes together without
having to have a common understanding of
all the different tooling around it as
well right monolithic applications you
heard from Chris for example about all
the ways we use to build applications
now the microservices concept or smaller
components or service-oriented
architecture based things be able to
deliver those applications in a much
much granular fashion building just
another app is what used to be the kind
of everybody's building an app who now
doing engaging interfaces where you are
now taking that application data
information
and providing that through a different
mechanism as well not through just a web
browser or through client application
running a thick client application but
more mobile watch those kind of things
are also becoming white interesting now
and then developing up functionality
first which is very common and still we
do it as many of you probably are aware
building the functionality first and
then deciding how anybody will interface
with it or how they will interact with
it to becoming API first kind of design
paradigm so really thinking about what
are the interfaces how you will have
somebody else interfacing to that
application what kind of API you want to
provide has becoming kind of the way to
design as we move forward so you kind of
support all these things there are lots
a lot of development requirements which
are coming out you need a platform which
can support a lot of this different
paradigms which are coming out you need
to be have a polyglot microservices they
can support multiple languages services
which can run in different stacks as
well as bring a lot of these things
together very easily and manageable
given that with micro services you've
heard how difficult it can be to really
debug test and collect and run those
applications micro services together how
do you really have a platform you can
bring it together and manage those
things easy then quickly it becomes
important API management when you're
building an API how do you have a
lifecycle around it how do you really
support the whole requirements
associated with distributing to that API
is as well as managing them and making
them secure as well as governance around
it becomes an important requirement as
well the DevOps tools there's so many of
them today how do you pick those
different tools as well as how do you
make them available to you in your
platform and how do you really have
those really working together to really
have the CI CD kind of delivery as well
as be able to have an automated way of
building your pipelines right chatbots
and mobile so how can you building this
application the platform also needs to
be able to support taking the
application and providing that
interfaces through different mechanisms
as well including charge BOTS and mobile
performance monitoring so how do you
tune your applications you need to be
able to analyze and understand in real
time the changes which are happening in
the application usage as well as metrics
you need to really monitor so whole
application and performance monitoring
can become real time so that you can now
make changes to your underlying
infrastructure to support the demand you
might be getting and then delivering the
thing to a containerized based
infrastructure so be able to take those
applications deliver them in multiple
platforms without again having to
rewrite them for the individual
platforms as well so those are the new
requirements we starting to see come up
and the goal really should be to really
look for platform we can provide you
this as part of the infrastructure as
part of the platform without having to
now choose each of the species and
bringing them together yourself so what
we going to do as part of this
presentation is also show you a live
demo of how you can build an application
and how you can build chat boards and
related stuff to interact from a fan
perspective to a we just took an example
of Golden State Warriors kind of
ticketing environment I'm sure many of
you are not fans of Golden State
Warriors here so apologize for that but
we are sorry but anyway just taking the
example of what we can do with a
building in real time application
without having to write all the
interfaces and write without having to
do a lot of the backend programming and
do this very quickly so we take that
example and show you how a fan can
interact with that through a chat board
building through api's and
micro-services and deliver that kind of
new-age interaction as well as user
experience to that fan just get the
started I will talk about API first
design and development and as many of
you know and I'm not sure how many of
you have been starting to think about
API first design kind of paradigm but to
really make sure when you're starting to
think about API is you really need to
start thinking about what API management
and what are different pieces you need
to worry about the API by itself can
definitely make sure that you can have a
ability for anybody to interact with
your application and if he as a API is
not a new concept anybody who does any
usually eventually build some kind of
interface to that application or a
service or whatever else you might want
to show to another user but it does
improve the agility where you are able
to now quickly transform and interact
with a lot of other pieces of your
infrastructure as well as an application
so the speed of development becomes
easier interaction integration with
other applications becomes easier as
long as you're really defining and
designing them very well and then you
can meet a lot of the user demands other
part which is also important with API
management is around the security of the
API is given that you'll be exposing
those API as well as interfaces to a lot
of other users be it other partners or
inside your application ecosystem
anybody else building an application
around it will be using this API so how
do you secure it how do you monetize it
how do you make sure that you're rating
it properly and providing the right slh
and then be able to take the visibility
from the API since of the usage and
taking that patterns to really make sure
when you're delivering those api's and
the services associated with the api's
are meeting those SLA is as well so the
whole API management beyond just
designing API the whole governance
around it becomes very very critical and
important element of delivering api's so
for that what we've been doing at Oracle
has been around this whole lifecycle of
API and I think it's important to think
about a life cycle where it's not just
about building or designing an API but
also be able to kind of secure them can
be able to make sure somebody can
consume it monetize it and analyze it so
you have the whole lifecycle around it
as well and for that we also recently
acquired a company called apiary and
we'll show you a demo as part of the the
thing I talked about earlier where you
can easily do a design and governance of
an API as a developer like today that
two hundred twenty thousand plus API
developers who are using apiary tools
have designed very quickly an API for
multiple platform multiple languages and
expose them and put that in the
repository which can be easily used and
shared so you can design a prototyping
on api's you can do run mock tests you
can be make sure that the API policies
are easily available and exposed and
make that part of your whole governance
a paradigm so if you look at the
architecture for kind of supporting API
platform the key thing is really you
have to have from the perspective of an
API manager be able to go to a platform
just really define the policies you want
to have associated with your api's API
designers will be able to build the
api's and make sure that that
information can be available to anybody
who's running it in the platform and
then you can expose those things as a
services in a gateway where the port the
analytics for that particular
information can be gotten from the
platform as well as the policies you
have defined as the developer can be now
real-time pushed out to the gateways
where those policies will be managed and
monitored and in real time applied to
the API so anybody who's using those API
is the right policies are really being
used on top of that right and an
application request when it comes in the
response associated with that is done
based on the policies and the SLA is as
well as the different governance things
you have defined in your API design and
it can be really delivered as part of
that and then you can take these
gateways and really deliver that on any
kind of platform it can run on premise
it can run on AWS as your it can run on
Oracle cloud or you can run on any other
place you might prefer those gateways to
be delivered so there's very scalable
architecture as part of the platform
right and the consumers are basically
now able to easily take the api's and
deliver those things as use the api's as
part of an application and get the
experience and that can change
dynamically underneath the covers
without having to worry about how they
were delivered and how those
applications were built and this is a
very important element when you talk
about micro services you talk about
different ways of building applications
without an API design and without having
the right kind of mentality from design
perspective it becomes very difficult to
scale out the platform and really build
this new next generation cloud
applications to make this real I'll have
in sensor from a Pyrrhic do a
demonstration of how we can build ap
eyes and design this application I was
talking to you about
all right can you guys hear me
perfect so thanks so much for having me
here and one more time welcome everybody
and thanks for being here today so what
I want to show you in a couple of
minutes see how you can leverage and use
a PRA platform in tools for designing an
API and not just design an API but
embracing the whole API design lifecycle
which is from having an idea to getting
an API done so let's say that we have
more or less an idea of an API we want
to build but before going in talks to my
product manager and say hey this is an
API that I really want to build and so
we have to commit our resource it's my
time in my development I want to make
sure that my users my customer will have
a great developer experience so for
example I want to make sure that my API
is exposing enough to fulfill my use
case what I want to make sure that the
endpoint I'm exposing they do actually
make sense but also I want to make sure
that my JSON payloads are returning the
right data are not over exposing the
team so the question is how can I move
this moment of truth as soon as possible
how can I make sure that all those
requirements are being respected without
actually writing a neat line of code and
the idea is kind of change them
infinitely let's not write the Cosford
and ask questions later and the answer
is to use API so what I'm going to do
I'm going to have a quick demo of the
API platform so I am going to log in to
AP all right now and sorry no so far
it's just integrated but they are the
final idea would be to try to abstract
this thing we want to make sure that you
can use API eventually further sorry
yeah I can we kind of a calculator so
this is a priori
and I'm loaded into the platform and the
first thing when I click the continue
button is I'm getting a kind get minute
scripture which is going to be the
source of truth for the for the whole
API design lifecycle more you rely on
the API description document more
idiotic and drink automation to your
platforms more validation API you can
bring from your developer license so
this is a simple API if the checkbox
that we are going to build and it has
got two simple endpoint the first one is
a seed collection which is giving me the
leaf of the state where I can suspend
eventually for the Yemen but more
importantly I also need properties that
I can drink in this API is in design a
di Blu link which is a language is an
open source language that we all saw it
and we can just use it but we also
support water the choice is really up to
you pick the language that you want
please pick one
so what document you can ap re what are
the facilities that is powerful can
offer - the first one is that we can
generate documentation from the Adriatic
it resolve and pay attention this is not
the commutation generated from the poll
it's not a dictionary of my class it's a
documentation generated from my
description document which means
football is interactive and it's also
beautiful so this is the documentation
over here and if I click on the list of
the beers you can see that the right
column is actually being populated with
technically based upon request so in
particular the Columbus telling me take
this is a get request and it's referring
this particular payload the most
interesting thing is that on top a PRA
is proposing me this year because every
time you put an API description document
in a priori we are generating a mob
server on spot for you which means you
let s start mock servers that is
behaving exactly the same way you
described in the document and the idea
is that we will be the URL documentation
or even the Box URL your shooter
developers even say hey
you
your API description document it's going
to be grab it from github
and all the tools related from it from
the API description goal document are
going to be updated the mock server the
documentation all the tests related to
your API so in order to show you that if
I now go here again and I select the
list of the beers and I again copy I
copy again these stinky and I try to
execute that again you can see from the
payload the t's is the period that I
just added giving you the true that the
proof that these documents caption
document has being dragons from github
and updating all the related tools in
apiary and the most interesting thing
here is that thanks to the version
control system integration you can
really embrace the flow that you want
and for example thanks to get up to the
pull request mechanism you really have
clear clear checkpoints when people
should stop for a moment and collaborate
and you can tell to your technical
writer hey please review this API you
can send to your software developers
this is an API that probably will be
going to build what do you think about
it and sharing the description document
is the way to bring the developer on
both and you can in iterate without
blooding any code as long everybody's
not happy with the API a nonce it's done
I can finally tell to myself over here
hey we are done with the design we are
ready to build the API so let's beat the
micro service and I will hand over to in
order to to continue this presentation
and thanks a lot for the attention
[Laughter]
thank you
Vincenzo's a good friend because he's
done the easy part and I got to
implement the micro service that's the
hard part and you heard what it takes to
build a micro service with the what
Chris talked about so let me just make
sure I can get that I have a couple of
slides here and then I'll go into my
demo okay let's make sure this is up
okay so I think I can skip this would
you guys agree based on what Chris
retention just talked about as to why
micro services and what micro services
is so then I want to focus a little bit
more on what is it that we're doing to
address all of those challenges that
Chris talked about right eventing
distributed programming etc so one is if
you're going to a zero in the release
cycle you need to have a continuous
delivery implementation and what that
means is integration with kit
integration maven a Hudson for
continuous integration being able to
have zero based issue ticketing systems
being able to have scrums being managed
so we're providing a developer cloud
service and that's what I'm gonna demo
which actually has all of that set up so
developer can just go to the cloud and
start using that and not have to manage
the installation of all these different
tools that give them a continuous
delivery lifecycle then when you think
about the run time in the run time you
want to be able to use containers
because micro services might be using
containers but orchestration of these
containers is hard you might need to use
kubernetes under the covers you might
need SVD in front of kubernetes to be
able to manage those containers and then
you need a scheduling mechanism you need
scaling of these services etc so we're
providing a runtime that is a path level
runtime which is using containers under
the covers but you don't have to worry
about scaling the micro service etc all
of that is taken care of you for you and
you can use whichever programming
language you want you could use Java F
II you could use PHP you could use Ruby
Python etc we're also providing you cask
as a service so you talked about
eventing eventing becomes such a
critical part or foundation of what you
have to do when you have to think about
isten see when you think I think about
microservices so we providing you
cascadas service and the last part is
how do you monitor and manage these
micro services that live and die but the
transaction scales multiple micro
services and so we're providing your
performance monitoring engine that is
being able to without you needing to
install anything on your systems other
than dropping in an agent giving you a
unified data platform across the user
experience data the web act database
performance data and the log data so
that you can get performance and insight
into your micro services and into your
transaction across all of it without
needing to hunt across many different
systems so you've got an entire DevOps
pipeline that is set up and you can be
really productive as a developer to be
able to build applications and micro
services really fast so now let's go
into the demo here which is how I you
know I'm able to use the developer cloud
service let me just switch to the
browser and I might have to log in since
my friend Vincenzo might have killed my
log in there but let me just sign in to
the Oracle cloud so this is oh yeah you
guys can see it this is the Oracle cloud
I'm just signing in here and once I sign
in I'm able to see all the cloud
services that I've subscribed to so for
example with the $300 credit that you
guys have you can log in and you can
subscribe to many different services
this is a live demo so I'm hoping that
Murphy's Law does not work here so it's
taking a little bit more time than it
generally takes which I am just going to
blame on the Wi-Fi in the morning you
guys need to get off the Wi-Fi in the
morning it are so fast you know I was
able to get in Bruno let me know if
there's anything that we can do to speed
this up but it's saying
right oh you have cable okay let's do
that okay there we go it's moving so I
should have done that before then being
dependent on the Wi-Fi and I hope I
didn't kill it in that process because I
put in the okay let me do this again
Oracle code you know this is nice right
because it's not working disconnect the
white one okay
disconnects okay let me stop this thing
I assure this that wired ping is working
you know I was thinking it's okay there
we go
huh just go to click on this again sign
in to let me try this one here okay
there we go
okay so I actually going to vote
directly into the developer cloud
service so here so what I'm going to
talk to you guys about whether I'm going
to build a chat bot now um the beer API
in the seats API was mark built by
Vincenzo now I'm going to build the
micro service that is actually going to
implement the real part of that micro
service so this is called the Oracle
Arena project this is the developer
cloud service you can see my continuous
delivery piece in here so here I can see
my project my code I can see the status
of my project the code issue tracking
agile and I walk through all of these so
let's take a look at the code here so
code
the most important piece is the
JavaScript file here server gorgeous and
yet I can see that there the API has
been implemented I've been hard at work
last night making sure that this is API
got implemented and then I can go back
here and see the manifest file which
tells me how this is being deployed when
you see the manifest file here it's a
node.js based application using version
six okay all of that looks good
I go into my issue tracking out here and
let me see I have a present developer
cloud service issue out here and I can
manage these issues I can look at these
issues and if I go into the agile piece
here this is where I'm part of a scrum I
can look at the active Sprint's that are
here as part of the scrum and here you
see it's in progress I can say that that
doesn't really belong to me someone else
needs to do the presentation I could
move that over here or I can say hey I'm
done I've worked hard last night I got
this done I can move it over here right
so I can manage my sprints out here and
then the build the build piece of it is
really cool because this is how you
build the project
and this is what a continuous
integration is built so here I've got an
Oracle Arena build that is out here I
can see the status of the build right I
can configure the builds if I want so
for example in configuration I can see
the source control so I'm pulling off of
get this is my git repository and I've
got a label with get that I'm pulling
off off I can see the build steps
associated with this so in this case is
very simple I'm just doing an install
and this install is going to happen on
the container run time then I'm going to
show you and I can add those build steps
I can do invoking a Fant maven Gradle
etc whatever I want and then if I also
go into Oracle at the arena build I can
see all the past bills that has happened
and what's really interesting is I can
also see the console output now it must
be just me being the geek here but I
love seeing this console output I love
to see all the packaging that is
happening what's going on and when I get
to the end I see that hey that is
success that particular build was
successful so I've got all of this in a
very simple easy to use environment and
by the way if you have parts of the
continuous delivery process for example
if you're using Jenkins for continuous
integration we're providing a web book
so you can integrate your continuous
integration piece into this right you
don't have to use everything here now
let's go to the deployment piece so here
I see that there is the backend app
which can be deployed and when I click
on the app it will actually take me to
the application container cloud runtime
and here I can see the configuration of
the build so for example it shows me
that the runtime is node and it shows me
that I have on-demand or automatic as
choices now if I'm a really good
developer I'm not going to go
automatically into production
I'll make sure them working with the
DevOps team or the production ops team
so I'm going to make it on demand but
for this one is just about beers and
seats and a jackpot I'm going live in
production as soon as you know I'm done
with my code so let me go back to
deployment here and I click on this has
141 and what that does is it takes me to
the runtime so within the same interface
now you're actually going to the runtime
that is running in the cloud this is a
container based runtime it is using
containers under the covers but you
don't have to worry about managing the
containers you can very easily scale the
containers up and down and here's the
view into the container I go into this
Oracle Arena back-end application ok
here we go and here you can see that I
have two instance of the micro service
with one gigabyte of memory I can very
easily change this to three instances I
can change it to you know different
amounts of memory now imagine what you
would have had to do if you wanted to do
this you would have had to change the
configuration file to change the memory
settings you would have to restart the
application you don't have to change the
load balancer to be able to say take
these many more instances right and
we're also giving you the ability to set
scheduling policies or scaling policies
so you can scale up the micro service or
scale down the micro service
automatically without needing to do any
of that so and here if I go this is the
actual implementation the Microsoft's
that URL through which it can be
accessed I can actually go in here and
put in forward slash seats to see would
that return anything and this is what
someone would get when they implemented
that micro service right this is the
response that they get to the micro
service let me just get a quick drink of
water so that's the building of the
micro service that part is done now let
me come to back to the presentation and
I have to say that I think I has a
harder job compared to Vincenzo or me
given all the work that I'm doing okay
so here when you think about the
engagement with users I fly a lot and I
download apps from Lufthansa Delta
United Swiss Airways Turkish Airlines
you know Oracle doesn't put me on one
airline just so I can maintain my
loyalty so I have apps from all of these
different locations and I'm sick and
tired of finding the app and checking it
into the particular app but I do have
one messaging channel not Facebook
Messenger or
lightly what's up it might be we charted
cetera so I want to be able to engage
with Delta for example to do check-in or
KLM to do chicken using messenger
that's what box are all about it's a
unified engagement channel that is
replacing more and more mobile apps that
are out there right this app fatigue
that is coming in so there are two broad
categories of jackpots the first
category is just simple transactions you
know very structured generally
instantiated or started by the user
where the user is saying I want to be
able to you know find I want to check-in
or I want to find the balance in my
checking account but what are the more
powerful box are the data-driven and
predictive BOTS and that's the hard part
that I'm going to show you in terms of
what it looks like and how you build
that bond right so here the bot is
understanding the user profiles
understanding the context understanding
the behavior of the customer in real
time and being able to do things that
are you know part of the state engine
but it is not as structured right and
it's using AI and natural language
processing to actually suggest the next
best action so what have we done to make
box really easy to build one is we're
giving the general channel configurator
so you can go across multiple channels
so for example Facebook whatsapp we
chair the checker so
the Commission so when you engage with
the customer what's the state engine and
how do you have context and how do you
maintain that state across the dialogue
that you're having at the customer ai so
no one can program all the different
ways that I could say yes or all the
different ways that I could ask for
certain things you just give a few
things and then we have an AI machine
learning platform underneath that is
learning based on how you're responding
and how multiple users are responding
and finally in order for this box to be
really useful
these Basques need to integrate with the
backend and we're giving you the way to
very easily be able to integrate with
back-end so all the way from the bot to
the backend applications where for
example you're getting the balance
information for your bank account or you
getting the check-in from the airline so
let's take a look at what the fan
experience looks like and I'm going to
switch to my phone here
actually before I plug in last time I
plugged in I had ninety one thousand one
hundred sixty emails unread and someone
said do you really work so let me first
get to my app here and then plug in
should give me one second okay here we
go yeah okay and if I can see that here
that'd be great
can you guys see the oh yeah there we go
okay so I'm warriors fan really excited
about Steph Curry I want to get go to
the Warriors game and so I friend the
Oracle Arena ticketing bot and I just
activate the bot by saying hello and it
says a Bob Jones you know how I assist
you well I want to find out what time is
is the next game so when's the next game
and it comes back with okay so seven
thirty Celtics
March 8 we need to beat the Celtics we
have some great deals on tickets sure
let's see what is going on and I'm
dancing why I'm not answering yes I'm
just answering why here says okay what
is your ticket budget this Bart is smart
you know I know it's expensive to go
there but I got a support staff so how
about $300 for the budget I know that's
a lot but you know let's go with 300 I
don't have wife or kids so that's okay
so here it shows me all the various you
know seats that I have $2.99 let's go to
99 looks like I can actually right next
to staff maybe I get a high-five with
him or a couple drops of sweat fall on
me so let's see here I can form that and
it says okay you've chosen to 99 to
confirm your selection for hold on and
if I use up all my $300 budget for a
dollar
can I get beer and food for a dollar
especially these events no I don't think
so I think that's just let me change
that and leave some money for myself for
some beer and food okay so okay so it
comes up with a new set of seeds let me
pick a cheaper set of seeds I'll be very
far from Steph Curry but I do have
binoculars so I should be using them all
all the way back there yes you know
that's fine 146 bucks
that's excellent huh are you running
short in cash or who is it's running
short and catch this part is really
smart I got to figure this out okay so
yes I am running short and cash here
maybe give me some cash I don't know
doesn't hurt to say yes okay let's see
oh so fifty bucks I get access to the
Oracle VIP room I know Oracle treats as
people really well I see free t-shirts
being given out at various places
hoodies and now free beer okay
free beer is good but what does they
have Budweiser and Bud Light that I've
been to Germany and and Prague and I
just don't like those let's see what
kind of beer am I going to be able to
get now if you remember by the way this
was the API that was programmed to
return the seats you saw that and to
return the kinds of beer
so let's see what kind of beer do you
have let's see what it comes back with
and smart enough it's thinking Oh geesh
it's ready an input sent out really
nicely with Guiness out here and what
else does it have Pilsner Snapple
Heineken lÃ¶wenbrÃ¤u okay I think I can
be pretty pretty happy with these let me
go ahead and say yeah go for the VIP
package so they'd cross the lap salami
huh okay so here's my summary looks good
196 bucks actually saved 104 dollars Oh
Apple wallet yeah because I'm always
hunting for email to find that thing
so go ahead okay here's the summary
invite with this is the interface for
Facebook this might look very different
on whatsapp or WeChat or 96 bucks that's
good and generate Apple oh here you go
and I can add that to add that to my
wallet that was excellent I have to say
I must have designed a really good bot
okay so let me take this out and if I
can switch back to whatever I was going
to do next let me see what was I going
to do next
okay I'm coming back to the presentation
here oh you are already there they're
fast too okay so here's all the things
that we set up for you right first of
all we're giving a channel integration
and I'm going to go into how we built
the bond I'm going to show that too so
channel integration we're giving you the
web box into Facebook etc so you don't
have to worry about a channel
integration Alexa when is the next game
I could have instead of typing it in
gone through Alexa and ask for that
intent classification so when when if
the next game is asked what was my
intent my intent was probably to
purchase tickets so was far enough to
figure out what is the intent and then
was also going through you know what is
your budget because it was trying to
figure out how to do cross-sell and
upsell then entity extraction
well this bot has to act on something
one of the entities that will be acted
upon here so it was the seed spell being
acted upon the beers the offers or if
suppose I was
I get balanced on my checking account it
would be on the account on the savings
account the checking account etcetera
those the entity so now we figured out
the entities you figured out the intent
now we have the ability to actually
structure a query and send it to the
backend right because that's what the
bot is really trying to do is to send
queries to the backend and that's why
the dialog execution flow comes in and
you have the integration component that
is set up for you are the box so you
don't have to worry about how you get to
the backend so that's the Chatwin
telogen chat bot knocks on that we've
created so let me actually go where am I
going I'm going to my demo if you give
me one second let me get out of this and
let me go back to my browser I kill this
guy and go here and let me put it into
full-screen mode so you guys can see it
a little better okay so this is the
interface to my chat bot builder and
here you can see the various bots that
are out there I'm going to go to the
Oracle Arena bot and here I can clone
the bot I can export it for development
lifecycle purposes etc but let's say I'm
going in to edit the bot and here you
can see these are the intense so when I
was talking about intent you can see
that the intent is purchase tickets and
along with that the business version has
given just a few examples of how someone
could ask for purchasing tickets right
so when is the next game for example one
was one of the intents that was defined
these are just written in common English
and from here on the system is learning
now let's say I as a developer want to
understand if I were to type in
something what is the return value so
I'm going to type in when is the next
game and what is the bot gonna respond
with so here it shows you that it is
first figured intent is purchase tickets
with an 89% confidence level now you
could train the bot if you want and you
could say no it should be exit part you
can add another example you can train
the AI engine that is in here but that's
pretty good it says okay purchase
tickets is the
thing that I want to do now let's go to
the entities so here the entities is
what kind of assistance is needed to
assist in this purchase tickets you can
have entities that a system entities
like date number x cetera that we
provided or the Box currency but they're
also user-defined custom entities that
could be billed out here yeah and now I
want to see as a developer you know what
is it I already saw the intent responses
now I want to see what the bots
responses so I click on the bot here and
I go and I type in when is the next game
and now it gives me the response of what
it would have said right in responding
to that and at the same time it gives me
a JSON package a JSON payload that shows
me what the response is from the backend
that is coming back right so this gives
you the ability to debug the bots and
then if I look at the dialogue editor so
this is where you know some hard code
programming is coming in and working on
building flowcharts Baystate engines in
here so you can make it very easy but
this is a yama based specification out
here where you writing code and llamÃ³
you've got multiple nodes and those
nodes connect they execute themselves
are call other nodes etc so you've got
that design editor here and then this is
where i'm going into configuring my
channels so here I've got Facebook or
smack or an exit set or different
channels that you can have and I can
have my three-legged OAuth being defined
right here so how do I sign into the
channel how do i authenticate because
the authentication is not my
authentication like meaning if I'm the
user
it's the user's authentication with
Facebook and I don't want to necessarily
be holding on to the usernames and
passwords something three-legged watch
with them and then at the same time I
want to be able to see what these
services look like what are the API
calls that are going to the backend this
is what the micro service piece comes in
so and this is being using mobile cloud
service in the backend to be able to go
connect to the integration points behind
the scenes so that's the demo out here
and with that let me just bring up one
last slide and then I'll bring it back
oops not hear something if 11 and we
already did the bot builder
demonstration I mean go into slideshow
mode here
and great and these are some of the
sessions today harmony API design
containers micro services for realists
writer Jack Foster there's definitely
more focus on chat box and DevOps in
action they might have Oracle content
they might not Oracle code is for really
you know really engaging topics for
developers so with that Amit would love
to have you back on to close out the
session Thanks thanks Don so hopefully
get so I mean it's pretty I think from
some of the things we're doing with this
idea of building a lot of interactive
applications so chatbot is one of them
and they're quite a few other content
being out there as a third mentioned so
as I talked about earlier I mean when we
talking about all this new evolution and
new ways of building applications and
modern application development
requirements you do require a pretty
good platform the cloud platform which
is open more than easy and what we have
done with all at Oracle is we have Bill
out at Oracle cloud platform which kind
of takes care of all the different
underlying technologies you require to
build your application be able to run
this in the modern environment as well
be able to really do low code as well as
professional development around it be
able to run micro services and
containers associated with that and then
of course scale it out with Enterprise
Java or if you're running node or you
running Ruby whatever may be the case in
terms of your technology requirements
and have that in one platform easy to
scale and easy to kind of develop
against so if you have comprehensive
application development platform with
automated DevOps the mobile first API
first kind of a paradigm which is
built-in and you can run build any
application can be delivered in many
ways and then a single pane of glass to
manage all of the applications be
running on Prem as well as running in
the cloud without having to have a
distributor without having to really
manage it separately all right and
they're beyond what we talked about
today that a lot of other services we
built out as part of the cloud platform
so if you want to do integration for
example between say any SAS application
be salesforce.com
workday or Oracle
applications on the cloud with on-prem
applications like as ap e-business suite
PeopleSoft so that integration of the
platform services as well available for
data movement if you want to do data
between different the heterogeneous
databases and be able to do real-time
data extracts we have services for
Golden Gate for example available in the
cloud and messaging as part based
services for doing your Hadoop clusters
and scaling them out tasks a service for
eventing and queueing requirements then
all the things around Big Data with
Hadoop as a service as well as things if
you are using my sequel via my sequel as
a cloud service we launched last last
year and a lot of other capabilities
available as a part of the cloud
platform for you to really have a full
end-to-end capabilities provided from
one integrated platform running on an
infrastructure with scales with compute
storage and networking capabilities also
provided out of the box out of the cloud
services today right and if you are
using a lot of other open source
technologies we have certified 500 plus
open source offerings today available in
the cloud so if you want to bring your
own stack you want to bring your own
open source tools open source
technologies all available today on the
cloud platform so you don't have to
really again go and use different
different cloud environments and try to
bring all the things together so we work
with a company called bitten AMI
who also certifies a lot of this newer
open source the stacks available on a
cloud platform and our cloud is
available in multiple regions and
countries we have 29 data centers live
today and we adding quite a few on a
regular basis so it's not about just
building it for one region if you want
to now have a distributed and a user
base available globally again you can
have your work load running in multiple
places as well and again the services
have been available for many years now
and we've been investing heavily in a
cloud platform
if 11,000 plus active customers
additional customers over the last year
on a cloud platform available 142
countries there are also different apps
so if you want to use other third-party
applications on the cloud platform we
certify and run on or
cloud platform 2,800 plus apps available
in the marketplace and that we've been
adding a lot of capabilities for all the
different things I talked about earlier
as part of the integrated cloud platform
right we have a lot of customers of all
different sizes and in different
industries who are taking advantage of
all the things we offer today and here
today later with some of some of the
sessions you go into about some of these
use cases and how customers are adopting
the services all right some of the
announcements we're making and every
cloud code event we have a lot of new
things to talk about
of course we talking about a lot of the
customer momentum and partner momentum
as who have been adopting our cloud
platform as well as we have if you're
using my sequel we announced interesting
features to make it easy for you to
scale as well as cluster the my sequel
kind of capabilities available today as
part of my sequel cloud service as well
as we have a partnership with rural site
which is a global learning offering in
the web today if you want to learn about
all the cloud technologies as well as a
lot of the how you build applications
how you integrate them amplified host
content between or for Oracle on their
website for you can go and get training
on the technology the offer right so if
you want to hear and learn more you can
go to developer Oracle comm it's a
specialized website we build with a lot
of code samples forums and examples
which you can now of course use and
download as well as start using a
understanding so when you're building
your application you don't have to start
from scratch so developer Oracle comm a
lot of live content out there as well as
if you want to try out the Oracle cloud
platform we have a serious proposal for
$300 credit which you can start logging
in as starting to sign up and start
using the services and try them out as
well so cloud.oracle.com slash try it as
a good place to start from
so hopefully enjoy the rest of the day
and look forward to kind of getting
feedback as well as your input in some
of the things we are doing and
interacting with many of you so thanks
again for spending the day with us thank
you
all right Thank You homage so uh for the
people in the live streaming appreciate
your watching we're going to have again
the reddit AMA happening already um
slash are slash ima on and thanks for
watching again so for you guys here on
site we have a great event this is the
agenda for today there is a mobile app
work</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>