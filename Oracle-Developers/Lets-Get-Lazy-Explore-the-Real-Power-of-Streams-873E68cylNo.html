<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Let’s Get Lazy: Explore the Real Power of Streams | Coder Coacher - Coaching Coders</title><meta content="Let’s Get Lazy: Explore the Real Power of Streams - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Let’s Get Lazy: Explore the Real Power of Streams</b></h2><h5 class="post__date">2016-09-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/873E68cylNo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright let's get started welcome to the
session on let's get lazy we're gonna
talk about pretty much lays evaluation
and some of the details around it best
time to ask questions or make comments
is when you have it so if you have a
question or a comment please draw my
attention I'd love to hear from you what
you have to say so I want to talk about
what does it mean to be doing lazy
evaluation well when it comes to
functional programming one of the key
things about functional programming is
well when we talk about function
programming we often hear people talk
about oh it's supports or it emphasizes
immutability we then hear people say
that higher-order functions are
extremely important well sure but I
always wonder when we are emphasizing
immutability I wonder it's kind of like
telling children to eat their vegetables
and the first question you ask is like
why and so if I want to really emphasize
immutability the good reasons to do it
cannot be the variable is immutable
right that's a circular logic so why are
what is some of the reasons why we want
a favored immutability becomes a very
important question to ask well it turns
out to be there are quite a number of
reasons there's not just one but one
among those reasons is that we can do
lazy evaluations so what in the world
does it mean to perform lazy evaluation
well lazy evaluation simply means you
are not forced to compute something at
any given time you can't postpone its
computation you either have the ability
to compute something now you have the
ability to compute it later or simply
skip it and not compute it at all and it
turns out if you really want to be doing
lazy evaluation you'll really becomes
very important because if there's a
side-effect people know when you do it
and so that's the reason we don't want
immutability but having said that let's
focus a little bit on this one of the
things we talked about in computer
programming are in programming languages
is about the so-called applicative order
versus a normal order well this is so
really fundamental but unfortunately
most of the mainstream languages that we
use every single day
predominantly support applicative order
that we don't even stop to think about
it so to understand this let's take a
little example and play with it so here
I'm gonna start with a very little
simple Java example so what I want to do
here is I'm gonna go ahead and call over
here a function called evaluate
something extremely simple and I'm gonna
pass to it and add one and two so as you
can see in this example the function I'm
gonna write over here the function is a
pretty much evaluate function so
evaluate simply is going to take a value
as a parameter and all that this is
gonna do is simply return the value very
trivial very simple as you can see now
what I want to do here of course is I'm
gonna call public static again in this
case I'm gonna cry right the add
function and I'm gonna take and let's
say an A and B and of course I'm gonna
return in this case a plus B so nothing
really earth-shaking in this example it
produces a result of 3 but if you look
at this code and I'm gonna ask you this
question in this particular function in
this line what is the first thing that
you think is going to get evaluated the
add function of course we know that
right and then the result of add is
being passed to evaluate and the result
of evaluate is being passed to the print
line so that makes absolutely good sense
now just to kind of prove this point
let's go to the add function and I'm
gonna simply say called over here and
then of course when I run this you can
see that call is being called but let's
change the score just a little bit I'm
gonna return receive a value but I'm
gonna return a 42 over here now the
question is when you run this code on
line number 13 what's the first thing
that's is going to do add of course
right so when I run this code it calls
add and of course I'm not asking you
what you wish it did it did I'm asking
you what it actually does right so this
is pretty much applicative order so the
word applicative order means in the
order in which you apply it it's going
to do it well that's the way Java is
made a lot of different languages are
made that way but let's think about this
a little bit further switch gears here
for a minute so I'm gonna write a little
piece of code here I'm gonna say add a B
equals a plus B this is a little bit of
a Haskell code right here I'm gonna say
evaluate value equals value and then I'm
gonna say mein equals and in this case
I'm gonna simply say Brent and let's go
ahead and call evaluate in this case add
one and two and let's just go ahead and
write run that little code to run this
little program to run and get the result
of Haskell well clearly Haskell did tell
us that the result is three when I ran
it so that makes really good sense no
worries about it but the question on
hand is when does Haskell run the add
function well Haskell is a purely
functional programming language and
purely functional programming languages
are predominantly lazy so Haskell says
oh here scold call add it says why well
I want to send it to evaluate but why
because I want to send it to print okay
that's a good reason you want to see the
result so I'll kind of get down to do it
but when does it really run the add
function well that's something we need
to really ask the question so to
understand that how do we know well I
cheated a little bit in the case of Java
code I did something really bad
and most people who will thrown on me
for what I did I put a print statement I
don't have that luxury in Haskell if I
put a print statement has to will call
me by names it was called my answer
Street right so it's not gonna be kind
to me so because I can't put impurity in
functions that are supposed to be pure
so I'm scratching my head you know I can
talk in theory here I can tell you
believe me that it actually is going to
not call it but nobody comes here to
believe right we want to be proven
that's actually true and I never thought
I would ever do this and I decided to
use the debugger to prove the point here
so what I'm gonna do here is I'm gonna
bring up
repple so this is Haskell triple G HCI I
just brought that up and I'm gonna say
it - Haskell hey Haskell go ahead and go
ahead and load this function sample Dart
a HS so I'm gonna just load it up I'm
gonna put a breakpoint right now and I'm
gonna put the breakpoint right here on
line number one character number 16 well
that's first line end of the first line
then I call the main function you can
see it's broken right it is breaking
right there and waiting for it to
continue so that's a proof to us that it
called the add function but then I'm
gonna say continue and then you can see
the result of three well all I proved
was that ad was called but I did not
prove to you when ad was called okay
we'll come back to that in just a minute
so let's get back to this code and
return our 42 right here and when I run
the code you can see it did print 42
just like Java print at 42 but I'm gonna
go back to the score and say load sample
right here dot HS and now I'm gonna put
a breakpoint on line number one
character 16 then I called main and you
can see that Haskell never bothered to
call the add function and it said hey
why bother calling add because after all
you're trying to pass the result of add
to evaluate I'll get back to you let me
go check what evaluate wants to do oh
wait a minute why do I care about
evaluate let me see one print wants to
do a print wants to print the result
I'll be back to print and it's within
the print that it actually cause
evaluate and with an evaluate it says
gosh you wanted a return of 42 I'm done
and it never ever bothered to evaluate
the add function so this is called the
normal order it turns out most languages
we program in use applicative order
normal is actually not that normal it's
actually pretty uncommon as you can see
because we don't use that as much in
languages we program n but it changes
the way we think about programming when
we can exercise some of these
capabilities so we saw the difference
between applicative order and normal
order and there are benefits to one
versus the other I'm not going to tell
you one is
on the other one sucks well there are
pluses pros and cons for every single
one of them but some languages are born
naturally lazy at the time of their
birth they are at the beach right people
serving them and they don't just move a
muscle and these are languages born lazy
and they are absolutely lazy and
everything they do some languages have
to work really hard to be lazy these
languages are kind of like me and my
wife will sometimes tell me why don't
you relax
and I would say how do you do that right
so it's really hard some languages they
have to work extraord to be actually
lazy
well let's entertain the start a little
bit how does it how does it really work
to be lazy versus eager evaluation well
a good evaluation is when you evaluate
things you know very eagerly meaning I
got to do it now I'm not going to wait
for later on to do it I gotta run it now
on the other hand lazy evaluation is
yeah I'll get to it so imagine this for
a minute let's say your boss comes to
you and your boss tells you I want you
to work on this particular project and I
want a report from you very promptly on
April the 1st now this wasn't February
1st the boss tells you now if you're
like me what are you going to do you're
going to start on this project very
promptly on March 31st because it's due
on April the 1st right come on let's be
honest about it right that's what we do
well in fact if you know you're gonna
quit on March 15 why in the world would
you bother starting on this project
which is you want April the 1st well
that's kind of lazy evaluation right
there but some doses really suck well
they tell you you are final report
that's when you know it's gonna go
downhill right your final report is do
you want April 1st but I need an interim
report every single week now you know
you got to produce some work to show
results every week that's kind of the
side effect so a side effect is where
somebody knows whether you are doing
your work or not whether your function
is running or not by the results the
effect you have outside
of your context well if you want lazy
valuation obviously you cannot have
side-effects that's why functional
programming greatly emphasizes pure
functions with no side effects because
they want to know they can decide when
to run and when not to run postpone it
until the point when it doesn't have to
be run at all well given this let's take
a little bit of an example here to see
how this is actually going to work so to
understand this let's change the example
a little bit and I'm gonna output and
I'm gonna say Oh in this case change it
a little bit here let's say you know int
x equals 2 let's say a 4 and I'm gonna
say if X is greater than 5 and expensive
let's call it as expensive up and let's
go ahead and say I'm going to call this
expensive up and this is going to give
me a result and I'm gonna say equal to 4
I'm gonna simply output let's say in
this case I'm just gonna say output
result other otherwise I'll say simply
no result so very trivial example but
nevertheless it illustrates the point so
if I were to run this code let's go back
to this expensive app for a minute so
what is this expensive
Abduh it's going to simply say well it's
all that it's going to do is says print
out let's say called over here and then
it's a returns oh let's say a value of
you know for let's say well I'm gonna
run this code and my question to you is
is that expensive are gonna be called or
not no of course not and what do we
called this feature ass yeah shorts are
killing it turns out John McCarthy is
the one who created this long time ago
in list so it's a very powerful concept
of shorts of curing every single
programmer who ever learns to program
very quickly learns sorts are curing
they never get agitated they don't get
angry saying oh my gosh how did you not
call that method right it's kind of a
known fact that's not going to get
called so when I run this code you can
see it said no result and the function
never got called well let's stay with
that example just a little bit further
so I'm gonna go back here to this
example and here I'm gonna say Val
X equal to four as would have imagined
this is Scala code and I'm gonna say if
X is greater than 5 and expensive up
equal to 4 so pretty much I'm writing
the same code here in Scala and I'm
gonna say a result and of course if that
is not true I'm gonna say else print
line let's say no result well of course
I need the the function expensive op so
what am I going to do here I'm gonna
simply return the value of 4 and I
execute that little code here in Scala
and you can see that it did not call it
so Java and Scala are doing pretty much
the same thing no confusion about it
but let's get back to this code for a
second what I want to do now is I want
to take I'm gonna just refactor this
code just a little bit or just change it
a little bit in fact it's doing extends
a word here but I'm gonna say this is
going to be attempt and then I'm gonna
say in the temp equal to expense
expensive operation the question now to
you is will the function be called yes
would you like for it to be called no
right so this is when you and Java are
not in agreement and you know this very
well if you don't agree with Java you
know who wins right job always wins so
as a result in this case it went on and
called it so this is such a
disappointment isn't it you're sitting
there and saying how wonderful it would
be if I could just you know define that
variable and if I don't ever use it it
would have been nice if it didn't use it
let's get back here to Scala for just a
minute
so in Scala I'm gonna take this right
here and then I'm going to say temp over
here and I'm gonna get Val temp equals
expensive so that's all I did here in
Scala so when I run this code in Scala
you can see that in this case what just
happened well I'm gonna say Val temp
equals to expensive operation you know
to be fair so pardon me here I forgot to
put that little print statement so let's
get back to that so in this case I'm
gonna go back to this code and I'm gonna
simply say alright return a 4 but before
you do simply print a call so you can
see that in that case it is it is it is
bypassing it
however if I were to change this to a
temp just like in Java and they say temp
equal to that and if I run this code
well that's kind of sad
Scala also went ahead and called it
right so that's very disappointing but
thankfully though you can ask the
question why did Scala really call it
why can't Scala be really smart right
well the reason is actually fairly
simple
Scala says well this function
potentially may have a side-effect and
where everybody in the world knows even
if your function causes a side effect if
you're doing the shots of curing and if
it doesn't get called don't complain
about it it's actually pretty weird when
you think about it when you read
language specifications I had to read
C++ language specifications don't ask me
why but I had to do it and when I read
the C++ language specification the
specification clearly says we will would
not call a constructor at will even if
the constructor causes a side-effect
so languages document these things very
clearly to give you a warning even if
you call side-effect we have the right
not to call it well Scala specification
says if you cause a side-effect
potentially we're gonna call it for you
if you are going to set the value into
it however they want to push the burden
on you because they don't want to take
the blame from you to say oh my gosh I
had a side-effect there you guys never
called it so they give you a little
little token to say hey Scala I know
what I'm doing I I don't care to use
this value you can mark it as lazy
explicitly in the language so by marking
the variable lazy you can see that it
did not call it so without the word lazy
you can see that it's actually doing the
call but putting the word lazy you can
see that it's bypassing so it is going
to wait until the first time you
actually use the value before it gets to
actually evaluate it and if you don't
ever use the value for example in this
case if a word change this to X gray
then too you can see the called comes in
because you are after Li using it but
that call actually comes after it
evaluates X greater than two but if it's
changed it to five you can see this
alright
so given this obviously we are seeing
lazy evaluation work in Scala but at
this point we are asking hey how do we
really do this in Java right so we
definitely want to be able to use some
of these features and we are like hey
that is all possible how could we go
about doing this
well it turns out it's really not that
hard to do except we have to think about
this a little bit differently so to
understand this let's take a little
mental exercise let's say for a minute I
have a little apple and I know this is
lunchtime everybody is you know hungry
so I have an apple so I'm gonna use you
as an example if don't mind so here's
the Apple there you go come on take it
all right there you go yeah I was kind
of worried well notice what he just did
I gave him an apple and he's not eating
it yet
you're very lazy well that's the whole
point isn't it so he has the right
here's the three choices now right
either he can eat the apple now go ahead
or he can eat the apple later or simply
trash it and not even cared or give it
to somebody that's you're just a nice
better man than I am okay so so he can
either eat it he can either eat it later
or he can give it to the next person so
those are really good choices right well
that's exactly the point
but let's not use an apple let's use a
lambda to me lambdas are more tasty than
apples so lambdas are awesome so when
you pass a lambda to a function it's got
three choices the minute it receives a
lambda it can call it or it can wait
until later to call it or never call it
so we can achieve laziness in Java or
almost any language that provides
functional style of programming with
lambda expressions so notice what I'm
gonna do here in the Java code and and
this is not a one-to-one comparison by
any means but gives us a
hope to see how we can go there so
notice what I do here I run this code
and you can see it eagerly evaluated the
call to expensive up but I'm gonna do
one more thing but before I do this I
want to say one thing that I admire the
most there's not a day in my life
as a programmer I don't think about this
a guy named David wheeler yeah I'm a
huge fan of his work and David wheeler
said something that matters to us every
single day he said in computer science
you can solve almost any problem by
introducing one more level of
indirection ah there is absolutely in my
opinion nothing more phenomenal than
that in our field I think because every
single day when I sit to solve a problem
I say I'm not able to solve it how can I
introduce a level of indirection and
solvent so having one more level of
indirection is a phenomenal you know way
to think about problem solving so we are
saying hey I want to apply a level of
indirection here what is it well if you
don't want to call the expensive op Li
introduce a level of indirection in this
case the level of indirection is that
lambda for us so I'm introduced a level
of indirection and I'm gonna say
supplier of integer that I'm gonna use
right here so in this case I'm gonna
bring in the function Dark Star and the
supplier comes in from the from the
functional package so now I can simply
say dart get over here and use that
value so now you can see how easy it was
to be lazy about it I mean to be fair
you really want to cash the value and
reuse it so I've not given you a full
solution here if you look at anybody who
programs in c-sharp here ok that you're
among friends that's ok I program too so
so c-sharp has this mechanism already
begged then they have a lazy type
already so you can pretty much define a
type as lazy and then they would not
only postpone evaluate
lazy they will also cash the value and
give it back to you
well Jabba doesn't quite have it but he
doesn't stop us from creating one if you
wanted to in a few minutes the supplier
is the gateway to that and we can get
going to cash the value and create it
which is not too hard at all so we can
see how we were able to defer the
computation so to me lambdas are that
gateway to being lazy think of lambda
like this Apple I gave in the example
you don't have to run it now you can run
it now you can run it later or never run
it at all right that's one of the things
you can do with this very nicely so in
most languages we can enjoy lazy
valuation using lambda expressions what
having talked about this let's talk a
little bit about how does this really
manifest into you know effectively using
on a particular problem so when it comes
to collections so this is one of the
things I really want to emphasize when
it comes to programming with streams API
honestly when I started looking into
Java I was not that excited about Java
Java 8 artists because lambdas are not
new to me I've used lambdas in a lot of
different languages and if Java is just
gonna give lambdas like Ruby does our
GUI does I'm like eh why bother but I
remember the day when I came across the
streams and I was thoroughly convinced
because streams give you something in
Java 8 that language like Ruby doesn't
give you groovy doesn't give you yet and
things like that and what is it well
streams are fundamentally lazy that's
one of the biggest benefits of lay
streams and and in fact my one of the
things I say often is when I wrote the
Java 8 book I wrote something in the
book my editor called me and said are
you sure you want to write this kind of
stuff in a book and I replied back
saying well remember I live in Colorado
and she said yeah you're right and hung
up well what I wrote in the book was I
said that lambdas are the gateway drug
streams are the real addiction and and
so much truth
fact lambdas are your gateway drug not
that I have any personal experience with
that in Colorado but the point really is
that lambdas our gateway drug
you cannot who get hooked on to this
idea by looking at lambdas but what is
gonna really keep you there get you
hooked really for a long time is the
streams library and and that is why I
love streams and without streams I would
have very little interest in the stuff
in Java eight that's how I believe in
that so given this let's think about
what does that actually mean for us so
to understand this and evaluate it let's
take a little example and play with it
so what I want to do here is take a
fairly simple example and see how this
is gonna change our life using this so
I'm gonna take a list of integers and
I'm gonna say values equals arrays let's
say as lists and in this case I'm gonna
simply say one two three four a bunch of
values so I've got a few values that I
want to work with but what I want to
really do in this example is I want to
say oh let's say find the double of the
so find the yup so find the double of
the first even number a greater than
three let's say that's what I really
want to do so in this case of course I
want to find the double of the even
number greater than a first even number
greater than three so what would I
normally do to do this I would say you
know result is equal to zero and then I
would say far int I equal to zero well
okay that's really bad so let's say
element in values and then I'm gonna say
if element is greater than 3 and element
Mar 2 is equal to 0 well then of course
I'll say result is equal to element
times 2 and do a break on it and then of
course come back output and say result
and print it so you run the code it said
8 as a result so the first question I'm
gonna ask you is is this correct so some
of you are saying yes and others are
consciously thinking about it right that
one of the beauties of imperative code
it hurts you when you least expect it so
when you write this code what's gonna
happen about two months later you know
who walks in right your tester walks in
well my tester always walks in and says
hey venket your code sucks and I always
tell my tester don't tell me the obvious
tell me how it sucks today because it
sucks different every day right so as a
result well the problem the tester had
in this case was you know how testers
are they just don't take the code in
good faith and run with it they want to
kind of sit there and say what if I send
an empty list like why would you do it
and then they have a reason to do it and
they send an empty list the result was
zero and they argue with you you see
that a search wouldn't be zero it should
be non-existent well what if the
collection had no even number at all
what are the coachmen had even numbers
but nothing greater than three well it
fails in several ways so but that's not
obvious coming out of this code it's
kind of hiding the detail so but also we
wrote an imperative style code that
looks a lot messy we want to really
improve this code how do we do this well
we do this in languages like JavaScript
Ruby groovy
you know Python keep going a lot of
these languages provide functional style
of programming however there is one
problem between these languages and Java
well Java is different in that Java EE
is used by nine million programmers so
when it's an enterprise language and and
millions of programmers use the language
you cannot just do stuff without
performance and say it looks cool be
happy with it so you have to really
provide good performance as well so
let's look at this code for a second so
what I want to do here is I want to
implement this exact code we saw in here
but in a functional style so I'm going
to say value start stream and then I'm
gonna say filter given an element
element is greater than three filter
again please are given an element
element Mar two is equal to zero well
then do a map given element element
times two and then finally do a find
first and get me the first element in
the collection well the good news is we
wrote it now in a functional style but
it's a little protecting us it doesn't
give us the eight it gave us an optional
aid to say hey you know what this may
not exist I do have to admit to you that
this is the most threatening method I've
seen in Java it's called our elves and
then you can specify a different result
if you really wanted to but you are
being very intentional you're being very
explicit in handling this and not gonna
run into a nullpointerexception thinks
that optional so you can see the code
was written in a much more elegant
manner in a functional style but the
obvious question that we are going to
have is hey the cool the code looks cool
it's beautiful its expressive but what's
the cost and if I tell you this is going
to cost you only four more times you're
gonna say get out of here so we don't
want to pay for performance just for the
sake of elegance so what is the
consequence of this well if you try this
example in a lot of different languages
what you end up getting is you are going
to start with one collection get another
collection yet another collection yet
another collection yet another
collection and that all amounts to more
garbage collection right so you're going
to be ending up with a lot of memory
cleanup and so much more performance
we're not going to be very happy with it
so they couldn't just leave this and
walk away and say hey that's what a lot
of other languages do good luck you know
go home use lambdas so they had to
really bring a better performance into
it and thankfully they did so what is
going to happen here but before I go
into it let's understand the
computational you know number of
computations let's put it in simple
words so look at the imperative style
for just a minute I've got a real list
of values 1 2 3 4 up to 10 the first
even number greater than 3 double effect
so E is 1 well not greater than 3 2 not
greater than 3 3 not greater than 3 well
for
is actually it's to have some fun with
this let's go back to this code and
change this to five and four it doesn't
affect the result but it just introduced
one more computation and there so now
you can see what the computation is one
two three five is greater than three
well five is even is not even and then 4
is greater than 3 4 is even double four
that's eight computations so the the the
the imperative code did eight units of
work now if we do this naively we take
the entire collection we check the
filter for every single value that's ten
computations already dead in the water
right to add insult to injury after all
the values that are greater than three
that's seven more seventeen computations
then you double the four values left
twenty-one computations later we're
gonna be you know rolling in and that
one has done in eight computation and
says hello we finish this in eight
computations you're just coming here
after 21 units of word why bother right
so that wouldn't really fly at all but
before we answer that question a little
bit let's do something just for our
purpose to make this a little bit easier
on us so let's say starting over here
boolean is even and I'm gonna take a
number and all I'm gonna do is return in
this case let's say number is mod 2 is
equal to zero well likewise I will write
two other functions here this one is
going to be you know is greater than
three and all I'm gonna do you simply
say number is greater than three right
here and finally I will simply say oh
this one is gonna be we'll call it
double it and I'm gonna simply go ahead
and say number R times two and return it
well the beauty of this is we can come
back to this code and I can replace this
with sample is greater than three we can
replace this part right here with sample
and is even and then replace this part
with a sample and we will say double it
so it should be producing the same exact
result but but before we evaluate it
let's understand one thing about streams
and
the streams have a characteristics I've
only seen this among my own children
they both are lazy to the bone so I will
explain a scenario that I've seen at my
home and it would relate really well to
you so I've got a teenager well if you
have teenagers you know what I'm talking
about
my wonderful wife will tell him I
teenager hey turn on the TV it's like no
words were spoken nothing really
happened then she would say throw the
garbage out nothing really happened do
your homework nothing really happened
and then she says I'm calling daddy
everything works so that is exactly the
way this actually works so they might as
well have called this as called daddy or
call mommy
depending on the family in the situation
right so sometimes I have to say call
madami sometimes yes they call daddy
but the point really is those are called
terminal operations until you hit the
terminal operation everything else is
lazy
in fact it's funny to the point some
days my wife will tell my children
something and and purely out of it you
know coincidence she would pick up the
phone to call me and they would
immediately get something I'm doing it
I'm doing it like come on I'm just
talking me husband why are you doing
this and they think that it is for them
right so eventually it kind of works
really well so the point really is that
these are absolutely lazy well to prove
the point in here let's get back to this
code and just print this optional for a
minute and let's refactor the score just
a little bit further and well before we
do that let's go ahead an output here
would say is even and then we'll say
plus number and then we will also print
right here 'is greater than three and
number and then finally we'll print here
our double it and the number as well
well when it run this code remember the
imperative code did eight units of work
and you can see that the functional code
is also doing exactly eight units of
work so we did not expend any additional
work so that is one of the beauties is
it is not doing any more
work why because it doesn't take your
collection and do all the work on the
collection instead it takes one value in
the collection and it fuses these
operations together and then does the
work for you so in other words how does
this actually end up working so here is
a way to really think about it so the
way to think about this is in the in the
first case when we have the when the
when you have the filter call so
essentially this is what is actually
happening so you come into this code
right here and then you're calling this
filter well at this point all I have is
a little marker on my hand four people
in the back row I just have a marker on
my hem that's all I have well the next
thing you do it didn't do any work with
it then you call the next to filter and
all that Java stream does is it takes
those two guys together and just
attaches them like that and says I'm
waiting it doesn't do any work well then
you call the next operation the map and
this is called the fusing and it takes
the third one and it attaches that and
it kind of builds this pipeline in fact
Martin Fowler calls this the pipeline
programming model so this is one of the
biggest traits of functional programming
is this pipeline model well the beauty
of this is you can keep going how much
ever you want to go and you can keep
building this pipeline as much as ski as
you can go I try not hold it on the end
so you can see that we can keep building
this pipeline well once you build this
pipeline well it's up to you whether you
want to run something to this pipeline
or not run anything at all and discard
it it ends up like the Apple that I gave
to him right so in this sense it is
gonna wait on this this pipeline is a
little bent right here but anyways so
the point really is that you can pass
things through this at any given time
that's exactly the model we are working
with is that it just builds all of this
until the point of highlighted code and
then when you attach a terminal method
to it is when it triggers and passes the
data through it that's when the data
flow happens
and the dataflow doesn't happen until
the terminal method hits and says I am
ready here and then it starts sending
stuff from there if you go to water
parks you probably have seen the the
person in the bottom signals the person
in the top to say mix it send the next
kid over to the water part that's kind
of the way the flow happens it's a very
similar way to that the terminal is the
one that triggers the computation well
to prove this point here notice what
I'll do in this example I'll remove this
particular print statement here and at
the very end I would simply say done and
you can see that it did all that work
and printed done as you can see however
if I come to this and stop one shy of
the last function and run it you can see
it never evaluated any of these this is
kind of like the employees at work right
you know some of them they come to work
in the morning and say hey where's the
boss or the boss is sick today yes I
don't have to do any work right so until
you have to show the result there's no
reason to do any work that's how lazy it
really is and like I mentioned this is
what really sold me on Java 8 and until
I saw this I was on the other side of
the Fickett line saying oh Java still
sucks and the minute I saw this I said
wow there's a game changer because Java
has taken lambdas really seriously
because without this all you are doing
is you're passing lambdas around this is
what you do in language like Ruby don't
get me wrong it's fun to program in them
but you're going to be creating a lot of
objects intermediate objects but if you
really want to go into something you
know bigger and better like big data and
reactive programming while you can't
survive without these kinds of ability
in fact this is one of my aah ha moments
for me was as I was trying to understand
what reactive programming is a little
lightbulb went in my head and I said oh
wait a minute reactive programming
starts where functional programming
leaves you functional programming says
I've got the function pipeline laid out
for you I've got lazy evaluation for you
go get it and reactive programming says
awesome I'll start with the pipeline
I'll start with laziness and I'll take
it forward into
and data flow computing so it's a very
nice segue into what reactive
programming really does and this is like
the starting point that is not to say
you cannot do reactive programming in
imperative style languages but it
fundamentally hinges on the concepts of
pipelining and lays evaluations from the
ground up so we saw how this actually
works and this gives us a real nice
power but where does this lead us to
well this leads us to some really
interesting things we can do with this
well the very first thing you can do
with this is well the laziness leads to
a few interesting options well when a
function can be lazy you can evaluate it
now or you can evaluate it later and so
you get the luxury of postponing things
so because you can't postpone it you can
start leveraging a few things out of it
so for example let's say I want to write
this particular function I want to say
print the so print the total of double
of all even numbers
well okay off you know 101 even numbers
let's say starting with 51 well these
could be variables so how do I go about
doing this so I could write the code
like this I I could simply say compute
and I could say 51 comma 101 but to
write this what am I going to do well
I'm gonna say this is a even numbers
double of even numbers so so we'll say
int and we'll say compute int star comma
int count and I want to go about doing
this computation we could start writing
this code but that can be really vexing
really time-consuming but we can turn
around this court very nicely we can say
stream dart eater rate and we want to
start with the given starting number
given an element element plus 1 let's
actually stop right here and then we
will go forward after this so let's just
output what this is just to get a feel
for it so then I will simply return a 0
for now so when I run this code you can
see in this case it is going to give us
the detail about what this is titres and
all it is is a reference pipe
line right that's a pipeline model we
talked about so you created a pipeline
but the beauty is that you turret
function says I am NOT going to do any
real work right now
this is lazy evaluation so this lambda
remember the lambda the Apple well you
gave it to the iterate and the iterate
says hey things for the lambda but I
will get to it eventually I don't have
to run it right now and so the start is
the starting point it didn't exercise
the lambda it just said I'll wait on it
well the beauty of this is now you can
start leveraging this so how does a how
does this actually work it's an infinite
stream so it can keep on giving data
every time you ask for our data and
here's a way to visualize this if you go
to a fairly big you know government
office or agency like a driver's license
office what have you well there's a
large crowd of people waiting so what do
they normally ask you they asked you to
go take a number picket right into what
I'm talking about so you go pull a
number ticket and you say oh this is 282
it's gonna be a long wait well that's an
infinite series if you don't believe me
well go find a child and point them to
that machine and they're gonna plug
several tickets like whoa wait a minute
right but everything is a unique number
that the key keeps coming out well
that's kind of like your infinite series
it can keep producing number but only on
demand so every time you ask for a value
it gives you a new value well now that I
have a way to generate these values
what's the next step I'm gonna do well
I'm only interested in even numbers so
I'm gonna say filter given a number even
II only send out even numbers and block
the rest well we went from an infinite
series of numbers starting with start do
we went to an infinite series of even
numbers that start with start with yeah
even numbers that start would start but
then we're gonna say dart limit and then
we'll say count well
infinite infinite not infinite
so we transformed from an infinite
series to infinite series to a finite
series a bounded series so this one will
only have account number of values
but here comes the charm the limit is as
lazy as everything else so you go to
limit and say limit what what is your
job and the limit stays when hundred of
them go by I will close the door well
that's awesome limit what have you done
so far and it looks just like do you do
I look like anybody who does anything
really right so it is just lazy and say
it stuff will happen and when it happens
we'll worry about it right so it's not
gonna move a muscle until that is
imminent in other words limit is lazy
and until you have a terminal operation
nothing is going to happen so now what
am I going to do at the very end well I
could even go a little further I could
say map given an element element times
two I can add more things to it so we
could say map to double and then in the
end you need a terminal operation one of
the most common terminal operation is a
reduce but it comes in different forms
or reduce comes in collect or as a
reduced function itself then there is
the fine first is a terminal operation
well another reduce operation is the sum
operation that you could use so now what
I can do here is I can simply say return
and call that and and get the sum out of
it or this is actually a double value is
it so in other words there should be an
int in this case so we can see that it
is actually a value that was computed
based on it so we can easily see how we
can use the lazy computation so we are
using an infinite series here but of
course it would not have worked had it
not been for lazy evaluation so lazy
valuation makes the infinite series
possible and the minute we get a hang of
infinite series we begin to explore
problems that we never explored because
we didn't have that little tool in our
hand until now in Java but it opens up
door for so many problems have to be
solved in this area I keep discovering
things I could actually do with infinite
series as I experiment and play with it
it's pretty you know phenomenal in that
in that way so we saw the infinite
series and
how we can use as a sequence generator
to do that very effectively but I want
to take this further too one little
example to show how we can actually
start benefiting from some of these
interesting things so what I want to do
next is I want to take a little problem
assuming my internet connection holds up
let's see if we can actually do this so
I'm gonna make sure if I'm able to
connect to the internet let me just see
here so yeah it seems to be let's see
you hope it works so let's give it a try
so what I want to do is the following I
want to compute so I'm gonna simply say
time a dart code and this is going to
just compute the time a code is gonna
take it's just a little code I receive a
lambda I measure the time before measure
the time after and report how much time
it took right just oh nothing really
spectacular about it so all I'm going to
do is I'm going to say compute eager and
that's what I'm going to compute eager
and call that function and to this I'm
gonna pass the curse dart symbols so I'm
gonna pass a bunch of ticker symbols to
this function see how much it's gonna
take to compute so let's say public
static and I'm gonna go ahead and say
void and in this case let's say compute
eager takes a list of string will call
it symbols and what are we going to do
in this code well the first thing I'm
gonna do is say list stock info and
we'll say stocks is equal to stock
fetcher Dart
well let's go ahead and look at what
stock vector looks like so the stock
fetcher is a class I have here and it
has a function called fetch stock prices
so what a spec stock prices do it takes
a bunch of symbols and goes out to stock
util gets the price and returns to me
the current price of those stocks and I
eventually return a list of stock info
so nothing really you know special here
it takes a list computes the stock
prices based on getting from the from
the web and then returns to me the the
stock information that's all so let's go
back to this code and call that function
and pass the symbols to it so that's all
we did so far well that's great so far
so what am I going to do next I only
want the first star
symbol or detail for something greater
than five $200 so stark start stream and
what am I going to do now I'll say
filter and I'll say stock info and stock
info price is greater than 200 . find
the first and all I want to do is just
print it so let's go ahead and output
that function output the detail right
now so in this case if you look at this
example if I go back and run this you
can see that it's trying to run it so
it's going to go out get all the stock
prices then find the price that's
greater than 200 and get the first one
out of it and print it so once it's done
is going to display the data for us this
should be done in the next few days so
when it is done we can see what the
stock price was but what did I do wrong
here well look at line number 6 line
number 6 is returning a list which means
I went on and brought all the data for
you I am being very eager I did not
bother to ask you what are you going to
do with this information and what for
all practical purposes on line number 8
you could have discarded the result and
moved on and all the effort I spent
computing it is a total waste of time do
you agree with me right so I never
bothered about what you're going to do
with it
I eagerly brought the data for you well
it took us 26 seconds and Amazon why no
surprise 780 dollars and 22 cents so
let's do it redo this and if you don't
mind I will comment that out I don't
want to waste when you do seconds doing
it or 26 seconds so let's do this again
this time but this time I'm gonna say
compute lazy so what am I gonna do in
compute lazy in compute lazy I'm gonna
start out with public static void
compute lazy just like the other
function list of string and then I'm
gonna say symbols one more time but I'm
gonna say right here
well output will start with that again
but I'm gonna say in here stock fetch
your dart fetch stock
crisis lazy and I'm gonna send the
symbols to it so then I'm gonna say dot
filter well tell you what let's just
copy and paste these two lines right
here and we'll just use that right about
here so I just modified the code just a
little bit where I said I'm gonna call
the stock price lazy and then take that
and call the filter on it and then take
that and call find the first on it so
I'm gonna kind of move these a little
bit here so but we don't have that stock
price lazy it is it is surprising how we
don't have to do much at all actually so
notice what I'll do now I'll take the
stock price lazy function and we're
calling the stock future stock price
lazy and you can imagine what is line 7p
and going to return to us a stream right
so rather than returning a list I'm
going to turn a stream so think about it
this way I travel a lot and and so one
of my common destinations is is Oslo so
I live in Denver I want to go to Oslo
the most ideal route would be I go to
the Denver Airport take a flight and
land in Oslo nine hours later the number
of times this happens is zero so I will
first take a flight from Denver to you
know Newark and then from Newark to
Frankfurt and trust me Frankfurt has the
best showers in the airport and then of
course after about six hours in
Frankfurt and I get to Oslo and several
delays later well that is like passing a
list to somebody and they give you a
list and you only take the list to pass
to the next person they give you a list
and any pass a list well instead if I
take a straight a list and convert to a
stream on a given stream he gives me a
stream I hold that stream up in the air
so to say and have passed the stream to
him get a stream I pass a stream to her
get a stream and now how much work have
it done so far zero right absolutely
lazy because this is all things we laid
out the pipeline we never did any work
until we call a terminal operation so we
can delay postpone it until we no longer
can postpone it
so notice what we can do here now I'm
gonna go back to this code and say well
in this case we're gonna call this as
stream of stock info and then I'm gonna
call this as lazy and this takes a list
of string let's call this as the symbols
of course and then we'll come back to
this function in just a minute so we
need to bring in the stream dart stream
of course then what I'm gonna do in this
code is simply say well return to start
off the bat symbol start stream so you
gave me a list and I'll get to a stream
I perform a map operation stock info and
I'm gonna call the get price on it and
return it so notice how this is even
more simpler than the code we wrote in
the top because you give me a list of
symbols I just got a stream out of it
I'm gonna perform the transformation
pipeline and I need a mapping but the
map says guess what I don't need to do
this stuff right now I've got it in the
works
I've got into the plan and I will give
you the pipeline and you can go extend
the pipeline so look at line number 17
what happened on line 17 on line 17 it
returns to you that that's all it did
right and it says here you go and on
line 17 it returns to you that one piece
of the pipeline and so what are you
doing now you come back here to line 17
incidentally the same line number here
and what are you doing you're saying oh
thanks but I'm gonna take what you gave
me I'm going to extend that pipeline now
and I've attached a second piece to it
and then you are introducing a terminal
operation after that so you got a
pipeline not a result and then you're
extending the pipeline to your heart's
desire and then you decide you got three
options at this point a exercise at
terminal operation B send it to somebody
else so they can increase the pipeline
further or three throw it away you don't
care about it anyway in all these three
cases no work was actually done a very
minimum data structure was created in
memory but the majority of the work
didn't get done at all well of course
let's see if this is actually true if it
actually works so let's go back and run
this little code and see what it is
doing and then we can get a feel for it
let's fix the error here so what what
line number is it so in stock fetch our
line number 14 so let's go ahead and go
back and fix it so a public a static not
stock okay so there we go so let's go
ahead and try that out so see what it
wants to tell us
Oh stock info I get price so this is
going to be the map operation and this
is going to give us the stock
information this is stock Utah not info
so when Kay doesn't know how to type ok
so let's go back and run this code and
see what happens well clearly you can
see that it's still trying to run well
the last time it took us about 26
seconds to go do the job well it depends
on which price is more than 200 I don't
know for that for sure but we know one
thing for sure it was not the last one
right so it took us about 8 seconds
instead of taking about 26 seconds
because we're absolutely lazy in
evaluating this so so we can start
thinking about so when you start
programming in reactive applications
you're gonna see this over and over and
over because in reactive systems in
reactive applicable programming you're
gonna pass data flow through these
transformations but you don't hit any
transformation until you are lazy
evaluating it you begin to read that
benefit at that point and you can start
pulling the data and and dealing with it
very nicely so this is one of the nice
things that it provides for you is the
code can actually be efficient when we
use this properly and we can greatly
benefit from it
so to summarize what we talked about
while functional programming emphasizes
immutability it emphasizes higher-order
functions I always wonder why it's gotta
lead to a greater cause well there are
several benefits of course are financial
transparency and various other things it
provides in an easier to test easier to
debug so on and so forth however to me
one of the charming features of
functional programming or two of the
charming features I'm from the
programming is the function pipeline or
function composition which is what
you're seeing right here is that
pipeline in front of you that is drawn
and then you also want to be able to
enjoy the lazy evaluation the function
pipeline
and the lazy valuation go hand-in-hand
it gives us expressiveness of the code
it makes the code concise but without
losing on performance at the same time
and that's what it gives you really so I
hope you would be very eager to employ
laziness in your code I hope you found
it useful thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>