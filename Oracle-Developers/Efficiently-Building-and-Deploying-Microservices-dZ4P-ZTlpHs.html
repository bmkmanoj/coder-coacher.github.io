<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Efficiently Building and Deploying Microservices | Coder Coacher - Coaching Coders</title><meta content="Efficiently Building and Deploying Microservices - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Efficiently Building and Deploying Microservices</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dZ4P-ZTlpHs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon hope you all survived the
party yesterday yesterday welcome to my
talk I hope you enjoy it my name is Bart
blowhards I live in Belgium as you can
see from the slide I have an email
address and a Twitter account so you can
contact me on either of those probably
not so very impressive to you guys next
up I work through HP Enterprise Services
I'm in our Java capability we have about
60 to 70 Java developers in Belgium and
my current project is at the Flemish
government I've been at the Flemish
government I think for about three to
four years now and we've been doing
micro services since I was there
actually now micro services are like a
more broad concept and our micro
services really don't take all the boxes
because we started doing micro service
before there were any boxes but what we
do see is that during the current
evolution the the hype regarding micro
services that problems that we were
facing are being solved today so really
for us it's also very interesting to see
how it goes from here just one small
disclaimer I know I work for HP and I
know you said you can contact me but I
really I can't get anyone free or cheap
cartridges for that printers so don't
contact me for those even IFIF I could I
I wouldn't be allowed to get that much
lasting about myself I have an account
on on github where all the code that I'm
going to display later on will be will
be pushed so you can get it from there
and I also have small blog where I
sometimes post some some things about
technology or about micro services okay
let's start my talk for today is consist
of three pieces its first its micro
services so why should you care about
micro services what are they what are
they not second part is building and
deploying so
I'm going to show some codes I'm going
to deploy some codes talk to you guys to
it and finally it's about efficiently
what are some problems that we faced how
did we try to solve them which pitfalls
can you try to avoid so basically
everything was in the title um should be
a good start
first why do we care about micro sources
well we used to in the past we didn't
care about micro service we were
building large monolithic applications
with several layers of more complex
nests and more for both gold and more
things I really don't care about and we
see that monoliths they work absolutely
work but they don't scale they scale
very difficult if you for example your
application one part of the application
that really is used by a lot of people
then it's very difficult to scale just
that one parts you're gonna have to
scale your complete application I don't
don't want to scale my front and if my
database is getting hammered
next up monoliths due to their nature
they're difficult they're large they
they they don't play well with with
technology changes then they're
difficult to understand to maintain so
and then the last part and that that's
first that's the interesting part
my melodic applications make it
difficult to adapt new technology and
you start your monolithic application
one day you say oh yes I'm going to use
the break the latest cool framework
outer struts one okay yeah you've been
there and then a year later you think oh
my god why why did I choose this I'm
going to change it to struts - and then
we're today and you're thinking oh my
god what I had on that now it is quite
difficult if you want to get both those
technologies out and want to do
something new another problem that I
personally have had to deal with quite a
lot is a melodic application it's like a
hard house of cards if you just take one
at the bottom that's probably going to
make all the unit tests fail very easy
example try changing your hibernate
mappings if you have a list of
think that's a Hewlett fetched and you
want it lately go ahead try to fix it
their units they probably will all fail
so microservice wants to solve that
problem now there is not a very formal
definition about micro services and I
think that's a good thing because a form
of this decision always always imposes
constraints micro servers have certain
characteristics and you can pick the one
you like we a Flemish government we
really we don't take all the boxes but
so of those karstic characteristics that
you will find a lot in most projects are
the ones that I'm going to talk about
right now so micro servers are small but
small does not mean that are not it's
not about lines of codes so really don't
think that if you're going to do
microserver that you're going to have
very small amounts lines of codes
because it small means it's about
responsibility Microsoft's do just one
thing get a product that does not mean
get prices from the product I don't care
about the privacy prices my use cases
get the products so that's a micro
service there have been quite a lot of
questions about people that I see here
sitting in the room that are asking them
where do you define the boundaries of
the the micro services and I hope that I
can point to point you in some some give
you some guidelines about that
so about business capability about use
case not about offline lines of code and
also and this is important there
stateless you can't go to micro service
and so do something and hope that it's
going to know what you did okay now
decomposition imagine that today you're
working with a large monolithic
application and you say okay this micro
services I can work with that I want to
try it I want to do it a proof of
concept then you are going to decompose
your existing melodica large application
into several micro sources and in that
regard that gives you the benefit of
scaling you can get the DD the green
triangle you can scale it out you can
put it multiple times into production
another I'm going to show a demo about
it later
under the characteristic of micro serves
is smart endpoints and them pipes that's
actually a quote by by Martin Fowler and
James Lewis who did an article on micro
source and I really think that that
that's an interesting one and also
there's this discussion about micro
service is just like more a pragmatic
approach of a service-oriented
architecture that might be true but I
think this is really a difference
because if you want to buy a
service-oriented product then you get
often really really smart pipes and you
don't want that you want your
application to be like the epicenter of
intelligence you don't really care about
what the protocol that's going between
nobody cares I can change I can't change
those I can change the application so I
want you up responsibility till I really
with micro service and so keep the
communication DOM
another thing is regarding find drains
or course drains communication with
micro services since they are about use
case about business capability you also
want to have a more coarse-grained
communication mechanism you want to ask
the product and for example the product
has a description maybe in different
languages then you get the product with
the description if that's your use case
if your use cases give me the product
with the prices then you get one
transaction give me the product with the
prices if you have really like like a
fine-grained communication then it's
going to be a chatty communication ask
for the product ID ask for the product
description ask for the price that
that's that's not going to be a very
performant application now smart
endpoints and dumb pipes you can you can
see it in two ways right communication
can be synchronous or it can be
asynchronous later on i've examples of
both of them and they bring some some so
knowledge with them that you should be
aware of if you choose that you're going
for a synchronous communication with
your micro service then it might look
like the driving here you have your
replication
and for every call it's going to going
to go over the network of the internet
that might probably be not not be a good
ID it might be a good idea free
application if you're only calling to
services might be useful but if you
really have a large application that is
composed of different micro services
maybe you want to put something in
between but we call an api gateway or
api mashup where your web application
goes over the Internet to the Gateway
and then the Gateway talks to the micro
service via the internal Lum network
it's going to be faster another
advantage of this is that you can really
make an interface especially for your
consumer for your web application you
can combine you can orchestrate
different micro services together so
that the consumer only has to ask one
question give me the product and that
internally you can also decide from well
this customer who asked me this I have a
contract especially for him I know he
wants the prices internally I'm going to
do a second call to the prices but
that's an internal communication it's
not over the over the network so it's
not going to be going to cost latency
problems now the synchro's yes go ahead
that's actually a good question because
it comes back to the previous one where
you want to keep the community the
communication them I think your mashup
layer is a micro service so you have you
have a couple of micro services combined
together in a new micro service and the
communication states really don't
because you're asking one question to
one micro service it's a gateway because
maybe it holds different micro service
or it's a common interface to different
micro services but it's in itself is a
micro service it's it's a stupid thing
just cause other things no that's an
answer to your question I kind of
expecting that home to be honest now the
synchronous with the API gateway it's
useful it's interesting but there's
still one large caveat it is a single
point of failure if you have one
Microsoft that it's not working it's
crashed then your end user the web
application from your user it's not
going to work it's going to fail
with asynchronous communication you can
solve that problem I see two solutions
we have lightweight messaging where your
web application asks question two for
example a an API messaging gateway and
the Gateway goes to ask the questions to
different micro-services and the Gateway
will answer you whenever he got answers
so this means that for example if the
the the one application the the red
circle is down then the web application
is still going to get an answer that's
cool right we can deploy a new red
circle and the web publication will
still work it's great right another
approach to that is like the event based
approach and this is really gaining a
lot of traction in in the microservices
world many people really save and don't
go synchronous don't go with its
lightweight messaging go to the event
driven approach I don't necessarily
agree with it I think those decisions
are our decisions that you have to take
very smartly if to think what kind of
communication what's my use case what do
I want to do now the event based
approach it means that Microsoft start
talking to each other for example you
have Microsoft that publishes products
it has the product catalog and is going
to say to some to some queue like
rabbitmq it's going to say van I have
products this is my product and then the
guys from accounting they're gonna say I
don't care about that I'm not going to
listen to to the events by that but at
micro service but sales guys there goes
the all-new profitless Go Go Go Go Go so
really that that's about the approach
you have one central messaging service
and all your micro service can can
publish their messages on it and you can
have subscribers did you have a question
ok no problem
now just in just a second I'm going to
show you both of the synchronous and
asynchronous encodes now another um yeah
sure
kiss me yes no uh you could actually
implement it with with an Enterprise
Service bus the problem is with the
Enterprise Service bus is that you're
going to use like like a product I don't
want to use the product I want to build
something that tails from my needs if
you use the machine messaging capability
of your of your service bus for example
we do it actually with an Oracle service
so I know it's possible to do it in that
way then you also get it's not
lightweight anymore it's going to come
with its own configuration files is
going to combat its own deployment is
going to come with its own rules and I
don't want to live in that ecosystem I
won't have like the most simple
messaging bus that I can think of for
example you have Kafka your epidemic you
just publish a message something and you
forget about it it's on but there are
definitely some some some comparisons
that can be made so that that's very
very viable correct question okay
something else about the micro serves
and this is really for us for developers
this is the cool part micro service they
have a decentralized governance so micro
serves the important part about
Microsoft's is the unique API you are
going to publish an API and your
consumers your web applications your
mobile applications they want to know
what the API does they don't care about
the technology that lies behind it so if
for example you feel like trying new
technology you can just publish an API
it's not it's not it's technology
agnostic if you're doing Java today and
you want for example to go line tomorrow
you can just make sure that the API
because that's the important part that
has to be the desk to work between the
different applications was a question
well that depends on what you're trying
to to how do you define the API for
yourself you can you can have formal
contracts you can write them for example
in the word document if you feel like
doing something like that don't or you
can just publish the interfaces as Java
classes and say well these interfaces
you will have you will be able to call
us like this
but the underlying technology that's
being used you don't get to know that we
decide that for you but this is the
interface you call the get products and
you give maybe like a date or something
or whatever it is you want to give to it
and that that's really the contract and
we're going to see the the date format
that you're going to the data format
that you're going to receive but we're
not going to tell you how you're going
to how we are accessing the products
internally okay so it's language
agnostics and and I think that's really
a cool feature to multiple versions are
encouraged so if you today you build the
product service version one and it works
people are using it but after a while
you see that it's not really that fast
anything from okay I can do performance
optimizations keep version one into
production people are using it don't go
to phase out make version two maybe in a
new framework maybe use new technologies
so really it's evolutionary you start
somewhere today you release it and maybe
in the future there will be multiple
versions of it so that's also an
advantage with microservice you don't
really have to think about backwards
compatibility
you have your interface that stays
that's that should stay you can also
make the interface backwards compatible
but the version that lies behind it
really nobody cares about it if it's
event-driven
you can have the product service version
one publish its response you can with
the publish the product version to
publish its response and you see what
what FD API gates rate does with it
maybe it doesn't want to wait very long
and it goes to publish the answer to the
the consumer right away and then maybe
version one is just too slow that's
possible
another thing about that is since you're
doing multiple versions every version
can be disposable so you're going to
write code and you might throw it away
later now this is also really cool for
us developers decentralized data
management I really like same political
persistence because it's an annotation
but it really means that nowadays you of
your big large monolithic application it
has it runs on a most of the time a
relational database really large
databases cost you a lot of licenses
lots of hardware going to play that you
need to buy with micro serves you really
save every service it has its own data
storage and you can tailor the service
to the data storage and vice versa so
you can have your one application that
goes to the relational database and go
fetch this product information there and
you can have another one that goes to a
no sequel database because it makes
sense for that so that's really possible
you don't have to worry about that the
large database when building the micro
service this is actually a closer
alignment to the business than than what
we used to do in the past and I will
give an example from that if you have
products I keep talking about products
can I try something else in a minute
if you have products then the
engineering team are interested about
why to the measurements the size the
weights the sales team they're
interested in the price the engineering
guys they don't need to know the price
so okay you can you can split them in
table and everything you want but it's
from a business scape from from really
business point of view they're not just
one table does that make sense
I think it does now I have a follow up
on that slide eventual consistency if
you have read decentralized a data model
then the first question that comes to
your mind is well well okay you you
updated two products but that other rep
stood up the load micro service is using
another product database how does it
work together because I want the updated
information so for that we introduced
something called eventual consistency
and that means actually in my opinion
that you have another micro service that
really travels around to different data
bases and at a certain moment in time it
updates the
all it can take some time this is also
interesting for reporting for example if
you if you're selling products and you
want to know an okay we have different
micro services selling products selling
a product to the engineering team
selling a product to whoever we want to
have one sales report that says one PDF
that says ok this many profit sales
results so eventual consistencies there
will be some kind of synchronization
afterwards and this also comes back to
the do one thing if you're for example
you're creating a product you're the
owner of the catalog you want to create
the product then you think about okay I
want a coarse grained communication so I
updates the products or I create the
product and that product it comes with a
product description you don't update the
product and then wait for a bit and then
go update the description because then
you will have F and then you're not
using then you're abusing the
distributed transactions and we don't
want to do that we want one really
coarse-grained communication that says
update the product and this is all the
information you need for updating a
product designed for failure as we're
going to see in a bit microservices
applications that are built with micro
source they have a lot of moving parts
so we are one large application that
it's going to have quite a lot of micro
services any of them can and will fail
so it would be really great if your
micro services no steadiness failed and
it can just restart itself because then
it's not the problem of the operations
team anymore of the DevOps team whatever
you're using in time that's actually
possible so the first time it crashes
you're not going to know about you're
going to look at the monitoring
dashboard and you're going to say null
pointer exception probably somebody else
touches it but if you can find all those
problems and solve them because you can
have multiple versions you can do they
are disposable to then the micro service
really they should be self maintainable
as much as possible without some humans
interacting and we also see that that
many of the frameworks that are used a
to build micro-services they come with
monitoring they know about this
they have metrics they have systems to
say well okay when when is a system
healthy when is everybody happy and when
when we love doing workout right I will
also show those in just a bit now just
as a side mark and coming back to the
previous one I actually think also that
monolithic applications should be
designed for failure let's we often
think about it at the end okay now it
works we put it into it has post UAT we
need some monitoring here and there but
that's really not the case you should
think about monitoring from from day one
because it's going to be just make your
life easier with microservices it's a
necessary really to have the monitoring
because of the many moving parts there
is question
okay so the question is does polyglot
persistence make disaster recovery
recovery easier or harder I actually
think it makes it easier because you
have the eventual consistency there is
nobody who uses the system from from the
development of the operations kind that
expect that all data will be there at
all time if you for example you think
about the most simple form of disaster
recovery is just backing up every 15
minutes
backing up a database with products that
contains only product information is
going to go much faster than when you
have this large Oracle database ever at
an Oracle conference that consists of 50
million records and due to backup it
cost a day and a half it's going to be I
think it will be easier also DDD
eventual consistency micro service
that's in place we had just run it
against the backups and it's done
automation we're pretty used to doing
continuous things at the moment I think
most of us have some kind of continuous
integration pipeline in place or are
thinking about it that's a good thing
and micro service really micro services
really show you that there's a need for
this I don't want to go deploy 80
applications every time at that Flemish
government currently I think with 87
micro services in place I'm not going to
deploy them manually
we have 114 servers where those things
run on I'm not going to deploy them
manually so the advantages and I'm going
to show that in a bit that you don't
need to need a new tool you can use
existing tools that exist if you like
Jenkins use Jenkins I like Jenkins it
works for me just configure your
development pipeline and done other
technologies work as well of course so I
think that automation really is as an
enabler for micro services if you start
with micro service and you think well
I'll start by by deploying it myself you
might fail so really it's so easy to
have a continuous integration pipeline
these days just talk to to the UAT or
the production guys that you can have
your your deployment like that with them
have them do it have them present
them I think you need it so just a quick
recap and then we're going to look at
some code Microsoft's are small they
have preferably smart endpoints and dumb
pipes the decentralized government means
that we get to do what we like
decentralized data management means that
your data base is going to be less of a
problem because it's going to be smaller
it's going to be really tailored to the
solution to the micro sources that
you're building design for failure
because it's going to fail like any
multiplication will fail and automation
ok building and deploying I'm going to
switch to my other laptop right now
I hope I'm going to switch to my laptop
right now oh come on over here I started
out with the most simple example I could
think of a microservices that consists
of five classes of which three are
basically glue code yes yeah sure better
okay so before showing you any code I'm
just going to run it and we run it like
this oh I need to actually go there so
this one is running spring boots I'm not
going to explain spring boot in detail
because it's actually pretty simple what
it does when I launch it with java min
jar it just starts up a tomcat instance
and it's going to deploy my application
on it so if you're thinking continuous
deployment it's only one line and it's
one line as we all have typed for a
million times so we know it works okay
so it's running at port seven eight nine
zero let's show you what it looks like
seven eight nine zero it's a person
service and it shows persons that's
really as simple as I could think I'll
try just another one to show you that
I'm not cheating that's me now how what
does it look like this is the person
microservices and it has it has even
four clauses I thought those five so
it's even smaller basically if you're
using spring boot this one is important
this enable auto-configuration spring
boot has defined a number of conventions
of configuration conventions so that you
don't have to do it all by yourself if
you're you can of course change them you
just add a properties file I have one
for the for the ports if you want to see
the configuration is just perfectly
visible in your application okay guys no
problem I'm not going to explain this in
detail but it's it's really spring comes
with this configuration that thinks it's
feasible
if you want to change it then you just
at the properties file for for the
different keys now another thing is I
was talking about the metrics about
monitoring and here we have it I didn't
do anything for that the only thing that
to get these metrics that is necessary
is at one dependency - in this case it's
maven project you just add the actual
spring actuator dependency and you get
monitoring you also get quite a lot of
difference endpoints and that are taking
care of by spring I don't know if it's
readable okay so for example we have if
I can see them like this we have person
we have error we have pot and so on so
spring comes with a lot of interesting
things that just to enable you to do to
build your micro sources now one thing
that I also want to show you right now
the metrics show me that there are been
there have been two requests and they
both have been successful now let's do
one that's not going to be successful to
see what happens so we have a person ID
that says ëi and that's bad request
right yeah so when we go look at metrics
again we see okay the person service has
a status 400 maybe want to report on
that maybe you don't but you also can do
is this is just counter right as a
sample if you want to have helped checks
off yourself you can configure them in
in spring boots now I'm not saying that
you should use spring boot but there are
some options I'll make it a bit larger
another one that I want to show you is
drop Wizards and then we're going to
look at the code so drop us at runs at
port seven eight nine one and seven
eight nine two so that's different from
spring right seven eight nine one and it
shows addresses really simple
now you also saw that there was a second
port running and in spring boot that is
actually used for metrics so information
for your monitoring
now there's also one thing that's very
interesting about about drop wizard drop
wizard throws you shows you a really
ugly large warning if you don't define
health checks so they want you to define
your own health checks and then you can
also just look em over here and you see
that address is healthy because I'm just
returning true
so it really enforces you to to think
about this behavior okay look at some
code the person application I explained
to the enable auto configuration and
basically this is it
this will run the person application
that's not too difficult right this will
start up the tomcod instance deploy your
application and make sure that it that
it has a server somewhere that you can
contact so I did a rest controller
I call it person controller and the
interesting code about this is basically
this very simple just added a spring
annotation on it and it gets a person ID
from the repository now just for the
example it's just hard coded repository
I'm not going to do it spring actually
spring boot has some really neat
features regarding integration with for
example MongoDB or your relational
database but that's beyond the scope of
this presentation so but they're
available so basically those two classes
make the application adjusted I know
it's very simple it's very small but it
does work and it shows you really the
main thing about the micro services just
for come to make sure here is the person
hard-coded here the POJO there's really
nothing more than than what's it like
two classes two methods it's really easy
right okay then the address was showing
earlier this one actually has five
classes or even six okay look at that
why is that because it has the address
health check that spring boots really
I'm excuse me that drop is it really
wants me to make so I just did some
dummy implementation and address
application this is what you need to
write if you want to have a working
microservices with
wizard now drop is it default doesn't
use Tomcat it comes with a jetty
implementation how can in boat you can
also produce a war file that if you want
to deploy it for example to your
enterprise application servlet you
already have it just perfectly possible
just configure it like that now what's
interesting about the the drop Wizards
example underneath this is the
registration and first of all the health
check and also actually of the resource
and my resource here is the address
resource and it's very very similar to
to spring boot very either rest
controller here also I just add some
annotations because it's it's a further
part and then and get to get your
address so that's really that simple now
in this case the the drop wizard service
it's using a JSON file to get its
addresses because in a bit we're going
to update it but again in a real use
case don't go using hard-coded values or
our JSON files yes I'll come to that in
later if it's okay for you another thing
I want to explain about drop wizards is
actually that's not it this file is what
I wanted is deep configuration so here
we have it drop Wizards um uses
configurations for example if you want
to connect to other web services or if
you want to connect to a database so you
need a specific implementation and this
one is just empty because it's not doing
anything useful yet the the other
example that I'm going to show you right
now actually has some configuration
where it's going to use a Jersey clients
to call other web services so the person
address here we have it the person
address application it's going to call
the running person micro service and
address micro service so let's just do
that I'll make it bigger
so it's starting person address it's
running ads reports seven eight nine
five so it's getting this information
from the first web service this the
first micro service and this information
from the second micro service now bear
in mind that these are all synchronous
calls this means if I shut down the
address service that is not going to
work anymore so I'm going to do that
because doesn't really it's not really
exactly true what I say right now you
can shut down the local instance of the
micro service if you for example like
cashing a application in place and the
Boyko service doesn't need to be running
there was a talk yesterday about Jay
cash if you want to do things like this
I just implemented the most stupid
caching I could think of just to show
you that right now micro address is not
working I will show you that it's not
working so it's not there and this one
should hopefully still be working so you
can have this this basic caching now it
only caches my dummy implementation only
cache is the last one so if I start it
again now for a real life product use
something like eh cache or something but
don't cash it like I just did and if I
try it again it should be there so there
are a couple of examples of the the
synchronous micro services I'm going to
go over them before I go back to the
asynchronous versions
thank you I'm going to do that work for
quite some for quiet times now the
synchronous just as a recap it's using
spring boots it launches a tomcat
instance and really it's easy right
there's nobody who doesn't understand
that the second one is using a dress
using drop wizards and jetty again you
can just make it a war also iPhone to
deploy it to something else and here the
interesting part is the resource and the
registration in the environment that is
provided to you by drop hazards and last
but not least the person address it is
just one additional feature over address
that is the the Jersey client that is
going to call both the two other
microphones now the code how simple it
may be it's also on my my github page
you can have a look at it now
asynchronous so I'm going back to the
other one and I'm going to start the
person publisher
it's going to use a person oh that's on
it thank you
so this one is going to use a rabbitmq
for the messaging no personal preference
just very easy to use oh when that's not
correct it's using spring boots at seven
eight nine three that's unexpected we'll
see what happens
seven eight nine three okay the person
publisher actually is publishing in two
phases so one endpoint is just one
endpoint is adding a person for example
here we have Luke Skywalker but it
didn't publish anything to the queue yet
I'm going to show in code why and if I
want to send the existing persons to the
queue I just sent all and will show
everybody who I just added then
naturally we also need some body
observing that which I called person
listener we're going to start it
and it should display everything that's
on the queue so here you have it I'll
add another one just to show you that
it's this work I added Luke so we'll add
Leia we send it to the queue and it's
there so very simple just send a message
to your messaging you and have someone
observing that let's look at the code of
that first you'll see that it's also
rather simple so first we have the
publisher as I said it's using spring
boots so it's only four clauses large
and it also has an application which is
basically empty and a controller the
controller is has a bit more code but
it's still very simple we have been
definitions of the queue of the exchange
those are four four RabbitMQ so that it
knows where to publish its information
to and this time around we have to
request mappings we have a person that's
going to get some variables from the get
and add it to the repository just just
as final reminder this is to make it
easy for me to to demo it on stage if
you really do an application just send a
JSON over don't do it like this but it
makes it easier they need to type less
and then we're going to send it to the
queue and the interesting part about it
is that spring boot comes with a rabbit
template that just needs to know that we
have a binding that says this queue
needs to be binded to this exchange and
we have the exchange in the queue over
there so that's a configuration of it
those three very easy methods and then
just the rabbit template that is going
to send all my persons to the queue
that's easy right now if we only send
something to the queue and we're not
observing it then it's not very useful
so we also have the listener and the
listener looks like this so it has also
the main method but additionally it also
has a message
listener adapter and the message listen
adapter here is a person listener with a
receive message method so that's over
here and all it does is just print out
whatever is on the cube okay
the controller of course is the the
container whether we have over here that
also needs to know what's what cook you
am i listening to and which message
listener is going to do anything with it
so that's in this case the controller
that's basically all that that's there's
to it we have a connection factory that
comes with with the message simple
message listener contain that's a
difficult word and that's basically all
the rest so I go back here personal
listener messages an adapter and then
the container I'm going to put these
sides and then if I just can switch
again
as a quick recap I'm sorry I'm giving
you a hard time okay
as a quick recap so no difference
between the other micro sources just use
of RabbitMQ and as an in spring fashion
a template that's really helping you to
to send your message easier over there
the listener with with the cues and the
exchange and then just binding that the
two together so that RabbitMQ knows that
somebody well that the listener knows
that it's listening to the RabbitMQ cue
okay so we've seen a couple of smaller
micro sources but they're not doing
anything together now so I have combined
a smaller application very small
application called the address publisher
and what's it going to do I'm going to
change an existing address in the
address micro service by using another
micro service so we have the person
address I showed earlier that it's
counting contacting via Jersey person
and address address storage information
in a JSON file because I was too lazy to
implement any database and the async
version where the address publisher is
going to publish an update to the
address to the cue the listener which is
observing the cue and it's also going to
change the file so ideally if I publish
something to the cue and the listeners
running then the JSON file should get
updated and person addressed should show
me the new address I hope this work but
because it's doesn't work it wasn't
working a earlier this morning
okay
I'll keep adding windows everything is
still running except for the address
publisher so I'll start that one first
I'm just turning it up it's all made so
you just do maven clean package and then
you're settled
I just publisher so this is one is seven
eight nine seven oh seven eight nine
seven it does I'll show you first we're
going to update ID too so let's first
have a look at ID 2 if I remember where
I put it 92 so right here gonna click
part-time in Belgium that's actually
where a Prime Minister lifts or sleeps
and then we're going to 7 8 9 7 and
we're going to update it to whatever
Street but I'm not going to I'll change
something here that you know that that
we're doing it live so any cool
countries excuse me
Armenia alright is it spelled correctly
so there we have it okay then we go back
here oh that's not okay I'll show you
accordingly parkland oh this is Belgium
yeah we didn't start a listener yet
I forgot that so we published the
address to the queue but nobody is
interested in the queue so we need to
start our listener address listener
let's see if it send anything yes so you
see here that it's printing out Armenia
addresses have been updated so just
let's hope this works there we have it
so yay
look I know this is very simple example
um but it does prove that that
microservice can be easy right um I'm
also going to show you the person
address one which is still caching come
on Armenia is over there too so that's
about it for the code demos if you wanna
have a look at it and then really try to
understand it just go to to my github
page and then have a look at it it's
it's really as simple as I just
explained this the address publisher is
basically the same as a person publisher
so we also have the controller which
binds the ID rabbitmq cue to the to the
exchange and then here rabbitmq convert
and cents of the addresses now something
else that you see here is the message
converter I'll get back to that or maybe
I just explained right now so in a
moving system in micro-services system
many services will be calling each other
hope I don't treasure stage it's very
important that you know who's calling
who and maybe maybe you want to know how
old to date the data is because we have
a decentralized state the data
management may be the data that you're
receiving right now it's all data we
want to know about this all data and
also the person the person address
Microsoft's is calling person it's
calling address I want to be able to
track that who did this call who invoked
my address micro services and for that
we use a system called the correlation
ID I'll show you over here so for
example here we have correlation ID that
and in ECE in the publisher and the
listener also receives the same
correlation ID so we know who has
invoked this listener maybe maybe we
want to use that maybe we want to save
on oh this correlation ID I don't know
it's not in a format that I'm aware of
I'm not going to answer you can check on
it
I'll show you the publisher is creating
it so the publisher has a message
converter which is Springs approaching
rabbits template where you get get this
message converter and in my case it just
a random uui and in rabbit template I'll
give it a converter the message
converter itself uses the message
properties where it's going to add the
correlation ID in that I just randomly
put the UUID in so the publisher is
publishing the correlation ID and the
listener is going to it's not going to
check out it's going to print line it
where did I put it over there
so the message system adapter has a
method called extract message as you
would expect and in that message you can
get the correlation ID now if you're
doing a reasonable implementation then
you might make your own message listener
adapter and just inlining it like I did
well it just really shows you need to
know where where spring is going to put
it if you want to have a spring boot and
drop is it working together then you
need to know that both have access to
the property where the correlation ID is
stored in that's only what I'm trying to
say here if you if you use it like this
it's not intrusive of your your API so
the consumer it doesn't see the
correlation ID maybe you want explicitly
to do that maybe want to tell the
computer consumer if you contact me you
need to give me some kind of random ID
so that I know that you are the one who
called me I'm going to maybe start and
in my own no sequel database and report
on it later so it's it's a consideration
you have to make they want to make it
part of your interface or don't you both
are possible okay
I'll hurry up now because I really want
to do the efficiently parts
okay so regarding automation you you've
seen me starting Tomcat and jet the
instances deploying my application on it
basically you didn't see it because the
the frameworks all do it for yourself if
you have a continuous delivery pipeline
like Jenkins you just make sure that
command gets executed really nothing to
it but it's it's a it's a necessity if
you're doing Microsoft's because our
simple application that I showed you
right now has five servlet containers
and a messaging queue and it's it's
probably the most simple example that I
could come up with so really think about
it if you're doing micro services make
sure you're using like like Jenkins or
bamboo or whatever you like and use it
from the start we didn't and we should
have done that another thing that might
be interesting in today's world is use
of a pass but from as a service like
like Cloud Foundry or whatever you like
because they come with quite a lot of
tools that that make life easier for you
you don't have to install anything
yourself any more or less any in in in
in DOS solution so it's interesting to
to look at those two efficiently I still
have some time but I'm going to hurry up
synchronous versus asynchronous many
people say that micro services should
all be asynchronous and they should also
all be event-driven I don't agree with
that we're not doing it like this I
think you have the EF the choice but
it's a very important decision you have
to decide from the start and what is
going to be my personal rule of thumb
when it's going to manage something
going to be synchronous and when it's
going to be asynchronous so really
decide early and then evaluate your
decision what we use as a rule of thumb
is if you're reading information if
you're requesting information from
something then you could do it
synchronous because you want to responds
immediately if you're updating you're
creating stuff that's generally not the
case if you're updating a product and
sent a message to the bus say update
products you don't so that's our
approach and further it's really working
now this interest governments I know I
promised you guys you could go cray
tonight with all new technologies and on
the alpha version preferably of anything
you could but really if you're if you're
building a code that's going to run in
production if you're going to have like
30 million calls a year
think about it wisely you can and but it
doesn't mean that you should you should
change technology when it makes sense
for example if you're doing struts one I
hope you're not then it then just change
basically change yeah go home tonight
and then use some other framework
usually use angular or whatever you like
but it's important if you just start
with a common technology set we call it
our technology stack and we actually
have made a maven archetype that
generates the web servers the the micro
service for us so we just put in some
configuration
say what's the API is going to look like
and it's going to generate the the micro
service we're not going to write the
boilerplate how few it all it is we
don't want to write it ourselves so it's
not a lot boilerplate anymore because
there are some conventions from example
from spring we're using spring but it
just generate those things for us and
then I'm going to say something strange
now if you're bored then you should
change the technology and I actually
mean that because it makes you focus on
what's happening in the world you don't
want to be stuck with struts one right
okay then modularity and if you looked
at the codes I showed you then you
probably will have seen life quite a lot
of person pojos and address pojos in my
my demos that's because I didn't use any
modularity so you can use for example
the maven or the dreidel modularity
system but have an independence
deployment mechanism for your micro
services so they can all use the same
person if that makes sense for you
person v1 but you can independently
deploy it it gives you options regarding
reuse if you save and okay this
definition of the product is make sense
for for legal it makes sense for sales
but it doesn't make sale sense for the
the engineering team then make your own
so you get options
and regarding deployments um it's also
important that you should look at that
devil practices I know it sounds cliche
but use your own stuff eat your own dog
food if it's too difficult for consumer
to use if it's too difficult for
yourself to use and the consumer is not
going to use it either now you might not
be interested in accounting or in
products but if you have your your
technology stack then then make a
sandwich microservice have everyone on
your team create a record that says I'm
want this sandwich then go to the
cafeteria team have them call the
listener T observer they're probably not
going to do that and then then then they
get the information so make something
that's useful for you because the micro
serves it should be easy enough it
should be small enough that if it fails
if you want to experiment with something
then you can if you want to use the
genuine technology out there go for it
you can but of course baby be smart
about it
don't go deploying 20 different
technologies every day into production
but you can use it experiment which it
really it should be fun also important I
showed you a couple of metrics did I
show you just bring the drop wizard
Patricks yeah I did I did they have
different formats they show you
different things if you make your own
health checks they're going to look
different so monitor your monitoring
make a monitoring micro-service we
actually have that so that's a Microsoft
that travels to the other micro services
and then going to aggregate all that
information together do something useful
with it have make a marketing dashboard
something and also this is not
specifically for for micro serves that
really log everything that there is
clock if it can go wrong but you have
some information about it at runtime
then it's just easier to fix the problem
now tracking I also already went over
this one micro source will be calling
each other it would be really great if
you know who called who maybe even why
they called it so think about the
correlation IDs if you're using a lot of
the technologies you may you may think
that you may decide that you wanted to
be part of your interface if you want
your customer to give you an ID to
identify his skull go ahead that's
actually what we do so everybody who's
contact was cutting it contacting us at
the Flemish government has to give us a
UUID and we store it and also important
and then that's something we also need
to work on is this keep track of the
edge of your data if you have eventual
consistency then then it will also be
moment of of inconsistency so how old is
your product maybe there are new newer
versions out there so I'll show you that
and then last but not least there is an
article by by Benjamin Button it's a guy
from London very interesting article it
sits right here on the slides
micro-service are not a free lunch and
the examples I showed you today were
very easy but if you've very complex
monolithic application if you have it
today in place your micro service won't
be as easy as the ones I showed you they
will have advantage just like like
scaling like like technology agnostic
but it's not going to be easy here your
your there will still there will be a
lot of moving parts so don't think that
you can can rewrite your multiplication
and it will be super easy because it
won't it just gives you more options
regarding technology and than just what
I said don't repeat yourself is a very
difficult one as you may have seen in
the demos I was repeating the address
class several times I was repeating the
person plus several times it is
difficult and there is also not really a
solution for every problem in that case
modularity can solve a lot but for
example if you have front-end using
micro services and you have a date
picker going are you going to make a
date picker micro service that might be
if you're if you're doing complex data
algorithms it might make sense but it's
we're not there is no final solution for
there is not not one answer to two to
every possible problem so really but
don't repeat yourself think about this
very very early now regarding to that
code duplication is not a complete
disaster in this one if you have a very
small
datepicker then maybe I put it in the
code twice or put it in and some kind of
library legacy and marshalling obviously
if you're having a lot of calls over the
network think about the API mash up
gateway I talked about if you have very
large information going over the wire
then marshalling is something that you
should look and there are some
frameworks that exist that really make
this easier for you make it's very small
make it very fast so think about it
versioning is some some small disclaimer
and I really encourage people to have
several versions of their micro-services
in place but also come up with a plan
you don't want to have twenty-five
product services running at the same
time so if you're monitoring everything
and you see that for example version 1 2
to 7 is not being cold anymore it's
disposable get it out but you should
make like a plan for it we did it it's
it's it can be a painful if you want to
look which person service it cost the
crash then API interface very important
you're not going to communicate the
technology you're using with your
consumers maybe you're young you're you
are your own consumer but the API
interface is really important it's like
like if you're doing soap the whistle
that you're making it's important it
should be backwards compatible and my
time is up so think about it very very
good and then regarding the security
questions from just ahead architects
security in from the beginning so maybe
you want to do a similar authentication
send the sam'l token over the wire to
Royal different micro services you
should start with that from the
beginning but it will have impact on the
coach that you're writing so if you have
further questions maybe come over and I
can give you some more examples but
think about security really from the
beginning
yes sure especially my first lights</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>