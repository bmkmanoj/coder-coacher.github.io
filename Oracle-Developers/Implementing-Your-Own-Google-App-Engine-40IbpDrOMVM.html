<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Implementing Your Own Google App Engine | Coder Coacher - Coaching Coders</title><meta content="Implementing Your Own Google App Engine - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Implementing Your Own Google App Engine</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/40IbpDrOMVM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi and welcome to my implementing your
own google app engine presentation my
name is Alexis Tina and I work for red
hat I'll go over the slides to describe
how we had red head actually came with
idea about this project and how we
achieved on what we had now the goal is
or like starting with a small bit of
history basically as probably most of
the ideas it's about as an idea or a
sandbox and that's what happened here I
was in two thousand nine or ten I was
done with my previous project and I was
had a bit of time and I was playing with
what was it at that time really really
like a buzz word was grow up engine and
Android and combining the two
implementing my own app Android app
going against and Google App Engine
back-end and started about thinking
about like being a java ee guy here at
jboss and just thinking about the api i
was thinking like i could probably do
something sealer on my own writing an
sdk i was looking at the sdk i was
thinking about oh we have jboss we have
all these different projects i could
probably start doing some common my own
and the beginning is actually something
that i called my green project was just
the other way around i was doing the
implementing creating my own api and
then implementing one implementation was
against Google App Engine the other
implementation was against Java EE but I
started thinking I could actually
probably do directly implement something
on top of jboss projects or other open
source projects directly on google app
engine API and then the goal when I
discuss this with my colleagues and my
boss and won't be able to actually get
the resources to do that was the goal
was as it has just take an existing
google app engine app drop it into
wildfly will call it alcohol formerly
known as jboss s we call it butterflies
it's less confusing just drop it into
wildfire environment and it should just
work no matter what kind of cool app
engine app you have it should work of
course we are still slowly getting there
there's like a different issues there
are different features that go up engine
provides and we still
have to adjust it but the goal is
overall goal is take how r which is just
dropped into SDK or appspot drop it into
wall fly and it should just work the
goal is when I discussed this and
presented this at Google they were like
oh nice there's like we could finally
say something about know when the
lock-in so you can move your apps
between Google's environment into jerry
bottle red heads or alpha environment
also what I like for example with sdk
you're limited there's no clustering
with appspot there's no way to test
things or debug things properly have a
bunch of logs you can get better you're
not able to debug in the case of this
you should be able to just attach the
debugger to your app to your instance
and debug and see what it does with
redhead we have this goal something
called open shift which is our pass and
we have all the integration with it so
it you have actually have an on-premises
cloud with cave door inside and of
course when doing this the whole SDK
cannot scale right apps for scale scale
and but in this case the whole project
all the pieces are designed to scale I
won't say they're like completely
optimal still only to learn some of the
things but if there is a piece inside
our implementation it is it was a it was
meant to scale just the agenda what's
google app engine you probably know what
it is just like out you see i'll take a
slide and just makes it a bit if you
have more questions Ludo is here he
knows more about it so implementing your
own google app engine I call the project
cape dwarf it's like a long story behind
it basically in cape wharf is a type of
chameleon but if you saw the logo the
logo is like a small dwarf vida cape and
having a chameleon logo when you see it
it's like oh when I see this before it's
like a linux user right when you work
for a hat you're not allowed to have
a chameleon as a logo so we switched the
bitten that's why the dwarf is there how
do the two work together a google app
engine in cave dwarf see that I'll go
into bit of details about how we
implemented some of the things inside k
dwarf if time permits how do a small
demo hopefully I'll have time and any
questions you can either ask me in in
the middle or just put it in the back
and we at the end of the session we will
have like a quick Q&amp;amp;A who's this guy as
I mentioned in our Malaysia still live
in Slovenia and work for remote for
redhead I'm a kid bore founder and lead
I consider myself old-school jboss Ian I
used to lead micro container project
which was the kernel of jboss five and
six I led the CD i weld implementation
do a bit of work on sale on which is our
new JVM language and bunch of other
things like being a trailhead for seven
years you put into many many different
things Google App Engine taken from this
from the from their home home page it's
of course it's lets you it's an
environment which lets you run your web
app against Google's in infrastructure
at the at the end it's all about
services and it's AP ice right you have
this nice well thought API which goes
against the cloud it goes against the
Google's environment and designed to
scale designed to do different things
and so on so let's move to what skipper
skipper as the title of the old
presentation is it's an open source
implementation of google app engine API
at the end for the users it's all about
the API not implementation you as a user
shouldn't care what kind of
implementation that is that's of course
like the nice thing about Oh object
object oriented programming here force
you have interfaces and you don't care
in the back what how they actually do
what they do it's about documenting the
interfaces and you can easily for the
implement implementer it's nice so you
can easily change the implementation in
the back right without you even even
notice
and this is what we do here in cave
dwarf we implement mode like all of the
Google App Engine public API it's
written of course on top of jboss and
other open-source frameworks for example
without in Finnish spend we wouldn't be
able to do in finnish band is j bosses
data grid framework implementation and
so on without without it we wouldn't be
able to do most of the things in Phoenix
pencil somehow uses hybrid search
cabinet search uses leucine for the
tasking we use JMS which is and its
implementation is inside J were wild
flight is Hornet cure and the whole
thing is as we did for previous versions
of Jo SAS or now I'll fly you were
always able to extend the application
server in with jboss or like wildfire
now with a bunch of additional
subsystems when we call now some sub
systems or extensions or like a bunch of
deployers we'll see later on in more
details how that is done but and the
good thing about it is you get the
management clustering everything you get
with wildfly of course you get it get
bored because k dwarf is just an
extension to develop existing weld fly
you can easily be the same instance of
wildflower you can run normal apps or
you can just if you add in a google app
engine app the subsystem is going to
recognize that this is a google app
engine app and it's gonna do a bit of
additional work on top of the deployment
it's super easy to set up locally that
was of course one of the goals you
basically just unzip and run as you did
with any java SE s in previously orbital
flight now it's super trivial to set up
a cluster you just run a couple of notes
and they're gonna like multicast and
you're going to find each other if
they're in the same network of course
you have a way of debug scalable apps
you can plug in a debugger to each of
the instances instances it's gonna it's
super easy just open it like there's a
line in the standalone run scripts just
uncomment that line is going to attach
it's going to wait for you to detach
attach a debugger
as I mentioned it's integrated into
openshift redheads pass we call the
additional like adding support for
different things inside open shift it's
called a cartridge and we have a kid for
cartridge cartridge and allows you to
have an on-premises cloud environment of
course it's 100 pure Java everything's
written job there's no other things like
a bunch of screws but that's it and it's
on github everything is completely open
source the whole project is on github /
and speed because github com ashgate
wharf it's split into a couple of
different sub projects so there's like a
of course you need we need an
implementation of the API that's cave
Wharf blue you have the integration
which is split in two which is caped of
a s that's what the integration with Val
flight lives and if we have a common
project which is like a code that is
shared between blue blue and a s that's
kept of shared I can really simple names
and of course you have to have some
testing and these different things so we
have cable or test suite which is where
all the tests actually live what but
we'll see about testing in more I have
more slides about testing and some of
the quite interesting things about it
there this is the current API matrix or
on how we support different things if
it's a check mark will pretty confident
that it works support you can always
find bugs in it if it's like a small
flower it means that we are not there
yet for it could be for different
reasons for example for XMPP of course
you don't have gtalk servers in the back
or four male we don't have a gmail in
the back but if there would be at the
mint we could somehow integrate an
external xmpp server into it and be able
to do the stuff or mail there could be
other or like up pulling mail server or
calico there we'll do a mail server and
app the cable would pull constantly put
things out of the that mail server
something that we focused more on other
AP eyes and just recently we added some
of the things that were missing
we implemented several things and apart
from the API as you can see if you can
see it this is which is a bit more gray
those are not the api's those are the
different extensions or different
features of the google app engine for
example of course we have some sort of
support for admin console which you have
in sdk which is like a more development
admin console which is what we mocking
cable of course you don't you're not
able to completely mock the apps app
spots admin console and then of course
we support the jph radio extension which
is that data nucleus is Google App
Engine plugin MapReduce we just means
that there's a cottage MapReduce library
which works on top of google app engine
API and in our case it was just a matter
of making sure that it works because we
implement the api's and MapReduce
library just uses the api's so it should
just work right and we did have to
adjust some species changing some of the
things better we managed to make it work
endpoints is a new feature that's coming
out recently we do support okay there's
still some issues like a discussion
between us and the endpoints guys on how
things could work should work must work
and something this SQL is first out of
the box for us because they don't have a
be done of course we don't support the
database as as it is in the back in with
a google app engine on the App spot but
of course SQL was always there for for
jboss or while fly sockets the same
thing and then modules which is the
latest feature we also support different
I'll talk about it in details a bit more
later on but others ap as you can see
how we support them and which ones are
completely supported which ones are
almost there testing or how do I
actually know that came directly works
right that's a good question and at the
beginning what we did was we started off
with of course we're adding our tests
next to the basic what we do is like
next to the cave or blue which is the
API implementation we always added tests
for different ap is different tests
based on our Killian in shrinkwrap
Killian is a like a test g bosses
testing framework which supports
different environments different
containers it's ready for example it's
like an extension to the j unit or
testing g in our case its extension to j
unit and basically when you see the test
the test looks like a normal j unit test
apart from two additional things you
have a something that's called run width
so you j unit allows you to have a
different runner test runner in this
case it's arquillian test runner which
plugs into the test and what it does it
takes the test you have to describe
tests binaries or what the test will
actually do and then it deploys the
binaries of that test into the container
and it runs the test almost like
remotely as a client it Pink's the
container for the tests and tests run in
container you have different ways of how
to do that presumably it's like an
indictment case of Google App Engine of
course everything is a web app you need
to have a sort of like a arquillian
server solid protocol that invokes the
test on the server side and we already
had this and and then the question is
how do Google App Engine kids work
together when we approached Google we're
discussing like we have this and this
and then we had an idea of making sure
that we can show that cave dwarf or of
course their own stuff works properly
and we decided on doing a joint project
and joint effort on the tck technology
compatibility kit and we started like
setting up what we already had with K
gorf like a similar testing environment
just enhancing it a bit more and then
pouring over our tests into this TCK and
we have like we're slowly from google
side they're putting their side of the
tests from cave dwarf society we are
putting forwarding outside of the test
into the tck
so the goal is on what we had before you
can still run that of course we're not
going to delete it but the goal is to
actually run the tck against different
implementations of the google app engine
API it was during google i/o we open the
beginning review is like a closed effort
but at Google i/o the Googlers got a
green light and open opening it up so
the whole stuff is available on Google
cloud platform project and sub project
is like an app engine d ck so what we do
is with inside cable test suite project
which i mentioned we take the existing
tests and run them against k dwarf the
tck itself of course is meant we have a
set up we have a set up in teamcity a
setup which runs these same tests
against different environments different
versions of different environments are
over k gorf beta 5 beta 6 sdk 1.83 1.84
and so on I'll show layer we are around
thousand test API tests and different
tests we also have additional tests like
endpoint tests dinner nucleus tests
MapReduce thats module tests you name it
we try to try to try to test it with a
current setup it's quite easy do I don't
know to add a new test to report the bug
and something like that as we speak
we're adding new API tests we have a
weekly conf calls Cape website and
Google side so we're making a good
effort on trying to test things as much
as possible I'll just show for example
haha yes this is the this is a team city
set up right the thing is we're not we
not even SDK passes all the tests so we
did expose some of the things for us the
exposed other things you expose some
things for them via the expo several
things for us so this is how we run it
we set it up and the end goal is
something like this so this is the SDK
and this is the cave dwarf the thing is
different limitations of different
issues so that's not really the good
thing is that for you you you're exposed
to some of the issues that they're aware
so they're not actually surprised it
doesn't work here and then for like
pre-k blorph for some of the things that
we fail is more of an issue of how as
the care how Google App Engine does that
with we have indexing which is based on
a leucine they have their own indexing
they can do much more different things
more I know sometimes even strange
things which one for us it would we
would be able to support it if you just
do a custom implementation for that or
for example distinct queries for us is
we don't that leucine doesn't have a
something feature of distinct right so
for us you're not able to unless you
actually properly extend that with like
a JBoss seed project actually need to
integrate that to just have a distinct
support right so something like this so
for example distinct tests of course we
not pass them with in-memory distinct
but there are some of the things that
we're not able so this that's why we
fail some of the tests or for example
some of the failures introduced here
actually it introduced a couple of when
I did a new release I found it I
introduced a new bug that produced it
reduced 6 Ferrars that I introduced five
new ones so it's good to have this right
although i don't know how i missed it
because i'm running that this is like
for example this is my setup for the
whole caper different like i said blue
request shared extensions test suite d
ck and all these things and i somehow
missed it i'm still looking how how it
actually how how was I able to miss that
so let's move about this UK its occur I
think it's a good display of what this
what maven can do what j unit can do our
Killian shrink-wrap and all these things
we all know maven we all know j unit are
killing as i mentioned is an abstraction
of environments the test looks like a J
unit test with the additional add run
with our Killian and you have you have
to something called deployment you have
to describe your deployment it goes
against the
container everything else the test
themselves are normal j unit tests so
that's real nice so we were able to
seamlessly switch between the same
writing the same test against kept Wharf
SDK appspot appscale you name it right
shrink-wrap how you describe your
deployments is with jboss shrink wrap
this is another project which does what
it does is for example we used to use to
it have to describe your deployments in
end or maven or like different scripts
it was a pain right when you try to
refactor that IDs are insanely good
right but still when you have tried to
refactor this it was XML texture files
and so on it was hard to refactor in
case of shrink wrap you basically
described all things programmatically
and when you try to refactor you can
refactor you refactor the code and ideas
are ideal to the fact that the code so
shrink-wrap really or let them just I'll
open up an idea at the end just show you
a small piece of how shrink wrap or how
the test actually looks like or no
actually I'll be able to show that on on
in the browser but additional things
that we wanted to do with t ck is have a
you have the API and we want to see how
much of the API we actually cover so we
have a nice way of creating a api test
coverage report so we see that inside
the tests recovered as much as possible
of the API so we know that we didn't
miss any of the any of them main api
methods right adding the adding the test
and it's like a test coverage report
show it in the next slide it's easy to
add new containers you run times with
that's done with arquillian you just
basically have to implement a new
arquillian container and to do that it's
more about two three classes one of
them's I could describing the class and
basically just the main class of when
you implement the container we did this
that for SDK apps what an appt scale and
in the case of wild fly of course we
already have containers for
we didn't have to do anything in that in
that case and of course we're using
github and it's community power to do
pull requests reviews and so on let me
just okay so that show a coverage report
it is so what we wanted to do is create
an HTML like this for example this is of
course and click here on the URL a deuce
it I'm clicking here on the on the URL
fetch API I have this match options and
so on I'll let's parlay let's find a
service okay there was like a services
in the back response your elf at service
in the case for example i'm wondering
what does this here's the one is if you
see like what does the fetch method
actually do so it's like a fetch which
takes HTTP request and then returns HTTP
response it's like a bit of content you
can test tube down so it fits into the
whole screen and I'm one look how do i
actually use this and then i can click
on this and it really does it push it
forwards me directly to github on the on
the same line where this is used in the
test so not you cannot just see what
we're doing it's also work to learn how
it's how it's supposed to be used right
the test itself okay we need to make
special care that we actually impressed
things as they should be done because
people can relate to them through the
through these reports while we are here
like it's like a normal JUnit test test
test test and let me just jump oh this
is what I mentioned like to run this
with our Killian this is what we need
this is the arquillian integration
that's all there is from the from
arquillian apart from let me just jump
into
I need to find not yet
they're somehow grouping the things and
this is the shrink-wrap integration
whenever you need to have a public
static method that returns a shrink wrap
archive in this case it's a web archive
it's a lock right and then you add this
deployment this is how our killer knows
which method is describing your
deployment right it searches the whole
hierarchy of the test classes and it
looks for this for this one I just
basically what we do is like in this
case we create a war we have a part some
of their like based methods that already
do certain things so you don't actually
copy paste things all the time and then
we add classes of course we have to add
the whole hierarchy of the test class
only the top level the actual test class
is added by default of course that's
what but every other car key needs to be
added and of course all the classes that
are used by the use by the by the test
right reading this hierarchy or fetch
option test base and then fed servlet
which use and of course that serve let
users probably a bit more classes so we
add like a whole package of this veg
servlet and of course you what you add
here is it's an index.html file just you
can just simply as you can see we can
just type it's like a string asset and
type it and rename it in the HTML and
that's the that's put into the into the
war into the web archive and this web
archive the shrink-wrap knows how to
represent this web archive as a binary
and containers know how to grab this web
archive these binaries and push them
into the into their own environment for
example in the case of wild fly we have
this management side of the wildfly
which knows how to when you invoke a
management and installed management this
is deploy this deployment in the case of
SDK we somehow had to locally save this
war into a temporary wire VAR directory
because it needs to be exploited and
then point the SDKs run start or
something
method 2 that exploded temporary war
this is like but that's the case of how
the how the container implementation
prepares repairs this web archive a
bunch of helper methods and so on so any
of course we have this just so go back
for the we have every API that we cover
we have this report this report is
generated as part of the maven maven
plugin when you create like a moment
clean install it compiles the test
classes and then it goes in just such as
for it's like a bytecode matching of the
usage of the API so it's there's no
class loading it's just pure bytecode
and it's really fast so creating
reporting and running these reports like
a really really fast as I said you found
a bug you're using our App Engine SDK or
appspot or Cape wharf for that is
basically just the easiest for you to
probably go and look into existing TCK
tests if you find the match already can
already be about it's missing right or
for example you can even look into the
report right so that's that's already
part of the report that's the test
that's failing so i can just probably
watch the space if that was actually
fixed or if you found a new bug it's
really easy just add a new manager unit
test run with the killian new shrink
wrap deployment and do a good helper
request somebody there's like a bunch of
guys like from google siren me and my
coworker on an hour side and watch these
pull requests and of course if it's
properly it's going to get integrated
it's going to be part of the tck run in
the next time ok let's go into a bit of
like details of how we actually make a
keyboard work I start off with the
project I think it was
don't two years back end of 2011 just
starting playing with those I think
first started off I was saying like let
me see if I can make data store API work
which is probably the most complex the
most stuff and if I can make that one
work I can probably make the other
implement a AP ice work as well I was
like slowly incrementally working on it
and of course the whole integration the
shared project constant I don't know
having using different framework
different libraries in case of in
finished a whore hibernate search and so
on of course we found some bugs or we
found some missing features so we had to
instead of complaining or waiting we
went and implemented that features
inside infinite spending hybrid search
but what that meant was that we were
running on snapshot so at the beginning
the development was for external users
was almost like impossible because you
had to know i was talking to Laura back
in the station and putting it out to our
different you need to build this first
and then this and then you need to push
this branch and use these branches like
insane of course like no way I can do
that so at the beginning use but hard
but the thing was we made a really good
progress at the beginning of 2012
january i was already able to present
running caved wharf read the google app
engine stem or like hello OEM example
which is basically it's actually runs JP
aj do it was it is already working so of
course those are like the fine details
and then adding goes adding new API as
you had a new support and so on so it's
well yeah it was a nice incremental but
at one point your header we had this old
libraries in this quite stable mode so
at the moment it's quite easy to build
and contribute to the project because
the versions are stable and easy to
still need to build it right but the
versions are stable sales are not
running any snapshots let's go okay then
data store of course as I mentioned if
it wasn't for you finished pan we
probably wouldn't be as easy
or actually implementing all these
things without in Finnish man I got a
question back in the two months back on
the forums if it's possible to switch
their agreed with something else I think
it in theory it would be possible if
that they're a great supported what in
Finnish plan supports gets all the
querying and all these different things
listeners callbacks and so on at the
moment our integration is tightly
coupled with infinite space we would be
a bit of a work to strip that out and
make an abstraction layers for all these
things but it's possible so to ask you
its first when you think about to ask
you who exactly what JMS that's right
just basically implement these things on
top and JMS that's it n points it's
jax-rs it's like rest easy which is part
of our world file already modules and
runtime how do you integrate all these
different things it's of course is a
subsystem you multiply and I'll go into
more details data store but it does
ample you have a bunch of instances of
data store they all connect to the same
infants Mandela grid inside and finish
panel agreed there's like in Finnish
Bank query which you use for carrying
twins fan query uses hibernate search
hibernate search uses leucine and in the
simple case of course to seeing goes
like a file it puts information to file
system but in the case for example as we
said system that's already designed to
scale right about it but if that note
dies what happens then the good thing is
that basically you seen pushes its index
in something called directory and what
we have here is you have implementation
of the directory on top of infinite span
so we're basically in Finnish spin loses
the solution uses in finish them back as
its where to hold the indexes so all the
indexes are actually clustered in
signing finished pan and so distributed
and so on so their fault tolerant the
thing was that what we also wanted in
in this case what you wanted to do is
minimize the usage of example in this
case it was using a force infinite spin
uses as a transport it uses J groups
which is the clustering the low-level
clustering layer inside wildfly and we
wanted to reuse the resources as much as
possible site so i implemented something
called they the MOOC server was always
already implemented means that for
different apps you can use the same
channel just carrying an app ID with it
with any daily message so that's already
been done so it's quite optima optimized
to be able to hold many different apps
under the same in finish pin grid so ok
let's move to the queue so have you have
different apps talking to the talking
doing the synchronous tasks to the task
queue API and of course in the case you
want there's like an API also supports
transactions if the transaction does an
ongoing transaction if transaction fails
you you don't want to push the task
forward thinking about it that's exactly
what JMS that's right you have an
intersection you push in a message if
the transaction fails the message
shouldn't be delivered and what you do
here is like we push you put the
synchronous task as a message to the JMS
if there's a transaction it behaves
towards actually and the cool also JMS
knows how to balance things right in the
case of for example if there's just one
app instance and it runs in this bunch
of a synchronous tasks in probably nap
scale app spot it's distributed among
different instances in our case if you
have more than one node running it's
going to the gym ask JMS in this case
horrid Q is going to balance those
messages across different nodes and it's
going to do a synchronous invocation of
your app and goes back to the app
instance right that's JMS was like
really adding support on top of arrows
quite easy because we had JMS endpoints
of course I mentioned well fire it comes
with jax-rs what
do is we simply map google app engines
and bites annotations on top of jack
jax-rs it's almost like a one-to-one
match what what you do is like in our
case we have jboss modules class loading
layer which allows for to add a list of
class file transformers so we add a
class file transformer to the class
loader and once the app tries to load
that endpoint class it transforms it and
it adds these annotations on top of it
inside cave dwarf we need to somehow
there's there are pieces where we need
to do some some sort of battle
manipulation due to different different
issues I can go in more details later on
if you if you're interesting in that
it's like a bytecode magic which I love
so i could probably reduce it a bit but
like i said the endpoints it's like a
annotations on top of jax-rs during the
class loading up engine API serializer
and it's still available I think as it
is right now I think we didn't properly
understand each other so our
implementation probably doesn't do what
what this actually expected but what is
actually expected I'm not really sure
that's the proper way to do it like
there was a kind of just had a note
there with rest easy and how we actually
do what we need to do is like we
generate the message body writer on the
fly I cut through the bytecode and we
just create the bytecode and install it
into the class loader but you have to be
careful how to how you handle generics
and because rest easy is already
integrated with CDI CDI somehow swallows
some of the informations we have to be
careful how to do that just like a small
note because I was like looking for a
day why it doesn't work then I found
that CD i swallow CDI integration in
rest is for some new information modules
in the case of modules of course what it
does is you have a it's like a new
feature in App Engine you have something
called in deploying ear which is not a
real java ee ear it's more of a
gathering of different web apps inside
the same deployment
and then it's in the case of appspot it
splits these wars in two different app
spot instances but all talking to the
same the back end the same data stores
in memcache and so on in the case of our
stand alone what you do is what we just
properly map java ee Iran to up engines
modular logic we make sure that all the
things that are basically just in Java
EE but we somehow limit summer java ee
functionality but it replace it with
custom okay perf logic and then you set
up virtual servers for each of the
modules so that's like a standalone in
still have to do somehow manual because
the support for dynamic commercial
service inside well fly is not there yet
better have a discussion with 15 guys
but also what you're actually thinking
about how to do proper how to do like a
proper modules support inside ball fly
as you know or just learn about it like
ball fly jaybo 7 was the first one to
support the main mode which means you
have a domain controller which has many
host host controller in each host
controller can carry a couple of week
insurance several instances thinking
about that's exactly what the modules
could could use to be like a proper
scaling of the modules and that's what
we add a custom domain controller which
somehow recognize this is a google app
engine module application it splits it
down into Wars and deploys as bad as its
described in the module part of the XML
of the opinion configuration it uses
that information to properly push
modules on two different spent observing
instances inside host server instances
right we could share observers but it's
easier for us to just create a new
observer for each of the module or each
instance of the module and by adding
that for example we're assessing how to
test this because now you have something
that's like a modular kissing simple app
and previous support for for testing
inside arquillian
was basically just expecting a single
app now it has it has to expect a app
with multiple modules and the nice thing
like you can I can see I'm always
talking about are killing it like a
swiss knife it has whenever you need it
it has these different features and you
can plug in and hook into it and in this
case it was really really easy just to
add something called like Anna Killian
protocol I already mentioned in protocol
it was the case of servlet protocol what
you do here we just extend this server
protocol with our custom modules solid
protocol which understands different
modules so on the test I can say run
this test against this module and the
protocol itself inside are killin it's
going to know on which URL it needs to
use to be able to test net module for
example inside the app spot it goes like
a module named app ID name appspot and
so on and it knows how to properly
attach that module ID to let your when
it creates the URL in the case of cape
wharf it knows how to invoke a proper
virtual server and so on so it was quite
easy as i kept for I think for classes
to add into arquillian protocol runtime
itself as i mentioned i think jboss
application server from version 2 1 was
always one wasn't a monolithic big moral
it was like a extendable environment and
the way we do that was through jboss the
pliers we had them in our own jboss
toward definitely in jboss 3 4 5 6 and
since we just add a list of the pliers
into your deployment life cycle which
handle different things for example you
get in a sort of an abstraction of your
deployment with different already
different things so in different phase /
let me have a parsing phase you have
described phrase you have class loading
phase you have post class loading phase
and so on different pages you have you
have you add different things for
example in the of course in the scribe
phrase you add different things you
describe how your class loading class
pet should look like so you can add
additional things
the classpath and so on and and what you
do here in Cape Dorf for each for
example in the parse phase of course we
look actually in the structure phase we
look is that deployment a cave or
deployment what what makes you the cave
curve deployment is a up engine- web app
dot XML file right if death XML exists
it's a google app engine app or in the
case of modules happy needs to have up
engine- application XML and so on so
when we recognize that we know it's a
Kevlar app and then each of the nudie
pliers first looks is it the Kevlar fab
oh it's not a Kevlar fab there's nothing
for me to do if it's a Kevlar fab do
this and this and this and this and so
on it's like like I said the extending
is basically 10 plus deployment unit
processors that's how they are called in
the in the world fine there's almost
zero configuration few few services into
the kernel and it's fully modular you
can run your apps as a as a module you
mean I mean it can use the App Engine
jar as a module which it means you don't
have to pack Google App Engine jar
inside your app because we're going to
find it in cave there in wild flies
modules or if you if you the way Google
App Engine apps actually work the inline
API jar into the although it's replaced
by the latest one but still in lined
into your app we support both ways it's
like I'll I think we still have time
right it's like yeah okay I think for
the demo and then basically it's just
that I used to shown a to-do list demo
which was some like a small demo and
we're gonna but I'm replacing it with
simple chat demo this simple chat demo
was basically contributed to us by a
user which wanted to use channel API and
it wasn't working for him and just okay
can you create a an example or a test
for it adding a channel test ap I was a
bit of a pain so we had to do
energy and Ronan drone integration with
phantom Jas and all the different things
so it was a bit more complex than needed
and for him it was much easier to just
create a simple a simple app that showed
the channel API usage I'm just going to
show it quickly on basically deploying
the same war into SDK and then deploying
the same war into local cave or where is
if i run this
this open up a new browser as well Duke
if I switch I got this one right let me
just go back here design take it off and
came from that sign right so okay we
know it works in SDK as it should right
just need to shut down this otherwise
it's going to collide I already deployed
the presumably in the case of the App
Engine always expects the app to be on
the route because it's only app that it
supports in the cave dwarf case we
support multiple apps as well vice
course multiple apps and you can you're
not expected for the for the app of
course to be on the route context to the
easiest way to deploy app to the root
context in the case of alpha is to name
your app root dot war I already disabled
the Welcome app and so on but you just
apply this route or you can push in this
descriptor inside your app it says this
app should go against the root and the
problem is that we don't like Map Reduce
somehow expects things to be on the
route all of the demos inside Google App
Engine expects the app to be under root
and so on with hard-coded there's no
dynamic context look up and so on we
would have you running capnography so i
added a simple script to skip dwarf SH
right somehow extends that and it runs
out like I said I already deployed this
app before if everything went well we
should be able to see how he started the
app and somewhere in here between we put
camanche of useful or useless log it
should display found I found a cave or
google app engine app I can just say
okay nevermind but let's go here yeah we
just fix this channel API in the latest
beta 6
what
hello
hello yeah so I was presenting this at
Google i/o so I had even more for
example i had a user from philippines
he's like quite eager on cable or they
had a bunch of different apps testing it
so i was something called visaya which
is a CMS app or different other apps as
well just trying to run it on top of
keyboard we have a app called calendar
which is a app developed by one of the
redhead people and turns on Google App
Engine nanos he mentioned that to me and
he's like can you share me the war and
I'd applied the same cool in that war
inside cave Dorf and apart from the XMPP
which he uses everything was running
perfectly so it's when people and users
somehow test their apps and they find
some issue they mostly they do either
create a gyro issue posted on the forum
or ping me on IRC or email directly so
we try to do our best to see of course
we try to test as much as possible but
of course there's always room to improve
let's just go here back so cable if you
can find us of course there's like a i
would say it in this disorder but
there's jboss org forums which you can
use just pose the question i'm online
most of the day and I'm not putting kids
to bed but yeah just post in the forum
we're really eager to find new issues
fix them help us all or during the day
during the working hours I'm nine hours
in front of this it's like a plus-9 in
Slovenia and we're on IRC and just ping
me connect to the IRA see on freenode
IRC hash cave dwarf just being me I have
this issue can you look it up or there's
like more information of K Borg which is
going to redirect it to jboss org slash
Cape dwarf you have a bit of information
about these different things or you can
always email me directly not like this
doesn't work for me in and so and so on
that's why we have the forms so it's not
just you
getting something out of it but the
whole community so I prefer using the
forms but if I somehow miss something on
the form a couple of days just email me
directly saying unless you said there's
a you have the forms you are going to
answer it then just push mower or you
have any other information that you need
any other help if it's more private
email if it's public i prefer the forms
or the IRC so that's it from my side if
you have any questions feel free to ask
what I did was just apply the app and
then had two different browsers look at
that so that what it does it creates a
channel to it solo track and we don't
use web sockets because the run we're
actually not the cable of the current
version start running on ball flight yet
we have a branch that turns on bottle
fly but for different reasons we're
actually running against seven point two
point O final AAS which is our yep 611
something like that but if we use a
different strategy to do a channel API
implementation so two different browsers
there's a JavaScript of course in the
browser that connects and uses and goes
against the against the instance right
to do to use multiple I think the
information when you when you hook when
you actually get your page loaded from
the server it puts the information in on
against which node it should go against
right so it knows its I think it's part
of the browser the browser knows which
if it went through
yeah I can do that like cable or fees
part of the quick samples right inside
the open shift so you can just easily
try that I think we still need to update
it it's not running on bed of beta 6 but
the thing is with I don't with open
shift is that it's a bit what you
running locally on what when I create a
release it's much easier when it's in a
more like a production environment has
open shift you're not able to just
switch things all the time and we had a
bit behind and the my coworker that was
doing that was on location as well so he
wasn't able to but once I come back I
probably discuss it with him to to
update that yeah
yeah that that stuff is a bit more
tricky right so locally of course it's
quite easy because the problem with
Hornet cure or problem as I see it is
that it uses two different mechanisms to
look it up right one of the I think it
looks it up through the neti and then
communicates through Nettie as well
through our net is infinitely doesn't
use J groups although I think you can
switch it to j groups but not completely
you still need to somehow at least for
the for the initial notification initial
look up still uses statically static
addresses or wherever to look it up so
it's not that's one of the things that
we were actually sort of missing like
we're missing okay everybody always
misses resources but we do miss them in
the case of openshift integration or so
on the cooling about it is that there's
like a torque box project inside J bus
as well which is like a ruby extension
to the observer and day as the last time
I disgusted and they were able to solve
this problem so we just need to look it
up how they solve that and we're
probably going to do the same the thing
is we're as I said with limited
resources view more focused now on
adding the features adding the API
adding the tck so that people over it
and then getting like it's so like
slowly slowly building the community the
project it was probably publicly at all
it was always public but it was
announced in early December was like
better one I felt comfortable to put a
better one to be able and then we're
slowly adding marijuana beta 2 beta 6
while still in beta declare the answer
is that there are some of the pieces
that some of the components because we
we're not reinventing the wheel we use
what it's there and some of the pieces
are still ero peek at link social which
is what we use for users API
implementation it's still in beta 300
completely changing the API and so on
but the rest of the thing for example at
the beginning of course it was like
snapshot the snapshot that but we're
slowly moving changing the what's not in
at least in CR or final we're
getting it out and replacing it with
what's more sort of at least stable or
what it's going to be supported right
no for example back in the office we
have of course our servers to test these
things running here and then I'm running
like a 16 notes and it does perform like
the thing is that in theory we had we're
not doing anything special about it
we're just using what's already there
using finished painting which uses j
groups and jacobs been around for 10
plus years and finish spends getting
mature and mature i'm just using of
course we did for example at least i
think with kevlar if you're one of the
more advanced at least api wise users of
the infinite spin so we found some of
the issues for example once they
upgraded something or for example
something changed in or increase panel j
groups we didn't know and our tests went
from manner of 500 milliseconds to a
minute and our tests didn't change so
something something is wrong right in a
clustered around when we i do have an
automated cluster tests as well and
those tests were like whoa it's taking
forever and of course we had to go down
deep and actually eventually found that
it was j groups that there was the
problem okay the problem was that it was
it was really a bug but is more of a car
yeah api that created the bug so if you
send somehow set up things didn't set up
things probably allowed you too much so
you confused the whole environment it
was actually expecting together once you
send a message was actually expecting to
get response from every node which was
necessary but of course those notes
didn't respond in was taking like a
default 10 seconds on each and so I was
like combined to a minute yeah so
nothing nothing special just right and
of course the unfinished pen what he
does once it sets up it still of course
when when you shut shut down their
instance it persists the current
information on the disk but it that's
still when you can still configure your
because what we do is like we just use a
like
stand alone xml for example for the
stand alongside ex extended with our own
standalone mine escaped of XML which is
copy paste of the standardized XML plus
some of the configuration that we need
for the whole k prefer environment to
work but if you change that or you can
change in phinney span file store or not
fast or to go where everyone you can go
against database it's still it's
infinite spam and you can configure your
store by default I thinking finish mine
uses file store so once you shut it down
it persists things on the disk when you
run it up and you bring it up it's going
to go and I think by default we actually
not preloading it so but that's the
feature of infinity spend once it knows
the keys writing only loads the keys
when it knows it's kehau this here it is
I'm going to load that value into the
into the in-memory and if it spills over
if too much things remember it spills
over that's again like we're just using
what's already there and because okay
thank</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>