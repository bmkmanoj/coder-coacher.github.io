<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Where Is My Memory? | Coder Coacher - Coaching Coders</title><meta content="Where Is My Memory? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Where Is My Memory?</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fRbbL-J1iik" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay we will talk today about memory
about Java applications memory about
memory leaks and how to find them how to
find the root cause of memory leaks my
name is Nikita I am one of the founders
and master developer of the company
named plumber from Estonia and you can
follow my twitter or cooperate with a
review like I will look I will not talk
today about our product and this
tutorial will not talk about this
product or company at all although one
of the problems that that plumber of
souls is exactly memory leaks but if you
are interested in that and welcome to
our booth and we will be glad to talk to
you about memory leaks about GC pauses
about contented clocks and how plumber
solve these problems for you but to but
today we will not your slumber we will
not reveal use just open source of three
tools that you that you can use in your
everyday job in order to detect find and
solve memory leaks so first of all I
will I will talk a little bit about Java
memory management just to refresh the
basics I will tell a couple of words on
garbage collector and how he does his
job I will explain what what does memory
leak me in an automatic manage memory
management systems such as JVM and how
it can happen at all and I will explain
one very important definition of rio's
reach ability that we can we will use
later on to find why your memory is all
used up so I i will i will briefly talk
about memory usage monitoring how can
you
monitor your j am you're running JM i
will then we will switch to heap dump
and active memory analyzer tool and that
will be the most practical part of
today's tutorial we are i will show to
you how to use the active memory
analyzer tool to find root cause of
memory leak in your application but the
first the most important slide on this
presentation is this please do not
hesitate to ask questions if at any time
during my talk you have any questions
any comment or objection if you think i
am talking total garbage then please
stop me interrupt me ask your question
right away because if you if you will
not ask questions then as this topic in
my opinion is quite simple i will finish
in one hour and you will and you left
nothing to do for until the next session
ok you can feel 15 minutes in our booth
but then then what so ask questions
please because well i will talk about
this topic as far as i know but to me
it's old and simple so you may have a
fresh experience with that so please ask
your questions that Stoke it's for you
not for me ok first of all when you
start to job application well strictly
speaking your you are starting JVM java
virtual machine which in turn will run
your application and while JVM runs it
uses different regions on of memory
native heap and thermal generation well
to today is already Java 8 days so no
terminan generation but metal space but
it's almost all the same the point being
that that is important on that on this
slide
is that JDM uses specific amount of
memory it cannot in general sense
consume all the physical memory or all
the virtual memory that you have on your
computer you can write a program for JVM
which which will cut consume every bit
of memory but for general java
application which uses just normal
object which uses heap memory the amount
of memory that you use that your
application can use is limited from one
point of view is very good because you
because we have that restricted amount
of resources that your application your
process can consume and that good from
the point of view of operation system
and from the developer from the
operations guys point of view then you
can you can use only the limited amount
of resources but from the other point of
view that's bad for you because well you
have constraints and constraints a bad
well we are good developers we know what
we are doing why do put constraints on
me I know better so that's double-edged
fort but all in all automatic memory
management and that constraining the
memory was a good thing for Java from
the day 0 that's my opinion you can the
default amount of memory that your java
or that your java process will consume
when you just run it with java minos
class pass your class joanne that jar
blah blah blah your jar the amount of
memory that JVM process will consume is
really operation system dependent it's
depend it depends upon the amount of
physical memory that your computer has
it really depends even on the which job
do you use java five or six java for
java 8 those amounts are a very jealous
certain specific operation system
specific if you use 32-bit operation
system or 64-bit operation system if you
want to know what what are those default
for your specific JVM for your specific
operation system then you can use this
line java unlocking diagnostic vm
options print slugs final it will print
the huge list of all inner second so
inner flat for for for current for
current execution of JVM and among them
there are two max heap size and mark
sperm sighs all marks meta sighs if i'm
not mistaken i sense a lot like that so
you can grab them and you will see what
our default for your specific JVM
invocation and by the way some smart
books about JM Julian hmm performance
really recommends recommend that that
those defaults they really could be your
default you try to run your application
with just default because in fact one of
the mistakes that over eager Java
developers do they try to over specified
or over tune GC we have seen an hour in
our client installations that Java
startup script contains tens tens tens
options about g cg union care and about
memory size tuning it's a huge list more
often than not when we asked developer
or administrator of that girion machine
what does these option means and why did
you put that the answer was well I don't
know really exactly why but i have
googled and the guy on the stack
overflow recommended put these five
you will be good and we have put those
five options on our current line it
makes things better but not good enough
or we google them once more and another
guy on Stack Overflow recommended those
ten and you put those ten too just in
case and that now it's a little bit
while okay don't do that never do that
every option that you put on your
comment blind when you start jvm you
should understand why did you put that
and what does it do and so try on your
first run or on your first version of
your application dry run just is will
default if later on you will find out
that those defaults are not good enough
then you can tune them it but maybe you
will find that well those defaults are
really over-provisioning because all
nowadays we have those that next type of
micro services so you have small java
applications doing one particular job
don't have those huge weblogic
installations with tens of applications
there that yes you have really tuned
that hard but if you have small
application well focused small
application for rest service for
microserver those may maybe those
defaults are really over-provisioning
for you and so you have to tune them
down but from the start just write
default maybe they are good for you okay
and on that link is a good document in
fact about GC tuning in Java 8 if you
google you will find the similar guide
for java 6 i believe there is no
specific guide for java 7 it means us
java 8 the things has changed
significantly enough to justify the
separate guy that's really good guide by
the way
okay that simple I believe that
everybody knows that so if you have
decided that those default memory sizes
or memory pool sizes are not good enough
for you then you can change them and
again please make baby steps if you find
out if you have found out that those
defaults are not good try to change just
exam X the maximum amount of memory that
your jvm will use not try to squeeze
right here this viral racial the young
generation size the promotion speed no
don't try to put only exam X only the
maximum amount of memory if you find out
that the defaults are not good to know
that they are too small okay increase
the maximum amount bouticks emmett and
try again yes you have person well the
question was is sure i specify the mimo
initial amount of of hip as well I
really do not know I what I mean is that
in my experience the only point in in
specifying the initial amount of Jo of
hip size is when you want to put that
initial equal to maximum because
otherwise why do you care and you want
to put initial memory size initial hip
size equal to maximum only in case when
he presiding really affects your end
users because he presiding when jvm
start with some initial size which is
lesser than maximum size and during the
work it will okay thats initial size is
not good enough for me i need more it
will resize and JM will recite that
chunks not all not four in one step up
to the maximum and that resizing is
stopped the vault event so application
is stopped during the Hebrew reciting is
full GC and recite and that that pools
can affect your end users so that adds
latency to your application if you want
to avoid that put initials initial hip
size equal to maximum memory size yes
other than that why bother yeah that was
recommendation about seven years ago for
ten years ago nowadays if you look at in
official article documentation faq well
we don't see that recommendation because
but that's one of the cases that I would
really want to give you my my favorite
answer don't guess measure if you read
if you put only x MX and you will see a
problem okay put initial size as well if
you don't see a problem the the less
options you have in your startup script
they're better because that will make
your startup script clearly more clear
you will understand better what's going
on inside JVM your administrator will be
glad and well the simpler the better and
well one point here is in Java 8 or 7 go
java 7 06 we had those permanent JJ
generation which holds class mail and
metadata and by default that value is
too small and so the majority of Java
applications about the majority of JVM
running all day in the production's had
to change that max government in general
generation size and increase it in Java
8 we have metal space which is
essentially means the whole native
member of the Opera
system that's unlimited well more or
less unlimited and so in Java 8 if you
want to tune meta space you want to
decrease it because if that somehow
interfere with other processes running
on this physical computer so in pre Java
8 you wanted to increase permanent
generation Joe it you maybe want to
decrease matter space but again really
so okay java or gvm let a more more more
strictly GM has automatic memory
management and that was one of the
biggest selling point of Java the
language 20 years ago and that was
invented not automatic memory management
but language because automatic memory
management was in small talk alone
before Joe so in Java Java developers
almost never think about memory
management we create our objects with
well new my object new my business
object new integer or whatever and
that's it before we forget about that so
Java developers don't think about memory
about 3 memory about destroying it
objects because well for that we have
garbage collector garbage collector is a
subsystem of JVM again that's not
specific or that's not some invention by
Java language that was before but
nevertheless that's one of the main or
one of the most important subsystems of
the JVM and the sole goal of garbage
collector is to reclaim unused memory
and in jello world unused memory really
means unused objects you very really
have used memory in java application
without that memory being occupied by
some objects ok you can you
bye boo-boo source etc but nevertheless
you have the one-to-one correspondence
between objects and and memory unless
you use unsafe but that's unsafe so we
will not talk today about different
algorithm garbage collectors because
well tuning garbage collectors and
specify and choosing the correct
algorithm is very vast topic and in fact
that in my opinion a little bit black
magic because you can do that you even
can master that to some extent by from
one point in your career if you go that
path that's well dark path well really
if you if you read some specified made
in pleased about garbage collector
tuning that's well that's black magic
was going on in there that seats power
that's not Jedi sorry if somebody here
participation at least sorry but that's
my personal opinion okay so garbage
collector garbage first thing that you
have to know about garbage collectors is
that they are not magicians they cannot
read your mind they always operate by
very specific algorithms and the
nutshell of those algorithms is one very
simple notion in Java Kristin J in J M
we will think every object to be garbage
if there is no incoming reference to
that object it's not reference counting
like if javascript for example or in
earlier languages but nevertheless if
you have not if you have at least one
reference that points to you and we will
talk about that a little bit later then
GC think that you are good citizen
you're good objects I
can not kill you so and in order to
understand memory leaks and in order to
understand how to solve them relief we
have to understand what does it mean GC
roots that because that's the
cornerstone or one of the cornerstone of
garbage collector algorithms so GC roots
in the nutshell is it's very simple
concept it sounds specials special
objects the garbage collector think
always to be alive these of the objects
are immortal they have to be alive yes
we will talk about what they are but
often those GC root of those special
objects are objects on the heap so I in
the injury I have forgotten to mention
that if you create new objects the those
my objects are more or less allocated on
the heap on the heat and so if you have
those other hip object reference from
outside of the heat for example from je
vais me inside of from jai jai Ram
internals from JVM internal structures
those objects are always alive garbage
collector cannot touch them and for
example these objects are system classes
those classes that were loaded by
bootstrap class loader so it's
essentially GDK classes or jia jie j.r
o'clock West Java Runtime environment
Clark classes Jane I reference jela
native interface references when you
have objects on the heap java object
reference reference from native heap
from native code for example if you
write native agent for your application
or if those objects are being referenced
by JVM internal structures all running
thread
threads that are right now are running
and are executing some code they are
considered to be alive garbage collector
will never kill a running threat in your
application that sometimes if Google
sometimes it's bad if you've forgotten
to kill that thread well JC will know it
will never do that for you local
variables or parameter so if local
variables of the methods that are
executing right now during method
execution when those local variables or
income input parameters of the running
method when they recite on the stack not
not not on the heap right on the stack
they are considered to be alive again
they have no incoming reference because
they were in stack their local they are
themselves may be referenced some hip
object but they are always alive they
are considered to be GC root a native
stack as well if you have some native
code running call those objects I are I
life at GC root if you have some monitor
for logs right now under you so if you
if you have some threads that lettuce
yes you have question
when you the question was if you exit a
method what happens with local variables
so essentially yes java Joey Joey
execution model is a stack machine so
when your method is executed or local
variables and input parameters recite on
the stack and you have almost like a
like and see you have take poor pointer
and you when you exit the method those
tech is well popped and they are
destroyed this reference style
references are destroyed yeah
the question was about the question was
mainly about measuring performance of
something and that is another another
black magic and I have a very good
answer in fact if you want to measure
some small pieces of code like object
creation for example so you have you
want to create micro benchmarks or nano
benchmarks never never ever for all the
present from the Santa Claus do not do
that yourself do not write a measuring
benchmark yourself right specified tools
and their 24 micro benchmarks on for
nano benchmarks is java meeker benchmark
harness JM h if you ever want to write a
micro benchmark never write that
yourself you specified tools please
because right writing correct benchmark
micro benchmark where you try to measure
some something in microseconds or even
milliseconds it's complicated jvm is
very smart beast it will try to optimize
your code as much as it can and so in
more often than not that's what you are
trying to measure will be optimized away
by GM and you and you will measure
nothing really so and that's the answer
to every night I don't hear
that's one of the reason you have Jeet
warm up you have JVM warm up you have GC
warm up and but Jeet java java in line
jit yeah it's very smart it will detect
that your code that you're running
inside is really doing nothing to the
outside world and it will just eliminate
that so that's off topic for today but
never write your benchmark yourself you
spill specialized tools please Jay Jay
mhm ok yeah well why okay yeah used
monitor so if you have running thread
and that threads is running cause I am
inside some synchronized block those of
that objects on which see it
synchronizes in his GC route as well so
GG route these objects are considered to
be alive whenever garbage collector
start his job to reclaim Emma memory
first think that it's doing it marked
g0t okay these objects are alive they
are GT route next next it try it it
follows references from those GC route
and in jail am or in Java you have
different types of references the first
one is the most common if you have an
object inside that object you have a
field so we had a reference from that
object to its field that simple we have
references from an array to its elements
you have a reference from object to its
class because well as you know the
glasses engine running JVM are itself
themselves are represented by objects of
type java.lang.string class representing
the type of that object and that
reference is very important we will see
that
later on why and the next every class
has a reference to the glass loader that
has lauded that class and that is very
important important as well we will see
later on why okay classes have had a
references to their values of the static
fields class has a reference to super
class and other than that you have a
bunch of other types of references in
JVMs in GM it's about 15 roughly
speaking Pijin I don't remember exactly
but these are the most common and think
about them so you have GC route now we
have references among object so what did
she do what JC does GC marks GC roots as
reachable then every object that is
somehow referenced by those GC roots are
in that turn marked as reachable then
every object that is reachable by
reference from reachable object is
marked reachable and so on so forth
until the whole memory of the running GM
is is walked so so GC marks the
reachable objects on the heap and
everything that is not marked everything
that is not reachable is thrown away
that is considered to be a garbage so
that's a nutshell an algorithm of
garbage collector in jail what reachable
from GC roots that's good what's not
reachable that garbage
and I wanted to say something here oh
yeah so from here we have one one side
effect and that side effect is that the
time for the garbage collector well in
general case the time the garbage
collector will take to do his job is in
proportion or depends upon the number of
life objects or the number of reachable
objects in your hip not the size of your
ship but the number of reachable objects
in your hip which means that a short
lift objects that you create for inside
method or inside loop they are
essentially from the garbage collector
point of view are free of charge they
were very cheap because if you have new
objects created inside method and that
objects never escapes that method it
only lives inside method for example or
inside loop then chances are then when
garbage collector will kick in and will
and will start his job this method is
already finished exited and there is no
reference to do to that to that local
variable or local objects and so he's
collecting it's free of charge so that
and that the reason of in jail and one
in JVM science part they have a weak
weak hypothesis theory which claims that
the majority of objects in JVM dies
young so that's why he works this way
because he makes the assumption that
when we when we do that the reachable
objects will be inside the small part of
the whole heap yes we have
the method has not called to a method on
another object outside which
yeah yes if you pass if that if that
local object somehow escapes these with
these methods if you use that as an
input parameter to some another method
if you if you buy that some thread if
you publish that to static variable
cetera yes then you don't know what will
happen not per se because it doesn't
need to it was counted whole heap and
what what it cannot reach that level
that cheap to to throw away but JVM does
do escape analysis a for synchronization
optimization not for GC optimization but
for synchronization and locked imitation
no no that that's completely another
part of the game are all garbage
collector are generational ones on
Oregon hot for GM so if if we do Young
Jeezy or minor G C only mark the young
generation but it has to take them to
count reference from old from old to
young that true yes have question
a kind of rabid base
yes
no no I when I taught when I told when I
talked about latency I taught that when
you when your hip is being resized that
will stop the the your application but
essentially the duration of that pause
is more or less dependent upon your life
objects reachable objects because
because it has to resize yet but is for
what that's complicated what I mean is
that in order to resize your hip you
have to clean it and you can and you
have to ask operation system give me
more memory okay okay
no because reclamation of unreachable
objects is virtually free the garbage
collector has a different phases in his
job mark is one of them then throwing
away is almost three of charge but
sometimes have to you have to compact
you your hip too and that again stop the
vault event so that's complicated really
if you're interesting that come to me
after the talk we'll talk about that
because that's not a direct connect to
memory leaks okay so reach ability the
rich ability is important why because
what is memory leak in JM memory leak in
jail am by my definition and I think
that correct definition if somebody will
tell you some other definition he's
wrong unless that gem Gotham then maybe
I'm wrong maybe well yes so many league
memory leak in GM a is a reachable
reachable objects that can be reachable
by the previous definition but those
objects will never be used by your
application so memory leak is in fact
it's the state of your application it's
your application specific situation
because only your application will or
will not use those objects there is no
such thing like generic memory leak it's
always application specific and depends
upon your application business logic
because it totally possible that you
create a bunch of objects you forget
them for a month and then you will use
them so that's not a manually because if
it looks like a memory leak but that's
not
that's why memory leak detection is in
fact very hard thing hard if you try to
minimize false positives but from the
practical point of view just reachable
but unused objects is not a big deal if
you created a couple of megabytes of
unused objects well so what so from
practical point of view I I prefer to
call memory leak a situation when you
create those objects more and more again
in the game you create objects you use
them for some time when you forget them
is where they are still reachable in
your jvm but you and your application
will not use them anymore and that
ribbon that cleans and rinse and repeat
rinse and repeat again and again again
on the game that's a memory leak so now
it's very it should be very simple and
clear how to false mayor and memory leak
you just find those objects which are
reachable you say AHA to thorgy column I
will not use anymore that's memory
simple thank you okay examples of memory
leaks first the the most common or well
maybe maybe not the most common but
somehow the most well love and hate
relationship for us for for the company
of plumber our caches because well what
does cash cash is something that you put
new object into and if you have msconfig
you're at your cash and it has no good
addiction policy here or if you if that
addiction policy is broken or you you or
if not right only cash you put things
into the cash but you forget to look
them up that's memory leak because you
put new objects into
ash that grows indefinitely because
remember you don't have an addiction
policy and you don't use that cash you
have a leak yes and I will talk about
one small detail a little bit later
against drinks up drink that was a
famous memory League up to Java 7
because if you use Java 6 my second plea
for you please forget that upgrade do
not use Java 6 and for God's sake do not
use Java 5 it's dead already that's
necrophilia do not do not use it upgrade
Java 7 at least because well jealousy's
broken jaws sound a little bit better we
lots of better sorry lot of better if
Oracle employees I Here I am again sorry
but well Joe six is nowadays it is
already bad and so yeah drink up drink
was a source of memory leaks prior to
Java 7 so upgrade to Joseon at lease or
joy that will be better again if you
have threads that's a running and if you
if you ever have written runnable or
thread with wild true cycle well that's
an immortal threat if you forget to kill
that or if you're if you have a threat
running until some event happen and that
event will never happen we have a memory
leak I input output streams the same
situation so please clean them and try
and use try with resources if you java
judge 07 08 and if you use some or use
lambdas OU's groovy clutters Fidel and
well storages which live longer than the
values inside them or that the values
inside them should leave well cases is
one example but the other favorite
example of mine is thread locals thread
locals
is very good instrument in Java but
thread locals are essentially is a
custom scope for your values for your
variables but in typical web application
type called G java ee application thread
that that will handle your requests they
come from the application server so if
you put something to threadlocal while
while being run by thread from the
application server and you forget to
clean that threadlocal for essentially
you create it a memory leak because that
value will leave infrared local in that
thread much longer than your application
in fact needed needs it so threadlocal
are good but you then will care so
that's yet another example of storage
where storage itself and stored value
have different lifespans have to be very
very very careful of that situation ok
so you have a memory leak how do you
know that how do you know if your
application has a memory leak more often
than not you'll know that because your
application crash was out of memory I
believe that's a nineteen percent of all
discoveries oh why all we have Outremer
error ok we have a memory but another
symptom of memory leak could be that
your application is extremely slow
because you're because your application
runs it could creates object it leaks
memory it leaks objects so garbage
collector kicks in it tries to reclaim
some memory have well a bunch of objects
that it cannot reclaim you cannot throw
them away so you have small free memory
a few little free free free memory GC
will kicks in again
try to reclaim anything it will fail
because well nothing to reclaim your
kicks in again in the game and again and
again so essentially you lose you will
reach the situation where were the
majority of you all the time cpu is is
running garbage collector and not your
application and that's very dreadful
situation because well your jvm is
running with all good you're you're
monitoring systems tell that ok green we
are up and running everything is ok but
your end-users essentially cannot use
your application because it's damn flow
some garbage collector algorithms has
has a defensive mechanism in place but
that means defensive mechanism is if
garbage collector works for ninety-eight
percent of the time so if well if
ninety-eight percent of the CPU time is
devoted to garbage collector but garbage
collector has reclaimed less than two
percent of your maximum memory then okay
then we will throw out of memory era
jeje limit exceeded and we will die but
imagine so it it will die without a
memory error only when your application
is 50 times flow or that it was when it
was good and healthy for me that's too
late I would prefer if you die much
earlier so you can recover from that
serious situation fail fast yes we have
questions
programmatically well yes you can you
can but a twifty you can try what I mean
that you can monitor standard gmx beams
which report GC metrics and so you can
deduce if GC time or GC overhead is over
the limit but the problem is that well
your application only runs when GC
doesn't run so they they may conflict
with each other but yes you can but with
me yes yes so well you can't use that
bad well if I'm not mistaken you can
tune that see situation and tell GC to
fail earlier but in all my experience I
have never seen an installation Algeria
which tuned that for some reason because
well but for in my opinion that one of
the one of the useful fact because I
haven't used to but well if to choose
from hundreds of JM flag that may be one
of the use of words
outside you cannot i would i will talk
about that a little bit later yeah
I have left flied about profilers and
then I will answer your question yes we
r fettle
no that's unsafe that means and save
that garbage collector will not touch
that if you use unsafe to allocate some
memory of the heap into native memory GG
will not see that and will do nothing
with that okay but those symptoms out of
memory errors and crash and excessive GC
doesn't get me that you have a memory
leak it is possible that you have just
too high allocation rate you create too
many objects too fast and GC cannot cope
with that that is possible and for
example if you have cash which is
configured to use to use much more
memory that you have well you will die
without of memory but well technically
that maybe not a memory leak because
well that was your decision to put so
much objects into the memory and you you
are really intended to use them but well
so it's too late we have already crashed
if you try to load too much data at once
the memory to process them all for
example you load some data from the
outside on throw from external system
and you try to process those big data
amounts of data at once in memory well
we have creel crash without the memory
but that's not a memory leak that's you
to that you be into greedy there's
different things and one of them I one
of my favorites a of sad data structures
well you just if you just choose
inefficient data structure to hold your
data does not a memory leak per se but
well you can you can end this out of and
rarer as well okay so how do you know
that you have a memory critical
condition before you crash without of
memory so memory monitoring I have
talked about that yesterday
you're interesting you can see the
recording I believe sometimes in the
future but essentially first of all we
have these are there or jello Mission
Control that's graphical tools that you
that you can use to mode to monitor
memory consumption you're running GM if
you have a graphical environment in a
machine you can use J start that's GD k
built in to to which you can use for
memory monitoring but today we'll talk a
little bit about GC locks so these
options or at least the first three
options I believe that they should be
put in any production JV there is no
excuses because GC logs are invaluable
tool for some performance optimization
if sometimes in the future you will have
to do some performance troubleshooting
or performance optimization you will be
grateful to the past cells that you have
put those options into your running JM
that you have run JVM with these options
turn on what what do they do they right
way the right text file with all GC
events which air and all memory pool
usage and you can use that so if you are
very experienced or you like you like to
inflict pain upon yourself you can read
them just by hand or by a buy right but
I recommend that you use specified
specific tools so GC logs analyzer if
you google that you will find a bunch of
them I personally preserve the second
one GC viewer it's a very nice too I
have found that the
today you can find some commercial
alternative as well these are free and
open source and in my experience these
are totally adequate and enough for
everyday usage so what do we use GC log
for essentially as we draw right now
talk about memory leaks you use GC logs
to see that you're used memory in your
running JVM constantly clients that's it
very very simple because well you can
get that information from jay start for
example or from usual there but you have
your GC logs already haven't you because
you have put those options before you
start to jail so we have a GC logs part
them with GC viewer and you will see
that your used heap is constantly
climbing up and up okay you see now that
you have a memory situation which
probably means a memory leak maybe not
maybe yes so okay we see that we have a
memory situation so we have a memory
critical situation we have rising memory
consumption what can we do well you can
increase your memory include six makes
well that sometime is it is good it sent
especially if you have one of this
situation so maybe the cheapest solution
if you have for example it tried to law
too much data and you know okay I tried
to load two gigabytes of data in my JVM
and right now I'm running in one
gigabyte but I can tune that for four
gigabyte well that the cheapest way to
solve your problem forget about about
more complicated one so if you can then
first thing that you do well try to
include six
one time one time as a first step try
that maybe that will be enough and so
that the cheapest way if after that
we'll have yet another problem because
well ma'am you cannot still feature your
data into memorable okay now you have to
dig deep now you have to go deeper oh if
you know that okay I real i know that i
have used some memory in efficient data
strength structure or algorithm okay let
me try and think that if that is cheap
if you can do that fast enough then try
that oh maybe you can tune your GC but
well thats dark magic and we don't go
that way yes k fashion yeah enjoy it
doesn't have German Jewish anymore so
yeah you don't increase term Jen you
have metal space
no GC locks are free of charge GED slots
are free so that's why every production
jadi means and should have them turn off
or turn on sorry sorry so first 300 all
of them should be used in every
production environment because they're
free yes on average each event so if if
if if some GC event happens and
depending on GC algorithm they are
different ones it will write them into
log so that's up to date always up to
date ok now they meet up to all of
today's pearl we r memory dumps so in my
in my experience memory dumps or memory
or heap dump because we are talking
about JVM heap dump dump right now not
arbitrary may and memory dumps is the
best way okay sorry one of one of two
best ways to solve memory leaks problem
heap dump and the second one is that
that I have mentioned in the beginning
of my talk and I will not repeat because
that's not product placement I am NOT
idea
yes okay so apart from that product that
we will not mention today any more
memory dumps or hip dams are the best
way to solve memory leaks from my
experience and I will talk a little bit
about other tools at the end and what is
a heap dump heap dump in a way its
binary representation of the whole heap
written to a file to disk but that is
not an accurate representation of the
memory it is not for example object
sizes and memory layout how objects are
laid out in the memory is not preserved
in hip hop what is a heap dump useful
for are essentially objects and
references that's all so you have object
values and references between objects
don't try to read anything other than
that flow from hip down size of objects
it's approximation it's not exact sizes
they approximation more or less good
ones but approximation memory layout
lost at all some inner information or
for example in running JVM you have
objects we have objects heaters which
contains log information which contains
object age lost so that's not an
accurate representation but it's good
enough for memory leak detection and
solving yes that's okay that's the graph
if is stored okay it's correct so graph
is correct some metadata about objects
that's lost but graph objects references
yes
no i am not aware of any tools that can
well that depends sorry in fact that
depends what i mean is that for example
the reef tools that you can use to
analyze object layout in the memory and
how its laid out in the memory and
correct object sizes that you can do
that java object way out one of the
openjdk tool can use that for that
particular task object lay out how they
have filter way out in the memory laid
out and how much memory it consumes but
other than that general purpose correct
heap analyzer no and so there are two
ways how to get memory dump or hip down
from your java one you can get a heap
dump from your running complication if
your jvm is still running and not
crashed then you can use a map tool
which is part of jdk installation to
dump that into file please note that
when this tool is involved while heap
dump sorry is being made that is again
stop the vault event which means that
during heap dump creation your
application is stopped and unresponsive
and clients will notice that and that is
flow because for two purposes for two
reasons one is that what that's writing
data to your hard disk so it may be slow
another one j mob has to walk whole heap
but it does that in single thread no
butter live here just single thread keep
walking and riding back to hardest
that the same if you if you use visual
vm or java Mission Control and you
request make me and heap dump that
essentially the same that the same API
that the same inner workings yes he heap
dump he's been created there where j van
runt oh boy oh boy oh boy yes okay
else it will stop the running JVM that
jebem will take hip dump from and
another way to get a heap dump is to put
these two options in your again startup
script on your jvm options list and then
if your jvm will throw out of memory
error then Heep dump will be created
automatically for you and that is
another couple of options that I believe
should be added to any production
environment because if out of memory
error happens that the perfect time to
make a heap dump and you want that heap
dump in order to troubleshoot and fix
why that out of memory error happens so
these two options the chip dumped on out
of memory error and heap dump path that
the second one is optional because if
you use just keep dumping out of memory
then it will create a hip down in
working directory of that JVM and its
name will be Java Pete the process ID
dot H prop so the second one is optional
first one is good to go
yes so if you are if out opener error is
a throne then a heap dump will be
created for me ah yes yes it will create
will create memory dump on every out of
on every out of memory error including
negative threads swap space limit cetera
on because well yes out of memory errors
can can have very different reasons and
causes that will create hip dump on
every one of them yes that the whole
heap dump into hip into file just hip no
known age of that a non-native allocated
here that heap done that I thought why i
have said that's not the same memory
dump done specifically heap dump only
heap memory no native memory it does
contain some information about threads
yes because well we have threads we have
sticks you have locals but other than
that no native memory okay now the
question is you have looked into your GC
logs and you have concluded that i have
some memory critical situation i have to
solve it now for okay I have to make a
heap dump went to do hip down my
recommendation is that you have to to
create or to get memory down as late as
possible because if you well if you just
run if you just start to JVM and you
create a hip down well it will be empty
no problems where the problem is memory
leaks is that sometimes you know from
your previous crashes that's okay this
application has a memory leak and okay
we have
or the previous try our application
crashed in four days without of memory
error ok let us restart it again and at
the end of the first day let us create
out of me sorry let us create heap dump
that's too early because maybe in this
point of time that memory leak is to
choose too small the problem with memory
leak detection of the solving that you
have to find out who is that culprit in
your jvm and you have and you have to
distinguish it from other good citizens
in your hip and for that your job will
be much more easier if that league has
grown and grown and you can easily spot
it so try to make that a heap dump as
late as possible that's why I think that
that heap dump on a hip dump on out of
memory error is the best time it and the
best way to get hip done if you can
allow yourselves to crash yes we have
questioned
yeah you can just go to stack overflow
and they have another yes you can I well
I cannot give you the exact code an
action rod right now but yes you can yes
you can just try to throw out the family
exception yourself well that's yet
another exception thrown you out of
memory exception I want to get a hip
down yes yet another variant you just
spawn another process and you run jayma
comment well we have plenty of
possibilities but in my opinion that let
let it crush egg or at least wait as
late as possible and do that heap done
by boy hat the simplest way well well in
my opinion if you have to program heap
dump creation into your application you
have you have gone with the wrong way
okay now you have that file and well
that file is huge I mean it's roughly
speaking the same size as your hip
roughly speaking the rub the butt but
roughly speaking the same size so it's
four gigabytes or ad gigabyte or forty
six gigabytes 46 where do I get that
number from 64 dear gigabyte so what to
do with it ok so you first of all get
that from your server to your son
computer which has bunch of memory it
will make your life easier if that
computer has at least that much memory
as that heap dump all or more it's not
strictly
s3 but that that will make your life
easier yes add more memory to that
computer and then go and download memory
a cliff memory analyzer to that's open
source project that open source it's
it's available I either a standalone
application or as a plug-in to eclipse
and well I am IntelliJ user but
nevertheless that's one of the things
that Eclipse he'll have done right and
now you get that it and here let me
switch to memory analyzer here it is so
if you if you open that hip down file
with with active memory analyzer it
first of all it will try to parse that
file to create and watch of index and
for that it needs a lot of memory and
that the most time-consuming process
here well apart from is CP that huge
memory dump to your machine then you
have to part that and it will present
you with picture like that like that or
like that or like that so that
representation of that heap dump so
that's your memory that your GMA in my
memory and now we have to speak let me
click here and here you can see that we
have a list of all classes in JM JM the
number of objects in that he heaped up
and we have shallow and retained sites
and here I will
switch back here and we have to talk
about shadow files and deep 5 shallow 5
if the size of the object itself without
its field so it's only these objects and
I will have a picture somehow here and
now so we have three different types of
sizes in fact we have shallow size
that's the site of one individual object
you have deep sighs deep sighs in the
cumulative size of whole sub graph which
are originated from that object so we
have object objects has fields fields
have those objects have yet another
field for a raise or references so if
you take the whole sub graph from that
one object that will be deep sighs and
yet another is retained sighs and retain
size by definition is retain size of an
object either size of a sub graph which
is dominated by that object and that's
not bad domination that's good
domination and what does it mean is that
the size of the sub graph which will be
reclaimable by garbage collector if that
object is thrown away or if you take
object throw that object away and now we
take the sub graph which has became
unreachable after that and we'll take
the size of that sub graph that will be
retain sighs and here is an example if
you have if you have this simple graph
from four objects then retain size of
object oh one is the whole graph because
because if you assume that oh one is our
GC root or 10
so if you throw away or one and you have
no more incoming references now garbage
collector can throw away or two or three
or four so the whole graph is dominated
by 01 yes so retain size of o2 is only
02 itself because if you throw away Oh
to object we still have 0 3 and 0 for
reachable through all one of them
understand so retain size is the size
which is kept in memory by that object
and why that's important is because is
essentially if you if you try to find a
memory leak in your application one of
the things that you are that you are
looking for is objects with the biggest
retain size because if you can throw if
you can find out why those objects are
being held in memory and break that
reference and so garbage collector will
will be able to reclaim that object it
then we'll be able to reclaim the whole
retain sub graph and you will get the
biggest win of that all of that fix so
so you have you want to find the object
through the biggest retain size and on
here on the first tab on the first cream
that memory analyzer will show you is
exactly this this object groped by that
the object is biggest retain size so we
see here that the majority of the hip is
being dominated or help in the memory
and prevented from being garbage
collected by the object which class is
of which object is here if I have this
one
so we have some object of the class
leaking interceptor that the name may be
beyond on the hot tray that leaking
interceptor one object though dominates
or prevents garbage collector from
reclaim the majority of our heap and
what we do now again we remember that
token on reachability and remember when
I told you that now it's simple in order
to solve memory leak all that you need
is to find why why object is being held
in memory and break some reference
making make it unreachable you want to
find out why these objects are reachable
and break that chain of reference that's
all that letís to fold in memory leaks
you find clicking objects in this
particular case we have a suspect that
that's leaking interceptor class because
it's dominate the majority of the hip
and now you want to find out why these
objects is why this object is reachable
and make it unreachable that's all okay
so what we do we click here and we we
have two menus here post GC routes and
merge shortest path to g0 well in the
handbook if you read some tutorial on
memory analyzer tool they recommend you
choose merge shortest path to GC routes
exclude all baba I will not talk today
about what are weak weak soft and
phantom references that's not so much
important right now maybe maybe if you
have time I'll talk about that at the
end but choose just will exclude all
phantom weeks or preferences and it will
show to you
a chain of reference is from GC the
shortest chain from some GC route to
that object so here we see that we have
some thread running and from the name of
that thread at some some JT request
power handling threat but that's not
important to have some thread here you
have some local variable so we have some
local variable on thread and you see
here some leaking interceptor class or
some object of type licking interceptor
and class licking interceptor so we know
that all those objects or specifically
the majority of the heap is held in them
in memory because of that object so now
we go to our source code Oh open that
leaking leaking interceptor class and we
see okay why do health so much memory
and what we can do more we show released
objects with outgoing references now we
see that that liquid interceptor object
references some field of his name plus
used images which is some synchronized
list and if you just follow the retain
hip path we always choose the biggest
retain hip reference from objects for
their own we see that we have some
another linked list and well link leaves
a chain of reference so we have we have
lost that big retain site but we know
that you know now that we have leaking
interceptor objects which helps some
list which consumes the majority of our
hip so we know our culprit now you know
who's who's responsible for that memory
leak now all that we have that we should
do it go
can go into the sort and check why we
put so many objects in that lift and why
we do not do not remove them that's
simple let me repeat you click here here
here and you click here that's all
memory fault in a nutshell really that
simple wait I'm a little bit
overconfident but nevertheless what I
prefer to do by the way so i would like
to show you now a couple of well more
electrics or tools which I use when I am
when I'm in the mud for example first of
all I prefer to choose or to try to see
all profits to Jeju root not only the
one shortest one because sometimes they
are different and sometimes I and in
order to solve that memory leak I in
fact have to break all references from
what all change from GC route to my
object so in in so here I see that that
leaking interceptor is referenced by two
different objects leaking interceptor
and some object object array and that
well i have class which is referenced by
object of that class and is referenced
by class loader every class loader has a
references to all objects of that class
but as as we see from here the real
problem is in some lists and as we as we
see here that class and not an object
references at least we'll have a static
shielding leaking interceptor class so
we have to just solve that problem that
at least least should be
shrink in size so let me see what I
would slides I have yes so that was one
another one is it's not always this
obvious where we're sure you look for
example in this heap dump that another
heap dump from another application we
cannot see any one biggest although
hanging fruit because as we can see the
the biggest dominator all the biggest
object or the biggest world subgraphs
routine is only for eighty eight
megabytes from our total two gigabyte
heap so if it solves this league well if
it's like at all that will not give us
any major improvement so what should we
do first thing that we can try and ask
mud give me League suspects sometimes it
helps sometimes not here we see okay we
have one one point four gigabytes of
something has problem suspect some ssl
socket implementation which occupy
sixty-two percent of our here okay
sounds fishy we can do we can do
something with that but if we click
details well details are liking so what
what we do next the next most useful
tool in mud is histogram again that the
list of all classes with a number of
objects with shallow sizes and retain
sizes of that classes that at least
approximation of those so now if we try
to solve if you try to to sort those by
retain size because as you remember I
have told that we should always look for
the biggest retain size on every step in
our journey through the mud
we see that we have two candidates we
have a game son security as a self
socket implementation and we have byte
array and if you ever will go hunting
for memory leak please let byte array or
char arrays be the last thing that you
check because in majority of heap dump
byte arrays child char array from maybe
even streams are always on the top that
all almost always okay unless you have
checked everything else and then well if
all the improbable situation are
eliminated that the last one however
impossible it seems to be if the correct
one because we have a lot of by terrain
and every drawing the job application
strings or your strings Achara race okay
I don't know because well by to raise
our ass girlfriend or that that question
for him not for me really but yes chef s
if you have byte arrays contained in
some object then chances are very high
that the retain size of those objects
will be high as well because if you have
either half a graph of objects and these
route change size is big that means that
these retains size should be bigger or
at least the yeah so it's a social
circuit implementation so first of all
we can check why they are so big so the
we can go and see this up without going
great friends so now we have all objects
of that class and we have we see what
what they refer to and in this
particular case we see that every
specific ssl circuit implementation is
well it's quite small not a 87 kilobytes
so it's quite small so we don't hunt for
one particular object for one objects
who who is responsible for our memory d
but the problem is that as we see here i
hope the row the real rose to see that
as well that we have 17 or almost
eighteen hundreds of those objects so
here we have we have no we have the
problem with too much of those objects
not one object being somebody somehow to
be but a lot of medium sized objects
okay why do we have so much or ssl
circuit implementation in in memory
right now again now we go to histogram
we click and we go to so we can now
either ask former shortest path to GC
route and well seems that matt has
problems with far we find in those
not okay running background because
that's that that I will go and another
way and ask give me all objects of that
class with incoming reference so who
reference is us and then I just take one
I bi thik one and see ok ok that's not
good because we have it seems that we
have some very complicated incoming
crater and graphs as well ok that's
again at the end it can happen because
if you are lucky you have a very simple
incoming chain or a couple of chains and
so you can see ok that's my problem now
what what we'll do then we ask again
mercial for shortest paths but we ask
with all references and now we see a
bunch of them whoa whoa whoa that's bad
I don't see anything google google good
in here ok that's the previous one have
some
okay we have five entries held by a
thread okay fire fizzle it is not good
enough so that's not interesting but can
we find anything here and here okay let
lettuce bun bo number of objects we have
here here here I now follow these called
column and trying to find where the
majority of objects are being held and I
and now I see the very familiar problem
Joe Allen Craig finalizer and that the
case that's that in fact example of the
heap dump which is complicated because
as I have a heap dumps are very good to
find if memory leaks in the majority of
cases but sometimes you have to have
enough experience to enter to understand
what they are telling you and in this
particular case I see that very much of
that sake of implementation that we
suspect to be leaking I've been held by
some Java rank rev finalizar and it's
good for me because I know what jalan
rare finalizer is and how and how they
work and now I just understand that in
my application I create those sockets
too fast and garbage collector cannot
clean them up that's not memory relief
that too fast allocation rate for sake
of implementation but why I know that
that in fact the topic for yet another
toca for half an hour to explain how
java.lang crea finalizes for so sorry
for that a little bit disappointing but
sometimes you really have to understand
what's going on this leak was easy this
leak was hard but that is interesting
example so maybe you can maybe you will
remember that and next time you
she is very strange hip dump and you see
okay finalizer I do remember that a
little bit so I will go in google and
you will find our article and our blog
about finalizar and we will explain that
to you the problem is or not the problem
what I wanted to show you with this
example is that histogram least objects
with ingoing and outgoing references
allows you to walk through your hip and
to understand why i am so big whom are i
holding why i am so big and who is
holding me why garbage collector cannot
collect me so these two pieces of
information is more or less that all
that you need to solve a memory leak
find the biggest object and find who is
holding that object in memory and
they'll break that chain okay and now i
have the last topic and that's about
classloader leaks classloader leaks or
permanent generation league as I they
were traditionally called because meta
space has not sourced that problem so
classloader league is the more correct
name for that and the problem with cloth
water leak is that as I have already
told every object in JVM has a strong
reference to its class every class has a
strong reference to its class load due
to the graph loader that has Lord is
that class and at least in Oracle
implementation of class loaders every
class loader has a reference to all the
classes that that class loader has Lord
which leads us to a situation when you
have a web application for example the
simplest example of class loader League
has web application you undeploy web
application or redeploy that
and you and you have somehow left one
object from your application live behind
either some thread left running or you
have published some objects from your
application to ginger 33 for example or
two other registry then that object
believe beyond your own your application
and that object will hold through that
chain all classes from your web will
flip a web beans classes in memory all
classes from your application will be
held in memory by just one object and if
you deploy that application yet again
after redeploy for example that
application by web application
specification we load all those classes
a game it will not reuse those classes
already in memory because for each new
web application for each new deployed
web application web container will
create a new class load and it will load
all those buses again so all classes all
static fields will be held in memory but
that one object yes no unfortunately not
that bad object has the residents to
class class to class loader class loyal
to all classes fortunately a class has
no reference to all objects that would
be pain and class load leagues in fact
they are quite easy to solve if you see
so how to detect that you have a memory
that you have a class load early you
have an application you make web
application for example you make a
redeploy and you see that your permanent
generation or meta space usage has grown
you make a redeploy it has grown again
it doesn't decrease you have a class
load early how to solve you make a
couple of redeploys you may
can we make a heap dump opens it with
mud and then just ignore that picture
you go here at the very bottom duplicate
classes duplicate classes and you what
this shows you it shows you all the
classes that have been loaded by
multiple class loaders and that's it
because well because water leak the
situation when you have classes loaded
again and again had not been reclaimed
so you just pick arbitrary class
preferably from your application because
that will be assured of sure a bit some
clothes from your application and so in
this case it is referenced by to class
loaders one of them belongs to the last
deployed application so one of them is
okay is a good one because what would I
have done here I have I started their
application I make one I made one
redeploy so now I have two two copies
from application in memory or
application classes one from the first
one and one from the redeployed one so
the second one is good the first one is
bad how to distinguish between them
again you ask give me pass to GC routes
from one of them and from throw from
another of them and you see here you
have one chain that class loader so you
you now have to find out who is held in
that class loader in memory these class
loaders is held by one chain from g0
these five changes chains so bit are
that this one is newly accentuated web
application which is now running and
this one is the previously under played
and that is the leak
simple rule rule of thumb the remote the
one is the less number with the least
number of chains that the culprit that
the leak and now you see that you have
some Java SQL driver manager maybe she
has a field registered drivers which
holds GT bc driver of your application
so that these part you see you have some
system level class which is GC root as
you remember which reference is your
class in that particular case your class
being GD bc driver from your web being
flip and that driver references
classloader class loader references all
other classes so now what you have to do
we have to break that chain how you
either knows that know that or you go to
Google Java is quelled rival manager
class loader league that's all class
water leaks are quite simple you find
the reference go google and that's all
because the majority of those class
loader leaks are in fact from the
libraries or well from that more or less
library not your class not your fault
the fault of application server or your
library and chances are that program is
already reported is already on the stock
stack overflow or is already in the
library back tracking system so you will
know how to find how to solve them or
you use tool that we have agreed not to
mention today that in the majority of
class water leaks will give you the
exact solution take that piece of code
put that in your application you'll be
good to go ok and that is almost all
that i have wanted to tell to you except
one more thing yes one more thing
do not use profilers for memory leak
detection and soda please that doesn't
work a couple of years ago we have tried
to solve memory leaks we have
applications memory leaks and we tried
many different tools a PMS profilers
debuggers you name it only heap dumps
and active memory analyzer was up to the
task profilers they can give you some
information which can lead you to memory
leak if you can interpret that but other
than that if you take into account the
overhead of profilers and memory
providers don't just take it heap dump
load that into a detective memory
analyzer and you're good to go do not
use profilers yes you have question yeah
almost not because if I have to to heap
dumps I can compare them and see what
where they increase but often if I just
take the second one and I've used
techniques I have talked about that's
enough so that's also me today if you
have any questions please other than
that thank you for your attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>