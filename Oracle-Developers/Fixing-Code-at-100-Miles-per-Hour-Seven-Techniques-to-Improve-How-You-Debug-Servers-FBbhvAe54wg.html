<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Fixing Code at 100 Miles per Hour: Seven Techniques to Improve How You Debug Servers | Coder Coacher - Coaching Coders</title><meta content="Fixing Code at 100 Miles per Hour: Seven Techniques to Improve How You Debug Servers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Fixing Code at 100 Miles per Hour: Seven Techniques to Improve How You Debug Servers</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FBbhvAe54wg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks everyone for coming to this talk
about production debugging at a hundred
miles per hour let's get into it quick
overview about myself I've been writing
code i would say for the past 16 years
focusing mostly on back head system
majority of time spent with teen c++ and
java so i couldn't render a web page to
save my life but um so that's been my
focus and filemaker i work at a bunch of
companies were issues of scale and
distribution were really big players
within our ability to ship software
confidently and you know ship software
that works and production debugging
especially has always been kind of a
passion of mine something i was always
very interested in doing and learning
new techniques and you know something
that I've always loved doing and
actually to the point and a couple of
years ago when we were faced with the
choice of what we do want to do next for
you know how did the startup and then
that went well and got acquired then I
did it and we kind of decided what's the
second company I want to do and I said
you know what I'm going to focus on
something I'm really passionate about
just production debugging so I'm not
going to talk about any of that stuff
today but it is something that I really
really love doing and I want to share
some techniques and some method that
I've used mainly over the past couple SI
2 years that have helped me tremendously
in being able to fix things and get
visibility into issues which would
otherwise going to be much harder also
blog about it and to keep a blog about
production debugging logging super low
level performance stuff so check it out
if you guys have the time let's get to
what we actually want to talk about
today and what do I mean by production
debugging because it's just it's a whole
universe but we want to talk about what
is we're going to focus about today so
we all know that
and we're no debugging locally
essentially if the product of the
process is what I like what I call
forward faith are for tracing meaning we
start from the beginning of the program
and we essentially let the code run and
each point we can see the variable
States at controlling the applications
flow control leading us to the point of
exception or the point where the app is
misbehaving or the point where we're
essentially impacting performance and
there's a university of tools to do that
IDs and we're not going to talk about
any of that stuff today what I want to
talk about is production debugging which
works in Reverse it's essentially
backward facing its or back it's
supposed two books about back-tracing
where something happens along the way
and essentially it's up to you to use
forensic evidence and your bread crumbs
left along the way to help you to go
back to it from that issue that you've
detector has been detected for you going
all the way back to the root cause now
modern production debugging which means
you know you're working on the scalable
architecture you have all these nodes
running some other versions of the
software all talking to each other
either synchronously using restful api
or asynchronously which is exploded over
the last couple of years using queuing
mechanisms and no frameworks no arm and
scala and all these different QT
mechanisms mana production debugging
poses to new challenges for us which is
state isolation data distribution by
isolation i mean you have nodes is
similarly essentially which are
processing vast amounts of data and when
something happens and bricks
sporadically you have to be able to
isolate that transaction everything that
has to do it very quickly out of that
entire data storm and the second thing
that plays into it it's that data is
nowadays almost by design is distributed
across different machines across
different nodes so it's not as if you
can go and have like one single log file
that you can open it up if something bad
happens you may but a lot of times you
know your depend on multiple log files
multiple data points coming from
different nodes and components within
your system
or other systems and it's really up to
you to kind of tie those pieces together
to be able to back-trace understand okay
this machine Phil but it's actually this
machine no much further upstream which
you know kind of was the one in charge
for that cardinal sin which caught that
air to be and there's a direct
correlation between the quality of data
that we have and that we're able to
capture to our ability to actually
resolve quickly so what we're going to
focus on today is really a couple of
techniques that help us gather better
better data really having what kind of
detectives you know the more evidence
that we have the quicker we're able to
get to resolution understand what's
causing this so on talked about for are
four different kind of tools and
techniques today and within those dive
I've into some additional ones and you
know I wanted in within the context of
the talk to make this something that's
practical so I kind of looked back and
said one of the things that I've been
using the most over the last couple
areas and I've been doing production
debugging either internally we're
working with other companies so no I
didn't want to go to like the extreme
and choose something like no hard core
core dumps you know we're in the JVM
scratch you know it is that stuff all
valuable it's not something that we do
on an everyday basis but really want to
see what are the things I've been using
the most and have had the cost to value
because a lot of time for you to go in
and am I the core dumped into all that
stuff at the C++ level you know takes a
lot of time and you know it may not get
you to that point so what I do want to
talk about is some best practices around
distributed logging that have up be
tremendously and I found it on other
people have sort of implementing them
trying using a mouth they've also
reported it says something that's been
very helpful to them then I want to talk
about some debugging to some low-level
debugging tools some which may have been
new to you and some which you already
know but I want to put a new spin on
them which is how to use something as
foundational HJ staff but in a new way
which makes it much more powerful in my
mind and then ah an open source tool
which I want to cover which some of you
may or may not know but it's pure magic
which is be tracing and then
the last most advanced technique is how
can you actually write your own custom
java agent going to share use case of a
really hard problem we dealt with that
this technique really enabled us to make
a breakthrough with and something that
is very valuable in my mind so we have a
lot of stuff to cover so I really kind
of want to get into it so when it comes
to logging essentially and we all log
right it's it's it's like cat it's like
one of the most basic idioms so I want
to focus on really two things that in my
mind can really improve the quality of
logging and a distributed system so when
we talk about logging there's actually
two pieces to every log statement that
we make there's the content whatever is
we're actually putting in there the
variable values to stay no on entering
transactions oh and so of about to do
this I'm about to do that and then then
there's the second part which in my mind
is as important to your ability to UM to
debug something using your log which is
the context you know that part which
comes to the left of the actual logging
statement and this is some place where I
feel people a lot of time don't invest
enough effort and it's actually
somewhere when it comes especially in
distributed systems it's crucial so I
want to talk focus mostly about Fred
idea and transaction anything and how we
can use those two tools to make
production debugging better so what's
transaction ID this is a design pattern
so it's not like an actual class for
what I've and every company implements
it differently those who do and I've
seen people get great results so logging
nowadays ok if you're dealing with our
web container which is almost back
design a multi-threaded or a
multi-process architecture logging is
usually spread across no different
Fred's different files and when
something happens across a flow within
your system you know something starts
here then it goes into a queue it gets
DQ'd gets analyzed and you're sending
out an arrest restful request to another
server to process get results you know
and stuff is happening the most
important thing for you when something
breaks and you get like a stack trace
for example
or like a log errands like trying to
look at from a file is really the most
important thing is to go to very quickly
capture everything that's related to
that transaction across the cluster okay
across all the machines and the best way
that I found to do it in terms of like a
design pattern idiom is what I call
transaction in D which means whenever
you have an entry point into your
application a user is sandy is clicking
something or somebody sending inbound
data your way at that point I saw the
isolate that point and assign it a
unique ID this can be just as simple as
a uuid which a lot of people use or it
may be something that's
application-specific if you have that
but it cannot be the user ID or a system
ID because you need to isolate the trans
that that specific transaction that's
why you a these are so powerful here and
then then you want to do two things
first of all you may want to make sure
that's appended into the logger context
so every line okay within your logger
should have that transaction ID appended
to it that will enable you to isolate
that process then the next thing that
you have that you have to keep in mind
and that's where it gets harder and that
requires a lot of discipline and
unfortunately there's no way right now
that for doing that better is you want
to make sure you maintain that across
the flow so whenever you make you make
an outbound HTP request or uq something
the message you have to make sure that
gets propagated along with the payload
that you're sending and when you're
dq'ing that from the message or you're
pulling out in a server or something
you're going to do the same thing and
you're going to take it you're going to
take that you you ad usually you're
going to store it in a TLS so you're
going to give it like a threadlocal
variable and you're going to place that
in and make sure that at any given point
in time and I'm going to show you some
examples around that you have that TLS
flowing as part of your execution
context so this is something that's
super critical because when something
bad happens and you're going to pull up
log files and use your log analyze like
a log stash or like a Cabana I'm sorry
like a log that you're like a paper
trail sorry it's very very easy for you
to pull up all the data related to that
transaction across
machines and seat execute and that is
super critical and something that I
found it when I don't have a tactic
start looking manually for stuff logical
I can spend a ton of time so this is one
thing second thing which is something
that's overlooked and I think probably
one of Java's unsung heroes when it
comes to production debugging i'm going
to show you multiple facets of this our
thread names so we all know that thread
have names it's something that's know
since it's been there since Java one or
something and I think that's something
that we don't use enough and I think
actually sis are starting using them
more intelligent the over the past
couple of years especially in tandem
with other tools I can get really really
great results so um as you know a thread
name is just a descriptive now we all
use it you know we all know about just a
descriptive property that is that every
thread has an den it's mutable meaning
we can change it and all people were
kind of a lot of times they're kind of
hesitant about doing that because no we
think that the container may not like it
i've got use it with a bunch of
containers and usually a hundred percent
of time there's no issue and I think
every container that actually is
codependent on the thread name it's
probably not it's not very solid pattern
and the reason why this is so helpful
i'm going to show you that in a second
is where we're gonna we're going to use
it in tandem with other tools such as j
stack for example so what I mean by
talking about thread name okay what i
mean by actually doing with it so what i
want us to do is within that same
context when you're assigning a
transaction ID to our thread okay you've
got a servlet you've got a scholar or
actor you've got a message that's being
the cute and you're assigning you're
pulling in or either generating of
pulling in a transaction ID you also
want at that point to set the thread
name and you asking yourself why because
we're going to show that when you're
going to take something like a.j stack
for example and j stack I just I'm if
people for those who don't know it it's
a tool which comes with the JDK is it's
very simple no it's it's an intrinsic
part it's actually just gives you a
snapshot of all the stack traces which
are running on the JVM at that time so
if you take
KJ stack and we're going to give an
example of it and you look at the first
statement okay and you're trying to
figure out what is this server doing
okay the challenge you're going to have
you're going to see pull one thread one
for example that's the name you're going
to see and essentially you see the call
stack but you have no idea what this
fred is actually doing okay assuming you
do the second bit where you actually put
in the time within and this is something
that most companies do at the
infrastructure level mean you don't have
to go and and spray it across a hundred
different place if you have service for
example and your company usually
inherent or derived from a standard
servlet and then you kind of use that as
a base point to them yogu do specific
application at that point no appending
that is we're going to be what if you're
going to make the difference between
something like a pull one thread one
which is pretty much meaningless to
actually be able to see exactly which
message is this thread processing what
type of message from which q is coming
that transaction ID and one and even
more importantly when did it start your
if you're looking at a server that's
thats hanging and you get like a hundred
and get like a hundred call stacks
within the j stack it's extremely hard
for you to know which one I know his
this won't be running for under for one
millisecond it's going to release a
second from now or it's been stuck there
for like the past five minutes it's so
hard to know because J stack is
stateless you have no state attorney
console when those Fred's start what are
those fred is doing if you're putting a
time stamp on it it's very easily fruit
for me to come in and say alright who's
been running the longest here ok you're
stuck ok you've been running for six
months you haven't you're not released
yet ok but not only then I'm going and
all right which message are you
processing what are you getting it from
what transaction ID are you working on
ok that simple trick has helped me
tremendously when I look at a server to
be able to pull that data and go
reproduce it locally pull that data and
then I could do because essentially our
goal when we're doing production
debugging is either to get enough state
to get your resolution using the
forensic data or at minimum get enough
data so we can go in and do for tracing
reproduce locally if I have this N or
you're the slowest want you're the slow
one here here's all the data I need to
reproduce I can go in and run that code
locally so using thread name in
conjunction with a J stack is super
powerful and technique that I've been
using and I strongly recommend you guys
consider it as well another place where
thread names and TLS is play a huge role
is with uncaught exceptions because if
you have an exception and you throw it
okay and you log it assuming if it's log
or it's called within your code we've
already talked about how you have your
log upended is going to get all that
data in I've seen multiple times where
people don't use uncaught exception
handlers okay which are your last line
of defense will find the threading
framework if something gets on cod and
you don't catch it it's going to go to
here before the Fred eater dies it goes
back to the thread pool this is your
last chance to capture data other than
the call stack and so if you guys are
not familiar with list I strongly urge
you and this is also a place where TLS
is Fred local variables and the fred
name are crucial because at that point
they're the only surviving state all
local variables have already been rolled
over the thread is essentially bit at
that point but if you have the fred name
which is fully loaded with pls is like
transaction sorry the thread is fully
loaded with TLS is just as a transaction
ID and you have a good name for it you
can log at that point and all is not
lost so ah this is so if you're using I
can't a like a sophisticated container
for the most part it will usually have
that built and for you but still I saw
any urge that you have this in place you
know it's a great place near ready to
put breakpoints in log stuff on and also
have full control of exactly where
you're logging this too especially true
if you're sure if you're running long
term job if you're wrong short running
java processes if you got like a Tomcats
like running forever something you
probably have something along those in
line but if you're spinning up a process
to do a short-term job ok and dodge and
that process is supposed to DQ something
process a process something and be done
with an exception happens and it dies
this is what you want to have and you
want to make sure that gets logged there
so this is
also you know a pattern which sometimes
I see people miss out on and it's a
shame because it's super helpful on a
move its forward and talk about Jay
stock as a tool and I some creative uses
that we can do with it I like taking
those stuff that's been out there for a
long one figure out ways it to it can
kind of do new stuff with it so as I
said it's a production debugging
foundation it's my go-to tool whatever I
have a vm ok the first thing I asked and
it's hanging or something do we have a J
stock for it can we actually see what's
going on but Jay stack has two main cons
to it okay which is a it's only
activated in retrospect mean you have to
be there to do J stack PID to actually
get the values and production debugging
in this review systems ninety-nine
percent of the time you're not there
when it happens okay and by the time you
get to it hours of past the state is
long gone and you can't actually get to
the data which you want so that's
another problem the second problem is it
doesn't actually give you any state I
mean you're going to see a ton of call
stacks but you're not going to be able
to actually see any variable data which
is a shame because you really want to
understand right what's this code doing
but more importantly why is it doing
what's the variable state which got it
to the point if it's if it's if it's
waiting for this you know if you a lot
of time know like a classic case you'll
have like a server you know and your
connection pool is depleted okay some
queries are like hanging and you're
trying to figure out which ones are
causing the server to hang so you go in
and you Jay stack the thing and you see
like everybody's waiting either waiting
for the server to return or you're
waiting for the connection for something
is trying to figure which is these
queries are shorter are short-lived and
which of these are super long live there
under ones which are causing the server
to stall so again this is where the Fred
naming bit is going to come super handy
because we'll be able to see exactly
when each query started okay because
we're going to set up the duration time
for that pool for a threat at the entry
point in from the thread pull into our
actual code we're going to set that time
but so what I want to do is I'm going to
show you a demo of how we can actually
use Jace
preemptively to make sure we actually
get automatic J Stax from our servers
even we're not there this is a design
pattern I've begun implementing within
our system about a year ago and it's
been just pure magic in that respect so
I've actually stripped down and by the
way all the examples all this stuff is
put up on github so you can go to github
com to keep UJ stack and grab i'm going
to show you guys just a cup of think i
stripped off of our production systems
you can kind of take them as ideas and
see if and now you may want to
incorporate them into some of the stuff
that you guys are working on so what
I've done here I've stripped by we have
this huge mechanism but I just can't try
to boil it to a bare-bones minimum so we
can kind of look at it within this
context here so what I have here
essentially is an application and the
point here is how can we use J stack
programmatically meaning how can we
actually set a minimum application fruit
threshold meaning we know that our
application is supposed to be doing x
and y this server once it gets you know
once it spins up after five minutes
should be doing let's say a hundred or a
thousand or so and so requests per
million this is an application-specific
benchmark what I've done essentially for
example we have processes which are
which are tasks tasked with dq'ing
messages from our from our Amazon SQS
framework and Duke you messages and
processing them and what we've done
essentially is we said you know what
each process whenever you see that you
do new fall belief beneath a specific
threshold of processing messages
actively get a Jay stack for yourself
and put it somewhere so what I do
essentially is we if we have we see we
have a production issue something's not
working we see stuffing things starting
to go down okay or I'm a good called
into it like five hours or a day later I
will automatically have J Stax waiting
for me with States on that server for
that specific point in time and it's
very in it super and surprising how easy
it is to do
essentially if you it's just a process
and you can execute it from your code
i'm going to show you that in a second
and while you can what it's possible to
actually capture our stack traces
internally from within your application
using regular all stack traces i don't
recommend it because a if no that's the
kind of that can be a risky kind of
method to invoke if you're georgia if
your jvm is experiencing something so
that make can cause your code actually
to block by itself also j stack is more
powerful in that respect it has all
these arguments which you can use to
actually if you do like jay and i work
you can actually see native frames you
can actually see which locks are owned
by each thread so i highly recommend
actually isolating and running that
process externally on it to self
introspect your jvm and the way that it
works usually i'm going to give you guys
and show you guys how this thing is
working here so let's say I can punch in
for example a value that's been if I've
said I think like a thousand or
something as a minimum fruit boots so
what is it when I go like here and I
said fruit booter and I've reduced it by
one doesn't matter but once i have that
it's going to within ten seconds I'm
going to have straight in the log is I'm
going to have the actual the system will
automatically each self now just put it
into the system ARR and the nice thing
about it is that even the fruit blue
thread will now show me the actual
throughput value when I'm j stacking it
so i can actually know at that specific
point in time what caused ah no other
specific matrix at that specific circuit
if I'm taking a bunch of J Stax and I'm
comparing them I'll see for each thread
a ton of context exactly what it's doing
the transaction ID when it's starting
doing it and then for the fruit put Fred
richest and it a specific for to also be
able to see are the actual our
throughput at that point in time this
has saved me multiple times when we had
like issues especially when they are
expert at 'ok something happens
you know that server gets restarted now
it's all good back and now it's all good
and it's very hard for you to go in and
figure out exactly from that huge amount
of log files what happened that time if
I have this and usually I just put it in
a separate file I sporadically I can go
into a specific point in time and use
and use just use that facility so this
is something that has been proven to be
tremendously helpful and especially when
combined with transaction IDs and thread
names so this is one design pattern
which I really really encourage you guys
to arm to consider as a tool the second
kind of tool which I want to talk about
is something which not all people know
about unfortunately and I think it's
really one of again one of those unsung
heroes when it comes to production
debugging which is be trace okay this is
an open source project it's been out
there for a while now for a bunch of for
a couple of years and its really it's
extremely powerful it has a couple of
drawbacks which I'm going to discuss but
essentially what it does it enables you
to take a live JVM and especially and
specifically write a made of script
meaning right could add code to that JVM
without restarting it without changing
it anyway which is named essentially
enables you to get into every specific
variable every specific point within
that JVM get it and capture it which is
super duper powerful because for example
a if there's a variable value are
interested in and you haven't logged it
okay like bummer ok I have to them now
go in and change the code redeploy test
you know redeploying wait for it to
happen again or I might have to try
catch a deep it's very hard if there's
something specific with Jamie which you
want to get you and that JVM is running
and it's a complex application to get to
it be traced enables you to do that in a
very very elegant manner it's an
extremely powerful tool and it's fairly
easy to use it uses a java agent
something i'm going to talk about as
part of the fourth technique to capture
to capture application
steak now the cons when it comes to uh
to something like um Abby trace is that
scripting language which you use to
which you used essentially append code
and insert coded specific cut points
into the JVM there's a bit of a learning
curve there and also one of the biggest
kind of one of the one of big traces
biggest you know premises is that it's
read-only meaning it does not enable you
to does not enable you to actually
modify the JVM state right which on one
hand is like good because you actually
want to debug something you want debug
something so you don't really want to
change the JVM state but the problem is
that if you want to do something like
add a logging statement into a specific
cut point in the file okay on you're
going to reset something at a specific
point to see what it does that's
changing the JVM state and Beatrice will
not allow you to do that so it's super
powerful for a grinning collecting data
but if you actually want to be more
active about stuff and you want to say
for example if this happens I want to
invoke that method right now because I
want to see what it does or even more I
just want to log I want just want to log
in these variables here which are
currently not logged it's not something
you can do there is a way to do that we
will cover that with our fourth
technique which how do you write a
custom a custom java agent but won't
that start with B trees now when I say
it be trace has restrictions I mean it
okay there's a lot of stuff that you
can't do with it okay it's very powerful
even if you want to do something as
basic as you want to append strings for
example oh that's allocating objects
you're not allowed to allocate objects
okay so you have to use a specific set
of libraries that are safe that are
considered safe by beatriz it's not that
big of a hassle once again it's fairly
limiting in that sense so I want to show
you guys some examples of what this
thing actually looks like and again like
be traced in itself you can do like a
hold one day class on
okay it's not it's extremely powerful
the things that you can do with it as a
tool I'm kind of giving a bad rap
because mushy not showing all these
restrictions actually an amazing tool
okay so I'm just going to show you a
couple of scripts and the end really cod
are going to get started with it the
best way to get started with be traces
actually uh take some of the samples
that it comes with and work and work
from them this is for example a socket
racer okay this is extremely powerful
what if I can go to a JVM and write a
custom script that will show you exactly
when and where sockets are opened
without changing the code without
deploying any JVM that's running
attaches showing all the sockets are
open or show me every sequel statement
that is made of show me if this this
file for example which thread is writing
to it and why again without changing
code this may not be in your application
one of the things that Beatrice is
extremely powerful it's not just limited
to you guys as code oftentimes I go to
if there's a specific library for
example if something's going crazy with
in tomcat I understand why I can use
Beatrice to introspect Tom cap code it I
don't have the source code qu the source
code for I'm not going to recompile and
deploy my own version of tomcat for
example so and this is just an example
that every library that you're using
it's doing something funky you can use
this so let's look at this language for
example this is the be traced language
which is essentially a variant of Java
essentially what it does you define
something like cut out what's called cut
points between our inject code and
specific places within the app meaning i
won't inject this piece of code whenever
this gets called ok this cut point or
whenever this method returns when
invoked within this code ok run this
that's how that's it's essentially think
it's like a meta script you have your
code and your cloud you're putting on
these little stickers with additional
code on it and what beach race does it
weaves that into your code dynamically
without again having to restart the JVM
so if you look here this is pretty
interesting instead this script is
saying you know whenever
or somebody is initializing a server
socket okay at the point of return I
want you to do this so you see I want
you essentially 22 log here to print
line here and whenever somebody binds a
socket do this so it's super easy to do
and it's very intuitive once you get
kind of get used to it okay you see it's
doing both the neo and just to serve the
standard bindings and we're somebody
except a socket you can also you can see
you know exactly how you can add code of
those points now if you want to look at
you think does it and another pretty
cool example same deal is when you look
at for example log files sorry just file
i/o and this is actually pretty cool
because this is one area when you see
you can actually define Fred local
variables directly within be trace so
for example you can say exactly when
somebody opens up a file for for writing
and then you can store that file and
then you can log in and see exactly when
it's closed so for example you can say i
want to see exactly when someone's if i
have a file for example when it's
exactly when somebody's writing to it I
can see that directly from here and when
it comes to the samples bit there's like
50 examples that come with be trace and
covering just just a plea for justice an
endless variety of options going to show
you get the last bit which is pretty
amazing is this script here you can take
it and essentially it can give you
amazing statistics about know every jdbc
connection that's being open or executed
within a live JVM and you can take this
thing and tweak and it's exactly though
this corey how many times has been
executed without using any additional
external tool or you know and you can
also incorporate your own kind of
variables into it capture TLS as this is
an extremely powerful tool once again I
can do like a whole day on this thing
but this is I think an extremely
extremely powerful tool so I really
recommend you guys if you haven't had a
chance to look at this it's open
source its up on project can i I've been
using it for a ton of time and really
really highly recommend it so of course
I'm happy to take questions about it
afterwards the last technique which I
want to delve into is probably the ones
that's the most powerful okay that's
when you're actually saying you know
what if Beatrice is not enough and we've
had those instances this is probably the
most powerful debugging technique that
I'm that I know when it comes to
extracting state which is how to write
your own java agent this is the
foundation which most profiling and
debugging tools that you use today
doesn't matter which if it's an end
performance monitoring tool a profiler
debugger this is what they all use ok
and once you get the hang of how to
write one yourself ok it can be
extremely I'm going to give you a use
case where we actually had a crazy issue
in production a couple months ago and we
used this technique to actually be able
to to overcome it now I want to talk a
bit about what's an actual java agent
some of you have heard about it some of
you have not so really want to kind of
clarify what these things are
essentially the JVM the JVM has this
innate ability to load up two types of
aging you all heard the name Java we may
have seen like two that we use when we
add like the minus Java agent and this
will also explain to us how be trace
works by the way we've all seen it but
actually something not all people know
about there is actually two types of
java agents that the JVM knows how to
load the first one is called a java
agent versus and the second one is
called a native agent java agents are
essentially it's kind of like Beatrice
essentially it's a nap it's a jar which
you can load up dynamically connected to
a JVM and start modifying and changing
and injecting new code into your jvm in
real time so and at that point you no
longer limited you can do all that set
of huge restrictions that come with the
JVM with Beatrice for example that
you're not able to do this or not able
to do that all that goes out the window
you can do
everything under the Sun that you would
all want to do with that no at that
point terms of code in terms of
allocating capturing States super
powerful now job what's the difference
between Java agents and native agents
Java agents are essentially you write
them in Java just a basic jar which you
write and you deploy and you hook up
into your jvm and essentially you load
code and modifying code I'm going to
show you a sample of that the second one
is something which is completely
different called a native engine
treating C++ and essentially if you ever
wanted to debug the JVM itself and get
like super low level visibility to like
things like when garbage collections
happen and why and be able to see
exactly who's acquiring a specific minor
lock or you want to be able to set
breakpoints dynamically it's it's
infinitely powerful but the problem of
those they're very hard to write because
you have to write a C++ you have to hook
it to the JVM and it's something that's
usually when trying to fix an issue in
production you're not going to have days
on end unless it's such a huge bug it
you'll be to do that so it's usually if
you're only building like a tool or
something specifically for your app for
your company that you might consider
using that also if you have an exception
or doing something bad and C++ you're
going to crash the JVM because you're
running code at the cipa at the JVM
level you're no longer protected by all
of these things we have like null
pointer exceptions if you do something
bad the JVM goes away so that's why
that's not something when it covered
today but there's actually a post that I
did about the differences in the pros of
cons of each if you download the deck
from the speaker's portal it links to
their it links there now when it comes
to changing tomate to working with
bytecode and essentially being able to
capture state the biggest con to writing
java agent versus using something like a
beach race and that's why i started with
be trace is that while Beatrice is very
Java it's right it's you're writing code
in Kwazii Java in that respect and we'll
job with some limitations on it
unfortunately Java agents ok operate at
the bytecode level meaning if you want
to change a method to add a logging
statement for example or to capture some
steak you're going to have to do it in
bytecode the good news is there's a hack
which is which I've been using for a
long time now to allow me to circumvent
all that and be able to very quickly
write Java code and injected into a a
java agent so what I want to talk about
today in terms of demoing that demoing
this is actually a situation that we had
in uh in production a couple of months
ago where sporadically once every 10,000
requests something bad would happen to
our Tomcat container it would start
allocating a cricket will go into a hot
loop allocate a ton of internal objects
and essentially throw out of heap are
out of memory exception and die okay and
this would happen every like every week
of a couple of days or something it was
super sporadic and we didn't fit and we
had no idea as to why this was happening
so the first thing we did is we set up
the JVM to do a core dump whenever out
of memory exception occurs you have a
switch you can say whenever that happens
do a core dump or we take the core dump
okay we open it up we see it's
completely full with internal objects
allocated within the Neo framework like
this gives us like absolutely no
understanding is to why this is actually
happening who is allocating these
objects why and to which server with
twitch actual users customers actual
actions within our application this is
tied to so we were stuck in your shawl
right all right let's write a Java agent
to figure this thing out and the point
is what we wanted to do is you wanted to
know whenever somebody allocates that
object we want it within Tomcat whenever
that object gets allocated we want to
know exactly not only where is it coming
from but also we want to capture the
tailor the thread state at that moment
which on which no ties back to what I
talked about all those TLS is that we
have so we can see exactly which user
which action which query which push
activity is causing that thing that
happens it's a combination of injecting
code of capture call stacks for us log
them and that
incorporate into that actual thread and
variable state information okay and this
is what we wanted to do and this is
something that's very hard for you to do
it like it be traced because you're free
to do all that stuff log and get to
access to all their very bananalogue
them to file it's not something you can
do sit right this is bad enough to the
point of or we're going to invest
the time and write a Java agent okay so
how do you actually go about doing that
it's actually very very simple and this
is something that a lot of people kind
of think about is the super advanced
technique it's actually very very
straightforward and it's no different
than writing any other Java code all you
have to do is your kampala jar okay and
instead of having a main function and
all the tools which you guys may be
using for performance monitoring
profiling they're all doing this there's
no magic here there's no voodoo it's
just this essentially instead you're
writing a jar which instead of having
like a main method it has something
called a pre main method I'm just
calling it here we have mainly we all
know all java package start with main
java agent this is this is a kind of a
keyword it starts with pre main and the
difference it con looks the same it's
just a string which give you some
arguments but then you get this this is
probably the most powerful this is
probably the most colorful object that
exists within i think the the java
library in terms of what you can do with
it and you can only get access to that
instance if you have a java agent it's
being loaded up into JVM a normal java
application cannot get for security
levels access to the instrumentation
object just because it's so powerful
using this object you can essentially go
into every class that's running and
change it dynamically completely rewrite
that class in at runtime doesn't matter
if it's tom cat class or a third party
class for example or your code you can
go in and start changing that code and
the JVM will support it we compile that
code and start running it so of course
you see why that's something that
requires some security that's built into
it and what you do essentially when you
want to work with such a class is you
have something notion called transfer
murs okay I'm not talking about the
movie transformers I'm talking about
these fellows here which essentially
enable us to take any class file and
change it I'm going to show you a
concrete example how will change it how
we're taking a live a live class and
we're changing it here we actually did
this we actually take the class not the
class name which you want to change is
an argument which is pretty cool so you
don't have even to have the hard-coded
like we we did a bunch of testing on a
bunch of different CAD file so we had
different configuration now we're going
to hook into this fall into this class
now we're going to hook into that bus
and you add a transformer and that and
that and essentially all it does all
transformer does is it implement a super
easy class fall transformer interface
it's just one method again there's no
magic to it it's super simple it's super
easy to do okay this means okay you're
getting this class which you want to
change and essentially it's got bytecode
okay and this is where it gets a bit
difficult and basically where we're
going to hack it okay and you're saying
okay this class file here okay I want to
change it so essentially you're saying
tomcat neo something something direct
block socket or this class here which an
application class which is missing some
logging stations which I want to add
right now okay I want to transform that
class all I have to do is go to the
instrumentation object which I got into
the agents say transform classes give it
a parameter class file name and this
hook will get activated and once this
hook gets activated I get the byte code
for that class and essentially I can
then go in and change the bytecode now
the question now becomes how do i change
bytecode okay we all know java runs
bytecode and source code is compiled the
biker gets compiled a machine code so
since the JVM runs at the biker level
the question is where I'm what the hell
am I going to do with this bio ray well
the thing is there's a ton of libraries
that allow you to manipulate bytecode
and do something with it i'm going to
show you here an example
but i'm going to show you a super cool
tool that converts that will enable you
to write any piece of java code and then
get that and get essentially generate
your script it when able you to hook
that to weave that java code enter here
so for example what i'm doing here ok is
essentially i'm reading up I'm
transforming file okay I'm loading it
I'm saying you know what I want to work
on that file this is this is my little
class which is going to work on it I'm
going to run it and I'm going to get a
bite or a result ok so far i'm saying
this thing here is going to change that
class okay it's going to add new code to
it such as a logging statement for
example i want i want to make sure that
then with this code gets executed within
the system i want to add a logging
statement at this point to log these
variables without going in and changing
the code ok especially if it's if it's a
third party library all this thing does
essentially it just says when I hit the
constructor method for this class visit
method ok and essentially whenever I
find the constructor constructor in Java
are just called in it what I want you to
do that's it I want you to add in
another invitation for a method ok I
want you to go in and I'll show you
exactly how to generate this code this
little API here i'm going to show you
exactly how you can create that you can
auto generate that code we say i want to
take a bunch of java code and just push
it into the constructor method so
whenever that code gets called I want to
get a hook into my code where I can come
in and essentially log stuff change
things and the way that gets done
essentially this thing here okay this
whole class is just this essentially
what I done is what we've done is
essentially we've said all right
whenever the constructor for target for
target glass gets called invoke ok
invoke the hook clasp i'm going to show
you exactly how
this little syntax which is kind of
weird how you can automatically generate
it okay so you don't have to think about
what it's saying is if that gets if a
specific target class gets constructed I
want a call back to here and this is
what we did in at that point essentially
we said all right you want to take a
stack trace we want to take we want to
take a timestamp for exactly when that
object its allocated but also one
incorporate variable state and TLS
variables so because that was something
that was really hard code into our
system for this to kind of be a compiler
I remove that bit but essentially what
you want to be able to do with this
thing which is kind of sucks complicate
enables to do is say whenever a specific
object gets allocate whenever specific
method gets called in to call into this
okay without changing the JVM without
restarting it without doing any
manipulation to it in that respect you
have changing the actual deployment code
so you're doing this and at that point
you can do whatever it is you like the
question is how can you actually
generate that script that in the library
which I'm using them talk about a
section to manipulate and to create byte
code is called ASM it's like the
standard library some of you may have
heard about some of you may or not but
it's a super powerful library for
manipulating byte code and the way that
it works is essentially if you look this
is like bytecode this is super hard to
generate okay what I like to do is
whenever I want to take generate a piece
of biker which I'm going to inject into
a running JVM all I have to do and
install this plugin this is called the
SME fire okay which means this bit of
code here I just write the code in Java
and then I toggle this on and I get the
Java code which will create that which
will create officers essentially take
this create similar bytecode to this
which I can inject into the application
itself this is a bit trippy okay this is
where it gets a bit we have to kind of
give it a second essentially what we're
doing is
I want to take this method here in it
okay for example and I wanted to leave
it in too whenever set for example
whenever I'm opening up an sqlconnection
under specific set of conditions I want
to weave in this method using a java
agent into a live JVM without restarting
this is a super advanced technique at
that point I need to end inject new byte
code and through the actual arm JVM the
way to do it I just go in right whatever
by what right whatever code I want to
actually inject in like for example
login error collect state change
something close them extend an email out
I've even had situations where I wanted
to say whenever this happens okay within
the code okay without changing cluster I
want to get an email notification that's
also doable all I have to do is go in
write the code and then go here and here
this is the vsm afire you just download
the plug-in from the ACM you go to ASMR
you just Google and something that's
you're going to see it here you install
it and then whenever you write that code
all you have to do is then get that
script and you can go in and you paste
it to that transformer and just paste it
in wherever you want that code to
activate so for example I chose to do it
within the construct ER and again this
sample is up on github and you can play
with it and and then whenever the
constructor get called add this and just
weave this in oK we've this bit of code
in and the wage for you to do that
essentially if you want to take that
java agent and connect and connect it
you can either you can use like a visual
of a JVM assoc to connect the agent live
you don't have to restart the actual JVM
to hook up an agent to it run that code
and essentially your pre main the JVM
will load up your pre main code run
danger no you will essentially go in and
find at target class change it that code
will hook up and since you've now
reloaded new code into the JVM and at
that point you know whatever is you
it to do will start happening now this
is a super advanced technique I only use
this as a last resort this is why I beat
race for example which kind of looked
funky in the beginning is what is way
simpler because beach race the way it
was this one beat race which you looked
at earlier which was much more logical
in that sense okay it's doing the exact
same thing it's a java agent which takes
code which you right here and instead of
doing that bit when you're looking for
that method you know using ASM you can
punch in the actual methods you see for
example if you wouldn't do a constructor
it's always in it and you can type in
the cut point here and then essentially
start typing Java code so eighty percent
of the time if this is good enough this
is going to be much much easier on the
other hand if Beatrice is not enough
then check out that the sample for the
agent I've used it multiple time for you
to be able to really go in into JVM and
expect every piece of every bit of state
or every something that every bit of
operation you'd like to change in real
time we're in real time without actually
doing anything to the JVM itself so kind
of to sum up because we're getting close
to the end I want to make sure we have a
bit of time for questions we've covered
kind of four techniques within the hour
within this hour moving from best
practices for distributing login
focusing mostly on transaction IDs and
thread names then we saw how we can
incorporate these into j stats and how
we can use preemptive J Stax 2 and this
is something I'll probably say number
two is if you want to take something out
of this stock number two is probably i
think a key takeaway how you can use
thread names of pre-emptive J Stax to
essentially know what a JVM is doing at
any given point in time then how you can
essentially go deeper with be trace and
go in extract States and then probably
the most advanced example here which is
how you can actually go in and write
your own custom java agent to manipulate
anything with the JVM to collect data on
allocations
method invocations and anything you need
in order to solve a production issue so
we have five minutes left if people have
any questions left it take them please
Mike all right so for example be trace
or your java agents you can attach a
java agent to a running JVM without
restarting it that's the beauty of it
you don't have to change you don't have
to restart a JVM you can take any
existing JVM and attach a java agent to
it be traced being one or your own
custom agent being one please c++ it's
C++ the API is very well documented but
it's it takes a long time to get it
right so and also when you're writing
native agents you can actually have the
ability to impact performance you can
start at like a gazillion switches some
of them have minimal performance
overheard some of them will bring your
jvm to a crawl so with native agent
that's like you need to actually master
how to write like a native agent that
takes a long time that makes like
writing a Java agent makes it look very
simpler it's really your coding at the
JVM level but on the other hand it's
infinitely powerful you can tell you
things like whenever that variable gets
assigned anywhere in the code I want to
get a break I want to get I want to get
a hook or whenever for example this
monitor here gets acquired I want to get
a hook for that it's extremely powerful
to do but to be able to say I need to
fix a production issue and I want to
write a native agent that means it's
really really come to the end of the
line so the pre-emptive Jay stack thing
i'll probably have that capability Nabal
don all servers the agent thing is
usually when I go because I'm
introspecting something specific so with
retracing there's something in this
server that's interesting to me I'll go
in and be trace it I'll go in and
or just do the Java inch or one or two
of course it's up to you but it really
depends on what you're trying to find
usually I find it when I'm beat racing
when I'm deploying a java agent one
instance is enough versus with it
because I'm there when i'm doing like a
pre-emptive J stack it's usually I'm not
there so I want to have really good
visibility and I want to have those J
Stax available when I'm coming a day
later and somebody at ops told me this
wasn't working well yesterday so we
restarted the server at which point I
have no evidence to what the hell was
going on at that time okay I would go
into the J stock folder pulled up and
start looking at what was happening
around that time sir yeah oh that's
super simple you can essentially there
one of the nice things that the JVM does
it always keeps the original version of
the bytecode in memory so all you need
to do is transform the file again but
don't do anything it will revert back
any other questions yes sir yeah so
those are log-analysers logstash cubanas
actually DUI for it but essentially if I
have a distributed system okay and we
have I've all these nodes okay logging
stuff and at transaction is bouncing
between these different nodes machine a
in cute God is a front-end tomcat web
server or a jetty play it got a message
from user it logged that then another
and then he put a synchronously it took
it to another thread which started doing
something with that cuter than the queue
which DQ'd it another machine worked on
it if at any point in time I'm able to
inject a transaction ID into the the
context of the thread and make sure that
gets log a log analyzer like log stash
or like paper trays for example we're
very those are commercial tools so I
didn't want to get into that God says
there's actually open source well it's
simply with very easily enable it to
capture every log state and had to do
with that transaction that I can see the
entire story that's extremely powerful
and that to me is a
is really logging foundation when you're
working on a distributed system so if
you haven't taken a look at those paper
trays is also very good tools it's a
commercial to lab I'm not affiliated
with it but it's a great tool for being
able to distill that data alright last
question please so one of the things
that beat race does so be traced one of
the reasons actually what it has all
these crazy restrictions for example not
having closed loops you can't actually
it's funny you cannot do a loop within
j-style losing beat rates because beat
race is afraid you're going to add a
performance hit to the actual
application you're going to add a closed
loop for example and then exemption you
can bring performs to a halt you cannot
make a Jane I call look to a database or
like a log file or any any of those
things because once again you're going
to impact performance so beat race is
very good at know keeping to that
promise where you're not going to be
impacting performers on the other hand
if you do want to do a loop for example
which is not something that's very
exotic you want to iterate over an array
for example of our connection pool for
example you want to iterate over a bunch
of messages in the queue and log them
because it's currently not logged that's
where you're going to have to go in and
write your own custom java agents just
because the possibility of the
performance increase the performance hit
exists and that's where you're going to
have to default and do a custom java
agent but be traced to your question is
amazingly good at making sure that
you're not introducing any performance
overhead and that's why to me it's just
an indispensable to within my our shop
all right it's nine-thirty i imagine
everybody has our class to go to thank
you guys so much for your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>