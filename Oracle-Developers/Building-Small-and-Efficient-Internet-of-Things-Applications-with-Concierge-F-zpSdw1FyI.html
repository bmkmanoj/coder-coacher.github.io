<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building Small and Efficient Internet of Things Applications with Concierge | Coder Coacher - Coaching Coders</title><meta content="Building Small and Efficient Internet of Things Applications with Concierge - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building Small and Efficient Internet of Things Applications with Concierge</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/F-zpSdw1FyI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">first of all I like to welcome you all
to our presentation today which is
called building small and efficient of
things applications with concierge we
are trying to make this presentation a
little bit interactive so whenever you
have questions don't hesitate to ask
them right away we'll still have some
time for questions afterwards but I
think it's getting more interesting if
you ask you questions all right oh
you're at this right let me introduce
myself my name is Jana Gana mana I'm
currently with IBM Research in Austin
Texas before that I spent some time at
eth zurich on doing my PhD there and
most of my work is revolving around
mobile enterprise systems embedded
systems programming languages and
runtime systems are you find my contact
information below in case so you want to
contact me so I'm a temper baron I'm
from Ghent University from I mines I did
my PhD recently on mobile cloud
computing and i'm using of obviously
concierge for that and i will show you
in a minute with a nice demo how i use
cone church and why it's so so so nice
to have it so yeah the roads are clear
i'm the performance person i will
present boring charts and we'll do the
cool demo let's start talking a little
bit about the intent of things just to
make sure that we on the same page we
hear a lot about it right it's one of
the themes at this year's java one it's
one of the themes for the Eclipse
Foundation where we are doing our
concierge work we also heard a lot about
this being at the peak of its hype so
what is it really have we all been there
before or not that's the that's the
question to us right we're coming from a
work of computation that started before
the mainframe era we went into
mainframes which was centralizing all of
our computation into a few expensive
very powerful boxes and thereby enabling
sharing and collaboration on a very low
level we've seen this kind of going
towards the PC era we could afford
putting more computation and more
intelligence into the end devices and
for enabling completely new applications
that wouldn't been possible before the
web era kind of did the next step
towards that right we could now build
large area networks do commerce even
across the internet and communicate in a
scale that there was not possible before
um if you look at the bottom of the
error right mobile cloud IOT the
pessimistic point of view would be we've
all been there before right isn't mobile
just an extension of you know going from
mainframe through the pc to you know
notebooks tablets and now smartphones
maybe in some sense it is isn't cloud
just you know the pendulum swinging back
towards more centralization of computing
resources maybe it is right is an IOT
just glorified embedded systems and we
really have been doing it for 25 years
right that that's a valid point of view
the thing that I would like to point out
though is that every step in this in
this timeline it has been completely
disruptive to everything that was before
right and I personally believe that the
combination of mobile cloud and IOT is
just as disruptive to everything before
s we have previously seen so I
personally think that there's a lot of
potential and hopefully I'll be able to
convince you a little bit about that
right so let's start with embedded
devices that's your old maybe your
father's embedded device right fixed
function device ASIC possibly or
microcontroller very limited user
interface good for exactly one purpose
right does anybody have enough fantasy
to figure out what this is no it's it's
a very old-school mp3 player so it's a
lot less old than you then you might
think right the thing is if you cross
this over with mobile you end up with
mp3 players that look like that right
now what has happened in between well
first of all people were no longer
satisfied with the user interfaces with
the fixed function device
characteristics so what you see on the
right on your right hand side my left
hand side is more like an open platform
where you can install your own apps
where you can contribute your own
content
you can customize it towards your own
personal taste and do a lot of things
with it right it's no longer just a
single purpose device furthermore it has
a lot more richer way of interacting
with you because it has sensors built in
it has a touch interface and so on right
by now even those devices on the right
hand side have died out because it all
converged with mobile but anyway that's
the step that mp3 players have taken
right let's take another relatively
boring and better device right a
thermostat when I first came to the US I
was really surprised that I had to teach
my thermostat whether to eat or to cool
because it was even too stupid to make
this decision right it should be able to
do this decision with you know just a
few circuits more but it's it's a crude
device right if you cross this over with
mobile and cloud what you get is
something that looks a lot more like
that Fred so what has happened first of
all again we have a rich a way of
interacting with the device we have
connected device that takes information
from the internet that post information
to the internet that lets you control a
piece of your home from the internet and
that gives you an overall a lot richer
into action also it has a lot more
computational power in it and it can do
a lot more smarter decision on its own
right so take this as kind of a trend
that we are seeing from relatively
simple embedded devices towards things
that are much more like mobile devices
that are much more like cloud connected
devices and that are much more
programmable and customizable so we used
to talk a lot about ESS embedded systems
and software I think nowadays most of
the time we're actually talking about
esse right embedded system software and
cloud because without is really an
enabler for a lot of applications that
we are seeing embedded and an Internet
of Things right one of the trends that
we also see is you know it used to be
the case that you would program your
clients regardless of whether this is
the web or Internet of Things in a
completely different way than your
servers and this assumption has become
kind of void because people have taken
things that were originally just
design for the client side like
JavaScript and ported it to the server
so now they have a continuous platform
experience because the same person can
basically co-design the client and the
server which is a relatively powerful
constant we see other things converging
as well we've seen more high-level
language being brought to the embedded
devices so that you can program them in
the same way and you can provide one
platform right and in this context let's
ask the question and better than IOT of
why osgi I mean I would really have to
start with a question why Java but this
is Java one so I can skip this you all
believe in it right why osgi well Java
has a bunch of interesting properties
and we heard some of that in the keynote
yesterday right it has this promise of
write once run everywhere we have
relatively good coverage of devices
where we can run our code and therefore
a lot of leverage from existing code we
have this property of being dynamic
linking linkable and adaptable at
runtime right so if you compare it to
the old-school languages for embedded
computing or embedded systems that's a
lot more flexibility and thinking again
of this you know platform being open
being extensible trying to get people to
contribute their own apps to your
platform that's what you really need
right because you're no longer shipping
a fixed function device that comes with
a firmware revision and we'll just run
on the same revision forever now Java is
a good candidate for enabling these kind
of applications and people have realized
this very early in fact osgi is already
pre old in those days people thought
about you know the TV set-top box as
being the next big thing interesting to
see coming back right now right and
these devices have a relatively hard
problem because people operate them but
they don't own them because it's owned
by a provider and the provider doesn't
necessarily want you to tamper with it
and install your own stuff but they want
to be able to stream updates and they
want to be able to stream updates over
the channel that this is connected to
without disrupting the rest of the
system right so these devices are
inherently long-running because it's
it's not something that you
to reboot every wednesday or so or
thursday remember depending on which
operating system you use it's something
that is ambient and it's just running
right osgi was really designed for for
that use case with that use case in mind
how can you provide a platform on top of
Java that is able to support
over-the-air updates right software
maintenance component ization of
application so that if you update one
part of it you do not disrupt everything
and on the other hand where you can mix
and match different components and build
more complex systems out of them right
now in this sense osgi solves the update
program right because you have a more
intelligent platform and more metadata
available it also solves another problem
which I usually call the mystical
classpath right whoever has built a
significant application in Java knows
how many things you have to put into the
class path in terms of libraries to
enable your applications now the
classpath is a relatively simple content
concept is a linear list of jars right
now depending on which order you put the
jars in your shed during the jars that
are coming afterwards right so you have
a relatively complex behavior plus by
really just looking at the classpath you
don't know which one of these jars files
contributes let's say a specific package
to your system which makes maintenance
and update relatively hard now if we
look into what osgi provides you with as
an alternative and and here I assume
that not everybody is intimately
familiar with osgi osgi is all built
around this concept of modules right
modules being called bundles a system is
composed out of modules out of
individual components that in the ideal
case work completely in isolation right
so logically we have modules physically
we have jar files with additional
metadata it's not hard to build bundles
in other words and this additional
metadata where it really is is that it
declares the dependencies right by
default you do not share between modules
where you want to share you have to
declare and that's a powerful
because now the runtime system which
annoys GI notation we call the framework
is aware of dependencies and it can tell
you what happens if you're updating a
specific version of a bundle right
because it knows which other bundles
depend on it plus you can do lifecycle
management of individual components or
and you see what kind of impact this has
now the first core concept no se is
really package dependencies packages are
the unit of modularity at least
logically in Java that we have right we
grew our classes into packages ohg is
picked this up and you can selectively
mark packages as exports and thereby
contributing to the rest of the system
and other bundles can import them and
thereby your back to plain old java
where you know the dynamic linker will
pick it up and it's becoming part of
your other module now this is good
because it limits sharing and it makes
sharing explicit oh it's still a tightly
coupled way of composing your system
right because ultimately once the linker
has done its job it's linked at the
level of the curve the class owner and
you cannot easily rip it apart anymore
in addition or those dependencies are
all mandatory by nature right because
the linker will require a certain class
in a certain package to be there
otherwise it will just not be able to
resolve now the second concept that is
really key to OS GIS services and
services completely implement the idea
of loose coupling right a service in the
end is just a plain old java class that
you expose to the system a nice
interface right there is a central
service registry where you say this
service is now available under this
interface and our other components can
look it up that means first of all they
are no longer tied to the implementation
just to the interface right the level of
dependency through the loose coupling is
severely limited and second whenever
there's the service not available it's
not a linker error it's just so to say a
runtime error so any application is free
to do whatever it can in the absence of
a specific service and you can build
systems that are extensible in their
behavior depending on which
service is present or no now the thing
is in osgi this is all centered around
the idea of components services having a
life cycle because your system is very
long running you might install updates
you might remove previously installed
bundles you might have services that
disappear so in addition to this
infrastructure osgi provides your
software with a way to listen to these
lifecycle events and rather than you
know change being the exception change
is part of the way how you design your
osgi system and reacting to change is
actually very crucial to burning robust
applications because it's no longer a vm
that is static and will never change
once you have started all right um one
of the very early applications that we
used my previous osgi implementation on
was the back platform that was around
let me see 2006 right is it 60 k 8 2008
and that was developed by a start-up in
New York which basically combined the
idea of you know hot been modularity
with the idea of software modularity
right this device consisted of this base
platform where you could plug in
different hardware modules and whenever
you would plug in such a module it would
trigger the appearance of an osgi
service in the underlying infrastructure
and then this new capability became
available to the platform and when you
removed it well it would go right you
could write applications that had
adaptive behavior depending on whether
there is a screen or not we have gps we
have a ser o meter a couple of different
sensors and actors and whenever there is
a situation where an application really
cannot run without a service you could
send it to sleep and basically wait for
the modules being plugged in there was a
really nice design of an embedded system
and it ran my old concierge osgi
implementation out of the box um in
order to provide this behavior now when
I started with
church which was really um 2006 if I
remember correctly my original question
was you know there is this osgi system
and it seems very useful for embedded
devices but embedded devices were not as
powerful as they are today so how low
can i push the overhead of osgi or in
other words what's the minimum
implementation size and resource
consumption that I need in order to
implement osgi and I came up with an
implementation of osgi that was
implementing the r3 center it was just a
little bit about I think 8086 kilobytes
right you were install it on top of your
Java Virtual Machine and now you had a
running or CI system or it would run on
all the devices that were popular in
those days and pretty much on all the
VMS that were available including some
of the really broken ones like personal
java there was still in use in those
days and in addition to the popular
devices i also modeled a couple of
devices that were cheap and available
and brought my system up on it now um
that was a long time ago right why are
we doing it again well first of all we
believe that osgi is still very
important for embedded systems and
especially for applications around
Internet of Things because we see this
as an N a blur of more richer and more
interactive platforms now the problem is
that we also see this trend of you know
conversion between the server and the
client code the r3 implementation was
basically fine as long as you accepted
that clients would be coated in a
different style we don't think this is
true anymore so we try to pour it pretty
much the state of the art not quite r6
has been released but it's just a minor
update over our 50 pretty much the state
of the art to embedded devices and once
again show the world how small of an
osgi implementation we could build and
which things we could enable um we're
aiming at full hour 5 compatibility on
our five core or trying to keep it small
trying to keep it readable which is also
often an issue if the code is readable
then people can easier figure out how it
works
remain backwards compatible we're not
quite sure currently we are backwards
compatible to java 5 we could go back to
14 with a limited set of changes but
we're not sure if these days this is
still of any concern anymore and besides
that we're trying to be a sandbox for
innovation about around osgi because
ultimately having a small and lean
implementation also helps to prototype
new experimental features much faster
than it is on a very large and
established osgi framework all right now
let's talk a little bit about the
technical challenges in going from osgi
of the old world towards osgi of the new
one right if you look at this chart this
is just an attempt to visualize the
increase of complexity that we have seen
from our 32 our five we have seen a
couple of releases and you just see how
many classes just the core osgi
basically the chorus GI interfaces have
they've grown by a factor of three right
why did this happen well the first the
r3 implementation was still designed
with embedded and mobile systems as
their primary target the more we go to
the right-hand side we see osgi being
applied to much different problem
domains right with our cio for it became
the runtime of the Eclipse IDE so
introduced features like you know
versioning of bundles running multiple
versions in the same virtual machine
which if you're coming from a plane Java
world you can imagine that this is
relatively involved and requires a lot
of discipline in the system we have to
make sure that all the individual
bundles see a consistent class space and
not two versions at the same time right
with 420 SGI became the fundament of all
the app servers of all the j ee
observers oh and you can see this being
reflected by the amount of complexity
that we had to add because now the osgi
framework was no longer the only
authoritative piece in the system you
had an app server that came with its own
requirement and wanted to manipulate an
influence the behave
view of the framework so we had to add a
couple of hooks in order to enable such
a use case where the app server can have
the last word over the framework and for
instance implementing is like having
separate subsystems that appear to be in
isolation and in reality they are all
running on the same osgi framework in
the same app server now with our five
we've taken even a step more forward
because previously all of our resolving
or centered around basically just two
concepts we had packages package import
and export and kind of by accident we
introduced bundle dependencies so you
could require a bundle and therefore get
all the content of the bundle plus in
some interesting way also things that
the bundle itself imported with our five
we've taken a step forward and now allow
you to basically specify any sort of
dependency that you want in a framework
that can express generic requirements
and capabilities now this is
particularly powerful if you think about
embedded systems because very often you
will see requirements being outside of
code right you can have a requirement to
a specific device being present to a
specific revision or firmware to
specific other events so with this
framework we added the possibility to
basically express that all now with all
this complexity and generality it became
relatively hard to optimize it for the
common case which is plain old bundles
right and with concierge with the work
that we've done on concierge we try to
you know embrace all these changes that
we've gone through and still provide an
implementation that runs very well on
the bedded devices all right so where
are we today armed followers GI Corps
are five compatibility we are basically
one out of four hundred and six Tests
away from it um so almost there I would
say the current footprint of our
implementation is 250 kilobytes that's a
lot more than the 86 unfortunately um
that's what storage yes yes that storage
um so
you know the the API itself contributes
quite a bit to the growth of the
footprint but we think that this is
still very reasonable we had this goal
of remaining readable or in other words
you know being an implementation that
people can read if they want to learn
our shower only works and we are
currently at nine classes 40-something
inner classes many of them would go away
with lambdas as we've all learned with
Java a trait but that's pretty much
where we are and backwards compatible
right now as I said to Java five with
the option of you know no that's it all
this is our implementation so this is
the implementation classes you have to
add the the osgi interfaces yes yep but
that was the same as we counted for
three so yeah all right now hopefully
you agree that this looks good the
question is right how does it perform
and that's what I would like to talk
about for the next minute now we have
two main platforms right now that we do
performance evaluation of the first one
is the device that I've been playing on
with for quite a while it's a bigger
board revision 5 um you can read the
specs yourself because I had it for a
while I was still running java 17 or
Java 7 SE embedded vm on it and recently
i built my own compact one profile
because i wanted to see the impact of
java 8 on such a device on the
right-hand side we have a relatively
standard Raspberry Pi with the jse
framework implementation that you get
from debian when you install the image
hardware-wise the specs are not very far
away the bigger bonus a more powerful
CPU the Raspberry Pi nominally has more
memory but it's shared with the GPU so I
think those are both relatively
representative devices for this class
of embedded systems now what is what are
the data points that we are comparing
against well first and foremost it's of
course eclipse equinox right it's the
most recent version that you would get
if you download Luna it has 1.4 megabyte
of footprint file footprint Apache felix
is Apaches implementation of the OSGi
framework again the current version 527
kilobytes we have kenapa fish this is an
implementation that traditionally has
been developed for embedded systems it's
coming in two different flavors a
regular framework and a compact
framework just for a sanity check I
tested both of them in my first
experiment and the performance is
identical so I assume it's actually the
same framework it's just that the 607
kilobyte version ships additional always
optional osgi API with it but it's the
same system underneath oh and finally
our concierge which you know the version
number is of course just a snapshot and
get because it's still work in progress
all right the first thing that you might
be interested in if you're especially if
you have to debug on embedded devices is
the start of time right the startup time
contributes quite a bit to the user
experience and in this experiment we
just measured a plain bundle that does
nothing but printing a specific message
to the screen which we can easily
capture by a prescrip versus the vm
starting up and printing hello world
right so the black one is kind of the
overhead that you need any way to start
your java virtual machine oh and then
the different bars is pretty much how
long does it take before the first
bundle execute the first instruction in
its bundle activated stuff right oh and
as you can see concierge is performing
pretty well in this regard we see the
startup time being somewhere between two
seconds on the BeagleBone and three
points something seconds on the
Raspberry Pi we also see that you know
part of the frustration that people
experience with equinox is actually
the long startup time which is in the
order of almost 20 seconds but yes we've
optimized our system for embedded
systems right and equinix does a lot of
initialization of data structures that
they believe will pay off later we don't
necessarily do that our framework is
much more lazy in the way how it
initializes itself all right on the next
component that we wanted to performance
test it's a service registry right
because the best osgi applications are
actually those that use the most
services and use loose coupling so in
order to stress test the system we
instantiate 10,000 services or just I
think implementing nothing just
java.lang.object and then as part of the
feature that you will frequently use you
can attach key value pairs to the
service so that you can distinguish
different service instances or and in
the lookup you can specify elder filters
or to match specific services so out of
these 10,000 services each of them gets
a service property or with a value in
the range of bytes so we deliberately
you want to create collisions and lots
of duplicates oh and then on this record
of 10,000 services we are making
thousand service lookups again in the
range of bites all of that driven by a
random generator or and finally we
unregister all the services that we've
previously registered and to us that's
like you know how much is the cost of a
service and how much does the service
registry itself contribute to runtime
behavior now if you look at this slide
the first one the registration are there
is not the tremendous difference
concierge performs best that's the good
news but maybe the other performance
values are still acceptable where we are
coming to the core of the service
registry which is the lookup right we
see a pretty dramatic difference oh and
I was myself surprised because I never
considered Felix to be a particularly
slow implementation but we see that
actually the performance of felix in
terms of service registry under the
stress test condition
it's so bad that we have to zoom in and
leave Felix out of the picture to
appreciate the differences of the other
frameworks and once again we see that
concierge performs best on all the three
different devices and actually another
interesting observation in the previous
chart Java aid actually perform better
than Java 7 for some reason and service
registry lookups 7 performs better than
eight on the BB boom and that might be
just some way of optimization that they
have tuned and in this case forward all
right um the final part of the service
registry stress test is getting rid of
all the services again the behavior of
felix is pretty surprising several I
would say more than order of magnitude
slower than the rest of the
implementations if we zoom in once again
concierge performs best and among those
implementations Klopp efficient is the
one that is closest to our behavior but
we reach our goal and hopefully provide
you with the service registry
performance that that does not get into
the way of a smooth application
experience now services is one part of
an osgi frameworks behavior the other
one is definitely resolving right
getting all the bundles in place the
framework figuring out which ones are
getting resolved against which ones we
generated a similar test for stress
testing the resolver generating a
thousand bundles basically
programmatically from scratch and then
flipping a number of coins right these
thousand bundles can either import or
export up to five packages we give them
a choice of 50 package names and they
generate random version random versions
or version ranges for import so we hope
that we coming up with a complex problem
for the resolver which is halfway
representative for a large application I
would say right we install all these
thousand bundles and that's the first
measurement that we make how much time
does it actually take to install these
bundles and then how much time does
through
is always spent on finding out how to
resolve these bundles this benchmark
unfortunately when we executed on the
small devices turned out to be extremely
volatile and unlike the previous
experiment where you know the precise
numeric value of the key does not matter
too much and you know over a reasonable
random number generator this is balanced
out by the large number here the
topology matters a lot so we ended up
using that for generating topologies
which we then materialize and just use
the same topology across all the devices
to have comparable numbers and I'm
presenting you an average over them in
the first phase this is the experiment
where we install all these bundles and
we see again concierge provides the best
performance the other implementations
are closely enough to be useful and to
my surprise again felix is relatively
slow and now finally when we start to
resolve this is the one and only slide
here where you will see concierge
currently performing worse than another
implementation we are not yet as fast as
equinox in resolving such a large number
of bundles part of this is because this
subsystem hasn't been tuned to the full
extent another part of is you know
dealing with large collections of
bundles is really the domain where
equinox has been designed for right they
are powering the Eclipse IDE they are
powering app servers so it's not
surprising that they have the best
performance among the framers still we
have reasons to believe that we can
match their performance on embedded
devices and that is the next thing that
we will be working in terms of
performance tuning and now i give to tip
for some demos
well for the tests we use the device
that's everybody clearly see is
classified as somebody device like the
Raspberry Pi and the bigger bone but
actually we all have like embedded
devices in our pocket or on our nose dig
the glasses smartwatches at all tiny
devices there are battery-powered they
have to make sure they not dissipate too
much heat that you don't burn so they
all have relatively small resources and
they all are embedded device so also on
these devices we wanted to you have
considered running now you could ask
yourself why why the hell would you have
osgi on your android device if i want to
write an application for android i just
use use the Google API and I'm I'll all
all done but the thing the thing is that
nowadays and mobile application is not
just running on on one device people
have a lot of devices you also want to
have the cloud and in somehow so this
puts a lot of problems for application
developers to create such such
applications for example if you look at
an application like this where I have my
glasses and I won't have some some UI
component on the glass I have my
smartphone maybe I want to use a sensor
from the smartphone maybe execute some
application logic there and I have the
cloud for for storing all kinds of stuff
how can I make an application like that
nowadays and actually you can do it so
it's not a problem to create this
application but it involves a lot of
work for the application developer
because first it has to make sure that
it can discover all the faxes it can
wire them up it has to choose which
protocol it will it will use to make
them communicate we'll use the risk
service at the cloud how will you
connect the things what will happen when
the when the connectivity breaks you
have to handle all this stuff also your
deployment is fixed you have to decide
where am I am I going to run which code
and you have to develop it as such you
have no no freedom anymore so all these
problems can be relatively easily solved
when you use or joy and all all these
facilities because if you think about
just the application like I let you you
medically think of separate components
that the application is running and it
has to run on all these devices so an
easy solution is just say okay I'm going
to use GI as the component runtime I
just run it on each of the devices and
then I can deploy my components wherever
I want but of course or joyous first
initiate as something on a single device
as well so it's not towards distributed
systems so you need something else that
that will make the distribution happen
that will wire all the components
together and that's basically what I did
during my PhD research and i created a
middle way framework that does exactly
that it will go look around for other
devices in your network connect them
together watch how the component
dependencies are and try to wire them
together and make sure that all the
components can talk to each other even
though they are deployed on different
machines so for the application it seems
like you have one big orgy Irene time
and all the components can see each
other but actually they are running
distribute Lee on the the different
devices so that's right where I created
angels framework and the basic features
are that it will discover all the
services and provide binding that all
the components can communicate it also
provides a implementation of the remote
services min from the OSD our
specification that provides for first
remote service calls and it allows for
runtime redeployment or deployment and
for service monitoring and of course
these are all nice words but they only
get hard with a demo so i will go over
there and hopefully it works
so can everybody hear me so the
application i'm going to show you is
like a kind of tourists application so
what tourists do now is they take a lot
of still pictures and then they come
home and they browse the pictures but
that's not really something immersive
you don't get the feeling that you're
there so the application i create you
call it TARDIS where the does is it
records the video and instead of just
recording the video frames that will
also record the orientation and the
location of the device so if you're back
home and you look around then you can
collect the frame that matches your
orientation should so you can actually
look around the video in the in the way
that you recorded it sounds really
difficult to understand but it's much
easier if I just show it so I have here
a smart glasses device which is actually
running concierge and I will show you
what it sees so I'm taking you to get my
university town and you can look around
and if I go through and turn around you
can see the frame updates and you can
actually look around the environment
then it seems a bit laggy but that's
because of it takes screenshots and send
them over by USB but you can look around
and you can look up for example here you
can see the costs over the Duke of
launders used to live in the Middle Ages
and so on now of course you want to
select the location where you want to
see it and it's not quite handy to do
this only gloss you cannot memorize all
the GPS locations or addresses that you
visit it and then say ok glass take me
to that location but but fortunately
most users also have a smartphone or
tablet like I have here and there you
can actually easily show the map so this
is what you see on
on the tablet so there you can see a map
with all your locations and if you want
to go to another location just click on
one and then it will update so now now
one of the squares in games where you
can see the theater and the cathedral
over there can be up to the tower and so
on so we can actually look around as if
you were there again now of course how
does this work internet internally under
the hood with a framework therefore I've
created this demo you I move this one up
so here you can actually see the
different devices and all the components
that are all running so this device here
is of the glass device you can see I
have the different components deployed
there I have a viewer which is basically
the UI I have the rotation tracker which
which will interface with the rotation
sensor and get the rotation information
and i have the viewfinder and this
component will basically search through
your catalog of frames and search for
the best matching frame for your
orientation then here i have the the
tablets which is running the map viewer
so that's the UI and the location
tracker which is just taking inputs from
them from the UI to give a date for a
given location and then immerse fewer
will fetch the location from there and
then on my laptop i have storage
components and i also have a base
apparently a map viewer deployed there
but what you can see yet you can see all
the devices in the framework you can
also see how they communicate so this is
basically what you get for free for by
using osgi you can the image you to see
how everything is wired together you can
see how the components are interacting
and what are the dependencies now I
mentioned that you also can can monitor
everything so that's on the left you can
see the details you so if I i'm going to
minimize or one this one thing so if you
if you click on one of the notes you can
you can see the information on that note
you can see how the cpu is used and so
on you can also click on the components
to see which are the services and also
you can see how long it takes for
example together to get the rotation it
takes about half a millisecond to find
one of the views it takes about 2.5
milliseconds so you can get an idea of
how the application is running you can
get an idea of performance and you can
actually have this from the API so you
can easily create some intelligent
component that just reads out all this
military information and say hey this
bundle takes too long to to do something
maybe something is wrong maybe I should
take action and so on some other thing
that you can do is of course a trend
time add or remove bundles for example
if you want to to show your tourist
thing to your friends it's very unlikely
that you will use the view right I just
showed you so you can it's hard to see
from here make it I better mirror my
display
okay so for example i can say i want the
inverse europe it for the web i deploy
it on on my deploy it on my laptop and
then you can see it's deployed over here
and it also automatically gets wired to
all the components and now i can just go
to the side and now you can get a better
view of what you actually see on the
glasses so you can still look around you
can look up and go down so you can
actually by adding components you can
for example if you don't have a glass
device you can easily deploy it on your
tablet on on on on any device that's
there so you can actually change the
deployment of your application depending
on the devices that are available
without having to change dexter actual
application code everything stays the
same is just about deployment another
thing you can do is for example if you
have here the viewfinder it takes about
2.5 milliseconds on this gloss to search
for the best frame and of course this
time will increase if as if you if you
have more frames in your catalog and if
you say okay i have this laptop right
here maybe i can better do it there you
can just move the component around and
it will be migrated to the laptop and
now if I look now you can see it's only
point 4 milliseconds to fetch your frame
so you can also upload computation from
any of your devices to the other devices
in order to to save energy or to make it
faster so this basically shows you what
you can do with concierge how you can
create nice applications
rid it and and how you can wire stuff
together pretty easily also for
distributed systems so what's next then
of course I also already showed you how
you can connect your end-user devices
like your glass and your smartphone also
show chart you can connect it to the
cloud which was in this demo my laptop
is if you just brewed up a vm in the
cloud you can essentially use that ones
as well but of course the next thing is
how can you add in your IOT devices and
of course then you you will have to make
sure that you can connect to these
devices which is your gateway and have
the Gateway bring up all the services to
your embedded devices and then you can
as with the application just import and
use these services from any of your
devices
so to do this we have some other IOT
projects from eclipse which will help us
do that we have QR which provides some
implementations towards the most common
services that you need to connect your
gateway to your sensors and actually
just last week we can you came to the
point that we can actually deploy and
run cura on top of concierge which is
really great we also have the Eclipse
smart home project which is basically a
more higher level framework that will
discover all your devices and then let
you create you eyes and rule-based
systems to to interact with the devices
like you can you can insert rules like
if the user presses this button then
that happens or if the temperature is
below this threshold and stuff happens
and then you also have the protocol
stacks that are implemented in Eclipse
IOT for example pay ho and mosquito
which provides and implementations you
have also californium which provides our
protocol implementations and they are
actually many more I guess about 16 or
17 projects that are hosted by Eclipse
iut to actually support all these kinds
of services all right yes and actually
we we also brought up maquette which is
the java implementation and we can write
it here on the BeagleBone or on the
Raspberry Pi on top of concierge we have
worked with spot home smart home still
has a bit of work it support to
concierge and actually most of this to
be fair is not necessary that concierge
wouldn't you know fulfill any osgi a
requirement is more that some
applications or bundles out there
explicitly wire against awk osgi or or
eclipse osgi things and mix a little bit
osgi and equinox behavior and as part of
porting smart home
a lot of the effort is cleaning up some
of the libraries to be running on any
osgi framework as opposed to only
equinox all right um so we're coming to
the end of the application of the
presentation are we have a home page
although it's really not very rich in
content because we are still an
incubation project or still have a look
at the homepage or clone our code from
the git repository it builds with end so
it's fast quick and easy and we think we
have hopefully convinced you that our
concierge is an optimized implementation
that is great for the internal things
and that you should check it out as well
i'll be at the IBM booth tomorrow from
12 to 130 and i have my beagle bone and
the raspberry pi with me so you can come
and play a little bit with it if you
like and other than this you can also
see what else we are offering here at
javaone including some of the other
talks here and with that I would like to
thank you and we are happy to take your
questions yes I don't think so I hope
that that's a very good question i mean
right now we are infrastructure right if
all the existing IOT projects in Eclipse
run on top of us that's already big step
maybe people will pick it up and
actually provide commercial support for
it right but it's it's not our immediate
next step to do so I would say yes
no so this is part of the middle Eric on
top that I great which was which is
called a Jose it's currently not open
source yet but I have plans to open it
up and it's supposed to be done by the
end of October so you're interested in
that you can check that out but
concierge is actually just the core or
GI specification limitation we we have
done some extensive work in the past
actually both of us with always share
remote services or our own
implementation our osgi that we created
even before remote services existed so
there is a way a standard way in osgi to
turn specific classes of osgi services
into distributed setups and there is a
component in it which basically does
service discovery I've used J SLP in my
own SLP implementation for most of my
adenosine small devices in the past
nowadays you can also plug in your
zookeeper or whatever you like the API
SAR there there are implementations out
there so this is a very common case that
you want to move things around and if
you design your osgi services with a
little bit of care meaning that you
don't accidentally leaked a transitive
Hall of serialization hell through an
API right then you can turn them into
distributed systems relatively easily
sure absolutely we are happy to give you
pointers yes we've both done a lot of
work in this area actually yeah yes yeah
you can you can definitely do so but to
do that what you basically have to do is
to expose everything which is which is
an androids you have to import those
packages into your giant time and define
them as system system packages which
allows you to create a service in your
retirement framework that then has
access to all the packages from androids
basically the same way that you have
access to JavaScript not string for
example so these packages are just
considered part of the system and then
you can easily create anything you like
like you do in regular Android
applications yeah so the osgi standard
behavior is that everything that doesn't
start with java dot is considered
private api and does not get exposed but
there's a very easy and convenient way
to set a system property and basically
teach the framework what else it can
safely delegate to the class loader that
had created the framework
stuff so if i was driving on as you can
from this level
received
I at the moment II the only way to do so
is actually to to make sure that
everything of Android is considered the
system package and is important energy I
that way and then you can just use it in
your bundle as if you want if you would
do it in a regular Android application
there's one thing that is a bit tricky
is that for example your activity these
things have to be declared in your
Android manifest and they are rooted up
by by Android itself so the way I have
implemented for example my applications
that i have an activity that is product
within the activity when you've
initialize it then you start your giant
time i support of your application your
Android application and you can do all
your orange our stuff within your own
jivin time and you can actually
communicate with your native androids
parts so to speak I'm using the
framework runtime packages that you
define there so there there is a way to
do so it's a bit hacky I know but yeah
the security state and yes more like a
restriction bye-bye Android itself
because it's by making you declare like
your activities and so on up front there
is no way through for example creates an
orgy I bundle that contains an activity
and bring it online because you're not
allowed to create an activity that's not
declared in your manifest so it's
actually breaks the modularity there
yeah I think we have to say that we have
taken care and engineered a couple of
solutions that enable running concierge
on Android but we have not yet absorbed
all the complexity of you know coding
real applications in it and in some
points there is just an impedance
mismatch between androids lifecycle
management always child lifecycle
management
any more questions all right then thank
you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>