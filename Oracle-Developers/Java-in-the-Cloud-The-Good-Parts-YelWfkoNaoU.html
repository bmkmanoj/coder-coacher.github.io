<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java in the Cloud: The Good Parts | Coder Coacher - Coaching Coders</title><meta content="Java in the Cloud: The Good Parts - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java in the Cloud: The Good Parts</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YelWfkoNaoU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you everybody for coming this is
the session called job in the cloud the
good parts and hopefully you will not be
disappointed we have a few I think
interesting things to share we being the
depiction of the door who's sitting here
yeah Greg Wilkins and myself Alexei and
we're here too because we believe that
Java in the cloud specifically can be
fun of course it can be productive and
can be rock solid all at once so
hopefully you'll agree with that by the
time we're done so just to give you an
idea of who we are at least little bit
can I our son veterans we worked at San
micro sims systems for what over a
decade I guess so so Java 09 we both
joined sun microsystems because we truly
believe then write once run anywhere
which to a great extent has been true
and has been a great value but we'll see
that you know things are changing a
little bit and there are different ways
to approach the problems that Java set
out to to tackle we still love Java we
moved on to another company which
happens to be Google Ludovic works on
App Engine in the SDK team he actually
leads that sdk team and i'm in the
developer relations group which focuses
on a lot of developer products and Greg
Wilkins who are you well I've been I'm
also working on Java since not at nine
jetty is the 8gb server in a silver
container that i started in december 95
so it's coming up to its 20th birthday
so I solvent got the program right
working on the same program over and
over and the Google guys have currently
asked me to be part of the talk because
Google App Engine has used GD for its
java container for some time right and I
think we can close that slide and saying
that we all believe in the cloud i think
that's that's where a lot of the future
is going and I'm certainly absolutely
passionate about it and Ludo you
probably should be too if if that's your
day job right great um so let's move on
oh and we used to work on things
and I like glassfish Java EE this is
really the things we focused on tulane
but not only and and and just to get
this out of the way we absolutely still
love Java I mean we spent a number of
years dedicated those years of our
professional lives to Java we don't
regret any of it we think Java might
need to evolve a little bit to move to
the cloud and to be again rock solid and
productive and fun in the cloud but you
know I think we're on the right way and
certainly we've been doing some
interesting stuff with it and we of
course love the cloud it's not that we
love what's you know new and fun and and
just because it's new it's not because
we love data centers and the massive
numbers and the pretty pictures of all
those racks you know we we like new
stuff we like cool things I think what
the reason the important reason why we
actually love the cloud is because it
allows you to iterate very fast you know
the cost to entry to try something to
get going to it is very very low and you
want to fail fast you will fail along
the way to what you're trying to achieve
and you might as well fail fast and
learn from those failures and the cloud
is an absolute great way to to do that
and to experience with with ideas it's
all about business agility now of course
we talk about cloud and a cloud is
probably not something you need to call
a sales rep to start using right it's
something that's should be provision and
and there right away otherwise it
doesn't deliver on that business agility
promise should be paying for what you
use you shouldn't be paying like a
subscription and all-you-can-eat you
really want to be paying for what you
use an optimized for that so um let's
see and you probably don't want to spend
time managing infrastructure it's not
that it's not fun some people love it
some people have a job doing that and
enjoy it very much but I have to say
that clustering in general and that's a
very broad term
is hard and we have people dedicated to
do that certainly in our our teams
security is equally hard and you hear
about that every day it takes it takes
really people to focus on that full time
and teams of people to focus on that and
all the time you have focusing on that
you're not focusing on delivering the
value and the applications that you as
developers are are trying to deliver and
and another thing is that you know
technology and you'll be seeing some
techniques and some api's and
technologies here they're great but it's
not enough you know the technology
doesn't doesn't do everything by itself
you need to have it run on something
right cloud is not just baby aware its
its actual Hardware it runs on so you
need to to do those investments and make
sure you have the greatest possible
utilization of that investment and it's
also about the people so at Google we
have this type of people that are called
sres site reliability engineers their
sole job is to make sure the thing runs
they know the system very well they're
just the opposite of a guy that knows
only how to start hit a restart button
but they're absolutely key so its of
course the technology it's the
investment you make and in the
underlying hardware and not just
hardware but you mean not just serviced
but network also and of course the
people that manage all this and you know
that carry the pager so you don't have
to do that so Java in the cloud um I
think also it's fair to say that if it's
you know we're not really talking about
a real cloud specifically a public cloud
if it doesn't support java one way or
another the reality today is that every
major Java vendor supports Java again
one way or another we can argue on what
support java means at Google everything
and I'm not talking about the cloud
services that we offer but all the
services that we offer to end-users
everything at Google is a cloud
microservice if you will and a good
number of those micro
services are written in Java so we
believe we know a thing or two on how to
run those micro services at scale at
Google scale and and and that we have a
few things that we can share along the
way at the same time server side java
microservices written in java isn't
exactly java ee per se google doesn't
use jboss glassfish or weblogic but that
shouldn't come as a surprise to you so
speaking of Java EE and again we spent a
number of years working on that it's
pretty mature it's still improving I
personally like very much you know all
the improvements that have happened with
CDI and and you know jax-rs and the two
together and all of that and and if we
even look back to j2ee this whole thing
started as a notion of a container
offering services and preventing you
from playing with underlying notions
such as file systems or threading and
providing you with higher levels of
abstraction so that is that is very good
that is a very good start especially
when you talk about moving things in the
cloud where obviously you don't want to
give developers access to file system it
makes no sense but at the same time java
ee hasn't really focused on solving
cloud specific problems there's been
discussions around multi-tenancy which i
think is not really dad useful but that
that would be a whole separate
discussion and and there are a number of
things that that might be missing also
um when we talk about java ee we talk
about a bag of API is there a lot of
them they play well together but some of
them don't play well in the cloud if you
talk about say web sockets WebSockets is
not HTTP and for that reason it may not
really work well in the cloud where
instances you know microservices come
and go for different reasons for you
know better utilization reasons because
we need to adapt the low to people
hitting
your service there might be some that
are not the right abstraction level I'll
get to you know API such as GMS versus
having a message queuing service you
probably would rather have a service
than have to configure and start an
existing service such as a JMS broker
for example now java ee defined the web
profile this was back in java ee 6 and
that's great we might need to take that
web profile and make it a fully cloud
enable and friendly environment or
define maybe a cloud profile that would
be something interesting discussing i
believe turns out if you've used Google
App Engine you know that there are only
a number of AP is that you're allowed to
use from the JDK there are some mostly
for security reasons some others because
it just doesn't make any sense that you
cannot use and I'd argue that this might
be from back 2006 when app engine
started with Java maybe one of the first
premise of something that could be
considered as a cloud profile now let me
share with you a few things that we
believe that are good practices when it
comes to architectures to you the Java
developers so at Google scale you know
in our data centers hardware failures
are not really problems they're not
anomalies we have hundreds of failures
every day and we just cope with that at
any given point in time there's a
percentage small we hope of hard drives
or network switches that are down
because at that point you know the mean
time between failure of those hardware
is such that you can't you know do
anything about it so the reliability of
our data centers really comes from the
software we put on top of that so it's
things like distributed data stores like
distributed file systems all of those
things that that make the whole thing
reliable and I think in the
that you should really consider that to
be an inspiration for your architectures
again as I said instances of your
microservices you know nodes of your
cluster if I was to use another term
just can come and go at any time just
consider that to be the case though the
requests you send to a server or to an
instance may not go to that same
instance the next time around in most
cases it will we're trying to optimize
for that but not always so that's really
important to consider so some people
will tell you you should be fully
stateless in the way you build your
applications there is really you know
but state needs to live somewhere so I'd
like to argue that you need a dedicated
here for that state you probably don't
want to have your state living in your
application tier you want that you're
dedicated to doing that and and that is
something like you know a database maybe
an in-memory database maybe a cache in
front of that to optimize for for
retrieving data I think that's very key
to be able to deploy applications start
up new instances without losing any data
or you know creating any disruption in
the system itself well in fact if if
you're in you know a java ee developer
you probably know of similar solutions
and products so in fact something like
even weblogic and coherence would
actually implement that part that
pattern and that's a really important
pattern in the cloud where you don't
want you know deploying an app or
shutting it down to have any impact on
session availability the other thing i'd
like to share with you is that you
probably would want to focus on services
and and services are something that you
asked for and that you're given
instantly as a running instance and that
is fully configured we're not talking
about binding jndi to something we're
talking about give me a persistent
service happens to be a data store in
this sample here okay I got it start
writing to it let's say and of course
the data
mine is not accessible to other people
deploying apps to App Engine all of that
is baked in but you know all of that is
hidden for you there's no reason for for
you to configure anything so try to look
for those services that are offered here
for you so of course you know a
persistent service is one of them a data
store in this case of NoSQL datastore
but a cashing service like memcache
available as a service not as you know
an instance and servers you need to
configure but really has a service a
mail service there are you know a
message queuing service so think
services that are really really easy to
start using because you just grab them
and you know it in this case this is a a
factory could be you know injected but
you know it should be up and running and
and usable right away injection so how
many people here use so spring nowadays
is a lot of things to a lot of different
people oh how many people use spring for
the injection part a lot of people and
spring came out you know a while back
you know it's been more than 10 years it
popularized inversion of control and it
initially did so with externalized
configuration in the format xml and had
a runtime dependency management system
and it solved a lot of problems that
allowed for better testing and mocking
and plugging in different
implementations and that's all great but
you'll see that we have a few issues
with that in the cloud how many people
use juice or know of juice let's let's
let's put this way so juice is the
reference employment a shin for j sr 3
30 which CD i built upon and and that is
the at inject annotation mostly this is
very nice in the sense that it's very
lightweight in the way does things it
does nothing but dependency injection
and you're not dragging along any you
know large library and in the cloud bit
like in the mobile world it kind of
matters you know the number of
luggages you carry along with you in the
form of of libraries where again talking
about density that's that's what we want
to achieve is the highest possible
density so the price that you pay for
the services is as low as possible again
because you're being charged for what
you actually use and juice you know
provided this really lightweight way of
doing things now how do people have
heard of dagger a few good so dagger is
I was created by some of the juice
experts ex-googler most of them work at
square it's a very interesting project
Google is still contributing to it turns
out there's actually a dagger to version
coming out real soon now and we think
that's very usable in the cloud not that
this was what it was built for it was
mostly built for mobile applications but
it provides a full you know validation
of the dependency graph at compile time
so you don't waste any precious time
when you start your application because
again startup time matters a whole lot
in a world where things can come and go
and need to start and react and be
extremely snappy in terms of reacting to
to demand so speaking of startup time
I'll now hand it over to Greg and he'll
tell you more about what we've been
doing with and what he's been doing in
collaboration with the App Engine team
to get those numbers really really as
low as possible startup time so I'm
Google's been using jetty in App Engine
since 2008 they didn't involve the jetty
team at that stage and why they picked
jetty but I can basically have been able
to reverse engineer the reasons and of
course jetties very good small footprint
which is great in the cloud jetty scales
really well to lots of requests but I
think the key thing that the reason that
Google picked jetty is because of its
modularity it's able to be customized
away from the Java EE norm so they were
able to pull out our session manager
extend it and plug it back as a session
manager tied into their cashing services
and they're persistent services
they were able to take out our HTTP
layer and plug it back in tied to the
Google Google secret source about how
they do it HTTP internally and so it's
that flexibility of modularity of jetty
that was really good in the Google App
Engine environment per se now Google App
Engine is not going away it's going to
obviously increase to have a few more
Java EE services in there but with the
managed VMs of the compute engine it's
being opened up a lot more so that you
can start using a spectrum of everything
from a completely locked down
environment like Google App Engine all
the way to basically an open door
instance where you can put pretty much
anything you like and there'll be
stopped along in between and so GD is
going to be a really good platform that
integrates well with the Google services
and platforms and is supported by the
Google infrastructure but allows you to
change the way you do things so you
don't actually have to always do it
exactly the Java EE way because the Java
EE way may not be the best thing for the
cloud and oh yeah so Jenni's been
powering the google app engine for a
while and because I don't work for
Google I can abuse their old logo like
that so anyway so one of the examples of
where Java EE is not necessarily good
for the cloud is that it's had a very
developer focus in the last few years
and you know all these annotations and
drop in jars into your web in flip it's
really great to get yourself up and
going and develop stuff quickly but
there's a cost to all this you've got a
lot of things that a Java EE container
has to scan for and discover at
deployment time you've got to find your
annotated filters and sir I'm servlets
you've got to search for web dot XML
fragment thus one xml anymore and merge
them and check the orders of your lives
you have to find server container
initializers because every frameworks
got one of those nowadays and then it
will have a handles type annotation
which means that you have to then build
the entire inheritance tree to search
for the classes that it's interested in
in the other annotations that it's
interested in and you've got to go back
to you maybe good old JSP still being
used with its TLD descriptors and you've
got to go find those and build all those
up and you don't have to just look at
them in one place that these things can
live in lots of different places they
can live in the container classpath in
weapon classes or web in flip and so
there's a lot of work to be done to find
all this stuff and the issue is that it
just doesn't work very well in the cloud
that discovery that you do in the cloud
well it takes a lot of CPU a lot of time
and guess who's paying for it it's not
google with you guys and so you don't
really want to pay for that so there's
there's actually so there's three key
reasons why you don't want to do this
discovery in the cloud I mean there is
that wasted CPU cycle and if you
multiply that by the number of instances
at large setups have and the number of
restarts that can get done it's actually
quite a significant proportion of the
cloud time can be burnt just scanning
for stuff it also gives you latency
problems if you wish to fire up new
instances because you have a a spike in
in load coming at you or or even just
fire your first instance on demand if it
takes you 20 30 seconds to start your
instance up that either means it's
impossible to fire it up on demand or by
the time you fired up a new instance the
spikes long gone and you've overloaded
so if you don't have quick start you
actually have to start running more
instances in anticipation of the spike
that you might have rather than in to
the spike that you're currently having
and so again you're using more resources
in the cloud in anticipation of a spike
that might never come and then finally
the other really downside of discovery
is it's a bit of a security issue a lot
of jars are getting to your web apps
nowadays especially if you're using
maven and things with transitive
dependencies and you're looking outside
where been flibben it's well there's you
know eighty a hundred I think 500s my my
record I've seen odd number of jars that
are in there so not only do we have to
scan them is that we might find
something in there that's a little bit
of a surprise I mean hands up anyone
here who has audited all the jars in
their war file to make sure that there's
no unintended servlets in there
yeah so security constraints servlets
filters can all be deployed by helpful
other developers that work for a team
working for a team that's working for a
team that's working for a team that's
provided you a wonderful library that
you're using and so it's really not the
time that you've just deployed a
thousand instances of your application
to find out that oh well that serve that
come from so anyway I'm going to give a
demo of what we've done Google sponsored
us to do some extensions to jetty to
provide a quick start mechanism which
moves this discovery phase off the UM
cloud on to you your SDK or onto your
ear your own desktop so so one more show
is deploying a a web app and then deploy
it again with quick start so I'm
starting with a just a standard distro
of Gd here and I'm just going to make a
temporary directory and i'm going to i'm
in there now so i'm just going to I like
to sit down to do this java minus jar
jetty home i'll start jar and i need to
set up an instance add to start the i
know i'm going to be talking HTTP i know
i'm going to want to deploy a web app
oops if i can spill it helps it I that
web app users jst al and I want to be at
a quick start quick start so do all that
and I've now configured a jetty instance
in here I can now copy our test web
application which Ludo developed which
has 36 jars in it of spring and you know
all the normal sort of stuff and i'll
put that into web apps and now i can run
jetty so and three and a half seconds to
start up jetty which is pretty quick you
know as solar containers go and i think
that was like you know 20 seconds to go
from an empty directory to a configured
running jetty as well but that's a side
thing but I'm let three seconds three
and a half seconds is too long to do a
deployment on demand so a request comes
in
you don't really want the first response
to take three and a half seconds you
need it sub-second if you want to get on
demand so let's see how we turn this
into a quick start our weather in the
jetty distro duty home you know
executive director we have an example of
an xml file to turn that application war
oops into a quick start one I'll just
have a quick look inside that for you so
you can see what it's doing if you're
familiar with jetty we have X ml's that
yeah go against the war file and so it
just gives extra configuration you can't
do within a web dot XML so here it's
just saying here's the war here's the
classpath the key thing here is I've
instead of using our normal web app
context I've used a quick start web app
and so it's got the quick start
capability I've also said a parameter to
say I do know that this one has jsps in
it that have been precompiled and so
that's the secret sauce you need to make
it quick started so i'm going to quick
start it now or started again and i'll
put a bit of debug on because it'll show
you another feature later on klipsch
jetty quick start the level equals debug
so the first time I start this it's
going to be slow still because i had the
auto pre-configure in there so the first
time it has to do the pre configure so
it took a little bit longer 3.9 seconds
but if i stop that and now i started
again I don't need the debug anymore
I'll show you the results of that later
started again 800 milliseconds that's
pretty good sub one second but if we
actually look at here we got 300
milliseconds before we get our first log
message out so that's a lot of staying
the some boilerplate and jetty and so we
can actually go better than that because
I can do the start jar work up front as
well I can say most dry run and that
actually outputs the command line that
starts I would have generated so if you
put that into a environment variable get
that ahead of time and then run that
it gets down to 543 milliseconds so
that's starting the jetty opening up the
connector we're listening 8080 we've
gone through and configured that web
application we're ready for the first
request to half a second yeah you can do
that dynamically people aren't going to
notice a half a second on that first
request and then after that it's it's
going so how has this happened what
we've done is you know in our web app we
obviously have got a web that XML I'm
just on a word count on that you see the
normal web that XML for this
configurations got 119 lines in it and
out 5k of characters but we've gone
generated a special one called quick
start with dot XML so for this web
application after we've gone and
discovered all our configuration the
effective web done XML is actually 500
lines and 37k worth of characters so
there's a lot of stuff in there let's
have a look what that is actually I
think how less it is better so the
QuickStart web dot XML is all the
discovered configuration or our web
fragments all the container initializers
put into a standard web dot XML which is
metadata complete true but just normally
the Java EE chaining metadata complete
to true turns a few bits of discovery
off but doesn't turn all the discovery
off and we've had to augment it with
some extra bits in there which we put
into context parameters for all the
things that can't be represented in web
dat XML so here we have a context
parameter that has the ordered libs
because you have to work out what the
order the libs are and so these are all
the discovered libs that we had along
through here in the correct order so we
don't have to discover them again we
don't have to order them again and so
this is coming from web fragments that
before after and stuff like that then we
have a the context parameter which is
set with all the container initializes
we've discovered so we've done our own
little jaspera initializer to start up
JSP especially and that's a jetty
specific one but the next one here is
the the JV Jersey Civic container
initializer which is a standard one that
came in from the jersey jar and not only
have we discovered initializer with
stuffs found all the annotation
and the classes that it's interested in
inspecting at startup time so rather
than scanning all the jars here's the
list standing by this is what once still
scrolling still scrolling that's all the
work we've done ahead of time there we
go still scrolling and there's another
his spring spring didn't wasn't
interested in so much what else we've
got we've got our tlds an interesting
thing is these are the teal Dean's we
discovered and all of them application
doesn't even have its own tlds all of
these are tlds that are just baked into
jar files that are there just in case
you might need them so we discovered
there's quite a lot of them multi elddis
then not only that we've done all our
listeners and our servlets and because i
ran this with debug on we're actually
augmenting the led to xml with
information about where we found these
from so this is the security element you
say well whether this filter come from
Oh came from a descriptor and here's the
origin it's that web descriptor it came
from and so we can go all the way down
till we start seeing things like the
Berber where I am a servlet here's the
servlet coming from an annotation
finally and that's the annotation that
it came from so this is a good debugging
tool not only can we completely learn
what the configuration of our web app is
we can see where it came from and we can
inspect it and go are do I really need
this one and you know start turning
things off if we don't need them and and
again everything we can turn off gets
that footprint down and you multiply it
by your instances and you savor a lot of
dosh so that's that part of the demo
Ludo is now going to show that same demo
running in the cloud but just before I I
finish i'll just show you how we were
able with working with google are from
google sponsorship to improve jetty this
is a couple of the other containers are
studying that same web app glassfish for
dat one takes 12 seconds plus so you
certainly wouldn't want to do that in
the cloud tomcat was actually pretty
good they came down there recently
release 80 12 tom cat 7 was up there
with glassfish to about five seconds JD
on its own before we started this work
saw three and a half seconds there but
after after doing the quick start work
we've got it down to less than a second
which is pretty buddy good so little
great so NetBeans interesting so yeah so
we've been using jelly for I mean since
day one in App Engine ok so jelly six
you don't see it but it's there we
didn't want you two to extend it in a
way and we mainly use it because it was
fast at boot time and extremely
unbearable ok now we are moving the
apply App Engine platform to a brand new
platform called the Google cloud
platform where we are adding a lot of
capabilities in the platform basically
thanks to a technology called docker so
what you will be deploying to the cloud
is no more a war file or a set of Python
file or not yes or whatever but what you
will be deploying is a docker container
ok I'm the docker container will contain
your application will contain by default
if you want if you want a GT will will a
job I will contain GT and will contain a
very stream down view of linux operating
system so you can control exactly which
version of GT you are using 9 dot-to-dot
3 which version of the u.s. you want to
use which version of the java jdk you
want to use you know they keep updating
every month so this is now the unit of
deployment so what we have been working
in is in to where into two areas first
of all the development environment so if
you are familiar with maven or Gradle we
have never not graded plugins then you
can plug a maven project inside an ID
like NetBeans and this is the same web
application that Greg was showing we
just started you know some XML to
describe hey I'm an app engine
application now ok so my my project was
called vm runtime demo and we can have
many versions of the same project so
this one will be fast
GD 9 okay and the nice thing compared to
the previous app engine is you have this
magic track called the unequal true so
let's go outside of NetBeans and just do
a command dokie so who knows about
docker because I guess well a bit better
than than before it keeps growing but
it's still an emerging technologies at
Google and Amazon and read that and many
many other people are embracing okay so
basically it's dhoka dhoka our system
can run docker containers and the docker
container is not a war file it's really
an image and partings importing system
image with your application in it so
here PS i have no process running in
tokyo so what i will be doing is run
exactly the same a web application that
greg did using the App Engine maven
plugin and we have a new tool called
g-cloud I mean Google Cloud whatever
cloud SDK and I will just run exactly
the same application so here it takes a
bit longer because yes we are
calculating this a quick stop of web
data xml okay so let's go back to here
and now if I go to a docker I see a
docker process okay so it's not running
on my Mac it's running in a
virtualization system running inside my
mind okay but it's really exploding what
will be in the cloud so here I have a
process this is a PID process or we
could be and I will just look at it logs
for this PID so here we are a little bit
slower than Greg why because first of
all it does i'm jealous you have a
faster machine but we are also running
inside container environment running
inside via for bugs okay but still it's
still better than tom cat it's still
better than less fish for the same exact
app okay you can attach a debugger to
eat i mean you can use eclipse netbeans
IntelliJ android studio command line mvn
no problem okay so you don't really need
to to know don't care because we will we
will
with one or n containers for you
automatically jostle stores okay so this
is basically the same demo we are using
JT 9 dot-to-dot 3 out of last week on my
on my system so it's almost ready to be
pushed to a early access we are still in
private re access for now for our
managed VM but we are moving very fast
to to make it public for everyone to try
so let's go back now to to the slides so
yeah yeah well I mean yeah so a lot of
people initially complain about App
Engine because you know they could they
could not use these they could not use
that they could not choose a awt it was
a locating system etc yeah we have so
maybe not because we're guess what I
mean people like reddit implemented all
the app engine API is on top of java
application server so you can go to the
App Engine TCK org we have a TCK so we
validate those aps with their
implementation and their product is
called quad cab dwarf so if you want to
run your application app engine
application in your garage you can
because jeebus is a very good product
other limitation yeah what is yeah we
had to be we had to introduce a waitress
because of the existing google app
engine technology guess what this wait
list now is gone because of the new
layer of security is the vm and the
docker image so we do not really care
now if you can do a from Java system
exact PS or et Cie shut down because
it's your vm u captioned on your vm you
cannot shut down a google Iraq ok by the
way if you do capture the Oracle cloud
they also do have a whitelist so
basically we are I mean we are trying to
see if a cloud profile would make more
sense
the web profile you have to have a wait
list in the Oracle cloud today what else
you know yeah you need your native code
so basically you want a Java process you
want you want agile process but maybe
you want to apt get a c++ library image
library whatever and then you want to do
gni with it okay so you want to be able
to configure not anymore java ee web
application because it's much more you
need to have an execution environment
which is the same on your mac and the
same on your cloud so here dr. will help
as well because you can do you can
customize customize a document using a
docker file which is a the recipe to
build your continued so one step is
running Linux commands like apt-get or
curl to download from anywhere extra
artifact that is part of your
application so this is what we are doing
trying to keep the simplicity of App
Engine that was out in two thousand
nights and released in 2011 for the java
area and with a new compute engine
platform of google we are trying to
bring the best things of the two
together and this is what we call
manager yet so it's not really a is it's
not anymore past because it's much more
powerful than math and a pass and this
is what we are calling managed VMs and
all those application layers can rely on
cloud storage data store we have a
stirred SQL database for you as well in
the cloud big data if you want to do big
queries on Messi's a massively big set
of data and then the existing and
updated app engine services mail
datastore memcache task you everything
ok so now this is your new environment
basically everything that was possible
before in appengine is keep possible but
then you have the power of if you want
you can
deep dive in the vm itself you can
access the ssh you can be rude you can
debug you can introspect it so these are
the differences between the old world
and the new world that is coming in the
Google cloud platform where you can have
mad now payloads of I mean service
requests thats can spawn more than the
day you can do threads you can do
background processes if you want you can
ssh you can scale you can write to a
local get that may disappear but you can
write some temporary files for caching
then finally you can run a servlet three
dot one thanks to GD 9 you can pick java
7 java 9 java 10 who cares you can even
pick your own custom runtime so we are
working on new images for node dart goo
and more network access you can have
WebSocket assuming you have the IP
address of the machine you want to talk
to and so it's a little bit more
difficult to configure as of today and
the pricing is more as a mixed of App
Engine pricing and compute engine
pricing so in one slide it's very simple
where I mean this is a the bridge
between a past solution and a
infrastructure solution like compute
engine the the unit of communication
between those two were is a docker
container and this is what google will
boot inside VMs ok and we are not
talking about one or two vm i mean we
have customers like snapshot for
Interpol it's a big big big consumer
they are running a lot of games a lot of
java processes so you will need to learn
a little bit more in fact you all know
java you are java one ok i challenge you
now to start looking at a new world
which is the next level of application
bonding which is no cure continuous so
when you come back you know at work
please spend time
learning dr. because this is what we are
basic on at Google and not only at
Google the entire big club players are
trying to unify but this unit of
execution the good part about it is the
Java process running on my Mac is not
using the GRE of my mac is running the
jury of the document supporting system
so when in my direct program i do get
out I don't get the environment of my
back I do get the environment of the
same environment that I will run in this
dr. container and in the cloud so it's a
perfect fidelity between your your
production I mean you're the development
environment where you can attach the PDA
debugger to a dock your container JVM
running if you want we do that in
netbeans or eclipse and the same
execution environment will run at scale
in the cloud so yeah everybody knows but
this works on my machine yeah so I push
the program you know who cares you know
well no you don't have the same
environment you don't have the same
class pass the same location of the GRE
the same everything so this is what we
are trying to solve so you have seen it
running locally same execution will will
run remotely so we mentioned a few
things but developer experience I mean
it's key to be able to develop still
locally we are moving and in google and
other player of our moving more and more
development in the cloud but we I mean
we are recognized that we I mean you are
still using IntelliJ know who is using
IntelliJ I am netbeans no eclipse okay
so it works on the kids I could have
done the demo naked but if it can work
in netbeans it should work in a kitchen
grade or as well so we have greater
plugins for for that so if you can plug
an ID ducking grader or maven then you
are productive then I hear I studied
only one vm
docker container okay let's say my app
engine app ng in web.xml I would say hey
you know I want 10 of them here okay you
put 10 well our SDK will be 10 dock your
containers okay and then we have a load
balancer locally to your Mac to simulate
what will happen in the cloud okay and
obviously when you deploy you will have
10 or your vm so when you have 10 jelly
speeding up plugs you are a bit lost no
because it's complicated to follow this
on the same terminal okay so we have a
mock-up admin console in the under SDK
and we have the full fledge cloud
logging tooling that we use for our for
projecting in the complete comprehension
developer experience is also but maven
even though it's not related to what's
going on here we are working with the
solar type gas so that they can move the
entire maven central repository inside
Google Cloud storage what does it mean
that it means that if you do a build a
maven build on a GC instance it will
access the dot m2 repository with a big
big Network pipe okay much bigger than
from here to wherever the maven central
repositories so it's still not fully
done but we have nightly 19 year old and
very soon it will be the official maven
repository clad debugger you can I said
you can you can debug locally you can
debug locally and let's try to see what
it means to debug in the cloud you want
to put a watch point somewhere but you
don't know where your process we will
run so let's try to see now let's try to
move to the other powers of spectrum so
I'm not on my SDK level anymore I'm in
the
a unified glad console this is my
project vm runtime limo this is exactly
what i put here ok and here you have a
version called vast fetch 89 so let's
look at it because i deployed a little
bit early so here ya vo do love because
way I guess what it's the first of the
month yesterday whether to run for
hundred dollars because i'm using a lot
of things to play with so billing then
you can see a few dashboard here in the
overview then you have an area for
attention and an area for compute engine
so the two now components of your
environment ok because you will have to
deal with applique App Engine
applications but you will also have to
deal with the apps ok so let's look at
the App Engine view for any poor all the
versions on module default I have two
thousand fast GD 9 again it was in my
app engine web that XML I have another
one which is called default which is
fractal we look at it later ok so i have
two version of the same app they are
completely independent and they are
lives i can I can talk to all those
versions because this is what we what we
what we have if i look at the compute
engine view so here very simple to 2000
of the same application called vm
runtime demo now if I look at the VM
instances here i have the vm view of the
process so i have something called gie
google appengine default fast GTG and
then a unique number ok so this is a
real physical vm that will run the
docker environment that will run your
dock your container that you tested on
your Mac previously and then i have 1 2
3 4 5 version I mean of instances for
another project that i have here so we
can be great
vm runtime demo version fractal and here
i put five okay so this is what what you
have ok the next thing but this console
is you can register in the source code
area you can register either Google git
repository or even better a github
repository ok so here I'm viewing a
github repository that I registered to
my flat project ok so let's look at a
surf the main it's exactly what you
would see in your development
environment I go to something i want to
to do and here i have a bunch of classes
and i have a servlet file that i guess
you know first of all it's a so let's
real file it is fully annotated it's
also using who can who can tell me what
this is here can you read huh yes java
it's a lambda using yeah the java 8
environment so here i have customized
customized the default java 7 App Engine
image and I plug a java java 8 i can go
there set a breakpoint it's not really
bright points it's a it's a watch point
ok so we have five VMs the first one
that will eat this watch bones will
capture the state of the vm so let's try
accessing the servlet servlet to debug
your member of the mapping ok so I'm
running I just print all the
probabilities I print the environment
which is exactly the same environment as
on my mac and then a system get home and
now i print some lenders ok so let's go
back to the debugger of you here well
guess what now we have this view here
maybe you can be bigger where i can look
for an apple we have a collection called
son least I can start looking at it like
you would do in a regular debugger okay
so adamant data number one is Joe Bailey
whatever okay but the request did not
stop you don't know which vm got it and
you have a complete wash of where the
bright moon was added okay so this is a
cloud debugger demo so fully integrated
into the other console so let's go back
to our slides here so this is a demo you
have seen it live did not crash so maybe
Alex see ya we have 10 minutes no let's
try to close in five and take a few
questions yeah great so thanks for the
demo so you try to step back a little
bit platforms the service can be offered
in a public cloud that's certainly what
we do that's what we believe in because
we believe we can achieve great amount
of you know of performance and density
and we've been doing that for a long
time for our own purposes at the same
time the plas platform I could be used
in other environments you know hybrid or
private and certainly the marketplace is
changing very fast so I'd like to
encourage you to read this recent blog
by stephen harris who is the VP at
cloudbees explaining why they're exiting
actually that pass a marketplace and for
that for that matter actually focusing
on continuous integration in the cloud
because they believe again that the
cloud is here to help them be more agile
so this is a great piece I don't have
time to work too much into it but it
provides you comments on you know first
of all how Java probably needs to evolve
in a number of ways to probably provide
as fast as possible startup times and
also gives you an idea of what players
are doing what and obviously darker is a
great piece of the strategy of most of
those players so do do do well look at
that dog another quote that I have here
is from Peter Queens from the osgi
foundation and that's a fairly recent
one where he is like questioning the
value of Java now that doctor offers
that portability and that we're taking a
container and transporting it from
development to production what is java
life to provide as a unique value that
others were not providing i think
there's still a number of things but
it's also interesting to see that people
are asking those themselves those
questions and and and we need to make
sure java remains relevant in in a
number of ways now finally I think we've
moved into a world where the unit your
application is not no longer your
deliverable is no longer a war file it's
probably a docker file maybe it's
multiple doctor files you'll get into
questions of how do you orchestrate
multiple doctor images because not
everything can be you know captured in
one container and and we're moving to in
a Linux world full portability where
it's not about hopefully this will
behave the exactly the same because I
have the exact same environment it is
the same linux distribution with the
same version of java with the same
application the same startup flags the
same everything so again a linux
container and this area is the new unit
of work for for for deploying things and
this is where we talk about
microservices this is where hopefully
most of them in the future will still be
written in java but there might be a few
things that we need to to discuss the
the cloud profile being one of them so
quick recap we talked about a number of
things that we think are useful when you
do Java in the cloud so things you can't
do really yourselves which is to define
a cloud profile hopefully the JCP will
consider that things you can do is make
sure you have this dedicated here for
storing your States so deployment
startup of instances or your application
have no impact on you know state
availability whatsoever choose your
injection framework wisely you may not
need if it's just for injection purposes
the full spring framework do keep an eye
on dagger 2 I think it's extremely
powerful and interesting to use in an
environment like the cloud early next
year will do tells me um use services
pre-configured ready to use services
wherever possible don't you know
configure anything if you don't have to
start up time matters if basically you
want really fast startup time either use
App Engine or use jet if you're building
your own pass I guess and we have a
number of we believe unique features and
and actually I don't want to go through
them again but as a thank you for coming
to this talk and and first thing this
long we'd like to invite you to a
five-hundred-dollar credit on the cloud
platform all of it and that includes of
course App Engine and and all the
different features we we've talked about
so get that QR code that the promo code
is Java one the number dash 14 and I
with that I think we're on time and we
have time to take maybe a couple
questions here's one right yes I know
some asos is really in the business of
orchestrating containers and has been
around in tonight patchy project has
been around for a while it's really
mostly useful for people building their
own paths and that have this problem a
problem of spinning up dr. containers
and making sure you do so with the best
utilization possible so what kind of
resources did I have what kind of you
know requires do I have coming in hi do
I you know do the best mapping possible
so if you're in the business of building
your own paths may be a private
and that's probably something you want
to look into you mentioned mezzos there
is another project that Google started
called Cuban eighties which is in the
same vein about orchestrating containers
probably with a different approach where
they you know start small approach and
it also manages different types of
containers so so managed VMs is using
internally Copernicus you you don't see
it yet but if you ssh to the vm you will
seek you burn it as bloggers containers
running in your vm but we don't exploit
it yet publicly for App Engine yes
it's ready so yeah so we are still in
private area private access so you need
to register you can ask me if you want I
hope you know in a matter of weeks okay
it's more a matter of week than month to
be in freeview for everybody and then I
hope we will have a lot of a lot of
preview customers we are creating
building data centers to to to be
already okay so one of the blocker
number of put a possible VMV we want to
boot and then based on your feedback if
you don't like it if you whatever you
you you you can participate the good
news is all those documents will be
completely open source you can build
yourself on your Mac you can customize
it the way you want it will be on github
last question oh sorry one one one here
will try to take the other one
yes
yes I mean yeah they are using our
dollar store because I think they have
good reasons to use our data store so I
mean try to replicate the performance
characteristic of the data store is
extremely complicated outside the data
store so but you have seen the API okay
I mean it's key value based we have JPL
a year on top of it or did you but the
API is dead simple okay so honestly I
don't think well you will have to spend
engineering cycles to migrate if you
want and we have customers of App Engine
that moved away from App Engine there
are still very successful on a different
solution it's possible</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>