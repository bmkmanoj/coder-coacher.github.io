<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Faster Object Arrays | Coder Coacher - Coaching Coders</title><meta content="Faster Object Arrays - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Faster Object Arrays</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_bzuAtUtN-E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hi everyone sorry for technical setup
at the first couple of minutes the
subject that there is a faster faster
arrays in Java and what we're going to
talk about is actually a proposal for
adding things to the Java libraries
we're hoping to push this into a future
job I see version like Java 9 but we
will have available open source support
for this before that and I'll get into
the details of wine how I'm getting a
little echo in my year do you guys hear
a lot of verbreitung echo so I can see
if you can take your little care of that
test us just like closer to the mic okay
again okay I'll try and stick with that
okay so when we talk about faster object
to raise I'm really talking about the
ability to close one of the inherent
performance gaps between Java and C and
C derived languages this is actually one
of the inherent gaps left and probably
one of the last ones left where there's
something you could do and see that is
inherently better or faster than Java
and in Java you have a challenge
matching that speed I'm still getting a
lot of feedback here the other mic is
not on me hmm what is that like that
okay we'll try this okay now I can't
even look at my slides it just let's try
this way yeah okay so let's let's look
at what it is we're talking about we put
up a bunch of stuff on object layout
Borg you can go and look at the website
there's a bunch of code in Java doc up
there but fundamentally are focused on
focuses on closing a speed gap that has
to do with how memory is laid out when
we create data structures and allowing
us to create data structures in a way
that is similar semantically
to the thing that makes see languages
fast not the language but the day let
the data layout we want to expose these
benefits in a way that's idiomatic to
Java in some new language way not some
data structures don't work with our nice
automatic memory management but in a way
that's very natural for every Java
programmer to use which basically means
we want regular pojos to be able to
benefit from this swim this layout we're
not talking about something that will
let you put some scholars in memory in
an array but I want any Java object to
be able to benefit from this and the
focus is therefore on speed for regular
Java objects on the heap that's when I
talk about idiomatic Java I mean on the
heap not some strange off heap scalar
things with no references for context
these are things we're not focusing on
okay we're not focusing on improving
footprint this is not about saving
memory memory savings somebody else's
business if you know where I come from
and what I work on I think our bridge
collection is a completely solved
problem we've completely solved it other
people will eventually figure it out too
we're not in the business of saving you
a few bytes of memory we're in the
business of making your code run fast
okay and you've got gigabytes and
gigabytes of memory to do that with
we're also not in the business of doing
off heap anything again no need to go
off heap with in Java objects if you do
need to do things off heat for very good
reasons there are other good solutions
that lame at that and then we're not
dealing with immutability or non
immutability we just couldn't care less
right you want to write a mutable
functional code go ahead you want to
write highly mutable c-style code go
ahead java presents the ability to do
both and it's an orthogonal concern all
these are orthogonal concerns these are
not good things or bad things they're
just things I don't care about okay okay
so the focus is on speed for java
objects on the heap remember this mantra
cuz all repeated every time somebody
talks to me about this isn't this like
this other thing remember speed java
objects on the heat
so let's look at some of those overlaps
because I'll do this little pre-emptive
leaders every time I talk about this
subject like on on on groups on google
groups or mechanical sympathy for
example we immediately go into this 20
message track about whether value types
are good or bad and I couldn't care less
right it's not about those but let's
talk about them and compare we have two
other things that people often associate
with what we're talking about here value
types impact objects Valley types are
very interesting and something I'd like
to see come in Java as soon as possible
and they deal with immutable small
values and the ability to move them as
parameters passed by value instead of
passed by reference returning something
that has more than one field very very
useful but this is not about that impact
objects deal with how to lay out objects
very explicitly in specific orders it's
useful for sharing things with you know
stuff that is not java off heap tcp/ip
happens to have already selected the
byte order for the headers we can't tell
it you know that we want Java to
randomly choose it but again these are
those that are used for other purposes
so as far as overlap the relationship we
have to value types is 0 the
relationship we have to pack the object
is 0 and we're laser focused on speed
for java objects on the heat okay none
of those that neither one of those deal
with java objects or speed or night we
don't conflict or contradict either
these both of these I think are good
things that need to happen in various
forms we need to be able to interact
with native structures when we call
native libraries we need to be able to
interact with shared buffers when we
talk to other processes that's what
packed objects are really good for or
ffi or jnr if you follow those and value
types as I said I think are very
valuable and will enable really cool on
stack optimizations now there is some
minimal overlap between all these three
because there are some things you can
express that you you can express it in
Java and could be better expressed in
all three of these things that we're
talking about but that overlap is kind
of similar to the fact that we can have
an arraylist and hash map and they both
are back to hold objects they're good
for different things they have different
purposes and yeah there's a little
overlap let's use a visual for this and
at this after this I'll stop talking
about those are the two things value
types packed objects or jnr ffi and
object layout overlap in a little bit
you can look at value types is the thing
that is very good for small immutable
stuff return values and such parameters
very good for unstack handling of data
you could put these on the heap but then
you most likely will box them if you
share them with anything else and that
has to do with limitations ran word
tearing and other things we're not going
to get into here but the value of this
will probably be around how we pass
parameters and objects and return values
when we call methods not in how we're
going to lay out shared data in the heap
a lot packed objects are focused on
really sharing precise asserting precise
control over data layout usually for
sharing things usually for off heap
stuff there are variations that go on
heap as well for consistency the thing
that both of these share is that neither
one of them let you do this stuff with a
java object a fact object is not a Java
object it's something else a value type
is almost a Java object but not quite
for example you can't lock it you can't
get an identity hash map on it and you
probably can't pass it these things that
don't know what a value type is so these
are about new new things object layout
is about speed for regular Java objects
on the heat number so here we have
things that'll go for a new code you're
going to see new code written in your
ways to deal with value types when they
come you're also going to see new code
for new objects written whether it's jnr
if a fire packed object or some
combination of all these together
but there will be ways to describe
something off heat perhaps and there
will be new code in object lab we're
dealing with code and constructs that
will allow you to use any existing Java
object and pass it into any existing
library that can handle java objects and
you'll see what we mean by then a little
later so at this point I'm done
comparing things ok just just to be sure
where I'm getting this out of our system
and out of her way first this is where
the overlap is tiny rays of tiny objects
I love immutable tiny objects and we can
express them in 03 but that's not really
that important so where does this come
from what's the original reason we
started looking at this it all starts
with an argument I was actually having
an argument with Martin Thompson and we
like to argue and argument really
represents two sides of a common
argument the first sight is we need
structs in Java look at all this stuff
that we do just because we don't have
structure in Java we go and use unsafe
we go off heap we loud things with
flyweights and other things but the
reason we do them and when I say we I
mean all these very high performance low
latency high throughput guys that really
know what they're doing the reason they
do it is that metrically they get zero
benefit it runs faster it has fewer
dereferences it streams through memory
it doesn't have the same range check
problems it runs faster and that's
something that's hard to argue it but
how do you argue with it you say well we
already have structs we have better than
structs we have objects objects or
anything as structs could be plus them
in what you actually are missing is not
the structure but the semantic layout
you want in order to achieve speed and
that's really the issue that we're
focusing on so you know we had a bit of
an argument and all that and then we
said let's try and code something that
captures the theory that if we just lay
out the structures right the data
structure in the right way it doesn't
matter if you're talking about a
structure an object you'll get the same
benefit so the the basis to all this and
this is a key concept is that speed
doesn't
from the the language definition of the
type it comes from the semantic
limitations on the type there are
certain things that you could talk about
in these types where because they are
limited we get to have speed out of them
and without that limitation we're forced
to do things that lose speed and I'll
get to specifics on that in a second so
where does speed come from how do these
see structures that we talk about like a
raise of structs and things like that
gain speed well the two main things that
you see are what's called dead reckoning
the ability to get from a reference to
an object to element number 17 field X
without doing additional data loads just
with math I have a pointer to hear I'll
do some math I figure out the pointer to
there and I didn't load any other data
to figure this out so skipping
data-dependent load point of chasing on
the way to some piece of data you need
dead reckoning is very powerful it's
taking out steps that go through read
this thing for memory follow agreed
follow if we have an array of structs we
could get two struck number 18 field 3
without reading anything from memory I
mean we need to read that from memory
but nothing on the way that's one now
the one that's kind of obvious is
streaming when we have these things laid
out nicely in memory and they're well
structured and they repeat themselves as
a pattern if we stream league on across
in any operation that scans all this
stuff in one way or another looks for
something at something all of them
benefit from natural striding in memory
and actual striding in memory is very
powerful because the pre fetchers have a
field day with it if you give a natural
stride to a prefetcher you don't see
latency you just see bandwidth
limitations because the pipe gets full
and everybody's happy but if you point a
chase and the next address is not
perfectly predictable from the previous
address you're looking at data dependent
load latency things and they hurt the
pipeline very badly so these are the two
benefits dead reckoning and straining
that's where most layout benefits come
from people often point to well I can
save some memory as well if I do this
right and that's where I
I don't care like the I care about speed
I don't care about how much memory you
waste and most people I know today if
they had to waste another gigabyte to
get another five percent of speed they'd
happily do it as long as it didn't hurt
right well you know if GCU solved then
it doesn't hurt okay so let's let's look
at specific example of what I mean by
speed enabling semantics we have two
ways of describing what is commonly
thought of as an array of structures we
have the Java way which is an object
array and we have the same way which is
an array of structs now c allows us
other richness stuff we could do another
an array of pointers districts and other
things but in Java the only way we can
describe an array of objects is object
array what is fundamentally different
between those two well semantically the
java ray is a mutable array of same base
type objects solid objects in arrear of
the same basic not of the same type I
can have multiple objects a different
type in the same array as long as they
have a common base type which is a type
of the array array of objects obviously
the common base type but also you know
array of foo is anything that's at
places for right it doesn't have to be
exactly foo in contrast in strong
contrast and see an array of structs is
an immutable ray of exactly the same
type object it's immutable because
struck number three in the array is
struck number three in the array i can't
say i want it to point to something else
there is no pointer i can mess with its
content but it is struck number three in
the array so that's why it's immutable
the array has these things and they
don't go anywhere and then it's exactly
the same type so we know exactly the
size of each which is the same this
difference is responsible for a
difference in speed because mutability
and non exact same size each separately
are responsible for not being able able
to dead reckon and not being able to
string if you are mutable that
means I could replace element number
three in there ray which means that I
can't figure out where element number
three is if I just have the right
pointer who knows what you put in
element number three and where it really
is you gotta chase a pointer to figure
it out that's loss of that reckoning
with that obviously you lose streaming
because who knows where it is right
you'll go and follow things and randomly
similarly for streaming if it's not the
same size obviously I don't get to
stream because sometimes I need to skip
a hundred sometimes it's 17 who knows
what the next one is and you'll get
interesting variations but again
mutability hearts streaming the same way
both of these are the basic speeds speed
benefits see gets and both of them are
lost because of semantics because we can
mutate an object array and because the
thing in it is not of a fixed size well
how do we fix that what's really simple
let's define a collection that has the
right qualities that's what is
structured array is it's one of the key
constructs in object layout it is a
array it's a collection but it's
basically an array of exact same type
object than array is immutable you
create it it's got all these objects in
it you can get them you could do
whatever you want with them but there is
no put operation there's no remove
operation there's no clear operation
because it's immutable this is just a
contract for a class right I didn't do
anything with the class yet I didn't
optimize that I'm just saying that I
need these two qualities otherwise
there's no way for me to get what I want
and hoping this is by restricting the
semantics of the classes we can then
allow the jvms to optimize the
implementation of the class knowing that
the restriction is there we have a
restricted contract that allows us then
to optimize layout in which ever way the
JVM I choose to do which hopefully looks
exactly like the sea way of doing it or
most likely looks like you okay so
that's what we're talking about with
semantic limitations enabling speed
you'll see this repeated and other
structures so the target forms that
we're looking at in object layout and
the package name is arg that object
layout so i'll start using that form
the first one is an array of structs we
want something that's like an array of
structs stride it and memory we get fast
dead reckoning fast streaming we also
want something like is struct with a
struct inside right not an object first
do another object that may be anywhere
but an object that first another object
that's inside of it laid out inside of
it this becomes very useful not just for
avoiding the dead reckoning but if you
have one of these in an array then you
can stream on the content of the inside
object as well and then the last
construct that's very commonly used in
NC is an array a nice truck that has an
array at the end a variable size array
then usually so think header with
payload packets messages those kind of
things they're repeated all over the
place and they're used for speed and
avoiding the referencing to get to the
payload and all that and it's very
useful so all the all these three
constructs are useful for speed and see
because of their layout and all of them
are expressible in java today but
without the speed so i can describe the
relationship in regular Java by taking a
class and doing whatever that thing is
but usually you have it has a
relationship additional dereferencing on
the way and inability for the JVM to
optimize things because it doesn't know
what the actual restriction is so we're
trying to create all these the starting
point for our we're trying to create
this is to capture the semantics of each
capture the enabling semantics in each
and then do it hopefully and we believe
we have a solution that there's actual
code working on github for this we want
to do this without any language change
whatsoever okay this is not a suggestion
for new keywords new byte codes or
anything right we want this to be able
to run on vanilla Java in java 6 plus or
later languages right so this is not
just aiming at the future this is
looking for continuity if you the syntax
for what we call the vanilla Java
implementation is not necessarily the
optimized ones but the ones that will
give you the behavior you have
exactly the same if you code to that
will behave the same across versions can
run java 6 and above and once we have
that in place we can then have future JD
case of footage of a nine or later
recognize what this thing is and then
say i know how to optimize that and make
it really fast rather than keep the
vanilla semantics of before and then
we'll get speed out of that the vanilla
and the intrinsic I'd i call them in
transit I'd implementations for the
speed have to semantically behave
exactly the same way we shouldn't be
able to write something invalid a little
break in a future JVM or vice versa
right we don't we don't want to have any
feature that's only possible if your
intrinsic I the difference should only
be speed but no semantic visibility to
the difference other than that now
there's a model that I followed in
creating this and that is Java util
concurrent I think that that's probably
the largest and more successful external
contribution to Java that came from
outside of aura Corsa and if you look at
how it went about doing that it follows
these same kind of goals it captured
semantics that made utilities you know
concurrent utilities fast and possible
right those semantics involve 0 language
changes there's not a single thing in
Java util concurrent how many of you
actually use this thing in Java 14
before it was in the language or just
the library right some of you are there
I still see some code that has that
instead of the Java 5 in it so and we're
you know what almost 10 years past that
point more than 10 years actually but
it's there it worked now you didn't have
to have any kind of JVM support for it
yeah it helped to have a little thing
here there but vanilla worked you can do
an atomic long compare and set by using
a synchronized block as an
implementation not as fast not
necessarily the best way to do it but it
works logically the same way once there
was a valid working implementation that
helped with the various things we then
went to the JD case and said okay here's
a contract this is what it does go
recognize and make it fast
that thing that right now is in player
with a synchronized mark around the long
inside of it won't that's one
instruction a Cavs instruction on a
modern CPU you go do that right instead
of the slow thing that we were doing but
semantically identical right and then
that whole thing got moved into the JDK
in Java 5 and moving into the JK JDK
gave it two things the first one it got
into the Java namespace which helps but
it also got legitimate access to unsafe
so the internals of the JDK for doing
things like compare and set were
directly callable from this code because
it was in the Jade again it's okay to do
some unsafe stare it's not okay at least
an alleged arity point of view to do the
same thing from the outside and some of
you might you might want to go to the
talks that are later this week talking
about how unsafe might go away it's
never going away for the inside the JDK
stuff so that's why when you get into
decay you can now safely use the
features it also means that if you're in
the Java namespace the JVM can now make
strong assumptions about your behavior
because you're part of the spec there's
a well-defined behavior to what you do
therefore we can go optimize point so
I'm trying to emulate that we're trying
to emulate that with object layout and
achieve the same kind of incremental and
benefit of getting in so we talked about
these three constructs I'll zoom into
structured array or the array of structs
first let's look at what that looks like
structured array of type T it's just a
generic collection basically a
collection of objects of type T anybody
that's used to collection should
recognize the form and this collection
happens to be laid out like an array or
act like an array which means it has a
get with an index right that's about it
right now it's immutable meaning that
you can't replace or add elements to it
right so it's got a fixed size and our
old there when you started you
instantiate it with a factory method for
example that much like you to San she
ate an array of some unknown type but
that way
and then all elements in this have to be
constructed at creation time because
it's immutable if the not created at
creation time then they can't be there
and in order to support that this very
elaborate support for ways of
constructing objects within these
structures so yeah you could just say
hey make that and use the default
constructor that's good for things with
the default constructor that don't have
any final fields yeah but some objects
don't have a default constructor some of
them have final field so you might want
to pass specific instructors specific
arguments and to say how to construct
these or maybe you want the element to
be constructed according to the context
of the index at which it's put there are
ways to do that so I'm not going to get
into the details ER but they're very
elaborate ways of letting you control
the construction of individual elements
in this collection as its created but
once they're constructed that's it
they're there now that doesn't mean the
objects are mutable it just means the
object collection is immutable now you
can get any one of them with again and
do whatever you want to it right you can
get element 17 and if it's mutable you
could go mutate anything in it right
what you can't do is change which
element is only 70 okay now there's a
very key thing and it took us a while to
figure this out and when we figure this
out that to us was really the
breakthrough and why this makes so much
sense for Java for idiomatic Java and
that is life pneus when we started off
we looked at the need to have an array
of structs and said okay if i'm going to
have this array of things and somebody
refers to an element in the middle what
happens to the array itself that who
keeps that alive how do we do that
because that's not a natural thing in
Java to do and in the JVM would have to
work hard to say if I if I'm keeping
this flat thing in the middle element is
referred to from that side how do I make
the collector and a JDM figure out to to
do all this so initially we we looked at
that because every other implementation
that we've seen of the equivalent of a
rare
struct in an environment like this
behaves like that if there's a garbage
collector in automatic memory management
if you point to the middle of something
you're keeping the something alive not
the middle alone but the entire
something so we worked hard to figure
those out and there's a lot of there's a
lot of spaghetti there to figure out
it's doable other runtimes do this but
it's complicated and there's interesting
semantic questions and then about a
month into it michael wolf actually
looking at me and saying tell me again
why we're trying to keep the array life
and you know because everybody does it
that way but this is a collection how
many collections do you know that stay
alive because you kept an element in
them alive that's not it i o matic
that's weird that's strange that'll
cause memory leaks the only reason
people keep the container live when they
point to the middle is because they
think that the thing that point to can't
live on its own it's not an object it's
a struct it's a field but it doesn't
have liveness right but we have real
objects these are perfectly good real
objects they can live on their own and
you're used to knowing that if you have
something in a hashmap the hashmap keeps
it alive and you might keep it alive and
if the hashmap dies and you have it it's
still alive and you don't keep the
hashmap alive somebody else might these
are natural relationship this is how we
are used to dealing with collections
collections keep their content alive the
content doesn't implicitly keep the
collection alive and we managed to keep
that relationship therefore structure to
write managed is probably a weird way of
saying it we saved ourselves years of
work by not doing the other okay this is
just natural so the collection keeps
itself alive the stuff doesn't keep the
collection life now when we have an
optimized implementation the
implementation is responsible for
keeping the collection together so you
know if the collection is nice and flat
and we did all this layout of an array
of structs like thing but array of
objects if we move this we need to move
everything together so our math would
work right
but that's the only thing when you need
to do if they move and their live move
them together but if the outside stops
being alive then everything could just
float anything anywhere it wants that's
basically the idea so that's how
liveness works and the benefit of this
is well we don't have special behavior
we don't have to teach anybody anything
new about this this is just normal it's
what you already expect from any
collection and it all happens to be fast
and easy to implement in JD case right
much easier than the other mode and
basically we can take any element in a
structured array and have it participate
in any other collection so you have a
structured array of a few thousand
objects and you want to index it with a
hashmap go ahead you want to put a
linked list that weaves through it go
ahead an object can be in any collection
you want including this to structured
arrays can't share an object for the
simple reason that there's no way to put
an object in a structure to Ray right so
when I made them they were created with
it so obviously they're part of the
structure to Ray if I make another
structured very well it's going to have
its own but I can share this with any
mutable collection that I can insert
things into existing objects into now we
can also as a result of this take any
member of this collection and pass it to
any piece of code you already have that
knows how to handle a Java object I
could take a structured array of lots of
things and put elements in the logger I
can pass them to things or transactional
we could do whatever we want that you
already have code it was written seven
years ago and doesn't know what the
container is can deal with the objects
in it without any special behavior
that's a big contrast to new types of
objects that existing libraries don't
recognize at everything in this stuff is
just regular poachers so all this is
natural the big benefit hopefully you
get the point on that now what else can
we talk about in structure to raise
there are a few common qualities or
simple qualities the indices in a
structure there are Long's not int and
probably don't need to explain why I
mean we're 2014 and
let's not have this argument okay we can
bring bill gates here if you want a nest
of the Rays are supported out of the box
so you can have structured race-off
structured arrays I've structured raised
right and a member element that's a
structure is just an object on its own
but also flat nice so you can have a
container that's flat inside a
containers is five inside a container
this flat and the third level one could
survive while the other stuff dies it's
just an object there's nothing special
about it structured raised subclass of
all which makes it very useful for some
nice coding patterns and coding
techniques anybody who's ever tried to
do you know three deep generics prolly
understands why you might want to create
some subclasses in the way just to make
your code readable but those patterns
the natural patterns also expose very
nice optimizations that we can then do
in the JDK if used what would be
idiomatic way of using this stuff
structured ring is not constructible
okay why not constructible because there
is actually no way in java to construct
an object of variable size other than a
primitive array there's just no way to
express that to a JVM as a new operation
the way to make those is with factories
which is what we do here so we have to
prevent structured away from being nude
but you can't new a structured array
because we need to know how much space
to allocate for it and we don't know
until the constructor get its parameters
and that happens after we've already
allocated the space and they've got a
chicken-and-egg problem so that's what
factories help us with now for those of
you who may have thought of the details
of this you might notice that these last
two bullets contradict each other I'm
saying that it's a classical because
that's nice and it's very useful and
it's part of what we use but it's not
constructible and if you want to
subclass if you want a subclass of all
class you have to expose a constructor
otherwise you can't sub plus it so
there's a nice trick if you go dig in
the code you'll find something called
constructor magic which allows us to
have non constructible subclass
and the trick is not that you can't
write new on a structured array you
could just never make it work all right
so you try and make to newegg structured
array not through a factory you'll just
get an exception so that way we make
sure that even the vanilla Java can't do
something fake that we will later have a
problem with okay implementation the
main thing that comes out and this is
common to all the object layouts
constructs the main thing that comes out
of this is a new concept of contained
and containing objects now contained in
containing objects are regular objects
there's nothing special about them but
they have a relationship between them
from a heap management perspective and
within vanilla Java that relationship
doesn't even exist but in the optimized
implementations when we do this we need
to track this new capability and given a
contained object you can go back and
find its container not you not the Java
code there's no way from you from an
element to say what's my container but
the gvm has to be able to do this
because it needs to keep the container
together so if a garbage collection for
any reason ever needs to move an object
that is in one of these contained
relationships that element of a
structured array needs to move to
compaction the collector needs to go to
the outermost live container and move
the whole thing together the reason it
does that is so that our math will keep
working right if I have a reference to
the container I could figure out what
the address is of an element without
dereferencing that means the container
always has to be flat and it needs to
move together I can't move parts that's
the main thing we need to do in a jdk
and a JVM to support this capability it
turns out that that's pretty simple to
do in all existing collectors that we
know of this isn't just for saying in
our cool collector but we've looked at
every collector in OpenJDK and we have a
straightforward way of supporting this
capability nice quality without ripping
the collector apart and making really
big new things in it this is a fairly
straightforward thing to do I've john
here with me who's worked on a lot of
these collectors and i'm going to try
and get to a Q&amp;amp;A part we can grill
why but we believe that all the current
collectors could do this with a very
relatively lightweight amount of work
and there's going to be a lot more
detail and discussions about this but we
don't have time here optimized
implementations gained a few things the
first one is once we put the layout in
place we don't need anything else to get
the streaming benefits the string
benefits simply comes out of the object
layout being what it is and the minute
we do that we're good however do you get
their reckoning we do need some compiler
optimization support and the reason for
that is that while there's no
dereferencing the actual computation of
the address of an element looks
something like this because an array has
is subclass able its body size could
vary by class because an array instance
only has one element type but you know a
structured array of points or boxes or
cats are all possible the omen size
isn't known for the right type it's
known for an instance of that right so
both of these are things we need to read
in order to gain to compute our address
and reading them from the instance of an
array is just as bad as dereferencing so
we replace dereferencing with some other
read however this is where the nice
optimization capabilities come in the
element and body size are not constant
in the world but they are exposed to
optimizations that look a lot like class
Harkey analysis and a lot like about
inline caching optimizations that exist
in method dispatch and those
optimizations will allow us in common
code to basically extrapolate those as
constants for a call site and get the
direct speed that's equivalent to see
this is where the compiler has to do
some work that JIT compiler has to do
some work not jealousy but with that
work and it's very doable work will gain
the dead reckoning benefit as well so
again a lot of details in other
discussion so we covered structured
around we talked about the whole picture
I'll quickly look at the other two
once trucks and do a couple examples and
then see we'll open it to Q&amp;amp;A so we have
two other constructs one is struct
instruct we want to emulate that we call
those intrinsic objects the word
intrinsic here is the english meaning of
intrinsic not the compiler meaning of
intrinsic meaning an object X is an
instance X's intrinsic to instance why
it was created at the same time part of
natural to look up the dictionary
meaning this is how we intend to how we
currently already declare that
relationship the the the point there end
point 1 is an as an object of type point
that is intrinsic to the class line it's
created just like it'sit's declared just
like any regular field but it's
initialized with a specific thing called
it called an intrinsic object model that
can be recognized by JK and flattened
and optimized energetic a that could do
that so in this in these few lines we
capture enough limiting semantics to
allow a jdk to optimize this and make
every line have an endpoint object
inside of it rather than somewhere else
and therefore we get a line with two
flat points if i do two of these and no
external references and I could dead
wreck into a point from the line without
having to read a reference that small
syntax changes based our syntax addition
if you like this is not new syntax it's
just you know some boilerplate
unfortunately someday in some future
java if everybody really likes this
maybe we'll get keywords for this right
but that's how an intrinsic object is
defined so then we'll flatten it or it
could be flattened in an implementation
that optimizes it now we have to deal
with the fact that you might could go
and change this final field with
reflection later because you can do all
kinds of stuff to mess with this and
that means that the optimized
implementations need to detect cases
where you did that and then throw away
their optimizations and you
I mean that's not that hard to do the
compiler optimizations are easily thrown
away you just need to leave enough in
the data structure to be able to use the
slower path of dereferencing if that
happens the other form is a struct with
an irate end right this is a packet like
thing and we represent that is subclass
of all race so of all the normal types
so this is easily captured as a an array
with a subclass of the subclass is where
you put your fields of your struct an
array is just an array so object layout
includes all the primitive types is it
possible right so basically a primitive
long array a primitive byte array
primitive double array ne ne you know
and all they mean is there's an array of
that primitive type and you can subclass
it at any fields any code you want to
that and recently I've found some really
interesting examples of doing that
without even wanting any fields like
Goldman Sachs collections of GS
collections library users has this thing
called an immutable list and they ripped
a pack basically an array of references
and put a bunch of code around it but no
new fields that's a natural thing to say
that is a subclass of reference array
and it will take out a dead reckoning
the reference step sorry it will replace
the reference that with your dead
reckoning directly so we get this for
primitive race we also get it for a
reference array of any generic type and
in addition to the primitive stuff
structured array is already subclass
able which means it already captures the
concept of a struct with an array of
other structure at the end ok it's an
array of structs and you can sub plasa
to create destruct at the beginning ok
so these are the three forms we have
structured array for arrays of structs
we have intrinsic object models to
facilitate the description of a struct
instruct and we have primitive primitive
arrays long etc and reference right to
model the struck with with a resident
those are the three forms now these
forms are composable
which makes for some really nice things
I tried to capture a few snippets of
code here but let me walk through what
you're seeing here at the top we have a
class called octagons octagons is an
array of octagon that makes sense and
it's nice to describe it as extends
rather than you know that way we know
what octagons are right so that's a
structured array of type octagon well an
octagon is a class that has an intrinsic
field in it in directly in it but
directly referenceable in that intrinsic
field is actually a structured array of
a fixed length aid because it's an
octagon and in in the structure rate we
have points so an octagon is a flat a
flat thing of point now what you see
there is a structured array of points
structure of point is down there that's
a it's a subclass of structured ray
point or extends it right now what you
have here is an array of octagons that's
a structure ray each element in it is an
octagon inside each octagon we have flat
not reference to a structured array with
eight things in it each one of them is
another object given a reference to the
octagons array we can calculate and
derive the address of X in point seven
of octagon Eva's at number seventeen
without doing any memory humps it's
completely flat data structure which
makes it fast and streaming and cool so
that's how composition comes into play
you could do the same with primitive
arrays and you can put a bunch of them
together um I didn't put the cool slide
ahead from the workshop but I like to
say that you know this is contained
objects all the way down I have Turtles
all the way down you can have things and
things and things and things you can
have 100 gigabytes of completely flat
stuff and go play with it okay so where
are we with this um the vanilla code for
this is up and github runs tests and you
can code against it and it gives you
these structures it's just isn't any
faster than if you wrote them some other
way because it's vanilla Java right
the good news is it's not reading any
slower like the speed of a structured
raised about the same speed of any
encapsulated array you would have the
other ones are you know you can model
and intrinsic object fiddle just not be
an intrinsic object but it won't be any
slower than one and then similarly an
array of a subclass able primitive array
is a class that has a field in it that's
a primitive array so you have a
dereference step when you're looking at
vanilla Java but in the future j decays
that will go and make this fast will
make your code fast if you start coding
to this concept much like Java util
concurrent got much faster doing atomic
compare and set after the JDK supported
it but some people here coded into it
before it did that so structurally is
fairly mature semantically the other
forms are maturing but I actually think
this is I forgot to update this bullet
because in the last two weeks we had a
lot of maturation going on the entrance
of fun implementations for this are
coming in the next few weeks for both
OpenJDK and thing now zing is a product
waiters will make and we're going to
have it support this with speed without
waiting for anything because hey we
could do this to java 6 code argonaut
object layout I know what that is cool
with OpenJDK we're doing the same thing
and we'll be contributing code for
vanilla openjdk that will do the things
in the JVM to intrinsic I stuff and to
come support the collection and our goal
there is to contribute that in push into
Java nine so we'll be starting an opt k
project to Jeff probably and see if we
can get people convinced to put this in
that's going to be interesting and we're
going to need a lot of supports all of
you here yeah so the next steps are to
try and build the right projects around
this and our aim is to add this to the
core libraries and to the spec of Java
nine because then we'll be able to
secure the access to unsafe and
the fact that the GV decay can really
know what this is and it's not going to
change the summary of all this is the
new Java classes are there we propose
that we move them into java SE 9 this
all works out of the box in Java 6 7 8
and 9 right you don't need jdk with
optimization to make it work you just
need to dedicate the optimization to
make it fast and this can the go fast
part doesn't actually have to make it
into jeddah key now to be viable our
main going jetty canine is to
standardize this all we need to do is
say these seem like the right semantics
and when I say seem it's probably
because we've built a couple of
implementations that make it go faster
and we know we don't need other things
from it but then we can say just capture
this put in an aspect the vanilla code
already works let's see what
optimizations we get maybe we just get
the streaming first and we'll do that
reckoning later maybe we can get both
all kinds of stuff but we think this is
a very viable goal to put into java 9
based on what it can expose either in
java dine or in later versions on speed
so with that we're we're open to
questions I am not sure what the timing
is like ok so we have about 10 minutes
for questions um I don't know if there's
a mic in the room for that or I'll just
repeat the questions otherwise ah well
that's always a question its anything
from zero to very very fast if you're if
you're streaming through a cash missing
operation pointer chasing in the world
you see a huge change if you're hitting
an l1 all the time it's a different
change it's hard to quantify those but
think of this is the difference between
an array of pointers destructs in an
array of structs and see ya
with the current cursor you that we have
a spectacular going to be a little bit
cumbersome syntactically has there been
any language so the question is whether
we've thought of the language construct
to make things flow a little easier um i
would say that of all these the arrays
are actually very natural there's really
no overhead to writing them it looks
very natural the only thing is there's
no there's factory instantiation rather
than than you so maybe in some future
version if you could say new in a new
way by a byte code that does
construction and instantiation rather
than allocation and later to invoke
special construction would be needed for
that and I don't see a huge need for
that to me it's trigger but maybe the
intrinsic object model thing is probably
the one that could benefit the most from
key words to say who but not as well no
you would actually say you know right
now we say private final full equals
something that's initialized for a model
if you had a keyword that enforced that
in the compilers helped enforce it it
would save a bunch of the sugar around
it's needed but you would still probably
have to declare a model for each field
if you wanted insurance because you need
to say how for example if I'm saying
that I have an octagon that has an array
of point I have to have a place where i
declare that to be constant length 8
because I can't have variable length
intrinsic so the model has to capture
that but there's you know there are a
lot of there's a lot of letters in what
you write to then that could probably be
compacted if you guys have any questions
about implementation and drag John the
lung and he can talk forever about
collections in the six minutes we have
left or other questions yeah
container the container is no longer
does that be that in order to reclaim
like a nerd you have to visit every
contained object down along I know and I
sleep in for the collector the caulking
collector that you know a vacuum tonight
continued objects learning you know copy
the entire container as you don't
necessarily visit the container first if
you can guarantee you can visit the
container first or not visit the
contained objects with a visiting the
container it would reserve that button
things like we have a separate marketing
phase there's no need to actually bring
that object along it's just the
individual contained object itself can
exist those say to think about this way
and all other implementations of this
concept the whole thing stays alive
we optimize it dramatically but only
keeping the life for its life
um you any marks we kind of container
certainly gets to do that what John
talks about what the copying collector
is a copying collector will tend to
promote this before it gets rid of the
rest and the reason is because finding
liveness and a single past collectors
are tricky business they just you know
hey it's the container you keep it
around until you can define you can
detect the fact that you just said which
is I only have this alive in the rest is
dead the coffee collector just can't
detect that but like I said all other
implementations of this concept keep it
alive forever so we're an optimization
you know but those ways you could make a
turn you can walk around us you know you
can sense you know you have separate you
know a sea of sg-1 parallel old they all
do is separate marking fizzies
beforehand you know so the idea is if
you know that some of these things are
you meal if you use the same premise of
g1 uses that some of these large guys
there are few and far between and
expected to be long live promote the
burly promote them often and are we need
to get cleaned up much more quickly let
me just search something is there a
session after us there is ok I just want
to make sure that when they get in here
we get out of their way but I'm happy
staying until people kick us out still
have more games ok
because if you give people this book and
you give them long indices they're gonna
make it big we're just going to want to
copy them a part of this land impossible
yeah if you give a mouse a cookie well
since they're at their regular objects I
mean so we have chunky your g one who's
chunking in the marking code is children
zing his chunky in the marking code you
know we learnt in the copying not so
much yet and we still in the process of
flesh as to the one thing we're doing
the relocation code and actually we
can't actually get chunked and I don't
know enough of what you want but I
assume that regions are separately you
know could be worked off separately if
you get a large enough thing you you're
naturally gonna strike the work of
moving stuff in infinity we have
mechanisms in saying it doesn't doesn't
necessarily mean that we need to chunk
these guys during the actual relocation
face regarding the actual talking you'd
probably could I mean we already yeah do
you want already does chunking of re
copying so about the following name is
naturally into this EKG one figured out
well as if you wanted to I mean you
could just feel it could be regarded it
could be half a region it could be half
a region law you know you could be
defending up here to make regions and
you say you want each one of these guys
to be just under 60k there is a
interesting enough to get there's an
interesting transition that this adds as
a quark to collectors that do special
handling of very large objects so huge
objects or whatever people call imagine
you have one of these and it's you know
it's 100 megabytes of size like hundred
gigabytes in size and then you have
three surviving objects in it right now
you have a situation where you had
something that was huge and you have
three surviving small objects and they
need to move to a regular region and
then all this thing will go away that's
a a something and collectors will deal
with or we need to deal with it's a
concept and it exists only if people
segregate by size and collectors are
segregated by size so this thing does
that I believe g one does that I think
shadow is going to do that and but for
example parallel GC doesn't do that in
as far as I know CMS doesn't do that in
all gen neither yeah it just you know
the nature is they go straight to the
Elgin but they're they're not separate
things they're just don't get collected
the regular way in places where there is
separate you know segregate and / type
of size and that's usually reaching base
collectors it does mean that you have a
movement potential movement of an object
from a large region to a smaller region
as a result of that object surviving
without its container so that's
something you just need to deal with but
it's again it's a fairly straightforward
thing to deal with as it take to go back
to the light using GV g one bottle mean
if you try to copy one of these guys you
know it's like this is the way i think
the guy is an oracle should have done
the young the collection of humongous
objects anyway the farm most of these
guys are going to be larger than a
promotion local allocation buffer it's
going to feel it's going to close to the
slope
anyway you know so that point you can
turn recibo the slope at Cana deferrals
these guys it to the end of the
collection by that point you've already
done your your first pass talking then
you can have an idea of wherever these
guys have been actually updating or you
know somebody objects within the model
on that detail is one of the reasons we
don't see the issue with copying
collectors surviving stuff as a big deal
because you know if it's a small ray you
don't care and if it's the larger it's
not in the newgen in a copying collector
so the other any oh we gotta leave by
fellow more questions JJ I'm not sure
how each exists but it seems to me is
possible to create a suffix on one of
these basically the life part array is
the suffix in the end of the array you
can have
riddle and discard the beginning stuff
like that so um they're all kinds of
really cool array things that are being
worked on by Oracle as part of their
race 20 heading that includes
interesting notions of sparse arrays of
coral rays of choppa bola rains either
in the front of the back and you what
you just described as a chopping of the
front of our array we're not going to
deal with those concepts until after
Oracle thinks them through for regular
arrays and I think that any of those
concepts as their solidified and we have
the right semantics to talk about them
in Java would just simply apply to these
arrays naturally so we're not trying to
research those things they're all kinds
of cool stuff I could do a sparse
virtual memory and other things but you
know people like John Rose have spent a
lot more time thinking about those cool
things and we have so we're just waiting
for them to lead in the concept and then
I think that these are just a race and
whatever you did to race we could do to
these were we're future proofing them
we're making sure the indices are long
that's just you know we don't want to
deal with the end in this question and
that's going to come in a race to demo
as well
just here benchmarks so not really no
because the compiler support has not
been done yet that's where I go that's
what you guys see the relevance mean
with one person who is working on me the
entrace vacation within the compiler you
know but like all kind of things
priorities shift and change I mean the
whole idea is to get you know we still I
suppose why should the semantics the
skill set and do yoga relatively quick
and dirty prototype with you know Zane
which we between O'Mara and some of the
OpenJDK we've been working more with
power GC mostly just say again make sure
communism from a different point of view
but the semantics don't contradict you
know I now actually helped us find a few
you know Raul's that we came to wind
down the other yeah the nice thing and
how we're implementing this is we're
going for the ship the intrinsic I
bulava code is separated but it's Java
code then uses some specific new unsafe
api's we've identified eight unsafe
api's needed for this mostly around
dealing with construction and knowing
sizes and things like that and padding's
but there's one that's needed for speed
which is given given an offset into an
object giving a ref to that offset which
is basically a cast on math but that
one's needed for speed the rest of them
are just needed for semantics what we're
aiming for his code that would be in
Java ident
for open to decay in singing it's a good
test of the concept that we have the
right abstractions in place if we have
to JPM implementations change our code
for the actual fast fan of things we
think we're pretty good shape and we're
close to that the the other kind of
related part is master okay we'll wrap
up with this and we could go outside if
you guys want um this the speed things
can easily be answered with models and C
code because it then we're dealing with
very simple things we know what the
instructions are going to do we know the
memory operations are going to do and we
can run c code that runs on hypothetical
layouts of exactly that and tell you
what the difference would be and you can
do the same thing yeah we'll get to
actually testing that which allah itself
but but we're not that worried about
that part because we know what layout
does there's no magic to that and we
know that if we can end up with the dead
reckon that we'll get what we want out
of it right now expect an answer I mean
as I say those are huge complications
you have to work around the fact that it
is a cat let's step outside free up the
room and we'll be happy to talk more
outside with people wanting okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>