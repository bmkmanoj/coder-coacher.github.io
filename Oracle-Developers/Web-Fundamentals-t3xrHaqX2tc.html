<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Web Fundamentals | Coder Coacher - Coaching Coders</title><meta content="Web Fundamentals - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Web Fundamentals</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/t3xrHaqX2tc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm James ward the session is web
fundamentals so the idea for this
session was to try to peek underneath
the covers of what our web frameworks
are actually doing and how they actually
work and how web pages turn into
applications and all that sort of thing
so the the first half I wanted to start
with some really kind of introductory
web stuff just really kind of dive into
the HTTP protocol and HTML and
JavaScript and kind of the the
foundation that we build on and then the
second half will be more diving into
some of the the ancillary items to that
like how do we do reactive requests how
do we use CDNs those sorts of things so
first half if you are already know all
about the internals of the web bear with
me I think the second half will have
some some good stuff for you as well so
that's the plan feel free to stop me at
anytime and ask questions and we'll dive
in okay so let's start with HTTP so HTTP
the hypertext Transfer Protocol it's a
request and response based protocol so
this means that I'm going to make a
request from a client to a server server
is going to then return a response it's
text based so it's not binary this means
that it's easy for us to read and write
well use it in a minute and then it has
some nice features to it like keep alive
and every time you make a connection to
a server that connection usually and
some protocols will close after the
response comes back and in HTTP there's
a mode where you can say don't close
that connection keep it open so that I
can continue using it the benefit of
that is that there's overhead to making
a connection to a server and we can
avoid that overhead when we have
subsequent subsequent requests coming in
HTTP also has HTTP which is secure HTTP
it also supports binary transfer and
things like compression so it's a pretty
versatile protocol been around for for a
long time now so HTTP has a server to
two elements a client in the server the
HTTP server
speaks HTTP obviously and listens for
connections so it's going to open a
socket and say anyone that can make a
connection to me I will try to handle
there
Qwest so it reads the request and then
returns a response they should be client
it also speaks HTTP and it's what
actually will make a connection over the
network to that server and then it sends
a request and gets a response so that's
kind of the the easy stuff let's dive
into the actual kind of bits of the
protocol so an HTTP request has has a
format to it and like any protocol it
has a structure for how you actually
will use the protocol so the first part
of a request in HTTP is the request
command this tells the server all right
here's what I'm actually trying to do
and it tells it what protocol I wants to
use so the structure of the the first
part of this request is the verb we'll
talk more about verbs in a minute then
the path and then the protocol so most
of the time now we're using HTTP 1.1 you
can also use HTTP 1.0 on most servers
and then there's a new version that's
being worked on for HTTP 2.0 which will
have some new and additional features
into it in it so after we've made that
request the line that is the text that
has the verb the path and the the
protocol the next line is our next set
of lines would be any headers that we
want to send in the request so headers
are name value pairs the name is just a
text block and then the colon and then
the value so pretty simple and then we
put in an empty line and then after the
empty line we can put in a request body
a lot of times we don't need a request
body if we were sending some data that
the server needed with a request then
that would usually go into the body but
a lot of times for most of our HTTP
requests there's not there's not a
request body so that's it that's that's
as simple as the request part of the
equation in HTTP pretty basic and it's
text-based it's human readable that's
the nice thing about it now the HTTP
response the thing that the server is
going to return also text-based and
there's a few elements to the structure
for that so in the HTTP status that's
the first line in the response what we
have is the protocol again so we're
confirming back to the client the
protocol that we're using the version
and then the
fonts code and their spots code is what
actually gets used to determine some
information about this response today
did it work
according to plan is there some other
information that I need to know about
this response like is the did the server
have an air does the server want me to
look somewhere else for this was was the
resource not found all those sorts of
things go into the the status code
what's interesting is that the HTTP
protocol also puts in a text version of
the response code so it's HTTP slash 1.1
okay or status code 200 and then it says
ok as well so it repeats the status code
it just does it in text as well and I
think you're not technically supposed to
key off of that text you're supposed to
use the just the the status code but the
nice thing about that is that now when
you're actually looking at your HTTP
requests and responses you can actually
see something you have to memorize all
the codes after a while you know you you
know 404 is and 200s and all those sorts
of things but it's nice to have the
actual text version of that response
code in there as well but it's actually
not used for anything as far as I know
so then there's the HTTP response
headers so these will come in subsequent
lines and name value pairs just like the
request headers then an empty line and
then the the response body the response
body is where most of our content is
coming through that we're that we're
using in our web applications it's the
HTML it's the JavaScript is the CSS so
all that stuff will go into that
response body so that's it that's the
whole HTTP protocol it's you know in a
few lines of code you could probably
build your own HTTP a very basic HTTP
server and client but pretty simple so
let's actually see it in action so you
can see how this works so to do this I'm
going to create a new application I'm
going to use Play Framework it's a java
web application framework and it allows
us to kind of get down to the bare bones
of HTTP and so we can see some stuff at
the low level so to do this I'm going to
create a new application I work at type
safe we created this thing called
activator it's a it's a nice way to
create apps so I'm going to come in here
and create a new application the one I
want is the
hello play Java only so that's what I'm
gonna use here and I'm gonna put that on
my desktop so this now is creating an
application based on this this template
this Hello play template and before I
show you the code and run the app and
stuff let's just go in and start making
some changes so first let's go here to
hello play Java so this is my
application that I just created there
and the first thing I want to show you
is how play maps requests here to maps
requests to code so play has this
concept of a routes file and the routes
file is where we define this mapping
between an HTTP verb and then the path
and then the code that's actually going
to handle that request so here on this
line we're saying alright map a get
request - slash - the controller
controller application dot index method
exactly that's what creates that mapping
so so you'll see that play it kind of
work is working directly with the HTTP
protocol out of the box that's why I
just use it for this session ok so
that's how we map the request let's go
take a look at the actual code that's
being handled that's handling this
request so I have a controller here and
it has a static method we could replace
that with dependency injection if we
wanted to but this this method needs to
return a result so a result is basically
something that is a status code and a
response body so there's a default
implementation here of this and I'm
going to come in here and change it and
say instead of returning that let's
instead return just a string ok so I've
got my controller it's going to handle a
get request to slash and then it's going
to return this string as a response body
so let's actually try that out here so I
can use telnet if you've never used
telnet to connect to ports it's pretty
fun so this play server should be up and
running it's on localhost 9000 let's go
make sure that that I'm all up and
running yep looks good so telnet is is a
general tool for connecting to you
really
any server any socket server that you
want to so it can speak any protocol
that you put into it so I'm going to
tell that to local host for 9,000 so
this now has an open connection up to
the server so telnet is now acting as my
HTTP client it's open to connection to
the server and so now I can put in some
HTTP so let's give it let's say alright
let's do a get so that's my verb to
slash and then let's use the HTTP 1.1
protocol now I could put in any any
request headers that I want I'm not
gonna put in any in right now so I just
hit enter I give it a new line and now
the play server is going to compile this
application and then you'll see that it
gives me my response so I made the
request and now play returns its
response so because I used HTTP 1.1
you'll see that my my telnet window is
still sitting there it's it's open it
still has this connection open and
that's the HTTP keep alive
I could send additional requests to the
server through this open connection so
let's look at the response and it's the
the protocol the response code and then
the the name of the response and then my
response headers there and then the
response body so that's the string that
I told it to be in the response body so
that's the ACP protocol pretty pretty
simple there before I go on any
questions about kind of the basics of
HTTP how that works yeah yeah yeah so if
we wanted to transfer a binary file an
image or some file download or something
like that
that would still go into the response
body it would just be encoded as binary
I think you can do base64 encoding or
there's other you can set a content type
of a binary some like application slash
whatever and then you can put binary
data into the response body so usually
if I wanted to serve a file you'll use a
web server that knows how to assemble
those HTTP responses with the the binary
data and they're in the response you can
also put any binary data that you wanted
to
HTTP responses there's some
serialization protocols like MF that go
over HTTP and that's just shoving binary
data into the into the HTTP response and
into the HTTP request bodies yeah good
question any other questions before I
move on okay
so that's our that's our basics of HTTP
so let's go back here and learn a little
bit more about the verbs so the verbs
that we that we use in HTTP there's some
some set verbs and they these verbs are
really there to indicate what the
request is about what it's trying to do
so you'll see that I made a get request
that get request is trying to say all
right I need this resource get me this
resource there's some other verbs like
head and post and put and delete and so
these verbs are really just trying to
explain what the request is about but
there's also an important part of
differentiator between some of these
verbs there's this thing called item
potency and it's kind of a weird word
but what item potency is is it's
requests which don't have any
side-effects
so item potent verbs are get head and I
don't know if there's any others but
these are these are things that don't
have side effects so let me give you a
scenario if you have a web application
that says checkout of the shopping cart
and you want the browser to of course
send this request say it say all right I
want to check out of the shopping cart
you don't want the browser to send that
request more than once or you know if
you're transferring money from one
account to another you don't want the
browser to send that request more than
once because that sort of operation it
has a side effect it's something that
you you don't want to happen more than
once unless the user tells it to happen
more than once so the item potent verbs
the get they they can happen as many
times as the browser wants to send them
and the browser will and some
circumstances send these requests
multiple times these get requests a good
example of this is chrome does a bunch
of prefetching and pre loading of web
pages so when you're like typing into
your url bar chrome actually will
predict what what your
webpage you're going to go to and it
does it as well when you're navigating a
page and it will actually preload these
web pages for you so it'll actually make
these HTTP requests to get these web
pages for you and if it was doing it if
there was no way to distinguish between
requests I had side effects and requests
that didn't have side effects these
kinds of optimizations could result in
you transferring money without you
knowing it without you instructing your
browser to do that and so post it's not
IID impotent because it has side effects
so that means that you've probably seen
that message in your browser where you
click refresh and the browser says hey
do you want to resubmit this and what
the browser is really saying is this is
a post request and this has side effects
and so I don't want to do this
automatically for you because you may
not want to resubmit this you may be
transferring money from your account
again and so that's that's how the
browser distinguishes between the type
of request and whether or not it can
make that request multiple times safely
so that's item potency it's an important
part of the web that our web frameworks
kind of hide from us usually but it's I
think important for us to understand
when to use the different verbs and what
they're for any questions about item
potency before we go on ok so there's
something you've probably heard of
called rest rest is the representational
state transfer what it's really trying
to do is use HTTP as a way to talk to
resources and so usually what we're
doing is we're combining rest with XML
we're combining rest with JSON as a way
to transfer data transfer basically our
objects that are on the server down
across HTTP and so usually rest is
combined with serialization like like
JSON or XML and what it does is it tries
to map basically the crud operations
create read update and delete tries to
map those on to HTTP verbs and so post
is like a create that's what we use it
for and rest get is a read and then put
update and delete of course delete so
that's that's the HTTP verbs on the left
and then the you know
style way of referring to those on the
right so that's really all the rest is
is trying to to get resources and update
resources do the crud operations on
resources but do it over HTTP so in the
case of crud we're going to use the
verbs as the way to distinguish what
we're trying to do we're going to use
the status codes so let's say arrest
request comes in and says get slash
users slash one with you know looking
for the user with an ID of one if the
server doesn't have a user with the idea
of one then it should return the 404
response code to the user so that we
actually use the HTTP response codes as
a way to indicate some information about
about the the information that's trying
to be fetched so really that's all the
rest is we're using the HP verbs we're
using the status codes as a way to move
data back and forth between this client
and server over HTTP
so that's rest you've you've already
seen rest
it's basically what what what you saw
already it's just using the HTTP
protocol in that way
any questions about rest before I go on
ok so let's talk a little about cookies
cookies are a way for the browser to
store information on the client side of
a machine so so we have this server and
sometimes we'd like to have a little bit
of information actually stored across
requests on the the client computer so
that's what we use cookies for it's a
way to store data on the client machine
the way that we use cookies is to use
HTTP headers so we can use an HTTP
header to to set a cookie and to get a
cookie so if we put a cookie into the
request into a request header then then
we can read that cookie out so we're
basically this would be in the request
so we're sending this cookie from the
client to the server so what that means
is that the client usually our web
browser has added this HTTP header to
the request and now when the server gets
this request it can read this
information that lived on the
client-side machine that was stored on
the client-side machine
and then the server can tell tell us to
set cookies so set cookie goes into the
HTTP response so the response coming
back from the server to the client where
the server is trying to instruct the
client all right set this information in
your local on your local machine so it
calls the set cookie so let me show you
a little bit of code we're gonna modify
this I'll just copy and paste this here
so what I'm going to do is have the
response here set a cookie and then I'm
going to read a cookie value out when I
when I handle this request so let's go
back to our telnet session and try this
out so first I'm setting a cookie named
name blah and I'm reading a cookie named
foo I'm not very creative with my name
so especially at 8:30 in the morning but
let's go now make a request let me start
from a new session here so let's make a
get request to slash again and this is
going to be HTTP 1.1 and now I need to
give it my cookie so say cookie : and
then my cookie that I'm going to read
it's going to be called foo so foo
equals let's just say bar and then a new
line and now my server comes back and
says all right HTTP response 200 and
content type and now the server is
telling me to set a cookie named blah
with a value of foo and then you'll see
that it says hello bar here and if we
look back at the the code real quick
that bar comes from reading that cookie
value out okay so that's kind of the
bare-bones
use of cookies we we don't often really
use cookies directly anymore because we
have something called session now that
that lives on top of cookies that we use
to to in most scenarios to store data so
let me let me move on to session or I'll
quick actually yeah
we'll talk about CSRF in a second before
I go on any questions about cookies how
cookies work really they're just the
text chunks that we save on the client
machine so session something that if
your web developers you've probably used
session before session is a way to put
state on the server about a user about
somebody the problem with HTTP is that
there is no correlation between any two
requests right I'm gonna make a request
and I'm gonna get a response and I'm
gonna make another question get in that
response but there's no correlation
between those two and in most of our
applications in most of our web
applications we need some correlation
between requests because we have users
and we need to know who the user is
between those requests so what we
typically do is we have this idea of a
session and the session is a place to
store data about a particular user about
an individual user so the way that
session is actually implemented in most
cases and most web frameworks is that we
set a cookie with a good a giant non
guessable UUID
and so that's something that will
uniquely identify the user and so that's
actually goes into a cookie well it's
usually set as like session ID is the
cookie name and then the value is that
big good and so we take that that good
good that's stored on the client and
sent with every requests and we then map
that good to some block of data that
exists on the server so we have some
relationship between this good and
between a big chunk a big object on the
server so the the problem with this
approach is that this is what creates
stateful web frameworks
so the problem with stateful web
frameworks is that now we've got some
information that exists on a server
about a particular user and the problem
with that is that what happens if that
server crashes what happens to all that
information so you know back in the old
days of web programming we would you
know not knowing what we were doing we
would put like shopping cart information
in in the session and then the server
would have to be rebooted or would crash
and we'd lose all the shopping cart
information you know those sorts of
things so so now what's so that's one
problem is that a server dies your
session goes away
another problem with this is if you have
two servers and you have a load balance
or talked a little bit about load
balancers later but if you have a load
balancer that's sending requests to
these different servers to balance your
load across two servers now you have
session on one and not on another right
so you've got this session here and then
a user request comes into this one
everything is good and then the next
request comes into this server and now
everything is broken because they're
missing their session so there's some
ways to deal with this you can replicate
your session across your servers you can
also take your session now most of the
the app servers now have a way to take
session and actually move it out of the
server and put it into some back-end
data store so you can put it into like a
Redis database or there any other type
of data store behind it the relational
databases but it's kind of slow so lots
of different options for how you how you
deal with this problem we'll talk more
about load balancers later but sticky
sessions are another way to try to
address this problem so session really
all that it is is this good that goes
into a cookie so let's hop back I wanted
to cover one other thing cookies are the
root of all cross-site scripting or
cross-site request forgery attacks
cross-site request forgery attacks a
little bit of a tangent here but I think
it's important what happens is all of
your cookies that you have for for a
server the browser will always send
those cookies no matter who is making
the request so it doesn't matter if if
your bank site has said you know make
make a request to this site or if some
hacker that you've browsed to some
malicious web site that makes some
requests it doesn't matter who is making
a request to a server it doesn't matter
who initiates that request whether it's
the person you intend to initiate the
correct the request or if it's some
malicious person it doesn't matter the
browser will always send the cookies for
that site so this is what opens up this
massive vulnerability that was I don't
know how long ago is discovered but at
some point someone discovered it and
realized that oh my god like every web
site on the Internet is vulnerable to
this and still to this day a lot of web
sites are vulnerable
to this so what did actually the what
the root of this problem is is that
doesn't matter who is initiating the
request your cookies are always going to
be sent and so that means that for using
session where we were saying all right
this good is associating me with with
this user then it doesn't matter if a
malicious person now initiates a request
those cookies are going to be sent and
going to identify to the server that
user so the way around this is one of
the ways around around this is to add an
additional value to every request that
that is a unique value that identifies
the user in a per request manner it's a
in addition to the cookie you have to
send another basically good with every
request to basically authenticate the
request most web frameworks have a
built-in way to do this to add these to
each request so now it's pretty easy to
mitigate this vulnerability but still
certainly exist in a lot of web
applications and the root of it is
because cookies always get sent no
matter who asks and no matter who
initiates the request questions on
cookies in session before we go on okay
all right so let's let's dive down to
the other side of the equation we've
talked about the HTTP server let's talk
more about the browser
so first the browser it's an HTTP client
making HTTP request for us it renders
HTML and CSS it runs JavaScript and it
manages our cookies and really ever
since the days of mosaic and the old
browsers that's all the browser's have
really done and everything else that we
have on top of that is just kind of you
know features for managing your you know
bookmarks and you know managing caching
and doing things more efficiently but
but ultimately that's what web browsers
that's all they do there HTTP clients
that render HTML and CSS and run
JavaScript and manage cookies so HTML
it's a hypertext markup language it's
text-based
it's XML ish there was a push to
actually make it some actual dialect of
eight of
- Mel but I think that that kind of
failed and we've gone back with html5 -
not trying to make it XML its page based
so we make a request we get a response
that's our page the browser renders that
page and then in a typical web
application anytime we need a new page
then we make an another request and get
another page back from the server so
that route that HTML is returning there
in the HTTP body response body something
that you'll hear about as you dive into
single page applications is the Dom the
Dom the Dom is the document object model
what it is is a model it's a a way to
reference the tree the hierarchy of the
webpage so there's been this this trend
lately in HTML to not put information
about the the look of a web page in the
HTML so back in the old days you know
all we had was HTML and so we would
basically combine all of our HTML markup
and all of our way that that markup
should actually be rendered in the
browser we combined all that information
into the same structure and so now
there's a trend to make HTML just like
the the semantics of our page just
laying out like here's my header you
know literally like like just this is
the header and then this is the footer
this is an article this is a section so
on and so forth and then take all of the
actual information about how that lays
out and move it into CSS and use CSS for
positioning things use CSS for changing
colors adding borders all that kind of
thing now happens in CSS so CSS the
cascading style sheets they're the way
to apply positioning apply look and feel
- to HTML and they're a OPH if you're
familiar with that term what that means
is that CSS is cross-cutting so whereas
HTML you say alright here is a button
there is no way in HTML to say this this
this look applies to all buttons that's
what CSS is for you can say alright take
all of my buttons and apply a border to
them so it's a cross-cutting
way to do cross cutting there's pretty
complex rules for how CSS works and and
how it orders how it actually orders the
CSS how you order your the rules that
you define
so it's CSS is is certainly one of the
most complicated parts of the web it's
it's something that that is is not just
a a complex thing itself but it's
complex to also figure out how all the
browsers actually implement the CSS and
how they do it differently and the
little quirks and different features
that they all have so CSS is is
definitely kind of one of the hardest
parts about web development as you dive
into it but the good news is is that
there's great tools for actually looking
at your CSS seeing how rules get applied
seeing the the way that that the rules
have been structured and and actually
going into the page and seeing the
structure of your CSS so the tool that I
usually use for this is the chrome
developer tools let's let's actually go
back to our code and I'm going to show
you some CSS before I do that let me go
open this this app up here in IntelliJ
so I can work with it a little bit
easier I'm gonna generate these files so
well that's well that's loading let's
actually go into the chrome tools so you
can see that so the chrome tools you can
get into them in chrome what we can do
in chrome is start to look at our page
so this is where we actually can see the
structure of our HTML we can see how our
CSS gets applied and so we can go look
at like let's say this button let's go
look here at this button so there's my
button in HTML you'll see that that
button on this page it's it's just
defined as as a button right there's no
look information about how that button
looks so all the information about how
it looks
gets applied in the CSS so we'll see
over here on the right we can actually
look at the CSS and how that gets
applied and chrome does a nice job of
kind of laying out the whole hierarchy
so we can kind of start at the bottom
and see all right from the very basic
CSS pay definition on this page we've
got some definitions for how this button
should look we have font weights and
font styles and font
sizes but you'll see these are crossed
out so that means that these work these
would have been applied but something
over wrote them and so we can actually
scroll up further and see alright what
the heck actually applied to this button
to actually get it to get the the
border-radius and get the get the border
information and get the font information
and get the color information so you'll
see that it's kind of stacking these
different CSS rules on top of each other
in order to just make that button look
like that so that's that's the way the
tool that I usually use to dive in and
see why in the world is my background
such and such for this button and nice
thing about chrome is we can actually
come in and make changes here so if I
want to change the the color of this
button to red
oh that's on hover you'll see that
there's a state qualifier there for
button hover so now when I hover over
that you'll see alright my button is a
beautiful black and red alright but nice
thing about Chrome and other tools like
Firebug is you can go in and actually
change these values you can see how the
CSS values got applied here and this is
a very invaluable tool for figuring out
how in the world did this thing get
looking the way that it looks on my page
okay so that's the the chrome tools
let's go we've got my project created
here let's go open up this this project
in IntelliJ so we can go a little bit
further okay alright so what I want to
do is is take that little request
handler that we have in this play
application I'm gonna have it return
some HTML first and then I'll show you
some of the CSS aspects to it so let's
go to my app controllers and then here's
my application dot Java file let me exit
out of my this VI session here okay so
I'm gonna clean this up a bit go back to
kind of where we were at the beginning
and what I want to do in in this
response body now is return an HTML page
and I could encode a giant string here I
could put in a string with
the HTML page that I want to return but
most of our web frameworks they have a
way to do server-side generated HTML so
what this means is it's a it's basically
a code that our application will execute
to generate an HTML page so let me show
you how play does it by default so
there's a view package here and the
server-side language that we use to
create templates or create these create
these views in our application and play
the default language is a mix of scala
and HTML so let's take a look at this
you can swap swap that out for a
different language but this will be
maybe a little bit familiar to you if
you've done JSP or things like that it's
a language to create these HTML pages so
in this case I have a page that's that's
rendering something and then I have back
here you'll see that I'm using this main
function which is now calling this other
template so here we actually see most of
the web page here that we want to render
so this is a basic structure of the HTML
page we have the doctype for HTML that's
the new html5 doctype we have an HTML
tag we have a head tag so you'll see it
looks a bit like XML right
but not actually valid XML in all cases
and then we have some other parts of the
page a body a div but no actual look
information for this page in here but
let's take this page let's take the
index Khaleda HTML and I'm going to
render that page here so let's go to
index dot render here ok so now I've
told my HTTP response to its body to
have this HTML page so this page is
going to be run and generated on the
server and then returned in the HTTP
response body so we could go back to our
telnet session and we should now be able
to to make another request I'm going to
try to use the the keepalive feature
let's do a get request to HTTP to slash
from HTTP 1.1 and let's see ok so there
we go
so you'll see there now in my telnet
session I just got my HT response body
well here's the headers right and I got
the response body which is now this
generator
webpage there's there's a move in the
the community we'll talk about a little
bit more later to not use server-side
generated webpages to do everything on
the client-side so that's a more pure
model where we just have just the static
HTML content and then the whole UI
happens in JavaScript we'll talk about
that more in a minute but in this case
we're actually generating this web page
on the server we're turning it in the
HTTP response body okay
so let's actually now go check this out
in a browser and see what it looks like
so that's my web page that's now coming
from the server so we can go back into
those chrome tools and see what actually
happened there's a network tab in here
that's pretty useful let me hit refresh
so I made this get request to slash so I
get requests to slash and that return
days status code 200 response we can
come in here and Chrome and actually
look at the response we can look at the
header so chrome is definitely very
valuable when you want to dig underneath
the covers of HTTP see exactly what's
going on see what everything kind of
looks like under the covers so then if
we look a little bit further at this web
page we'll see that there's some few
things in here that's that are going on
to bring in some CSS and then some
JavaScript we'll talk about in a minute
so to bring in CSS what I'm doing is I'm
creating a link tag with a rel of
stylesheet and then giving it an href
this code is just server-side code to to
to locate and then put in the URL to the
CSS stylesheet so we can talk more about
that in a little bit but essentially
what I'm saying is is put in a link in
this HTML page to this bootstrap mndot
CSS you may be wondering what's
bootstrap bootstrap is a CSS library it
was created at Twitter it's originally
called just Twitter bootstrap now it's
called bootstrap and it's a CSS library
so what it does is it applies a bunch of
CSS for me so that I don't have to
manage making things look good it's
basically a way to make things look good
without me having to be a total CSS
expert so this webpage that we're
looking at you'll see that it looks kind
of nice right I've got this this nice
well I've got this nice header that's
all coming from bootstrap that's all all
that
you eye all the the colors and those
sorts of things that's all coming from
bootstrap though the positioning that
that all is provided by the CSS of
bootstrap so if we take a look here at
like this header let's go inspect it
we'll see that the this header there's
some CSS being applied to to position it
you know padding right padding left and
you'll see that that's coming from that
bootstrap CSS file so let's actually go
just create our own CSS file so I'm
going to let's create a copy and remove
this so I'm going to create a new CSS
file here in my public directory just
come in and create a new file and I'll
call it index CSS and then let's just
add a body this is a rule to say for a
tag that matches body applied the CSS
and I'm gonna just put in some really
ugly background color here
alright so now I'm saying alright
wherever you see a body tag apply the
CSS background color okay now to
actually include this in our page let's
go say all right get me index dot CSS
there let's refresh this page and see if
it works
so it'll recompile the the app and OOP
didn't work let's see I include it index
dot CSS Oh wrong directory its assets
slash index dot CSS let's try that again
so now there should load up that CSS and
now when the webpage renders I get my
very beautiful background color of red
so CSS it's it's it's certainly as you
dive into the web one of the most
complex parts of the web to figure out
all the rules there are some tools that
are emerging to make it a bit easier to
work with boots libraries like bootstrap
are one there's also some languages that
create CSS for you so one of these is
called less and there's a few others
like sass and so these are languages
that actually compile down into CSS so
this makes it easier to write your CSS
and makes it easy
year to have reusability in your CSS and
those sorts of things so so for me when
I've been writing CSS lately I've been
doing it mostly unless you know we're
the the web is evolving and things are
getting better in the direction that
things are getting better in his - - we
can't avoid using CSS it's all that we
have for how we position and how we
style things we can't avoid it but we
can have better tools for how we write
it and that's a trend happening in the
web okay so that's that's our basics
into CSS
let's any questions about CSS before I
go on or anything else you just saw yeah
good any Java object so the CSS is all
client-side it's there is there's
nothing about CSS that's happening on
the server it's all being run the
browser is loading the web page the HTML
it's loading the CSS and then it's
applying the CSS on the client-side to
the HTML so there's there's nothing in
there that's that's actually happening
on the server side it's all on the
client side so so yeah so we have to do
all of our CSS all in the client side
and these are just static assets they're
not the CSS file that I created it's
just a static asset there's no java code
in that CSS file you shouldn't put java
code in your CSS file keep it a static
asset not something that needs to be
compiled or generated by the server yeah
good yeah good question so there are IDs
that do support less so I use IntelliJ
and it actually does support the less
syntax so it'll actually do the syntax
highlighting and do code completion and
less files just like I would get if I
was using it in CSS I'm sure that
eclipse has similar things as well the
the the more challenging part of less
and using these compilers to generate
your CSS is that it can mess with your
workflow right if you have to go through
an extra step to compile you're less
into your CSS that can be pretty
cumbersome so the modern web frameworks
they actually have built-in compilers to
compile less into CSS and we'll talk
about JavaScript and CoffeeScript later
so play framework has a built in less
compiler and
other frameworks as well have built in
compilers so it becomes just part of
your standard workflow you just write
your your code for your CSS and less
instead of CSS and you don't feel any
difference to that the place where this
does get challenging is because your
browser is actually using a different
format than your then you're writing in
it you now have a mismatch when you're
trying to debug things and so now
there's this move to create source maps
for JavaScript and they're working on
source maps for CSS as a way to address
this but it's moving pretty quickly but
the debugging is where this kids
challenging yeah the the doctype that
html5 uses works fine in every browser
that's that is commonly used I think
even down to IE 6 so they don't they
don't freak out about that doctype
usually there there could potentially be
issues there maybe if somebody's using
some really old or weird browser but
yeah he ate maybe cross browser is
definitely one of the hardest things
about web programming but libraries now
abstract a lot of that stuff away from
us so the doctype itself i've never had
a problem with the html5 doctype that i
know but maybe users didn't report it so
ok let's move on to javascript so
javascript it is a dynamic language it
is not a very well designed language so
what most people think but unfortunately
it's all that we have in the browser it
is the only way to execute code on the
client side in the browser outside of
plugins browser plugins can also do that
but javascript it's all that we have and
so we're trying to make the best of it
there's a few ways that that we're doing
that like less compiling to CSS there's
some new things languages that compile
to JavaScript so one of the most popular
right now is called the CoffeeScript
really it just takes some of the bad
parts of JavaScript and makes them
better and so it's it's CoffeeScript
it's a language that you write that
compiles down into JavaScript so the
move here is to actually use javascript
is kind of an assembly language for the
web we're not really using JavaScript
directly I'm
you still certainly can but the move is
to use JavaScript more as just this
assembly language that is what runs your
code in the browser but is not a
language you actually used directly
we're kind of at the beginning of this
and there's a lot of different places
where this is happening just about every
language can be compiled every other
language can be compiled down into
JavaScript in some way so it's kind of a
new area the source Maps that I
mentioned earlier that's something that
enables us to do debugging now when
we're compiling down to JavaScript
there's some new libraries like ASM js2
really actually kind of standardized how
we use JavaScript as an assembly
language so what's happening in this
space pretty quickly but for the
foreseeable future we're stuck with
JavaScript as the actual thing that runs
code in the browser on the client-side
this is good and bad
we now are building applications which
depend on JavaScript this is a new thing
that we didn't weren't able to do a
number of years ago where we always had
to have a failover if javascript wasn't
enabled and I think we're beyond that I
think that most people now they're okay
with depending on javascript in their
applications so now that we've gotten
there now we're able to do things like
single page applications a single page
application is where there's only one
HTML page and then the whole UI all of
the interaction everything that happens
in that application is driven through
JavaScript so that's kind of the
direction that we're heading and it's
it's all being done on JavaScript for
now so one of the primary reasons why
this is now possible is because the
browser's made JavaScript a whole lot
faster JavaScript and ie8 and in older
browsers is horribly horribly slow and
so you just couldn't use it to build
applications on now it's gotten so much
faster with things like v8 from chrome
that now we can actually run a whole lot
more code through JavaScript and do it
efficiently there are some interesting
movements to add other languages
actually first class supported languages
to the browser so dart is one of these
from Google where they're actually
trying to essentially replace JavaScript
as a way to run code on the client side
in the browse
but nothing has really kind of taken off
yet in this space everything is still
using JavaScript because all of your
users are probably only going to have
JavaScript as a way to run their their
code on the client for the foreseeable
future
yeah good dart is another language it's
a it's a language and a VM so it
replaces the JavaScript VMs it's it's
own VM so it's its own language own VM
and it's it is a possible future
alternative to JavaScript dart can also
compile down into JavaScript so you have
a way to use dart today in the browser
but it's but using dart natively through
its own VM is something that you need to
have the dart VM in your browser for and
unfortunately most of us probably don't
have the dart VM in our browser so we
have to failover to running that running
the JavaScript generated code from Dart
if you wanted to use Dart yeah let me
show you how we would put some
JavaScript onto this page so let me
create in here a new file called index J
s and let's let's in this index j st
like a alert all right the most exciting
thing in javascript and alert and now I
want to load in this script so to load
that in let's go create here a new
script tag so this is in my HTML page
I'm going to create a script tag and
it's type is text it's funny because we
set this script type to text JavaScript
when really there's no other options so
and then the URL here is going to be
assets index j s okay so there's my
script tag let's go try it out here in
the browser
I'm going to load that hey and there I
get my alert so what happened was when
the HTML page loaded it loaded the
javascript file that javascript file ran
on my machine ran on the client side and
then displayed an alert so super
exciting let's remove that back to our
web page
good question yeah I had that on my
slide so so jQuery is a JavaScript
library that is like it's like the
kitchen sink of JavaScript libraries
what we could use JavaScript just
directly and there's there's api's in
the browser to do everything that you
need the problem with that is that those
api's aren't the easiest to work with
and sometimes they're not the same
across browsers and so jQuery is
actually like like this tool that almost
every web application now uses jQuery
because what it does is it gives us a
standard library for the browser that
works across browsers so jQuery is it's
a very important tool to to building web
applications which run in which use
JavaScript so I'm not going to go into
any of the details on jQuery today but
if you're if you're in this room and you
want to be a web developer in the future
and you don't know jQuery like that's
your first task like - that's the most
important thing jQuery is absolutely
fundamental to - to building web app
modern web applications it's it's really
the standard library for the browser -
yeah
so jQuery it's important it creates a
standard API some people don't like it
because it's kind of big so depending on
some use cases it's you know the 40k or
whatever it is is too much for them so
some people have created alternatives to
jQuery but still today jQuery is the
most important when you're learning
jQuery I started learning jQuery before
I even really knew JavaScript so because
there's so many code examples like
anytime I don't know how to do something
in jQuery I search Stack Overflow and
there's like a million answer so the
jQuery community is massive it's
probably one of the most adopted
libraries most used libraries on the
planet so it's a really good community
it's a really good kind of way into the
whole browser web app world yeah what is
it
angular yeah so let's let's move on and
I'll talk I'll talk about those coming
up so I'll dive into you let's skip
react to me we'll go back to that in a
minute but so there's this there's this
emerging thing called html5 and I'll
answer your question through this html5
it's really kind of update
the HTML standards and and there's a
number of the standards you know
standards for CSS standards for HTML and
so it's adding a bunch of stuff into
HTML it's adding things like alpha and
support so you can actually have an
application that works offline it's
adding the ability to do video and audio
so you don't have to have Flash
installed it's adding drawing api's like
canvas and things like WebGL for for 3d
and a component model and push so it's
got a bunch of new features in it it's
it's definitely moving us forward in a
great way
really what html5 ultimately is about is
that now we're moving the browser from
being a web page rendering thing to
being a way to run our applications it's
becoming a platform to run applications
on so html5 is really filling out all
the needed parts of building
applications on the browser so as part
of this what's happening is we're now
we're taking our web applications that
we traditionally they were page based
applications every time a user wanted to
do an interaction we'd send a request to
the server and then return a whole new
page back to the client so that's the
that's the traditional way of building
web applications html5 is enabling us to
move into a new era of web applications
where our servers no longer actually do
page based applications they serve data
and then that data is then rendered and
interacted with all on the client side
in JavaScript so you build the entire UI
of the application in JavaScript or some
language that creates JavaScript so this
is what a single page application is we
can do it all directly we could write
that javascript manually but what's
happened is now we've gotten all these
web frameworks building on top of this
to make it easier to build these web
applications so there's frameworks like
angular and backbone and knock out there
what we're essentially doing is most of
us traditional web app developers we did
server-side MVC Model View controller so
we did all the Model View and controller
pieces on the server and we generated
web pages and sent those web pages down
to the browser now we're actually taking
that whole MVC and we're moving it over
to the client side over to
JavaScript's we're rebuilding all of our
web frameworks in JavaScript and then
the only interaction between the
JavaScript MVC application and the
server is through restful JSON usually
it's the the way that we do that through
an app or possibly through WebSockets so
we're moving the the whole thing the
whole UI down to the client side there's
a problem with this is that some of our
users don't have fast enough computers
or modern browsers and so there's a
mixed approach called pjax it's Ajax but
with P I guess and pjax what it does is
it keeps some of the stuff on the server
so it still does some server rendering
of HTML snippets and then it updates the
page with HTML snippets rather than
doing the full MVC on the client side
we just found most people found when
they switch to all client side NBC is
that if you have users that are on ie 8
or even on a 99 or on older versions of
whatever that doing that actually
doesn't work because the JavaScript on
the client isn't fast enough so then we
went with this mixed approach pjax if
you've used to github github is all pjax
based do they don't do a full
client-side MVC they do this mixed pjax
approach and there's a lot of others
that are doing that as well yeah
question good question so one of the new
API is in html5 is actually a way to
from JavaScript update the URL without
actually refreshing the page and so
github actually uses this as well where
when you're navigating through github it
looks like you're changing pages because
your URL is changing but it's not a pull
page refresh it's a partial page refresh
through pjax
there's also some other ways that you
can do it if the browser doesn't have
this where you can use hash tags in the
browser instead of you can change a hash
tag without without having a causing a
reload so that's the older more
traditional approach to in that but this
means that now you have to manage the
whole back forward
reload interaction you have to manage
that on the client side so all of these
modern client-side web MVC frameworks
they all have a way to manage basically
history and back and for
and reload all those things but manage
it on the client-side so it's it's all
being recreated again just telling the
client-side everything we did in our
Java web application frameworks ten
years ago it's all being redone on the
client-side yeah so that's that's one of
the other downsides why people are using
pjax as well is that if you have to load
in
you know megabyte of JavaScript and half
a mega CSS and a bunch of images to load
your application then that's you know a
painful experience so people have come
up with ways to optimize this but
depending on your use case that may be
okay to have a long load time it may not
be okay so different web frameworks are
gonna be better suited for you
angular it's it's a fairly large web
framework so that's better for like
enterprise applications where your users
can handle a bit longer load you
probably wouldn't create you know
Twitter comm with angular because it
would just be to users would have to
wait too long for that to load yeah so
caching is is a whole kind of massive
area of HTTP and how browsers work
essentially there's there's two
different ways to cache you can tell the
browser hey cache this thing for this
amount of time and then you can also
tell the browser basically an ID that
says if if you want this web page so if
the client makes if the browser makes a
request and says hey I have this I have
this page is that is that one the one
that I have in my cache and the server
can say yep that's the one you have in
your cache and then it won't send the
actual response body so those are two
ways to optimize the load so that we're
not continually retransfer inaud at a--
across the network yeah okay that's
JavaScript web frameworks
what's what's also happening now is
where we're taking these JavaScript web
frameworks these client-side frameworks
and now we're building mobile apps with
them so the nice thing about this is we
can get write once run anywhere and we
can get reused between our web sites and
our mobile applications and so PhoneGap
is an open-source tool that's now part
of apache and it's a way to basically
take a application that you've built in
this modern style this javascript CSS
everything on the client side and
packaging it up into an actual mobile
application that users can install on
their phones so PhoneGap is definitely
very interesting it can help us avoid
having to learn objective-c to write
iOS apps and that sort of thing so it
also has Bridge API so that you can
bridge to the native API on the phone
push is an interesting part of the web
touch on real quickly so we would like
for our web pages just to update in real
time whenever data changes whenever we
something has changed we want to see
that information immediately that's how
the web should work unfortunately
because we didn't have good mechanisms
for push and we didn't have good ways to
manage the the scalability that this on
the server pushes has not been something
that most of us have used but now that
we have real api's we have servers that
can can handle push connections scalable
e.push is now really making its way into
most web applications what we're
beginning to see is the Google Doc style
of experience to collaborate the
real-time collaboration that's beginning
to just percolate into normal web
applications so the ways to do that
WebSocket server sent events and then
the old hack is is comment so a lot of
people that need to support old browsers
they're using comet still server sent
events is kind of the newer html5 API
for doing push and then there's also
WebSockets which is not just push it's
bi-directional so you can push from the
server to the client you can also use
that same channel to send messages from
client to the server let me talk for
just one minute about I've talked a
little bit about load balancers but CDN
so as part of this what we're doing is
we move a lot of our a lot of our assets
to JavaScript and CSS and HTML we now
have a bunch of static assets and this
now opens up an opportunity to to take
these static assets and move them close
to the user the speed of light is
actually pretty slow I think round-trip
the minimum amount of time that you can
get a web request from here to the East
Coast and back is like 90 milliseconds
and for web applications we'd like to
shorten that even further you know
we're making a lot of web requests so
edge caching and CDNs content delivery
networks what they do is they move this
content actually physically close to the
user so that we can we don't have to
make those long trips across the United
States or across the world to get this
content CDNs are only for static content
they take static content they move it to
the edge and now that most of our
applications are built with static
content they're built with static HTML
CSS and JavaScript files now we can
actually take the whole client-side of
our application put it on a CDN so
that's close to the users and then just
make these it's hard to decentralized
data so our data usually stays someplace
far away from the user so just the data
requests which are going to be much
fewer and much smaller those are the
ones that are going to have to go to a
central location so that's one of the
exciting parts about this move to the
the new approach of building web
applications but definitely important
part of how we build web applications
and I am unfortunately out of time but
I'll be around I'll be outside if you
have other questions or anything feel
free to stop me and ask but thanks for
coming I hope that was useful for you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>