<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Toward Native JavaScript Performance on the JVM | Coder Coacher - Coaching Coders</title><meta content="Toward Native JavaScript Performance on the JVM - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Toward Native JavaScript Performance on the JVM</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9jhjOWMmYSU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to my session at javaone which
is adapted from something added to the
Java language summit in santa clara the
summer and expanded upon the more
general direction it's called towards
native performance with dynamic
languages on the JVM and I'm not just
talking in the even though i'm going to
use naz a'ren a lot as my examples and
javascript as you shall see this is a
more generic topic and we hope to move
into that direction architectural a very
soon safe harbor statement you've seen a
lot of these i don't need to go into the
legal slide very much dynamic language
is on the JVM is not a new thing new
thing per se people have been
implementing stuff on the JVM since well
95 when it came out compiling to
bytecode if that were not java alien
languages dynamic languages but there
have been several problems with them
mostly performance related even though
of course byte code is turing-complete
you can express everything with bytecode
and you've lacked some of the mechanisms
to efficiently implement dynamic
languages invoke dynamic is the most
important instruction of them all that
came out with Java 7 and it was the main
facilitator that enabled full rom time
linkage this is an advanced session so I
expect some familiarity with bytecode
that people have heard about invoke
dynamic before and stuff like that and i
might go pretty fast at times but i'll
try to hold your hands and it dropped me
for questions if you're hopelessly
confused so the first question that we
set out to answer when we built now
Soren started building nasser on a
couple years ago was how far in both
dynamic can take us to implement the
dynamic language on the JVM efficiently
with good performance and i'm happy to
report that now a couple of years later
I can say that invoked dynamic as a
concept took us pretty far actually and
this session is going to be a very nice
run based the new and improved
mechanical rhino it's part of the JDK
because that's where we done though star
performance experiments and that's what
we done our implementation experiments
with invoke dynamic
into until it turned into a full-fledged
product so I'm Marcus I work in the Java
language team mostly on invoke invoke
dynamic and dynamic language is on the
JVM and I've been doing that since full
2011 something like that previously I
have a background in run times among
other things have been the jitz
architect for the jrockit JVM worked for
b EA when they were acquired by oracle
i've done low-level things like a java
operating system and and several other
things in the runtime space but as this
is dynamic language sessional
hydra-matic sedo and take on the proper
hipster attire so this is JavaScript
we're talking about and dynamic
languages so the agenda also you can
follow me on twitter if you want to see
rennes about javascript or in general
status information or whatever i tweet
prolifically the program agenda for
today is a little nasrin summary people
should know of what nasrin is so I just
spent a couple of slides on that and
then I'll discuss what we've done the
last 12 months in the newsroom space
with invoke dynamic and how we did it
and the focus is on performance because
traditional that's been the problem on
the JVM deploying in non Java language
and having it perform well and for
example can JavaScript inmate perform as
well as v8 which is a native JavaScript
implementation custom written for
JavaScript even though we have an
abstraction layer between us of the
hardware the JVM and I'll talk about the
future and the directions were going
with dynamic languages lots of
forward-looking statements but you saw
the safe harbor slide so I'm safe so
that's one is a JavaScript runtime
shipped with the OpenJDK since JDK 8
which is replacement for rhino which is
very old and dated based completely on
invoke dynamic as the linkage mechanism
for every dynamic part of the JavaScript
language getters and setters and calls
and things that are subject to change
without notice in runtime estate as they
are in dynamic languages like JavaScript
and Ruby and whatever we support the
ECMAScript 5.1 and now with the a 240
release of JavaScript
or over the OpenJDK should say we have a
limited ECMA six support as well and
this more stuff coming their language
feature wise I would like the community
to help a lot as well since we're a bit
short staffed on on stuff like that so
you're very welcome to it help us and
contribute Mazarin generates currently
only generates bytecode it doesn't do
any interpretation of abstract syntax
trees it takes any piece of JavaScript
that you execute turns into the bytecode
and has the vm executed it has a good
security focus it's been security minded
from the start and so we're quite
confident that we have a solid runtime
architecture no one really wants to be
that Rhino the override a strained swing
classes guy whatever some security bugs
we've seen anymore so we try to provide
that from the beginning we have the
Avatar projects to be releasing which is
JavaScript in the cloud our node
implementation written in osborne and
java that is our co product and we're
using us or not just to implement
javascript but to lay the groundwork for
a generic dynamic language platform
support framework and just like ryan now
you can do hybrid java programming with
Mazarin which is the main strength the
reason why anyone would want to use a
java-based dynamic language in the first
place the scripting api java x scripting
jsr two to three I initially scoffed at
the concept of hybrid applications but
I've come to realize that it's quite a
powerful concept I mean everything every
time Jim does a demo I say wow that was
short so it's definitely married to this
and the nazarene executable is is
shipped with the jdk to JDS and you can
run it for the repple and try it out
yourself there's discussions going on
the mailing lists d'arthur endeavors and
lazarus specific mailing list in the
OpenJDK nmo vm dev is the mailing list
where we do discussions about multiple
languages turning the JVM into a
polyglot runtime a lot of focus there is
on dynamic languages so if that kind of
thing interests you I recognize you join
these main lists
and some Twitter tags usually nas when
an agilent ASR used probably the first
one more and various members of the Naz
a'ren team can also be reached and
Twitter for questions just quickly the
release schedule java 8 was the first
version of Mazarin for public
consumption a 220 which came out earlier
this year is security fixes and a lot of
work in the hotspot virtual machine
because it's far from everything in Java
that is needed the we can't do
everything in naz a'ren to facilitate
fast dynamic languages we have to be
really good at implementing it in hot
spot as well which is ongoing work that
I'm getting involved in more and more a
240 which is coming out next is going to
be a performance release with some of
the performance magic I'll be talking
about today will be present in some form
and Java nine more forward-looking
statements I think we'll see ECMO script
six support I think we'll c java flight
recorder support because it's very easy
to integrate flight recorder events into
anything and we pretty much got that
aspect out already we just get up take
the time and resources and i think
moving into an area multiple language
front ends possibly with the help of the
community I have a CC skye sec student
in stock on right now looking at
interpreting and executing typescript
with Mazarin and that looks really
promising it seems like the architecture
expands fairly soundly into other
dynamic languages m and n 1840s as i
said what i will be concentrating on the
performance work we've done because we
know that envelope dynamic works and but
how do you make dynamic languages of the
JVM fast using invoke dynamic and byte
codes and as I said before as well
people implement all kinds of alien
stuff it's not java compiler to bytecode
and run it and they have been doing it
since the beginning of java so the
reasons for that is of course that the
JVM is an abstraction layer that's gets
you so much for free you have garbage
collection automatic memory management
you have JIT compilers technology that's
like man decades I've been spent on to
execute bytecode fairly quickly you have
the hybridization framework you can code
java java square
to java dynamic language cross
applications very simply with with a
well specified API and if you look at
code basis this is Mozilla Rhino this is
naz a'ren and these are various native
runtimes for JavaScript was all
spidermonkey v8 you see that obviously
it's a big productivity win there's a
number of lines of code in respective
code base because we don't have to
implement in a memory management or jet
your stuff we will take what JVM already
has there and that's a good story for
anyone but me as it looks at what really
happens with invoke dynamic but at least
minute adding a lot of code so for the
end user and for the dynamic language
implementer the JVM is a really
attractive platform and seeing it turn
polyglot is one of the more exciting
things I know so two problems with
dynamic languages on the JVM most
dynamic languages not all of them have
wake types javascript has weak types you
don't declare integers in JavaScript you
declare variables that are a number or
something else and then have a grand
time linkage which in both dynamic is
here to solve invoke dynamic gives it
gives you constructs to connect like
function pointers you have a calls like
that points to location X someone
reassigns a function in a dynamic
language in front of time you can
reposition that call site to position Y
without recompiling an entire method
which had to do before or set up complex
dispatch table using say invoke
interface instructions or however you
express it in Java before which
basically costs you all hope of ever
getting performance you compiled code so
this is the main issue week types
because bytecode say call it platform
independent it is but it's also strongly
typed it contains exactly five types the
numeric types and object types because
it was written for serialized compile
Java and that's not a good fit for
everything so that's what we had to
solve and we also want to turn this into
a reusable solution for many dynamic
languages since the same problems appear
over and over the appear in Ruby they
appear in groovy they appear in well to
some extent in typescript where you pick
your own types only declare types if you
want to and so on so let's envision what
a random product evangelism will say
about nasrin today would say that it's a
fast one hundred percent compliant a
milk dynamic based JavaScript runtime
written in Java running on top of the
JVM fair enough and if I pick around the
future evangelist what I hope he would
say is that nasrin is a runtime for
dynamic languages on the JVM not just
JavaScript nasrin takes away the pain
and performance loss of bridging the gap
between language and bytecode types
object and code automatically adapted to
be an optimal fit in the JVM mold so our
dream is that Anna atilla Sega d my
colleague talked about this strange loop
a couple of weeks ago we want this to be
sort of an llvm thing for dynamic
languages of the JVM and we started
working with javascript because we
needed a rhino replacement and if you
solve JavaScript you've solved pretty
much every problem in the world when it
comes to horrible dynamic nature as my
friend Eric who said once you admit that
everything is terrible the universe
opens infinitely many doors for you too
terrible but it's our job to handle the
terror and your job to reap the benefits
of us handling the terror we've been
playing with typescript in the lab which
is pretty simple to extend nas run into
because it's just a superset of
JavaScript mostly parsing problems we
can feed it in the same type system and
the known types they go into the same
type system as well we've been playing
actually some with groovy in the lab as
well just for a day or so implementing a
very like force this groovy thing to go
through the parser and see if it
compiles and all other any obvious
mental model problems with with
implementing this as well and we haven't
gotten four at all but just let you know
that we we looked at it and we care we
kind of like our architecture so I hope
that we can look more at this in the
future if we can get more these--
students so the path to native like
performance which is basically running a
language on top of the JVM as fast as
you would in a native runtime like v8
where were we where are we going so I'm
going to show you some benchmark numbers
for the octane benchmarks they should
always be taken with a grain of salt the
octane benchmarks are
I call them the spec jvm 98 of the
JavaScript world and marketing and
product management people they like
benchmarks a lot but it's one of the
measurements that we have to show scores
so here I have two bars which in the
Java one palette or blue both of them
sorry about that the dark blue one is
RINO and the light blue one is nas were
on every released in Java 8 of
normalized it's all the scores are one
and Rhino is relative so you can see
that even the first invoke dynamic based
release of Nazareth it's much faster
than right now I'm pretty much
everything these two guys don't even run
on rhino because it was lacking
extensions just crashed because it
generates too much code or whatever and
where are we today now it says now swear
nine but just like a 240 has pretty much
always functionality in place as the
third bar the light blue one and I've
still normalized it on the 8th release
you can see that where many orders of
magnitude faster and pretty much all of
the benchmarks for for for a 240 already
so this is quite a significant gain in
in a little skunk works project that
we've been doing for the last 10 or so
months comparing this with v8 the native
runtime another bar also bluish we can
see that some of them are better like
crypto which is pure number crunching we
have to go into the JVM and do something
about tag values to get that to be on
par but most of the other benchmarks
were actually in the same ballpark as v8
which I find pretty impressive given
what we started out with and given how
much left we have to do on the JVM level
and I built the latest VA before the
conference just to do a fair comparison
the bleeding edge bits and as you can
see we're still some stuff has increased
but we're still fairly competitive there
and this is like a really impressive
effort if I may praise myself in just
like 10 months really hard work and we
also have avatar no JSE's is all the
rage these days so let's not forget that
project avatar has a couple of internal
benchmarks as tests workloads HTTP and
rest benchmarks and those are actually
in a 240 comparable to
v8 running the same benchmarks native
performance we have more improvements
slated for a 240 and beyond there and
we're also invented some exposed
mechanisms like the buffer array data
that uses ngaio buffers for for avatar
to use internally boring table but
basically this is node and this is this
lyrea thing is running nas burn and you
can see that the numbers are pretty much
the same for the same benchmark lower
than the same machine which is really
cool I mean this is in my opinion way
cooler than crypto number-crunching
because avatar Jas is a server-side
fairly complex app so even though last
year Pat had its moments of pain and
over time we came up with a secret sauce
note that I do all my own clip art to
avoid various intellectual property
reasons and so the secret sauce for this
performance all concentrate on is the
optimistic type runtime architecture
which is a Jap that you can read as Jeff
196 it's online if you're interested in
the internal workings at a more
technical level and we had to recognize
when working with dynamic language is on
the JVM that anything can be rewritten
at any time even built in classes like
math sign and getters and setters and
objects to change shapes at remove
fields so have this late runtime linkage
which we use invoke dynamic for and as I
said bytecode is strongly typed
everything needs to type in byte code
and not so in JavaScript so
traditionally people have been compiling
to bytecode reasoning like the JVM is
technically advanced as man decades of
jet optimizations in it I should just
serve it up byte code and it will
magically get this arbitrary bite go too
fast native code but it's not really
that simple because the JVM has mostly
been working with Java bytecode and java
bytecode is what it knows best and
optimize is best and also the type thing
so we realized quite early on that we
couldn't find the answer to our homework
on Google and had to reinvent our
structure ourselves so this is a
function in JavaScript taking the
greatest common divisor of two numbers x
and y and it would look pretty similar
in Java the difference in Java would be
that probably
int a and int B and you have
declarations for x and y otherwise it
would be virtually identical this is
JavaScript but it's the same algorithm
and the same semantics in the same code
in curly braces however in JavaScript
you don't know what happens when you
read a might have side effects it might
like throw exceptions because you've
overridden to number of conversions and
JavaScript you can't just say variable a
well in this case you know because it's
local but say X then X can be anything
and way to try to multiply X with
something in X's someone has done
something with X is to number function
you can you don't know and seeing this
the compiler certainly doesn't know so
in order to turn this into a native
bytecode that is compliant to JavaScript
I don't expect you to be able to read
this but it's quite a story you have to
have like JavaScript specific type
conversion libraries you have to convert
things to objects because you don't know
the types even if it's a number all the
way through you can't know that so you
have to treat them as objects just in
case and when you do the math operations
like the subtraction you have to do them
as doubles conservatively because a
double is enough to fit any javascript
number which at least you know you have
remote location but not an end so this
is this is pretty horrible if you
compile this java method with ins
instead it looks like this which again
you don't need to read but it looks a
lot shorter and doesn't have any calls
and if you benchmark use against each
other it's a factor 150 difference i did
this in my laptop before so you can't
just naively translate stuff to
javascript and you can't just naively
use object types for anything so the
answer if you want to use byte code and
we don't have the luxury to assume that
byte code will disappear anytime soon so
we will use invoke dynamic and we will
use white coats and we can't can't
really do anything else so that's a
target platform we need to generate Java
like bike cut as good as we can so it
looks the job as much as we can and we
have to work in the GBM switch support
things like invoke dynamic and
enlightening policies as better suit
this kinds of alien code as much as we
can so it's a bit of punching this
square blocks through the round hole
where the round hole is the bytecode and
the square block is JavaScript but we've
done the punching now we'll actually
have fixed the shape of this whole see
you can too if you use mouse work for
Lisa soon as your deployment platform of
choice for a language so byte code in
JavaScript we say if we have a number
but bite cut hasn't flowed lungs and
doubles that we use for numbers and
objects if you use box numbers so white
coat doesn't understand that x and y can
be anything if you see x plus y like
this it could be strings for all that
JavaScript nose and the bytecode knows
so conservatively you generate a call to
some some JavaScript add operation and
represent x and y's objects and even if
the fast case is true that there ends
just sort of boxed integer cyl take time
to unbox and compile and I know that
JRuby still uses for a lot of objects
internally and they have good
performance for some of the stuff they
do at least if you measure against MRI
which is native ruby implementation but
if you have to compete with say v8 like
we do everything has to be optimized so
it's quite a spur to to make things
efficient so we generate a sufficient
optimistic functions as possible instead
if we assume things are in if we can't
prove their innocence the compiler and
hope we're not wrong and every operation
like an addition where we add in
together has to be surrounded by an
exception check in the bytecode because
if we're on and we're not dealing with
in or the in TOA flows which if you add
too large ins together you might
overflow the 32-bit java Nate event but
still fit in a double things like that
have to be handle if they happen they
never happen but you have to handle them
so what we came up with this is a
mechanism to save the state of an
ongoing JavaScript method is executing
it's a continuation from where we are
and finished a method and then tell the
linker in a zone to generate a more
conservative version of the method for
example if you started out with int
guessing that you were working with
instant is greatest common divisor
example and suddenly an exception was
caught by the linker saying hey I have
doubles here in my scope there are not
in any more of this program point then
you have to regenerate the version of
the method that uses doubles instead of
int you can save the info on because
someone might call it with insulator or
its garbage collected I don't know but
you have
on demand generate a more pessimistic
method the original approach was to just
use objects everywhere because then you
could never be wrong and regenerate
anything so how did we implement this I
mean if you have a function multiplies
few numbers x and y are in scope which
means they're in memory the restorers
field somewhere the conservative
JavaScript again would be very messy
we'll have to do number of conversions
it would have to double multiplications
and things like that whereas the
optimistic version of the same method
will just assume that we're dealing with
int x getting getting extra memory
assuming that we're getting in return
value back the city about dynamic used
to retrieve any value from anywhere in
this type this is probably a field
getter if this throws an exception this
will throw an exception if we get
something that's not what we assume say
a wider type then we finish the rest of
the method in the continuation and call
a wider version of the method next time
but hopefully this is going to be an int
same with why we assume it's an int and
then we do a multiplication of two int's
we know at this point if we haven't
thrown any exceptions that we can do an
implication the reason we haven't
invoked dynamic here as well is that a
multiplication again if you have too
large in its can overflow and not fit in
a 32-bit Jolla need event setup I also
be a reason to recompile the method we
call these red there's these read
operations optimistic operations because
all of them can throw an exceptional on
failure and causes to regenerate the
method a wider method for this to work
hopefully this will never happen and we
tag these with program points in this
case one two and three that are uniquely
identifiable when you regenerate the
method because if a method breaks you
know which program point was wrong say
that the linker is examining an
exception that says something is wrong
with program point2 I got a double at
17.3 and it was supposed to be an end
then you know that at least this guy has
to be wider when you regenerate the
method next time so the ideal java
version of GCD is here again same into
your base byte code and the optimistic
Malzahn version which is too
us when we generate these here on the
right side and the observation we can
make here is that they're exactly
similar except that we have to invoke
dynamics instead of two I subs just to
handle the rare case that the
subtraction actually overflows 32 bits
this looks exactly like native compiled
java code of GCD right now in its
optimistic version which is pretty cool
you got that 150 factor speed up and
then you have some kind of exception
handling framework that I'm not going to
go into deep detail in you can listen to
my GV on my last presentation for
instance if you want to know more about
that last summer or the summer and that
will handle any optimistic operations
that might fail but ideally this won't
happen and we'll execute this the
subtraction is an intrinsic in the JVM
it'll boil down to a sub instruction on
the processor and an overflow check
which both are very cheap operations so
this runs exactly i mean this almost no
difference in the overflow check so this
is almost the same speed as the native
java if this optimistic version is right
which in this case it is because i'm
only using into my grace common divisor
operation so given that we never fail
any of our optimistic assumptions we
have very decent performing code that
looks exactly like Java code in many
cases and this is pretty cool we also
did some other enhancements to the
compiler for a 220 like liveness
analysis i'm stealing a slide from my
colleague attila from from strange loop
here it says that when it comes to types
in dynamic languages thirty percent you
have inherent I proliferation so you can
tell like a double always operate some
numbers that much at least you know and
seventy percent is Java scripts
brain-dead local variable scoping rules
and what this really means is that you
can't really tell what something is
usually at the compart compile time in
JavaScript or a dynamic language just
see X when you compile Java you know at
compile time that there's an end this is
double it says so right there in the
source code so you don't have that
problem you don't have to guess but we
have to guess in order to produce
bytecode that looks like Java which is
the entire key to performance it
targeting bytecode so liveness analysis
in the old Mazarin this is a simple
function it just sums up the values from
one to ten in a loop and then come cats
of concatenates the string test to it at
the end and we use one byte code slot
for X and that had to be an object slot
even though most of the time I mean if
this loop went to 10 billion would still
have to use an object slot and this ad
operation would be a boxing in the
unboxing of java.lang.integer see if we
use the same slot for X all through just
so we can put test there because the
bite could vary fire will immediately
throw a verifier if we try to use the
same slot for different types in the
same light range so again let's a byte
code one slot and a local variable I
that we could in fear was a double
because at least the worst thing we did
to it was plus plus with the numeric
operation that's what we did in enjoy
Mazarin and again the white coat is now
full of nth we have two slots for X two
live ranges which bytecode gratuitously
permits one of them is an int for these
parts and then it turns into an object
for the green parts of the code and you
can see that even the plus + in the loop
is this optimistic add with the
overflowed shake so this runs a lot
quicker and of course the longer you run
the loop the quicker it gets you get rid
of all the boxing and everything so
field representation is another issue
because eventually everything in scope
in javascript is not declared locally
has to be stored in memory in an array
somewhere in a field somewhere in a
class every object in nasrin is a script
object every JavaScript object is a
script object which contains a few data
structures among other things in the
property map which describes its shape
and by shape we mean which fields this
this object contains among other things
where to find them in memory if we look
them up scope variables and it also
contains a growing array called spills
which is also scope variables that don't
happen to fit in a pre generated class
we start out so like putting in a few
fields in every Java object Script
object class we have some
the store scope variables in but if you
have 3000 scope variables it's
impractical so it will replace the class
so we use the Spiller rate for our data
in memory and this was a lot of other
things in the script object like
something called array data that we use
if someone uses the object as an array
which is frequent of the case in
JavaScript so the script object has the
spell array it has a property map and a
machine generated subclass of this might
have this is naz warren openjdk eight
again might have four fields that he
used to store variables like X and Y
that we don't declare locally so we have
to find them in a class with a get
filled put field and the property map
for this my little something like this
we have four properties for an object
they're called red green and blue and
you should look for them in slot 1 3 &amp;amp; 0
or in the spill at index 0 basically
information where to find them in the
script of the class in these custom
generated fields all the property maps
are immutable and copy-on-write so when
any aspect change is to get a completely
new property map and this makes it
simple to add a guard to any dynamic
call site get or set or a call that's
just the reference check so if the
property map is different means the
object shape shape has changed and you
need to relink a particular getter
because the property might not exist
anymore or be in a different field so we
use this for almost all in both dynamic
coal sites reference card so if you have
a method that has a scope for which will
be a field or in the spill array as I
said not declared local aid can't be a
bytecode slot for a function f and you
do an operation on it and it was 17 in
this case what would happen in nos or an
eight was that we had to load the scope
for and which was stored as an object if
you remember my last slide and it would
be a java.lang.integer a boxed integer
if no one has done anything with it I
should actually have initialized it to
something because otherwise will be
undefined let's pretend it's initialized
to 21 or something and and then it
always do the and operation the
JavaScript specification says they have
to query some terms to int which in this
case means i have to unbox the
java.lang.integer
do integer value all or whatever it is
then I execute the eye and instruction
bytecode which does the end and then
Mike where's the result back to object
because I have to store it back in scope
for which is not a primitive nth or I'll
get a verifier and it will put feel on
the result and this for a simple logical
and which is like a cpu cycle that i
want to write to memory so it's it's
pretty hard and some of them might say
hotspot why can't you remove this boxing
and it's not hot spots fault it's it's
naz one's fault for using an object
field there is no way out but can remove
the bot the boxing if you store
primitive objects in pre declared object
fields it's not going to get better so
this is a little bit ugly we're working
on a JVM based solution but this is what
we did for a 240 and we had this spill
objects the map and the object fields we
added a primitive version of the same
fields we represent them as Long's
because along is 64 bits and it can be
used for floating point numbers as well
and then our getters and setters know
what type of field is and where to look
for it done it for the primitive field
of the object field and if you write an
object field or something previously a
primitive field you relink the call site
and you write it to the object field
instead so this is a bit nasty because
we waste 64 bytes per per object but
we're working on support for this into
JVM which hopefully we might do
something with a JVM time frame that
looks like tag values in most native
JavaScript implementations but right now
this is a very important building block
because you can be optimistic all you
want with local variables if you store
things in memory as objects you're still
going to just going to move that boxing
overhead around and it's not going to
solve anything so we absolutely
positively have to have something it
looks like primitive storage for every
kind of place an object will end up even
if it's a local object even if the local
bar then it's easy to take a primitive
slot for if it's a field or array entry
in memory then you have to have a
primitive place to store it so this is
an interim solution to make it work and
it turns out that the memory
overhead compared to other things to
take up memory isn't that bad and we
definitely got it back in performance
because this is second of three
important areas where we need to
eliminate all kind of objects and boxing
the third is the built-in libraries in
JavaScript and getting to them so
reading and in longer a double is always
to convert these from a long field 22
what you need storing actually and
reading them you can just use the double
long bits functions to convert the
double or and in cast these are all very
cheap operations and for the object feel
to write an object so this would if you
implement it and see the union with a
tag or something like that and that's
what we're trying to implement in the
JVM now in a limited scope was discussed
off and on on the ml vm dev list as
tagged arrays not sure if you're
following that but it could be an
interesting exercise you look it up and
we expanded the property map to not only
include like slot information and named
subtype the names of properties but also
their types so if you change your type
if the blue field is overwritten by a
string this woody validate the property
map because the copyright to get a
completely new property map if you
change it type any cool site that we're
looking in the primitive field j 0 where
it happened to me before or j 3 in this
case we now look in the object field as
long as we re link and change the
property map the same guard can be used
and we have no extra overhead so instead
if we store the Supreme ative object
this was how we used to do it we just
load the get low the variable get field
as a long do a long to int conversion
very quick microbe well one cycle do it
and convert it back to a long a story to
memories long and if we get JVM support
for this we get more and more into the
gym at JVM area this can be even faster
but this was enough to take away the
boxing overhead from scope in a 240
which mattered tremendously so we could
do this using unsafe maybe we try to
avoid those because we are the JVM we
shouldn't have to cheat in your own
class library but we need some day via
magic anyway and I mentioned
son tigra is one of the proposals and
maybe we can tweak the GC to get us
callbacks Rob dick changes like probably
v8 and like native run times do I
encourage the community again to discuss
how the JVM could support this better
for dynamic languages in the last part
as I said it's the class libraries or
the built-ins in JavaScript you have a
lot of built-ins like array push and
arrays and strings and string car at
functions like the JDK but smaller and
if you read the JVM spec which is is the
most horrible retrofit I've seen in my
life to something that obvious it was
already in place when it was written you
have to do a lot to implement stuff
correctly this is push look quickly it's
a lot of code to implement push
semantically correct for an array in
JavaScript you don't need to read it's
just I can see it's a slide full of code
and this implements push ECMAScript
compliant as you can understand this is
very slow it push even takes or
arbitrary number of arguments which in
this case produces an array behind the
scenes boxing and unboxing objects even
if you were maybe pushing integers and
so on but these days we can do a lot our
real incre for instance can be made to
relink a javascript call site if it gets
an exception for a switch point which is
another handy mechanism in java.lang
invoke that useful dynamic Cole site
relinking so an array get your these
days for instance is very simple we just
ask for like the method handle framework
to give us a an element getter an array
call a get function of an index and what
we do here is we assume that we're
dealing with an array that is
representable as a java array that's the
best case in javascript but you can
represent anything as its Java
equivalent that's fast and you usually
can if you have an array with ten
numbers from index 0 to 9 like that are
in it's a perfect Java inter a if you
start assigning index 27 billion it's
perfectly legal JavaScript but it
doesn't make for a very good job array
because you'd run out of memory so you
have eternity this kind of map structure
but witness logic does it basically
assumes that this
I is a continuous rates in this from 0
to n and you can just get an end X from
it and if it isn't a classcastexception
will be thrown at runtime and the call
site can be relinked so we just tell the
real ink or that if these switch points
are invalidated these guards fail or if
these kinds of exceptions are thrilled
relink so we can use a lot of the
inherent type checks in Java that have
to be done anyway in the bytecode and
thus take no more time than the
equivalent Java native code would do
where java bytecode would do two to
relink our call site we can use the
logic already inherent in the java
bytecode check casts for a validating
cool sites so we can turn this guy if
we're only dealing with in pushing one
int into an array into this guy which
looks much nicer and notice it takes a
primitive nth as well so there's also no
implicit boxing there which was the case
before when we did this call so we have
a couple of versions for the different
primitive types and this increases
performance tremendously so now we've
eliminated the need to box and use
objects on type objects everywhere so
provided that are optimistic assumptions
hold and we don't have to invalidate and
regenerate the method this runs pretty
fast now there's lots of candidates in
the JavaScript class libraries that we
can specialize like this array pushes
and pops and string operations and math
operations function apply is something
that people use a lot in JavaScript we
can turn that into function call which
doesn't need to box an array and saves
memory and we can use the same
recompilation framework for native
methods which is in our case means
built-in methods like push as for
javascript methods we can throw an
exception saying something withdrawn
pessimistic in the middle of the method
and have the linker well it can't
generate a continuation bytecode of the
rest of the method from with the
exception happens but it can restart the
method as long as it has functional
properties and has a modified state and
this with no extra codes we can use the
same link or both for Java code in
JavaScript code to make up the mystic
guesses in our runtime here's an
anti-pattern the JavaScript programmers
love
when they don't have classes they create
classes they have a class variable which
returns to create function which is a
function that calls this dot initialize
which is the constructor doesn't apply
on this under this method with the
arguments passed in which are arbitrary
0 too many and then they have some kind
of color class that they think is neatly
abstracted and when you do a new color
this will return do a call to apply with
whatever arguments have put in there
which behind the scenes will be put into
a JavaScript argument objects an array
will be allocated they will be boxed two
objects because that's how we represent
the array you pick it apart you have to
prepare the coals likely apply you have
to create method handle collectors or
spreaders or whatever they call the
process an arbitrary number of arguments
as in general it's really horrible just
replacing the supply with a call
specialized in this function to take
generate version of this function to
take three integer arguments for this
particular call site passing them in
their call is apply but without the box
in without the array just pass the
ellipsis you can get like a factor 50
speed up so that's pretty cool we can do
things like that too there's a lot of
JavaScript the tries to look object
oriented and nice and really turns into
more of a nightmare there's also other
optimizations in and outside the JVM I'm
going to go a bit quickly among them we
do partial evaluation to some extent
they're basically we treat anything as a
constant and any getter of anything any
property as a constant saying this will
never change and then we have a switch
point which is a mechanism in java.lang
invoke and a synchronous mechanism to
invalidate this assumption if it changes
we assume that the field X is 17 and if
someone writes to X will never assume it
again because it's going to be expensive
to keep assuming that it's one thing but
if we are a constant if this X of length
turns into like a method handle constant
just the method returning a constant
value hotspot will hoist it out of the
loop pottsville we know it's loop
invariant and we don't have to do with
thing above loop optimizations so this
is pretty awesome facilitating the JVM
to do stuff like this just by setting up
the method handle
the correct way we can even use a
receiver guard to have a few constant
checks but it seems to be not worth it
and it's harder to debug but it was
quite also when I realized that I action
if you do things I don't need to write
my own JIT compiler woohoo i can
actually make hotspot use java
optimizations if I just serve it the
bytecode and the method handles in the
correct way we use nya for things like
type the race which is an ECM a6
extension that we support and depending
on the micro benchmark got some really
good improvements there export to the
mechanism will buffer array that avatar
used as well a JavaScript built in using
nya directly we did a lot of stuff in
the JVM improve the type checking for
dynamic language code math intrinsic so
you get this additions and subtractions
with an overflow check if you call
java.lang math at exact which
corresponds to a javascript add it's
actually intrinsic I'd just to assembly
instructions these days we tweak the
inlining a lot because the dynamic
language cold site consists of many
small methods that needs more aggressive
in lining this is ongoing work we're
probably going to have to change the
internal representation of how coal
sites are generated because we see class
generation overhead with these internal
hidden classes called lambda forms in
the JVM we've experimented with partial
escape analysis and boxing removal among
whole sites which is something that
worked fairly well in the jrockit JVM
for indie scene bokeh dynamics so we
have good hopes that we can remove a lot
of cold side overhead for this as well
and we experimented with uncommon trap
placement in hot spot doing it much more
aggressively co that's rare and never
executed isn't generated and the smaller
the code mass the better hospet works we
had to beef up a lot of stuff the
java.lang in vogue vogue library we're
trying to make it more generic so we
won't even need specific method handles
for specific tasks there but generate
them on the fly / coal site this is
ongoing work that won't make it into a
240 catch exception turned into a very
hot one because every optimistic
operation is guarded with a method
mandala we set up using cash
exception which is the try-catch pattern
as a master handle and it turned out
that it created I think object the race
for every coal site so we were a bit
concerned when we ran the first version
of optimistic typing before we can point
to this but now it's fast or at least
not so fast path startup performance
call site performance and teaching the
jet about dynamic calls i flirt works
it's one thing the hots but isn't the
world placid at yet is invoked dynamic
because its newest feature but we're
falling crs every day and we're
discovering things every day so there's
finally a lot of good JVM work going on
there I said math intrinsic is already
and we've done more than implement
languages we facilitated proof of
concept that invoke dynamic in general
nasrin has created so much in vogue
dynamic related work the JVM nose in
which direction to go with this and
invoke dynamic is not just used for
dynamic language is used for
implementing lambdas it's used for more
and more things so it's important that
it's fast and by it isn't going to go
away so there's so much more I want to
tell you but I'll have to end it here
feel free to catch me this week at the
conference I have to talk a little bit
about the price at least right now that
we're paying for this and as you can
imagine it's warm up because if we fail
optimistic type guesses we generate new
code so until the system is stable we
never go back to a narrower type so the
system will become stable eventually we
generate new code so the need to
recompile on people reach the steady
state has increased were mackin startup
time for an asura for a 240 so we have
some tricks to get around that when we
get a rewrite exception which tells the
calls like to relink because the type
was too narrow we look at the scope and
try to get out all the known runtime
types out of it so we don't have to
recompile one call slide one call so at
one whole side rather every calls like
we have type information Alma to give an
exception we have heuristics so ax isn't
recompiled ten times because it's likely
to be the same type they're currently
disabled we have lazy compilation we
only compile what is about to execute
otherwise we don't touch it which
matters because even parsing takes time
them will probably look into some kind
of profiler that goes over the AST type
tree in the future but it's not here yet
so lazy compilation here is someone
calling GCD from the beginning of my
presentation and that means GCD will be
generated if you remove that call no one
will generate GCD it will not exist to
nazrein which alleviates startup time a
little bit because methods early compile
and demand so we we maintain minimum
info for a method unless you actually
call it and there's also a mechanism
involved if you work with optimistic
types enable in a 240 and find that your
warmup is getting too long to be
acceptable if you're executing the same
code we have something called a
persistent code cache in a 240 which
stores serializes all generated code to
disk along with any optimistic type
assumptions or missed assumptions it
stores the entire state of the system
after warm up or continuously stores it
so if you restart the system after if
it's steady state it will deserialize
this from disk and will be up like this
the complex applications like avatar for
instance okay the file is very useful so
this will be in a 240 already however of
course not the first run will be
affected by this so I mean if it's
unacceptable right now disable
optimistic types or or wait until we
solve the problem because we working on
it right now we're in finding what
low-hanging fruit right now that will
get into a 240 but the next release will
probably have a more generic solution to
the initial warm up problem but already
with some code cache you can work your
way around a lot of it and still get the
performance that we working so hard for
so final section is the future and and
I've already told you what the future
will contain in my vision I I like Java
flight recorder job flight recorder is
the ultimate profiling tool I use it
every day for Java for an ass run for
other things and j4 for those who don't
know it is very customizable it's easy
to write your own Java flight recorder
event
with your own event producing API and
you can do that with the open code base
that's not propriety Oracle stuff so we
have a unique I mean this is weblogic
we're seeing here wld f weblogic has
written their own flight recorder
plugins to instrument things like SQL
queries a long time did it take what was
in them and we can do the same for
JavaScript so we have a unique
possibility to create the JavaScript
profile that no one else can do because
an asura JavaScript method is just a
java bytecode method as far as the JVM
is concerned with local variable tables
names line numbers and it fits already
into the j4 framework but we could make
it even more visual and we could export
events that are only true to a
JavaScript or a dynamic language runtime
2j far and there's more events and you
can shake a stick at like this is what
we brainstormed 30 seconds the events
that would be really useful if you're
debugging a JavaScript application this
is a metamorphic cool site it's called a
lots of different receivers different
types here's a type widening this is
like a bytecode size warning near as a
method in validation code splitting was
made because this JavaScript method was
too big to fit in the 64k bytecode limit
that the java method has if i had all
these i would like Quinn to pull my
productivity debugging nas were alone
and it's not that hard to write them is
really simple to write J for events in
any application so you should try it
even if it's not dynamic languages
you're working on so the future I see
avatar that's the node thing in the Java
EE cloud I see a lot of JVM support it's
better for dynamic languages jdk changes
I see nas weren't gradually turning into
your dynamic language toolbox and not
just a JavaScript runtime and I might
even see hardware changes will improve
me that integer add with overflow in
hardware stuff like that so I mean it's
been one of my hardest most work
intensive years as an IT professional
and I've been rightly professional for
20 years well we've got some good
numbers show and and then feels pretty
good too to stand here and tell you
about our progress and if you're
interested in the in the inner workings
the details of optimistic typing
validations and scopes and how we do the
continuations tweet to me and i'll send
you links to two other presentations or
i've gone in 20
details about that so thank you very
much for listening I'm sure if we have
time for questions I'm just out of time
I think but go for it yes yes and I
haven't done a lot of footprint
measurements in 18 v8 is actually quite
memory hungry and nasrin is actually
quite memory hungry too we're finding
more and more situations where we can
easily get rid of footprint footprint
right now tends to be things like
classes meet a space in the JVM it tends
to be structures left on the heap and
things that don't have to do with
javascript object layouts JavaScript
objects are a very small fraction of the
heap if you do an analysis I'm not sure
if Jim is anything to add about
footprint now so right now I'm not too
worried about it but yes it is memory
hungry so is RINO actually and
continuous improvement there this this
first of all we had to do the
performance race any other questions yes
if we can't deduce what it is we always
start with integers if you see that this
is used in the multiplication then it
has to be at least a double if you see a
declaration locally yes we get whatever
static information we can after the
compiler it would be stupid to throw it
away because it helps but otherwise if
we don't know anything we just guess
it's an int if it can't be an int if we
see that we've concatenated with a
string we don't need to bother because
it's going to be promoted sooner or
later anyway so we try to do it
intelligently but still every failed
guess is warm up time so we have to do
this intelligently yes yeah we have
where separate class those who actually
should have we discovered a shocking bug
to daily fix for a 240 but yes and but
we also keep them around for a bit if
you have coal sites that might be the
case that you call a method within its
in one place and with doubles in another
and then it makes sense to have two
different versions of the method of the
same method because if one it reduces
megamorph assists know the coal site and
to both of them are optimal for its call
site implementation yes but both both
bull versus and methods will have the
same me to information for the debuggers
if the debugger it will look the same
however if we mess up you will be
confused but that's our problem all
right no more questions thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>