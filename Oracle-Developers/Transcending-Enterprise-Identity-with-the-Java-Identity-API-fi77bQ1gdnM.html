<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Transcending Enterprise Identity with the Java Identity API | Coder Coacher - Coaching Coders</title><meta content="Transcending Enterprise Identity with the Java Identity API - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Transcending Enterprise Identity with the Java Identity API</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fi77bQ1gdnM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for coming everybody my name is
Ron mongillo I've been working on this
project for about two years now with
other people I thought a few of the
expert group members would be here today
but I don't recognize anybody if you are
just the stand introduced yourself when
you get a chance and I have a lot of
material on these slides it I wouldn't
say that it's all I can't guess that
it's all pertinent to you guys so I'm
going to go through it fairly quickly
and try to save time three guys that
asked me what you'd like to know about
and so the title is a little bit bold
but our idea is to make it easy for java
applications to consume network identity
and to actually contribute network
identity as well and i'll try to
describe that and more detail this who i
am some of you know me I i was with son
before oracle acquired us i was the java
security architect for many years now
I'm I work more in the oracle identity
organization with some old collaborators
my group is composed of people that I
worked with in standards before that so
we have a very interesting a job right
now so the agenda is i'm going to show
you our architecture or some programming
mop some programming examples and show
you a little bit about their reference
implementation that's really the main
gist of the topic and i'd like to hear
what you guys think and we'll try to
save enough time for that at the end so
what you will get out of this
presentation is an introduction to the
project and its information model which
is very simple but you know it will help
you think about what we're doing and how
you might be able to help us improve it
i'm going to preview the api and try to
give you a basic understanding of what
it would be like to write a pro
with this API and I'll try to give you
some links to where you can find us and
I can contribute so this is the
introduction I'll skip this part you can
see that i'm going to do a little bit of
a history here i'll try to go quick here
so it's painless so it was approved in
just after a java 12 years ago the first
expert group was in november of that
year and we've been meeting since then
there's an early draft that's prepared
and ready for release but we needed some
internal approval within Oracle at which
we received yesterday so that will be
coming out very quickly it's a very
brief document in terms of has a lot of
boilerplate stuff in the document but
mostly it's just an encapsulation of the
API actually a link to the API so it's
just the proposed API but that's what
our early draft is and we'd like to have
a final release in june I I used the
word anticipate or you would like that's
the plan these are the expert group
members and other contributors I noticed
a Wernher kiel entered the room I don't
know if we have anybody else here from
the group we have a fairly broad range
of contributors this is about licensing
I'm going to skip this all right but
it's basically an open source project
it's available on java.net you can see
the work even the specification has been
checked in there which I'm not exactly
sure that I'm everything is okay right
now because I'm waiting for another
summon you to bless a license but that's
the way we're doing business so the
objective of the API is the client side
java framework so we use the word
attributes uriel to hear our terminology
attribute service etc but we're really
trying to make interfaces for java
programs to consume identity and to
produce it but they're not really mostly
focused on being a service provider as
much as they are
being a client of distributed identity
repositories well the main assumptions
that drove the API is we don't believe
that there there is any standard for
this information it comes from lots of
sources there's lots of protocols
there's lots of authorities for it so
we're trying to essentially create a
unifying API to make it so Java
applications can consume identity put it
in a common representation form we're
also working on our on the programming
model to try to make it be consistent
with modern ideas based on things like
dependency injection annotations being
used to clear dependencies that are then
resolved at runtime based on techniques
like intercept there's dependency
injection etc and this isn't a vault
where we wanted to apply is actually an
involving area at first we are really
focused on java SE and to make this
available to java ee applications as a
layer so it's not something that we have
to wait for for the next release of EE
it's just a technology that works in an
environment like that now we're focusing
more on making sure it also works well
in consumer devices so we'll stop me
mention well it's probably not going to
be relevant before
and we embedded 9 but the speculate of
the ME embedded eight expert group also
mentioned something is that direction
would trust identity and purity where I
guess this makes a nice yeah so this is
a very early slide but this is probably
the the easiest slide for you to get an
understanding of what we're doing so we
have a very simple information model we
have entities and they're just
collections of attributes that pertain
to abstract abstractions that you're
interested in whether they be persons
computer services documents etc and one
of the one of the important things is
that these representations these
collections have they're essentially
collections of characteristics right
which we call attributes the attributes
have values and they also have metadata
information such as where they where the
data comes from how long it's you know
who's certified or who's who's issuing
that data so so that's what the next
paragraph is about metadata conveys name
property values within the
representation and then a very important
part of our model is we have references
for entities and attributes so that we
can exchange information identities
between systems without exchanging the
values which is a very because because
it's important this is this is there are
privacy concerns with this information
it can't just be a value based system
that's the maybe if there's one of the
key takeaways is understanding that's
what our model is and that we're trying
to create the simple model for common
representation and exchange by reference
including exchange play value so we have
services defined within our architecture
and I don't I don't know what the best
way to read this slide is but really we
talk about the attribute service is what
you see within your client application
but it's actually built from layers the
lowest layer is a repository which is
really an agent that knows how to talk
to to an identity source or sink or
whatever you would like to use for a
term of place where there's data
identity data an agent is a pluggable
component that knows how to talk to
specific types of identity repositories
it speaks their protocols and on the
topside it integrates into our
architecture an attribute provider is
the part of our internal architecture
within the attribute service that
understands how to talk to the
repository agent and it performs certain
services on behalf of that agent to make
sure that the information inside it is
handled in a secure fashion for example
and the attribute service is sort of the
composite you know the top level element
that contains these which I think
there's a little more detail here oh so
we have this this reference model and
there's really four types of reference
in the references in our architecture
there are attribute references which are
on the bottom here those are the things
that you'll you can extract from the
attribute service and those are handles
they're durable handles that you can use
to go get an attribute you can't get the
attribute just because you have the
handle when you go to whatever attribute
service in implementation you have in
your environment you just create one
basically it's a that's something that
we provide the implementation of it will
determine whether you have the
permission to dereference that reference
so that's how we exchange information
without necessarily exchanging value and
entity reference is just the same
construct but for the logical collection
attribute and provider lookup context is
the way so every one of these the lower
level the entity reference in the
attribute references are bound to an
attribute provider and the provider
lookup context is the reference that
essentially binds these attribute
references to a provider that can
satisfy them and the highest level piece
is actually the lowest level piece of
the reference architecture it defines
the binding to a
repository and a specific instance of
that repository so this whole system
binds together if you will through these
handles to allow you to refer to
identity information in an disparate
repositories but I'm going to try to go
a little quicker here we define this API
based on five motivating use cases the
fifth one being a hybrid of two of them
and the simple one is we just want to
have a client application be able to
consume identity attributes the second
one is that we want the application to
actually be able to expose its
information as identity information so
it tend to in effect become an attribute
provider in our architecture or or
perhaps better an attribute repository
and then we as I've described we wanted
to be able to exchange identities or
propagate them in an important use case
is when an authentication system runs
and decides who you are we want it to be
able to express who you are based on the
the types that we've defined and so we
want to describe how that's done and in
the last case what's really happened is
the authentication system has bound
information about you in the Java
authentication state perhaps the java
access control context which is the
standard wave at stone in java and we
want the information within that context
that access control context to be such
that you can use it to go fetch
additional attributes about the user and
this is this is the case for example if
the system that was consuming you know
you you authenticated to a service the
service now has a reference essentially
to your entity now they want to get your
zip code or your birth date or something
like that they can use that entity
reference and they can ask for an
attribute reference corresponding that
entity and dual and try to dereference
it if they have their authorized to do
that that's just to give you a
high-level sense of how it works an
access control system an attribute based
access control system may need atrophy
it's about you and rather than having
you collect all the attributes they
might need because you can't anticipate
what their policy is we're able to give
the the access control system a
reference to you to you as an entity and
then they can get whatever attributes
are failed so those are the high-level
use cases the approach was the standard
representation for identity attributes
in Java promote the attribute services
appointment or eight interaction and
then to try to promote a higher level
programming model based on you know
declarative constructs annotations and
as well as a as I mentioned earlier
dependency injection and interceptors
etc so I'm trying to make sure we get I
think I have too many slides so so to
talk a little bit in the next part we'll
talk about the app the service
architecture of the attribute service
it's composed of three services and one
of the things it does is it provides
virtualization teachers over a bunch of
identity repositories you can compute
their certain combined operations that
you can perform to be able to construct
essentially an abstract a virtual
repository over lower level ones and
then I'll try to talk about the identity
protection model that's the area where
most of the work is going on right now
so the attribute service is a point of
interaction governance and
virtualization that's what I tried to
say in the last slide and there's
various services that it it will impose
on your interactions with identity and
the point is that if you write your
applications to go through the identity
the attribute service you'll be able to
say that your uses of identity conform
to the policies that it it enforces it
as opposed to what we have right now is
nobody really knows how people are
acquiring their their information
there's no real there's no real
government so it isn't there's no way
that we can force applications to do
everything through our attribute service
like you could get eval
called the digital whole you get a value
you can write it on the wall in your
your room you know people can get that
information in various ways but if you
use our interfaces in your programming
model then there's a certain
understanding of how information is
being exchanged so the other thing is
you need to know where the information
came from so the attribute service can
coordinate the different sources of
information and give you authority of
representations of where values are
coming from it also can as I mentioned
earlier can keep track of what identity
you're consuming in your application
right so that's its purpose and the
three services are 24 well there's this
top level one is basically at spi it's
how agents are integrated in the
attribute service and that's called the
repository agent registration service
then a provider lookup service is the
way applications acquire the providers
to meet their needs and a lot of that is
abstracted for you in the API and the
third level of service is once you get
an attribute provider the attribute
provider is split into a few different
types of services and you can ask for a
lookup interface you can ask for an
update interface you can ask for
essentially predicate building
interfaces I'll talk a little more about
that these types of interactions are the
low-level program is the low-level
systems level programming model a lot of
this stuff is hidden when you use the
higher-level parts of the API so the
service provider architecture I briefly
mentioned that the repository agent was
the way you you so let's say you wanted
to have a the ability to interact with
Facebook as a repository there would be
a repository agent that's integrated in
your attribute service that does those
interactions and the provider lookup
initializer its purpose is just to make
it so that when you start up your
attribute service those things are
pulled in it's a CDI mechanism that does
that and it's a it's a user's repository
injection I mean I construct
objection I think I showed an example
here but the details so every
implementation of something that
implements the provider lookup
initializer will be run when will be
passed into the your your implementation
of the attribute service there you see
the word nobis for the first time Novus
is the reference implementation and
that's the Novus attribute service being
instantiated right there so let's say
the provider lookup context I mentioned
this is this is a I think i've probably
said enough about why it's here it's in
its embedded in predicates attributes
entities and attributes a--'s entity
references and attribute references it
its what binds all those things to an
agent that can can interpret them so
there's a simple model of composition of
provider look of context and that's the
way that's the basis of attribute the
provider composition I think these are
this is essentially the the types of
providers including the composition
model there's leaf providers and there
they leave provider lookup context and
they just refer to essentially an
attribute repository the bottom level
thing that was integrated they refer to
the agent that can get you the
repository that you're looking for an
entity selector is i'll talk about
selectors in a little while a way to
essentially do a projection over
repository say I want a positive that
only has these entities in it the ones
that satisfy this criteria the union is
just a commune oh add roopa an
aggregation of two providers because you
want entities from multiple sources and
then we have essentially the ability to
do a join these functions are
implemented within the virtualization
layer of the attribute service so you
don't have to implement this you just
get them and the role of the attribute
provider the attribute provider you
don't implement either it's part of the
attribute service that
acts with the repository the attribute
repositories and its deals with making
sure there is a common service
protection model above all those
repository agents it makes sure that if
they jeans don't I mean the repositories
don't assign metadata that it makes sure
that whatever metadata is appropriate is
a sign I guess that is not there so that
services protection model is based on
the java SE permission mechanism and
there's a permission that the layers of
the attribute service check to make sure
that you're authorized and then the name
of the permission is a you know it's an
attribute repository of permission with
the name being the leaf provider that
you're up operation will ultimately
operate on and when you operate on a
conflict provider you need that
permission on every leaf and then
there's a utility this is probably not
relevant but the basic idea is this
permission is used to determine whether
you can get access to interfaces and
then whether or not you can perform
operations on those interface and then
there are two other somewhat more
difficult to describe levels of the
security model there's the content
protection model and that is whether or
not you have access to a specific entity
to a specific attribute and this is a
more complex because it depends on the
technology you know sometimes the
backend respond will tell you you can't
do things unless you have credentials
the attribute service itself is going to
acquire credentials so that it can
operate on those sometimes it will
operate using its credentials sometimes
it will interact with you to get
credentials so that you can interact
with the backend system and so the
combination of what's done in the within
the attribute provider layers and what's
done at the backend attribute repository
defines how content is
and in the backend systems as I
mentioned they have their own models
they can be very different there's as
many of you probably know there is
evolving support for things like getting
your authorization to see your
information at runtime so the attribute
service and the provider is above it or
seek to create a common interaction back
and forth to the application the client
of the attribute service for credential
exchange all the way back to the feckin
repository in one of the one of the
special cases is when your application
is an attribute provider and in that
case more of the content protection is
actually internal so part of that is to
allow applications to be able to define
that model so I'm going to just show you
briefly a picture of what I've been
talking about so you can see the
attribute service on the left there we
we just tried to put this together
quickly and you know service requests
are going to the attribute repositories
those invitations are not expected to be
remote you know that's likely to be sort
of all within one process there and
there's a there's a repository agent
that put those attribute repositories
that that instantiate those attribute
repositories within this attribute
service and then you can see the
repository making requests to the
repository on the right and it has an
enforcement point there that's what you
know it has it requires certain
credentials etc and so this is the model
that we're trying to promote and you can
see there that in the one of the
facilities the attribute repository will
need to know what tokens it needs to
talk to the backend system and it will
interact with the attribute service to
acquire those tokens
think if a government agent wants access
to the content as you also have to ask
the system for permission that's our
different that's a political question
you know thank you there's no way for us
to talk to to control their pathways to
data but through our pathways the data
we wouldn't be treating them differently
so programming model an API i'm going to
show you some concrete examples now we
have programmatic interfaces we have
examples of lookup provider by
annotation and content protection by
annotation I was going to put here but I
left it out we're still working on that
so as I mentioned did I go the wrong way
here
this slide looks out of place we'll just
skip that so here's an identity
attribute what it looks like is very
simple it's a collect so an attribute
can have multiple names that's probably
not something you would necessarily need
front your attributes that multiple
names but it turns out to be fairly you
know a useful for attributes not to be
forced to have a single name that the
attribute value type is itself a
container for the value the value can be
missing inside that container it can be
multi valued it can be single value the
objects of value or Java objects were
not limited to like scream types etc the
property map is just a collection of
single named properties like issuer and
then its value and the reference is
we've talked about that's a very
important thing so when you have an
attribute you also have a reference to
it so if you want to you can give that
reference to somebody else so that's our
simple representation of it any actually
one of the nice things if you want to
put this inside a job of principal you
just create a principle that also
implements this interface and from that
point on there's a lot that can happen
with relation to the attribute service
so the attribute lookup service as I
mentioned is a sub service of the
attribute provider and this allows
somebody who wants to directly interact
with it to do entity look up you can do
the lookup of an attribute of an entity
you can get the absolute reference of an
entity you know and these are the
specific queries you can briefly see
that there's the use of an attribute
selected select or type the entity
selectors in the entity look up I'll
describe that in a minute and you can
see that in the attribute event if you
look at the passing an entity reference
that scopes your query then you use
selectors to indicate what attributes
you want this borrows a bit from JP a
we're trying to simplify things because
we have some problems here we can't
expect our remote repositories are
external repositories to understand a
very rich predicate calculus they and
they do things that are hard for us to
do in predicate calculus for example
they do keyword updates where they have
some heuristic algorithm that matches
values which you know you know it may be
documented somewhere but when when you
use those facilities you can't express
that with a predicate so this is this is
one of the areas where it's very
powerful at one level but there are
limits on how it can extend all the way
through the system so I'll bring that up
at the very end so I mean I get that far
so selectors predicates and expressions
this is a just a high-level description
most of us already know these things
it's a slightly different perhaps way of
expressing this just so that it fits
within our our API so the expressions
are statements about error attribute
characteristics as you saw attributes
have names they have values they have
properties so we can make statements
about the properties of the
characteristics of an attribute then we
can create a predicate that essentially
is is a boolean result a certain type of
test of those expressions like you know
is its value greater than this other
value etc or is it is is the app does
the attributes satisfy these leave these
is conjunctive test so if different
kinds of predicates and then we have
selectors which is a special kind of
predicate used during attribute or
entity look up and the reason they're
special is because they've been
restricted to only support the types of
lookups that are based on that we don't
support any predicate lookups based on
proper I mean any entity or attribute
lookups based on property values I'm not
saying that exactly right but we've
essentially restricted what the
predicate space is for operations that
are likely to be on
more repository so just to make sure
this is clear our attributes are just a
bag of attributes and they're not they
don't have like primary keys they exist
somewhat independent of what their
attribute values are and that's
necessary because otherwise we could
refer to them if we had to refer to them
and you change the value of that where
you were using for a reference we want
that reference to be durable and you
know one way you could say that it be
durable as we could say it was a primary
key but we don't have those luxuries to
make constraints like that on what our
entities are so the attribute updates
service is very similar so there's built
there's lots of methods but you know
create an entity add attributes add
properties rename removing cetera so
those are not every provider has to
support both of those interfaces one may
support only look up for example
probably more common these are the
annotations that allow you to write a
program to to interact with the
attribute service when you use the ID
entity annotation you're basically
marketing your class as a receiver of
attributes and what'll happen is every
attribute every field public field that
you annotate with ID and I mean identity
attribute the attribute service will
fill values for those attributes into
your entity and the way it does that is
it has to understand it has to know how
to find the entity context the entity
reference that applies to that logical
injection whether it's done by injection
or by interception or whatever and an
identity provider is the opposite you're
creating essentially an entity that
you're making a provider an attribute
provider and within the attribute
service there's a there's a subsystem
that keeps track of all the instances
that you
to be entities and we designate the
instances by saying I De'Anthony
provider you indicate what attributes
they're going to explore and and then do
you assign at values to those fields and
you know that that entity is part of the
attribute service now so other parts of
your vm your large application can refer
to those values so those are functions
that are implemented in the novus
attribute service today I think I'm
going to show you some example the
application consumes identity attribute
values the entity provider example how
you would write that how the
authentication system might bind an
entity reference so then and then this I
make sure I'm doing the last one there
I'm just I think showing you how to
dereference a reference so so this is a
this is a receiver by annotation I
mentioned that earlier it's very
straightforward the etiquette the
attribute names are generally taken from
the field name but you can override the
field name and
the attribute service will fill in the
values from the backend repositories the
way it does that is by knowing the
entity reference and then it knows which
providers it has to consult this is an
attribute provider this is the inverse
of that case in this case you're
exporting these attributes and you can
see I think in both of these you can see
that you can have the entity reference
be included in the object so if you want
to give somebody else that value for the
entity to the entity reference because
you know it's coming from the system
various ways it may come from a caller
you may actually have that's a system
where because you have a call or the
other call or principal effectively
you're able to derive an entity
reference from that caller principal but
when you give it to other parts of the
system you want to make sure that they
know what that reference was you want to
sort of capture it there and you can see
that doesn't that in principle that
doesn't leak out identity values that
referenced there are problems because we
have to worry about you being able to
correlate references to values that
you've seen earlier and we're trying to
deal with some of those issues so this
is a how an authentication system might
do this and it just has an entity
reference and it puts it as a principal
and a subject and so there's an example
of a principle that that is an anti
dereference principle once that
principle is in the subject the anybody
who gets that principle can use it to
get more attributes about the
authenticated user so that's
conceptually at one simple way that this
is yours this is a
this is very similar so let's say the
authentication system created that user
object on the on the you know that's
shown on the left that's an identity
provider so you could write your
authentication system to construct an
instance of user that was annotated with
identity provider and you see here user
equals new user when if if that's done
with an interceptor know this provides
an interceptor to do that and it also a
factory in green on the bottom it shows
that happening with the nobis factory
CDI injection is also a possibility but
we'll just focus on these two cases
because these are what notice those
right now so essentially what happens is
when you instantiate that entity
provider it fills in you know it it
becomes an entity not an attribute
service then as you can see here you say
set the user attribute values so you
have setters on that to set the internal
state of that entity and now when you
get an entity reference for that user
dot entity you see the red reference
that that allows you to have the entity
reference for that you bind that any
reference into the into the subject I
think buying entity reference was on the
previous slide or just put it as a
principal on the subject you now have
within your running vm you have often
been authenticated user object that if
somebody wants to refer to it a later
time they can get whatever attributes
were put there so look up attributes of
authenticated user I just wanted to show
you how that how that works so
authentication establishes entity by
reference you saw that and perhaps that
entity is in get user principal now that
principle is then you can request the
attributes of use are either by use of
identity app identity attribute as I
showed you earlier or you can do it
programmatically by interacting with the
attribute lookup service and I just
showed you a high-level query to do that
you just say attribute you get an
instance
the attribute service showed you earlier
how you can construct an instance of the
Novus attribute service and you just say
get attributes for that entity reference
if you're allowed you'll get all the
attributes or whatever ones you're
allowed to get you can ask forget all
the attribute reference a very simple
tribute to the idea is that simple
interaction should work for many
different repositories so we also want
to be able to support CDI and there's a
lot of technical challenges there and
some problems in my understanding and
others in our expert group but we do
have some of some experts who are more
familiar and Pete Muir from the CDI team
has been contributing as well but we
would like to be able to inject entities
and attributes as well and it's a little
there's some some complexities because
of the way those things are defined
Stanton more statically than we would
like them to be so this is a little bit
about the reference implementation and
mostly this is just gives you a link so
it's a jit project it's open source you
can download it and can't really build
it very well right now we're having a
little trouble with getting all the code
so that everybody can build it but you
can start looking in there there are
various things parts to the project
within the project we have interceptors
to process the annotations like identity
and identity provider and so there's
there's some very so if you were running
inside an ejb or inside a you know a
container like that you can take
advantage of those in their post
construct interceptors we also provide
entity factories one of our experts
prefer that we not rely on either CDI or
or interceptors because you wanted to
make sure that you could use this
paradigm in cases where you know it's
the lightest weight environment and so
we have entity factories and essentially
you just get a factory that knows how to
process your
and we've made that very simple and the
interceptors use exactly the same
functionality so it's a common code base
just a different way of invak indicating
the Deanna deconstruction code I think
I'm about done here interceptors NCD I I
think this is mostly what I just said we
defined a caller qualifier I mentioned
earlier so you man a producer that will
return an identity it and ID entity
reference and that's how we integrate
with CDI it's if the basic idea is the
producer looks through your environment
and finds what it believes is the
correct entity to create an entity
reference for this is an advanced topic
I briefly mentioned predicates so we
have predicates and then we have these
complex providers composite providers
and you know they you know you have a
provider at the top and it's composed of
all these underlying systems and the way
that bad happens within Novus is the
predicates you guess the top-level
products let's say that you have this
complex provider you ask for predicates
that's going to look you know it's going
to test an attribute reference an
attribute an expression about an
attribute name for whether or not it
equals some value you want to take that
predicate now and apply to this complex
of you know composition of underlying
providers well the way this works is
there are swim lanes basically that that
distribute that query as appropriate to
the underlying repositories is fairly
sophisticated and the end result is you
know logically equivalent to the right
processing of the predicate but
predicates are bound to the provider
from which they required so we have to
be able to convey the right predicates
and keep so when you get a predicate
like fat from within nobis you're
essentially getting a very
located reddiquette predicate SAR you
know they have to they have their own
references within them that's a in which
provider they came from etc so some
advanced topics I mentioned briefly that
one of the problems we have with this
predicate calculus which is that you
know it's essentially unlimited isn't in
terms of you know it's it's you know not
quite Turing complete but it's a very
sophisticated language and we can't
really expect something like Facebook or
LinkedIn to both understand all our
predicates or to allow you to issue
predicates outside of certain
constraints that it's established for
you know you know you know what is what
is the domain in which they'll they'll
let you issue a query so a conectar
repository is this idea that if you
bring entities into Java sort of like
that identity provider methodology then
we can fully operate on them so connect
a repository for example in LinkedIn
you're able to get there the entities
that are in your network so a connector
repository would be the way that
essentially a provider that only
referred to the entities in your network
was constructed within the attribute
service and how that would happen and
then you'd have full fidelity of the
predicate calculus within that space and
we would also be able to better control
access to that identity we wouldn't have
to bring two values and we just have to
bring the references and we you know
depending on the knee on the nature of
the query that we ultimately ran another
problem is or another work item is we
define basically a property space a
metadata space but we really haven't
crystallized what the requirements are
for what metadata to create and when
it's created so we have our work cut out
for us there we all know that we need
some kind of miniature paradigm where
the data come from came from how we
represent is sure has not worked out
whether or not we can have multiple
representations or whether we need
thing like you know a certificate or
like Java would use something like a
signer representation and so the next
topic is about how we get tokens to add
to interact with the backend systems and
that we need we need internal contracts
to manage the interactions between the
backend repositories and the part that's
closer to the user app and the app and
the client application so that's what's
really described on these slides I think
I've pretty much covered them
another topic i'm going to skip this
predicates and joins are very
complicated because they have to be
bound it's all seen in SQL when you
described expressions you have to scope
them to the right side of the joints we
have some of those problems so I'm going
to move on I'm going to also try to
offer order a chance to make some
comments because he's easy to rest it in
some of the next steps and integrations
with other projects but let me just
start here and then all give him a
chance though so next step some really
focusing on making our code running
general consumer devices and where we're
working with whoever will is interested
in creating agents repository attribute
repositories and agents for those
repositories that will integrate in our
architecture we've had some you know
interest for various places and we see
other projects that have already
developed agents or trying to build
connectors and bridges to those agents
and as i mentioned we're trying to
improve our integration with CDI and
generally just refining it the AP i'm
completing the specification i'm
supposed to put this up here you've
probably been lamb basted with this all
week so this this is a good point for
you get i'll leave this up here and
thank in we're really i'll invite one or
two to say a couple words how much time
do we have and then we'll do some Q&amp;amp;A
the early draft of the spec i guess we
have a bit of time i think we have about
18 minutes
yeah so one of the things that are also
sent for slide but it was all 22 short
notice but basically I'm involved in
Pete Moyer one of the other expert group
members is also involved in projects
that are related to social integration
for example a guava and there are some
security frameworks that recently taco
our project has switched from an
external a third party Oh off provider
that's very specific 20 off scribe I'm
not sure maybe some of you have heard
about that or used it somewhere but now
we basically use a more flexible
framework underneath that is closely
related to an cheapest driven initiative
called picket link and that will also be
used by for example the that's our chase
are for portlets the portlet standard
frio where some of this will come into
play and the Apache is also going to use
synergies where possible but of course
in a chase are we also reaching out to
possible other solutions for example
spring security would be a very good
example and spring social which is also
backed by spring security and we like to
do is be able to bring sorts of agents
that have figured out the interactions
with back in our passwords we just would
like to retrying to create a common
interaction applying it's essentially
for people who want act so to degree
that people have already done protocol
translation we just like to integrate
with that I just read a tweet that for
example some another stuffing for stove
or some other analyst called ping
identity that the factors standard and
the most important vendor for
identity management or such big players
of course if they also have some vested
interest in the travel community and in
java enterprise and of course doll also
vendors that we would like to get in
touch with and to to help them to
implement the spectrum so i'll just
comment one thing about our because go
ahead so you're talking about passing
identities that it works between
different systems and obviously things
like Shibboleth and open ID have cargo
attributes that come along with an
authentication you know they say yes
this user is who they say they are then
they can potentially give you some other
information i actually without the skin
version 2 is going to be a restful
standard so so let me say that those are
very good questions let me say that i
was about to say when Warner was
speaking when he was finishing that one
of the important news cases is related
to Shibboleth Shibboleth like I still
remember Shibboleth but I haven't been
as involved as I once was but you know
as a sam'l attribute-based the past
representation form one of our important
of objectives you know whether it be by
certificate or by XML certificate as is
as a sam'l or Kerberos for that matter
as is an asn one is to take the content
of this you know specialized
representation of den today and lifting
it up into Java so that as a program you
don't have to parse the underlying you
know transfer forms to be able to
understand the information that was in
so for example in a sam'l assertion from
Shibboleth we would be taking the
information out of that assertion as
creating attributes or references the
apt attachments that could be acquired
on demand when those attributes come out
they would have the issuer from the
assertion in their references but for
your programming model you won't have to
know those
you know that it was a you know how do I
reacts ml but so that and that's I think
sort of at least a partial answer your
first question skin is a little bit
harder question for me i was actually
anticipating that question so we're
trying to do if the whole world becomes
skin then to some degree are probably
simpler but our problem skin won't
really be there's a difference between
restful api is in program in asia so
that's one part of the answer is not the
same thing to define restful api and to
have an API that people want to use to
write home runs against but it also
we're right now not assuming that some
repositories for example a facebook
repository or linkedin repository well
necessary we provide a skim interface
for you to interact with if they do it
will make our problem simple we're sort
of a sort of the heterogeneous
integration system so right now we're
very mindful of skin and we want to take
advantage of it but it's not the
solution for us it's just an enabler and
when one of our group members is very
involved in skin so applying as well so
i think it's it you know i'm impressed
at how much progress that you know in
traction it's getting maybe you give you
it also has a lot to do with
provisioning repositories right a lot of
its use cases or how do you take a bunch
of data and create all the users over
here and some of that we have a lot of
what we have is once it's there how do
you get it and sometimes skin is it used
for that and any other questions yep
education authorization
well I think the wave will do that is by
least common denominator effectively we
won't we won't be so we need to have a
common programming model we won't be
able to represent the backend systems as
they are seen but what we don't have
right now honestly is we don't have a
good binding for identity in Java and so
it's you know we could say that it's a
very difficult problem and an unsolvable
problem but then we get nowhere so we're
trying to do is make it so that within
the constraints of the interactions that
we've defined which do address at least
some of the issues you're talking about
trying to create a simple model for that
and there to grow it to a practical
sense where it it's an enabler for
applications you're writing a simple
application on a phone and for example
in that the backend repositories using
some standard you know authorization
paradigm we believe that we can create
an integration for that we you know we
can't do that for everything or for
every level of service or protection in
the backend system I agree with you
there actually is very hard just to do
one such agent is very difficult but
that's the intent there's also the value
of just having a common representation
so it might be that if you create your
own complex understanding of a complex
system that would be inspired to rip to
represent in Java your data using our
we're not sure that we'd ever get
somebody to do that because that's how
you know it's a like a wine tasters
dilemma you know we would you mention
hierarchical because I guess for some of
the actual business use cases involving
ldap Oh would also in many cases be
relevant no but I did mention that so
jazz is a lot of things I guess but you
know plug ability it's a lot of
different things but what jazz does talk
about is you know access control based
on you know subjects principles so we're
not redefining jazz but what we're doing
is we're making it possible for somebody
to write a different access control
system that's based on attributes that
where the access control system right
now let's see why I said I began by
saying jazz is a lot of things so
there's the policy object within the you
know the standard job check permission
policy Don implies a lot of people
attribute that or call that jazz and so
that interface could still be completely
supported and used within your jvm but
in your implementation you can now be
receiving principles that your
implementation goes in gets attributes
for so its representation of the
policies it enforces may be a lot
different than the default policy syntax
that we defined in the in Java you know
which is as principal code sources and
signers you could now right perhaps
policy expressions that said well you
know what's his social security number
you know what's his date of birth but
you need a different policy language but
as far as jazz as what I view is its
interfaces you may not have it may not
be required to change
so it's a it's a little bit of a yes to
your question how does it relate to jazz
we're trying to make sure that we're not
creating something incongruous and so
that we can represent attributes within
the Java security model that jazz is an
important part go ahead I've heard of it
but there we have nothing like that yeah
we don't have anything based on at you
know actions or anything like we don't
have any eventing system maybe you could
give us a use case where we need
something like that we're just mostly
trying to make it so that you can get in
and you know and understand information
and you can get from other places and to
some degree making it so I didn't talk
about one area to we're trying to make
some annotations for access control as
well but that's a little bit of a lower
level problem no don't neither this is
all attribute you know people my my the
manager of our group which is our
research group he's a just you know he's
an a back you're familiar with a back so
that this would be in support of a back
afternoon based access people so looks
like her but you have anything else
you'd like to add work you have a few
minutes off well Shibboleth because you
also mentioned the social security
number at least from the Austrians your
security system I know that they hardly
used it for the Austrian ha health
insurance smart card because one of the
other spec kids of chase audits about
trusted chava they were
involved in this in Austria as well I I
heard a little bit of about that and
also soil and stole it their schiphol
that definitely plays a role also with
regards to social insurance and patient
identity if you want we're not thinking
SS ends it we are working on going for
sure myself around in common which is
essentially it's different players in
trust so how you know we're kind of
staking our reputation that we know that
this person who they say they are help
for certain levels the person is
physically shown up in showing freeforms
ib or something but one of course so I'd
study the internet doesn't dump a lot of
trust is it one of those sites that
where you have like a social source of
trust or something similar and you write
assertions right and you put your you
certify the assertions is that what's
happening so that's really important see
it would be an excellent source of data
to be represented in Java in which will
probably close with this picture where
that's what we're looking for is people
that can help us do that make it
relevant in what you get for it is you
know there's another client for your
information in your you know the
infrastructure you've built and
disseminated so if you're anybody's
interested you know there's some contact
information here you can find us on the
on the net as well I and the last
question for pretty much out of time
thank you thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>