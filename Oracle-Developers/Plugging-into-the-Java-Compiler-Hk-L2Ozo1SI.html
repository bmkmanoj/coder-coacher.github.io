<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Plugging into the Java Compiler | Coder Coacher - Coaching Coders</title><meta content="Plugging into the Java Compiler - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Plugging into the Java Compiler</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Hk-L2Ozo1SI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so thank you all for coming Christian
and I are going to be talking about
annotation processes and how to plug
into the Java compiler so just a quick
presentations I'm a one McManus I've
been at Google since 2011 initially
working on gmail servers and now on App
Engine SDK but one of the perks of
working at Google is that you can spend
twenty percent of your time working on
another project and for me that project
is the Java core libraries so before i
was at sun which then became oracle on
the jdk team working on gmx and javafx
i'm the author of two annotation
processors the older value processor
which i'll be talking about on the
JavaFX builder generator which i
mentioned in the abstract for this talk
and subsequently discovered has been
retired so but anyway that was a useful
experience anyway so hi my name is
Christian Gruber and also with Google
since 2009 and my role at Google is
actually my main job is to work on the
team that he twenty percent on which is
the core libraries team so we're wearing
the shirts but my main focus these days
is specifically on dependency injection
and testing infrastructure so I actually
am also a former Sun and oracle i was at
oracle before it was cool or ID sunba
they bought son but i was a son and then
oracle subsequently doing a lot of java
and o consulting back before you know
and around the early days of j2ee I'm
the co-author of dagger 1 and 2 dagger
one is actually for processors dagger 2
we pulled it into one as well as a lot
of the auto common libraries that we'll
be talking about a little more today
okay so here's the outline of the top
very straightforward we'd be saying what
an annotation processor is at a very
high level will be looking at a couple
of examples so that we can have a better
understanding of what annotation
processors are about and then we'll be
giving you some tips for how to go about
writing your own annotation processor
and at the end then we'll open it up for
questions so just a reminder probably
everybody knows this this is what
annotations look like in Java everything
in red here is an annotation so we have
an annotation on the class we have an
annotation on a method we have an
annotation on either type order
parameter depending on which version of
Java we're looking at so what exactly is
an annotation processor then an
annotation processor it's a kind of
plug-in or extension of the compiler
it's a way to get your code to run while
the compiler it's doing its business of
comp and compiling resource files so it
was standardized by jsr 269 in Java 6 so
it's not recent it's been around since
2006 and it's supported by the two major
Java compilers that are out there which
are java sea for the jdk compiler and
ECJ which is the competitor that eclipse
uses so it's been around since since the
2006 as I mentioned but it's really only
been picking up recently and there's a
number of reasons for that of which one
of the most important is that I des now
support annotation process is really
well so that while you are working on
your code the annotation processor is
basically running all the time so it's
really as if you have extended the
compiler it's a very fluid experience so
what an annotation processor can do it
can it's invoked by the compiler the
compiler basically shows it the
structure of your program that it's it's
in process of compiling and it can then
make additional checks so potentially
output new warnings that the compiler
itself wouldn't have output and the most
important thing that it can do ever that
will be talking about quite a lot is to
generate Java code so it can generate
new Java code and the compiler will then
come
that code alongside the input code that
was already there when when you started
okay so let's look at an example which
is auto value so the problem that order
value is solving is a value types so
many languages have negative support for
value types but Java doesn't really so a
value type is a value is it is it is a
class basically whose identity is purely
dependent on its properties so two
instances that have the same properties
are completely interchangeable and the
properties never change so the object is
immutable the mutability is a good thing
in Java it's good thing everywhere but
especially in Java it's much easier to
reason about immutable types and they
are inherently threadsafe so use
immutable types wherever you can and
here is a way to value is going to make
make that much easier for you so there
are a number of uses of immutable types
i'm sure you've encountered or rather of
value types i'm sure you've encountered
some of these so if you want to return
more than one value from a method or if
you want to have a map with a sort of
complex key then you quickly get sick of
trying to use two types or whatever and
you really want have a custom type where
you can see what the components of the
key are so here's what a value type
would look like ideally you would just
say here's the name of the class here
are a couple of its properties I write a
constructor that assigns those
properties and we're done that is pretty
much what you can do in some languages
but in Java that's not really very good
one reason it's not good is that if you
directly expose the fields like that
that means that your clients know an
implementation detail of your class
because those fields are an
implementation detail and you can never
change them without breaking your client
so if you want the postcode for example
to be derived from some other
information you're basically screwed
because your clients are going to be
looking directly at that field so you
want to fix that you're going to first
of all add accessors so the client is
using is accessing a method rather than
directly calling the fuel so we've got
these street address and post
with methods and the other thing that
you're going to need to look think about
is validation so even in the simplest
case the street address here we don't
want it to be no so we're going to
introduce an old check pointer so that's
already getting a little bit verbose but
it's not actually good enough for a
value type because it doesn't define
equals and hashcode which means that
you're not going to be able to use it as
a key in a map it's going to be using
the default equals and hashcode which
are based on identity so we have to add
all of this stuff so don't worry if you
can't read that as kind of the point
there's a huge amount of boilerplate
that you basically have to rise in order
to make a complete value class so that's
what auto value is trying to solve so
let's say here if we look at this the
repetition of this code the postcode
identifier appears 11 times in the
source code so if I want to add another
property say a country or something then
I'm going to have to introduce that name
11 times through the code and it's going
to be really tedious so here's how all
the value solves the problem you change
your class into an abstract class you
add the ultra value annotation and you
still have your getter method so these
are the methods that the client is going
to be calling but they're now abstract
methods and so what auto value is going
to do what the processor is going to do
is that it's going to generate a
concrete implementation of this class a
subclass where each of those two
property methods is going to return a
few that you've assigned and where the
equals and hashcode and to string have
all been defined correctly and where the
validation checks like null pointer
checks have been made at construction
time so instead of a constructor then
you're going to have a static method and
that static method is going to call the
constructor of the generated class so
the generator class is called overvalue
underscore what the original House was
so auto value underscore address in this
case and you just call its constructor
and it returns you the sub class and
that's that's all you need in order to
be able to work on your value types so
here's what the subclass looks like but
it's completely unsurprising I won't
dwell on this slide it's basically
exactly the same code as we saw in the
earlier side except you haven't had to
write it
okay so what does the processor what you
do in detail so the compiler what the
compiler does is it takes the initial
Java source files that you gave it and
it compiles all of those let's say it
parses those enough to understand what
they're made of and at that point it
looks to see whether it's been
configured with any annotation
processors and that basically just means
that somewhere in its class path it has
a jar which has a service entry that
says this is an annotation processor so
we'll see how to make that happen very
very straightforward you later so once
it finds an annotation processor one or
more annotation processors it basically
asks each one are you interested in well
so more it knows what annotations it's
seen and for each processor the
processor says I'm interested in these
annotations and so it looks to see all
the annotations that I've seen are there
any processes interested in those and
for those processors you will then
invoke the processor and say here are
the places where i found that annotation
so in the case of the older value
processor it finds its it's seen an auto
value annotation it finds the other it
looks at all of its processors it sees
the auto value processor which
recognizes the auto vado and annotation
and therefore it says oh processor here
is a list of all of the classes where I
found the auto value annotation so we
know a little example it's going to say
here's address the class that contained
the order value annotation so do your
thing with address and what that that
thing is for auto value is that it's
going to make this class the dot Java
class that i just showed all the value
underscore address based on what it sees
in the in the class that it was given so
once it's done that so it's taken all of
its Java files and its evoke to all of
the relevant annotation processors and
those processors have potentially
generated further Java source files it's
possible that those new Java source
files themselves contain annotations and
so the compiler would potentially invoke
do the same thing again for these new
Java source files and so on until there
are no more generated source files so
once it's done that it's got a whole
bunch of source files the original
source files those top three source
files plus any source files that were
generated by annotation
it takes all of those source files and
continues their compilation from where
it left off until it gets the output
class files so that's all a little bit
abstract let me show a demo of how it
works in practice so I've got NetBeans
here and it's got the address class that
I was talking about it's got the auto
value annotation and all I did in fact
for this was to create a maven project
where I expressed a dependency on the
older value processor so NetBeans did
all the necessary stuff of setting up
the compiler and everything so let's
just see what happens if i add a method
to this so all of a sudden netbeans
which is doing its continuous
compilation and that compilation
includes calling annotation processes
now sees that this constructor that I
was calling is no longer correct we
probably can't see the error message
there but it's basically telling me the
theory that it's expecting three
parameters because there are three
properties so i can add the missing
property and what i'm going to do is
we're going to use whoops i'm going to
use code country completion so i just
hard control space and netbeans knows
the the types of the constructor
parameters even though it's a generator
constructor and so it just fills them in
because those are the only possible
values for them so that's really good
let's have a look at another possibility
supposing
I try to do this so it turns out that
Otto value doesn't support array value
properties except primitive arrays so
it's amusing an error and you can't
probably can't read that error either
but what that what the compiler is what
NetBeans is now saying it's basically
pointing out exactly where the problem
is because the processor was able to
signal an error at exactly that point
and so it says you can't define an array
value property ok so with that over to
Christian about dagger thanks Haman so
dagger is a dependency injection
framework based on jsr 330 sort of a
spiritual descendant of juice in a way
jsr 330 of course is a spec for
dependency injection that was a
collaboration of the juice folks the
spring folks and a bunch of other people
daggers name is kind of a pun on
directed acyclic graph which is exactly
what we're doing we're managing graphs
of classes and their command their
collaborators dagger 1 was a joint
project with square and Google some ex
Googlers that square needed a one a
dependency injection on Android and
found that all of the startup time and
the reflection of juice was a little
harried and made for various slow
startup times so Jesse took his mini
juice example and re-rolled it and
teased it apart and turned it into about
is minimal and dependency injection
framework as we could figure out and we
worked from there the key point is we
eliminated a lot of reflection by
generating source code so that a lot of
the work of analysis that gets done gets
done by at compile time and then
adapters are generated which do the
actual work that would normally be done
by reflection also the compile time
analysis moved errors early is really
happy we weren't quite satisfied there
was still some overhead of code loading
from loading the generated code
dynamically so that inspired dagger 2
which will be looking at in a minute
which actually kind of turns the dial up
to 11 on koh gen it eliminates pretty
much all of the runtime and also
eliminates all of the remaining
validation we were doing at runtime
as well so quick thought about in
dependency injection it's a pattern that
most people are familiar with it's a
kind of inversion control inversion of
control martin fowler first described
this particular approach and really
concretely what it amounts to is this if
you have classes that know how to
marshal their own collaborators they end
up with a static dependency on those
collaborators implementations so this is
bad for decoupling it's bad for testing
I've actually worked on a project where
our test rig was issuing credit card
authentication authorization requests
that was a bit of a problem that
convinced them to maybe use fakes and in
their testing infrastructure but
obviously you don't want to do that and
you speed up your tests by having fakes
that don't go to the network this is all
standard testing lower I don't really
need to convince most people about this
so really dependency injection just says
instead of the class knowing about its
collaborators it simply declares what
collaborators it needs and let somebody
else take the job of wiring together to
pieces so then the question is whose job
this class is perfectly reasonable for
dependency injection but somebody's got
to actually write that glue code in that
wiring and you can write it yourself and
on small projects you probably will but
that's really tedious much like value
type implementations it's tedious code
it's completely inferable and so why not
automate it and that's what spring did
initially configure with XML juice did
configured with a java-based annotations
spring got on board with that and you
have GSR 330 so that's all fine you also
need some configuration though because
how do you know how to get message store
and user service if they also have at
inject that's perfectly fine the system
can figure out how to build them but
let's say message stores an interface
well you need some sort of configuration
and all of the dependency injection
frameworks have some mechanism of
binding interfaces to implementations in
their configuration we use it with a
module class which just enumerates these
different configurations that are not
inferable and it provides method just
signals this is a method that will
provide the type in the return type
message store in this case and declares
dependencies on its parameter list much
like if you look you see these
dependencies are on the constructor
parameter list so it's all about just
defining these dependencies and letting
something infer the full graph of course
something that infers the full graph
will have to understand errors and
figure all of that stuff out and that's
fine that's all part of the automation
so in dagger to what we've done is we've
said instead of having a generic object
graph type such as the injector or the
context in spring or the object graph
and dagger one we actually decided let's
go with what we did with Auto value and
actually start letting you define the
contract of your graph edge so the root
of the graph is actually defined an
interface you create and you wire it up
with component and dagger we'll just
build all of that internal wiring for
you in in spectacle classes the point is
the annotations provide the signals the
graph analysis is actually start starts
at the component because that's the
graph route so you can actually say do
we have cycles in this graph do we have
missing elements in this graph all of
this stuff we can infer because we have
compile time signals the annotation
processor can see and what's generated
is plain java code it's actually
perfectly reasonable to go through and
read it you don't need to but if you
want to because you're in the middle of
debugging something it's very handy
sorry duplicate slide so why do we
bother I mean Juicin spring work really
well they have you know a lot of this
logic already they just do it at runtime
well we found the performance things
that I mentioned before this is true on
things
like Android but it also starts to be
true in a cloud environment where you
have instances coming in up and dropping
kind of arbitrarily and you're having to
write servers that are very tolerant of
that you don't want to pay extra money
to real cloud providers I mean I work
for one would like you to be paid to be
paying us for really important work that
your app is doing delivering value for
the users not for boilerplate up and
down so you know reducing those kinds of
costs developer productivity is a huge
factor if you get your errors at at load
time you you're past your development
cycle at that point you're deploying a
server and you realized oh I screwed
that up or worse at runtime if you're
smoothing out some of that analysis load
into runtime you end up you know a week
after you've deployed it you find your
error because that weird code path is
finally invoked no we want all of that
analysis up front and we'll get into it
much but we we found that by going and
taking this approach it kind of unlocked
for us some improvements in the design
patterns that we were looking at because
it allowed us to do things like having
that interface that is much more
targeted it's you generate the interface
and we build all of the pieces as
opposed to having sort of more framework
e bits that that are more traditional in
dependency injection frameworks none of
that is impossible without but this made
it a lot easier so I'm going to change
mics and yay change machines good okay
so just really briefly now he was in
that beans i'm in eclipse i'm going to
point out that dagger 2 is early we
haven't released even an alpha yet but
this stuff works it's just there's some
ID integration issues that we're working
through so bear with me so if you notice
here we have that mail service right and
right now it's really simple it just
starts and it says mail sent it has no
collaborators no big deal but how do we
get it into the main you know you can do
it and that's fine but we're going to
start out and collaborators in a minute
and so all you really need to do and
is start just like that and oh we have
an error already we have an error I
don't know if you could read that I hope
you can but it's basically saying that
the mail service cannot be provided
without an at inject constructor or from
a provides annotated method already
we're seeing we've got missing bindings
in our wiring so that's pretty easy
because male surface is pretty simple so
we'll add an inject to the constructor
oops and suddenly boom there it goes and
it's it the errors go away and you'll
notice there's a couple of generated
files here I won't get into that right
away but then what you do is you say my
server well code completion is having
fun
and here create so it actually generates
a builder but we're not going to worry
about that for now because there are no
dependencies and no modules it doesn't
know about so boom that's fine and then
server dot mail dot what are we doing
send sure and ah so this is by the way
one of his IDE integration issues we
have a fix for this we haven't put it
out eclipse runs processors twice
sometimes and so it writes the generated
file and then tries to write it again
and you get an error you just clean
build for now but we actually have a fix
for that it's not a fix for the problem
it's just a fixed so that dagger doesn't
invoke this problem but there we go and
now we just run the main boom mail sent
done but this is really really simple
obviously we want dependencies so let's
add a dependency now you're never going
to pass in a dependency as an instance
variable but you know this is a demo so
we need a place to put it
okay so what's going wrong oh look
string cannot be a provided without Matt
inject constructor so it found the type
string notice it doesn't have an at Jack
constructor and complaints now string is
a java type in the jdk so we can't
actually do that so we're going to have
to provide a string properly so we'll
create a module
oops
and source file already created sorry
guys build clean my understanding is
that IntelliJ and netbeans don't have
this issue but we'll make our art thing
tolerant of it oh we still have a
problem what's the problem haha well how
does the component know about that
module lots easy we just add it and
could not generate go clean demos what
are you going to do so now we have a
dependency a dependency that's been
satisfied down here and you'll notice
we've got these classes that have just
been generated along on the fly as we go
and what are they well if you look
here's the factory for a mail server and
it's extremely obvious it is a factory
that requires because a mail service
requires a message this needs a message
provider and so here we do some tests
some checking for no we assign it and
then when this factories get method is
invoked which is behind the scenes in
the component then the message provider
will be invoked it and that will return
the message into the constructor of the
mail service which will then return the
mail service similarly this is actually
really what you would have to write
anyway if you are going to abstract to
the point of having providers and
factories doing these things and again
right here it knows how to get the
module because the module has a default
constructor or we don't prevent it it
knows how to create one on the fly and
it just does all of that so then we have
the actual component and what's in the
component well here is the module that's
needed the two providers that are in
this little mini graph and what does it
do
there's initialization of the providers
but when it all comes down to it and you
actually go and return it oh good lord I
have to find the darn method Oh male is
right in front of me right here it asks
the mail service provider to get mail
and if you go back here you'll notice
that's what we were doing in the main
server male now we have a fully up and
running mail server and we type send and
we should be able to oh we didn't
actually do anything with that message
let's make sure it actually does
something useful and we will build clean
and we will run voila male send a couple
of really quick examples of error
messages suddenly we have two bindings
right there again at the point of the
graph construction this is bound
multiple times these are the locations
where it's bout you can actually start
finding your way around the graph and
around the configuration elements in
your graph in your ID right there and if
you need to you can step through you
know hey I don't know what's going on
here so I'm going to oh yeah it doesn't
generate the code if you have an error
let's try that again
alright yep so now this class exists we
can go right into the create we can you
know we find an error we can just step
around the code and it actually makes
debugging kind of easy I don't know if
how many people have used spring of
juice in this audience but if you've
ever had to walk through a step through
debug your problems in wiring you end up
in deep in reflection stack traces it's
extraordinarily hard to figure out you
end up setting breakpoints in keeping
state and looking at variables all over
the place it's maddening so this is a
real step up and yeah I think that's it
at the end of your monday so a little
bit of detail about what you can do if
you want to write your own processor so
first of all it's important to know what
you can and can't do with processors and
then we're going to give you some tips
about which are they because it's a
fairly big API what are the most
interesting points of the API what are
the things that you're going to need to
know first so annotation processors are
invoked by the compiler when it's
already seen the source code as I was
saying and it's already constructed the
structure of the source code it's a nose
is a class which has these methods in
these fields and so on and it gives you
basically an API that allows you to see
the high level structure of your classes
so all true value for example can see
that there are these abstract methods in
the class that it's looking at dagger
can see that there are these app
provides methods and so on so you can
see methods you can see fields but what
you can't see is what's inside the
methods or what's inside static
initializers or constructors or
initializer expressions so it's really
just the top level structure of the
class which is enough to do a lot of
stuff and that's what we've used for for
a dagger and for auto value and for the
javafx builders and a bunch of other
stuff so what can they do they can
generate a new java source code to be
compiled so that's really the most
important thing
they can do that we've been talking
about they can also generate other files
why not they can generate xml files they
can generate meta in services files
which are jarrah service providers and
that's what we'll be looking at actually
in a little bit and they can just
generate any old file they can perform
analysis so they can make additional
checks for example amid warnings so
we've seen we've seen examples of errors
where the analysis determined that there
was something wrong with the structure
for as understood by dagger eyes or as
understood by Otto value and those
errors can be associated with specific
source elements so that's why we saw the
little red underlines in exactly the
right place in the IDE because the
processor was able to say the error is
exactly there but processors can't
modify the code of existing classes so
this is really the major restriction and
it's deliberate if the idea is that Java
is of what what you see is what you get
language it will be very confusing if
the actual result of compiling this
class was not what you saw in the class
but was that plus some other stuff or
maybe that but modified in this really
strange way so you can't do that and in
particular you can't even introduce
nested classes so we'd actually like in
Auto value we'd love for the the
generated subclass to just be a nest at
last with in the original class but
that's not allowed so I just to mention
that we call the mana tation processes
and we've been talking about them in
conjunction with annotations but
actually they're just a generalized
compiler plug-in mechanism so you can
rise a processor that is actually
invoked for every single one of the
source files that are being compiled if
you like so this slide Assize exactly
how you go out go by doing that okay so
reminder of how you go about defining an
annotation so once again you probably
know this you so use art interface
instead of interface and every method in
the interface is going to define a
member of the annotation then you say
use our target to say what the
annotation applies to is it classes
methods views and so on and you can also
say the retention of the annotation so
if you've defined an annotation in the
past for juice or whatever you've almost
certainly used retention policy runtime
and you've probably wondered why are
there even these other
policies at all so retention policy
source is really there for the compiler
itself so it's for say override and
suppress warnings and stuff like that
annotations that are understood by the
compiler but it's also for annotation
processes because they're still running
at the source stage they can see the
source so they can see things that are
annotated with source annotations so all
true value for example is sore
sanitation it's not visible at runtime
you can't tell by looking at a node
value class that it is an order value
class and that's deliberate we don't
want you to know that it's an
implementation detail if tomorrow you
decide you want to use some other way
clients shouldn't have to be changed in
any way they shouldn't be able to see it
oh my goodness I hit the wrong button it
that's disastrous okay there so a
processor an annotation processor the
usual way to define one is to extend the
class abstract processor so there's a
few things that you need to do then one
is you want to say what are your
supported annotation types so that
basically means here at the annotation
types that I'm interested in is what I'm
talking about I was talking about
earlier the compiler knows which
annotation types you're interested in
and it sees classes that have those
annotations it would just call you on an
tell you it's those classes the other
thing that you want to say is what
source version do you support and what
that really means is what is your
strategy if you find your processor
being invoked on a later version of Java
than the one it was built for so say I'm
writing my processor on Java 8 I have to
decide what's going to happen when a
year or two from now somebody comes
along and tries to run my processor with
some Java 9 code and maybe that has some
language constructs that I didn't even
know about because they were introduced
in Java nine so i have two possibilities
one is to say I always support the
latest version it's kind of a gamble I
probably be able to deal with the later
stuff because it'll probably be
compatible or the other possibility is
to say I support every version up until
Java 8 and I don't support later
versions and in that case your processor
would just not be invoked if if it's
given source that is Java 90 yeah one
last thing the older service
they're so in fact ultra value is part
of a suite of projects of open source
projects from google they they auto
project so in addition to auto value we
have Auto common which we'll be talking
about in a little bit auto factory which
we won't be talking about and all the
service which is this annotation that it
allows you to say when you're building
this please generate the meta in file
that needs to go in the jar which is
able to tell uses the jar service
provider mechanism to tell the compiler
there is an annotation processor in this
jar okay so in addition to those things
that you actually need to make your
processor do something and the way you
do that is to override the abstract
method that's defined by abstract
processor called process so that's given
basically a set of the annotations that
the processor is is being invoked
because of so in the case of the offer
value processor it's going to be a set
containing all true value class
essentially and it's given an
environment which you can use to
discover what exactly it's it's seen so
you would pretty much always want to say
round and get elements annotated with
the annotation in question and that's
going to return the the classes if it's
if it's a glass annotation or methods if
it's a method annotation and so on that
had the annotation and then you're going
to do whatever it is that you need to do
with those as and then the last thing is
you want to return false from your
method so in fact there's this
complicated notion of claiming
annotations a processor can return true
and then it's saying I claim this
annotation no other processor should be
invoked on this annotate annotation
after me in general you don't know what
other processes there are so you can't
really presume to do that we recommend
you just always return false and that's
what I'm saying here okay so there's a
the API is this a is not trivial and
there's a few things that are quite
important to know first of all there's
two there's the package called util
image of X
lying model you too i think it is and
that contains a number of things that
are important and in particular it
contains types and elements so the types
interface contains with utility classes
for introspecting on types and likewise
elements an element is a class or a
method or a field or a parameter you
know it's it's a program element
basically so if you've been scratching
your head and trying to figure out I'm
looking at the interface that represents
an element and I can't see a way to do
this thing you should look at the
interface called elements and it might
have a method that allows you to do it
so and the same thing for four types and
here's how to get those things basically
processing in which is a few that you
inherit from abstract processor has
these methods get type you tales and get
element utils and you end up typically
passing those around quite a bit within
your processor okay then another thing
very quickly element filter and really
it's just those lines in red there once
you've coffee at the elements annotation
with your annotation in fact your
annotation only applies to classes but
that method is going to return you all
elements in principle that that are
annotated with it you're only interested
in methods which are called executable
element so you call element filtered out
methods in this thing I just mentioned
this because everybody writes an
annotation processor seems to discover
this independently you all add end up
looping over the things to pick out the
ones that are of the right type and then
you suddenly realize there's already a
method that does that's hidden in this
class called element filter okay and
then one area that's sometimes a little
bit confusing is that there are two
interfaces type mirror and type element
there's a subtle distinction between
them which I won't get into but the
point is that one of them applies
sometimes and the other applies other
times you don't really have to worry
about it too much if you find you have a
type element and you need a type mirror
or vice versa there are straightforward
ways to convert between them one of
which is just to look at the types
interface that I was talking about and
they will allow you to do that
okay over to question so some things
that we found there's some gotchas in
annotation processing environments in
particular your code can be processed in
the middle of having erroneous upstream
code so the classic case in our case is
somebody left out an import statement on
the provides annotation or provider yet
provides annotation and so everything's
compiling everything's great but they
left off the import and because you're
in the middle of the compilation the
compile error hasn't surfaced to the
user yet because you're still going but
what ends up happening is you go to look
up elements and you you try to get the
modules and blah blah blah and it all
blows up because it finds your method
that has provides on it but then you try
to inspect the annotation contents and
it you get classcastexception you get
null pointer exceptions it's kind of a
mess so what you want to do is do some
sort of a sanity check to make sure oh
this is actually we've passed the basic
compilation of the things that I'm
working on or at least the sort of
Lexington parsing and it all kind of
works and the pieces are there so we
built this thing called superficial
validation which has a nice little
validate elements method all it does is
it checks to make sure that you don't
have error nodes and some missing things
that are symptoms of upstream
compilation problems and what we
typically do is we just say hey this
element validate it if it fails we don't
even run the rest of the processor we
just exit out because the processing
happens in different rounds your
processor will come back again so
exiting out early is not a problem but
what it actually does is it lets those
upstream compilation problems bubble
through and not get masked by a
classcastexception very confusing to
users and and that's in the auto common
project by the way a couple of other
gotchas type mirror does not have
a sort of value type level of equality
you can go type mirror a dot equals type
mirror B and expect that to work well
there are a couple of ways to do that
the types interface has a method but
sometimes if you're really deep in a
call stack you don't want to be passing
the types utility down the call stack
it's an extra parameter maybe you've got
six parameters the six method calls deep
because it's a big processor so we made
some nice utilities in a class called
more types and that you know lets you do
roughly the same thing without having to
have the the utility class the instance
utility class similarly it's important
to know type mirror does not conform to
does not behave well with instance of
checks and that's actually explicitly
disclaimed in that javadoc so you want
to make sure that you're not trying to
do instance of then cast if you ever
have that pattern in your head instance
of then cast then you probably want to
use one of these converters we've
written which will validate that it is
the right type using a visitor pattern
underneath and throw an illegal argument
exception if it fails so it's a little
more orderly and you're not likely to
get far more confusing errors that don't
you know the kind of mask the problem
and that just sort of brings me to
generally the auto common utility a lot
of this is stuff that we just endure an
auto value and auto factory we've just
started abstracting out these common
utilities that we found really valuable
superficial validation more types more
elements are really just focused on type
mirrors and type elements respectively
we have stuff in dagger 2 we are
migrating into auto common particularly
annotation mirrors and annotation values
it turns out there's some gotchas there
in particular trying to do comparison of
annotation values gets tricky especially
when you want to use them as keys and do
comparisons that way under the hood
because it turns out they are deeply
chained and you might have annotation
values that contain a notation mirrors
which contain annotation values and
because annotation mirrors dot equals
don't work you can't just you know do a
simple superficial thing you actually
have to do a deep comparison so we
handle a lot of that for you
now I'm going to talk briefly about a
Java writer so the the example you're
going to see here is actually the new
Java writer that's in dagger 2 again
we're pulling that out and putting it
into the Java writer project at square
there they're really happy with the
direction we've taken it the current one
is sort of a a code emitter but the one
that i'm going to show you is actually
it's a little bit more of a builder or a
constructor if you will so in this case
it lets you build up code
programmatically you start at the very
top with a file in a package that's the
java writer shell and then you start
adding classes and adding methods do
those classes and it's it's very orderly
very obvious what it isn't is a mirror
of the output code and we'll see a
different approach that's a little more
sort of where your code that builds the
code code is similar to the code that's
built but from this right here we're
adding a field we're adding a class
we're adding a field we're making that
field final and private we're adding a
constructor we're doing an assignment
adding parameter to the constructor
we're doing an assignment in a statement
and then we write out to a dependable
it's important to note that a pendulum
can be anything it's a string buffer in
my example that produced this output but
it can be the there's a filer interface
that's part of the annotation processing
environment which have you actually
write your files and that's that's how
that goes so this is what you get from
Java writer that specific code produced
this specific output note the one
advantage that we found with this
builder approach it handles the imports
for you so one of the ways to make much
nicer code is to make sure that you're
importing all of your types and you're
you know dealing with short names and
not fully qualified names all over the
place otherwise it's very unreadable and
Java writer handles that it handles you
know if you have conflicting short names
it'll it'll use a fully qualified for
one and shorten the other and blah blah
blah all those nice good things
a little bit of indenting but as I said
really useful in a lot of ways it
doesn't generate code that looks like
the code you wrote to generate it the
one place where I'd say it really is
most important is if you are doing
things like generating builders for
example where you have each element in a
loop you're looping over for properties
requires that you touch several
different parts of the Java file in
order to add things because this builder
is sort of a semantic representation
rather than a textual layout it actually
lets you put all of the changes in one
place so you know you're not having ten
loops in the ten places that are looping
over the same thing you have one loop
for each of the elements and you're able
to touch each of the points of the code
logically we'll move over to templates
to em can talk about so this is the
alternative approach based on templates
and that's what I use in ultra value
basically because I find it hard to
reason about the code that's written in
Java that's generating code in Java I
get kind of confused between the two
levels is this the generating code or
the generated code I stare at the code
and I try to imagine what the other code
which is also in Java is going to look
like once it outputs it so I find and
this is probably a personal choice I
find that it's easier to work with
templates we're using a template
language that is really nothing like
each other so you can very clearly see
that's the template logic and this here
is the actual Java code so if we look at
this template so i'm using apache
velocity if you can see that it's
looping over the properties and you can
see so the syntax highlighting here is
exactly the syntax highlighting that
netbeans users so the big advantage of
apache velocity is that it's very widely
supported every ide has plug-ins for it
so your ID is actually going to be
coloring your code like that and you can
see the code that's in black is the
actual Java code that gets generated and
everything else is the directives
basically that tell the template engine
which things it should be choosing so
all of that big template logic over
there with the colors produces the stuff
in the box and you can easily see which
of the the lines in the template
correspond to the the lines in the box
so in the list of advanced and cons that
Christian gave for the Java writer
approach essentially all of the pros
from that are cons of this approach and
all of the the single con of that is
basically the probe this approach so it
depends on whether you think that the
pro of reaping able to see exactly what
the generated code looks like outweighs
the fact that for example you're going
to have to generate the imports yourself
so I just mentioned you use it use
apache velocity and we do altra value
for example does need to manage in ports
and also if you would really want to
look how the code look nice the
generated code look nice you're you're
typically from a template engine you've
got to get a lot of spaces and blank
lines that and that so you might want to
do a post-processing pass which is what
I do in order value ok ok so we're
running we're running at a time so I'm
going to blaze through this as quickly
as I can ok so a tool Ian areas of
testing testing unit testing and
integration testing functional testing
because you're dealing with this
processing environment you often will
have your code relying on things that
the processing environment gave you
namely the types and the elements
interfaces so that's a pain but we've
helped that out we have a compilation
rule that's part of a project called
compile testing which was evolved
essentially because we hated testing
annotation processors we actually had
maven invoker tests in dagger 1 that are
just horribly slow and long because
we're invoking whole builds just to test
failing builds its really kind of gross
so we've cleaned that up a lot and so
the compilot compilation rule basically
will exactly like you see here you could
cut and paste this code into your test
and it will give you the types and
elements and you can then actually run
things through in unit tests well unit
tests sort of a vaguely live system but
it's as unit as you can get in this
context you also need integration test
to test failures you're generating air
and warnings out of the compiler so you
want to be able to test that and your
build can't fail or you end your build
so you want to successfully test a
failing condition so we built this thing
Greg actually who was largely
responsible for the implementation of
dagger 2 built this in a week of anger
it basically lets you run a compilation
on an arbitrary set of processors you
give it on arbitrary code that you give
it as strings or as files and it'll do
all of the compilation it will store all
of the proper Java Sea diagnostic
information internally and then you can
assert about that diagnostic information
either that at compile sex successfully
or that it failed and if it failed that
it has messages error messages attached
to certain lines and columns and
actually just looks like this more or
less it's a little verbose but that's
because a lots going on you've got
here's just an example of some test code
that's coming out of a source here's
test code that's coming off of a file
you can choose which one you want or
which way you want to do it and then
here it is asserting about java sources
that this set of sources processed with
this processor fails to compile and with
errors containing i am missing a bracket
there oh well with error containing
invalid use of annotation blah in that
particular up wow I messed with a slide
I'm sorry folks there's typos I'll fix
it before we post it but in a particular
either this one or this one on line 7
and that assertion will either pass or
it will assert they will throw an
assertion error if you didn't get the
expected exception it's a nice paradigm
you also want to succeed test success
right and there's a couple of approaches
compile testing has a method that lets
you test on a successful compile that
certain sources were generated that's
very handy for testing golden files
particularly we do an AST comparison if
you're comparing sources so you can have
not less brittle Golden's because we're
not going
carrying a text Julie with spaces matter
it's really just that all the
programmatic elements are as you
expected and then you can test against
raw text if you wish but golden files
are a little brittle so you also want
functional tests that test the real
functionality that don't rely on
Golden's if you're relying excessively
on Golden's which we did because we got
happy with compile testing then you make
a change to the implementation and you
have to go fix all of your golden files
everywhere it's pain so we've learned
our lesson it's the thing about rolling
your own tools you get happy to use them
and then you forget that they were fit
to a purpose so yeah really the question
is its a mix and you want to use the
right thing in the right place at some
level this is basic testing hygiene but
don't feel like you have to do one you
know one solution unit test what you can
we have tools to help you do that
functional test what you can to get you
know maximum use case and code path
coverage and then use compiled testing
for the failing test cases and you're
good to go
aid so wrapping up we've told you the
annotation processes are a powerful way
to extend Java Sea will be showing you
some of the things that you can do with
it an ecosystem is evolving as I
mentioned at the outset a lot of stuff
is showing up java writer or the common
and in particular support in IDEs there
are several useful annotation process
out there so we showed you a couple of
them and so there are big advantages to
annotation processors earlier checking
this is a really huge one performance
improvements and viewable generated
source code so you can actually see what
what's going on it's much easier to
understand what's going on then things
that are buried in the results of
reflection so with that we're done I
will open up to questions yes
the
yeah so I I'm gonna join in repeat the
question yeah he was asking about sort
of flexibility of replacing things in
dagger I'm actually going to defer we
can talk maybe after this about dagger
specific things because I don't want to
this wasn't really a demo of dagger or a
session on dagger but there what I
showed you was a very superficial subset
of the total kind of thing that you're
going to use when you're doing dagger
there's a there's better talk by Greg
kick which you should be able to see on
on YouTube where he goes a little bit
more into dagger specifically and we'll
be doing a series of toxin and demos and
things as we get closer to really
releasing it yeah okay
eat this so that information comes from
the diagnostic information that the
compiler returns and and we hide that
diagnostic and wrap it in assertions but
that's not available in the annotation
processor that's actually available in
running the compiler as sort of an oem
moving and you get the diagnostic
messages back and they contain line and
and column information about where
errors occurred what you have in the
annotation processor is you can
attribute errors two elements and those
elements are then translated in the
diagnostic messages to line and column
numbers yeah you can't you can well you
might be able to cheat you might be able
to admit it like a diagnostic and then
look at what line number was in it and
maybe surprise that or something I don't
know if you can see the Diagnostics in
the processor though because the
Diagnostics come out of the compiler not
yeah but you have no diagnostic listener
right so oh yeah you're right yeah so we
don't probably not yeah the thing is if
you really want to nothing is stopping
you from finding the original source
files and parsing them yourself I mean
there are sometimes you might need to do
that and actually an offer value I did
need to do that because the clips is
kind of a little bit buggy and wasn't
really following the annotation spec
completely so I needed to reparse the
source file is too kind of correct
whether they're done
I
so there there is no standard API so if
you wanted to do that you'd have to know
you're in the Eclipse compiler and do a
clip specific things or Java seeking
specific things I just wrote a really
super facials gone through the thing
that because that was enough for what i
needed to do yeah
yes yes so they do black magic yeah we
should repeat the question yes oh oh
sorry yeah so the question is I said
that you can't interfere you can't
modify the code of a class being
compiled and the questioner points out
that there are projects out there a
notably project lombok long book that do
exactly that they do that basically by
as Christian says black magic they
basically have they cast into
implementation specific classes so a
different implementation specific class
for java sea and for eclipse that means
they're very brittle it means that a new
version of java sea because this isn't a
published api a new version of Java Sea
can just like break this and it doesn't
work anymore it's also like a morally
wrong i would say because Java is
supposed to be as i said this kind of
what you see what is what you get
language and if you go around like
mortifying so the weight lombok does it
basically inserts coding to you into
your class isn't actually there in the
source code so we're like when you're
running a debugger on this it's
completely mystifying because like line
numbers are wrong and they if it prints
out source code you don't know where
that's coming from so you know it can be
done you can always do hacks but I
wouldn't recommend it what other
questions
right right so if there are the
questions I think we're actually out of
time we can certainly take them here but
we want to leave this open for the next
presenter thank you thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>