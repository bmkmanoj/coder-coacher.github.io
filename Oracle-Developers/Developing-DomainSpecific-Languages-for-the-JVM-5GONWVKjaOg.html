<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Developing Domain-Specific Languages for the JVM | Coder Coacher - Coaching Coders</title><meta content="Developing Domain-Specific Languages for the JVM - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Developing Domain-Specific Languages for the JVM</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5GONWVKjaOg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Travis de Sala I work for a
company name did Yuki cooperation how
many here know of digi-key or have heard
of de jakke like two people awesome so
we're an electronics distributor so we
buy sell and distribute electronic
components for all sorts all sorts of
projects from prototype stuff to
production runs and so I work there in
the IT department and architect just
means that I do a lot of different
things so the title of this talk is
developing domain-specific languages for
the JVM and so if that's what you wanted
to hear about you came to the right
place
so a quick outline we're going to look
at the definition of what a dsl is we're
gonna compare and contrast internal
versus external dsls and then we're
gonna spend the rest of the time looking
at code so I don't like PowerPoint and
I'm not very good at putting PowerPoint
presentations together so a couple
slides and then we're gonna balance to
some actual working code so just a quick
recap is there anyone in here who does
not know what a DSL is or hasn't heard
the term I'm gonna guess nobody so DSL
has been around for a long time the
terms just become more widely used but
it's an old you know but it's an
actually an old thing right so SQL for
example would be a domain-specific
language you have your your Java's of
the world on one end of the spectrum
those are your general-purpose languages
and a DSL is just a very specific
language you're not going to use SQL for
example to write an entire accounting
system but what it does dealing with a
database it does very well and its
expressive and it's easy to look at and
understand and read and you don't have
to be a SQL rockstar to get up to speed
on inserting rows to a table and
deleting rows it's easy to use so
they're just small languages and that's
really a good way to think about it and
that's what we're gonna look at so
there's a picture of me golfing I
snapped that photo last week so I got
that up there we're gonna look at just
something that kind of everybody can
relate to because I kind of suspected
that maybe not everybody had heard of
digi-key so I didn't want to create a
domain problem of electronic
distribution so I chose something that
maybe everybody could relate to so I
don't have any golfers there are in the
room or there any golfers about the same
people that know did Yuki okay I picked
a bad domain then anyway so when you
call up a golf course you want to go
golfing you'll you know you'll say
alright I wanna go golfing and they'll
ask you what time and that's just called
the tee time
so you'll schedule a tee time at a golf
course they'll ask you how many guests
you're bringing along and and then your
name and then it enters into the system
okay so our use case for all these
examples is we have a system already
today that manages you know scheduling
times at a golf course so the people
have two golf course use their
application do that but we want to give
them capability to actually write
scripts to interact with our system
build a whole new language that they can
understand we can't make them learn Java
that's probably too hard just because
there's so many intricacies in learning
what's going on with Java code but maybe
we can offer a little scripting language
so now they can interact with the system
themselves or maybe we have tech support
people that when there's a problem with
the system at night they can actually
write scripts that they can get the work
done that way so that's our goal so
here's kind of a before and after slide
now if you're gonna write Java code to
tackle this problem it would probably
look like that before slide on the Left
right you create an instance of a
tee-time object and set the date and
time that the the golf event is going to
take place and then I create an instance
of a golfer class and I set the first
name and last name and the number of
guests that are golfing with them and
then of course after duty time dot set
golfer and and this all makes sense to
us because we code in Java every day day
in and day out and we see this and this
makes sense it seems easy to us but if
we're trying to offer some kind of a
script or a language to maybe a domain
expert somebody who's very familiar with
our domain in this case scheduling times
at a golf course but they're not
programmers we would really want to give
them something like what we see on the
right so if we had code on the right if
we could write a language that did that
where they could actually type in new
tee time at 2:15 p.m. for you know name
and number of guests they could get up
to speed very quickly I'd say in
learning how to use that language just
like you get up to speed very quickly
and learning how to use SQL so looking
at that previous you know focusing and
trying to kind of imprint this in your
memory this before slide look
look at how we can actually improve on
it just a little bit okay one thing I
don't like about it is that at the end
of every line we have a semicolon and
people at JavaOne all week will be
talking about those little nuances about
java that they don't like but those are
things that that we want to try to get
rid of and just the sheer number of
lines of code that it takes well let's
see if we can improve on it just a
little bit and I apologize it looks like
my there we go get my IDE up okay so
here this is just pure Java code I
haven't done a whole lot other than just
refactor it a little bit but what this
should probably show you is that or
hopefully show you is that it's a step
closer to what we want in our DSL
because it's a little more expressive so
now we're saying new T time dot create T
time and then all this is doing is every
time I call a method it's simply
returning the object so I'm using method
chaining so that I can now say set
first-name set last name set number of
guests the time and then finally booked
T time and all I'm doing to kind of
verify that this is working is when I
run it we just get some XML so in the
real world of course if you are going to
build this kind of a thing you'd
probably insert this to a database or
maybe marshal it and send it over some
web service call for example to commit
to the system we're just focusing on the
structure of the language and how we can
get it to look like this so I'm just
marshalling at XML and spitting it to
the console so here all I'm doing is I'm
using a builder pattern so this create T
time if we were actually dive in and
take a look at all it's doing I've just
got this inner static class that I'm
using to actually build up my object and
then I use method chaining so that when
I call set first name after it's set I
simply return this and I can continue to
chain methods method after method so we
don't have to have a bunch of lines of
Java code now you know obviously this
isn't how you would normally design an
API but what we're trying to do is
actually build a new language and
hopefully this shows that there are
there are some things we can do with
Java to get it a little closer
still not perfect so when we looked at
that that Java DSL that's what we call
an internal DSL so an internal DSL is a
language where we didn't write a parser
for it we don't have to create a lexer
and parser and and actually generate any
final output our final running code like
bytecode for example all we're doing
here is building a language within a
language right it's just like a fancy
API more or less and we were able to fix
a few things by refactoring that and
using a builder pattern we got rid of
most of the semicolons we just have one
in the end but we can't job is not gonna
let us get away from that completely
parenthesis you're gonna need them when
you invoke methods regardless when we
dispatch methods we have to put you know
dot set dot you know dot set first name
dot set last name these are kinds of
things that are little nuances they make
sense to us but if we're trying to build
a language for somebody they're gonna
ask us why they got to do this all the
time we're gonna tell them well that's
just boilerplate it's required but
they're not programmers we're trying to
give them a script they can get up to
speed on really quick and it often takes
a lot about a lot of code to actually
pull off those abstractions so how many
groovy people are in the in the room a
lot more than golfers awesome
I expect that so now we'll look at you
know can we make this dsl groovy so
pardon the pun there all right so what
we're gonna do is rewrite this in in
groovy and obviously we could if for
those of you who know groovy we could
make this even better yet but the what I
tried to do here was just show off a few
features in groovy that allow for a nice
clean internal dsl development so what
we see here is a language written
entirely in groovy I didn't write a
parser or anything for it but just using
some tricks in groovy we've been able to
make this a little more expressive this
is better than the Java example and it's
far better than the first Java example
we saw this is something that you could
show it to a domain expert
somebody who understands scheduling
times at a golf course and they would be
able to read this and know what it said
what it's doing
it reads just like an English sentence
now we'll take a dive into just a few of
the things that is happening here behind
the scenes that allows us to do this
and what we can do is just kind of walk
through so new tee time what I did is I
just put all of this in a single a
groovy script just because it was a lot
easier that to to pull into my actual
test utility which I'll show you in a
second so all I'm doing when I call new
tee times
Groo be smart enough to figure out that
this get is what's actually being called
and so it's gonna return me a tee time
instance and I can then invoke the app
method on here at simply takes the date
and time that the tee time event is
going to happen at the golf course so I
take a look at that app method and I'm
just using a simple date format and then
returning the tee time again and so here
I am using method chaining again but
notice we don't need the parentheses
here groovy smart enough to figure out
that this is just a single argument to
this method there's no ambiguities so it
knows what method needs to be called and
so we can omit the parentheses here okay
then I call this for golfer method and
the only reason I named it for golfer is
just because it starts to read more like
the language of the domain so new tee
time at 2:45 p.m. for golfer and then
inside this code block I have the actual
information about the golfer that is
scheduling this tee time so in this case
it's me and I have zero guests because
if you've ever seen me golf you don't
want to be on the same course when I'm
teeing off so there's zero guests and
what's happening inside this code block
take another look here this this four
golfer method it's simply taking a
closure so a closure in groovy you know
is you can think of it as just a block
of code and we can assign it to a
variable we can pass it to functions
it's really handy when we're designing
languages that are expressive because
now inside this block I can almost put
whatever I really want in here and to
show that off what's happening is this
disclosure is getting past this four
golfer method and I'm creating the
instance of my golfer
and then returning the tea time for
another method to be called when the
code is executed and for that closure
and that closure code is executed Ruby's
gonna look at this and see this as a
method call well obviously we know
there's no method named Travis to Zell
in quotes and even if there was it
wouldn't work right because this we need
to be able to change this name for
whoever's going golfing all of you
groovy guys I'm sure are familiar with
method missing so I won't spend a bunch
of time on it but basically groovy has
this hook to to intercept missing method
calls which is awesome when you're
designing DSL because now you can be the
only thing that limits you is your
creativity we can really name these
methods whatever we want they don't have
to exist and we can hook into them and
act on them accordingly again obviously
this isn't an API this is a new language
and since we designed the language I
didn't know what we're intercepting and
I know how to act on so here the method
name I actually know is the name of the
golfer and so I'm I'm simply splitting
on a space and grabbing the first name
last name and you could argue that maybe
that wouldn't work right because you've
got somebody might have multiple last
names but you know you get the idea for
this simple example we we grab the first
name in the last name and then the
argument to the method is really zero
guests well there's two things that's
really cool that that's happening here
that groovy does for us the first is
that we're just able to grab that
argument value and then set the the
guests property on this golfer so now
we've got the entire payload for the for
this golfer object inside this closure
now for those of you who aren't familiar
with groovy this seems a little bit like
magic and indeed it kind of is there is
no guests property of course on the
integer class we've all used integers
and there is no guests property another
awesome feature when we're designing dsl
is because because we want to be
creative and expressive as we can as
we're designing these things so when we
give it to the end-user they can get up
to speed really quick and understand it
well groovy allows us to hook into
existing classes and add new methods and
properties so at the end of my script
I'm
I'm using the integer metaclass to add a
new property I'm not doing anything more
with that other than just passing the
integer value on through but it adds
some expressiveness to this dsl because
now you know if we were to maybe we
didn't have that we just had Travis
dazzle and zero like the number of
golfers if we were going to give this
dsl to somebody to actually write
scripts to interact with the system they
might not understand why that what that
zero is doing we just have to tell them
that it needs to be there but as soon as
we add that dot guess it just reads a
little better and then they understand
that's the number of guests and it reads
a heck of a lot better than having to do
something like that because now we're
getting into things that are really more
code like noticed here - what groovy
gives us is some syntax highlighting
when I hover over that add method and
for those of you in the back I apologize
you might not be able to see it real
well but I get a help hover so it tells
me this is the date and time for the
scheduled tea time entered in the
following format there's an example of
usage when I hover over guests and this
is pretty darn awesome we've got a this
guests property that doesn't even exist
on the integer class but we've hooked
into it and we're able that help text
for this property that would normally
even be there and so we say it's the
number of additional golfers in the
group and then there's an example of how
you'd use it well these kinds of things
are awesome when we're trying to deliver
a DSL because now the developers that
are going to be using this DSL or the
users are able to know just like we do
when we're coding if we've done it right
if we've typed in the right thing if if
we don't then we lose our syntax
highlighting and it underlines it to
warn us that we've got the right syntax
well the way that works is with DSL
descriptors so groovy has the ability to
actually add metadata about our DSL so
take a look at the guests property for
example if we're if we're calling dot
guests on an integer this is the help
text that's going to be returned so
that's all that that's happening there
when we hover over these now we're able
to offer help text and
if we get the syntax highlighting for
free because it's able to recognize that
this property exists and so users of our
DSL will actually know if they're doing
there anything and like the rest of the
tests I wrote a little test script that
when I run it it simply outputs the XML
down here to the bottom now there is
something else that's kind of cool here
what I'm doing is simply grabbing the
DSL definition which is my groovy script
here and then I'm loading up the actual
DSL that somebody might use so you could
imagine if we were to if we were to
build this and ship it to somebody all
they would need to do is provide that
DSL script we would read in our groovy
script read in their DSL script
essentially bring them together as if
they were entered in line and then use
the groovy shell to run our script and
like I say the end result is this tea
time schedule and it's less interesting
because it has nothing to do with the
language design but what's happening
there in our book tea time method
is that we're using this XML builder to
actually output our XML so that's all
I'm doing in all of these examples when
I call this schedule T time it's just
that's where we'd actually do something
with this out with this output so the
kind of the underlying theme that's
running through here is that we're
designing these languages and at the end
of the day we're trying to take this
language pull out parse essentially the
information that we need and build up
some kind of objects or payload that we
would then deliver to some back-end
system and in this case I'm just
outputting into XML for the example okay
so groovy gives us a lot of things like
optional semicolons you can put them in
if you want but it sure is nice to not
have them in there they don't add any
meaning to our language they don't help
the user and understanding defining
what's going on so they don't offer
anything the domain so we wouldn't
really want them in our domain-specific
language we can omit parentheses
whatever grew be smart enough to figure
out what method needs to be called so as
long as there's no ambiguities there we
can leave the parentheses out
we have closures we have hooks to
intercept missing method calls and then
add new properties and methods to
classes that already exist and then the
DSL descriptors so we can actually
describe and give some helpful
information about our DSL so that the
users know that what they're doing is
correct okay so these are examples of
internal DSL so we didn't write a parser
we're not doing anything any language
generation we're simply just building a
language inside a host language but it's
different than an API because a
traditional API would be a set of
methods right that somebody would pull
in some library they call some this
method that we provide and we take care
of the back office that back office work
in this case we're defining a new
language to actually solve the problem
and a focused language which hence the
term domain-specific but what happens
when that's not enough what happens when
we decide that the language constraints
within the existing host language are
just not they're too restrictive and we
need to be more creative with our syntax
of our language and so that's where
we'll define a custom language and that
the only thing the only difference here
is that the language we're going to
define is very specific to a particular
problem in this case scheduling you time
at a golf course
normally when we design a language we
wouldn't have to write a grammar some
CFG to define the syntax of our language
and then we'd have to write a lexer to
tokenize it a parser to build up some
AST representation we'd probably have to
perform some analysis to make sure that
variables or things that are defined are
defined in the right order and then we'd
probably have to write some kind of an
interpreter or code generator that's a
lot of work so there are a lot of tools
out there that make this really easy
especially if what we're doing is
building a small kind of focused
language we don't have to get it it
actually doesn't require a whole lot of
work and so I've got a few different
examples for how to achieve this how
many of you know of antler and have used
a l'heure awesome okay how many of you
have never never even heard of a l'heure
few okay so I'm not gonna spend a ton of
time but those of you have never seen it
will be really I think you'll be really
pleased those of you who have seen it
hopefully there's something in there
that maybe you you didn't already know
or maybe doing something a little
differently so when I download and
install antler all I'm doing is bringing
in an eclipse plugin I'm an eclipse guy
so I apologize to all you non Eclipse
people I got a question right here in
the front okay you're an eclipse guy
alright good so I'm just getting props
for being an eclipse guy that's good I
kind of thought maybe I figured I come
in here with a Windows laptop running
Eclipse I'd get a bunch of people would
just see me and walk out so I've at
least one fan that's good so we're gonna
take a look at antler now remember our
goal here is if we're thinking through
our use case we've decided that we need
to be more expressive and creative in
designing our language
so we want to create a brand new
language now there are a lot of ways to
do this an antler but for most dsl
development we can build what's called a
combined grammar so for those of you who
maybe are active and language
development today you can at least
recall writing context-free grammars
back in in undergrad or grad school
right so when we really focus at the the
nuts and bolts of this in this grammar
all I'm doing is defining these rules
okay so I've defined a rule called
t-time and after the : I then define
what that teatime rule is composed of so
this teatime rule says that you have to
have the keyword new followed by this
keyword t and so on and so forth and
then after the keyword at there is this
time rule and I've defined then a
production rule for what time is time
has to be a date time from there then
I've defined a date time and you get the
idea
so here I've defined it's two digits - a
three-letter prefix for the month the
the theme here is that you have complete
flexibility and how you want to design
your language you can design it any way
you want you're no longer bound by the
syntax of a host language like when we
did the Java and groovy examples at the
end of the day it has to compile and
obey the laws of the language in this
case we're pretty free to design it
however we want now obviously this isn't
Java syntax is's and groovy syntax what
we do then is after hour after hour rule
we can create a code block to actually
put in whatever java code we want here
so here I'm creating a new tea time
class setting the time setting the
golfer and then returning that tea time
so all I'm doing here is pulling out the
pieces of information that I really care
about this new tea time act is just
syntax right we don't really need it
what we really need is the time and then
we need that golfer so we simply pull
those in and then build up these pojos
what this tea time is doing is all I've
done is created a couple poll shows I
just use Jack's be for my XML
marshalling so that's the only reason
you've got the annotation there but I've
just got a class for tea time and then I
got a class for golfer so I I wrote
these classes these Java classes and now
might what I'm doing is taking the the
input from my scripts and using antler
to parse it and build up these pojos so
that once it's parsed I'll actually get
back some polls that I can then do
whatever I want with in my case I'm
streaming and I'll text somehow so each
one of these rules executes and inside
each one of these rules is some Java
code that gets executed
you'll notice even the littlest nuances
like for example a name is a string and
then I've written a rule for a string as
one or more letters a letter is you know
a lowercase or uppercase letter so you
you know maybe a bit of work although
all of this stuff is usually reused from
language to language
you're never gonna probably redefine
what a letter is for example or a
character but but once you have it then
you can actually design the language any
way you want so now when I run this for
this example I actually wrote a little a
little script so if you recall from the
previous slide this was our goal all
along right we wanted to design a
language where we could type that in and
run it and so here I have this test golf
script we could have named it whatever
we want because it's our language we've
designed it and we say new tee time at
2:15 p.m. for travesties l and in this
case I found three you guys probably the
three of you golfers to come with me I
was actually probably only two of you
but we'll leave it at three and then I
wrote a little just a main method so
it's not a J unit test but it drives the
point across on for testing this so what
we do after we can write this this
combined grammar here is I read in my
test golf script and then I read it into
a character stream using this antler
reader stream that the antler library
provides and for those of you aren't
familiar with aller remember it's just a
jar that I pulled in and then I've got
an eclipse plugin so that I can actually
it recognizes the fact that it's a
grammar for example so it's easy to get
up and running with and then I run this
golf scheduler lecture well where did
that come from well the nice thing is
when we save our grammar as long as
there's no errors it generates the lexer
and the parser for us so gone are the
days when you need to actually go in and
define all of the rules inside your
lecture although if you're building a
general-purpose language you could argue
that you know you need the flexibility
in doing that but if you're doing small
languages antler writes this lecture for
us we don't have to write any of it and
then the parser of course too
tail on to the end of the the lecture
output that's all written for us as well
so the beauty is all I needed to do was
define the structure of my language in
here I've got some information to tell
it where I want the generated classes to
go and what other imports I need when
mice win this script runs and so now I
can create an instance of my my lecture
and then I take that token stream that
that's the result of that of that Lex
and pass it on to my parser and now I
can call this parser tee time rule and
remember at the end of the day when we
defined our grammar parser tee times
simply return to tea time object so when
we run this we'll get back the XML that
we were hoping for so you know a short
summary of Amalur we're able to define
our grammar we can mix Java code into
the grammar for processing the input
however we need I put a note in here for
those of you who are familiar with alt
you already know this but you can get a
lot more sophisticated if you need you
know if you're building a something
close to a general-purpose language or
it is a general-purpose language you can
build abstract syntax trees and then
make multiple passes and there are
things that have learned is you in terms
of like tree visitors and tree grammars
that make that easier as well in this
example we simply wrote a little
interpreter haven't we I mean we're just
going to pull that script in we process
it and as we pull in that input we then
generate whatever Java objects we need
so our example is simple but elder will
do a lot more for you if you need it to
and then Edler does all the heavy work
so it generates the lexer and the parser
for us so that we've got a simple job in
front of us I think we got a question in
the back
so the question for those of you didn't
hear the question was just that his
experience he's used and learned his
experiences that and hopefully I get
this right
that it's maybe not as flexible when you
step outside of Java so in my example
I've got I'm creating Java objects and
that works fine the other question was
he wish you wishes it was separated so
the first dance of the first part and I
got a lot to go through too so I mean I
will save time for questions at the end
so that dance of the first part you can
generate languages other than just Java
so I chose Java and that's something
else we talked about afterwards and of
course I chose Java because Java 1 and
then the other question was he wishes it
was separated and I think maybe if I'm
wrong you can catch me after after the
the session here but I think what you
were referring to is that I have this
grammar with a bunch of Java code
embedded in it and that's because I
created a combined grammar but an antler
you can separate your grammars out so
you can actually define multiple
grammars and you can define these are my
kind of final lexical rules and then
this is my actual grammar and you can
you can you can actually separate that
out if you need to so we can talk about
that more in detail maybe after the
session you can catch me in the hall but
you know hopefully can convince you that
antler is a little easier to use than
maybe your experience so now the other
thing we'll look at is Scala parser
Combinator so skull of course is a very
popular language how many of you have
used the parsing library in scala have
used parser combinators 1 2 3 ok
excellent so there's probably something
here for a lot of you people that are
familiar with antler and maybe not Scala
parser combinators if you take a lot of
those same ideas that we looked at
you can apply them to writing languages
with Scala parser Combinator's without
actually knowing a lot about Scala
granted you need to know how to program
in Scala but you can get up and up and
running pretty darn fast so let's take a
look at writing this in in Scala and
actually we'll start with our end
results so notice here we have the same
end result only we have a script that
this is what we want now let's look at
how we would actually do this using
scala parser Combinator's now the reason
i wanted to show the antler excuse me
slide first is that in that example i
assumed most of you had already seen a
l'heure and it worked out well because
there was less than no scala parser
combinators so i got lucky there but if
you recall in that antler demonstration
all we did was define all of these
production rules in our grammar and then
what we actually want to parse this is
really no different if you think about
it that way so I have a rule called T
time and each one of these rules returns
a parser and I have my result here so
what I ultimately want to do is return a
T time class an instance of a T time
class and just like in in antler then I
have equals and then the actual syntax
for what this rule looks like so I'm
going to parse this string new tee time
at and there's a lot of approaches to
doing this I just try to keep it simple
and then this till the operator actually
just combines my parsing rules here I'm
using this arrow which basically says
discard this once you've parsed it it's
important for our input it's part of our
language but we don't actually need to
do anything with it so this is the part
that I'm really focused on so it's going
to be new tee time at followed by some
time and then the word for and then
followed by the word golfer so this is
really just you can think of this as
just concatenation this rule
concatenated with this concatenated with
this and then like antler we can have a
code block that follows our rule and
execute whatever Scala code we need the
only difference here is that we use this
double caret operator to tell the parser
Combinator that we're done with our
input and we following is now Scala code
that we need to execute and so each one
of these rules like time for example
will return a date and here I'm actually
defining what it what consists of a time
right it's it's this date well date is
defined by this reg X up here which is
really nasty and I'm not a regex fan but
it works what the the reason I put this
in here was you know there may have been
simpler ways we could have just said
will accept any string and assume it's
in some date or you know then use a date
format those kinds of things but the the
beauty of this or the power of it is
that we can combine the simplicity of
some of the built-in parser library with
the flexibility of things like regular
expressions so if we really need to get
down to the details of defining some of
our input we can here I'm extending Java
token parsers there are some things we
get for free when we extend Java token
parsers for example I've said here that
first-name is just an ident okay well
this is just the equivalent of like a
job identifier darn close now obviously
that probably wouldn't be a very good
thing to have in our language for a
first name because that would assume you
could have underscores in your name and
things like that and you probably
wouldn't want that but I did this just
to show an example of the case where we
wanted a really defined rule for what
our date input looks like and something
more general and so for first-name we
did that and then number of guests is
just going to return an integer and it's
just gonna be a whole number which again
we get when we extend Java token parsers
so for a lot of these rules we don't
need to define reg X's for everything
and then at the end I'll just return the
the integer value of that input so
notice two in these in these rules each
one of these rules is just returning
some type some class and so again like
you saw an antler all I did was I wrote
a little golfer class with a first name
last name and number of guests okay and
then I wrote a tee-time class
and teatime has a you know time that
they're golfing and then the actual
golfer that's teeing off and then a
schedule method that will finally output
my XML that I want here so I'll call
that once everything's built and then
it'll it'll get scheduled so we look
back at our script here's our input
script now let's look at running it with
our the parser that we've created so
similar to again kind of similar the
same concepts anyway to the other
example we saw I'm reading in that test
golf script here I then grab all of the
the the actual contents of that file and
then I create an instance of my parser
so now that I've got this instance of my
parser again similar to what we did with
an hour I can call parse all here and
parsall's method that's provided to us
when we extend Java tolkien parsers and
all I do is I tell that parcel method
what parser I want to run and so each
one of those rules that I defined as a
parser in this case this is our route
rule and so we're gonna execute this
tea-time parser passing in our input and
then finally we'll call schedule here to
run so you can imagine if this is what
we shipped to somebody to actually be
able to write their own scripts this
would basically be the the driver
program or the harness that would pull
that script in and execute it our parser
against it and like the rest of the
examples when I run it we'll get the XML
that we were hoping for down here so
moving on from Marek
you know it's reviewing the scallop
parser combinators the beauty of parser
combinators is that you get to work
entirely within scala you don't have to
download other libraries or extensions
you get it when you've got the scala
development kit and that's awesome
if you when using the parser combinators
similar to what we saw now there you're
gonna define your language just like you
just like you did now they're very
similar to antler in a grammar format so
you'll go in and you'll define
these production rules and what those
rules evaluate to and then combine each
of those rules to farm our final DSL
syntax that we wanted which was that tea
time rule that was kind of our route
rule and like the other examples we've
seen today we can take that input in
once we've parsed it and generate
whatever output we need okay in this
case we spit out some XML but remember
at the end of that at the end of each
rule we simply have action code and
inside that that action code block we
can execute whatever Scala code we need
to process that input however we need so
we can generate XML or we can we can do
whatever it is we need to do with that
input so now we've we've looked at
internal dia cells we've done that using
java using a builder pattern we've done
it using groovy and some of the features
that it has it got better and now we've
polished our domain-specific language
using parser Combinator's as well as
good ol aller
we'll take a look at language
workbenches and one in particular is mps
so I don't work for JetBrains so this is
just one that I used to build up this
demo so there are others out there as
well so
but MPs works pretty well how many of
you have used MPs ok alright so more
than parser Combinator's which is kind
of surprises me but what we're gonna
look at here is kind of a different way
of thinking about language design so
we're not actually going to define a
grammar instead we're gonna actually
think about our language at a much
higher level so we're gonna define the
concepts of our language and the
relationship amongst those between those
concepts and then let MPs do all the
work for us so I don't claim to be an
MPs expert but it does work very well
for for all of the dsls that i've had to
to develop so let's take a look at an
MPs example that I have here so again
kind of starting with our our end result
I have the MPS IDE up here and running
it does integrate with IntelliJ but like
I say I apologize I'm an eclipse
guy so I just use the IDE that comes
with it here we have a script new tee
time at I've got my time and the name
and the number of guests which is
exactly what we want so we've we've
achieved our goal now let's look at how
we would do that okay remember and with
scala parser Combinator's an antler we
go in and we actually define the grammar
that's where we start pretty low level
but we have the flexibility there in
defining the language structure however
we need well with MPs instead of writing
a grammar you go in and define the
structure so you really want to think of
it as designing kind of the abstract
syntax tree for your language so I have
two concepts a golfer in a tee time so
within my IDE if I was going to go new
concept I get my concept editor popped
up and all I have to do in here is fill
in the name and then type in the
properties and if I type in the
properties notice that I don't actually
have to write any code per se all I did
there was hit control space and I get
some help text to just say you know what
is the type of property and now I can
name it so you know I could do something
like this and and then name the concept
for example so I'm not actually coding
and I'm not really you know I would
argue at least that it's not really
coding and it's not really I'm certainly
not defining the grammar in here what
I've done is I've created a a concept
called golfer and you can see here that
within the IDE I've defined three
properties a first name a last name and
then the number of guests and you'll
notice that I've said false for rut
because this is not going to be our
route rule because we've got a tee-time
object and composed within that tee time
is the golfer that's teeing off at that
time right so for my route rule I've
defined a tee time and I have a property
here called
time and this is an example where for
simplicity I've got it being a string
type that then will parse and and do
what we need with and then in this case
it is a root and it has a child
relationship to golfer and we've got
multiplicity here so we pro
to change this to one maybe so the sense
you're always gonna have a golfer if
you've got a tee-time but in this
example I've got zero to one just to
show that we we have that capability so
again I'm defining these kind of
high-level concepts and then nowhere in
here do I actually define the grammar
after I've defined those concepts and
also the editor for them so I can define
the syntax for what it's going to look
like when you when you actually want to
create one of these concepts then I can
write whatever generators I need and in
this case what I've done is I built a
little generator to generate like I have
in all the other examples to keep
everything the same I'm generating some
some Java code so I have a route rule
I've said take this tea-time concept and
map it to tee time in pole and I've
defined a tee time in pole class and
this is the closest thing I've had to do
to actually writing code and in this
case I didn't actually even write the
code I use MPs to say under my generator
I want to generate a new class and when
I do that
MPs gives me this form this template for
me just to fill in the details so again
we're not defining a grammar in here we
don't have to define all of the
low-level structure of our of our
language syntax we can simply define
these concepts and then the link be the
link amongst them and so in here I
create a little test and like all of the
tests we've got our syntax exactly the
way we want it and because it's an
external DSL we have that privilege and
then I can say preview generated text
and remember I'm generating Java code so
we'll see here that it generated this
Java code generated by MPs and then
again because I'm an eclipse guy what I
have done is went into my module
properties and said take all my output
and just generate it to this to my
workspace so that my Eclipse project can
bring it in so we've got integration
with eclipse that way then when I run it
then I've got the same output that we
have in the rest which is just XML
output right so we can go in here take a
look at this Eclipse project
we've got and I told MPs to place all of
the output in my Eclipse workspace and
so just MPs generated the output that I
need so now when I run this thing you're
gonna get the same output that we have
from the rest which I agree isn't really
exciting you have to work with XML day
in and day out it's the last thing you
want to do when you get to Java wanna
see more XML I'm sure but we see the XML
that we're hoping for in our output here
so with MPs you're gonna you're gonna
think at a higher level and you're gonna
think in a more abstract level and
instead of defining a grammar and all of
the the rules around the syntax of your
language you'll instead define these
higher-level concepts essentially
designing kind of the abstract structure
of your language and then you'll work on
those concepts in structure to to
actually create the properties within
them define the relationships amongst
them like you saw where I had a tee-time
class that had a child relationship
parent-child relationship with golfer
and you'll do very little of any
traditional coding instead you're really
focused on as a language designer you're
focused within this kind of workbench
tool you're focused on the structure of
your language the concepts and the
relationship amongst them and then you
can generate all kinds of output we auto
generate a Java code but you could
output XML directly if you wanted or a
whole range of things and then you can
test your DSL within the MPS IDE or like
I did I exported the Java code to
eclipse
I believe IntelliJ has got a plug-in
which makes it as anybody used the
IntelliJ mps integration know so alright
so I so now I can say whatever I want
then and it's going to be true right
because nobody can really tell me I'm
wrong
I'm not IntelliJ guy unfortunately but
they do have plugins so that you can
operate seamlessly with whatever
languages you design in MPs so what I
hope I mean I covered kind of took a
broad stroke across the DSL landscape
and we looked at internal DSL zin Java
on groovy and we looked at external DSL
is using antler
and Scala and and also MPs which is you
know kind of really starting to kind of
pick up speed in the the dsl development
community and I hope that you guys all
took away something if you didn't know
what DSL is were you you hope you do now
and if you're already developing DSL
hopefully you saw at least one new tool
or technique that maybe you weren't
already doing the question now is people
will ask as well that's really cool but
where in the heck am I ever gonna use
these well one example is adapting
legacy code so if you've got some legacy
api's and you just want to allow
developers to be able to integrate more
easily with that why not write a DSL
that sits in front of it as a facade
much easier to program with and then
behind the scenes you can do whatever
you need to do like we saw with the
Scala and the Java examples another
example would be to develop a DSL for a
particular subsystem you know maybe you
have an inventory control system and you
need developers or maybe operators who
aren't necessarily programmers but they
do they need the power and the
flexibility of writing scripts and code
in or interact with the system but they
don't want to have to learn or do or
write java every time and you can't
provide all of their power features in
just a GUI so why not offer them a DSL
where they can write the code they need
another thing I've used in work is to
actually flesh out requirements and test
cases and most of what you read is kind
of academic but it does work if I show
my business logic if my business logic
is written in a DSL or at least for at
least testing and kind of requirements
analysis faces it's written in a DSL I
can show that to the business users and
they can understand exactly what the
code is doing and I can run it right in
front of them so and I can change it
right in front of them and they see it
and they know it's a clue it's doing I
don't want to show them Java code
because they're gonna look at that and
freak out when they see it not knowing
what it's doing well this is nice
because we have something that I
understand and can show them and they
understand and can provide me useful
feedback with so a lot of times that DSL
can be used to write your business logic
so it kind of bridges the gap from
actual requirements to implementation
and then of course you can use it much
like what we talked about with a
particular subsystem
on the bottom there I have enhancing
custom IT tasks so you know you go back
to your shop and one of the hardest
things when you go to a conference as
you get back and you've learned a bunch
of cool stuff and then you just try to
figure out where you can fit all this
information in and how you can use it
enhancing custom eyeteeth tasks is a
good use case for dsls for example you
have operators and sis admins that are
having to maybe automate and do all
kinds of system work whether it's
traversing directories on a file server
or creating new VMs or interacting with
whatever software applications they're
running they're not programmers they're
not going to write code but there are
kind of power users in a way or super
users and rather than writing a GUI for
them or making them write shell scripts
to do everything give them a DSL
something that they understand and can
can code up and and apply to whatever
tasks they need to automate and and run
every day in their in their jobs I've
got some some books up here these slides
will be made available at the end of the
Java one so you don't need to write them
all down but if you're interested in
dsls there's some good references there
this is also a great week at Java one
for language development so I put in
here some some talks now this you
probably do want to write down if this
is a topic that interests you because by
the time the slides are made available
the week may be over but there's a talk
this afternoon it's a tutorial from 4:30
to 6:30 here in the Hilton on embedded
DSL which we looked at internal DSL zin
groovy so I expect this talk will be
debating groovy and Scala and which is
better and which offers which features
and then and that's a two hour session
tomorrow night there's a talk on Scala
parser combinators if I see any of you
there tomorrow night I'm speaking there
so then I'll know I didn't bore you
completely today if you're interested in
what that's going to be doing we're not
going to be repeating ourselves at all
here so with the with the thought that
maybe some of you guys might be
attending both sessions we're actually
going to write an entire programming
language using Scala parser Combinator's
it's gonna be a small language but it
will have control statements loops
if-else statements function calls
and variable declarations and references
we're gonna do it all with Scala parser
Combinator's so if you if you like what
you saw with Scala and even if you don't
know Scala but it seemed interesting and
it didn't scare you away hope to see you
tomorrow night
and that's in the Yosemite and then
there is a talk
Wednesday on groovy dsls beginner to
expert and so there again if you liked
what you saw with groovy and you want to
learn more about how to write internal
DSL within groovy there's that talk to
attend and then last but certainly not
least is integrating jvm languages on
Thursday which is an important topic if
you're gonna get into DSL development so
that the languages you write can
integrate well with other languages on
the JVM you know I'm not leading the
session but but absolutely right so we
looked at so the question was you know
how would I actually get implemented so
the beauty of the JVM as you all know is
that it's all bytecode at the end of the
day so it all lives very well together
in the same ecosystem so there are
excellent features that allow us to
integrate you know Scala to Java and and
Java to groovy and so on and so forth so
I don't know exactly what's going to be
in the talk I am I am going to attend
myself so I'll probably learn some
things as well to kind of wrap up and
give us some time for some questions
it in conclusion you know today we
looked at what is a DSL and the fact
that it's just a specific language that
hopefully does a very very good job at
accomplishing a small task and the goal
is to design syntax that's easy to read
even for a non programmer it defines the
domain very well solves the problem very
well but you don't have to be a
programmer to understand how to use our
scripting language and we reviewed the
fact that internal do cells can be
written in many jvm languages and when I
say many I just looked at groovy Java
and Scala but for internal DSL
development especially Ruby enclosure
and even Scala that the example we
looked at was an external DSL with
parser Combinator's but you can
certainly write very expressive Scala
code using its features so some of the
things we
looked at in in groovy are not limited
to groovy of course so I'm not a ruby or
a cloture guy so I didn't have examples
for that but I I've been told and I
trust that you can do just as just as
much exciting things with internal DSL
development and those languages as you
can with groovy and I assume that the
talk later on the fair duel between
groovy and Scala will maybe set the set
the facts straight right as to which
language is best and then we looked at
external dsls and the fact that what I
hope you guys took away from that is
that you're not if you were maybe a
little frightened or apprehensive about
getting into language development or
thinking about wanting to design some
small language I hope that you've at
least walk away now with some knowledge
of tools like antler and parser
Combinator's in Scala and maybe MPs as
well for designing these languages so
that at a minimum if it's a topic that
interests you you can at least get
started doing DSL development with some
of these tools miscellaneous hope you
didn't write down all that code as I
showed it on the slides as fast as you
could
it's on github so you can grab it on
there I put my work email me there so
you can email me just promise not to
send a spam bot after me because then my
boss will be very upset that I gave that
email address to you but you know if
they're if you have questions or you
have problems maybe getting the code off
get up or whatever you know just shoot
me an email so we can keep in touch that
way so with that we do have about five
minutes for questions we got a question
right here and roll four okay very good
question so as we're trying to design
easy-to-use dsls the question was what
do you do when the user actually gets
something wrong they type something
incorrectly now in all honesty what will
happen in all of the examples I show of
you is we'll get a runtime exception
right that's what you hook smacked your
hain so each one of those those tools
offers a variety of ways to to hook in
to errors and in what it will involve
though is code on your part so like for
the scala part
Combinator's for example you know we can
evaluate the the input and then based on
that we can catch whatever exceptions we
need and then handle them accordingly
with with a case statement the same
thing with antler you know we've got
Java code just running in our little
action code block at that point we'll
have to do some analysis so I think on
one of the slides before I had you know
that we have to do semantic analysis
probably when we're designing a language
you didn't see any of that in this
presentation we will see some of that
tomorrow night at least when I do the
Scala Boff session we are going to look
at error handling because it's important
as we're designing a language so the
question is you can do it you have to do
it yourself
and I didn't put those examples in this
presentation so sorry another question
okay good question so the question was
as we developed these languages well any
of them give us IDE frosting if you will
right so that you can actually get
syntax highlighting and help others and
I assume your question is more directed
at the external dsls so honestly my
experience is very limited capability
with actual helpers and syntax
highlighting although we're the MPs guys
in their room who's used MPs now I don't
see any hands now that I asked now that
I asked a question but so with MPs you
can actually and we can take a look at
it afterwards if you want but with MPs
you can actually create a build script
and you can tell it to run as an
external IDE and so that might be
something what you're kind of looking
for although the reality is that I
imagine you're gonna have to do a lot of
maybe work yourself to do that ok
awesome
so the answer to the question so thanks
to what was your name alright alright so
thanks Andy so the answer to the
question has to you know what's
available when we're designing languages
my answer was very limited offering
Andy's answer is that and ler is so if
it's antler that you're interested in
which I assume that was tools like that
but the question was directed to that
they're in the process Terrence Parr is
in the process who's the author of
antler in the process of offering those
capabilities and that's come a long way
already so don't let that scare you away
from using a handler
another question towards back ok yeah ok
so I did not bring up so ok so good
point right ok so I'm and I apologize so
towards the end of the presentation I
did mention that there are you know wait
for internal do cells groovy isn't the
only option right there's closure and
there's there's Ruby in addition Scala
and I did neglect to mention that in
addition to tools like if you're from if
you like what you saw with aller X text
isn't too far off and it does give you a
lot more in terms of Eclipse plugins so
you're right and I have played around
with X X text as well so any other
questions we got probably one minute
left otherwise you can catch me in the
hall to know well right and and and
that's kind of yeah yeah so the one cool
thing I'm getting a lot of antler
feedback and questions and Andy you know
unfortunately you're going to get like
swarmed now all these people are gonna
follow you but but I will say that I
mean now there is really awesome it's
very well supported and so now therefore
is out and so it's not something that's
frozen in time and you need to be afraid
of latching on to it because you know
are they gonna come up with more updates
absolutely there are a lot of good books
Terrence himself as published or written
books on implementing dsls and handler
reference so so very good information
out there and it's very well supported
so and there is a video series by a
Scott Stanchfield I believe and I'm
looking at and maybe you know it I've
seen it and I've watched the video
series if you're looking for just how do
you get started with with a l'heure
he gives great credit and reference to
Terrence and he's got a whole video blog
on I think it's like a 10 video series
on actually starting with setting up
eclipse with antler and then doing some
simple examples like what I showed and
then stepping through to a more advanced
example like actually writing if
statements and while
loop's and those kinds of things in
parsing it he doesn't get into then
interpreting an abstract syntax tree and
walking that tree but he does get into
actually writing the parser for it which
is probably the hardest part at least to
get started anyway so Scott Stanchfield
you could google that there's some good
videos out there for him so without
we're out of time but you can I'll get
out of here to let the next guy come in
but you can track me down the hall if
you have any other questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>