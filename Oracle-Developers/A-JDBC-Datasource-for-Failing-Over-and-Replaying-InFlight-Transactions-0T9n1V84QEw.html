<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A JDBC Datasource for Failing Over and Replaying In-Flight Transactions | Coder Coacher - Coaching Coders</title><meta content="A JDBC Datasource for Failing Over and Replaying In-Flight Transactions - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A JDBC Datasource for Failing Over and Replaying In-Flight Transactions</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0T9n1V84QEw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm Casamance I do product management
and with me this Jean Talavera is senior
deaf manager for JDBC on the condition
pool and dogmas sober whose consulting
number of technical staff and who's also
Oracle rep at the JDBC expert group so
today we are going to present you a JDBC
driver should say driver for failing
over and replaying in flight transaction
okay this is our usual disclaimer we
might talk about future force analogy
but that's not a commitment from Oracle
okay so we'll make it more concept on
technologies and product we are not here
to talk about the product there is a
product talk at 5:00 p.m. is for
anybody's interested okay so which
problem are we trying to serve with this
driver we will go through that quickly
and then we will talk about the issues
that application are confronted with in
the face of database outage okay and
then talk about some application
assessment and then take some questions
okay
so this I think you might not see
clearly but what this picture is trying
to show is that sometime when you try to
book a flight and you end to the
purchased red button and you click the
purchase button communication breaks
between the application and the database
okay so the problem we're trying to
solve is when this happens how do you
deal with that so we have identified two
main problems to address in the face of
breadth of communication between the
application the java application on the
database okay so mainly how to make a
reliable determination of the outcome of
the
meet I will explain a little bit later
why is this is a challenge and the
second problem to address is what
happens to the in-flight transition can
the driver assist in capturing while
it's going on and replaying the
transition what are the issues in doing
that so those are the two main issues we
like to address in this talk okay we
make some asad assumption some of the
assumptions that you need on a DBMS
which has been instrumented to cooperate
with the driver okay any-any our DBMS
can do that you also need the driver
which is capable of capturing and
replaying interaction between the
application and the our DBMS and I think
any any JDBC driver can do that as well
and there are some coding best practices
that we can talk about a little bit on
the other assumptions are that we assume
that there is a mechanism to give you a
notification quicker than the timeout
timeouts are predictable and you know it
depends on you cannot wait for the
timeouts to kick in so you need the
mechanism which can give you the the
notification the error message as
quickly as possible and then you need
the database which can fail over quickly
I think most databases can do that okay
so what is reliable commit outcome and
why is this a challenge so I will
explain a little bit under and dhoklas
can chime in to give you more insight
into why is this a big challenge
okay so during a break in communication
between the Committee know you hate to
commit kill you keep the purchase button
and then a break happens between the job
application on the
so you get a message from the you know
you get a message that the commit
instruction failed but this this error
message does not tell you what happens
to the commit did it commit and I did
not get the answer from the our DBMS or
did it not commit so what is the status
of this commit instruction so you might
say well I can just check the status of
the committee okay so this is the
scenario typical scenario you check the
status of the commit at T zero and you
got the information that it has not
committed usually the application will
make decision based on that information
you know that you got at T zero that the
committee has not then have not gone
through so many application made that
assumption and asked the end-user to
resubmit the you know the the purchase
order or something like that and most of
the time you end up by buying twice the
same chicken or paying twice taxes it
happens to me but the problem is between
T 0 and later on could be few
microseconds later on the our DBMS or
the commit eventually goes through so
that's how you end up buying you know
buying twenty seven flag because the
application made the assumption based on
the information it got at T zero that
the committee did not go through but the
commit went through few second a few
microseconds later so the question you
might ask is okay well is that a big
deal whatever it may be we can check
again you know a few seconds later well
there is no moment no right time to
check and get a reliable commit outcome
okay so I like doughlas on Jean to shine
in on X
why is this a big deal you know this is
really a big deal we think it's a big
deal well I think you have well
described the problem just just one
small thing that I'd like to add to what
you said the the commit operation on the
database is usually very it involves
many resources that's the call that will
make a right on disk that's the call
that will free up a bunch of resources
that's the call that will so make some a
oh maybe generate some events to notify
another tier that need did register for
notification so it's it's an expensive
call and hence it's a call that usually
takes more time than other run trips and
it's also a call that is subject to
problems and it's fairly common I'm sure
there are people in this room who have
been facing problems where the commits
comment with their our DBMS whether it's
an Oracle or DBMS or another our DBMS
because all our DBMS have to write on
disk
during commits and so it is a call that
is subject to problems and so you a lot
of applications have been trying to come
up with a way to figure out what's going
on in terms well in case of problems as
you described quasi you can actually
reconnect use it another connection to
the database to figure out whether your
stuff has been actually written on disk
whether your row is has been inserted in
the table for example but if it has not
been inserted in the in the table you
don't really know whether you're bad
your commit your in original commit will
actually go through or not as was
described so it is it is indeed a
difficult problem to solve
right and application developers are
left with having
a bunch of codes across the application
to deal with that unfortunately there is
today and without the mechanism we
cannot describe
no reliable mechanism to get the outcome
of the community okay and so this is
what we are addressing this particular
problem okay so the our DBMS will
associate with each in-flight
transaction a number you know let's say
we call it a logical transaction ID that
number uniquely ID is associated with
your transaction and this number will
only change if your commit goes through
you know it's committed or really rolled
back okay so if this number does not
change and there is a break in
communication if we can check the status
of this logical transaction ID and we
know that it does has not changed and
the other DMS tells you it has not
changed and takes appropriate action
that the classifier has spread to you in
a much more detail we you know for sure
that okay my commit has not committed or
it has committed and this is a reliable
information that we are giving you okay
so combination of logical transaction ID
and our DBMS action for example the a
DBMS Kangoo can block the transaction
from committing but the less you want to
elaborate and on that the important part
of the assisted the database not only
reports whether or not the transaction
committed it the database must actually
this is working
I can hear it okay I don't know if they
can hear it I can hear it okay so a key
the database actually makes a change on
disk to a guarantee that the transaction
will not commit so this is this is an
important part of solving this problem
is your database has to actually do
something if if the outcome of the
transaction is unknown or so far as the
database is concerned it is not
committed then the database must
guarantee that it will never commit in
the future because the whole problem
with with what what that we're trying to
address here is databases try to recover
so the database thinks it committed but
it didn't actually make it to all the
bits didn't make it to disk but they
made it to the redo log so when the
database comes back up it goes through
the redo log it finds out that yes
indeed it did commit that transaction so
more stuff gets written and now all of a
sudden when you query you discover that
yes that transaction did commit so it
can actually be you know minutes later
before the system as a whole realizes
that your transaction committed and in
order to address this problem you have
to wet have a way to force the database
to say no I don't care what's in the
reboot log or anywhere else this
transaction didn't commit and that's
part of the solution thank you very much
and you can see on the screen a code
fragment that the application developer
can use to find out what happens to the
commit so what you see here is that
you're gonna get the logical transaction
ID which is on the application
side which has been sent to the driver
but a DBMS when it starts a transaction
okay so you get this logical through the
LED and then you get a new connection
because your communication with the
database has been lost right so you get
a new connection and using this logical
transaction ID you're gonna check what
is the status of this logical
transaction ID and that's where you get
a reliable information from the database
and that's where the database might
block the transaction if it has not yet
committed okay so that's a code fragment
application developer has to use and
this is in picture the interaction
between the driver on the our DBMS
so what you see here on the left is the
application the dev application with the
JDBC driver and on the right is the
database so you get it connection you
start a transaction the our developers
will assign a logical transaction ID to
that transaction okay so you do your
interaction you know
sequel statement remote calls etc get
your result etc cetera and then you hit
the commit button I mean the end user
hits the commit button and that's where
you got this break in communication okay
so let's assume it is a recoverable
error it's not like a constraint
violation because if it's a constraint
violation it will always happen okay
let's assume it's just a matter of law
network breaking you know that you did
not get a response back from the our
DBMS so if that's the case the
application just need to do what we have
described in the code snippet before
which is get the last logical
transaction ID that has been sent to you
about our DBMS get a new connection and
make the call to the our DBMS to find
out what is
status of this routine cultural
rationality is there any question and we
can assure you on the next slide the
complete code that you can use in your
application on you can see the code
fragment is we we is in there with some
how to invoke you know this date beside
a procedure to get the outcome is there
any question on the way we are
addressing the problem go ahead
so what happens to the alternation well
you you whole go ahead the question is
what happened do you have to hold on to
the old connection only long enough to
get the logical transaction ID you could
in theory get the logical transaction ID
before you call commit there's no
particular reason to the well it depends
on how its implemented you know it what
exactly the database does of course a
database could implement it in such a
way that the connection has to be open
to get the logical transaction ID in
which case you'd have to get it before
you call the commit but there's nothing
I mean it should be yeah so anyway okay
so no you don't have to hold on to the
dead connection for any particular
length of time in fact it's the logical
transaction ID is in some cash in some
property that's what I was saying to
doctors it's a local call the gate
logical transaction ID is a local call
the driver has to maintain the value
within it within the cash somewhere
because your connection is gone so you
can you can all go to the database to
find out your yeah it's actually I need
they can you have to have the logical
transaction ID before you attempt to
commit because the the point is to
commit may fail likely because the
network went down and therefore
if you don't already have the logical
transaction ID you have no way to get it
okay
any other question okay go ahead
or what is the purpose of in working the
logical rationality is that the question
um
not quite because okay the question is
is forcing the transaction to fail does
that defeat the whole purpose of
recovery not really because when you
request the transaction outcome from the
database if the database can either say
yes this has committed in which case
life goes on and everyone's happy or it
can say no this has not committed in
that case there is no guarantee that it
would ever commit in the future and you
could say okay I'll wait 10 minutes to
see if it commits but your user might
get impatient if you were to do that so
instead we blocked the transaction from
committing in the future and the intent
there is to be able to recover by
reproducing the transaction either by
telling the user we're sorry we weren't
able to buy this book please hit submit
again or you know something more
sophisticated than that or we you know
we could just put up a nice error that
says please reenter your transaction but
at least the user would be guaranteed
that they're not gonna pay their taxes
twice like some people up here did
because oh oh you don't have to call
United I said no I did you don't charge
me twice for the same ride I only booked
one flyer I don't want two flights so
does that answer your question is to why
you want to block a transaction from
committing even though potentially some
time in the future a correct transaction
might commit
well it it's a little different because
it's instead of giving the database
every possible opportunity to recover
we're acknowledging the fact that every
possible opportunity can take a long
time at least relative to how long
things happen in the real world minutes
and quite frequently that's too long for
your users or your application so rather
than wait minutes which basically the
apps gotta stop be I can't sell any more
copies of that book I can't sell any
more seats on that flight whatever
because I've got this pending
transaction out there and until the
database is restarted and gone through
its recovery mode and we know the
outcome of all the transactions then the
whole app at some level is stopped and
that's not not acceptable so instead
we're going to you're proposing that you
would pay a price by forcing one
possibly completed transaction to not
continue and then recover in fairly
short order and allow the whole app to
move forward and that just seems in many
cases a better trade-off right thank you
okay one more question
it doesn't wait it actually just says no
I mean it either comes back and says yes
it committed or it says no it did not
commit and it will never commit so it's
an immediate return now it may say no it
didn't commit because there was a you
know if something happened in the
transaction that prevented it
committing there was already a competing
update or whatever or it may say no it
didn't commit because I've never heard
of that transaction which is quite
likely
but it doesn't wait around to find out
what's happening it actually needs to
update the database commit tables in
such a way as to guarantee that when
that system goes through its full
recovery cycle if it stumbles across the
transaction with this transaction ID it
won't be committed all right thank you
so it's not a trivial exercise for the
database to be able to more or less
after the fact
the recovery system thinks to the extent
it thinks anything since it's the
machine is dead but it sort of thinks
the transaction might have committed but
we're saying after the fact that
machines dead and so whatever bits it
has don't really count and we're gonna
block that transaction from committing
okay so we see okay one last question
okay
how expensive that would be obviously
finding out the results of a commit is
not a high-frequency operation it's not
something you do very often you only do
it when there is a failure pretty much
during the round trip for a commit so
it's not something you do often the cost
of executing that I don't think is is
that high it's probably a write to the
disk or maybe - that's not a big deal
for a database it's I mean that's a
relatively heavyweight operation but
it's not huge there is also some
overhead cost within the database
databases transaction in an engine to
manage the transaction IDs and stuff
like that so know this stuff isn't free
but the cost is not anything you're
gonna notice okay thank you so what we
think is okay the really one last
because we need to move on
with the time I'm the timekeeper
because the database is dead and it may
think it have committed but it may think
it had committed committed before it
died but that that decision didn't
propagate so nothing else in the system
knows it yet and the other problem is
maybe the database commits unsent their
result but it did never reach the client
never reach the application break in
communication anyway what we think is
with this mechanism and there are two
benefits benefit for customers is that
you will never execute the same
transaction twice you know we call this
at most one commit education so you will
never be now in the position to buy
twice the same ticket to things like
that but for developers as well you have
now a one place where you can deal with
the outcome of the transaction and you
can deal with it in a reliable fashion
okay okay so next we want to talk about
the next level which is how can we fail
over on replay in-flight transaction
without intervention of the end user or
the application okay before we we
explain how we did that we need to excel
we need to define something that we are
calling a unit of work or internally we
call this database request but I don't
know if we do it this will never make
the standard Douglas you are our rap a
big database requests make internist and
okay so the unit of work is something we
can demarcate and then we can capture
what's going on and we can replay if we
don't the market you know when do we
start recording and when do we stop now
so we needed to define something so
that's what this is about when you in
theory you get a connection we assume if
you're using our condition pool that we
begin the the transaction or no we begin
the recording but I will explain a
little bit later so we needed to define
a block of operation okay so what
happens what the driver does in normal
operation we capture all the interaction
between the driver on the our DBMS
that's phase one okay that's why we
needed to demarcate when do we start
capturing and when we stop capturing so
we capture what's going on now break of
communication happens that's phase two
there is a recovery recovery / reconnect
phase so the driver will find a good
standing a DBMS reconnect and replay
transparently everything it has captured
during phase one okay so phase two and
phase three I like you know reconnect
and then go to Phase three and replay
everything we have captured for that
specific relationship to the point of
the failure okay you want to add
okay any question on this mechanism on
capturing replay okay so let me show you
an animation of how these things work
and this is a this is the java
application in blue and this box here is
the DVD driver and intelligent driver
and here is our DBMS could be oracle
could be any a DBMS which is capable of
offering you a recovery when something
happens if one node fails you can
recover you can fail over to the other
nodes okay so what happens you ask for a
connection before we establish the
connection we create a context in the
driver we associate a context with that
particular user so we can use that to
capture interaction and then we as we
gives you the connection okay so
connection establish with the
application okay second user same thing
you know you ask for a connection we
create the context and then we
connection is established now something
happens break of communication between
the application on the our DBMS the
driver which now is intelligent you know
so we will receive the notification by a
mechanism that's specific to Oracle but
any our DBMS can have a mechanism which
is faster than timeout to get a
notification that something happens to
the our TMS so you get a notification
once a driver gets a notification it's
gonna find a good stunning our DBMS
instance okay so it found one it's gonna
transparently transparently under the
cover create a proxy object you know
proxy connection replace with the
existing connection you know proxy all
the Java objects that associated with
that condition okay that's the yellow
thing so the driver does that
transparently under the cover
use your context everything we have
captured and replay with this
intermediate this new connection but
it's not yet known to the application
the driver will use those replay the
context and if everything is successful
because mine might not be successful for
example a resource that might not be the
same some other transaction might have
updated inserted or deleted rows in that
case when you run the same query you
will not get the same result set in that
case even though the operation is
successful we are going to consider that
it's not successful because we don't
have exactly the same state the same
result set so we do some checksum
comparison to make sure that we give you
exactly the same result said that you
had before so if everything is
successful well the driver give back
control to the application and the
application continue as if nothing has
happened
so that's transparent that's how
application I mean that's how the replay
worth failing over on replay okay so you
have any question you want to know more
about we can talk with the expert here
any question on how this whole thing
works no okay I think I should give you
a demo yes time for demo let me give you
a live demo on a real database so I have
my virtual box here on the Virtual Box
we have okay so we have two two
incarnation of the driver the
traditional driver that we had before
you know before this new thing on the
new driver okay which we are calling the
replay driver so we have the no replay
on the replay we're gonna use the same
application and by playing with
properties let me
by playing with properties we can okay
so I have two different property files
and you can see that here we are using
the vanilla JDBC datasource and here we
are using the new data so you can see
replay in the name
that's the replay data source okay
everything else is similar okay here we
are using a specific service but that
does not come so this application is a
JDBC application which is using a
connection pool we have a pool of two
connection for each incarnation of the
driver and we have six threads on each
instance so 6 threads sharing a pool of
2 connections and doing operations in
the database the operation doesn't
matter it could be anything okay so
those two things we're gonna launch
those two things in parallel so I'm
gonna fit here and I'm gonna launch this
replay run or replay ok I need to show
you so you don't think that we're
cheating cut run with an or replay low
replay is a shell script which uses this
know replayed property to launch the
application ok
so similarly here we're gonna use we're
gonna use a cat run replay Rome replay
will use the replay property file okay
so I'm gonna launch the each of them run
no replay here and here
run replay
and so those two instances are hearing
the same database'
of course and doing the same operations
nature each driver are doing its own
stuff so what I need to say is that the
replay driver while this is going on is
capturing everything that's been going
on so it captures well when you come in
when you reach the end of the unit of
work we drop everything we have captured
does not make sense to keep recording if
we know this transaction has been
committed okay okay so that's going on
now I'm gonna simulate a database crash
by killing the database server processes
which are associated with those users
okay so
so I have four server processes remember
each pool has a 2-2 connection okay so
the it translate into to Oracle database
server so we have four servers which
means you know the both drivers so I'm
gonna kill all of them four zero zero
nine zero six nine and four six nine
thank you and I have my glasses all
right so are you gonna notice something
you notice that here we have these error
messages and we have we have the lady
driver to retry to get the connection
otherwise it will just stop the
application we just stopped while here
nothing happens
well something happens which is under
the cover the driver received the error
message and replace what was going on
under the cover and it was successful
and it continues as if nothing happened
you want to add you want to come make
additional comment yeah for these guys
they wrote the code you know I'm just
the speaker they wrote the code so yeah
that's so what is happening
okay
good question yeah go ahead good
question um I don't know how sneaky it
is direction oh the question is how much
memory does it use to capture the
results from the database so that we can
compare it on replay we compute a CRC so
yeah I mean there's an extremely low
probability that you could actually
manage to get a CRC collision big enough
CFC that's greater than the heat death
of the universe I can live with that one
thing we need to add is that if you are
on Intel or SPARC we delegate to the
hardware to do this Yoshiko computation
okay okay go ahead one more question
okay how long can we record that's the
question
there's no enforced upper bound there
are certain operations that cannot be
replayed and that will turn off
recording if you're running a huge batch
job you're likely to run out of memory
at some point
I mean recording the the individual
operations does take memory so it's not
just the CRC to record the returns from
the database we actually have to have
all the information required to
reproduce the original calls to the
database which means you know if you
sent a couple hundred megabytes of data
over we got to store that so if you're
trying to use this with a long-running
batch job you know this is gonna touch a
few hundred million rows and insert a
lot of stuff probably not gonna work
unless you got a lot of memory but for
your typical parties action-oriented
yeah OLTP application that does two
reads in a write you know it works just
fine
any other question okay we can try to
explain a little bit what's going on
under the covers all right so if we go
if we dive into the details there are
multiple components involved in making
this work first of all this is not only
this is not purely client-side replay in
in our design we've made the decision to
actually make it a collaboration between
the client and the server
so that during runtime so during this
capture phase both the driver and the
server can decide to actually disable
the capture phase when it figures out
that the chances of successfully
replaying what's going on in the queue
are very small or no then we will we
would disable replay the impacts on the
server the cost on the server is is
there's no memory cost on the server
it's a purely CPU cost the CRC checksum
will actually happen on the server and
the server will send a replay context
that questi mentions so for every entry
in the replay queue we will not only the
driver will not only store a record the
the method that was called with the the
arguments it will also record this
replay context so that when if it needs
to replay you will be able to find out
whether the data has changed
so there is a CPU cost involved on the
server to actually compute this replay
context the replay context has also it's
an opaque object from the Java
perspective from the Java driver
perspective so the the driver just needs
to store the this replay context opaque
object doesn't need to know really
what's inside and that was a conscious
decision as well because we wanted
backward compatibility to be possible at
some points so if the server if during
an upgrade the server needs to put some
more bits into the replay context you
don't have to actually upgrade their
clients as well so it has the number of
round trips it has the data checksum it
has some summary of the session state's
database session states so that during
replay once we also want to make sure
that the states haven't changed so
that's that's what's going on on the
server
there's no it doesn't store anything on
the server because obviously we're
trying to recover from the database out
it read so there's no point in storing
anything because that whatever you store
on the server would be gone anyway so
the whatever the server has to compute
will be shipped to the driver and it's
up to the driver to make sure this stays
around in case of problem thank you sir
the other thing we want to say is that
the driver is not using concrete classes
and that's gonna be Co best practice we
are using proxy objects so we can
replace on the decoder without the
knowledge of the application now during
normal activity you know when there is
no outage this is what the driver is
doing and Jacques explained a little bit
so it maintains called history
coordinate with the server history
things like that trust illogical
transaction ID etc cetera
when outage happens this is what the
driver does another cover you can see
here it received a recoverable exception
and reconnects to a good instance
transparently reflect me drive object by
creating a new conditional recreate the
the Java objects that were in the
previous condition which has died and
then for example you might have specific
state you want to set when you get a new
condition if that's the case you need to
provide a callback and the driver will
invoke the callback to set those
specific session but states that you
want to have in every session before it
does the really default replaying the
thing what else can we say I think we've
guess there's one thing with that can be
added here okay go ahead at least one
thing the the replay will not have
always succeed obviously and it is
important for the education to continue
to have to maintain error handling route
right so it is it is it is not guarantee
that guaranteed that this replay
mechanism will always work and back you
up from database outages the requirement
was that when we started this project it
was that first of all it should be
totally transparent to the applications
so your servlet code would continue to
execute without any change at some point
there will be an additional latency when
you make the next JDBC call that's
actually using the connection to the
database that's when the driver figures
out that actually oh my my connection is
is dead and so that's when the replay
driver will do its magic to reconnect
and redo everything so this there will
be a result set that next call for
example that would take more than
usual but that's the only visible impact
on on the business code or the servlet
code but there may be plenty of cases
where the replay driver would not be
able to successfully replay the cue and
so in that case the the requirement is
to throw the original exception so you
would get this recoverable exception as
if you are not using the reply driver at
all and still up to the the application
to make sure that it has some recovery
mechanism to at least try to hide the
ugly exception that you get from the
database on the webpage right so the
last part of the presentation is we want
to discuss you know application
assessment you know what you need to pay
attention to and things we need to we
also need to stress that if you are
using the Oracle Universal connection
pool it does the demarcation
transparently for you so very busy code
does not need to do that but if you are
using third-party connection pool the
condition pool needs to demarcate the
the unit of work for the driver you know
otherwise you can do it explicitly in
your application code but that's not
that if it's the purpose of having a
list and I didn't see applications we
are diving into the Oracle solution of
this but I want to do product pizza but
you know so right so the our technology
that I guess the technical choices that
we've made require that that requests
have to be identified and typically that
means whenever a servlet grabs a
connection from a pool that's the
beginning that's the the beginning of a
request right and when the connection is
released into the pool that's the end of
the request and we call this a unit of
work a request for the lack of a better
world
yeah a request is not exactly the same
as the transaction and we could have
done this where it was on a transaction
boundary the problem is there are more
than a few business apps that actually
execute multiple transactions to satisfy
a single web request a single unit of
work so actually replaying only one
transaction may not put things back in
the state that the the business
application thinks it is so in order to
support those business applications that
do more than one request more than one
transaction as a single unit of work
we've introduced this notion of a a
request which corresponds to you know
your basic HTTP request
yeah you mean data beside everything
happening on the database i when you eat
your web request is called a request so
maybe two last thing we want to tell you
on the the technology is that in some
cases you might have side effects when
you replay exactly the same calls for
example you're cutting shakes or
whatever you don't want to cut twice the
same checks now you want to cut it only
once
so we provides you an API that you can
invoke to temporarily disable fragment
of the your application quota you don't
want to replay you know we provide you
this disable replay and reenable replay
so that's one thing the second side
effect you might have is when you're
making when you have things such as as
this date or sequence number if your
application really needs exactly the
same as before
okay we we with cooperation with the our
DBMS gives you the ability to freeze the
time you know you play God you freeze
the time and this day will still give
the same time as even though the time
have passed you know it wins this really
say so that's really if the app your
application is very sensitive to those
kind of time stand or sequence number
right those are what we call visibles
and there are ways to say I want to keep
those meet about the same as before even
if I replay so in the Oracle database
there's a sequence that is very commonly
used and so during replay you don't want
to get a new sequence because that will
make the checksum check film invalid
right invalid
so there's there's a way to tell the
database to actually send the same
sequence
whether it's
you know the same sequence upon sampling
formidable if you're selecting the
system dates or system timestamp you
don't get the same data during replay
right yeah that's pretty much what we
have to tell you any questions that's
all we have I think it's oh yeah that's
what we have yeah go ahead
Oh a very bit of the functionality it's
okay now we're not gonna talk product
it's in the 12c JDBC driver okay there
are some licensing issue you need to be
using the rack server or the data god
server and has to be 12c database both
side needs to be 12c hey mr. rep at the
expert group the only plan is to support
the request boundaries which request
mount request boundaries are the only
real change in your JDBC source code
other than picking a driver or somehow
telling the driver that you want to work
and replay I don't think there's any
intent oh I guess another possibility
would be getting the transaction ID the
LTX ID we haven't discussed getting an
API for getting the LTX ID as far as I
know right now Oracle is the only vendor
that offers that capability getting the
other vendors to agree to an API that
only supports one vendor doesn't always
work but the request boundaries is in
fact useful in other ways which I can
talk about at length if anyone cares so
for the recording the question was are
plans to support this mechanism in the
future Jenny be system any other
question yeah go ahead
okay the question is when is this
available in WebLogic and the answer is
it is available in the Oracle data
sources so that you see P or in web in
WebLogic server starting in 12 1 1 okay
quick question in the back how about the
implicit condition cat okay watch the
implicit connection cache is deprecated
and no it doesn't support this feature
it's a dissipated in 12c wind is no
longer around yeah yeah it is the
support question the question is any
fault on supporting that with MySQL we
cannot speak on their behalf so we don't
know well we should ask them don't you
guys want to support this thing it's
useful the question yes what about J was
good question so it's really a matter of
the connection pool marking the requests
so it can work with any application
server any server even a standalone java
program as long as you mark the request
boundaries it requires that you call
begin request and n requires once you're
done and the API exists they just need
to invoke the API so it might it's up to
to the data source in jboss either the
managed data source in jboss that will
at some point call maybe our api is to
call begin and request or maybe you can
plug in you see P our Oracle connection
pool into J bus and then you'll get the
interest rate right okay yeah go ahead
yes
the question was was there any thought
to making the request boundary actually
be the same as the transaction boundary
might defer by default and with them
with the precipitation if we're writing
that and the answer is no we actually
never thought about doing that because
as we will as we were working through
the through the the problem space it
just doesn't it doesn't work yeah you
need to understand that some of our work
is directed by some of our application
suite their requirement was not to limit
that to the transaction and one of the
original requirements was also to
support read-only requests mm-hmm and we
had that so with with only read-only
queries
there's no demarcation right okay
any last question in the back after we
have have two minutes oh the question
was that does the OCR drivers support
that and the answer is of the OCI driver
the or or OCI JDBC driver does not
support it right Oh CIC library does
support the same feature not in this
release well no okay no okay
p.m. override development no okay I see
have we done okay thank you very much
for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>