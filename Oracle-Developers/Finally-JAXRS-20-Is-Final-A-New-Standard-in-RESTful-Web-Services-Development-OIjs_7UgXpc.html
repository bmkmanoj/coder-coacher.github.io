<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Finally, JAX-RS 2.0 Is Final: A New Standard in RESTful Web Services Development. | Coder Coacher - Coaching Coders</title><meta content="Finally, JAX-RS 2.0 Is Final: A New Standard in RESTful Web Services Development. - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Finally, JAX-RS 2.0 Is Final: A New Standard in RESTful Web Services Development.</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OIjs_7UgXpc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so thank you for coming my name is Marek
Boetticher and I'm a software
engineering manager at Oracle
I'm also Jack's rskopek leet and all
that I also introduced Santiago Kurtis
Gertz an who is also colleague of mine
and joxer's co spec lead and one of the
fathers of Avatar project that was
released and also the sole father of the
server site technical keynote demo
application so the thing that is moving
this robot arm the chess robot arm it's
his work and it's still running he just
told me it's still running we are not
sure about that yet something something
something's there mmm all right so
finally finally we can we've been
talking about this for a few years and
finally we can say that the jacks are
still always final it's it has been
released as a spec together with Java e7
earlier this year it was June 12 I guess
if I remember correctly and the actual
Dexter spec was released little bit
earlier by the end of May
so mmm in the next 50 or 60 minutes or
so I'm going to talk or we are going to
talk mostly about Jack's era stuff and
what's new and coming what's new
injectors to the dal
however before I dive deep into that let
me summarize briefly why I think that if
you do any
client-server development why you should
consider using rest as your primary
method of developing applications the
client-server applications anybody
completely new to rest here don't be
ashamed one two okay so few of you so
when whoever starts with the rest they
sooner or later Google up the
Royals Royce Fielding's presentation and
it's not completely a light reading it
has some pictures but it's definitely
not a comic book
however despite that whoever manages to
read that book or get more information
about about dress what you will come to
is that you will find out that the rest
is actually some architecture style
which kind of postulates some constrains
you should follow when you are designing
your applications and if you do that
what it promises you is that you will if
you do that carefully those those
constraint will translate themselves
into into the properties of the system
that you designed and those properties
are something that you mostly mostly
want in in a client-server application
such as scalability loose coupling that
supports are all very evolved ability
and also performance due to the
capability of supporting caching and
stuff like that so this is actually
nothing new and whoever has been dealing
with server client development for years
probably knows that similar things have
been promised to us also by other
technologies such as CORBA RMI soap and
you can you can think that the rest is
essentially trying to do the same just
just doing some promises but not
delivering on it however there is a one
one important difference between between
the rest and the other technologies
because rest has a powerful ally to it
and the device is called HTTP HTTP as
everybody knows is Oba Critias is a
communication standard and you can bet
at any modern software platform
including all the mobile ones which will
be which already is important part of
the part of our domain our
all those platforms are supporting one
way or another HTTP api's and this also
means that basically any even average
skilled programmer can code write the
code that sends HTTP requests and
receives HTTP responses so if you expose
yours your service as a restful service
if you expose it over HTTP you very
quickly get a lot of new customers you
can reach 2 you can reach 2 essentially
anybody that can that can write simple
HTTP request/response
or communication code let's look at what
are the options to write HTTP services
or restful services in Java basically
essentially we can we can if you think
about it you can you will find out that
there are three distinct layers of the
API is available in Java for that that
are capable of dealing with HTTP on the
bottom lay on the bottom layer there are
some low-level io containers that really
just work with sending or receiving HTTP
requests and responses and they expose
some api's that let you more
conveniently deal directly with with
those artifacts with those request and
response artifacts those are typically
really just data exchange oriented and
serve well in server well in embeddable
devices that that requires that have
only limited memory size a little bit
about that there is a servlet api that
provides some additional support is also
included in java ee and on the top layer
there are frameworks which are really
focused on on exposing api's that let
you conveniently develop directly jaxa
directly restful services and those
frameworks are jax-rs
restless fully
maybe some others and if you look at
these different types of api's you can
see that the higher up you are in the
lair the more simple and product
productive you are when you are
developing the when you are developing
your restful service applications and
also you can you can immediately feel
that the api's are on the higher levels
are forcing you to adopt the restful
constraints more directly as your as
your design or as your implementation
style
so obviously that the language of the of
the of the restful frameworks forces you
to think restfully when you are
designing your services and implementing
them alright so I promise that I will
talk or that we will talk most of the
time about jax-rs so let's switch gears
a little bit and let's recap about the
jacksters one of the one what was in
there and what was missing there so one
of the main strengths of jax-rs is that
it doesn't doesn't doesn't try to
interfere with your business logic
beyond certain point instead it tries it
it introduces annotations that let you
provide this kind of meta information to
your methods and let you and these meta
information lets you map the HTTP
requests and responses to to your
joxer's resource methods that are
handling these requests and responses as
I said the use of this API means that
the API doesn't doesn't induce any that
doesn't impose any hard constraints or
or what your class be you are not forced
to implement any specific interfaces
which is also in line with Java EE since
five that that's the new style of it and
while jax-rs is part of the Java spec
it's not it's not only usable in Java so
it's it's a standalone specification
that can be used of out of Java EE and
as such independent of containers such
as Charlotte you can develop your
restful applications again standard
protocol without actually tying yourself
to the servlet and that again is
something that can be really useful when
you are considering developing some
mobile applications or even something
doing something more with the mobile
devices or exploring what are the
options we give into Internet of Things
and stuff like that all right so let's
quickly summarize on an example how a
jax-ur is resource look like or how did
it look like from the very beginning as
I said you are starting with a POJO
you don't really need anything else than
that any anything else than that you
don't need to implement and interfaces
first thing you need to do you need to
do is to assign it assign it a name and
identifier so you can do that by by
applying the eight part annotation to
your resource or your methods as soon as
you do that the the eight part a
notation on the on the resource class
makes this route jax-rs route resource
with a specific path that that can be
that you can use to access access that
resource additionally as you can see you
can also put that annotation also on
your methods which kind of lets you
build up the whole part here he and
built up the the URI space of for your
application conveniently and in those
annotations you don't really need to use
on the literals as a strings you don't
need to use hard-coded values you can
also rely on something which we which is
called temp are templates the ID is
actually example of the pattern plate
and by that you are very flexible and
you can you can actually define your
application substance URI Subspace
almost you can expand it to almost to
support almost indefinite numbers of you
are eyes in in a single resource alright
so once you have
all your resources and methods you add
additional annotations to the 2ds to
tell jax-rs runtime which methods are
actually resource method which methods
are actually handling the particular
requests and you do that by applying the
get or post or put a delete annotations
essentially HTTP method annotations you
can even define your own one-on-ones to
if you want to extend your if you want
to extend the HTTP protocol or support
web data or something like that and once
you do that essentially your methods
become a so-called jax-rs resource
methods if it's if they're if the method
has also a SAP pad attached to it we
call it jax-rs a sub resource method the
method which has a path but doesn't have
any method it just served to look up the
resource that will eventually handle the
the instance of a resource that will
eventually handle your your request
that's what we call injector is a sub
resource locator so in this case the
customer method is a sub resource
locator okay so when you when you bound
your methods to any resources to to the
path and to the methods you can also
attach additional produces and consumes
annotations to to tell joxer's runtime
what are the media types supported by
the resource and again as you can notice
this logic this is done by applying
metadata the logic is not hardwired in
your code you don't really need to write
if-else statements to decide what is
going to be served to the client and
since the client can send the accept
HTTP exit the header to you jax-rs
runtime based on these metadata can
figure out what is the most most
suitable answer or for a representation
of the of the data to serve the client
you don't really need to do it directly
in your code so that aspect is
completely moved away from from your
business logic
okay I miss something yeah so the last
piece I I wanted to talk about which was
there since jacksters wonder those days
is the is the support for injection
joxer's led to inject lots of useful
information about the HTTP context about
the context of the HTTP conversation
such as the information from the request
the information from the URL request URI
or from the headers of the request or
from the Curie parameters etc by using
special annotation so you can apply
those annotations either the method
parameters are serving the they are
serving the particular requests or you
can apply these annotations also to the
to the jax-rs resource field or
gatherers or setters and since by
default
joxer's resource class creates a new
instance for every single request this
will work obviously if you have a single
tunnel request which is or also another
option the attaching this information to
the fields is not is not suitable and i
would advise you to mostly use the we
use the method that is described here to
attach the annotation to attach the
annotations and consume the request
scope specific information inside your
method parameters so that was briefly an
example of how jax-rs looked like since
one dot o H or and one dot one in
addition to what I just showed you in
the in addition to exposing your
projects as resources a jax-ur has
provided provides you since the very
beginning some additional useful
facilities how to inject the addition
the extra information about the convert
HTTP conversation context some of them
was already mentioned also it provides
you some extension points where you can
plug in your own ways of supporting the
media types beyond the standard ones
that are supported by Jack sorry so by
default
sorry supports marshaling to text plain
XML and bunch of others and also
supports marshaling of specific standard
Java put Java types into those into
those into those media types so if you
want to do something extra such as
support Jason you can write your own
extension that lets you do that all
right so enough about jacksters
wonderdog let's switch gears to
jacksters to allow and before we do that
let me just quickly summarize what we
did between the two version so it's a
it's indeed a my major update in I ran
some statistics using some open source
tools based on the both code bases and
it turns out that we actually managed to
increase the in terms of the the classes
of the API v we increase the code we
increased the API one and a half more
than one and a half times also the whole
code base which means also the including
the all the implementation code and and
all the documentation is three times
larger so as you can see we did quite a
lot of work and most importantly the TCK
test coverage the compatibility test kit
contains curl now more than six times
more tests to test that every
implementation that implements jax-rs
specification is compliant and adheres
to the spec as much as possible so this
is a is actually quite an important
improvement and it was actually
controversial quite a bit because once
we release the TCK implementations the
implementations of jacksters 1.1 some of
them even some of the major ones found
out that they are actually not compliant
with with the spec and we had to solve
it so also in terms of the even with all
that increase in in the indie API were
able to improve on on Javadoc which was
on in some places not
not covering the the situation well
enough and I guess we will continue to
do that with the future releases as well
so and we did let me let me try to us
something I got to take over and talk
about the features themselves all right
so let's dive into the 2.0 features and
unfortunately we have more features than
we have time today that's I guess a good
thing so we selected a few features that
we thought be interesting to you but at
the same time what we've done is we put
a number of different slides on the
other features in an appendix to this
presentation so if you have a chance to
download the presentation after job one
you can take a look at the other
features explained there as well so the
ones I'm going to be talking about today
are the client API as synchronous HTTP
processing filters and interceptors and
configuration features or a common
configuration as we call it and let me
see if I can use the clicker here all
right so let's start with the new client
API before I start I'd like to get a
show hands of who has tried to use the
HTTP URL connection in Java to access a
web resource raise your hand now keep
your hand raised if you thought that
experience was Pleasant okay that's it
that's all I needed to modify right so
one of the number one features that
we've been asked is what about a client
API since jax-ur as one came became
available and so the main problem with
the HTTP URL connection is that it's
just not at the right level of
abstraction in the same way that you
probably don't want to write an entire
rest allocation using servlets if you
know about jax-rs you wouldn't want to
access web resources using the HTTP URI
URL connection if you see this API okay
so and the other thing we wanted to do
is we want a bit to make sure that we
could reuse certain concepts mainly the
providers that we have in jax-rs
in the API so that we're really working
at the same level of abstractions we
don't want to think about HTTP requests
we want to think about accessing web
resources
so the API that we came up with is of
the fluent kind you may have seen many
of the new API such as the lambda API
using this particular style in a fluent
API what we do is we chain method calls
and we try to essentially make a if you
will so that when you read that
particular statement you can understand
what's going on and so these are the
objects that we have I'll just move on
to the next slide these are the main
concepts that we have it since it's a
client API we need a bootstrap process
to start everything and we have a client
builder for that and of course if we
have a client builder we are gonna have
a client at one point and we do the
client is going to manage all the
connection and we're gonna see that it's
something that we can configure for our
particular application and then from a
client we're gonna create what we call a
web target I'm also going to be calling
that just a target because we use it two
terms interchangeably and you can think
of a web target as being a glorified URI
but as we shall see it has been
glorified really nicely so let's jump
into an example and see how we can use
this client API so step number one it's
the bootstrapping step we need to get
access to a client so we just say client
builder dot new client no rocket science
there the next step is well we want to
access a web resource remember we're not
thinking about HTTP request here's we're
really thinking about accessing web
resources so from the client we can
create a target or a web target and for
that we specify a URI now this is an
example of an orders rest application so
the orders URL is going to point to
perhaps all the orders that are
available we may be interested in
accessing one particular order from that
set rather than the entire set so what
we can do is we can take this one step
further and create another web target
from the target that we create it and
adding a path to it of course I can do
all this in one sentence right in one
statement because it's a fluent API but
I just we just broke it up here so that
you can see all the steps and notice
that one of the things that we have here
which not all Kline API support is the
idea of
plate variables but these are if you've
used jax-rs server-side you must be
familiar with this particular syntax
where you can say you can put a template
variable inside curly braces and then
fill in that hole later on and this is
very convenient because we often reuse
these web targets with different values
for the URLs and certainly we do in this
case depending on the order that we're
trying to they were trying to get okay
so now that we have that so how can we
actually get a representation for that
resource well first of all we need to
fill in this hole that we have created
in our URI by providing a value for that
template variable and for that we use a
resolve template the next thing we need
to do is we need to specify what is the
representation that we're interested in
getting remember that in in rest and in
HTTP the client is in control of the
representation that it wants so we say
dot request application slash XML in
this example indicating this is the
representation of the resource that we
are interested in getting and finally we
have the HTTP operation itself which is
about get and we can also optionally
indicate a Java type or a Java class we
are a class reference to indicate well
when you get that representation please
give it to me in the form of a Java
object okay so this because we do that
then the type of the entire expression
it's going to be the type of the last
parameter in this case an order so we
don't have to do any casting and assign
that to an order now something
interesting is going on here we are
requesting an XML representation but at
the same time we're requesting a Java
object so we have something in jax-rs
that can do that conversion who
remembers what that is oh you do I don't
have to do it's what we call a message
body reader right so message body
readers are available in the client as
API as well as on server API and this is
an example of how we get to the same
level of abstraction so if we have a the
proper message body reader that knows
how to convert an XML representation
into an order object then we're done
let's take a look at another example
so how about posting new new resources
or creating new resources well let's say
that we want to post a new order so we
have the order object in our data model
and so we can establish a new request
this is going to be of the post kind not
the get kind and we're also going to be
indicating well first of all we notice
that we're using orders target not order
target because the ID is going to be
generated in this case for the order
with that we're posting we don't know
that what the idea is so we are also
requesting the representation for this
ID to be text slash plain and finally we
do the post and here we have a couple of
different ways in which we can express
what is the representation of the
payload that we're sending or the entity
that we're sending one way and one that
we particularly like is using some
methods in the entity class also part of
the API so we can say something like
entity dot XML to indicate that the
order that we're posting we want it to
be represented in XML so you can think
of this entity dot XML of like being a
caste if you will you're indicating
what's the representation that you want
for that order okay so this is great so
but how how can we make this a little
bit more interesting well the first
thing to notice is that in this case we
haven't indicated what is the Java type
that we want back from the result of
this post and because we haven't
indicated that we're gonna get a
response rather than a specific Java
object and we're gonna see why we do
that let's say for the sake of the
argument that whoever created this rest
service know something about
hyperlinking and hype and hypermedia and
it's going to give us links to other
things that are associated to this order
so as an example when I post an order we
can assume that there's going to be an
invoice associated with this order so
our task is going to be to see if we can
get access to that invoice as well via
hyperlinking so this is how we can do
that so the first thing we do is we
check that this is an okay
response that everything went as
expected if that's the case then we can
go ahead and read the order type I'm
sorry the order ID we probably need to
use that later it's not actually using
this example and now we can and in fact
we
you specify what is the Java type that
we want to get for that order ID so
we're seeing saying that we want to read
the entity as a string and once again
there has to be some magic going on here
as the representation is to explain and
we're asking for a string representation
or a string object rather so once again
a message for a reader it's going to be
in place here in this case is going to
be one of the standard ones that that
are part of the JAC service platform but
after that this is the sort of the new
part one of the new things that we
support in jax-rs 2 is the idea of
including links to other resources and
we can do this using what we call what
is called link headers so once we get a
response we can actually request one of
these link headers via its via using a
string which corresponds to the
relational value or the rel value of
that link in in the real world we will
probably check if that link is available
it may or may not be available available
but if it is then we can use that link
to create a new target and get access to
that to that invoice for the order that
we just post it so this show you see one
of the new things that we have in jax-rs
which is the ability to do easier
linking between the resources of course
you could always do linking by hand by
putting URLs inside your representations
but using these this new feature it's a
little bit easier ok let's talk about
the next topic which is asynchronous
support in in jax-rs
and for this I like to use an analogy
that occurred to me while I was going
through these lights and the analogy is
related to a call center so these are
1-800 numbers that you call whenever you
want to do something with your credit
card or your bank or your insurance or
whatever it may be so the first time you
call one of these places I mean they
always put you on hold of course and
they put this nice music that sticks in
your head for the rest of the day and
there are a few different things that
you can do when that happens number one
perhaps the first time you call the call
center the one thing you can do is you
can just stick glue to the phone you're
on the
and just wait and wait until somebody
picks up so you're essentially blocked
okay so if you had to do some work
because you're on the phone you don't do
anything you just wait for that the
person on the other end to pick up for
that music to stop for a little while
and this is essentially what we do when
we do synchronous programming and this
is something that typically in Java we
don't care very much because in Java
it's a multi-threaded environment and
therefore we think well you know if this
thread is block I'm sure there's going
to be some other thread that is doing
something interesting so I don't care
JavaScript programmers care because in
JavaScript the model is single threaded
so you'd never want to be block or
you're blocking everything but the fact
is that in even in Java there are many
cases where we do want to not block as
an example is when we're trying to
access a certain resource that then
maybe takes a little time to get to us
so going back to the analogy of the call
center perhaps the next time you call
you're a little bit wiser and then what
you do is say well what if I use the
speakerphone and or the headset and then
I put on the speakerphone and start
doing some work and periodically what I
do is I check and make sure that the
music still playing
they only probably that sometimes the
music pauses for a little while and then
it resumes but you can you know keep an
ear on that music and see what happens
so that's something we can also do in
jax-rs using one of the new features
which is async so the first thing to
notice is that we have a new invocation
as part of our fluent sentence or
statement which is async and this is a
way we indicate the jax-rs client
runtime that we want to do this
operation asynchronously and because
we've done that then the runtime is
going to return something called a
future if use yeah if you have used any
of the concurrent API in Java you may
have encountered this class before so a
future is something that we can
periodically check to see if essentially
the future becomes the present and if
the future became the present then we're
ready to get the value if not we keep
waiting so this is a little bit of the
analogy of with a call center where you
are actually doing a little bit of work
but you know periodically checking on
what's go
with that without coal and once we know
that the value or the resource became
available then we can call get on the
future and we're done but in the mean
time we were able to do a little bit of
work yeah what you probably shouldn't
but all right but the question is can we
do better okay and it turns out that we
can't do a little bit better and in fact
I've noticed that the call centers are
doing something a little bit better
lately what now in some places when you
call one of these numbers they actually
tell you why don't you leave us your
phone number and we'll call you back
have you guys noticed that that's
something new I think they actually read
our spec and got the idea from us
in fact we so they don't well they do it
in the States now so yes we can do that
in jax-rs as well we can we can actually
essentially leave a phone number and
have us in have somebody call us when
the result is available so to do that we
still use a sink of course just like
before but rather than having to deal
with the future and the future becoming
the present and all that stuff then we
just specify an invocation callback I
notice that the invocation callback is a
parameters parameter ice type that has
the message as the type and that's what
we're gonna get if the operation is
successful so if the operation is
successful the completed method is going
to be invoked and we're gonna get we're
gonna get our message and otherwise the
failed method is going to be invoked and
we're gonna get throw a ball or an
exception so this shows you the
different kinds of things that we can do
on the client side and of course when
you're building certain types of clients
especially a client that is also
managing a user interface in the same
thread you probably want to use async
processing so that you don't block the
UI refresh and stuff like that all right
so this is all great so how about the
server side
do we have a sink on the server yes we
do and so what does why do we need a
sink on the server let's think about
that for a moment
well the server usually doesn't know
much about the client
the client may already be doing a sync
which means that if the client was is a
smart line it's not actually waiting so
why don't we need to do anything special
in the server well it turns out that
even if the client is not waiting when
we're running on the server side
somebody else is going to be waiting for
us when we're running on the server side
we're typically running inside some sort
of container that is managing the
threats for us right when we write a
jack service resource we don't have to
think about threats and things like that
typically because that just happens and
it's managed by the container well it
turns out that if it takes a while for
the resource to be produced and
therefore the representation to be sent
to the client then the container is
going to be just waiting for us to
produce that response so in that case we
can also do a non blocking operation and
inform the jax-rs container that the
response is not going to be immediately
available and therefore it can take that
threat do some other work and then we'll
later respond and that's basically what
happens with the synchronous jax-rs
services let's take a look at an example
of that and Before we jump into the I
hope we can get through this example
unharmed because I I went through it and
it takes a little while to get but let's
see if we can understand what's going on
here suppose we have producers and
consumers of messages okay and because
these producers and consumers of
messages may come at different times
what we're going to do is we'll use a
data structure to store the messages and
so that if a producer comes before the
first consumer comes then you know we
can do something with that but let's
assume for the sake of the argument that
we would not say that no consumer is
ever going to wait ok so when a consumer
asks for a message if the message is not
available we don't want that operation
to be blocked ok so we're going to have
this messenger resource class that has a
queue and then we're going to implement
the method get message in a sync fashion
so to do that there are a couple of
things you need to do in Jack's RS first
of all you need to use a special type
that we call an async response and the
way you use that is by
injecting that as a parameter to your
method so for that we use the ad
suspended annotation which is a new
annotation jax-rs and we indicate that
and with that we're indicating to the
jax-rs container that we are now going
to produce a response right away but
this is going to come later on and the
first thing you can notice here is that
the get message method doesn't return
anything it's a void method which is
pretty strange for jax-rs
so what we do is we because it's an
async response it's a Java object is a
first-class citizen we can push it into
a data structure and we do we just push
it into the queue so think of this as
being again like your your your phone
number or your personal information
that's been pushed to the queue when it
couldn't when a producer comes later on
they're going to send they're going to
look up that information and you're
gonna send you that message to the
information that you left there but
because we don't wait forever we also
have the option of setting a timeout
Handler and indicate well if the message
doesn't come in more than 15 seconds
then I don't want to wait any longer to
forget about me and that's what we do
with a timeout handler here so let's
take a look at what happens with the
producer or the other side of the
equation if you will so the producer
who's posting a message it's going to go
and check if there are any async
responses available in the queue okay so
think again about the async response as
being your personal information almost
and then if there are then it's just
gonna call resumed on that async
response and send you the message okay
if there are no no then it's gonna have
to wait a little bit until one becomes
available but basically this is the idea
that where you can do how you can do a
sink in jax-rs let me go back to the
previous slide for a second you define a
new parameter a new parameter called
async respond so we've defined a new
parameter equal async response and we
use the add suspended annotation to
indicate that and of course you notice
in this particular example that the
response is going to come on a different
thread this is something we didn't have
before before the the response and the
request always came on the same thread
alright so next slide this is the state
diagram for the responses I think I'm
just going to leave this as a an
exercise to the reader to
go through this but basically we are in
suspended mode if we get the timeout we
can suspend again or we can resume or we
can cancel all right so to summarize the
async response on the server side we
have a new type called async response
which in a way similar to async context
for those of you that have used
asynchronous servlets before it it's
similar to the support there except that
it has been pushed into jax-rs now we
essentially detach the request thread
from the response thread and we have the
ability of doing timeouts and we also
have a new annotation call-out suspended
but we think in the future may be used
for some other purposes alright so next
topic the next topic I'd like to talk
about is filters and interceptors this
is so also something new in jax-rs 2 and
these are two new forms of providers in
jax-rs 2 so let's start with an example
again suppose you have a rest
application that has hundreds of
resources and your boss walks into your
office and says you know what I we are
being audited I want you to start adding
a log for all the resources that people
are asked that are getting from our REST
application so how can you do that well
of course one way to do that if you want
to add login is to edit every single
method resource that you have a resource
method that you have and add you know
two or three lines that check if the log
is enabled and our log and blah blah
blah of course that's going to take a
long time and we know we can do better
if we've done it some servlet
programming we know that in servlets we
have the filter and so what we can do is
you can inject a filter into the
processing pipeline and then the filter
can do the login for you and you don't
have to touch your resources this is
what we call cross-cutting concerns and
in fact you could perhaps use a servlet
filter if you were running in a servlet
server environment but for the same
reason I earlier about the client API
you don't want to be crossing
abstraction layers like that so we
created the idea of a filter for jax-rs
and and we think that it's something
very useful for people to to use and
examples of that are logging as I gave
you that example compression security
anything you want to do as a
cross-cutting concern you can do it
through a filter the other advantages
that we
have support for filters on the client
side so you can filter requests coming
out of the client as well as those
coming into the server and the fact is
that we had proprietary api's for
filters since many of the jacks are s1
implementations had some notion of
filter so it was becoming more and more
difficult to move an application from
one vendor to the next so that's another
obvious reason why waste and arises so
let's see what kind of filters we have
in jax-rs so filters come in various
flavors we have either container filters
or client filters okay and and the other
the other axis there would be it's
either a request filter or a response
filter so that gives us a combination of
44 different filters we have container
container request filters client request
filters as well as container response
and client response now when we talk
about filters i've been using the plural
all the time because you can in fact
have multiple filters you don't have to
have one typically you would have more
than one you'd have one for login one
for security and and and some of the
other cross-cutting concerns you may
have in your app so the filters actually
are all gathered together in what we
call the filter chain and the filter
chain in jax-rs is of the type of a
specific type that we call non wrapping
so what does that mean it means that the
jax-rs runtime is going to call a filter
and then the filter is going to return
control to the jacksters runtime and
then the jax-rs runtime is going to call
the next filter and get control back to
jax-rs
runtime and so on and so forth so it's
basically calling all the filters in a
loop and you can think of the stack
trace or that invocation to always be
constant it is possible for a filter to
decide to break that chain
perhaps a filter that you have in your
app is doing some sort of smart caching
and it has found a response so you don't
actually have to hit your resource
method and you can just return that
response and break the chain so let's
take a look at an example of that the
canonical example is the login filter so
to write a login filter you say that it
implements a container request filter
and it has a single method
filter and and and then what you're
gonna get is a context in the context is
going to have information about the
request that you're filtering with that
context you can extract whatever
information you want from the request in
this case we're assuming there's a lock
function that we're calling and it's
just doing some pretty printing of the
requests that we're getting and that's
all you need to do and once you have
that class available in your application
and we'll talk about how to do that then
you're gonna have the filter enable for
the resources that you want so the other
thing we added is interceptors ok this
is a little bit different from filters
how many of you are familiar with CDI
interceptors have ever used to see and
okay so of you see dia interceptors are
similar to what we have here except that
CDI interceptors are generic when they
design the interceptor API and in in CDI
it was designed so that you can
intercept any method it turns out that
there are a couple of methods in the
JAXA rest runtime that we want to
intercept and because they are so common
we could we've created sort of custom
interceptors for those those two
interception points and the reason to do
that is because if you ever had to write
an interceptor you would have seen that
the all the parameters that you get in a
CDI intercept or it's all very generic
and you have to look for the where the
parameters are and things are not so
straightforward as as they may be as
they should be so when looking at this
problem in jax-rs we decided to create
interceptors but just for these two
places that we want to intercept rather
than a new generic mechanism a lot of
people think that we've invented a whole
new interceptor API in jax-rs and that
cannot be further from the truth the two
places that we found very useful to
intercept our readers message for the
readers and writers more precisely they
read from on the right to method of
those two classes now the interceptors
are also in a chain just like the
filters but the chain instead of being
non wrapping as before it's a wrapping
chain just like the cd-i interceptors
will be and that means that when if we
have multiple interceptors when we call
the first interceptor then that
interceptor is going to call the next
interceptor in the chain rather than
getting control back to the jax-rs
runtime and they still have the ability
of breaking the chain and all that so
let's take a little an exam
of an interceptor and and and again
going back to the example I gave you
before suppose that your boss walks into
your office and says you know we're
spending way too much money in our isp
account so can we just do compression on
all of our messages and sure you can go
and change all your resources and
message for your readers and writers to
do compression or you can just write a
single interceptor and throw it in your
app okay so here's an example of a gzip
interceptor that is gonna do compression
for you it's a class that implements
reader interceptor there's a single
method called around read from and just
like with the filter case you get a
context and all you have to do really to
do compression is to in real life you'd
have to do a few more things but for the
sake of the example we made it as simple
as possible all you need to do is you
need to wrap the input stream into a
gzip input stream so that when the final
message weary reader is reading it's
actually reading a decompress stream or
a inflated stream right and that way we
have actually sort of changed the the
underlying stream that the reader is
reading from bye bye rabbi doing this
wrapping and then we don't have to
update the message for a reader and once
you do that then you can call proceed
which means you know call the next
interceptor in the chain and if the if
this happens to be the last interceptor
then we're actually going to be calling
the message for a reader and then
because this is a well-behaved
interceptors is sort of restoring the
old input stream so that when it returns
control back to the previous interceptor
nothing has changed so this is an
example of how to do another form of
cross-cutting concerns with interceptors
rather than the filters because we have
chains we need to have priorities if we
have multiple filters and multiple
interceptors in a chain you know which
one is executed first which one is
executed last and so for that we have a
new property called priority which just
takes an integer value essentially the
larger the value the lower the priority
and you can attach that up that priority
to the filter interceptor that you
create and we've also defined some
default priorities that we use
internally in jax-rs
and these are the different classes if
you don't specify a priority then you
get user priority which is the lowest
presidents all right so now we have this
idea of filters and interceptors these
are two new providers in jax-rs
but we haven't talked about how do we
tell jax-rs that we want a certain
filter interceptor to be connected to
one of our resources one of our resource
methods in particular this is what we
call binding we say we create all these
message what I'm sorry these filters and
interceptors but then we have to tell
jax-rs
oh by the way I want this particular
filter to be connected to this resource
method or this interceptor to that
resource method if we don't do anything
any specific binding then we get the
default binding which on the server side
means that it applies to everything in
our application on the client side it's
gonna be a little bit different but
what's interesting is that we can also
do some custom binding where we can just
take a particular filter and associate
it with a resource method and the same
for an interceptor let's see how we can
do that and again this borrows from
ideas and c-d-i the way to do that is
the first one is the static way which we
call name binding we name binding what
you do is you create a new annotation so
you have a meta annotation called name
binding that you can use to annotate an
annotation it sounds complicated but it
isn't and what you do is once you create
that annotation then you can attach that
annotation to both the filter or the
Interceptor as well as the resource
method that you want that filter and
interceptor to apply as long as you put
that on both places then the two are
connected and that's all you need to do
and of course this is pretty static
because this is all compiled into your
code so as an example we have this new
adaptation called add logged and we put
the annotation on our login filter that
we created before and then we can go to
one of our resource methods like hello
and attach the same annotation to that
method in that in that way we're
indicating we want this particular
filter to be associated with this
particular resource method and we're
done so this is very nice it's very easy
to read that's other people can come and
look at the code and understand what's
going on especially if you picked really
nice names for these annotation
but it turns out that in practice there
are some cases where you want to do
something a bit more advanced perhaps
you want to associate a filter and
interceptor with the only classes that
are in a certain package and are related
to a particular module within your
application so just doing name binding
statically it's not sufficient so for
those cases we have what we call a
dynamic feature and basically this is
something that is resolved at deploy
time so when you deploy your application
you're basically gonna get an invocation
for each of the resource methods you
have in your application and you're
gonna have a chance to configure that
resource method in whatever way you want
okay and so let's let's start with an
example and then we can come back to
these types here so here's an example of
a dynamic feature we call a security
feature so remember this is something
that happens in deploy time in the
invocation and and the jacksons runtime
is going to invoke the configure method
passing information about the resource
including the method and by that I mean
the actual java method object as well as
a configuration that we can that we can
update in this case we're assuming that
we're doing some sort of jax-rs
extension with some new annotations and
we're so we're looking at the actual
java method for a certain annotation and
if that annotation is available then we
want to attach a filter to that
particular resource and this is what the
dynamic feature allows you to allows us
to do essentially right any Java code
any condition that you want to attach
filters and interceptors to return it to
the resources in your class so if you
have something that is more complex that
you cannot do statically the dynamic
feature is the way to go all right so to
wrap up the client the I'm sorry the
filters and the interceptors this is the
how the client pipeline looks now in
jax-rs 2 so starting on the Left we have
the application that it's producing a
request the request is going to go
through the filter chain until it gets
to the transport and at that point we
have to actually produce an entity for
that for that request and we're gonna
have to use a message body writer to do
that and if there are any interceptors
associated with that message body writer
those will be executed in a chain and
and the last part of the last piece in
that chain is going to be the message
body writer itself coming back in the
other direction we get a response from
the server and then we filter that
response all the way until it gets to
the application and then the message
body reader just like in jax-rs 1 it's
only going to be invoked if the
application decides to do that it is
possible for the application to just
look at some headers and say I'm not
really interested in this response and
completely ignore the entity but if the
application doesn't do that and there
are interceptors configure then we're
going to go through the chain of reader
interceptors before we get to the
message body reader server pipeline is
similar except we have one more twist or
one more flavor of interceptor in filter
which is called pre matching as you know
when jax-rs one in the server side when
we get a request we do something called
resource matching we look at the request
and there's a very detail algorithm in
the jax-rs specification indicating how
we're going to match a particular
request with our resource method now
there are some cases where we want to do
some processing on the request before
that mapping takes place for example
there are some cases where we may want
to change the HTTP operation we want to
change it say from put to post or
something like that and in those cases
whatever change we make is going to have
an impact on the resource matching
algorithm right because we may have a
different resource in our in our class
one annotated would put and the other
one annotated would post so if we want
to write a filter that is going to do
something like that then we have to
indicate that that filter is a pre
matching filter by default they're all
post matching they happen after the
matching algorithm has has completed
that's the only difference in the
server-side pipeline there we have
another chain which is the pre matching
chain all right so the last topic I want
to talk about today is common
configuration yeah
common configuration it's something very
interesting that we added also in jax-rs
2 and we haven't I haven't talked too
much about configuring decline so let me
just show you an example of how you can
configure the client and that's going to
motivate why we have this common
configuration and the improvements the
improvements that we
made so that you can do this a little a
little bit easier all right so now we
have all these rich set of providers we
have message body readers writers
filters interceptors exception mappers
and we have a few that we haven't talked
about so how do we configure a client so
that all these things are in place once
we start accessing resources using that
client well we use the fluent API the
fluent API has specific methods where we
can register things like body readers
worried writers or inter and
interceptors as we do in this case we
can also put some properties that we may
need to configure this particular client
and so the fluent API gives us the
ability to do this but it turns out that
in practice especially for large
applications you're gonna have a
collection of these readers writers
interceptors filters whatever it may be
that all need to be configured in one
shot and if they're not all configured
then the application is not going to
work if in the various parts of your
application you have an instance of
client and every time you want to use
that client you need to go through all
these steps for registering all the
pieces then it becomes really tedious so
there is the notion that we introduced
in the specification called a feature so
I talked about dynamic feature before
this is a different kind of feature so a
feature is something that allows us to
do some configuration of all the things
that we need in one shot so we define a
class in this case the JSON feature
class and which implements the feature
interface and then excuse me and then
when the method configure is called then
we can do all the configuration that we
need for our particular application by
simply using a context object if we
define a feature like this then rather
than doing this we can just do this we
say client dot register
Jason featured our class and that client
should be lowercase that's just
PowerPoint insisting that I don't know
what I'm doing
so Jason featured our class is a
reference to the feature that I just
show you and rather than having to do
all those steps to register all those
things that we need in and for our
application to work we can just do it in
one shot and in fact we can do even more
than that what if we need to configure
this feature in some way before we
enable the feature we can indeed do that
we can create an instance and oh pretty
much all the methods engine jax-rs
client and server take either a class
reference or an instance of that class
so in the second part of the slide you
see an example where we actually create
an instance of that feature we tweak and
initialize that feature in one way or
the other and then register it and we
can do the same thing on the server side
so how do we configure things on the
server side well on server side we have
class scanning so with class scanning we
can find things like filters and
interceptors and things like that but we
can also do it manually by subclassing
the application class I'm sure you've
done this in jax-ur as one a few times
so in in that subclass that we define we
have a method called get classes and
there we can do whatever registration
that we want and here's the same example
basically server-side we can do it one
by one or if we had the feature defined
then we can use the feature on the
server side as well and so this is this
more or less summarizes what we have
talked about today and a few things that
we haven't talked about and as I said
you can go and look at the appendix 2 to
this presentation for that and you want
to have a few more minutes on there ok
and with that we can leave it open to
questions we had another section here
that to talk about future ideas for
jax-rs
if you're interested we can go over that
otherwise we can open it up for
questions yeah go ahead
that's because on the server side we
already had this before this this is the
way you did it in jax-rs one to register
things like message for readers and
writers so we we haven't invented a new
thing for the server side so this this
admeto this from the hashmap because you
need to retain or know either you need
to return a hash side so that's just the
method of the hash self yeah
yes it's the using either the message
rotary reader or writer depending on so
you have to have a message for a reader
configure in your app
okay
so basically the thing is that the
resource is the concept that you are
accessing and and the entity is the
representation you are sending it to so
basically think about it like current
time is a resource for p.m. is the
entity of that you can just get from the
resource that the repress the current
time so 4 p.m. would be the entity and
the current I will still be the concept
the resource and that's why the web
target represents the target to a
resource when you want to send some data
to it we call it entity to data you are
sending the representation you are
sending it's called an T and also in a
response you have the think of it in
HTTP terms you have the payload and you
have the headers the resource will be
everything the entity will be just
everything but they are of sub resources
the server-side concept it's a nested
resource basically you have a root
resource which has a part on it and you
can directly access it however you don't
want to always handle all the stuff
inside the resource let's say you want
to you have the ID no customers resource
but every single customer metals that
handle with with the detail details of a
single customer you want to offload it
to a different class so you can just
create a sub resource locator and return
the cup customer resource entity which
would be then the sub resource you are
returning from a root resource so it's
just a Jax's concept yes
Oh
not sure hold you do that on the client
side you do not always have a container
right so so what what some framework is
an including Jersey what we are what we
are sometimes doing is that if you if
you have a resource and you adopt this
approach it you create an interface and
then you implement it and you annotate
the interface with Jack's Arizona
tations on the server side you can you
can take that interface and let the
framework create a proxy for you so this
is really good for testing and that's
why we are supporting it these are very
bad for writing your client code because
you you you are completely losing that
loose coupling ability between your
server and the response whenever your
server interface changes your client
will be broken this cannot happen with
with this lower level API and actually
we have some ideas how to how to make it
a little bit higher level so to say
maybe also what we do using some
annotations so far it turns out the
experiments that we played with are not
so easy to understand to regular
developers and it especially because if
you if you want to keep the high level
API but still don't lose this loose
coupling in Java which is a static
language is simply very difficult to do
one usually as I said usually people
have troubles understanding the concepts
that that let us let us do it well we
will try
lianna's the other problem is but but
but who's processing those annotations
on a client-side environment what
happens if if the API changes of the
message and then the other thing
obviously when you have an API you have
the full power you can do if statements
you know if this is true then I can
trigger this if this is so annotations
is going to take you so far
and but yeah I mean it's certainly I see
where you are where you're heading and I
understand we are trying we so far are
not confident with anything that we came
up with we are not confident than to put
it into the spec so what's hoped I think
somebody there had a question before
this one this one yes yes here yeah
called in what in which context is
called yeah okay yeah so this this slide
here assumes that you're familiar with
Jack sir has one in Jack's rs1 we have a
an abstract class called application so
you could register things by sub
classing that class and the method get'
classes is a method in that in that
abstract class
so in Jack's ours you had two ways of
configuring your app either by getting
this callback at the beginning when your
application is deployed I guess is will
this go or via class cannon so if you do
it this way then this method is going to
get called and that's your chance to
insert everything you want in the model
the jack service is creating yes that
that's why it looks a little bit
different from the client because we had
we didn't want to introduce a whole new
thing that we just reuse something that
existed there sitting yes deployment
yeah hold on I think he was he was
waiting he said sorry Sagan
yes yes yes website P P so basically
yeah yeah it's HTTP so it's yeah in fact
we didn't have a client before so
invoice words that you can have a
service there's no exact written in Java
and you can still use the joxer's client
to access it right
communication is via HTTP so that that's
one kind of language and agnostic we
have waddle we don't have with though we
have auto web application definition
language it's it's not a standard it's a
submission in w3c and we support it in
Jersey turns out that for instance Red
Hat is very much opposing mark littell
especially the distinguishing
engineering redhead it's quite opposing
to doing anything like that because he
says that that encourages tried coupling
you know on the other hand they support
proxy clients which is completely tight
coupling so I'd understand that and I
know that people are asking for it so we
we do that there are also some
additional frameworks such as blogger it
has its own format for doing it there is
also a there is also format which is
called JSON home which is also another
way of exposing the representation of
your application in the JSON format so
that is more convenient consumable by
JavaScript clients or browsers and so
there are things
nothing is standard so far but obviously
you can you can get support for that I
think there was a questionnaire
we you don't but we have it so the
reason is that initially when we before
we move to the final standardization
phase we had some additional parameters
you could put into the annotation and
that some and and that for some reason
again Red Hat they opposed those those
parameters they didn't they didn't want
to support it in a standard so I am
little bit hoping to sneak it back in in
the future revision that's why I kept
doing so I mentioned in passing that we
may have other uses for at suspended
that we don't have today all right so
that's that's basically because what we
are one thing we are thinking for the
future is the deployment descriptor that
can yet that will let you externalize
some of that and you know for basic for
like simple playing with applications
you don't need it but as soon as you
move to the enterprise you it's often
useful to have that information
externalized and turns out and in java
everything which which has an
externalized form already also has the
kind of annotation based approach so I
think once we good want to gather the
suspended room become making more sense
and we don't want to break the API again
once what will happen so we gotta go
well if you have any questions we can go
to the pure cure</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>