<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ten Reasons Why Java Now Rocks More Than Ever | Coder Coacher - Coaching Coders</title><meta content="Ten Reasons Why Java Now Rocks More Than Ever - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ten Reasons Why Java Now Rocks More Than Ever</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qN1UWPztJKY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm here Devin I'm the product
manager of X travel at zero turn around
I've been a job a champion for a long
time and I kind of started shava as an
open source developer i created a
framework that no one ever used but they
kind of had its rise to fame when
continuations were all the rage a long
time ago and I've been active in a lot
of open source project from the gentoo
linux distribution 2222 desktop
solutions to be no machete k wrote a few
books about that open source is what I
what I do right I've always done open
source and I believe in open source and
open source basically is my lifestyle so
so what I did for three years who have
done Java so long in three years for
three years I actually totally left a
Java landscape and I'm also a musician
and I worked on an instrument on
electronic instruments and wrote the
software for that and that software so
that's those are the three instruments
that I worked on called the eigenharp
and so that software is totally
different from the focus of Java mainly
because it had to be completely real
time no latency everything had to be
perfectly constant you cannot have any
garbage collection forces that is just
no no so there is one of those edges
cases where you have no choice you have
to kind of resort to something that is
close to the metal so I got dusted off
my c++ books and did C++ and Python for
for a few years but a strange thing
happened is that I realized there were
so many things missing that I actually
thought were there as a Java developer
having done Java for so long I got used
to many things that I took for granted
that I thought were just normal that
everyone had that because I assume that
development software engineering
naturally graduated to these particular
things in other programming languages
and other environments also but I was
very wrong so this is basically what a
talk is about it's not 10 features but
then features that we take
granted that maybe we don't realize or
acknowledge every day anymore right so
it's a nice thing pat ourselves on the
back and see wow it's so cool to be a
Java developer so first of all the Java
compiler has anyone ever compiled C++
code yeah have you ever compiled C++
code with templates mm well it's very
hard to get that to compile right so the
Java compiler very summery it compiles
to bytecode with this awesome i'm going
to talk about bat with afterwards but
this allows you to have the JIT and the
JIT does all the optimization for you so
you don't have to worry about
fine-tuning your app it can dynamically
change its performance characteristics
while your application is running this
is amazing but the thing about a Java
compiler is that in general you just
type Java Sea or use any kind of build
tool that does that but the few flags
that you have to understand is do I want
to enable debugging or knob or that both
basically it or the one-half verbs
compilation or not in that Sun that's it
that's all you have to understand and
then afterwards we get jar file and byte
codes and they can just be loaded on the
fly you don't have to link you don't
have to worry about this and finally and
that's why I asked if anyone can pile
C++ go before we get very useful error
messages now granted this with the llvm
has become better with JCC but not
everyone has adopted lvm yet and there
are quite a few platforms where it's not
recommended yet but so if you do
straight to native compilation one of
the things that struck me as so weird is
that that I had to understand exactly
what the optimizations level meant and
they're very useful because they start
at 0 0 and then the other option is 0 1
and 0 2 and 0 3 and the documentation of
the compiler tells you oh one optimizes
more than 0 0 and 0 2
optimizers more than 0 1 and 0 3
optimizes more than 0 2 and then you
have OS which is optimized the maximum
possible the problem is that it's not
really detailed what these optimization
levels do but they do change the way
your code executes in native form so
things that happen is that you might be
writing some statements that work with
01 and then you switch 202 and they stop
working and if you don't do that
consciously if you let six months months
go by it's almost impossible to figure
out what particular compilation path
causes the errors to occur because you
get you get those happens before errors
things that get optimized away or or
extracted to another location and since
that's another topic but since threading
is not really well-defined and the
memory model is not really went well
defined in in other languages becomes
very hard to reason about why are these
optimization levels not working anymore
and so I saw on the project that I was
working on that we started at Hi
optimization levels and then after two
years well we had to stuck with oh one
because no one no new anymore why 02
stopped working and we never had time to
figure it out so not very useful and
then obviously and this is kind of it's
a big drag if you have to think about it
once you compile to native you have to
distribute for each individual operating
system and this means 32-bit and 64-bit
and this means different versions of
Windows different versions of Linux how
are you going to distribute something on
Linux which package manager are you
going to work with how this is going to
integrate with the upgrade mechanism
it's it's a lot of additional headaches
that you actually don't want to deal
with right so talking about the error
messages this is one of those very
useful C++ error messages so the only
thing that I did there was I use the
wrong data type for the templates and it
gives me and this is actually a short
one because I picked one that fit on the
slides so it tells me that somewhere in
the code it cannot
use an assignment operator but it
doesn't even tell me which type it is
off and it's horrible so once you start
working with templates in C++ the thing
is that it generates code behind your
back it is not like integrated into the
language like generics it generates its
typically it really is a templating
mechanism so as soon as you introduce a
type inside a C++ template it will
behind your back generate like source
code that you don't see that has these
particular characteristics yes yeah so
the remark is that with lambda we might
get stuff like that also it's possible
though lambdas are strongly tight so I
don't think we will get these kind of
problems because it's not like doing
uncomprehensible magic behind your back
and that is all you know that is all the
benefit of Java so you are the strong
types is you you know what reason about
you know if something is not working
what the actual contract was this
created a contract that I wasn't even
aware of just because I made a mistake
in the data time that I used right other
thing about Native compilers so imagine
i talked about those compiler flags now
these are all C++ compilers so you've
got g + + which is the most common one
then the newer version that is using
llvm uses clang but then you've got the
Intel compiler which actually you want
to use because it gives you about twenty
percent twenty percent performance
increase on intel processors but it
compiles differently so it doesn't
understand the same subset of the
language it doesn't have the same
libraries even so it's very frustrating
and then you've got the Microsoft
compiler and that is a little bit like
ie they say that they support everything
but only half of it works so
it's a bit frustrating because you have
to kind of experiment with how it turns
out when you write code and the problem
is also that they each have their own
set of options and you have to read
through it because if something doesn't
compile it might be that you have to
turn off a particular flag or turn on a
particular c plus blocks language like
want language the extension or not or
that experimental feature that might
work now but maybe stop working later so
each compiler requires you to go through
that imagine that it's crazy and then
finally and this is something also that
I didn't realize is once you start
module lies in your application and made
it up in a native compilation you have
to take care of how they'll know the
DLLs are being loaded how the modular
aspects are being discovered and there
hasn't been figured out yet at all so
you have to manually this is a little
bit like binary contracts just as if you
would write an interface for your
classes and implement the classes you
have to do the same thing for dll so you
have to explicitly declare which aspects
of your classes have to be exported and
which other ones will be imported so
this kind of layers on top of your codes
an aspect that you really don't care
about which is how are these things
going to be loaded dynamically and it
requires you and this is the nice part
to change your header files depending on
if you're compiling against it as user
of the DLL or if you are the dll so did
so you start working with preprocessors
to conditionally add flags to classes
and methods and if they're exported or
not and the nice thing about that is
that it works differently on different
platforms so you have to extract that
then again to make it behave differently
if you want to have the same code base
whether you're you're working on Mac OS
or Windows and this is even for the
stupidest types
it's crazy there sometimes we spent like
days just figuring out why something
stopped composites stopped linking on
windows because we forgot to set a
particular flag that windows only needs
on a particular method and then you get
a typical same thing but I think we've
all seen that who's a gamer here who
plays video games yeah yeah yeahs who
uses steam I think guess everyone uses
team right so you see that every time
you load a game a new game it's that
installing DLLs and then it's installing
the dll from that particular version of
directx and another another version of
the microsoft visual c runtime engine
and then you've got version 101 at one
month or two and they all have to
reinstall it in the hall of the
installers for themselves because
there's no way to properly do this
version management it's horrible and we
don't have that in Java so any questions
about that remarks no okay next the core
API so this is something that I kind of
took for granted one when I was working
on Java it's that it is a very important
point is that the JDK is complete and
sufficiently completes to write entire
applications with you can if you want
just use Java SE that's it you can use
Java EE that's it if you want to you can
use additional libraries and frameworks
but it's not required it is complete and
sufficient so the benefit of that is
that people don't try to avoid using it
because something is missing everyone
uses it we all use the Java API is all
the Java API s and this also means that
any of the library developers of
framework developers rely on the core
jdk which implicitly means that they're
all compatible they all use the same
string class all right think about that
it's the same frame class throughout
Java
and something I also didn't realize was
Java is extremely liberal to distribute
your applications so once you've
compiled against it it's very easy you
don't have to worry about the licensing
aspect which is strangely not the case
in C++ applications as soon as you start
working with any well there is no real
platform api but with let's say boo boo
store with a QTE or with juice or any of
the kind of bit more established as the
case you have to start worrying about
the last thing is the licensing going to
be compatible am I gonna be able to
afford it it's it's quite a nightmare
and so in the end in Java and I think
that this is something we don't realize
the fact that we've got this API that is
so pervasive and present everywhere and
everyone uses it that allows us to be
one community we are all working with
the same huge tool set of language and
libraries that's great because if you
don't have that you all speak a
different language even though your
language itself C++ of java might be the
same your API is just import just as
important as the language itself alright
so in C++ you have something that's
called the stl but it's very small it is
not sufficient you cannot just write an
app with the sdl it's basically geared
towards utility classes and I've had
projects where I had three different
string classes and that's just for
string right it's such a basic class and
it gets you wondering about things like
encoding how are you gonna handle the
difference in coatings between those
different strain classes very strange
and so the problem then is that as soon
as you switch to another solution that
for example does include something that
you lack you have to adopt the whole
platform and you end up with three
different platforms complicates
everything's in compatibilities not nice
and then Python was which was the other
language that I've been work
with a lot yeah the documentation is
it's not a part the documentation of the
API in Java it's super good it's great
you can read a javadoc and understand
what is going on in Python it's just
impossible it's like very vaguely
defined and the only way you have to you
you're sure that it works is that you
have to try it out but it's very easy
because it's a scripting language so you
can quickly type it out but what you're
not going to do that for every statement
right so any questions about that
particular aspect or comments well we
all like to Java API yeah now Google's
API you have the guava classes and stuff
like that yeah yeah well seed so that's
I think that is a there is real effort
that has to be recognized on Oracle's
version of Java is that there is an
effort towards keeping the API and the
documentation up to date which I think
we all know was develop re love writing
or communication right so it is it is a
real effort yes compare Java and C sharp
well no have you know okay no so no I
cannot comment on it so but if anyone
has they're pretty similar yes yeah yeah
I had this impression that they're very
similar mm-hmm right right but it's
there is kind of the impression that I
had also the yeah this is being recorded
so I gotta repeat what you say so the
impression that C sharp is kind of in a
parallel paths with Java which is
actually great right because that means
there is competition and I guess that
this kind of fuels both sides it's a bit
like Android and iOS so no let's not
start that p babe
yeah really yeah oh yeah yeah they have
non checked exceptions by default write
in C sharp right well that's a whole
already baby we can do a whole session
about that but what I like what I
personally like about CC sharp is that
there is mono which is the open source
distribution it seems to be getting
quite a lot of traction and being used
by by by quite a lot of projects oh yeah
so open source we're off we've all
adopted the open source in Java it is it
is part of our DNA which is really
strange if you think about it because it
has java has always had this connotation
of being an enterprise toolset but open
source is everywhere it's the leading
number of open source projects number
it's in Java the whole reason that the
apache foundation now continues to be so
popular is of job is because of java
even though it started with a sea
application which is the apache server
right most problem projects in the
Apache dog or Java projects it's kind of
weird but great at the same time the
terms of use in Java before deploying to
server okay I've never read them
so to deploy an existing application to
a server is that what you mean how to
install ja okay add the fact that you
have to click through a licensing
agreement before you can install the JDK
and things like that yeah I can see that
it's it's quite annoying but you have
the OpenJDK which doesn't require you to
do that right then openjdk is there's no
reason not to use it actually it I think
that this is kind of a legacy mindset to
use the commercial version of Java but
from what I've heard it's no real reason
anymore to not use OpenJDK I don't know
sound support some papaya is this still
there yeah okay so sound is not there
yet but I think most of the rest is in
there so actually on all my machines
I've got OpenJDK Ford for server-side
applications and I've never had a
problem with it so so the terms of use
in that case are not the problem i think
so well at one point maybe you I know
yeah maybe try try it out now and see
they OpenJDK works for you but I think
there has been a huge effort on Oracle's
we have to to gradually implement open
source versions of all the components
that were proprietary before and from it
took a long time but they did it yeah
okay but they did so which which is I
think very recommendable so and then the
open source nature of Java allows us to
be to collaborate on different projects
and to have this massive collection of
working code examples that actually work
yes sir yeah
well well you can if you go back to the
fact that you don't have a common
platform so if you don't have one
platform where all your code examples
will work on it means that you will have
to figure out which code what the code
example was worked for I was written for
and if it's going to apply to what
you're working on at that particular
moment and you will find out that it
most of the times it doesn't so it
creates these what we'll get into that
so it creates these silos of people that
work with fraction fraction of
frameworks and libraries and they
they're not really compatible because it
gets very difficult when you've got the
threading to take into account and got
the difference low level data types take
into account and I don't see the same
community and aspect of working together
on open source in these well in C++ when
I was working with C++ button is a bit
different because Python they have their
kind of more or less complete SDK and
the super blaster wasn't the case and
this is kind of I just put that in there
because it kind of boggled my mind
you're probably not interested in but
I'm gonna say it anyway so since I was
working on music software one of the
things that struck me as very strange is
how in other areas so like to the music
landscape how closed-minded people are
I've had that people react to me about
one particular algorithm that they
didn't want to share because this is my
algorithm okay well don't share your
algorithm I said this it's it was really
weird to me and yeah because i've had
this algorithm about how you handle
breath control since 1980 and it works
well and i want anyone to copy it okay
well breath control is just one little
thing of your instrument you want to
have the whole thing and that i missed
that of the java community so maybe it
might be just as strong and i think this
might be just just a strong in
like linux distributions or desktop
distributions only looks like gnome and
KDE and to go back to what I said in
beginning of this dog this is not
intended to be hey Java is better than
that thing that's not the point of this
talk it's just saying we have that right
so it's very nice to be aware of the
fact that we've got this open source
collaboration and we can rely on it and
often you just go on the internet and
find an example and you can apply it it
works you can go on Stack Overflow ask a
question and someone will give you an
answer that you can use you don't have
to write three paragraphs to say exactly
when does this particular example apply
and then which version are you using
that was something that I really had to
deal with a lot of the times so number 4
i'm just going to check how we are on
time yeah 25 minutes in so as I said
this sometimes takes two hours depends
on how many interactions there are the
Java memory model who is aware of the
Java memory model who knows what it is
see that not many people but that's what
everyone takes for granted right
everyone takes for granted that you can
reason about shared state in a
predictable fashion a shared state I
mean state that is shared between
different threads so one of the things
that Java did early on is they created a
spec that defines exactly what happens
before each operation when it is shared
across threads so you can reason with
predictability what happens when a lock
is in place state changes and the lock
is released or if you worked with
Atomics how Atomics works but it's
predictable it is stable and it works
always the same in every situation and
java has been the first platform that
did that which is a very nice advantage
is that they figured out huge problems
with it a long time ago and other gone
because i think it was in jdk one that
one something that they had to run this
for tomm remember so many version
numbers
that they had to work on a critical Java
memory model issue but it's fixed and
since then they haven't been any others
it's taken C++ tootin until 2011 to
start standardizing about such shared
state specification which means that
almost none of the compilers actually
adopted none of the compilers understand
it and it's buggy because they don't had
have had this is years-long of maturity
maturity no this is horrible if you
cannot for certain reason about how your
state is being shared across threats
imagine that spreading is as is already
a super-hard ever anything that's
concurrency related takes a lot of
effort to get right and you will anyway
right bugs it will be very difficult to
get to be correct but if you then cannot
rely on something that is predictable it
becomes a nightmare and then pythons way
of solving that is called the global
interpreter lock and that is yeah you
can use threats but we still have one
lock everywhere this is one lock for the
whole interpreter and it will baby your
basic bottleneck and then one of the
responses that I often got as well you
can just isolate through through
processes what how do you share state in
that case they bribed it to disk create
lock files in the disk anyway so you end
up implementing a lot of the primary
constructs of multi-threading because
they're not stable so we had to deal
with that a lot because if you've got
real time data streaming through that
cannot have any latency attached to it
you have to make sure that memory
allocation will not pose it so you've
got a real problem with how you handle
that memory allocation that's where we
got a lot of those threading issues
popping up any questions about that No
ok cool who's writing multi-threaded
code yeah you understand it
yeah so there's my point so high
performance vm well i think that that
kind of speaks for itself right so we've
got a vm that is super mature and that
is very fast you can tune it on the fly
when it's running you can even you so
you can tune it started can tune it when
it's running garbage collection is
constantly being innovated when I think
this is something that I love about the
vm is that you can monitor the way it's
running while your application is
running you don't have to switch in and
out of different modes at compiling
profiling solutions or memory analysis
solutions we just have that this is
amazing so and the same the same vm
applies to a wide range of devices which
means that we again we have this one
tool set that we can apply everywhere
and we've got jmx which is cool to
manage it but other languages like I
said before if you want to actually have
something that's performance you have to
write it yourself you kind of trickle
down to the lowest layer possible and
build it up and you get no profiling no
monitoring no visibility and that is
something I didn't realize at the time
but if you actually have to do your own
memory management because we're all
about okay cool we've got automatic
memory memory management not only is the
memory manager in Java handy because it
does it for you it also gets out of your
coat while in all in C++ I had to
constantly adapt my code just to do
something as simple as memory management
the actual way of working with the
memory dictated the way that my code had
to be structured it was this other layer
that was interwoven with the business
layer because know if I Rai I which is
what the objective c does is resource
allocation is instantiation it means
that you have to always instantiate if
you want to allocate a resource it dick
it's the pattern of how you're going to
be programming smart pointers is the
same it means that you have to rely on
pointers if you don't use pointers
you're gonna you're going to get memory
leaks reference counting is the same
thing you have to be very careful to not
have circular loops if you get loops
then you're kind of screwed over the
ownership transfer is okay
some-something has the ownership of the
memory if you are not very careful in
the way you structure API to transfer
the ownership of the memory to another
location then you're screwed again so it
really dictates the way you structure
your code which is very pervasive and
the thing that we had to do is again
very specific to our application is we
had to transfer memory between C++ and
Python without a stable memory model
that was kind of a drag so let me just
check which section I am because okay so
the fact that we have a vm that
abstracts everything for us allows us to
stop thinking about everything at the vm
level as long as it works on the vm it's
fine it's cool no because I concede you
ok cool so what we had to do was to
actually it's not only about compiling
for a specific architecture but you have
to test for every architecture you have
to change your build process for every
architecture now look at how horrible
maven is now is imagine that you'd have
to do that for every platform that you
have to distribute for you have to build
up your whole different build process
because you have to integrate a
different compiler a different runtime
environment the build tools are
different the packaging and installation
already said that are different and even
the development tools are different so
everything is different for each
different platform even though you use
the same language all the rest is
different it's not just about up having
to compile natively to the hardware
that's actually the easiest part it's
the whole other thing around them that
the JDM also allows us to abstract from
as
right if you open up a project for
example in Xcode and you open the same
project even though it's valid c++
you're going to open in a visual c++
you're going to spend at least half an
hour trying to get it to compile because
you have to structure it the way that
C++ wants it you can have to set up all
the compiler options you have to do that
manually all right so each tool for each
platform makes it more difficult do you
want to say something about that now or
you want to wait until point 10 okay oh
I'm scared now Ethan he looks like a
smart guy who stood there hmm so
bytecode already touched on that before
who has done bad foot manipulation why
not yeah yeah it's nice huh you feel
like a wizard yes it's awesome well it's
not that it's not that difficult is it
you think it's difficult oh don't don't
use anything else in Java then so you've
got hell this is our typical hello
worlds and this is the bytecode I think
this is also you can read it it's not
assembly you can just this is this is
your bodies are your bad code
instructions they're very similar to the
actual statement that executes they're
structured in the same way and the last
thing is the Java ships with Java be
that allows you to see the bytecode of
everything that you ride so if you're
interested you can easily get acquainted
with the bytecode of code that you're
writing and that is how most people work
with byte code is basically you write a
little piece of byte code in Java you
compile it and then you look at what the
bytecode looks like so don't think this
is understandable right loot a wound I'm
just curious no judgment here who thinks
you this is not understandable right
it's it's got the same structure you've
got the classes in place you've got the
methods in place it just adds an
additional few operations between the
things that are going on but apart from
that
it's quite it's not as human readable
but it's understandable right it has a
direct relationship with the code that
you wrote okay and I like watching it
because it makes me understand about how
things are happening in Java it gives
you an idea about okay well this is
actually a constant because the compiler
is smart enough to know that the string
is going to be a constant and it's going
to load it from a constant register and
it's interesting to know about it also
makes you realize why some things become
large or small in their compiled form so
the one thing about byte code is and I
think we all know that it allowed us to
bring Java past the Java language right
we have the vm that understands byte
code and then thanks to the Treasury of
the community we have this invoke
virtual byte code that has been added
that allow scripting languages to be
more performance but apart from that it
allows us to explore new territories
it's a little bit like Star Trek you
know golden and go to planets that
you've never visited before let's
experiment it's awesome so one of the
things this is just a summary of things
that has done but who's still for
example doing aspect-oriented
programming you're still doing it okay
you like it so are you going are you
going not just curious are you going off
of it or continuing with it or
continuing with it okay well i still
remember when I before those three years
aspect-oriented programming was the
whole rager at a particular point in
time it was a lot of the talks were
about that and we were able to explore
that Avenue of that programming model on
the vm thanks to bytecode manipulation
the fact that something could be
interwoven with the Java language and
our final classes that was possible as
an independent effort someone could
undertake that and get this whole
mindset going and explore it and if it
works for you all the better but it it
kind of it's a nice
experiment and there are a whole bunch
of things like that like the fact that
we've got all these scripting languages
the fact that we've got I think everyone
uses some kind of aura I'm mapping tool
the fact that those exist on the fact
that you've got dependency injection
frameworks that the fact that our
products exist at zero turn around
without bytecode manipulation they would
just not be possible and a lot of things
that you actually take for granted rely
on bytecode manipulation so you should
try to do backward manipulation go home
and try it out it's actually a lot of
fun just you've got a bunch of options
to integrate it with your code I'm just
listening they're here so if you come up
with a language just write a little
compiler for it could be just a few
statements just see what happens and you
realize if you use a tool like I prefer
SMI like a sm as a as a library for byte
code generation manipulation because
they got this nice integration with the
IDE that you can see alongside your code
you can see the byte code that
corresponds to it and then you can just
copy paste so you just do the whole copy
pasting and well these are just a number
of ways that you can transform your just
plug it into existing architecture if
you don't know about them you can have a
static transformer that pre processes
existing classes you can write a JV a
java agent that instruments right when
the JVM will load your classes or write
your custom class orders but I would not
do that because it's just a whole world
of hell but if you want you can try it
showing that what sorry the Java box is
made made what possible
so Java proxies are part are another
part of the solution that made that
possible it's got it there a bunch of
technologies that are being used by orn
tools but or I'm tools instrument your
classes for example lazy loading the
fact that it's gonna load load load
state when it's needed that is done
often through bad code manipulation
proxies are another way of implementing
other I've never implemented ORM side
they cannot really tell you where they
are used I know they're used but also
use backup interpolation they use both
okay it does that answer your question
or yeah no it's not all done to proxies
now we have to deal with the back of
manipulation in our products all the
time don't through RM so yeah I don't
know until which degree this is done you
might ask some people it's a good yeah
it's a good point 17 intelligent I IDs
and I think intelligent is there the key
word here so we have ideas that
understand whole project on the abstract
syntax tree level so one of the things
that I always took for granted is that I
could refactor without actually having
to worry about what's going on the only
way that I could well there are a few
refactorings in some c++ ideas but
they're quite basic and they don't
understand many things and you basically
it's like a glorified search tree place
and that doesn't give you a lot of
confidence if it's just replacing text
strings one of the things I personally
like a lot is on the fly error
highlighting you just stay in the focus
rot errors and then continue until it
compiles you don't it's like fixing
little bits and pieces here and there
until you get a nice finished work of
art and then the IDE is also likely to
locally debug your code or remotely
debug your code and support because the
language is not just a language but as I
just
we discussed before you've got the
frameworks and the libraries and
integrations with the different
platforms most ids understand these able
to understand that you're using a spring
application order you're working with
servlets or they will they will allow
you to work with that in a meaningful
fashion and give you inspectors or
editors or property editors that allow
you to actually work with those
higher-level concepts which i think is
awesome so I'm not making any
comparisons here I'm just saying
intelligence IDEs are awesome let's just
have a quick poll who who uses NetBeans
i'm curious because it's 12 yeah good
ten years ago it was no one so that's
quite good eclipse yeah intellij yeah
i'm not making any value judgments but
it is quite interesting though I don't
know if you followed how how the whole
idea thing happened over the years but
it used to be kind of an expensive thing
you had to buy an IDE know who buys who
has bought an ID it's about it's strange
it's about the same number as NetBeans
users but are different
so even though we got this it's it's a
huge technology intelligent at e's but
they've become a commodity we all rely
on them as something that we take for
granted and that we just use it's part
of what's normal right 10 years ago this
costs a lot of money and still in other
platforms we have nothing like it
nothing at all it's it's quite amazing
actually and that brings me to number 8
profiling tools so who's using profiling
tools right nice your kit awesome isn't
it no value judgment J profiler yep what
is the other one help me there was
someone else who raised his hand no
visual vm yeah official vm ships with
the JDK how amazing is that you've got
profiling tools shipping with your
standard distribution right so it allows
you to inspect everything everything
about a running vm you can do heap
thumbs in the real time you can even use
it on production applications you can
get real-time data collection about
method calls from production
applications and get meaningful data
from them I think this is awesome we had
that one of the products that we kind of
canned it's your turn around because we
found that the market wasn't ready for
it but live rebel we had to fine tune it
to to kind of find performance
bottlenecks but to be able to push in
real time in production to 2,000 3,000
servers but that's a profiler to it and
get meaningful data even though it's a
humongous amount of data but being able
to reason about it and to just do that
with tools that are available like that
it's kind of kind of mind-boggling that
that is there so yeah so these tools
allow you to very easily
do root cause analysis and if you've not
done that as a developer it's quite
interesting to do so so I always like to
kind of crack my head once in a while on
a performance problem because it kind of
helps you to code better because you
know what you should avoid or how you
should do things differently any
questions or remarks about that No okay
you're still waiting right is anyone
else waiting I might just have to rename
this talk soon after you are in marks
like elf 11 reasons why Java works more
than ever backwards compatibility so
when I came back to Java I could just
use applications that were actually had
a server that was running for years and
I just upgraded it to jdk wonder date no
problems at all I had to change nothing
there's one little thing yet they
changed the way that the bytecode
verification works there was a flag that
you had to know about but everything
still works so what does that give you
it gives you the thing that cpus had for
so long just way two years in your
application will work better right now
the CPU this is not the case anymore but
with the JVM it is the case your
application will gradually perform
better over time because it continues to
work with the same JPM and it's not only
a bad code level even the source still
compiles and I've had that code from a
very long time ago and that also allows
you as a imagine that we've got code
from 18 years ago that still works and
still runs and we can rely on it and
integrate it into our projects not yet
so I can still make the slide
yeah I next year next year I'll drop
this one so another thing that this
gives you is it gives you forward
compatibility it means that you can
switch to another set of hardware you
can switch to the future you don't have
to tie yourself to one particular
runtime solution you build your apps in
Java if within 10 years a new processor
comes along that's fine the JVM will be
implemented on top of that you just take
your application and we'll work on it
you will not have to use new tool change
you will not have to figure out how to
build it what the compiler flags are you
will not have to learn all of that and
so these are just examples of things
that were done that I remember that the
garbage collection has been under
constant improvement we got management
and monitoring real-time profiling the
adaptive optimization of hot spot the
escape analysis lock worsening class
data sharing and so on and so on and so
on all these things were added in the vm
alongside of what the language does but
it makes your applications run much
better let's see if we can get to and
yeah I just said that so it also gives
you sideways compatibility you can just
jump to another architecture if you
think that that is appropriate or spread
out all right well it's not just
platform abstraction which is what most
people think of with the vm the vm
abstracts away from the underlying
platform that's just a minor benefit the
benefit is that your you've got all this
investment that you can continuously for
the lifecycle of your application of
your company of your project you can
continue to rely on it and use it and
work on it together with other people so
there is also part of why our community
so so large I think ah that's probably
not it right so number 10 maturity with
innovation and that is just I think that
a lot of a lot of times other language
users
kind of ditch that Java is mature and
strife actively to try to keep things
stable but still gradually step by step
try to innovate without any major
breaking changes so this is this this
allows us to do all the rest that I just
talked about if it if it would just kind
of every two year really something that
is totally incompatible but it's a huge
innovation it's wonderful and great it's
not very useful but the fact that for 18
years the Java platform has evolved in
this way gradually maturing more and
more while each time very carefully
adding new things that might be useful
gives us this huge baggage that we can
actually rely upon and then yeah just
Java 8 i think is kind of the proof of
that the way lambdas were introduced the
words the fact that they realized that
they waited long enough to realize that
we needed the fourth methods for lambdas
to work well because london's by
themselves are great but kind of if you
just have them you would have to write a
whole new collection api you would have
to ride everything from scratch again
but default methods were the realization
that was needed to make we have the
maturity of java applied to this new
innovation and we've got all these
others here and so that is kind of my
summary of this whole thing so i think
java is the most 12 Benes balanced
compromise between riding productivity
reading intuitive news execution
performance product made in project
maintainability technology evolution
application stability and runtime
visibility and that's summary did I get
it yeah
well now it's a summary right and if you
want to read more about this I wrote
about well 10 articles because there are
10 reasons about this at this URL come
visit me at our booth at zero turn
around if you want to talk about this
with you I guess you still have a
question or remark on observation mm-hmm
the Java compiler okay so we're talking
about the distribution right ok let's
true if you want to have an integration
with a native package manager for your
java application you will have to deal
with that i agree this yeah good point
yeah but then you had a bug yes so I
didn't say that you will be able to
guess what code will be doing thanks to
the Java memory manager they didn't say
that i said once it will behave in a
certain way it will always behave in a
yes because the behavior there is
unpredictable that is the thing that
will happen all the time it is
unpredictable there is a bug there you
as a developer for God which is kind of
the contact for the memory manager to
take a lock or to use a shared resource
that you can coordinate across if you
introduce such a bug and it's about but
if you follow the contract which is you
need to acquire a particular resource to
have the happens before contract supply
and they reasons our list is what are
the what are the conditions for them to
apply then it will always behave in that
way we got preconditions
he said Wow first one why yeah because
in 32 it was because whatever was in
64-bit is it behaves yes I can see that
happening mm-hmm yes or take a look it's
like this it's this this fallacy of most
developers they try to do premature
performance optimization if you've got
shared state you take a look it's it's
very simple now you have to choose which
lock to take and in Java 8 we've got a
whole bunch of locks that might apply to
you if you think you're smart enough to
not use a lock you'd better be damn
smart all right this and in most of the
cases you'll probably be wrong but how
long has it taken people to realize that
the double-checked locking fallacy was
actually not working until the Java
memory bug was fixed and then you could
use volatiles with a double if statement
and have it work but it's these kind of
don't try to be smarter than people that
have been doing that for 30 years right
it's if there is a reason why you have
to take a look when there's shared state
you might think that you'll get some
improvements from not doing it but most
of the times well 99 for nineteen
ninety-nine ninety-nine percent of the
times you will be kind of screwed so yes
sir
increasingly finding myself evangelizing
job that's what sorry like for example I
get into conversations job is good yeah
yes some of them I'm constantly heavy
defend you how do you how do you defend
against that you don't know it is a plus
you let ask how many times do you write
your code how many times you read it do
you like to have something that's easier
to read or easier to write sure but the
dead got actually grills is a perfect
example or we'll all groovy you mean
right Java is about the platform the
language is just one part of it right so
but my I stand with you I personally it
has never bothered me even to use
anonymous inner classes to simulate
lambdas it has never bothered me because
I give this to some other developer and
he will understand it yes exactly
and how many I'm just because this is
something that I've had happened
recently well I've had a bitten for for
so many years now recently again did you
see your own code and like what what was
I doing there I don't understand it so I
think that even for yourself it's better
to have focus on readability and that's
why the bingo thing said
visibility and readability because I
think this is key it's key to having a
viable long-term software development
going on so yes some other I don't know
where we offer time but well we still
have three minutes yes sir I'm sorry I
didn't really understand the question
that's so the question the question our
new features and new language constructs
preventing from people to understand the
inner workings is that your question I
think that this it's probably a gradual
process if you don't want to know the
inner workings that's kind of a power of
Java is that you can just stay very high
level and if you want to start doing
bytecode manipulation then you'll you'll
learn about it and you'll stay up to
date in the same principles apply mhm
okay so your your patterns your you well
that's why Java 8 is probably the
biggest change for java since its
inception your your whole workflow of
constructing your business logic and how
you're going to create your code is
totally being changed by lambdas it's
it's a total the only different mindset
but you don't have to use it but it's
yes it's it's innovation with maturity
right that's that last point you can use
it we don't have to use it but if you
use it you will obviously have to adopt
those music on you construe tonight I
think you're right in that they're
fundamentally different they are totally
different mindset but at least you can
still use all the other stuff so yeah I
think we're done thanks a lot for coming
I don't know if because this is the
first time at a session this year is are
there any elephant valuation somewhere
that you have to fill in or not there's
a survey please fill it in it helps me
it helps the content committee it helps
everyone to organize a conference and
the speakers to know what we did right
or not so it's it's really helpful
please please fill it in thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>