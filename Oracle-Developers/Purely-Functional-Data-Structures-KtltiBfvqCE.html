<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Purely Functional Data Structures | Coder Coacher - Coaching Coders</title><meta content="Purely Functional Data Structures - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Purely Functional Data Structures</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KtltiBfvqCE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Dan Rosen I'm a software
engineer at Twitter joined Twitter
pretty recently I was been there about
five months now
before that I was teaching whoa we got
loud is that good yeah all right uh-huh
I was teaching for a while before that I
was teaching training classes at a small
San Francisco company called Maracana
which then got acquired by Twitter
anyway so I've been teaching classes on
software engineering best practices
mostly on JVM so Java Scala you probably
know at Twitter we do a lot of work with
Scala so I'm pretty pretty into the
functional program and kind of stuff but
this is not a talk about functional
programming despite the title purely
functional data structures it's sort of
the point of this talk is a purely
functional data structure is not just
for purely functional programmers or
require a purely functional programming
mindset per se so we're gonna talk about
different kinds of data structures that
you might want to use on just you know
very very very frequent day-to-day basis
so first thing we're gonna talk about is
mutability right purely functional you
probably heard a thing or two about this
is sort of the difference between
mutable and immutable data structures
right so common problems with mutable
data so we're gonna just gonna start you
know I'd like to start simple start with
a you know kind of a boring example a
rectangle it's exciting so a rectangle
has a width and a height with knight or
private but not final so it's it's
mutable you've got a getters and setters
right so this is pretty standard beam
right kind of job of being probably have
like a you know probably have like a no
args constructor as well maybe you know
so that you can satisfy hibernate and
things like that but then you know sort
of this is your your run-of-the-mill
data structure that stores pair points
I've got an identity hash code equals
and compared to as well nothing too
fancy now
the problem we're gonna run into a lot
of problems with this really quickly
right
a lot of this probably be pretty
familiar to many
you it first probably run into when you
have a data structure that is mutable
like this rectangle is that its identity
is not stable what do I mean by identity
well I don't know what would you mean by
identity the type of ways that you
identify an object in Java usually
something to do with like its reference
identity maybe or its hash code or you
know comparing it against some other
objects maybe it's compared to right so
hash code equals compare to those all
sort of comprise some notion of the
objects identity and when you have a
data structure that is mutable such as
this rectangle well you know you put it
into a set that relies on its identity
say a hash set or even a tree set you
get kind of the same properties you you
know so you add it to the set you mutate
one of the fields of this rectangle and
voila disappears right hands up who's
seen this sort of thing in you know this
is this is a pretty common bug right the
manifests in in your code so it's you
know it's not a good thing you know the
real fun part is that you know a set has
this invariant that you know set is
supposed to have only one of a certain
you know it's supposed to be unique
right well okay so if I put you know
another another element you know if I
put another copy of the same element
then well now I've got two of them
because one of them is either in the
wrong hash bucket if it's a hash set or
you know in the wrong node in the tree
so this is this is all bad right if I
sound down you would have heard a nice
like and it'd be cool okay um so that's
one problem problem number two that you
know and this is sort of a classic kind
of a like a textbook problem this this
this comes up sometimes a little bit
more subtle is an issue with with
substitutability when you're dealing
with subclasses we're rolling Barbara
Liskov who's a professor at MIT so you
know let's say you have a subclass of
rectangle called square right all right
again now if you're exciting square
extends rectangle of you squares the
kind of a rectangle it's a special kind
of a rectangle all right fine so you
immediately run into a problem because
you know you can you can adjust the
within the height of a square and so the
square is no longer square so you know
you've got a problem we can try to solve
this problem by saying well you know
well let's just have another set length
method and we're gonna override set
width and set height right okay hands up
who's seen it this is a very classic
like you know object-oriented design
thing yeah all right cool
Thanks I feel validated and this is
important for me okay so you know so you
can override these things and you're
happy because square maintains this
invariant that a square is always square
all right cool but you know you have
this other invariant that might have
been hidden which is that you know let's
say that you know I if I were to say
that for all rectangles if I were to set
the width of the rectangle
I expect that the rectangles height
shouldn't just mysteriously change right
let's say I have that expectation about
rectangles in general because you know
let let's say suppose that I had some
other subclass of rectangle like you
know a colored rectangle so you know if
I set the width of a pink rectangle I
shouldn't you know expect that that
rectangles height would change or you
know is this smelly rectangle or
something like that you know the the
smell shouldn't change either right but
you know the square violates this in
there in right the square has this has
this separate property where if I change
the width well the height does change so
so either my expectation about this
invariant is wrong or my implementation
is wrong but there's some cognitive
dissonance either way right so this is
another another problem with mutable
data you you wouldn't have this problem
if you just couldn't change the width or
the height right you would set it once
you'd be done right okay so that's
that's that's another issue so no yeah
right that's another issue oh yeah now
the real fun part and this is this is
sort of like my biggest beef I think
with with mutable data this is the thing
that I think bites you the most as you
know sort of a working engineer who's
trying to like make your code go fast is
you have this issue where like you know
it's so I've got a rectangle pair right
because I'm managing lots of rectangles
my application this is what Twitter does
actually we just traffic and rectangles
so let's say I've got this rectangle
manager that's managing you know this
large amounts of rectangles and the
rectangle manager should be solely
responsible for its content right you
know it has this set of rectangles and
nobody should mess with that set except
for the rectangle manager and you know
except for going through rectangle
managers specific interface right but
what's the what's the problem with this
any anybody what's what's the yep going
yeah yeah exactly the actual get you
know so we have it's a final set right
its final well the final isn't constable
right this isn't C C++ right so it's not
the fact that the reference to this set
is final doesn't really do it do us any
good with respect to the sets content so
it you know it's kind of a problem so so
what do we typically do well alright
well we just have to either make an
unmodifiable view of that set right this
is when I was teaching Java classes I
was very surprised to find out that not
all that many people were aware of this
you know it's like in my advanced Java
classes but not that many people were
aware of collections not unmodifiable
set right what does this do by the way
unmodifiable set what does it do when
you try to let's say add an element or
remove an element or whatever so yeah
throws an exception right okay well so
that's better than nothing
throws an exception oh yeah you know so
presumably if you try to do this
immediately when your program starts up
you know you'll you'll find it before it
ever gets out to production but you know
it's still not great you want your
compiler to to deal with this well okay
fine so so you only live once the the
way that we typically deal with this in
Java is is we say you know forget it I'm
just gonna make a copy I'm gonna copy
the whole thing you can do whatever you
want with the copy no problem right do
you do whatever you want with the copy
of this set well but you know in the
meantime anybody at anytime anybody
wants a copy of this set well you know
we have to you know basically stop the
world
we're synchronizing access to this thing
so that we can make a safe copy of it
because sets are not necessarily thread
safe and we make a copy and now you know
so how much memory are you using well
we're using twice as much as we were
before
you know one for the copy and one for
the original alright so this is really
dissatisfying yeah that's that's like I
said that's kind of my biggest beef with
with the typical approaches to just
general data management right and like I
said this is not this is not a talk
about pure functional programming this
is these are problems that you deal with
all the time right this is not like this
is not haskell you know neckbeard
ivory-tower stuff this is this is
realistic problems here so you know just
to kind of summarize what we've got so
far
unstable identity as an issue or it--
you can't you know you can't treat these
things as values like you know the value
one well that the value one has the
identity what's the number one one
doesn't suddenly become two right one
you know integers have a stable value
identity strings they're immutable right
they have a stable identity you can
always use those safely as keys and ass
in a in a map right so we want our
things to have stable identities that's
that's a big deal this this stuff about
Liskov we're not going to focus too much
on that in this talk but it is difficult
when you have mutation as one of your
behaviors in a data structure it is
difficult to make sure that you know
your subclasses are going to mutate
exactly the same way that that the
superclass does and then the biggest
problem that you know like I said I'm
worried about is this issue of just
having to make defensive copies all over
the place and the memory and
efficiencies CPU and efficiencies and
second ization issues that come with it
right so this these are the key problems
that I'd like to get at when talking
about immutable data all right
immediately
so let's you know look who's trying to
feel a little bit better here we're
gonna make this a an immutable rectangle
right it's the immutable rectangle this
is like I said this is what Twitter does
we make immutable rectangles so private
final int width night
all right cool great it's immutable
success we've got to get width and get
high-end we don't have any setters cuz
you can't hash code equals in compared
to our now stable we're happy right I
haven't filled in the implementations
but presumably you can like have
IntelliJ do that for us
that's cool and then you know the
I kind of started this is it feels good
except for we're changing our sort of
programming idiom just a little bit
which is to say that that our setters
like we still want setters right we
still want to be able to mutate in
principle we want to be able to make
make adjustments to our data once it's
been created
well our setters actually don't return
void now they return copies of our new
rectangles all right you might might
wonder what does it seem it's bad right
now you know you've got the copying
problem it's just you've just pushed it
down a level right well all right let's
not worry about that for a moment this
there is kind of a trade-off here
because if you're working with some
framework like you know I would say
hibernate or you know some of those some
other thing that does introspection it
expects your beans to look like beans
that this this messes with that a little
bit right but it's you know we get what
we pay for so all right so this is this
is what we're gonna do any time we need
to make any time we need to make
modifications to our data or just make a
copy of the data it's fine right
everything's final we'll copy when we
need to and we're just going to assume
that the engineers at Oracle who work on
hotspot work on the GC know what they're
doing seems like a reasonable assumption
and and what I'm gonna try to talk about
is you know whether or not that's a
valid assumption okay
now all right so we talked about
rectangles this is not actually what
Twitter does for a living let's talk
about some more interesting data
structures and and again you know I'm
kind of starting simple I'm starting
with stuff that you that you many of you
probably seen it's you know it's um it's
some level we're gonna do a stack we're
gonna try to implement a stack which is
much more general purposely useful data
structure than a rectangle is one would
assume so our stack interface is going
to consist of push pop and top easy is
empty is kind of a nice helper and the
way that we will create new stacks
alright we're not going to make like a
stack constructor this is gonna be sort
of like a pseudo constructor of Factory
to give us an empty stack because all
empty stacks are the same so you know
just start out with an empty stack and
push whatever we want I'm okay so that's
gonna be our interface and what I want
to do
just as a quick exercise is is it's just
kind of visualize what this gonna look
like again you know many of you is
probably seen this is gonna be something
that we call a cons list you may have
seen this if you've looked at closure or
any sort of list or really any of any
functional language is a very pretty
common not a new date estrada not I'm
not inventing anything new here so we
start out with and this is just kind of
a notational slide here anytime you see
like a green box this is a reference
that's on the stack and anytime you see
like a circle or something that's that's
like an actual object that lives on the
heap okay so we started out we allocate
you know we call stacked on empty that
gives us something on the heap and we're
pointing our local empty variable to
that thing now let's say we want to push
on to the stack
all right well the way that it's gonna
work is we have a new cell a new a new
element that contains you know let's say
we're pushing integers let's say it
contains number one and it also contains
a reference to whatever was we had
before well you know what we had before
was just the empty and do you stack
right okay fine
so one points two empty or nil right
okay so far so good so we want to push
some more things push two and three so
this is now assigned to B that's kind of
interesting because we still have this
reference age sitting around right a
hasn't changed a is still a reference to
a stack whose head has the element one
and a pointer to two empty right B is
now another reference it points to you
know three at the head then two and that
two also points to it just happens to
point at what a point set right so we've
got some sharing going on it's kinda
nice so okay we'll talk about what this
means in a second you know we can keep
playing with this let's say for example
that we wanted to pop from B and then
push something else on instead well that
doesn't destroy be right B was immutable
what we've done is you know kind of in
this picture we've we've just made kind
of a small copy sharing as much as we
possibly can
and so si has a different head but the
tail is that was cool
the tail is whatever we had before right
everything is good so far
happy yeah right we can keep on with
this right you know we still have a
reference to our a so we can push
something onto that we're still sharing
as much substructure as we possibly can
between all of these that's kind of nice
and then the really nice property is
that when we no longer care about what
being used to be or what D used to be
right now let's say you know I could
assign these to nil or I could know
whether or I could pop them or whatever
I wanted to do well I can garbage
collect just those elements individually
which I no longer have references to and
everything else still just remains the
same
right so this you know what's the the
space efficiency of all of this like
anytime you need to push an element onto
the stack well do you know that the
additional cost is just oh of one right
the additional the cost of adding that
additional element we don't have to make
an O of n copy like we would have if
this had been some kind of opaque opaque
data structure from you know the
standard collections library right
this is my troll water I have to get my
composure here okay so the
implementation of this pretty simple
again you know many of you have probably
seen this already a stack is just
something that has a head and a tail the
head is the element that you're looking
at any get in a given point and the tail
is some other stack read it some you
know the remainder so you know we have
some private constructor that just
initializes these to know this is our
empty stack and then any time I wait any
time we want to create a new stack based
on an old one well we just you know have
a new head and the tail is whatever we
used to have it's very easy and the nice
thing about this implementation is that
push pop top and is empty are all
extraordinarily trivial right anytime we
want to push just make a new stack
anytime we want to pop well popping is
not the popping doesn't even create
anything right popping you know you
might even garbage collect something
when you pop it is it doesn't have to
create anything you just have a
reference to the tail so that's that's
what you get right and then you the only
additional like kind of little nice hack
here that you might have seen in some
other collections is the use of a sort
of a dummy empty this is kind of like a
nice little untyped hack where you know
anytime you want an empty stack well it
doesn't have anything in it so you don't
really care about what the type of
nothing is so just make it I could have
no and cast it to whatever you want
later okay
so this is a really basic example again
this is like you know a cons list from
from lisp or you know a list in any any
functional language right this is an
example of data structures that we call
persistent or purely functional so the
idea with purely functional data
structures is that they share is much
common substructure between updates as
possible so that's that's what we saw
here right they share all the common
structure a sub structure that they
possibly can which is somewhat similar
to to copy-on-write but it's kind of
easier to manage right because you don't
have to keep track of when something is
actually being written because nothing
ever is being written the same kind of
idea but simpler the nice the nice thing
also is you know given what we talked
about before stable identity
right so if we wanted to we could throw
these things in a hash map right there
hash codes won't won't change because
the the object can't change I like I try
to I try to get laughs in anyway so you
find that that's not necessarily I mean
it stacks are definitely more more
general general-purpose than rectangles
are but you know you stacks are also
still like fairly special-purpose in a
sense it like you know maybe you would
use a stack only if you're doing like
some I don't know if you're implementing
a compiler or something like that or oh
yeah I don't know yeah you might
implement oh yeah you could use a stack
if you're implementing a calculator
right yeah everybody's done that okay
Q's Q is a much more general much more
much more relevant for us in this day
and age of asynchronous processing where
you have to pass messages in between
processes and you know so you need to
keep your messages right that's this
this is kind of like our our main
abstraction for for concurrency these
days queues okay so let's say
hypothetically that we had a nice
immutable queue to work with and you
know would kind of see where the see
where that gets us well how do how do we
build this thing this is the same sort
of interfaces before right we're gonna
in queue and EQ instead of pushing pop
good the same same kind of deal so I
don't know maybe a key was a dumb doubly
linked list right so if a stack is
singly linked then you could just be
doubly linked I don't know that that way
we can like get the end off so anyone
see how this goes all right so you know
let's say I'm just gonna start out with
a queue a non-empty queue this is a
queue that has that's had one in queued
and then has had two and cute and then
has had three in queued so if you wanted
to write on the right side here is the
it's the front the left side you know
the things coming out the left side is
the things going in right so so what
would happen if we wanted to DQ element
number one well so we have kind of it
you know we can get rid of element
number one but then what do we do with
number two well we have to we have to
kind of tie it up so that you know
well do so so our new copy of two still
points in its previous number three
right still points at that but we needed
to make a new copy of it because it's
next element is now nil right the empty
empty queue or empty empty whatever it's
a pointer to nothing all right so fine
but then the issue is now that we have
this new copy of 2 we still have our old
copy of 3 which points to the old copy
of 2 which points that one so that we're
not quite right we actually need to make
another copy of 3 to point to the new
copy of 2 and then you know we can just
kind of tie all that up and that's
that's you know so so we've got our sin
our QA and our QB but they don't share
any common substructure aside from their
pointers to null which is kind of not
very interesting so that's that's not
gonna fly right like it's persistent but
not like not interesting the persistent
is so we're close though
so let's say and you know starting
pretty simply let's say that you have
two stacks right we know how to
implement stacks already so let's say
with two stacks one for incoming
elements and one for outgoing elements
anytime you need more outgoing elements
while you just take the incoming ones
and flip them all right easy enough and
we're gonna have an invariant again I'd
like to talk about invariants this is
sort of what helps us reason about this
code and keep it simple the invariant
we're gonna try to maintain here is that
the outgoing cue we can always pop from
inexpensively like the outgoing stack
always has to be non-empty if the cue
has anything in it at all alright okay
so we're gonna start out like this again
the left hand red dot there is the
incoming empty stack and the right hand
right dot is the outgoing
elements right so let's say we end Q the
number one well again we had this
invariant that it's always easy to pop
so when we put it on the right hand side
but if we push two three and four we're
in Q two three and four they would end
up on the left hand side the incoming
stack Iran you can't just pop from those
because like the arrows are going the
wrong way like so you
a problem there let's say we were to DQ
the number one now right D queuing the
number one well
we end up with this new stack and or
this this new queue rather this new QC
doesn't have number one in it anymore
but we needed to now have access to two
three and four and we needed to have
access to them in an order that we can
deal with so we had to reverse that list
we had to reverse that stack so two
three and four are now - now copies they
we're not sharing very much substructure
here anymore but you know the next time
around we actually get some decent
sharing right if we want to do to DQ oh
yeah DQ - and then n q5 we get some some
common sub sub sub structure sharing
here so far so good these these pictures
start to get a little bit messy so so in
the subsequent ones it's gonna be a bit
less cluttered we're gonna show the less
less sharing so the only thing that we
need in addition to what we had before
to implement this is just an
implementation of reversing a linked
list which is like kind of the thing
that you do in an interview on a
whiteboard not going to dwell on that
but you know so we can reverse the link
let's do it if we can do that then we're
solid right our constructor just becomes
a little bit a little bit more
sophisticated we've got our incoming and
our outgoing elements and then this this
queue on the bottom here is says well if
the alcohol if the the stack of outgoing
elements is empty we'll just take the
incoming elements flip them and we're
good to go
otherwise we we take what we need
otherwise we've got a little gun given
that constructor again you know the
details the details of how you implement
this yet I'm not expecting anybody to
remember this the slides are available
on the web the nice thing about this is
that the implementation is very simple
for in qdq front and is empty still you
know still very simple that's kind of a
nice design goal for us we do the same
trick here with with empty so the next
thing that we need to do given this
implementation is figure out actually
how much does it suck will you know
let's see what we can do with that okay
so n cubes always easy we just push on
to the stack of incoming elements right
we push on to the stack so that's that's
easy we already know that that's order
of one operation DQ well if our stack of
outgoing elements has something in it
DQ is also easy right now remember that
that getting the the tail or popping off
of a stack is just you know it's just a
pointer dereference right so that's
that's usually order one except for if
our outgoing stack was empty in which
case we need to reverse the incoming
list right so it's like it's it's
usually o of 1 but sometimes is o of n
all right so we need a different way of
analyzing this so that we get kind of
like a better idea of what this is all
about right so in queue we know that
enqueue is always order 1 but anytime we
in cute let's say and this a few ways to
slice and dice this in the literature
you'll see this is sometimes you you see
references to something called the
bankers method sometimes the see
reference is something called the
physicists method this is a few ways to
de toutes analyze this but they'll boil
on boil down to roughly the same thing
which is that anytime you're doing an
operation that you will have to like
undo later you pay for that cost up
front you could you just kind of take
that cost you put it in your pocket and
you're like okay I'm just gonna hang on
to that so you know assume that every in
every element the in queue you're gonna
have to pay for later in a rotation at
some point so so anytime you in queue an
element to say say okay I'm just gonna
like you know did that's oh of one plus
I'm gonna take like a dollar put them
over the Bitcoin or something I'm
putting in my pocket right you just you
you you you stack that away upfront and
so so therefore the cost of n queuing is
o of 1 plus you know one credit right
then anytime you DQ well you needed to
pay for all that D queuing somehow right
at any time you rotate how much does it
cost well you know it costs 1 plus
whatever the cost of rotating we're
rotating was but you've paid for that
already right you
take those bitcoins out of your pocket
you're all set so so we can say this is
an amortized constant time queue and
this actually turns out to be a very I
mean it's very simplistic right but this
turns out to actually be a very high
performance queue in certain cases so
what we're gonna do and this is this is
perhaps my only novel contribution to
the state of the art right now is it
everything else I've described so far
has been well discussed in literature
we're going to talk about how this works
on the JVM right how does it perform
since we're working with queues right
you know the killer app of queues is
messaging so we're gonna make a
real-time messaging system out of our
immutable queue right is very exciting
this is starting to get more you know
more real here the issue when we're
dealing with real-time messaging is like
you know we need one queue and that
queue does need to be mutated in place
at some level because like you know that
you're your producer threads are gonna
be talking to it your consumer threads
are gonna be pulling from it so we need
some way of dealing with concurrent
updates I decided to make two benchmarks
one using a compare and swap or a
compare and set right so this is using
an atomic reference and a semaphore to
sort of emulate the blocking queue
behavior right so this is a counting
semaphore to make sure that we like
don't try to pop more elements off the
queue than we've got all right and the
other implementation is probably a bit
more familiar to most people which is
just to use a lock right a lock in a
condition to guard against concurrent
updates all right so here's my
measurements I got to learn I get to
learn how to use our for this which is
totally not a JVM technology although I
just saw said somebody tweeted today
that they released like a new R for the
JVM I should I forget was called so I
got to learn how to use our and do some
nice plots here so what I've done I've
compared can I use this thing ooh
if anybody can can see my laser pointers
very nice first time we've used one of
these things very exciting we're
comparing against Java dot util dot
concurrent linked blocking queue that's
kind of like my reference to see you
know I mean I don't expect to do much
better than it but you know I'm hoping
it kind of like achieve achieved parity
with it and each of these
each of these dots is either you know
p90 P 99 P three 9s four 9s and then max
this is like people 100 right right so
so we're talking about latency of any
any given operation in these queue
implementations so so Johnny will
concurrently block and Q well the the
p90 operation for doing anything with
this Q is about one microsecond with our
compared and set Q we actually get
better then you know sort of the most
common cases right P 50 is presumably
lower but nobody cares about that the
issue is that as you look at like the
worst cases it's way worse right this is
log scale right so our worst case for
java.util current link buck and Q was
about a hundred microseconds worst case
just with one thread for doing an insert
or remove or in queue or DQ or other end
of this thing was about a hundred
milliseconds right which is like one
three orders of magnitude worse all
right so that's not that great you can
see that the more the more threads we we
throw on this that sort of the worse
that we get our lock based queues not
too too terrible the compared and set
based queues though which you know
hopefully hopefully would be cheaper
because we don't have like the cost of
entering and exiting a contended
critical section or whatever you want to
call it monitor you know hopefully
hopefully to be faster in the general
case but because we're in this like
tonight compare and set loop and more
and more things are being added into
that queue with a know of one cost well
you know anytime we need to rotate it's
like you know the the producer queues or
or the producer threads are always
winning the consumer thread is always
losing and so we get this like bigger
and bigger pile up so the worst case is
like a really bad worst case right this
gets this gets especially bad up here
this is like you know on the order one
second for for a message and qdq
operations like not that great this this
is relevant to Twitter you know I was
joking before by the way we don't
actually do anything with rectangles um
so okay
the these kids are grading theory
amortized Oh of one cost in theory in
practice this is not that great for a
real-time application like Message
Queuing so we're gonna do something very
similar we're gonna take what we had and
just kind of like tweak it just a little
bit we're going to introduce a new
invariant right so our invariant
previously in the in this data structure
was that any time the data structure is
non-empty the stack of outgoing elements
stack that you can pop from the stack
that you can DQ from should also be
non-empty right that was our invariant
before we're introducing an additional
one now on top of what we had before
which is that stacks can only be three
elements long okay so why is that good
well anytime you have to rotate a stack
well that's order of three right that's
constant time operation to to rotate a
stack okay great well how do you do that
with you know the assumption here is
that is that you can only have a queue
of six elements in length and then it's
full yeah it's not gonna fly so what we
what we do isn't may introduce a new I'm
going to kind of attempt to highlight
this year we're gonna introduce a new
thing in the middle that I'm gonna call
a spine and I'll talk about what that is
in a second all right so to start with
if we want to in queue the number one
same as before right we stick it on the
on the right hand side so that we can
pop it immediately if we need to if we
want to push or n Q two and three again
same as before no big deal however when
we want to push the element four we're
gonna do something different
we're gonna introduce a new element in
this spine and what that element and the
spine is gonna have well first of all
it's gonna have all of the elements in
here rotated right so two three and four
are now in in order that you know we can
actually pop things off right to was in
queued first and that's the head so
that's good right three is next this is
going to be an element in basically sort
of a recursive deeper copy of this thing
so this this kind of big rectangular
rectangular box here is actually just
one element now in the outgoing stack of
this
you sort of sub the queue we can putt it
we can push more things onto this right
so you know who if we push five six and
seven they'll end up in the incoming
stack of this sub Q we push eight nine
and ten they end up again in this
incoming stack and then what well let's
say we wanted to pop let's say we wanted
to DQ well two three and four are you
just sort of queued up for us we had
them already already already right
they're all set so the cost there you
know we pop one off we needed to maybe
rotate something but rotating is now
easy because all I need to do is just
grab our two three and four and rotate
these two elements to note here right
eight nine and ten five six and seven
we're in the wrong order here now
they're in the right order
what was the cost of that to one however
you want to count it right again
basically constant time all right
very exciting so okay yeah I mean this
is the same is more sophisticated the
only additional thing that we really
need to implement this is just a size
operation because we need to bound the
size of our stacks so fine right easy
and then to implement this it's really
just kind of like uh during the pictures
we have a stack of incoming elements a
stack of outgoing elements in a queue of
stacks right so this is where our sort
of sub-q comes into play and this this
is a technique that I believe in
literature is described as recursive
slowdown implicit recursive slowdown
this actually provides a speed-up for us
I think the slowdown refers to like how
many times you have to do any particular
thing right because the more things you
put into this kind of the less work that
you end up having to do nice so this is
going to be a bit hard to read and
definitely don't expect the people in
the back to read this really or the
people in the front but you know
basically you just have a few cases to
deal with case number one same as what
we had before if you're if you're
outgoing set of elements is empty well
if the spine is empty then we just do
what we did before we just reverse our
incoming things otherwise if we do have
a spine to pull from we just pull from
that so no problem if we're trying to in
queue and the size is at our bound it
can be 3 by the way 3 is just kind of an
arbitrary number I used the number 3
because of what appears in the
literature this is something called a
finger tree a 2 3 finger tree this is
described by Patterson and a guy whose
name I think is whose name is Brown
seems that perhaps two three finger
trees so I chose three but you can
choose like you know 8 or 42 or whatever
you want you're balancing between the
constant factor of you know how long
does it take to rotate any given stack
and how deep do you want your thing to
be right mmm okay so the constructor is
a little bit hairy not too hairy
and the nice thing again is that our
implementation here for n qdq all that
kind of stuff is just as simple as it
was
for we just called the constructor
everything is taken care of in there
again same same technique here and what
I want to do is you know just kind of
check out the the performance of this no
we're doing pretty good on time check
out the performance of this now we are I
think talking hopefully right our link
block and cue again is here as a
reference so right so say one
microsecond for p90 about 100
microseconds for worst case the compare
and set what I'm calling a recursive
queue this is not a this is not a naive
queue this is a recursive queue it's
awesome as it has about the same
performance roughly for one thread if we
do lock-based it's kind of still in the
same ballpark and then you know you can
kind of just follow this up when you get
to 16 threads well are linked blocking
queue the p90 is way over here really
small and for some reason by the way I
ran this so these these benchmarks were
done on one of Twitter's production
servers don't tell anybody I just kind
of took it out of commission for a
little bit and did the tests and then
put it back up nobody noticed so for
whatever reason I'm not sure if this is
due to Twitter's performance near to
engineering team or what but when we got
up to like eight threads and 16 threads
our cost of managing locks was actually
way way cheaper than it was say down
here like this curve kind of like comes
back I'm not sure what's up with that
but when you start looking at the worst
cases like they're actually all in the
same ballpark now they've in you know
even like for a lock based recursive
queue implementation like our thing here
is like actually pretty nice so I
consider this a great great success okay
so I think we're coming up on time but
you know I just want to I want to kind
of recap what we've learned I guess or
how we're feeling about all this
talk about our feelings the problem of
unstable identity again you know we
didn't talk about it that much the thing
I was concerned most with was
performance but you know just to kind of
like package all the
unstable identity this idea that like
you know you throw something into a set
and it gets lost because it's hash code
changes solved right this is like no
problem if you can't change anything
then nothing can change easy this issue
of behavioral subtyping like I said we
didn't talk about that much but you know
you could imagine making subtypes I'm
not sure what good it would do you but
you can imagine making subclasses of
these queues or these stacks or whatever
and being able to fairly simply
implement these subclasses without
worrying about like screwing up the
behavior of the parent class right you
know I'm not sure what you do with that
but you know you can it when you're
developing your own data structures for
doing data modelling and your problem
domain right this isn't you know not not
general-purpose stuff like hughes and
sets and so forth queues and stacks and
vectors things like that but your own
you know like what Twitter really deals
with is say users and tweets and
timelines and things like that and if we
represent those as immutable data
structures you can imagine having
special kinds of timeline you know
special subclasses of a user's timeline
or space but so excuse me special
subclasses of a user that you know are
pretty easy to deal with and don't you
know don't screw up again the the
behavioral contracts that are specified
in the apparent alright
the big problem was this issue of
copying this issue of like you know how
much does it cost if I want to like hang
on to two different snapshots of a state
of a structure without having to like
make a full copy well so this was what
we're really concerned with persistent
data structures are really the solution
here that this this idea of purely
functional data like I said not just for
purely functional programmers this is
like you know you kind of have to do
this most of the time you know because
all them like all that were paid to do
at the end of the day is just like take
collections of stuff and like put things
in them and take stuff out of them and
transform them right I want to earn my
paycheck so like this is this is this is
a big deal right okay
so point being right like the point of
all this was not that you know I'm
offering up like a new awesome solution
for for queueing right we didn't really
do any better than
what our existed in excuse me in in
concurrent concurrent linked key or
whatever it was J the job you look
concurrent stuff we didn't really do any
better than that and in fact like there
exist way way better solutions for
queuing anyway like dis ruptor L Max's
thing has a professor who's sorta
disruptor good good awesome there's
gonna be a talk later on on like CPU
cache stuff to do with what was that was
the term mechanical sympathy I think was
what it says that's that's gonna be
later this afternoon that's not me I'm
looking forward to that talk though so
you know yeah that the point is don't
use these cues for like a real-time
application but if what you want is
persistence if what you want is the
ability to like to work with these
things and be able to maintain old
copies and new copies at the same time
without having to worry about like you
know blowing up you're blowing up your
your heap these are a really good thing
to use performance is great for general
use and you know like stacks and queues
these were kind of a simpler the simple
things to talk about and you know the
scope of 50 minutes but vectors exist
right there's a there's also another
talk I think I'm not sure if it was
earlier today in which case I missed it
but Scala and closure enclosure in
particular implements some very nice
immutable data structures that that that
provide guarantees of like constant time
random access or near constant time
random access like vectors unordered you
know look up like dictionary kind of
structures sets and maps this is these
hash array map tries or do to fill
Bagwell who passed away I think last
year unordered or sorry ordered set some
Maps like red black trees right you've
probably probably seen that kind of
stuff these all exist in a persistent
setting and you know you can just kind
of like do these you can pull these off
the shelf you can you can use these and
so what I would really like to see since
these are so generally useful I would
really like to see these in the Java
standard library I would really any
Oracle employees here I would really
like to see this in Java standard
library because people should be able to
use them
right these these are these are very
good for general purpose use that's all
I've got so thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>