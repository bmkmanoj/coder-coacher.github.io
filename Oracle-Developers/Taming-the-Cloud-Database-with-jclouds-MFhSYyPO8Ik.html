<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Taming the Cloud Database with jclouds | Coder Coacher - Coaching Coders</title><meta content="Taming the Cloud Database with jclouds - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Taming the Cloud Database with jclouds</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MFhSYyPO8Ik" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone this presentation is
going to be all over the place which
means that it's either going to be
somewhat interesting or somewhat
confusing and potentially both so doing
trap me and ask questions if you feel
like you should also we will have a
couple of demos which I understand is
short for demolition so there might be
some explosions we'll see how that goes
and before I do anything else literally
before you anything else you want to
talk about setup it would be nice if you
want to follow along e either now or
later on at home maybe I have a virtual
machine for you don't download it now it
will explode the network I'm sure it's a
probably 4 gigabytes or something insane
like that but it has linux desktop with
some editors and all the software that
you need to do stuff done with jake out
such as good and maven and whatnot so
again yeah don't download now download
later download many times later it's on
CDN it's a convenient way to get up to
speed if you don't want to go through
the work of actually setting it up on
your own machine I'm going to go over
how to set it up on your own machine as
well next so if you don't want to use
the virtual machine you will need java 7
j clouds is because of the j obviously
java right on ubuntu i use the web
update team for java you can just go to
the Oracle site and download it maven
has amazing constructions really well
thought out about how to get it
installed and also get going to be using
it heavily during this presentation some
instructions on how to get it on the bun
to for windows just github is fine a
quick note about using get and j clouds
together the way Jake house is set up
you don't want get to manage your line
endings especially on windows because it
will not compile because of how it is
done and if you have questions about
that asking later but let's pretty much
what you need
and also testing they're going to be
running some demos one way to test the
demos which would be setting up
infrastructure in the cloud with Jake
out so one way to test them is follow
this link you will be able to set up
free ish or I think I think it's free
account with the Rackspace which runs
open sec and I'll go over what all of
that is but if you do that you will be
able to get a token that will or an
account that will allow you to run the
examples and test them in a pretty easy
way now there's also alternative ways to
test if you don't want to sign up for
anything you can download that stack at
this location you can also run devstack
in the cloud you can run it even on
rackspace there is instructions on how
to do that in this link and of course if
you don't want to run Rackspace you want
to run something else there's a bunch of
providers that actually run OpenStack so
a lot of alternatives waste if you want
to test the demos that i'm going to show
you so lots of options not really
married to either one so yeah going to
be using two repos the first one is
jacobs developer examples will be using
this later on during the presentation
this a really explains using mostly just
code a couple of steps on how to develop
a new API for J clouds the other one the
J clouds examples this is a more of a
user facing one we are going to be using
the TRO of example only branch for this
from the ski trip repo it contains the
database example that I'm going to be
showing you today and this will explain
how to set up a database instance and a
database in the cloud with j clouds
alright so i guess after we got all that
out of the way so we can work on that if
we so want
I can do some introductions my name is
Zack shalev you can find me on IRC
pretty much all of the time my hand
though is Zack Sh also on Twitter is
actual f j Kyle's channel on freenode if
you have any questions about Jake outs
there's a whole bunch of people that can
help you out with really anything and
you can also email me is actually laugh
at rackspace calm which brings us to
what do I do I'm a software developer
with rackspace I'm on the developer
experience team which you can reach at
this email most of the people on this
team our software advocates what they do
is software advocacy they make it easy
for developers to use our platform and
three things that we do develop on
probably the most important one make
tools make things easy to use build SDKs
the advocacy part talk to you guys if
you're pissed off with anything that we
do you let us know and we'll hopefully
fix it aim of course community in point
of community is showing up at events
like these and talking about what we
have and about the tools that we use
some goals for today we're going to be
talking about the cloud for it's just in
case anyone needs to get up to speed
with that we're going to be talking
about oj clouds is and why it's
important going to demonstrate how to
create a database in the cloud going to
be talking about abstractions and why
abstractions are important when you're
working with multiple cloud providers
and finally going to walk you through
about how to add a support for an API
using Jake loads so you might have a
cloud API that you want to support you
want supported with Jay clouds show you
how so you can contribute to the project
the cloud the cloud I don't want to go
into the actual definitions of what it
is a bunch of machines on the internet
that do network then distributed
computing and
I will let you do stuff you / AP ice
right it probably makes more sense to
talk about the variety of services that
the cloud offers the two most important
ones that most everyone knows about
compute and storage you get rent virtual
machines from some data center who knows
where over the Internet and you get
computing resources run your
applications on that storage you upload
files download files have CDN maybe
databases this is what we're going to be
talking about today there's different
levels of how much control you can give
over to the cloud you can run email in
the cloud applications anything it's
it's all about the idea of can someone
else doing a bunch of people have a
bunch of common issues or problems that
they want to solve mostly around
infrastructure building in most cases
and how do we do that we solve that by
hiring a company that can run things for
us in the cloud infrastructure of course
probably the one that you've heard about
but there's a couple different ways to
talk about the cloud so based on how
much you want to manage versus how much
your provider manages there's a couple
of different ways to categorize clouds
for example private this is a something
that I've actually done you buy a bunch
of machines and they might even be
commodity servers or blade servers or
what have you you stick them in the room
somewhere on your premises and then you
start running cables you figure out how
to do the storage figure out all the
hardware purchase orders whatnot then
you have to maybe do virtualization make
it easier for multiple users to get
access to those machines you figure out
what server does what what runs
applications what runs databases you
might need to figure out how to do
authentication with that run times such
as Java and then applications on top of
that and it's obviously a little bit
complex and a lot of small companies
have probably tried to do that in some
time
another of course the very common use of
cloud is the second one
infrastructure-as-a-service which means
that all the hardware difficulties and
issues and you know putting things
together and running cables get someone
else to do it and they'll just give you
virtual machines or what have you and
you just need to run your stuff on top
of that such as your database for
example I get a get a virtual machine
from someone and then connect to it and
install a database run that and run your
application on top of that platform as a
service you just do your application and
then use everything else it's provided
on the stack what does it mean your
application usually has to conform to a
specific platform which might make it
more difficult to switch between
different cloud providers least one
disadvantage of doing that but of course
much easier to develop new staff much
easier to prototype and of course if you
just want to buy software so just say
email i think is a good example you do
that and that would be software as a
service alright another way to
categorize clouds the public cloud
versus the private cloud again the
private cloud is probably more of the
case of running on premises versus
running publicly now there's also the
hybrid cloud in a lot of cases what you
have is a base load right we have a
bunch of computing needs that you have
per week or per day and run ban on your
private cloud but sometimes such as
maybe retail season for those of you who
are in retail you might have additional
requirements about computing capacity
running database analysis and data
analysis might require you to burst
through the public cloud as well so the
hybrid cloud is you have a base flow
that room privately sometimes to burst
through the public cloud I think that's
the most common use case of how you do
that some advantages of the cloud
metered pricing of course you just pay
for what you use scalability if you have
just a little small application with a
couple of users you just
pay for that we have thousands of users
large application multiple machines we
pay for that I want to say it's safer
now some security people might disagree
with that but I do think it's safer
mostly because it's off-site and
redundant so even if your business
explodes because of a gas leak or
something oh you know everything's still
running somewhere and something that I
think people underestimate a bit is a
economies of scale so what this means is
that if you're using the right cloud
provider you get expertise and support
for many of the issues that you might
run to especially if you're running on
your own private cloud right so a lot of
the issues that you will see when trying
to deploy applications through databases
or just figuring out how to do the
hardware that's that's all problems that
have been solved already it's very
unlikely that you will see something you
when solving common issues like that
it's already being done so if you have
access to someone who can help you and
someone who's already seen these issues
you will probably do a lot better than
just trying to figure it out on yourself
and reinvent the wheel right ok some
disadvantages less hardware control
stuff like provider control downtime
doesn't really happen much anymore right
at least I am not aware of any important
cloud providers that do a lot of down
time that you don't have to throw over
but things happen virtualization are
kind of unpleasant you can't run things
as efficiently as you can if you just
completely avoid virtualization and run
stuff on your own server somehow the big
issue with cloud providers is locking
you get married to a provider then
you're pretty much stuck if you use
there as the case if you use their
special features that are also nice and
one day you figure out that well we can
just actually do that on it you know by
yourself maybe or switch by switching to
another provider even if it's much
cheaper it's not going to be much
cheaper once you're married to a
provider it takes a lot of engineering
resources to actually figure out how to
look you know look at this bunch of
source code we need to point it at
fairly difficult I've had to do it one
of the companies I worked for we had to
switch from amazon to our own solution
because we decided it's cheaper to just
buy the hardware we didn't have that
much base load so we could actually do
it but switching it couple months for
maybe five six engineers for a small
project pretty expensive a lot of this
can be solved if you use the right
software specifically the right tools
and j clouds will help you minimize this
disadvantage because j clouds is very
big on abstractions and making sure you
can switch between different providers
easily again switching between clouds or
switching between a provider and your
own local solution expensive so keep
that in mind now there's some advantages
that were very specific to databases
we're going to be talking about this a
little bit today in a lot of the cases
that I know of specifically Rackspace
the database instance that you run will
be optimized by your provider things
like settings they the provider will
have a set of settings that have been
optimized for the hardware that the
database instance from some injury some
kind of virtualized container which
brings me to the second point virtual
virtualizing databases they usually can
be virtualized a little bit better than
or a little bit more efficiently than
actual machines using container
virtualization of course the settings
might not necessarily be the ones that
you want but in mole generic cases they
will be very much optimized for running
applications and of course we get into
your own custom settings we'll talk
about that later on automated software
updates critical patches security fixes
and so forth that usually you would have
to manage yourself if you run your own
database software those would be applied
automatically by your provider so that's
you know what off your mind redundant
data storage obviously everything's back
up your database is not going to just
disappear overnight
if something explodes back up in this
case this is different from the
redundant data storage because this
means on-demand backup you might want to
save versions of your databases over
time if for some reason your application
screws something up and you want to go
back to a previous version of it
migration one of the providers will have
ways to make sure you your data can get
into their cloud obviously this makes
money for them because you should switch
to them so that it would usually be
provided choice when I say choice I mean
you can pick the database flavor as
software of what you want to run for
example you can easily select between my
cqo or post grass or a bunch of other
databases and clustering clusterings
pretty hard to do nowadays still
especially for some of the open source
databases and its really nice if this
can be handled for us by the provider
and you can do something like I want
five piston instances now I want them
clustering I want that just work and
there's no reason this shouldn't be
available right of course support which
goes back to scale efficiencies and
whatnot allows us to use previous
experience allows us to make sure that
problem is that we see by using
databases have already been solved by
someone else and we can just tap into
that okay so i mentioned OpenStack
before OpenStack is a cloud operating
system you can think of it as Linux but
for the cloud open source for years ago
by Rackspace and NASA it is free and
it's supported by a bunch of companies
such as 18 th p IBM and Rackspace of
course when I say Linux for the coil it
means that you can run it in your data
center or by using that stack given on
your local machine if you want to test
with that
we are going to be talking about what
services it provides so this is not a
complete list but OpenStack would give
you access to compute which is virtual
machines it would give you object
storage again the two most important
services that people expect out of a
cloud database it's called drove by the
way all those names really bad I don't
like them oh well they don't really
speak to me at all so which is why I
have explained what each of those things
do otherwise there's just no way to
figure it out if you look at that for
the first time a block storage which is
disk like access network virtual
networking there's been a pretty hot
topic lately I think we're going to be
talking about that a little bit more
later on authentication through Keystone
image service like bootable images
orchestration which is similar I thing
to amazon cloud formation which is using
templates to build up infrastructure
ironic allows you to skip doing
virtualization and just get access to
real machines which is I think awesome
messaging q messaging and MapReduce and
a bunch of other things such as control
panels to all of that is provided with
the OpenStack again you can run that in
your own data center then it's free and
you can do what everyone with it even
contribute now I do have this which i
think is a very cool link szostak allah
dicks this shows who's contributing to
OpenStack by companies by modules and I
guess also by engineers so pretty nice
if you want to have a look at what
people are working on it seems a lot of
the work goes into nova right now in
Neutron yeah neutrons pretty hot all
right um you want to have a look you can
go to the link let's talk about Jake
outs in the place of Jacob's you know
that and also object out this so Jay
Klaus is an SDK right and when I say
mezdeke means that this is something
that runs on your own machine right its
job
so it can run on any of those things
that I have listed on this diagram and
it uses the internet which is
represented by a series of pipes to talk
to an API for some cloud I haven't
really said what the cloud is because
Jake out supports a bunch of different
clouds so it's not married to any
specific cloud and by using abstractions
you can talk to different cloud
providers again J cloud is a cloud SDK
it's a top-level Apache project and it's
open source java enclosure supported we
have closure bindings if anyone's into
that fairly easy to use i will show you
some code about how to use it because
it's java it's quite portable again
cloud agnostic to the use of
abstractions we have a pretty big
community just visited the j clouds
channel say hi and that people will talk
to you in its open source of course all
right and this is our website if you
want to get more information such as
dogs or in the wiki the wiki has also
good guides on how to get started with
contributing we're using jacobs which
goes of course beyond the scope of this
presentation but i just wanted to talk
about why j clouds makes things easier
for you as a user specifically j clouds
will handle the networking layer for you
it means things like the requests and
responses will be built and parsed by j
clouds for you jacobs knows when to
retry and how many times to retry and of
course this is so configurable but the
defaults are pretty good it will handle
authentication for you so people keep
asking how how do they handle expiring
tokens or authentication oj clouds will
handle all of that for you when i say to
your vent occation the example that i'm
thinking of is when you authenticate
with the cloud for example Rackspace you
will get an authentication token back so
you don't have to keep sending your
password or API key to the cloud right
and that authentication token has
limited lifetime usually between a
couple of minutes to a day or so if you
keep using your session and it's really
a session token' to keep using the token
eventually to expire and you run into an
access denied kind of a response and
jake house will understand that it will
automatically in the background rio
indicate for you and take care of that
so yes awesome pagination most cloud
resources are paginate 'add if you have
a lot of say database is running in the
cloud like couple thousand the service
will not give you a list of everything
it will be paginate it to save resources
so Jacobs will take care of that pouring
when you make a request to the cloud in
some cases such as say booting up an
instance this might take more than a
couple of seconds so the cloud will
return something like a token that tells
you well we this is your ID what your
instance is not ready will tell you when
it's ready if you keep pulling this
address right so there is to sing Jake
house that would allow you to do that so
Jay clouds would keep requesting and
keeping track of resources that you have
requested until they're ready rate
limits cloud services have rate limits
mostly to prevent things like DDoS
attacks right which means that you can
only do so many requests per minute or
per hour usually pre high limit but not
infinite Jay Klaus is aware of those
limits if you get close to hitting them
you will be warned based on what
settings you have the reason you're
warned by Jake outs is that if you do go
over that rate limit usually you will
get walked out of the service or for a
specific amount of time and you don't
really want that to happen again I
mentioned three tries this also includes
retries like service returning 500
errors in addition to the authentication
retries abstractions by using
abstractions in Jay clouds as I said
before you can easily switch between
different cloud providers by using the
same code of course logging completely
modular logging you can plug in what you
will and over
that results in much less code used
throw a splash screen of a bunch of user
is that we have that's that's pretty
awesome we have a gin Kings redhead HP a
bunch of other people not going to go
over everyone so again services that
jaipal supports specifically storage and
compute we have really good abstractions
for them we have provider specific
services such as load balancers DNS
database is a bunch of other things
today we're mostly going to be focusing
from databases with rackspace just
because it's very easy for me to
demonstrate that of course there are
other providers that you can play with
and use a whole bunch of them with that
you can access to Jay clouds so we want
to showcase some database code go over
best practices in how to use it best
practices include stuff like walking i'm
going to show you how to do that too we
might compare it with how the compute
code works not sure if we'll have time
for that specifically and some gotchas
and work rounds including error states
and how to work around those and how to
use jacobs to avoid these we're going to
be talking about abstractions all right
again the requirements I already
mentioned those and okay the Java
project we are going to be looking at
the skeleton project for this let's see
all right here we don't really need that
alright so dependencies I'm going to be
using maven Pradesh mostly to get the
dependencies you don't necessarily have
to but let's just have a look at this
poem file so may even use the spawn
files which is basically an XML file in
this case what we have in the spawn file
and let me see if I can do this maybe ha
okay so this should help a bit in this
poem file we have the J clouds version
we just have it as a property to make it
a little bit easier for us as will be
using it a couple of times we have the
cloud databases us provider so this is a
cloud this is a rackspace specific
provider that Jake outs understands the
reason we have it like this and we don't
need other dependencies is that all the
other dependencies that Jake out
actually needs would be transitive
dependencies and will be automatically
download at once we have specified this
this includes stuff like the trove API
which is the OpenStack this contains
most of the code the GL chooses and I'll
go over that in a little bit we have the
walking so this is pretty much all of
those two dependent those two
dependencies they are for logging only
we have a mysql connector this is not a
jake house thing but just a JDBC
connector that will be using to actually
connect to the database and make sure
that once we have set it up and it's up
in the cloud it's actually there and we
can say well let's do something with it
right and also we have a load balancer
dependency the reason we have a load
balancer dependency here is that in the
example that i'm going to show you we're
going to be using a load balancer the
reason for this is that the way cloud
databases with rackspace work right now
is that when you instantiate the
database it's behind a firewall right
it's on the Rackspace private network so
you can talk to it but you can't talk to
it from the internet so to talk to the
database we're going to also build
through Jake outs
load balancer we're going to use the
load balancer to connect to the database
and we're going to be talking to the
load balancer is if it's a database so
pretty interesting it's mostly security
thing all right yes yes pretty much yes
we're using hello bouncer just because
it allows us to talk to something that's
behind the net from behind the firewall
right yes okay yes sure yes so the load
balancer runs on the rack space network
so what this means is a very so think of
it as a virtual machine that runs on the
rack space network right the database is
technically runs on another virtual
machine also on the rack space network
however the database itself cannot be
accessed from the public internet which
is where we are right now right to be
able to access the database which is not
on the public Internet first we need to
go through the load balancer which has
access to both the private network
behind the firewall and to the end is
also accessible from the public Internet
does this make sense ok
okay so the two important dependencies
in the pom file again the provider which
would give us all the code that will
needs to actually build up the database
in the cloud and then the mysql
connector which will last actually talk
to the database i just want to make sure
we understand that to actually download
the dependency so i'm not going to be
building using maven don't recently have
a maven file like that is so we can get
all the dependencies in one place and
then we'll be using Java Sea in Java to
actually run all of that too so to get
those dependencies with maven what we
will be doing so I probably already have
them downloaded when I was testing this
so I'm just going to remove them so I
can show you how to do this so this will
download all the dryer dependencies and
it didn't actually downloaded and copied
them out of my cash out of my maven cash
it copied that into lib so if we look
into lib we'll see a bunch of
dependencies so that's a all the
dependencies that we'll be using today
for the specific example as you see we
just said get us a cloud databases us
which is this one it automatically
requested all the other dependencies
that as transitive dependencies that
Jacobs needs to use such as for example
let's see cloud identity this allows us
to authenticate with the service well
that's going cover all the dependencies
not as important oh I just wanted to
mention that JK actually does not use
that many dependencies the main one
outside of what you're actually using
would be juice in guava those are use
pretty much throughout all the code all
the actual dependencies that you use
would be based really on what you want
if you just want to do databases only
the dependencies that are actually
related to using the databases will be
downloaded through mainland which means
that if we
you have a bunch of other providers and
stuff this is not going to be downloaded
by Jay clouds so you get a very modular
experience so to speak and you only get
the minimum of what you need out of jail
out and no more and no less right
excellent let's talk about logging a
little bit when working with API sand
you know calling stuff over the internet
logging can be extremely important the
reason for that is you usually get
responses that you might not expect half
of what's going comes is really not
under your control and you really want
to know what's going on specifically I
think the most helpful part of this is
knowing what's going on on the wire back
and forth right and to be able to do
that logging specifically this wire file
I think this is probably the most
important part of logging if you go to
so again the way that walking is set up
with Jake outs okay the weight set up
with Jake house is we use a log4j which
is lsf for Jay in this case and walk
back we have a bunch of settings that
tell us tells us how Jacobs is going to
actually walk things we have a standard
out file wire file why file is what's
going to over the wire in this case I
have disabled standard out and
everything would go to a specific file
because we don't want you guys to see my
authentication tokens when I run the
demo and if you don't want to do that
you can just be enabling when you follow
along at home or now so let's go back to
this okay so how do we initialize the
API this is what we do this is the
important point but i want to show you
in code so the way this example works
is that we have a smoke test and this is
if you want to actually run through all
the steps for testing the database so
first we'll create an instance well let
me just do this okay so first we'll
create an instance we will create a
database on that instance will create a
user will test the database will do a
grant root access which allows us to get
root access to the on the database
instance and then we'll do some cleanup
now write the code for this is is in
here alright so we have a bunch of
imports not going to be going over that
we have a trove API and a flavor API
defined the trove API so trove as I
mentioned previously this is the
OpenStack service that deals with
databases right they had all those weird
unwieldy names yeah so trove is the
database one we're going to be using the
trove API this contains most of the code
that you actually need to talk to the
actual API the flavor API is you can
think of it as a sub API of trove so by
using the trove API you can get a flavor
api out in this case when we say flavor
we mean the actual hardware
specification or set of specifications
that you want your database to run on so
for example we want fairly powerful
machine with a couple of CPU cores may
be faster disk or something all this
will be determined through the flavor
also things like maybe the flavor of the
database that use such as my city over
suppose grass all of that determined
through the flavor so first off before
we actually can boot a database instance
we need to specify what type of instance
we want to boot and that's what flavor
does so the way it's structured is
basically it's a bunch of runnable
programs that we have they all get
executed from smoke from the smoke test
if you want to but you can run them
separately in this case and this is very
much almost
exactly the same as the actual J clouds
Rackspace examples this is where this
code comes from so it's all available on
github and it's officially supported
okay so we do get flavor so what does
this do let's open this up okay this one
so the way we determine which flavor to
use is basically we just get the first
one and the way we do that is we do
flavor API dot list so this is pretty
easy we just get the list of all the
flavors we just get the first one and
then we use the first one to do you
tails don't get breaking instance now
get into that a little bit more so first
off this is how we initialize the trove
API the first thing we do need to get a
set of modules so modules can do a whole
bunch of different things in this way we
just have a single module in this list
which is our slf4j logging module which
you can replace with your own logging
solution if you want to the way we get
the trove API one which is the API that
contains all the other API so we need to
control databases is we just need to
tell it which provider to use which in
this case is just a rackspace I believe
yup let me go back to that okay yep and
a user name an API key which we got from
the command line now this is where we
add the modules in and then we finally
say just build us the API which will be
the travois probe API once we have that
out of the trove API we can get the sub
API which would be the flavor API zone
here is really you can think of that as
a geographical region for this specific
instance zone would be I ad and again
we'll also be using the name and
password which would be Jake wats
example and some gibberish right
okay so i mentioned that the way we
actually get the instance out is by
calling you tails don't get working
instance and we doing neutral details
the reason I have demonstrated this and
this way is that I wanted to show you
just this like a helper function that we
have in je crois specifically for this
API and there's a bunch of error
conditions that we handle for you and
this is really more for demonstration
purposes usually you might want to
handle this in your API in some kind of
a different way the way this is done
here is that it's kind of guarantees
that you will get a running instance
that you can use say in a demo even if
something bad happens in this case what
can go wrong when you create an instance
when you send a request for an instance
you might get some kind of a response
back that says maybe like a 500
something happens maybe something else
in which case you want to retry it maybe
the instance boots up but boots up in a
broken state really unlikely that any of
this will happen but I'm just kind of
demonstrating what we should be thinking
about when working with us and of course
this is handled to Jay Klaus but the
important part here is again if I go to
this is of course getting the trove api
out i'm going to be talking about that
now so i keep saying trove api there's a
couple of different levels of
abstractions in j class so you have
cloud databases i mentioned that before
what this means is that if you just have
information about the provider that
you're using such as Rackspace so when i
say use the provider Rackspace cloud
databases us this means that Jake outs
will use the Rackspace endpoint in the
United States it's automatically going
to know what type of an API Rackspace
provides which in this case would be
probe trove is the OpenStack database
p I that it uses the reason it uses
drove in this case is at rackspace of
course runs OpenStack in OpenStack is
what we do so abstractions next we don't
have abstractions for a databases right
now in jacobs but that's something that
we're working on the reason we don't
have it is mostly that we don't have
enough providers for the all the other
databases that are supported we mostly
have one for rackspace and amazon and we
want to get I think at least one more
before we do the abstraction the way
this is going to work is that at some
point we'll have just as we have with
compute and blobstore and everything
else we're going to have an abstraction
that allows us to talk to different
databases within changing providers
without having to implement you called
but it's not implemented right now so
the important part of getting the flavor
out is just get the flavor API where I
already covered that if you want to see
a list of all the different API you can
get out of the trove API those are the
flavor one the instance one fresh
getting the instance out getting the
database out and you can have multiple
databases running on the same instance
and then user which basically determines
who can connect to what databases of
course utilities is also what I showed
you earlier so back to creating the
instance the important part on creating
the instance as we probably saw in your
intro videos yep the Saudi important
part is this you say you first you get
the instance api out and then you pass
the flavor ID the size which is the size
of your database did you want to
database you have access to and then a
name for that now having done that you
need to do a weight available so when
you request an instance it's not going
to be available right away it takes a
little bit of time maybe like maybe
one thousand seconds for the instance to
boot up and the weight available is the
way that Jacobs lets you too Paul the
status of that instance until it is
ready yep and this was the actual code
that we saw and this is the you know get
breaking instance that goes through all
the error States and whatnot for you now
let's actually see if we can run this so
first off what we want to do is a
compiled example see if it works no okay
in next you're going to just run compute
instance okay
alright so this is actually going to try
to create the database instance now if
we go to on rackspace if we go to the
control panel which is a cal control
panel for rackspace we should see that
an instance is being built so just go to
databases so yellow means it's being
built yeah the demo is working so far so
what we request it was the small
smallest flavor available which is my
secure with the half a gig of ram and 1
Giga disk and I think one is just what
we requested for the disk size I think
it can we can change this and it's
called Jay clouds example now as you see
because we're pulling it just said you
know create instance for flavor 11 is
just the idea that it's selected and
it's not just waiting for the point when
so this instance to be ready right so
this might take a little while and i'll
just keep going should be done in a
couple seconds so once the instance has
been created we want to create a
database next so you can have more than
one database for instance even though it
especially really small instances like
this i probably wouldn't recommend it
the way you do it is again you get the
12 api by you know the regular way just
the provider username a picky api key if
you want to do you can just add modules
which is what I've done in the actual
example this is just kind of cold
highlights all right okay so we get the
instance API and then get the database
API out of the trove API by saying get
us the database API for specific zone in
a specific instance so when you get a
database API at the database API itself
here would operate on a specific
instance so everything that you do with
it would refer it only to that specific
instance that you have selected
and then you just say create a database
by name that's all you need to do this
database when created it will be created
on the specific instance because this is
already included in that database API
alright and then we're going to be
trying to create to create a user very
much the same way we will get the user
api out of the trove api we're going to
specify the username the password in the
database name and then we'll test the
connection so testing the connection is
a little bit more involved here again as
I said we need the load balancer and
will create one with Jay clouds so this
is the meat of the code for creating a
load balancer we use builder so odd
especially because one of the actual
objects that gets your lies over the
water kind of complex so to create a
building to create a balancer we will
need the name that we want to give it
the protocol in this case we'll be using
my secure on a specific port for my
secure the algorithm doesn't really
matter we just have one database with
one load balancer it really doesn't
matter which algorithm we use but a
couple of those are available add nodes
so add nodes pretty much just contains
the address the host name of the
databases we want to connect to and we
say virtual IP type public so we can
connect to it from the public internet
and then we'll just do what balance for
API dot create and I'll show you the
actual confirm this is just like the
highlight so actually let me just check
if this is done okay so we got the
instance was created successfully and
it's green so it's there now I can
actually just delete it from the control
panel yay okay so they should be fine so
here's what I want to do let's just run
the full thing here while I explain
breathing so it's pretty much going to
be the same command
except for make a small change instead
of running the create instance just
going to run the full small test alright
so again what this would do is that
we're going to create the instance going
to create a database online want to
create the user and going to test the
database now we're just talking about
testing the database testing the
database is probably the most complex
part of the example just because of what
we're actually doing we have the cloud
the cloud load balancer API the load
balancer API 12 API instance API the
important point here probably test
database we get the cloud load balancer
API in the load balancer api out of it
so the cloud lower bounds api would
contain additional api's for some other
troll for some other load balancer
related things in this case we just want
to create a load balancer though which
is why we get this sub API the reason we
need to also use the trove API is
because all of these examples are kind
of separated from each other and the
only thing that they get from the
command line is a username and API key
we need to actually figure out which
which is our instance that we want to
operate on we need to get the instance
ID and once we get the instance ID we
want to create the instance and get the
hosting of the instance so that when we
can build up the load balancer we can
give the load balancer the host name of
the database it has to connect you all
right so this is just a idea being
complacent we what we're doing is that
when we're adding the node we do get
instance which will give us our instance
as an object and would you get hostname
and the hostname would be our node
address that will give to the list of
nodes that our load balancer uses and of
course this node will be enabled and
this is the port we want to talk to
which is the MySQL
for it what we actually do is you know
create the load balancer make sure we
can get the virtual IP for it which is
the IP that we need to use to connect to
the database and the actual test
database just uses the mysql connector
to build a connection string that we can
use to connect to the database and what
it does is it gets the load balancer
public IP it uses the my secure protocol
at this is the name of the database that
we do but that we use and then the
username and the password all of those
constants that have been defined in the
example yes to the load balancer so each
load balancer can load balance multiple
nodes right so this is what the load
balancer would send requests to again
the reason we use the load balancer like
this is because of the firewall we only
have one node and this one node is the
database that we connect to which is
also why the algorithm that we use from
the load balancer doesn't matter just
kind of a way to bypass security so we
can talk to the database but also a nice
demonstration of how we can also set up
really quickly other resources on demand
does this help yeah that's what we're
doing you could do that yes no you
wouldn't be able to do that to a load
balancer to be able to actually cluster
the database the databases would have to
be aware of each other unfortunately by
just using a load balancer you won't be
able to make a true cluster the reason
for that is when you send so for example
there's no way to figure out where
you're getting your resources from I can
talk to him a little bit more after the
presentation but you won't be able to do
that with a low bounce you actually have
to tell trove which is the database
service to do clustering for you you
won't be able to do at your load
balancer okay yes
yes uh-huh
basically
yes that's correct so it makes sure that
you're properly authenticated to your
provider it takes care of all of that
behind the curtains takes care of the
retries the network layer and all of
that yes it is doing the authentication
for you well the authentication is true
the provider so the provider knows if
they should authenticate you so the way
it works is that Jake Al's you give Jake
outs your username and password say it
will send the username and password to
the provider the they will make sure
that you can actually authenticate with
them and if you do they'll send you back
an authentication token which works is
your session right and once you have
your session in place you don't need to
keep sending your username and password
you just send your authentication to the
provider which with each request that
you make so for example when you make a
request to start running a database
instance in that request which is a
restful request that you send to the
provider you will say I want to use I
want to create a database this is my
authentication token that you send me
the provider will say ok this
authentication token is valid we're
going to boot up a database for you does
this make sense ok yes yes that's
correct alright um ok so where was I ok
we have the connection string in place
we just use the driver manager to get
the connection and we run a very very
simple create query to make sure the
database is actually up and running and
this is select three plus five and if
this works we'll get ate out which
probably means that the database is
working which reminds me we had this
running and this is seems to be still
running so that ok this is I guess is
still booting up alright
a little bit slow okay so this might
take a little bit longer to do for some
reason and the connection string in
three plus five ok so again this example
is based on the j clouds examples the
actual Jake routes examples it on github
will contain a bunch of other examples
in addition to just the database one
such as for example the full load
balance for example if you're interested
in that we have a bunch of other
documentation there's ways to use Jacobs
without using maven of course there's
some documentation about how to
contribute of course we're going to be
talking about how to actually contribute
now as well so that would probably be
the next step but again in the
presentation if you want to actually run
this database project I have the command
wines that you need to do to use Java to
run it directly without my even for
linux and windows they're slightly
different and I guess the challenge is
to spot the difference and again some
something's going forward I just wanted
to talk about the future of trove
specifically within the OpenStack
because they mentioned a lot of things
like glass ringing and backup and
whatnot so some of those things are
supported and some are not I'm pretty
sure settings is supported maybe for
some of the databases but not all of
them just because of how databases are
backup extension is something that
already exists so you can do point in
time on demand backups in addition to
the regular data redundancy that you
have of course cool string I don't think
clustering is available in trove right
now in OpenStack but it's on the roadmap
and since I said roadmap I'm just oh
look at that so before I do the road map
before I talk about that I just have a
look at the results from running this so
here's the output of running the
subprogram we created the instance we
created a database in the user we
created the cloud load balancer
when we connected to the database using
this connections training and then the
database was up we got that k plus 5 is
a that that just excellent it means that
we were able to talk to the database
engine we got fruit access on the
database and then we deleted everything
and made sure everything's cleaned up so
good good all right let's go back to I
think the roadmap okay so we're talking
about the trove roadmap and I was able
to find this on their wiki aha they
weren't able to hide it so I was talking
about choice earlier today and part of
choice is making sure that you can pick
and choose which database you use so as
you see things that we that trough plans
to support would be all of these
databases and they have a decent status
of where things are with them so percona
might not be really ready but cassandra
is which is something that I'm
personally interested in and there's a
bunch of other features and I think
clustering does at the bottom of these
okay so we have replication and
clustering and blueprints have been done
for most of these and probably will be
implemented sometime this year so while
clustering is not available right now
for trove it will be and probably pretty
soon so I will keep looking at that all
right um so about the abstraction layer
so as I mentioned before the providers
within Jacobs that support databases
Rackspace and amazon so amazon also has
a thing simple database or something
like that we only have two of those
providers other other providers that
have database services like Microsoft
for sale Salesforce or a cow GDB we
don't have providers for them but
actually adding a provider for something
and just the API is pretty easy which is
what we're going to be talking about
next and I did show you the troll
roadmap and there's some links about how
to cooperate but now the next step we're
going to be pretty much just doing
inside the IDE so let me close that yes
if is the container that it uses
virtualized oh I think so yeah it's a we
have a lot of osgi stock in g cows so
everything is it's built up that way I
think pretty much pretty much anything
that runs java for j clouds does this
make sense all right so if you can run
the oracle virtual machine for java you
should be fine which is which is what
makes it so portable all right so what I
have here is the neutron SDK example so
neutron was something that we developed
very recently it was about virtual
networking which was really a very hot
topic we're going to be going over this
just because it's a simple example and
demonstrates how to actually implement
support for something in Jay clouds so
if you have this available and yet you
will see that this specifically specific
repo has a bunch of branches the
demonstrates step-by-step how to support
a new API so we're going to just start
with the skeleton
alright
so unlike the database example in this
example you have to use maven because
Jake outs everything that Jake else does
is basically maven based so if you want
to add support for a specific new API
you will have to use maven all right and
there's really no alternatives to that
the way you will do that is you would
usually inherit from the J clouds
project which contains a lot of really
nice tools for the new API that we will
be implementing and some of those might
be things like checkstyle making sure
that whatever you do is within the style
limits of how we develop in Jay clouds
couple of other things as well we're
also supported three things like group
ID artifact idea and so forth those were
up to you of course we have a couple of
boilerplate properties i want to say
that they're not very important this
part is kind of important when
developing a new API for Jay clouds it
would be really helpful for you to make
sure that you have access to the J
clouds snapshot repose this means that
as you're developing you can see the
changes and also that like the latest
version of Jay clouds that's committed
to master you have access to that and
this all happens through the snapshot
repositories and those are I think
hosted an Apache as they are okay so a
couple of dependencies that you need
Keystone in this in this case will be
demonstrating how to implement in an
OpenStack API so Keystone is part of it
it will handle authentication for you
and you need that the other one is Jake
outscore it contains all the really
important dependencies that we need such
as of course juice in guava which are
very heavily used within Jay clouds but
it also will help us actually implement
the API bindings that we need to
actually talk to a service and also
jisan which would allow us to use domain
object modeling to allow us to serialize
and this year
Jason into and into objects and classes
which will be we will be doing couple of
that alright so these dependencies and
they're quite a few of them are used
only in tests in our test scope most of
them not very interesting one that is a
mock web server we use mock web server a
walk in our test specifically the unit
tests I'll show you how the way mock
tests or unit tests work in Jay clouds
is that true the mock web server we can
actually verify that the API that we are
developing sends and receives what we
expect to a server so the Jason gets and
the objects gets he realized in
deserialized properly which is a fairly
important win testing right okay so
since I was talking so much about tests
let's let's look at what tests we have
so the skeleton that I have in this
example already has a bunch of tests
like a wall of these like the neutron AP
metadata test and the bass test there
are not as important most boilerplate so
we're not going to be looking at them
much the important parts that we want to
look at are the network API mock test so
we're going to be providing an API that
creates a network in neutron or just as
a subset of it I don't want to show you
all the complexities of the actual
implementation but this is what the
example is based on so we'll be looking
at this test which is of course quite
red because we don't have the
implementation yet and also we're going
to be looking at how to actually test it
the actual test has things like in
resources that you Jason that we use in
the response Jason so OpenStack is a
user's restful services that use Jason a
lot it also has XML but I don't think
anyone cares about that much so we're
just going to be using JSON in this case
right so when creating a network you
might send a request that looks like
this right simple Jason you have
something that's called network it
contains something that's provider
network type mocha whatever that means
it's probably in the documentation but
also it has a name Jake out swivel
alright that's I guess is the name of
the network how do we actually figure
out what those properties are well this
is so in the documentation so I'm not
going to be talking about the actual
properties and what they do I'm going to
be talking about how to serialize them
in the serialize improperly and how to
do that in j cards alright so the actual
details are not as important as the
implementation here but we also have
just quick look at the response when
creating kinetic you might get one of
those properties that you send back just
confirming that this is how the network
was created you might get also some
additional ones back such as network
status in this case which says active
whatever that means we don't know yet we
haven't looked at the documentation we
were just looking at this example we
might get something back which is called
a tenant ID tenant ID is actually pretty
common for OpenStack in this case it
represents your user your OpenStack user
and an ID this is the ID of the network
ok no need to spend too much time on
this let's look at the test and how it
works hmm so this is a very basic
OpenStack mock test for j clouds what we
want to do is that create testing that
the create network actually works now
let's throw a bunch of exceptions which
we're not checking for it so if when we
actually run this if it draws any of
that will fail we use a mock web server
again I mentioned that and we use the
server to in queue a couple of responses
so first week you a couple of responses
means that this when we talk to this
mock server the mock server would return
the responses that we have in queued
so the first one that we do is access
dog Jason so the first thing that
happens when you talk to an actual
server is that you said you send an
authentication request right what you
get back is this accessed up Jason you
can think of this as a Service Catalog
so if your authentication is successful
you get back your authentication token
which is your session token but you will
also get a list of services in the Jason
of what's actually available for the
provider that you have those different
OpenStack implementations might be
different so the actual services
provided would be different and when you
authenticate you get the list of what's
available and what is not alright so in
the case of implementing a new support
for a new API or an extension to an
existing API the only thing that you
need to worry about with this access
jason is to make sure that the actual
API is included in this response when
testing and all the tests will probably
use the same access jason so this makes
a little bit easier now this is the
network create response that we looked
at week you it as the second response so
the second thing that we will do in this
test of course is after we get after we
send our authentication requests and get
a response back from the mock web server
will send the request saying please
create a network which would be Jason
and we'll get something back and this is
the response rate so in Cuba the
responses in the beginning and then what
we do is we get the neutron API using a
helper method which is provided for us
this is the provider name that we use
and we use region one as a mock
geographical region that we use in the
mock test all right in the unit test and
then here's how we want the actual cult
work we want to be able to create an
object called create network and we want
this to be something that we can send
when we say API dot create so we'll
eventually will be and get a network
back so this is what we actually want to
happen we use a builder
learn to build up a create network
request then we send it to the bount API
and then we make sure that the requests
that we sent to the server or what we
expect we do that by a certain 10th
occasion which is a helper method that
we use to make sure that whatever we
send to the server is the actual
authentication request that we expect it
to be sent it's got a complex sentence
and after that we make sure that our
second request which is the actual
create mia network request matches these
parameters that we have want to make
sure and this is all based on the
documentation for network you want them
to make sure that the request that we
took from the server was of type post
that it was sent to this address which
is version 2 networks and we want to
make sure that this is the actual Jason
that we use to in the request right and
then of course we will check the
response and in the response we check
that the response was actually parsed
properly so we get some JSON back we
expect J crowds to parse this into a
network object that we can use and we
can get stuff like the name out the
network type out and of course all of
these properties were already in the
response which was here so you want to
make sure we can use get reg to get to
all of these and that it was the
serialize properly right okay so this is
what we have in the skeleton the next
step would be or we have the ranch okay
so the network resource we need to
figure out how to actually serialize and
deserialize these properties the first
thing that we want to do is how come on
okay so we will skip looking at the test
for now we're actually going to go
through actual implementation so what of
this would be again boilerplate such as
the metadata the metadata has you know
the name of the API that you use
authentication methods Oh of that most
in most of the cases you can just copy
paste this from another API it's not
that important this is what it is a
little bit more important this defines
what sub api's you have inside a neutron
and we talked about the sub api's
earlier on so for example in Neutron you
might have something like get configure
configurate regions which determines
what geographical regions are supported
for your API this is not an important
point or this is also not the important
part this is the important part getting
the networks of the API and of course
this is all handled through delegation
and juice not going to go into that too
much because what we want to do is and
of course we have some other boilerplate
such as the HTTP API module the neutron
error handler of this is fairly standard
in Jake clouds we will have the network
API and this is where we'll configure
how the API is actually bound or the
medical such as create would be defined
here we don't have anything right now
because we haven't started looking at it
yet but something that they wanted to
show you is that all of the ones here
will consume and produce media type
Jason which means that the content type
of the requests would be Jason in that
also Jason is expected when you get
something out of the services so the
produces one is in this request filters
authentication request is the way that
Jay clouds automatically does
authentication for you through the
sanitation okay and of course we have
path networks it means that everything
that happens here goes to the endpoint /
networks okay so back to how things are
serialized in deserialized so we have a
bunch of member variables here which
respond to that request and the response
that we saw a little bit earlier in the
test so we want to make sure that say
this response here gets the serio eyes
and see realized properly right and this
is how we do it with network so this
just has a list of the things that we
want to have now we don't have any
anything of the actual stub it makes it
work we just have it listed here it's
like the first step figure out what you
actually want to support inside your
network the next step of course would be
just a small improvement here so the
improvement that we're talking about is
that we used to have a private string
status and the status was this status
over here which was active right so when
you see stuff like that in the OpenStack
usually means you have a bunch of but a
limited bunch of possible strings for a
property inside Jason now it doesn't
really make sense from a user
perspective you have to go through the
documentation every time every time to
figure out what's actually possible here
right so the way we handle that in Jake
house is that we have enemies like this
network status so this allows us to
document in code what with what we can
actually do with these enums so the
possible strings were the status that
you get back from the network are active
down build an error and I got that out
of the documentation and that's pretty
much it now something one way we can
improve this is to make sure this is
actually documented which enums would
allow us to do fairly nicely all right
so what we want to have is in the image
that we provide users want to make sure
that everything is documented all right
now we also want to make sure this is
serialized in deserialize properly the
way we do that is we have this from
value method now this is very j cloud
specific what this does is that Jake
else uses JSON
and our JSON is configured to use from
value when it finds from value method
inside an enum the way this from value
works is that it will make sure that if
your enemy is actually now in the
response during the request it would get
the C realized as a now also make sure
that if any of these strings is matched
it would be matched in a
case-insensitive fashion and also if it
sees a string that it doesn't know about
for example because the service changed
which is one example it will return and
recognized so it won't crash on the user
right which we don't want ok so this
behavior and this from value method is
also documented on the j kallis wiki so
i really like how in a mess where and
how they help services be documented in
j cows which is why I really wanted to
cover this it's a and we see a lot of
those actually with OpenStack so the
next step
what was that okay the annotations so if
we go back to the domain class that
we're building will see that we have
some extra annotations here so some of
the names that we use such as this admin
state up was canalized where as in the
example that we were using it was a it
was using underscores and the provider
network type was slightly different so
we use the named annotation to make sure
that any of these properties any of
these member variables that we're
modeling here in this class would get
serialize properly to deserialize
because of how geez on Rixon because of
some edge cases that you might hit we
prefer to use a construction with the
constructor properties annotation and
when you use that when use both of these
names and constructor properties
annotations you ensure that when you
implement an API with Jay clouds your
object member variables would be
properly serialized in DC realized okay
okay so of course what we need to do
next is implement a whole bunch of
methods to make our class usable in the
way we do that usually see you know we
have in the way would you do main
modeling with Jake houses we want to
provide a default constructor and a copy
constructor in addition to this one then
a bunch of Gators in this case we use
now balls instead of options now there's
a you could use I'm not sure if you if
you know of a guava optional but you
could use that instead of now bow if
that's what you prefer it's basically a
different way to program to avoid using
mouse and you have absent instead but I
don't want to go into that for now we
just use box types and now balls and in
addition to all the Gators we will just
implement you know the hashcode echoes
in to string the way we implement these
in Jake clouds is that we use the guava
helper methods to do that also in idea
there's a way to also generate these
using the guava helper methods which is
a pretty cool you save a little bit of
time with that not sure if everyone sees
that alright so once we have that
so the way we want objects to be
implemented in Jake houses we want most
of the objects to be immutable and also
to be easy to use usually with the fun
builders to do that one of the things
that we implement is in this case let me
just go up alright so first off when we
switch everything to final to make sure
that once the object is instantiated it
is immutable when this helps a lot with
red ink right to do that who will
implement a builder this is not the
final version of the Builder this is an
example of a standard builder that you
would implement with a class like that
the way you do it is you have a static
builder method that gives you an
instance of that builder not necessarily
the way it's done but this is how we'll
do it here and then you have inside that
same file you can separate it out but
not needed here we have a private static
builder class it has the same member
variables as network and it has cetera
so the actual classroom like a say a
beam object or a quest it doesn't have
saturated soil etc sir in the Builder
you build up your builder and once you
set everything that you want on the
Builder you say build and the Builder
will give you an immutable network
object that you then can use now some
issues with this somewhat naive
implementation of building for this
network is that you only get one network
out right so but what we want to have is
we want to have one network type when
creating canet work we want to have a
slightly different network type maybe
when updating kinetic in one we want to
have a different network type from for
what we get back from the service so
that's a total of like three different
network classes that we want to handle
somehow and this is like just a single
builder so potentially the way to
improve that is to have multiple
builders for each of these we also want
to provide different validation paths
when updating or creating or even
listing back from the service the way to
do that will be in the actual
implementation
alright so the way this is done is we
still have our network object but it
provides two different methods one
method is a create builder and the other
one is an update builder and when you do
network create builder you get a crate
builder back and this is the Builder
that you use when you want to create an
object that that you can use in the API
call that actually creates a network for
you and this is different for from the
object that you get when you want to
update a network this is also different
from the object that you get back from
the service this is because we don't
want users to get confused when you know
using code of networks and maybe send
the wrong network to the service which
won't work of course the service would
validate that but you kind of want to
make sure that all of these things are
handled as early as possible so they're
saying issues they fail right away using
forward failing right and the way we do
that is by having those different types
of builders and subclasses so the way
that you'll builder gets implemented
then is we have abstract builder which
has a parametrized builder type we
didn't want you so we kind of decided to
weaken immutability here so instead of
having all the properties of network
inside the Builder we just have a copy
of like a working copy of the network
that we use inside the Builder and of
course we have the abstract method self
which allows our builder subclasses to
return the right type of build ourselves
self kind of replaces this and this
allows us to chain builder methods
together so as you saw in the test you
can do dot name don't description and
just keep training methods and then do
doc build and you will get the right
object back okay so we have all the
setters and this common code that will
be shared between our builders of course
if you have a setter that you don't want
to be available say in the Cree
or in the update method you can take it
out and you can move it to the specific
builder that you want to have the center
so for example if you only can set a
particular property in when you're
updating something you can make sure
that this is only there right okay so
the way that actual create builder works
fairly simple it just extends builder
and it says it's a type trade builder
and that's pretty much at now the way
our builders work is that if there are
any required properties and in OpenStack
those will be very few of those they
will be part of the constructor for the
Builder just seems like requiring users
users to specify them in that way has
been helpful to some people okay so this
is again this implements the abstract
method itself which just returns this
which would be create builder in this
case and you have the build method which
would return create network and create
network is the subclass of network that
allows us to actually create a network
an update builder works very much the
same way except the update builder
doesn't actually require any properties
because any of the properties within
network can be updated or really none
can if that's what you want we
experiment the same way and of course
you have the network subclasses create
network and update Network which allows
us to use that compile time checks to
ensure that whatever you send to the
service is the right one and I also need
to show you how the network API has
changed so this is responsible again for
binding virtual calls to the API it uses
annotations that are supported by Jay
clouds the named annotation is mostly
descriptive get or post or put specifies
the HTTP method that you use for this
call path of course works better with
this top-level path so when you are
getting a network it would be
ash networks / the actual ID and this is
what this annotation handles select
Jason means that when you're
deserialising from the Jason it will
take it will find network inside that
JSON into two will use that sub part of
the Jason to deserialize into your in
this case Network class object of course
we have fall back annotations supported
in this case if you get a 404 instead of
network get would return now which is
why this is also available of course the
example that we were looking at for the
test was create of course we have the
descriptive annotation we have a post
type of HTTP call and we select again
network so the Select Jason here
describes for Jay clouds when you get
the response back which part of the
response you d serialize into network
which would be called network here wrap
width means that your create network
object would be serialized in to Jason
and then we'll put a network in front of
it and it will make it look like the
example of course we have all the other
ones now you will notice that
collections are supported so for example
when you're doing create bulk you can
just wrap with networks instead of
network and then use an immutable list
and J crowds will make sure this is
serialized and deserialized properly as
well because it understands how these
collections work update similar to I
guess create except the difference is
that it uses the proper in network
subtype which is update network and
again what you get back from the service
is still a regular network and of course
delete which is just returns a blend
time now since we all also had a test we
can just check real real quick if the
test will actually pass in this master
which I'm sure they did because I tested
it this will download our dependencies
with me even
it's pretty quickly and then it will run
the test again if we look at the test
which was where was it
choose this will make sure that this
works which is still downloading some
dependencies but but that's that's
pretty much it that's how you can
implement using Jacobs and new API and I
think that's pretty much it and because
it was kind of complex I kind of wanted
to have a lot of time for questions so
do let me know and we can go back to
some of the code yes in the service
there might be functionality for this in
this case we're mostly talking about how
to talk to the service that provides
that network functionality does this
make sense okay so i think there's way
so specifically if we're talking about
neutron and networks it's the service is
fairly complex of course this is just an
example of a subset of network the
actual network object has a like a dozen
more properties that do different things
and neutron itself supports network
virtualization which means things like
us which is and pour it routers floating
IPS so this really just shows you a
subset of all that right but there's a
lot more that you can explore it yes
yes so the idea is that this API
specifically provides functionality to
talk to one cloud provider right so you
have this and this is just like talks to
an OpenStack API in this case now below
that on a lower level of abstraction you
might make this API talk to a specific
providers such as Rackspace so you have
OpenStack neutron which provides all
this code because this code is mostly
standard across different OpenStack
providers below that water abstraction
level you can have cloud networks us
which would be the endpoint for
rackspace and then this would work on
rackspace and it will automatically use
OpenStack Neutron Fred now above that
you might have something like j clouds
networks which would run and work with
multiple different providers that have a
network like rich virtual networks like
service does this make sense ok any
other questions so that's a difficult
again because it depends on the level of
abstraction that you use if you use a
very low level of abstraction such as a
provider level of abstraction or a
specific API level of abstraction you
will actually have to be cold well J
Klaus provides on top of that is an
abstraction that actually works with a
specific provider so if you use the
abstracted called that Jacobs provides
you can only change the provider
underneath it so you can just change
change the string and say instead of
this provider use this provider and Jay
Klaus would automatically figure out how
to use that different provider because
there's code that tells jay clouds how
to link those two right but you have to
use the highest level of abstraction
than jacobs provides for example the two
important ones compute and blobstore
those work with pretty much
all the different clouds because pretty
much all different clouds support that
right some of the services such as
virtual networking not all providers
would support that skewing might not be
supported by all different providers
load balancers the other thing is that
when you use a high level of abstraction
you can actually select to unwrap that
abstraction layer and go that to go down
to the actual provider and then use some
providers specific code so this is
another thing that you might want to
avoid but it's possible so it really
depends on what type of abstraction you
use and Jake house gives you a lot of
flexibility on how to do that of course
you do take on more responsibility if
you decide to go war right because then
it would cost you more money to you to
switch to a different provider now the
idea is that we want to have providers
for all the different clouds out there
for all the different services and then
we want to have abstraction layers on
top of that that allows us to use where
as much as possible different providers
in a cloud agnostic way of course it's a
little bit difficult to provide lot of
those abstractions but this is just the
ongoing work that we do especially
considering that all the different cloud
providers keep coming out with new
services right so that's a yes submit a
pull request it's a very simple so we
had somebody just a you know download
for example j clouds labs OpenStack
which is the repo that you're using you
just clone that then you check out the
branch based on master right and then
you work on your branch you just follow
the process that I just did to add like
a new extension that you're interested
in like an API that you want or even
like a completely new cloud provider and
then you just do a pull request based
off of your branch and we review it will
give you some you know hints and tips in
the comments on github we do use github
for that a lot when we have a lot of
extra details about how to contribute
and like guidelines and whatnot online
and eventually we'll ask you to you know
fix what needs fixing can
we'll just merge it and the process
based on how responsive you are is very
quickly we usually get a response the
same day when you submit a pull request
and might take a couple of days maybe to
figure out all everything that needs to
be fixed probably not a lot of stuff we
do want to make sure that you know
things like style and use abilities of
course they're right but it's fairly
easy to do that I mean if I was able to
explain how to do a new API in like
clutter maybe an hour so I that's pretty
good it's not that complex obviously you
you can copy a lot of the stuff you can
see how other api's do it your provider
might be slightly different in some
cases you might need to do some research
but it's not very difficult and the
process is basically submit a pull
request and that's it okay yes how much
it would take some more catchy because
this is this was not using the database
abstraction layer because database
abstraction layer does not exist we do
have a compute abstraction layer right
so if the example was about virtual
machines for booting up a virtual
machine what we will do is that we would
have an example with the highest
abstraction layer which will just say
something like use this template like
thing to create a virtual machine on a
provider and the provider would be
something like Amazon or brag space and
we'll just be string so based on what
abstraction levels exist in Jay clouds
and how abstracted you want your code to
be that will determine how much it costs
you to switch to a different provider
does this make sense in this case yes
well okay somewhat of a clarification
the code is OpenStack code in this case
so we don't use Rackspace specific code
we just use the provider so the same
code you will be able to run against any
provider that has OpenStack as the basis
for their cloud right so for example you
can run the same cold against HP for
example because HP uses OpenStack Amazon
does not use OpenStack Amazon uses their
own private solution which I don't even
know what it's called but they like the
underlying implementation is not open
source and they use use their own thing
I mean they have a set of interfaces
that are public but only the interfaces
Republic and we program against that
whereas OpenStack is an open source
cloud operating system really best way
to think about it and multiple providers
would actually use OpenStack you know
Amazon doesn't use it but HP does and
Rackspace does in a couple of other big
providers do so anyone that uses
OpenStack you can actually run that
cloud database trove example against but
not against Amazon because they use a
different set of interfaces
all right anything else all right I
guess that's it thank you so much please
talk to me online if you want to send me
an email check out this developer at
Rackspace com if you want to figure out
how to get a nice discount for about a
year or so I think and if you have any
questions let me know thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>