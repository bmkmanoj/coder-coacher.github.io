<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Groovy and Concurrency with GPars | Coder Coacher - Coaching Coders</title><meta content="Groovy and Concurrency with GPars - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Groovy and Concurrency with GPars</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7AByMX76c_4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">on this slideshare you'll have extra
material if you're interested in other
libraries whoa so you can use there's a
number of other libraries you can use as
things like a cur and so on that because
it supports Java as GP supports Java you
can you you can cross use those between
tools and there's a bunch of other rum
other little libraries that are there
you can see some other examples there's
some like dining philosophers done in
six different tool kits and things like
that um now I'm not going to give you
the lot at this point in the
presentation I meant to tell you that
the will is about to end if you don't
learn concurrency and and every single
sequential program you've ever written
is going to be useless in any day now
because the concurrent is becoming such
an important thing for many of my
customers concurrency isn't a huge thing
for them we our industry goes out of its
way to provide frameworks that let you
avoid concurrency nearly all the time
but there are times when concurrency is
very very critical and that's what
jeepers is going to help you get get
benefited from so I'm not going to give
you the big spiel about how the world's
ending and everything what we do know
for sure is that there's more and more
cpus available there's more and more
opportunity to leverage concurrency if
you've got a scenario that has
concurrent concurrent algorithms or
concurrent data so so we know that's
there it's it's good for finding those
scenarios to have some extra tools in
your tool kit to solve those problems
and as we said before is hard if you've
ever been doing concurrency in various
forms for many years in back in C and
C++ days and so forth it was lots of
pulling your hair out and lots of things
that could never possibly go wrong would
go wrong and the good news is that each
version of Java that comes out slowly
raises the levels of abstraction
toolkits like jeepers and so on raised
at a whole groovy itself raises that
raises the abstractions that you can use
a lot more and then
jeepers sits on top of that and gives
you very very nice abstractions that you
can use in your programs if you really
want to dive into some of the theory in
all of the hard stuff there's a lot of
good books this what this is one of my
favorites Brian goats he's done it quite
a few of the key sessions are through
through this conference if you had a
chance to hear of any sessions you'll
know that he's a very knowledgeable
person and he's done some really smart
things right throughout the the driver
libraries the other thing that I'll just
briefly pause on Ralph Johnson presented
a thing at strangely a few years back
and it sort of resonated with me that
something that I didn't find happening
in a lot of the other talks that were
there there was lots of people saying ah
we've got this brand-new think'll actors
you know in our library everything
should be solved with actors or
something like that you know whatever
the favorite thing was that there the
particular language hadn't now just
supported and really again the
experience that I have with most of my
customers is you don't get the biggest
bang for buck with actors actors do move
you you know sideways into it into a
different realm where certain problems
go away but you've still got quite a few
problems that you need to get your mind
around to make actors work well so it's
it's some much much better than where we
were back in with doing C++ with
handling everything ourselves but
there's usually if you look at some of
the MapReduce frameworks and other
things if you've got big data or
algorithms that have got particular
characteristics about them you can get a
lot of bang for buck with some of the
other things like data parallelism so
really we've got a different levels of
abstraction and we you get the most bang
for buck by looking at things that are
like data parallelism that a very very
minimal chance of going wrong and very
very simple to apply and things like
actors in at least in most of the
scenarios that I deal with are a very
very useful thing I'm glad I've got them
and I make use of them quite frequently
but they're not the thing I go for what
I'm trying to impress a customer give
with a quick solution
so each of these levels there's
different things that you need to deal
with when I said data parallelism is get
you to the biggest bang for buck that's
true but if you don't if you don't have
masses of data that's not your problem
right if you've got to do lots of i/o
that it's not going to help solve your
problems so so depending on your picking
the circumstances you've got to go and
pick the right abstractions and the
right tools okay so jeepers gives you a
toolkit with a whole range of high-level
abstractions in his inner spectrum so we
have will be going through these so
there's data parallelism which is the
one I think is the one that's most
easily applied I've got customers who
know nothing about concurrency who don't
you know wouldn't regard themselves as
having the top the best top-notch
developers and they can go and start
using jeepers for doing concurrent tests
and things like that with very very
minimal impact on them very little
training that they need and so there's
you know lots of things that they can do
and we'll look at a synchronous
functions will look at data flow data
flow is a very underrated technology it
often lens very very elegant solutions
it's some we've all sort of saw data
flow in early incantations if you
remember the transmuters and other
things and it never really took off and
there's I think when it's now at a point
where it we could see some resurgent of
that particular technology because of
the the style of programs that we can
create now and the kinds of technology
that we have available we're not trying
to create dedicated transmuters that are
doing data flow themselves we've got
general purpose hardware and applying it
in smart ways then we've got actors and
CSP is another thing that we can support
we've got software transactional memory
which I won't spend very much time on
today and agents agents are another rum
very very powerful technique that
they're kind of low-level in the sense
of there are a little hack you can do so
that when you do need to do mutable
structures you can do it with safely but
it for me it tends to come into play
because a lot of the time I'm dealing
with you know legacy software that I
need to interface with legacy libraries
that I need to talk to him unfortunately
some of them are using mutable state and
I want to do I want to use those but I
don't want to have to think through all
the complications of using them you know
in a proper way because they were never
designed to be used in a concurrent way
properly so agents make it really really
easy to do that and we'll have a look at
that so um it's I find it people always
ask me or you get you told me about
these you know n things that are in
jeepers which one should i use and it
really depends on what your problem is
so if you've got you know let's just
let's just have a look at things if
you've got a hundred numbers and you
need to square them all that's data
parallelism in a list or ray or whatever
so you take all the numbers and you just
want to throw lots of CPUs each one is
independent tasks you're doing but it's
it's that same task across a massive
numbers that's a linear data parallelism
problem you just go use the parallel
collections we're talking about if I was
going to sort a hundred numbers and I
had an algorithm and said ah well if I
could sort the left half and then I
could sort the right half and then maybe
just do an insertion sort of those two
sorted lists and then for each of the
left half in the right half I could
split them in half and so on and I can
throw CPUs at those sorts of problems
that's still data I've got a hundred
hundred numbers i want to sort but I've
got a recursive algorithm that I can use
to do my sorting and that's a recursive
one we can use fork drawing sort of
methods for that if I had that the data
but it's are streamed so it's not just a
hundred numbers but it's 100 numbers now
100 numbers you know seconds time and
100 numbers in another seconds time then
we've got we've got stream data
parallelism and it would be a dataflow
operator or CSP would lend itself well
to that if it was an irregular thing so
it's it's not just you know there's a
whole lot of data coming in but it's not
just going to be the same calculation
across all 100 numbers it's depending on
what the data is i'll be doing a whole
range of different things that's a
really good candidate for
does um if it's not massive data if it's
actually got lots and lots of different
tasks many many different tasks that I
might want to do that's really task
parallelism which is sore the middle
branch in that tree and again depending
on the kind of tasks I'm doing it might
lend itself to data flow or fork join if
it's recursive or if I do have to deal
with shared data there's tricks i can do
to not go through the pain so are using
agents using software transactional
memory there's different things that i
can do there it's that all sort of makes
sense yep and another there's a couple
of other different ways to look at look
at look at those things one of them um
and I think Dirk probably coined most of
these if not all yeah another
interesting way of looking at what these
different coordination of approaches do
is how the coordination is handled right
when i'm using data parallelism it's
it's fixed so I've got my hundred
numbers like it goes through a step I
get some results of hundred results then
I might go through another step and get
another hundred results or there's a few
different variants on that but that's
basically it so it's a fixed sort of
coordination when I've got actors I've
hopefully got little pockets and there's
a few different flavors of actors but
we'll do the simple case little pockets
that are pure that are talking to one
another so we're not when I want to have
communication between my pockets of pure
functional activity there's explicit
coordination I'll this pocket will talk
to that pocket by sending it a message
and this pocket will talk to that that
actor sending get a message and so on so
there's explicit coordination between
those things in my program it'll be
quite obvious who's talking to whom when
and where with our agents its its
delegated coordination so I've got
someone else who's going to handle you
know I don't to do all that
synchronization stuff because it's hard
I'm going to let the agent do it all for
me okay and with dataflow there's an
implicit so you won't see any
coordination at all in your code you
will just say here is the declarative of
nature of the relationships between the
things I'm trying to calculate and their
inputs so it's a declarative expression
of what you need to do
this isn't you can't see what
coordination is there the coordination
happens automatically we will see we
will see a little graph of that very
shortly yet another way to to view where
jeepers sort of fits in to to this sort
of thing um the JVM provides us lots of
features to do prowlers and concurrency
they're all fairly low-level as I said
each new iteration of the JVM we're
seeing a few high-level things creep in
which is all which is good we're getting
better and better things groovy provides
a range of things to to give a little
bit of sugar to what the JVM provides so
now I'm got time today to go through
most of the manga I'll go through one or
two in the next couple of slides and
then we'll get onto jeepers but it turns
out that when you're using you know it's
great that we've now got red locks and
right locks and things in at the dr ian
but when you're using them it's actually
is still a little bit tricky so groovy
gives you some annotations to make it
easier when you're doing synchronized if
you have used the synchronized keyword
in Java you've probably introduced a bug
in your program so synchronous
synchronized annotation in groovy gets
around the common bugs that people do by
just using that keyword without a lock
and things like that there's a whole
range of laziness features you can
leverage now in groovy there's a whole
lot of libraries that give you some nice
features the lazy annotation of your
things you can use Griffey bye-bye as
distinct from other functions some
functional language that might be
immutable by default which has got some
benefits groovy groovy doesn't have that
default in in most cases but makes it
very easy if you want to keep things
immutable okay and there's various
persistent data libraries and things
I've got one slide on that very shortly
that you might want to use so you'll
still want to use a sprinkle of those
concepts when you doing jeepers but most
of the time you'll be using your
application will talk to jeepers and it
will give you some higher level
abstractions to keep you away from from
some of those nasty little things that
can occur ok so just to give you a
flavor some of your I've probably seen
this in pre
his talk so I don't have dwell on it if
I know you all for bedtime reading you
read through drawers blocks book on
effective driver and you've memorized
the 22 rules for writing immutable
classes there'll be a test before you
leave of course if you have memorized
them all you'd very very easily be able
to whip up that little immutable class
that's here you'll have put in all your
you get is but no setters you'll have
done all the right things in your equals
and hashcode methods and and you would
have made your all your things private
and final and so forth if you don't
remember the rules Griffey would sort of
say well all that boilerplate and you
just write that and groovy would sort of
handle all the rest right and if you
don't if you don't like what that
immutable annotation because you can
easily write your own annotations and do
slightly different things okay so the
other thing that I just want it's not
really part of jeepers per se but it's
just something that's quite important in
today's functional world is collection
so when i'm using a mutable that's when
i'm writing my own class and i want to
make an immutable class what if i've got
a collection of things either my classes
or strings or primitives or strings or
rabbit types or whatever it is that i've
got a collection of um when I'm dealing
with those in a minute concurrent world
now the nice thing is that some of the
abstractions we're going to tell you
about later on you don't need to care
about this because you're not going to
have any any you're not gonna be sharing
any state at all so it doesn't matter if
you go and use a mutable lists inside
your little pockets of siphoned off bits
of code because no one else is going to
be seeing those or sharing those okay
but there's other times when it's it's a
it's very very nice to be able to
actually share some data usually in a
concurrent world it's when we want to
read some shared data it will be the
safest thing and reading a shared
mutable structure which is the
persistent data structures can be a very
very useful thing to do okay you've got
a whole lot of look up data that you
want to share use a persistent data
structure and you end it's much much
harder to go wrong you still need to
apply all your nicer pure fun
behavior in all the other parts of your
code so just to show you just to talk
briefly on what this this little slides
about most of you would be familiar with
ArrayList hash sets hash maps and so on
the stuff that comes out with the normal
driver collection classes and they're
all mutable classes so if I've got an a
a list that has two letters in it CNA
and i want to add T it'll just mutate
that array in memory and a little
clunker little T character in there and
you'll be done okay good news is that if
anyone else is interested in this
particular string or array of grey of
characters whatever they can be pointing
to this and they'll once you've finished
assuming they don't try to peak too
early and you're in the middle of
changing something they'll be able to
see all the changes there's no
coordination problem but there's an
update problem if multiple people try to
update this at the same time or there's
various race conditions if updating is
an atomic so there's sorry
well um yeah you're in a multi-threaded
race race scenario and depending on the
circumstances of what you've written and
so on that that is a possibility but
yeah on the whole you you know the way
you were typically write a dumb
multi-threaded applications using shared
state you'd eventually see it at some
you'd see it fairly quickly there's
certain certain guarantees that you'll
get and but you it's a very dangerous
place to be you don't want to be there
because if you've got data yes if it is
a strict constant and never get changed
even though it happens to be an
ArrayList if you've got nowhere in your
code that changes it you can get away
with it certain certain circumstances
but you know concurrent world this is a
bad place to be because you just hit all
of the update problems and the race race
problems as soon as you try to change
anything so one of the techniques that
you use to solve this problem is to have
a mutable list so if you've ever used as
immutable or the immutable variance in
the in the Java collection libraries or
you've used the Google collections the
guava libraries or you've done little
meta programming tricks to just go and
get the any any method on a on a list
that updates go and block it out using
meta program if you've done any tricks
like that that's one way to solve a
certain range of problems in this
particular space and what in that
scenario if you want if I wanted to add
a tea character into this list array of
characters here I'd leave the initial
one if anyone else was observing that
appointing to it they'll now be pointing
to the old one but once I've what will
happen is part of the operation of
adding in this to you but all the
characters here will get copied and the
tea will get added and once the it's
finished that operation the new one will
be revealed and now anyone who wants to
point to this new one will see the new
thing okay and anyone is pointing to the
old one won't be affected okay
now you still you haven't solved all
your problems because if you've got
parts of your program that need to see
the new value you've got a coordination
problem now with your references because
you've got to somehow tell other places
in your code to point to the to the the
new thing okay now we could spend ten
minutes describing various things here
but I'll leave it at that for now this
does solve a certain range of problems
button but not a lot not we're not a lot
lot better off with the the current
libraries that we have the third
approach is using what's called
persistent data structures now these are
called persistent nothing to do with it
doesn't store values in a database or in
your file system or anywhere it's not
persistent in that sense it's persistent
in that anything that gets added to a
data structure anywhere gets left around
and usually shared whenever possible
okay so in that particular case I'll
have CNA if I add a tea or I'll get a
new thing added to this data structure
here that point so long anyone who's
interested in the old stuff will be
still pointing to here in this
particular one here pointing to the a
and they'll still see what they saw
before ok now this solves a whole range
of problems there's many efficient
algorithms that let you share large
amounts of the data so it's got some
really really neat features but it's for
certain algorithms this becomes horribly
inefficient if I do a naive
implementation and I want to go I've got
a tree of nodes and I want to go in
insert an element at one particular
point the hot the tree might fold and
move you know move positions but
everybody who was originally pointing
into this tree needs to see what they
saw before so I might need to
potentially copy huge slabs of this tree
in order to let the new people see the
new tree and the old people see the old
tree so not every algorithm is going to
work well here now the good news is that
there's some very smart people doing
very very good research on the
characteristics of these kinds of data
structures and there's also different
sorts of smart trees that have very very
good
performance characteristics even when
you're doing certain kinds operations so
you know if you've got it even when
you're creating a persistent data
structure that might be a set or might
be a list it'll probably use a advanced
tree of some kind underneath the covers
with and the tree will have fingers of a
raised inside it for efficiency reasons
and so on so there's some really smart
people doing things well the reason why
I'm just raising this is that a lot of
people start using these things and then
do something that they think is a very
very simple operation and not observe
the kind of performance that they might
expect so you don't need to worry about
the complex things that are happening
underneath the covers and over time the
sum of the inefficiencies will go away
but just be aware that when you start
using these there is some some magic
that's going on and you you might think
you're doing an innocent thing like
adding one node into a tree that might
cause your tree to almost be caught the
entire tree you might be a very large
tree might have to get copied almost
entirely okay so let's get on to GP so
even when you're using GPS there's times
when you'll want to use these sorts of
data structures and persistent data
structures is one one that would be
quite useful so we're going to just look
at the parallel collections part of this
site graph you now the first thing on
the left so first of all this is just
I'm going to take the numbers 12 30
that's my massive data that I want to
work on and I'm going to square all
those numbers and then find all the ones
that happen to match the regular pattern
with the one at the front so basically
if I did do the two string of a number
in it the first character in that two
string would be a one they're the ones I
want to match up against so there's all
the numbers that start with one so then
my one starters so this is just normal
groovy there's no no parallelism going
on at this point so I can just go one
starters max is 196 one style is that
some is 747 and that's all my one
starters does that make sense yep so
there's no parallelism there if we
wanted to introduce jeepers to this
and make it concurrent we added an
import to get a with pool statement
here's our with pool and what we did was
changed our collect find all macs and
some to have the word parallel after
them okay otherwise it didn't change now
this will pick a default pool there's
options we'll see you later on for
choosing a pool size and so on but this
will automatically create a threat of
pool so that you won't have to worry
about if you've got if you're numb if
your array he was bigger than 30 you had
a million numbers you don't have to
worry about trying to create a million
threads and so on there's a pool there
that manages all that and it'll go ahead
and do those things in parallel making
use of all your cause so fairly easy to
do yeah so when this is extremely useful
if when you when you've got a whole
bunch of our test cases that you might
be firing you can run those tests
concurrently if you've got our system
that's meant to be bombarded in the
concurrent fashion like a website um ok
so now well this does this work
everywhere no so what what what's
important about this one if you're
trying to think think of the different
problems that you might have to have to
be working on is that each each of these
operations that I was doing or
independent so I squared 1 then I
squared 2 then I squared three and so on
I didn't have to wait till the result of
the previous one then add one or
whatever so there's no dependencies
between the the operations here so I've
got parallel data a single operation
across all the data yep so if I was
doing a factorial I'd have a bit of a
problem now I'm going to hopefully I'll
hopefully a speed up and get through
some of this material I'll show you a
one case study at the end which shows
you if you if you've got a problem that
doesn't look as if it's got independent
operations how to work through and turn
it into something that can be paralyzed
we'll get to that
later now on the other thing is that
inside these operations here you should
not be using any non thread-safe code so
you'll see I'm only doing simple stuff
so it's it's basically the kind of stuff
you'd get in simple functions and that
sort of thing you should be using
strictly you shouldn't be even be doing
like print lines in in these statements
because that's sort of got a side effect
that if the different threads are all
writing to that stream at the same time
that could be interleaving you'll see in
a couple of my slides I probably sneak
in a few little print lines here and
there just so you can see what's going
on it's usually safe to do a print
lining in one of your threads or in one
of your actors or one of you but we'll
wait and see whether over being a little
bit naughty in a couple of them okay so
um if you didn't like having to change
all the method name so clicked became
click parallel find all find all
parallel and so on you can just use a
little bit of a meta programming so if
you use a make concurrent then it allows
you to keep the code for all the other
stuff the same okay there's a way to do
a few different flavors to do that
ok
so when you're using the art this is
back on two parallel arrays yeah I've
got some more slides coming up that will
explain some of the concepts that I'm
going to talk about so it so basically
this up there's a whole lot of our
operations that can be done here you can
see the parallel versions and the non
parallel versions okay so a couple of
these are lazy so for if I go and say is
if I using any it'll fire off a whole
lot of threads as soon as the first
thread comes back that's got the answer
that you know if you're doing if you
trying to see that everything's positive
as soon as that you get a negative it'll
it'll stop if you're trying to get a
negative a suit if you're doing an end
or any depending on which one you're
doing every or any it'll stop as soon as
it can tell you what the result is okay
so um there's a slight variation one of
the things that's come I think it's in
it's in Java 7 is parallel arrays did it
make it there was a still in a separate
char karamo um that nothing is bundled
here um so parallel arrays is is that
one of the other features like I think's
in Java 17 that does some really neat
things under the covers in terms of
these operations I'll show you a little
pretty picture I think it's probably
Dirk who created that picture as well
we'll see if i use a parallel it turns
my list here my collection into a
parallel array and then i can use a
whole range of operators like like we
had before we had collect and find all
it uses the more traditional names once
I've got parallel arrays here so i can
use map and filter okay so there's the
same numbers we had before I've got max
I've got some I've got reduced and so on
so they're all the methods there for
parallel arrays now if you're wondering
what's the difference between these
parallel rays parallel rays I've got
some really neat features underneath the
covers in terms of how they're
implemented they use there's some smart
fork join stuff and other things that
come into play when you're using those
and when we were using our original
operators that each parallel and so I've
clicked parallel and so on find all
parallel as we were doing the hundred
numbers and it was squaring them all we
do all 100 numbers square them all and
and sync everything back up then I'd add
one or whatever then I'd find the ones
that start with one whatever it is I'm
doing and so you'd have concurrency all
happening here and and then it would
wait for all of the hundred numbers to
be finished and depending on how that
gets chopped up you'll get some wasted
cpu usage at some point while it's it's
it's letting things finish once i use
the parallel arrays it can actually walk
along a number of these steps without
relinquishing that the thread that it's
on and can be a very very efficient use
of all your cpu's so you can have map
filters and reduces all sort of
happening fully utilizing all of the
CPUs that are all the cause you have
available and you get some result
conceptually there's not much
distinction between the two but there's
some slight differences in what's going
on underneath the covers okay so I want
to flip over now to one of the other
technologies and it'll become very
obvious shortly which one it is i'm
going to be talking about but before i
mention which one it is I've got a
little problem here I've got four
functions and what we've got five
calculations or what one variable is
getting set there or on values getting
set then I've got four calculations and
then I want to check the result with
some number so perhaps I've got a four
core cpu and I've got four functions
there that I want to execute so I just
hit all four functions with one CPU does
that sound like a good thing to do and
it'll come
with my result really fast what what do
people think can you read it from the
back its first functions taking a is the
parameter gives me one of my results the
second one's taking a as well the third
one's taking see where does that come
from
hmm yeah this dependencies between my
data here isn't there so yeah we've got
a little graph so in I think I've got
four functions but because the
dependencies I'll probably maybe only
gonna be using to cause this is because
I'm never going to have more than two
things available right so this is the
kind of thing that I've got here and
okay well I can one of the things that
jeepers supports is asynchronous
closures asynchronous functions so yes I
can go and solve that using asynchronous
function so I can fire things off and we
could support futures so we can go and
you know it once we have our results
everything will filter down through this
chain and and and it's relatively easy
to do the co doesn't look too bad but
there might be a slightly smarter ways
to do that and that's using data flows
so with data flows although I
declaratively express the relationships
between my inputs and my outputs so here
we just say that I've got some task
where I'm taking ain i'm using f1 and
producing be and so on so it's the same
things i had before but they're now just
tasks and in fact i can swap the order
of these around in any order they're
just declarations it's a decorative
statement of the relationship between
the inputs and the outputs it doesn't
matter which way I do it then hmm
kind of you so it's in some ways I've
raised the abstraction before the order
in which I had these statements was
important if i move the order of these
two around there when i tried to invoke
the lady yet they'll either i'll either
not believe they're not compile so
depending on your language or it'll get
some null value or some something that
hasn't been finished yet the lights were
starting to flicker again but they were
all the lights went off up and down a
bit before but no okay yeah so we've
raised the level abstraction so data
files are really really powerful that
technique for doing that and very very
handy when you're writing tests because
the results will you know will just flow
when they're ready and you just just
describe the relationship between
everything once once your results are
done you'll have the values that you
want okay so this is just a few more
examples here again I'm not trying to
get into the nitty-gritty of the
technologies today it's more just a
taster so you can you can easily dive
into the tutorials or read the grooving
action book or whatever and you'll see a
lot more of this stuff
it
um so it depends what you mean by block
but yet so it in a data flow there's
there's no thread that's blocking
waiting for things in some sense there's
just a whole range of things that can
occur when they're available to occur
they will so it's you know like when we
saw the asynchronous underneath the
covers it's effectively like the
asynchronous stuff here so there's like
a future that's available once that's it
it'll-it'll it fire off now there's a
little bit here on looking at a few more
complex things so you can you can have
graphs and things in your tree want to
be a bit kev you can do things that you
don't want to do but i won't go into the
detail if you find yourself trying to
write a for loop in a data flow you're
doing the wrong thing so you'd
restructure that to you use a steady
flow stream so there's a slide that sort
of shows you that you're doing the wrong
thing here and here's now here's a nice
stream so in this case here we have a
stream of data coming in and the results
coming out I won't go through all of the
specifics there but again it's a very
very declarative expression of what it
is that I've got so basically the
streams are labels for the for the flows
that are going through here and you'll
see that the operators are all very
declarative okay
there's some nice properties of data
flows okay there are inherently safe and
robust so unless you go and do some
weird and wacky stuff like have a random
number generator inside your code or
something like that data flows are going
to be very very repeatable data
structures so if you write them so
here's a deadlock if I say flow X is
dependent on on flow I and flow wise
depend on flow x that'll deadlock but it
always deadlock okay so i can write test
Suites and know if those test Suites
pass then I've got code that's doing the
right thing there's very also very
static analysis libraries that let you
they look for different kind of
deadlocks so this is in this simple case
here would be it's obvious it's trivial
as a deadlock there but in complicated
cases it may not be so easy to tell then
there are analysis tools around that can
analyze this stuff the I've only I've
only ever there's none that
automatically work on groovy code at the
moment I can take some groovy code and
generate a data file and feed it through
one of these tools so it's sort of a
researching tool at this point after
another open source project at some
point in the future okay so there's
there's some I've been showing you
little the little examples that I'm
showing you you've got a little mini dsl
here for writing concurrency the when I
was showing you the with pool and these
task operators and so on the good news
is for most of these operators that
there's Java classes underneath the
covers and if you want to go and use all
of this stuff from from Java you can get
us go use the classes so if you've ever
used like the server class in a web
server you can go use the actor class
the data flow class that other things
that I'm talking about and use most of
this stuff from from Java you just won't
get the little the pretty d SLE looking
language that we've got here okay so go
over to actors so again actors I find to
be invaluable in some scenarios but much
less than you'd expect if you're
listening to a lot of the hype that
comes
that's come out from some of the other
languages I would want to be without
them but yeah a lot of the other ones
that we've seen before are better bang
for buck in terms of you'll come up with
a simplest solution that is much much
reduced chances of anything going wrong
if you use something that we've
discussed up till now but the things
we've discussed up to now only solve a
certain range of problems okay so um if
you if you use actors that lets you have
little slabs of code that talk to one
another of our messages there's a few
different flavors of actors some that
don't have any state and some that have
minimal state I won't go into all the
specifics today but yeah it's fairly
well understood dumb set of guidelines
for what you need to follow okay the
idea of actors isn't anything new the
erlang and scholar or two languages
quite now which are very very popular
that are heavily utilize our actors
throughout them it's all based on much
much earlier work and there's another
don't think I've got much more on csps
there's a communicating sequential
processes which is sort of the closure
way of communicating between these
things that's also supported by by
jeepers there's not a lot of for many of
the solutions that we do there's not a
huge distinction between those two ok
the the network graph of the things that
are talking to one another is fixed in a
CSP solution
okay so one actors are a way in which
you can compartmentalize your system
into little classes that talk to one
other only viral messages so they're not
sharing any state now that they're just
there's a class underneath of an actor
class and it's just got your normal
method so there's nothing magical in
there I'm going to I've got examples
that show a few of the different
variants of actors but i'll probably
just pours on the the dsl you flavored
one so if you want and especially if you
will from Java I'll quickly go through
this one as well if you can just go and
you extend the one of the actor classes
and there's a couple of different
variants that supporting the stateless
and non-state those things but I won't
go into all the details the main thing
is I create my class I'll have a non
message method that I put some logic
into okay this one here it's our voting
if you ever went to the script bowl
yesterday or you going to the emerging
language script Bowl you'd have to vote
here is some code here for voting it
might have some subtle biases in the
code I'm not sure if the language starts
with G it might get voted and other ones
might get er sorry the network's too
busy you can't talk right now but I'm
sure there's no bias in there it's just
sorry is there money in that can I
collect colorful I know ok so here we
are we basically start our actor so
there's now an actor there that we can
send messages to we start sending
messages to it it happens to support
both single strings or a list of strings
again we just feed them into this
processing thing and we can stop it and
join and again I'm using some print
lines which is a little bit more digits
of localized to one spot though which is
sort of probably going to work ok for us
here we are where it will have print
those messages ok so I better rewrite
that code here's one that's definitely
not biased this is using the dsl flavor
it happens to be checking if it ends in
Y but i'm sure that's just a coincidence
thing so here we are where we've got
some languages we create an actor and
for each of our languages here we're
going to send them off to our another
actor which is our votes which is up
here reacting so this this is a an actor
that lives forever in its current form
and whenever it receives a message it
just returns a string so it's just in
its returning back to its origin the the
string that it sends back to the actor
that centered a message one of those two
strings so what we do is we fire off all
of these messages off to the actor and
we loop around now waiting for things to
come back and once they come back we
print them out once we've got back three
messages we'll just stop it selves yeah
ok then we'll stop our votes that was
looping around forever and wait till the
world finished ok so I better rewrite
that one this one definitely couldn't be
biased that was checking for the length
of six but i'm sure that's got nothing
to nothing about bias in there so this
again is using another slightly
different API and again it you probably
only odd typically only used as if i was
integrating in front from java but
there's a few nuances there so again we
can feed feed some different languages
in and get some results back ok so um
you can mix and match so I'm showing you
different approaches but obviously you
can mix and match some of these
different approaches so I can have one
section of my code that's using data
flows to calculate stuff and when it
gets some result it can use an actor to
go and talk to some other part of the
system okay i want to show you sir
agents very quickly okay so let's shrink
this part down so I've got I've just got
a random a random object here that it's
going to pick a number between nine and
sleep for that many milliseconds okay
why is that going to be important we'll
see in just a tick I've got a string
that I'm going to append stuff too what
am I going to append I'm just going to
take all the letters from A to Z and for
each of those letters i'm going to start
far off a thread i'm going to randomly
wait for those few milliseconds we saw
before and then I'm just going to append
the letter that I had on to that string
so the string I'm going to create a new
string from the original string and
adding a letter and then put that back
the reference to the original result
reference and do that for each of the
letters and this is all commented out so
ignore that bit for now then I'll do a
poor man's join basically if I sleep for
a hundred milliseconds all those other
will be they will be finished and I'll
print out the result and I'll print out
the size so when I run it I'm not
getting all my 26 letters right so
there's a race condition here each of my
threads is all they're taking the
original string getting their letter
appending them and then assigning it
back and they're doing that all
concurrently so if any of those to
happen to be doing it at the same time
they'll both do a read at the same time
two different ones will add letters and
then they'll both plump them down Oh
plonking over
one another okay so I've purposely made
this as an unsafe example so how do we
use agents to make this safe we import
the agent class we create ourselves an
agent that handles strings will get rid
of our unsafe variant we still do this
red dot starter as we did before we'll
do our random delay what we do now is we
take our unsafe bit of code let's make
it the same as what we saw so we just
take our original value that the agents
taken care of for us add the letter and
we tell the agent to update the value
used am IntelliJ keystroke inside the
console didn't didn't do anything um so
the agent now is it was ways that we're
sending sending slabs of code for the
the business object that we want the
agent to take care of for us so normally
we'd have to put synchronized blocks or
something around this and pretend lots
of potential for things to go wrong so
but what we're doing is we send the code
over to the agent and they did handle it
there's a few different variants I've
used the same method here but there's a
few different flavors if you see
something that looks slightly different
to this it's a few ways we could have
done it we can actually just send values
as well and there's ways if there's
exceptions going on in the little
snippet of code we send off there's ways
to collect that and so on I'll just show
you the simple case so that's what we do
when we're finished I'll still do the
poor man's joined for now we get the the
agents got the result we we can there's
a few different flavors for this as well
for asynchronous and so forth versions
this this will wait and get the result
once all of the actions that we've
passed on the agent of being performed
this will return the the value that is
now taken care of for us and we can
print that out and it's 26 each time you
can see the the order of the characters
is changing but all of them are getting
through so it's all fully synchronized
okay now
that's what we've got here okay you
might have wondered why did this poor
man's join I was just trying to keep the
noise out of out of the slide what you'd
probably do rather than doing a to z
teach what we're just what I showed what
you do is you'd collect all the threads
so so here I'm going to take my 26
letters do a collect which is like a map
convert each of the letters into a
thread that appends the letter and now
I've got 26 threads and we just drawn
all the threads and we do what we did
before so that's the nicer way to do it
but I was trying to keep some of the
noise off the earlier slide so make
sense okay so there's a few things I
haven't told you about agents there's
some a few different smart things you
can do you can have V Tobel actions that
you send and validation sort of steps
and as I said you can find out if errors
occurred and so on so there's a fair bit
of smarts that's going on but does that
seem like a really neat way to do some
of you can counter stuff you hear you
just say yeah I don't know how to deal
with concurrency you go and do it for me
yes there's no esteem in in that one
okay was it or was it always an actor we
know so it's it's it's borrowing off the
ideas that are in the closure agent
things I didn't think the closure one
had an act of it but anyway ought to
look into them okay um so yeah it's a
very very neat thing and yet not very
hard to use it all so there is software
transactional memory I don't really have
time today to go into the details again
if you've if you've used closure it's
it's a very very powerful mechanism that
you can potentially using that language
the when it whenever I've thought STM is
going to be so so software transactional
memory it's um if you've ever done
transactions into a database and you
know you can roll back the database it's
that same kind of concept but in memory
okay so you try to perform a bunch of
operations you're doing it in memory and
it in some cases it's like an optimistic
sort of sort of things that you do and
if something goes wrong and says I
shouldn't have actually let you change
something it can roll it back okay and
it's it's it's a technique that's got a
lot of power behind it but whenever I've
actually tried to use it in large-scale
scenarios I tend to hit its limitations
fairly early now I presume the closure
people have done more to solve this but
the current implementations on on the
JVM are um still seem to have
scalability problems when I when I've
used it but I don't turn you off it
because the I'm sure over time those
sorts of issues will get addressed but
yeah that's that's the concept behind
this one so there's you can just squeeze
through the code here if you if you want
it's trying to do a transfer of funds if
you don't have enough funds it'll roll
it back basically what it's going to do
okay so the final thing that I wanted to
quickly go through our there's there's
how easy it is to use this sort of stuff
in the test cases so I'll have a
customer that I'll have test code that
looks like this but they'll be running
each of the test cases here there's only
four but i'll be running them
sequentially you just do a with pool
around the whole thing and change on
each to an each parallel and now their
test suite will be running in parallel
so it's trivial to get customers using
the store stuff um the final thing I
want to do is so I've kind of showing
you all these techniques and I've said
yeah go go use the data parallelism I'll
go use data flow or go whatever um and I
said of course it doesn't work if you've
got into interdependencies in between
your different pieces and so on well it
turns out what you really need to do is
yeah even if you've got a scenario where
you think you've got dependencies
between your different steps in your in
your elgon you can often just tweak it
refactor it very very slightly to have
slightly different properties and you
can make things that look like this
sequential
can't be made parallel you can turn them
into parallel things now on this is
stolen directly from guy steals train
ship talk from a few years ago where he
showed fortress so some of you heard
fortress mentioned in some of the other
talks it's a it's unfortunately an hour
dead language there's the funding that
was supporting its development from by
some I think was the the main people
that originally was withdrawn a couple
of years ago so I think it's I don't
even think it's been resurrected as an
open source thing at this stage Brittany
how it didn't it had some weird and
wacky symbols in it so you couldn't use
ASCII characters to encode it but you'd
get some very very nice properties in
terms of how it could do concurrency and
some stuff automatically I wat trying to
give you a tutorial on fortress today
though so let's just for size sufficient
to say that there's a nice solution
there so what I want to do is do the
same sort of problem in in groovy I'm
not going to go through today the the
entire problem for you but I'm just
going to pick out a couple of key points
which is that the the the reason behind
this particular example if you're
interesting example the full source
codes in these slides is on github you
can go and work through it yourself but
what were the problem we're trying to
solve here and for something that's only
a small number of characters it's it's
almost it'll actually be a performance
decrease to paralyze it given this size
of this thing but just imagine it was a
bigger scale but for the purposes of
fitting it all on one slide we've shrunk
it down to something fairly trivial so
what we're trying to do is find we're
going to try to count the number of
words there's in some arbitrary text
right so this is the kind of big data
problem that Google is trying to do
searching and so on so they've got huge
slabs of data they're trying to split it
into the words so they can do their key
indexing on all the words and that's all
stuff so if you think through well
what's involved in counting a word
surely it's really trivial to make this
parallel well if I've got a Sabbath text
somewhere out of the mid
all of one of these hard drives you know
gigs and gigs of data that I've got
there and I've been told I you go start
in the middle you know you're one of
1,000,000 cause you go start in the
middle and start counting the words
what's the first thing I do well I
really don't know whether or not the you
know if I'm segment number 1 million
well what happened with a segment number
99 99 99 because did it finish on a
space or is it halfway through a word or
was it just you know if I don't know
what happened in the previous one how am
I going to know how to start and if I
don't know how to start well you know
i'm not sure if i'm halfway through a
word or do i start counting at one or do
i have to wait till i find out how many
were up to now and then do I start well
it seems like you've got a problem where
each each one depends on the one before
it looks like it's an inherently
sequential problem but all you need to
do is twist that problem around and say
oh well eventually I'm going to hit a
space once i hit a space I know that I
can start counting for real and all I
need to do is remember what remember
some boundary condition up to that space
so what I'm going to do is do all the
work of candy in the middle and then
have two boundaries one on each side
where I'll remember some little
artifacts about the conditions on the
either side and once you do that it
turns out that you can then paralyze the
whole thing and then introduce another
little tidy up phase a reducing phase
where I have to take two things that are
side by side look at the the you know
the trailing conditions on one of them
and the the preconditions on the other
and do a bit of tidy up I did the
left-hand one start a word ok and the
right-hand one finished it ok i'll add
one word or did each one both finish on
a word so maybe there's nothing to do or
maybe you have to add to or whatever it
is depending on how it how it lined up
so that's that's what's involved and if
you want to sort of look at it
graphically it looks like it's a
sequential problem so I've gotta wait
for that looks like I've got to wait for
the previous one before I can do sort of
mine but
so there's there's an example so so here
and these are the different cases so
here we actually started on a new word
boundary but we don't know that what
we've got to do is remember that
boundary and if we convert the problem 2
over 2 now that we basically split it up
into chunks and segments then we can
turn it into this okay and so what we do
is I'll phase and if we kind of what you
want to think through what have we
actually done here there's our trunks
and our segments so basically you'll get
times you've got some of you may or may
not need to do something with so
basically you'll yeah you'll have these
segments with left and right little
things to tidy up and this is some code
so basically we've created a little
domain so this is a domain and of label
things + + 0 here and if you want to
think through what properties of this
system need to need to be applied
basically I need your social utility so
that when I'm doing these different
chunks it doesn't matter what order I do
them in and I need some zero element so
the thing is if I go back to this craft
when I saw a lot of the times when if I
on the first one as I'm sort of moving
down my tree doing stuff i need to zero
on the end there was always i've got a
zero ability to some these different
pieces then i can solve this problem and
that's if you've heard of monoi not mine
add but monoid that's just any set of
operations so in our case our both our
trunk class in our segment class are
both monoidal they both have this
property they've got the pluses the
operator we've got and it happens to be
associative because it doesn't matter
the order in which i calculate these
things i'll be able to add them together
and it'll still work and 0 I've got a
zero segment so if I need to put a
segment on other side or a chunk on
either side I've got 20 as well and I've
then got a flattened which is the tidy
up bit so this tidy up people then tidy
up all the different pieces and it
basically pieces together the the
different parts of my system so this
gives you a technique that you can do
you know if you don't just have to see
every arbitrary problem and solve it you
take your problem put it into this form
and you'll know it will be solved so you
just lead yourself down until you've got
that zero and you've got
your associative ed and you'll have a
solved problem okay and if you want
those versions the solutions to that
using straight boring old concurrent
hash maps using parallel arrays using
data flow using fork drawing etc etc
okay that's my talk thanks for answer
think the doors are opening to tell me
that I've used up all of my allocated
time happy to take any short questions
I'll just just come and see me I'll take
questions are after this thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>