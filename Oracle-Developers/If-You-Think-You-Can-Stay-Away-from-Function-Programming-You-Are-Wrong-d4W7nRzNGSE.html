<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>If You Think You Can Stay Away from Function Programming, You Are Wrong | Coder Coacher - Coaching Coders</title><meta content="If You Think You Can Stay Away from Function Programming, You Are Wrong - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>If You Think You Can Stay Away from Function Programming, You Are Wrong</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/d4W7nRzNGSE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi guys thank you for coming my name is
Mario Fusco i'm from italy i work for a
debt in particular i work on drools the
jboss rule engine anyway today I'm here
to speak about functional programming of
course in Java but yeah we had lots of
great lambda tools during the Java one
the biggest part of them explained it
that the how you used it the machinery
of using the lambda the lambda
expression I would like to take a little
step back and also explain the why
because I'm still have the feeling that
not everybody is convinced that that it
is a great idea to introduce lamb
despression in Java and I so I want to
give a some more theoretical view of
functional programming but also to give
some very very practical advice in how
to use it and how to leverage it
especially for parallel programming so
ok I think all of you know the molds
love lo and yeah the fact is that every
two years or even a every 18 months the
number of transistors are now on our
secrets on our chips doubles the fact is
that in the last year's let's say
starting from the mid-2000s this number
is doubling because we are doubling the
number of the course on on our chips and
I think that the biggest part of the
program we weave right there are not
suitable to to to leverage this parallel
power and the net effect of this is that
now every two years we are doubling
the number of the idle transistor on on
our machine and and the so the idea is
to try to do to fix it fix this issue I
think there have been two trends two
separate trends in in the recent history
of and and even not so recent history of
languages and language decide the first
trend is that the biggest part of
languages started from the the hardware
for the cheap for the machine registry
or whatever and the added obstruction on
them but almost uh never trade in
performance for for for purity I mean
never sacrifice performance for for the
purity of the language for the beauty of
the language okay and for example this
is evident the in Java where we have
primitive for for a very good reason or
at least what it was a very good reason
in 1995 and of course we decided the
language designer decided to sacrifice
the beauty up a little bit of the beauty
of Java in the name of the performance
and they and this makes sense the the
second trend is that other languages
started from the theory the mathematic
the lambda calculi the category theory
and the sub tract obstruction but in
this case almost never sacrifice the
beauty of the language in the name of
the performance okay and and for this
reason those great languages are known
to be note that performance and and and
and it is true or a place this is true
or on a single core machine the fact is
that
having multi-core machine we are
realizing that many of the principle
that are in those language are our good
principal and at the same time where we
have a very good very good construct in
the imperative languages so probably we
we don't want to get rid of them and
this is the reason why some new hybrid
languages have been decided namely
scholar F sharp and I think that that
Java is is moving slowly in this
direction I'd in a deal and lambda
expression to the language okay so this
is I think the historical historical
frame but in a particular in parallel
programming another load that is
important and I think you also know this
is the under slow saying that the speed
up that we can have on of a multi-core
processor by parallel it's I
parallelizing that the program is is
bound to the to the sequential part of
the program so we have to strive to
reduce the sequential part of the
program and make it as small as possible
okay and this is good both for
concurrency and for parallelism okay I
try to put in two pictures what what is
the difference between concurrency and
parallelism it is not always clear I
op-ed it is clear with those with those
images but anyway both both these these
things are aqua are quite odd are very
hard and what circles of the problem
Einstein once said that insanity is
doing the same thing over and over again
and expecting different results
problem is this is exactly what it
happens in using using the thread while
we're having rest condition for example
having not well synchronized the program
so the cause II of non-determinism is is
the sum of mutable state and parallel
processing and for this reason we have
to throw away one of the two and
honestly I don't want to throw away the
parallel processing I want it so my
decision is a straw away mutable state
and go through functional programming so
this was the cause of the problem and
and and all of you I think knows the
effects that are rest condition
starvation deadlock live locks and so on
and yeah it's very very difficult to
reason on all of them it's even harder
to debug them if you tried so we want to
try something different and the native
java concord NC model is buster is based
on thread that you have to synchronize
with semaphore and will locks and that
this is just often plain evil sometimes
it's unnecessary pain but the most
important thing is that always before it
is in my opinion always the wrong
default we have many concurrency model
and and the one that java gives us by
default is the most difficult the last
effective one okay and indeed we have
the java concurrency model and we have
other models that probably the other
concurrency model that probably we would
like to explore that are that are the
actors model
and endo and the functional programming
so let's explore those three we with a
very a very a very simple example okay
so so let's suppose that I want to sum
up the daj so of all the attentions to
two of this torque okay so what we do in
Java is that we have a blackboard and
everybody is going to sum up the age on
this blackboard so what every of you has
to do is to come here create a line and
use the blackboard the blackboard once a
time so we have to to avoid race
condition and and cancel the deal zone
sum up the your age and end write a new
some okay that is why what I'm doing
here in a synchronized block okay so
this is the Java model let's let's see
another example did the actor model the
actor model is ok I can have a mutable
state but this medieval said is not
shared I'm the owner of the of D of the
state and I'm on the only one allowed to
to change it ok so what what you do to
what we have to do to have the sum of
our age is that everybody you send me a
message gives me a piece of paper will
be their age and I do do some up for
everybody okay this is the this is the
reactor model okay i'm here i'm using
the acha acha class is a connotation
that is a framework rittany scala but
that can allows you to do to use actor
salts also in in java if you want the
third model is we don't have a mutable
state that is the functional model so
what we do to sum up our edges is that i
give our blank piece of paper to him
yves roch the
is age there and then I pass away that
the piece of paper and everybody has to
throw away destroy the old piece of
paper and create a new one adding usage
okay it is totally different there is
not a mutable state we are destroying
the estate and create and you are new
immutable one okay so these are d'être
the three different different model we
have aidan and we can put them on a
graph a very simple graph on this axis
ax I have the the fact that estate is
shared or are or not and on the others
on the other part i have did the the
fact that that e the state is mutable or
not so what we say what we have for what
i said is that we have the the actors
model year we have the functional
programming model year and we have the
threads model year this clear and what
actually happens is that the green area
is the area where i would like to stay
because the problem arises when when
when we have shared mutable state so
either I about the shared state or I
avoid the mutable state having both is
the cause of the non determinism that is
where unfortunately the threads model
our lives okay so the idea is that okay
I i want to start up to view in parallel
the object oriented model and the
functional model and an let's underline
the domain differences so Michael
feeders say that that the object
oriented programming makes code
understandable by encapsulating movie
parts while while functional
tries to minimizing the moving parts
this is the the most important
difference and I wanted to underline
this difference with another very simple
very simple example so I have a very
simple story that i want to to tell
under two different points of view the
the object-oriented points of view and
the functional one so this is the the
object-oriented way of telling my story
and my story is just a cut a cat catches
a bird and then and then the cat eat it
and so I have the bird class I have a
cut class that that can eventually have
a catch and as a flag saying if the cut
is full or not ok so the histories I
create a new cut and then you build and
then the cat capture the beard and then
eat it ok so when the cat captured the
build the birdies is is is in the state
of the cat and when it the catch is is
is set to null and finally the cat is
full ok so this is the object-oriented
way to tell my story let's see our I I
can tell it in functional language I'm
not saying you should do this ok I'm
bringing the extreme of the functional
programming to is extreme consequences
ok I'm not saying you should do what
what you said before or shoe you should
this you have to probably mix the two
style you have to Fink which is the best
fit for the problem at end but i want to
show you the two the two extreme all of
this the black and white but there is a
lot of gray in e in the middle okay so
what's the functional way
doing this okay i am anna once again a
bird class but now i have three flavor
of of cat class I have a plane cat I get
with a catch and a full kit okay and
when the cut captured the beat it
becomes a a cat with a catch okay and
when the cat with a catch eat it it
becomes a full cat pretty easy okay and
and what's where is my story what is my
story my story is this one and it's just
the composition of the 22 of the two sub
stories right okay so the first story is
the capturing that the second story is
the eating and I'm composing it and this
is my story okay and after that the way
i play my story is just apply to the
story a cat and a bird okay and any
question okay and which are the main
difference is he of course him with a
beetle immutability I'm destroying the
cat and creating arcade with a catch
okay I already spoke about this the
functional programming give emphasis to
two verbs instead of names this is quite
typical and this is the most interesting
part in my opinion so let's let's take a
step back how many tests you have to
write here you have to test that you are
calling it with aniket that actually as
a capture that the bird is not null that
after the cat
as eating the day is full and then the
catch is now again you have to to write
some tests here okay to be sure that
that that it is confirmed to to your
expectation and how many tests do you
have to write here 00 because the fact
that is that this piece of code compiles
is the biggest insurance that it is
correct because you cannot eat you
cannot invoke it on on a cat with other
catch okay and the rest and the result
of the story is a full catch is on an
object of type full catch so you don't
have to test this state it is in his
type okay makes sense so let's let's
give another another quite new no known
example the difference between internal
versus external iteration okay okay I
think you already heard of it we did the
old way of using collection manipulating
collection is iterating it from the
external so I I have a list of employees
there there and I want to give a three
percent rise to all of them and I do
this this for loop okay and oh what's
wrong with this mmm apparently nothing
but only because we are used to to see
this stuff this stuff remembers me what
my two years old daughter does when she
has to put away your toys I'm not able
to tell her to tell her just put away
all of your toys it goes it goes more or
less this way and Sophia what's on the
ground the ball okay take the ball put
it put it in a box okay and what else
it's on the ground the dole okay take
the doll and put it in the box and what
it's on the ground the car okay do the
same with the car and so on okay and
this is what exactly what what we are
doing here it is semantically wrong ok
big it also wrong with it because this
is inherently cereal and and and the
client has to do my job I have to do my
job then I want data would like to do
when I asked to Sofia to to put away
your toys okay and also NASA troops are
poorly readable I think probably is not
located the case of these loops but
probably if you have a very deeply
nested loop with the widow we with the
with the if condition probably you see
that it is not that readable okay so
what we do what we do in Java 8 is
iterate the collection internally okay
with a lambda expression but this is not
only a syntactic change is not only
syntactic sugar okay because uh because
if I wouldn't have to tell to my
daughter take these testes and dictate
my daughter could outer autonomously
decide to to take the car with one end
and take the doll with the other end and
put them away together they could
autonomously decide to do pará to
parallel processing two items okay or
they could she could autonomously decide
to to first take the toys that are that
are closer to the box and then and then
dddd dddd the further one so she could
do a kind of instruction reordering okay
without without without me having safety
take this and they and take that one and
so on okay so it is known not only a
syntactic sugar what you have to gain
is that in this way the Libra the
library is in control so you are
delegating to the library the all the
optimization you can do okay so and and
it's more readable because you are
you're telling the hull not the wood
okay and then you have you have also the
dread abilities increased by the fluent
the fluent api of the of the of the
stream class for example okay and and
moreover using musing lambda expression
the client has the opportunity to pass
not only data to a method invocation but
also behavior okay and and this allows
you to rise the obstruction of your code
and and so to have more more powerful
and more express for expressive api's
and yeah a clear example of this is the
stream where where as I was saying we
have wave dis fluent interface and yeah
that is encouraged by by by the lambda
expression okay the stream divides the
operation in in intermediate and
terminal so you do some intermediate
open operation like filter I'm up here
and then you do this for each but and
there are other important thing is that
it is lazy in nature but the most
important thing is that is that the
internal iteration gives you the
parallel is for free for free and think
about what what you have to do to
achieve the same result in using an
imperative style okay so question is is
that such a finger free lunch and do can
can we still have free lunches because I
think we have we had a lot of them in
the past right I starting I started this
work about 20 years ago so early
nineties and between early 90s and and
and mid two thousand we had lots of free
lunches because if our programs weren't
fast enough the only thing we had to do
is just sit up and wait sit up and wait
up one years and the next year they will
be fast enough right so this is a free
lunch for me but but it is not happening
the same so probably yes we can every
lunch but now we are not increasing the
speed of the of the clock we are
increasing the number of course so we
need Forks functional forks and knives
to it is free lunch make sense so let's
see what is ok we we talked about
functional programming but what is a
functional programming a functional
program is a program that is made of
just pure functions ok so a pure
function the most characteristic think
of a pure function is that it doesn't
have side effects so you are not allowed
to do this stuff none of them ok you
cannot or actually ok of course we need
we need to to accept some input and
print some output if the DA the purpose
of the program you are writing is not
only is not only make the CP water you
need some input and do you have to
produce some output but you can avoid
you can totally avoid some of these side
effects and you can defer the other ok
so you shouldn't they assign a variable
you should modify the structure in place
and if this is very important in my
opinion you shouldn't throw exception
never ok there are there are others ways
to signal that that emitted cake can
returning out in an option Anini in an
exceptional way and and this should be
in the sand in the signature it should
be in the type return it ok for example
we have with we are starting having this
in Java it with the optional which we
win let me make up a very simple example
if you if we try to convert a string to
an integral very likely we will get a
number format exception if if we cannot
that API is wrong in my opinion we are
trying to convert a string in an
integral probably that operation can be
done probably can't and that means that
the data data metered should return an
integer it shall return an optional of
an integral ok so should be an optional
wrapping the right indego if it could do
the conversion otherwise should be an
empty optional and what is because
because in this way I can still working
on the value return it by by that method
without having to to do any throw and if
NC trotro try catch but even better in
this way I don't have side effect so for
example I can catch the result ok we
will see this later so but but but
messages that functional programming is
not a restriction on how we can do it's
only a restriction on what we can do one
on how we we can we can arrive to
desired result
so a pure function what is up your
function yup you function is just
something that transforms our evaluation
a value be without doing anything else
nothing else okay it just goes
transforms a to be it takes some input
it gives you a now to put nothing else
and and this concept has been formalized
the world with what we call referential
transparency and what is referential
transparency an expression Issei to be
referential trespass transparent if all
programs if in all programs it can be
replaced with the result of evaluating
that expression without affecting the
behavior of the program okay and a
function is pure if for every value of
its domain it is referential transparent
okay so this is the theory but what is
meaning practice very simple okay so
let's compare how our string and string
builder behaves what's the difference
between string a string bigger the first
is is immutable the second is mutable
okay so what what I can do here is that
I ever won and there too that the
replacement of p with T in the industry
and I can also always replace I can
always replace the variable with the
corresponding expression and the result
will be always the same okay but try to
do the same with a string builder that
is mutable okay so this is my definition
of why and let's try to see what happens
if replace y with its definition year
and then year I will have this result
right so this is the difference between
between referential transparency and non
referential transparency this career
very simple and why do we want a
preferential transparency because under
a developer point of view it's easier to
reason about it given and any any
variable you can replace it with it with
expression it's because the that
expression that doesn't doesn't have any
side effect when it is evaluated so you
can just replace it in your mind this is
called the substitution model okay and
moreover there are no side effects so
that the effect of the evaluation that
that is the output produced by the
evaluation is purely local local and an
under a performance point of view we
also have something to gain because the
JVM odd spot is allowed to do lots of
optimization of course we don't have
shared data so we don't have we don't
have anything to synchronize okay and we
can also have memoization for free
moment memorization is more or less just
a fancy name of cashing in functional
programming so for example you have you
have this new omitted in the map
interface so if you have a very
expensive computational expensive
function you can memorize you can cash
its value in this way okay so what this
method does if there is the key it
returns there's the associated value if
there isn't that key it computes the
function with the key and then we store
it and and the the second time you will
ask the same key you will you will
already have the same result I'm cashing
the result nothing would okay but why I
can safely catch the result because
there is no set effect if I function in
some
ition throws an exception or if my
function in some condition change the
state of my program i will have said
effect so that function will do more
than than just producing an output and I
and I don't cash its resulta anymore
because my program need though that
additional side effect with ability okay
I talked a lot about meat ability but
III really wanted to make the concept
clear so this is what I think about mid
ability so parameter binding is about
assigns assigning names to things okay
and if you think about it with a bill by
mutating variable is assigning things to
name does it sound where I think it is
weird I think it is okay so what we want
is immutability so why do we want this
because because immutable object can be
saved shared among how many threads you
want without any guards without any
synchronization locks and whatever okay
and and and we can not only have we can
not only have immutable objects week we
can have our whole immutable data
structure okay so I wanted just to give
you a key our quickest example order an
immutable data structure structure isn't
and now it works so let's suppose I have
I have teased 33 okay and I want to add
a new value okay so what we normally do
with mutable the destruction is that I I
put two on the route and I I traverses
the tree on the left or on or on the rag
depending
if two is a lesser or greater than the
five and so on and then probably I will
get there and I will replace these did
this empty pointer with the to adapt
done and I'm done but the problem is
that I'm mutating the collection in
place so if i have a fireman object
having this collection in my state and I
desiccator through each you gotta tease
this collection and you add something to
this collection you are messing up my
state right so what you normally do is
to copy the world collection but it is
very very inefficient you we can do for
better for example we could do this okay
so when I want when I have to add these
two we we will just clone the nodes that
we traverse and then we we have at at
this point we will have we will have to
root the my object we will point to the
old to the old route you're you're a
piece of program we will point to the
new route and everybody will be happy
and we don't have the copy cost because
the biggest fart the biggest part of the
data are shared so they need to be copy
okay another important thing about about
a functional programming is modularity I
fink okay so know what I'm doing here
here I'm just saying that I have I have
took a player actually two player those
two players play a game and then I want
I a bar a meter to to to say with the
winner that that interns that the check
if the score of of p1 is is greater than
the one of me too and this case declare
p 1 the winner and you're a in the other
case the class p 2 so what's wrong with
this
the the wrong thing in this case is that
once again we are mixing a computation
with side effects and probably we don't
want this so what we will do it
separation the low computational logic
with a side effect so I want to split
this method in two parts so i will have
a a mug scar that just say who is the
winner but this is referential
transparent and and then i will have
just a meter that that will print who is
the winner and so the winner midi
admitted will combine the two and why
i'm also doing this because think about
if you have not only two players but a
list of player and you want to do to
find out which out is the winning one
which one is easy the winning one ok now
we can do this we can do just pass the
the the demitted reference to the todo
reduce to the reduce metered of the list
or of the stream if you want ok and i
cannot do the same here because I if I
pass this winner meter dear i will have
the side effect that it will print out
something for each comparison and i
don't want this
okay so what's the idea here the idea is
that i'll show you i showed you a soul
limitation before let me go there okay i
showed you some some limitation before
and I said that we want to avoid some on
them and we want to defer some other
okay and and we can do this actually by
decomposing by decomposing our our
program okay we can we can split our
meted and and isolate the one having
having side effects okay so the final
effect of this refactoring will be will
be to ever a functional call purely
functional core and isolate the side
effect at the beginning add on the end
and at the end of my program and this
pure functional core I eat it's the one
that tub completely satisfied the others
diem seldom does law there is no sub
inherently sequential partier okay okay
so okay let me wrap up so the this does
the suggestion oh I i well i would i
would like to give you our of course
strive for immutability we talked a lot
about this okay confine side effect by
refactoring by a refactoring a metered i
say as i told you avoid bought a
blocking good avoid synchronization
avoid locks because that that primitives
the wooden doll of you to leverage your
your multi-core processor okay and since
now you have i order functions in java
it you can sit control you can see
control of your list iteration 2 to the
Java API for should for sure they can do
far better than you and i'm a lazy
programming programmer so if somebody
can do the job at may place a map and
this is the principle ok so we also saw
what would referential transparency mean
and you can you can really leverage it
both again both because it's simplify
your life as developer because the
program's be called becomes become very
very clear ok and and also it allows
lots of optimization that you condone
there without referential transparency
ok and the final thing is that
functional programming allows you to
design more composable and reusable FBI
dude you did you see for example ow I I
composed my story before right I
composed to the credit the catch in part
with yet in part and I at the end i had
i had a story but just confused
composing the to sob story right but i'm
up a pragmatic person these are not
dogmas ok i told you i emphasize it do
this over the i would that get rid of it
or a please don't do this they're good
of advices i think but i am i am i am up
pragmatic person so for instance we have
with so we we have a different different
concurrency model so we can use all of
three okay we if you if you only have an
ember every problem resembles our nail
okay and some sometimes you need a
screwdriver
okay so ever as many to sell as possible
in in your in your toolbox so if you
know the thread model if you know the
functional one if you know the actor one
you can you can use always use the best
tool for the problem at the end and this
is the most important i think i know a
few developer that that are polyglot
programmer meaning that they do Ruby
they do java they do scholar and they do
all of three exactly in the same way
okay and i don't see the point okay i
don't see the point i think that it is
far more important to be a poly
paradigmatic programmer than a polyglot
one okay polyglot miss polyglot mismo is
important but because different
languages as DF different products not
because the language Percy okay and if
you have and if you have multiple para
dig in the same language you are done
you can you can use imperative
programming in Java with java it will um
despression you can start using
functional programming in Java I told
you I Medusa developer so if you want
you can use declarative programming I
mean once again once again you you have
many tools and and my suggestion is to
choice to choice among them wisely okay
one very small announcement ax I'm start
writing wewe with two friend the lambda
book I we started just a few weeks ago
so the menninger early access program of
the book will be will be aware i will be
out i think end of october so yeah there
are some very good lambda lambda
books outside and yeah probably we
wanted to put their also a different
point of view as i did i sat right to
did too did to do during the during my
talk my talk today okay I'm don't
question yeah yeah yeah okay what what
ok the question is how monads allows you
to avoid side effect how many of you
know what I'm on are these okay so so I
believe where we could take this this
question offline because I should start
explaining what I'm on a decent then
that doesn't seem a good idea okay
thanks yeah
okay yes yeah yeah of course why I was
doing it okay but the TTC's in the in
the spirit of what they say are be
pragmatic if you need to multi mutate
them here but yeah yeah okay okay okay
yes I was mutating them here yeah okay
so the question is uh okay it's
everything fine everything wonderful but
what about the garbage collector we are
brutalizing to the garbage collector
because we are creating lots and lots
and lots of object and this is he this
is in the spirit of what one of my first
slides ok this is in the spirit of these
slides we have different style and and
the imperative style pays more attention
to performance on a single core ok and
and the functional programming say ok
create create create the fact is that
the in the last 15 years the hardware
change it a lot and the Java Virtual
Machine change it a lot and what was a
very expensive thing in Java one dot one
or one or two is not like that is not no
longer expensive and a few weeks or
month ago I I read that a tweet about of
brain gates that for sure knows this
stuff better than me but he industry te
bros nowadays
creating new new object is cheaper than
me turbidity cheaper meaning that of
course you have some overhead you of
course you are you are putting the
garbage collector need to do some effort
to throw away those additional object
but but this allows you to to leverage
of the course so it's a trade-off it's a
also not really no no no not for what i
want but also did the other thing you
have to consider easy it is not that
expensive as you think my friend simona
is smiling there i don't know he has a
completely different point of view
that's fine but but also consider that
that those who object are typically very
small liveing are very shortly so they
will they all died in the in the
premature part of the garbage collector
so they will never reach the the tenured
part you know the garbage collector okay
so probably it is not that expensive
it's a trade-off of course it is and ok
is further question was up candy up
sport I think do some magic to allow me
to have a functional style but I I don't
have an answer i I don't I don't know if
okay there are some minor optimization
the compiler can do for you of course
for example what the Scala compiler does
but Java one doesn't is that is the
tailor a cool
Shin you know what is what is it meaning
that what the scholar compiler that is
that thus is that in a functional
programming use recursion a lot so
emitted the cold calling themselves
again and again and again and again and
if the very thing very last things he
does his is doing this recursion
tskalikan can optimize this so in the
sense that you don't have this all this
invocation on the stock it flattened e
okay and but but java compiler doesn't
do do this yet but it is possible in in
minor fingerings okay no question
I honestly I honestly this is a very
very very good question and honestly I I
don't know or or better I have wishful
thinking about this okay but for example
I was pretty convinced the three or four
years ago that that this scala was going
to take a very very huge traction and
yes it came it can eat some traction but
not that much as I expected for some
reason I don't know and I don't know it
also depends a lot on on which is your
business which is your data model for
personally why what I said at the moment
is there is there are many more
companies emigrating from SQL to scholar
than from Java to scala this is the way
thing because for example there are lots
of business banking in in in the city
london that they did scala because they
need SQL because they had lots of number
crunching and with a very strong
mathematical theory behind and they feel
comfortable with skull and and they are
moving from esco to skull of course
somebody's moving to skull as well and
and you know there are there are very
big companies doing skull at the moment
the biggest one if i can think about his
widow the biggest part on twitter is
written in scala and they they move to
to scala because they won't want it to
do functional programming so okay Scala
is an easy and I breed language so you
can do more or less what you want but
but I think that if they move to scala
they are they are poly paradigma
programmer they are not just poly
polyglot program
so they they are they are moving to to
functional programming flew a functional
language for a functional reason yeah a
dynamic okay this is very personal
dynamic languages are my enemies now we
have look at look at ax ow i'm using the
type system here but okay but this is
very questionable o scoff course right
but look at how our amusing the type
system here with the type system I am
enforcing the correctness of the program
and this is what i love static erlang
languages end and i want more typing not
not not less yes there are there is
closure there is groovy again my
personal opinion ah I love SQL that is a
that there's a stronger typing that then
scholar that there's a stronger typing
than Java so again I I don't see the
point IE Indian knee I really don't see
the point in dynamic languages become a
ghana i'm a lazy i'm very lazy if the
compiler can do lots of check form for
me and do some optimization at my place
if the compiler can do my job let's see
to do my job okay also because not only
because i'm lazy because i'm pretty sure
that the compiler he is it's a better
than me to do the job okay sorry yeah
sure
hmm
ok
big red so it is the compiler one time
you you know okay the question is the
compiler ease or order on time of course
not not the compiler the runtime is mart
enough to leverage the parallel is me in
the right way be meaning that if the
biggest part of my cpu RBC I don't want
to split another job in in multiple
parts because because there's no point
in in this I think this is this is the
job what they did or what our thoughts
what does because as you know in Java
you have to level of compilation you you
compile your source embed code and then
your bad code runs and then you are sort
of further compilation made by out spot
that that learn from from your your your
execution paths and and and adjust
adjust the way it executed it so i think
these this is in the in the sense of it
is partially answer to your question of
course of course this is not a
convenience well anyway that the other
important thing is that you are in
complete control of this meaning that
there is no magic parallel ease that
happens when you don't know already when
you don't think that it should happen
okay meaning that let me find the point
meaning that me meaning this if you do
if you say stream you will get a
sequential stream if you do if you say
parallel stream you will get a parallel
stream okay
so it's up to you but you can decide
nothing happens unless you you you don't
want it if you do if you okay if you if
you if you say that you want the
parallel stream if yours to a parallel
stream do this on a big array it will do
in parallel and this and it is not said
that will be faster than the sequential
version yes really it's really it's
really different to give an answer it
depends case by case but but what were
you are doing our much load you have on
your on your machine sorry you have
control of what you want to do in peril
and what you do sequentially yes but but
it's up to you you are not convinced
okay it is cereal if you do if you do
this is it is sequential you are your
ensure that this is coty see sequential
that sorry I didn't explain myself very
very well of it this is for sure
sequential if you don't say parallel
stream it won't do any magic to be
compared alley you are in complete
control this is important okay thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>