<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON1657   Refactoring to Functional | Coder Coacher - Coaching Coders</title><meta content="CON1657   Refactoring to Functional - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON1657   Refactoring to Functional</b></h2><h5 class="post__date">2015-12-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VezFbGaCD1I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so welcome to this session on
refactoring to functional there is um I
see some of you are sitting on the floor
there's one chair left here who gives me
the highest bid and have it no maybe
I'll also exchange it for a couple of
tickets wealth and John as I can oh you
have a seat okay it's a seat here oh
there's one here as well okay so uh I'll
give you a brief outline of what this is
just think as now that you're all
sitting down and all like which make
your chairs warm you can start to walk
out this is a very kind of introduction
to functional programming it's going to
cover some basic concepts and it's going
to take a different approach of instead
of just explaining concept after concept
it's more kind of like how we can apply
to existing code bases so if you are
doing any kind of functional programming
I suggest you leave now if you stay do
not vote red
in fact don't vote yellow either saying
man I didn't learn anything I'm warning
you seriously I happy I have people
watching okay so with that we'll start
and it's also interesting that they've
put this track under I think this is
emerging languages which fits in nicely
because you'll see why anyway functional
programming when I want to find out
about something I go to the main source
of information which is Wikipedia and in
Wikipedia which is truth it says in
computer scientist are casting in
computer science functional programming
is a programming paradigm a style of
building the structure and elements of
computer programs that treats
computation as the evaluation of
mathematical functions and avoid state
and mutable data it is declarative
programming paradigm which means
programming is done with expressions
fantastic what does that tell us that I
read very well in addition to that there
are some key points of that which are
important which are those the ones in
red bolt ok so given that we want to
talk about functions avoid state void
mutable data be declarative and work
with expressions so let's take that and
let's refax it functional but I like to
kind of answer myself always why before
I start something why should I be
refactoring to functional and and it's a
good question i mean if you're doing
agile you've surely heard of the five
wise yes ask the customer why they want
something five times until they give up
I used to practice that I used to work
it doesn't work on kids you get on so
anyway what are our goals these are the
goals that I've learned over the years
of writing code I've tried to as much as
possible write less code right the you
know I think there's no country left in
the world that actually you get paid by
lines of code even Spain where I'm from
so I try and focus on writing less code
as much as possible the other goal that
I always have this trying to write
expressive code because code that i
write that I understand today you know
some other colleague might not
understand if it's not expressive in
fact take your own code base and go six
months down the line and you probably
don't understand what you've written so
a good another goal is always to write
expressive code all is sold to write
correct code when I first started in
software development I didn't unit test
right I didn't know what that was and
the testing was basically the customer
would call and say this doesn't work on
say okay i'll send you another one and
that will work of course that did work
until it broke something else and then i
discovered unit testing and I thought
this was fantastic it was an amazing
thing so then I started to unit test
everything and after unit testing
everything someone said to me yet but
that's unit test now you need to do
integration test and then I started to
do common 0 comma comma 2 permutations
of all the different integration tests
that I could potentially do trying to
reach my goal of a hundred percent code
test coverage and then I realized that
this is really boring and I went
downhill right and now I'm somewhere
around here do you share my experience
so point being that i want to write as
much correct code as possible meaning
that i don't have to test things right
performant code why because silicon
valley we are actually in silicon valley
right now yes it doesn't matter what
you're developing nowadays someone will
tell you you need to scale okay doesn't
matter whatever you're doing even if
it's a site for five people think about
scalability those are our goals except
the last one kind of if that's your
thing great if those don't matter to you
it's to be part of the in crowd because
nowadays it just really feels like if
you're doing object-oriented programming
they look at you and I kind of live
really you should get into the whole
functional thing back in the old days
people used to say like how many of you
have read the book gang of four right if
you if you ask that six years ago do and
you hadn't read it there would be kind
of like really and you call yourself a
software engineer now if you say I have
they're like really you read that book
and the and the irony is you know that
and I find it funny because now there is
this trend Awards functional programming
and recently I saw a tweet that said
functional programming is this awesome
new paradigm and it was by someone in
the JavaScript community
which it probably they were it came
around before they were actually born so
but anyway oh you know I as you get old
you kind of like get off my lawn kind of
thing and I'm old ok so anyway can I use
any language to do functional
programming now this leads us to the
question of what exactly is a functional
language and this is very much kind of
like how consultants work right every
time you ask them a question they're
like it depends and this is very much
the same thing different people can tell
you different things right someone will
say functional language is something
that has higher order function has
immutability immutability by default and
has this and that and has coloring and
stuff like that in essence you know I
think that it needs to have a series of
traits and not only me a lot of people
think this and some of them are that it
has that has functions as first-class
citizen will see why because we're
basically embracing functions as a
primitive and that means that
essentially you need to have higher
order functions which basically means a
function that takes a function or
function that returns a function has to
have lambdas well yes because we want to
write less code more concise coats are
often lambdas are helpful top level
functions what do I mean by this that I
can declare a function just anywhere
without having to associate it with a
specific object so right now if you're
doing Java or C sharp you have to
associate a method as part of a class
right if you're doing JavaScript you
don't have to you can just place a
function anywhere and then spend the
next six weeks looking for it but beside
the point
they don't have names faces so besides
the point you know if that's not
fundamental but it does help a little
bit in terms of conciseness and
expressiveness and of course immutable
data which will see why so what can you
use now this is where this section fits
very nicely because I'm going to be
using Carlin why am I going to be using
call in because that's the language that
I've been using for the past several
years and it's a language that I enjoy
and it's fun and I didn't mean a pun by
that how many of you have heard of Carl
in okay it's very easy to read if you're
if you're doing C sharp or Java you'll
pick it up easily if you're doing
JavaScript you'll pick it up easily as
well I'll go through the most basic
syntax in a minute so that you see what
it's about you can of course use
anything so you can use Java a Java 75
plus functional language scholar
JavaScript closure Haskell f sharp C
sharp o camel is anything Arden Erlang
as well um and oh free gay frig is here
mera know yep anyway javascript as well
right and people say is JavaScript a
functional language yes if you can call
it a language
it was designed in a week I mean you
know put that into perspective and how
long it took this design closure for
instance so basic syntax just to get
familiar that's how you declare a
function in cortland it has top level so
you don't need to define classes you can
just place the function there and much
like JavaScript spend time looking for
it basic function parameter uses kind of
like the Delphi Pascal syntax which is
parameter name Colin's up to type return
type much the same way at the end that
you could then you can have single line
functions which is basically just in
line it has pretty good type inference
so that it continues its statically
typed by the way higher order function
you can see that it's just a function
you type that the third line is
basically a function that takes an int
and returns an int and then you have a
way that you can write lambdas there
that's all you need to know basically
for this talk the rest you pretty much
understand easily everyone follows this
code right very simple now a few
definitions before higher-order
functions as I already explained is
basically a function that takes a
function or returns a function here you
can see that I can reference a
higher-order function in cortland either
by referencing it by name passing in a
lambda etc and very simple okay another
thing is pure functions so pure
functions is basically that given some
input the function always provides the
same output right and execution does not
cause absorbable side effects so
effectively what that means is that all
that function does is calculate
something and return that something
there is no side effect
if I call that function a million times
it will only calculate something and
have no side effect on the environment
and that is a characteristic which is
called referential transparency which
effectively means that I could take that
function and replace it with a lookup
table right it would be exactly the same
thing if I took all of the possible
parameters replace it with a lookup
table it would be the same thing as a
pure function and we should aim for pure
functions why should we aim for pure
functions because we want to reduce
moving parts if you take a class and you
have a method and you start to invoke
that method and that method you don't
know what that method does until you
look at that inside that method if that
method doesn't return a value then
obviously it's going to cause a side
effect because otherwise what's the
point of the method right if it starts
to produce a side effect now you have to
keep a mental model of all the things
that are starting to change so now when
you test that method you have to start
to test various input parameters and
side effects etc whereas with a pure
function you know that if I call
something it will return a value and the
scope of testing starts to be reduced it
doesn't impact the environment so given
these characteristics can we achieve the
goals that we're setting out so here's a
bit of code and this code says it does
something and it takes a list of string
and it takes a hashmap as soon as you
figure out what it does raise your hand
okay you raised your hand don't tell me
what it does but good I trust in you
now let me show you a different function
as soon as you know what it does raise
your hand right see how fast hands go up
now yep and guess what they do the exact
same thing right both of them do exactly
the same thing and yet this one is much
easier to understand it's more
expressive so you wonder what what's
functional about that well let's kind of
drill that down and see there isn't
nothing there's nothing really like
magic or anything about that first of
all let's take this example loops right
I have a list of albums and I dream that
one day the event in Oracle will be
Roger Waters and here's a list of albums
of Pink Floyd and what is doing is
basically going through and looking for
the album that was a hit in the US and
in the UK so it's got a loop and it goes
through that loop it sees what position
that album was in and then it adds it to
a list of hits and then it returns the
hits now look at everything that's going
on there I have a loop I have indexes I
have an initial array i have another
array etc we can start to remove state
so i start to remove that index and i
say for album in albums already i'm
reducing some moving part right i no
longer have to keep a mental image of
the index parameter etc and i say if
album chart it goes that then hits to
album but i still have that conditional
there and i still have that additional
arraylist now let's add some syntax
sugar and what I've done is replace that
for loop with a for each but already
something has come into effect here that
for each is a higher order function
right and the way that it's broken down
in this sense is so that you associate
it with the previous version in Collin
there's basically a characteristic and
where
if the last parameter of a function is
another function you can drop the
brackets right kind of like groovy so
here I've dropped the brackets and I'm
saying for each the only difference is
that I've taken that for and I've
created a new function called for each
which inside is going to do that for for
me and what am i passing to that I'm
just passing in a predicate which is the
same conditional that I had as part of
that for loop but I'm still having
emphasis on how right I'm still saying
you've got to go through this loop you
got to filter out this you got to get
all of that not what so let's write this
code I'm not taking that for each and
I'm replacing it and i'm calling it a
function called filter that's it it's as
simple as that that is another higher
order function I have basically used
function as a primitive that's it
nothing more now this is a very simple
example I'm just getting you know doing
a filter we can also say let's get data
let's get data in different ways so here
for instance I have top hits of us and
UK by year and I want to group and only
get the year not you know other
information so now I'm not just getting
the album as it was I want to get it in
a different way so again I can do kind
of like you know filter we already
learnt that and now I get the list of
albums and now I create a list of years
and I repeat the same process over and
over again but why not just take that
original list and create use another
function another higher order function
which is called map right and then just
map out the value
so very very simple all I'm doing is
just starting to use functions as first
class primitives a more involved sample
is this here I have a structure that is
not flat I have a list of albums and
each album has its own list of albums
and I want to try and get some value
from there again I can go through this
iterative process or i can use this
other function which is called flat map
so you all know what map does right it
takes list and produces some lists with
other values yes a flat map takes a list
of lists and produces a flat list of
values and those are primitives and
they're primitives of building blocks
that are functions that we can start to
use because now we understand what they
mean and we start to use them and we get
rid of some of the boilerplate code so
if we go back to that original example
and put them side by side you can see
that all I'm doing is just using code
that someone else has written but that
code that someone else has written is
much more expressive yeah
nothing magical so thinking functionally
how do we apply these things like what
what exactly are we doing as I said
functions are our primitives and all
we're doing is just combining functions
that's what we're doing functions taking
functions filter it takes a predicate
map takes a mapping function group x
takes a lookup function may and they're
just building box allowing us to use
functions as first-class citizens and
then what we do is we basically take
those functions and do pipelining get
the result of one set apply to the
result of another take that apply
another function and so on and so forth
and then there's the data right and if
you look at the data what we're doing is
we're taking data and processing it in
stages so it's pretty much like whiskey
I mean that's all it is right if you
think about our life as programmers it's
nots clamorous all we do is process data
right before they used to put us in
cubicles to process data now they put us
in an open office floor plan and they
call it hipsterish it's just to save
costs on the cubicles
but all we do is just take data and
process data that's effectively our life
it's just maths and what is our data we
have customer we have invoices we have
points we have aged so we have two types
of data we have scalar data like age
date of birth amount etc and then we
have collections of abstract data types
which could be list of customers list of
invoices sets of pairs and we take
inputs as lists and process outputs as
list and we can combine these and with
common functions or map flatmap which we
saw filter find all merge zip and then
sometimes we can say okay now I have a
list and I want to obtain a value from
that list so I can apply some other
functions such as first last find
aggregate and all they are is just
functions taking the same type of data
structure
and in fact many of these functions ball
down two folds fold is very big in
functional programming right full reduce
aggregate these are all the same thing
so how many of you are familiar with
fold right what is full for those not
familiar here is fold in a in a slide I
have an array and I have an initial
accumulator and then I have an element
in the list right and then I take a
function and I take the accumulator and
I take the value and I apply that
function and this gives me another value
I then take that value and I put that as
the accumulator and then go through the
next element in the list so on and so
forth until eventually I just end up
with a single value right so fold is
taking an accumulator and a list of
elements and it's reducing a single
value and this has some relationship
with recursion so here's an example
right what is this this is basically a
max and this is very similar to how like
Haskell and you know this if you've ever
if you've ever looked at list you have
the head and you have the rest of the
list this is basically doing pattern
matching with the actual data structure
that you have so i have a list and i
want to calculate the maximum of the
list so i say if the list is has zero
elements throw new argumentexception if
it has one return that element else call
the maximum recursively on the rest of
the list the first element of the list
and the rest of the list and if you
think about this now recursion sometimes
is often viewed badly right because in
terms of performance it's not great but
it's also very useful because it's very
expressive but if you look at this this
and in fact is very similar to fold in
fact many recursive functions you can
express as a fold let's take this
example how would this be in a fault
it would just basically be a lambda a
function that does a comparison of Max
now there is a bug in that slide who can
tell me what it is
and
what is not recursive it's it's full
exactly if it's negative it won't work
yeah
and it won't work with negative numbers
ok now but sold is if when you start to
look at functional programming fold is
like the essence of it and that's why
because a lot of these functions reduce
basically its fold with an initializer
already okay now the other aspect that
we've been talking about initially has
been this immutability of the data right
why why do we need immutability of the
data so first and foremost to avoid
state why do we want to avoid state if
we have state we need to think about
state if we have a class we if we have
methods and these methods are modifying
things we need to think about these
things that are modifying and we still
have to create this mental map in our
mind of saying okay this will modify
this value this will modify this value
and it starts to feel like a black box
you don't know what that method call is
going to do whereas if you have a
function that returns a value and it
only returns a value then you know that
all it's going to do is return a value
right and there's the command and query
separation principle which says separate
methods that act on objects versus
methods that return values okay and if
we start to avoid state then we can
treat things as infinite we can start
doing things like lazy evaluation and
this next great thing that is available
nowadays which is called RX java and
reactive programming and we need to
start to think about creating things and
not constantly modifying things and if
you're familiar with domain driven
design right one of the principles of
domain driven design and they talk about
a lot is you know you create models and
when you create a model when you create
some kind of nth domain model that
represents whatever it is that you want
to represent make sure that that domain
model is valid right so you don't have
all of this validation code etc on your
on your object and that's also based on
the principle of immutability I create
an ombre I create an object that is
valid if that object is valid and I can
never mutate it
I don't need to worry about when it's
going to mutate and when it mutates if
it is valid right now we start to treat
these functions as little building
blocks we have them as primitives we
start to pass functions two functions
and it starts to become a little bit
more concise etc but often what happens
is that we want to reuse functions right
I don't want to have to recreate the
same function with different that a
minus slight change I want to start to
reuse functions so how do you do that
now a lot of functional languages have
composability of functions right so here
for instance I have a sum and I have a
squared and I want to compose these two
so that for instance when I want to do
an operation of salmon squared I don't
have to repeat code or have one call the
other etc so i can start if i start to
treat functions as primitives i can
combine these carlin by default doesn't
have composition of functions but you
can create it right so I can create a
function called compose that takes two
functions and returns a new function
which is a composition of both one other
aspect that many functional languages
have is called curry right a haskell
curry the inventor of carrying and
basically that means that if I have a
function with multiple parameters what I
could potentially do is call that
function with a single parameter that
their returns another function that I
can call with the second parameter and
so on and so forth right and we'll see
why that's important in the in a minute
but again for instance with Kotlin it
doesn't have first-class support for
curry but you can create a function that
does a curry right so here I have a sum
that takes two integers and returns the
sum I can do some curry and now that
will return to me a function that takes
a single parameter so now i have some
curried 3 which returns a function with
another parameter and on that i call the
function
here's another example of carrying right
with three parameters so what is this
useful for now what I can do you're all
familiar with optional parameters right
and default parameters with default
parameters i have a function and i have
some default parameters and if I don't
pass in those parameters it basically
create it uses the default values this
is basically the same thing I could use
this technique to do what's called
partial function application so now I
could define functions that have default
kind of values but instead of obviously
when i call that instead of getting the
result of applying that function what
I'm getting is a function with certain
default values set right and a little
bit further on we'll see where we can
use this so all of these building blocks
how can we actually apply these two
techniques that we have so here's a
typical example we've all done this
everyone in this room has probably done
this right this is I've called it a
customer filter but it back in the old
days we used to call it a customer
repository by a class that has 6,000
methods that has nothing to do with the
actual pattern repository but
nonetheless we called it that and it
says you know search customer filter by
name filter by country etc etc and if
you look at these two methods what
changes what is the difference between
these two methods just this couple of
lines of code yep so why don't we take
that and start to use it functions as
far as class primitives right and we can
do pass in the predicate so have a
single method that we actually pass in
the condition now how many of you are
done net developers by chance right and
learnt about seashore well c sharp okay
when I say God that developers etsy shop
vb doesn't count
an f-sharp is still trying to gain
traction so in c-sharp we have this
thing called link which is functional
programming basically select is filter
etc or selectors map where is filter and
when they introduce link to c-sharp they
introduced it not as functional
programming they said wow look what you
can do with your database so we started
to look at this and we're like this is
so cool and then what did we do we
started to take our repository patterns
and we kept those 6,000 methods and then
inside each of those methods we used to
use link instead of actually using link
as a first class citizen instead of
passing it so we used to replicate all
this bunch of code for absolutely no
reason right why it was called
abstraction in case one day we rip out
one ORM and put in another how many of
you have done that in your life ripped
out 10 RM and put in another year not
too often template pattern you're all
familiar with this pattern of object
orientation right I have let's say a
cost I have a customer record and I have
an invoice record and I have a UI that
deals with this and basically it's the
same pattern over and over again the
differences is what exactly happens when
I do an edit or save etc so here I have
a customer record that has an edit that
does a check permissions edit record and
persist data and then i have the
customer record and then the invoice
record and all the changes is the way
that they persist data or they edit the
record again a lot of boilerplate code
for what why don't i just pass in that
functionality it's two predicates why am
i doing all of this additional
boilerplate code for
here's an interesting example we don't
in well in Java you have closeable
object right so I do try something
finally object close I have to make sure
that I close the object after I've used
it what if I want to avoid having to do
this you know they promised a memory
manager you know memory management
garbage collection looks obvious we know
that when there's a filehandle open you
can't do this when there's a resource of
you can do this but why not use
functions as first-class primitives to
try and solve this problem so in c-sharp
we have this thing called using which is
kind of like try with resource right and
all I'm doing is basically the same
thing I implement a function called
using that takes a closeable and a find
the actual code and then I say creates a
closeable object passed a closeable
object to using execute the code and
once it's finished it's done it closes
it implementing using so basically
implementing something that you can
guarantee to take place avoiding having
to people repeat boilerplate code or for
instance when they take place if you've
played with gold there is a
functionality which is called defer
which allows you to defer the execution
of something to a later stage so here's
an example of implementing it with
carlin right i don't have differing
colleen as a native thing so i can say
with the first and then create print
line a differ and then print line b and
then the execution of that would
basically be deferred should happen lost
again just embracing this whole function
now i'm repeating yourself
I have a object code called class which
is VAR length for height for volume fun
area that calculates that and now i'm
using it this is one way to use it right
instantiate the object and then object
name dot something object name dot
something object name dot something i'm
repeating the object name constantly
over and over again why not use high
level functions to play with that and i
can say apply and then just take the
object and just set the properties if
any of you have come from delphi by
chance yes we had this it was called
with yeah that was 20 years ago I'm old
yeah but let's try not to mention visual
basic I know it's a big language in all
butter I'm joking yes visual basic has
it so strategy pattern again strategy
Brandon is you know if you think about
the structure fire all that is doing is
just changing the exact implementation
on something so I have a sort algorithm
then I have quicksort and I have bubble
sort and then I have to find the correct
algorithm for a specific case anything
that's changing is just the algorithm
itself everything else is the same so
why am I generating all of this
boilerplate code why don't I start to
embrace these functions it's just passed
in the functionality now the question
arises here is okay great that's
fantastic but what if I have to maintain
state in one of those sort algorithms to
which the answer is why you maintaining
state try and refactor code so that you
stopped maintaining state the less state
you maintain the less you have to worry
about dependencies we've all been there
customer repository has access to data
access and then it uses data access and
let's think about dependencies for a
minute what happens when dependencies
grow so here's an example of you can
this control in spring could be whatever
right I have car repository shipman
repository etc what happens when
dependencies grow what do we do we don't
do anything we say oh don't worry about
it the ioc container will take care of
it and then someone comes along and says
ioc containers a bad practice why
because they allow you to pass in as
many dependencies as you want and they
blame the tool because that's what we
like to do is developers blame something
else apart from ourselves
if you have a class as passing in four
dependencies that's not good because you
are decoupling absolutely you're
decoupling implementation details but
you're not the coupling functionality
right that class is probably
coordinating too many things so you're
missing some abstraction there and you
get a typical example like this that
I've suffered for example in asp.net MVC
which is a framework on the.net
framework by default you map your routes
based on the class name and then the
action name etc and then what happens
you create these really big classes with
these really long dependencies and then
you find that one method uses one
dependency another method uses another
dependency and they force you into this
pattern that is not useful right and in
fact what the problem here is that
you've just got too many dependencies
being passed in so how do you deal with
these dependencies well to begin with
you pass in behavior but the problem is
that you don't want to constantly pass
in this behavior over and over again you
want to kind of like initialize certain
behaviors and that's where the partial
function application that we saw
previously can come in we can now use
partial function applications to
initialize certain ways that we want our
functions to behave so i can say i have
a card data and i have a check out
handler that has uses the actual
repository by default and then in my
test environment i can pass in some
other functionality so using partial
function applications in the same sense
that you would kind of use ioc
containers in a more object-oriented
approach
and if you see all we're doing again I
keep insisting is just using functions
as first-class citizens now as we start
to do this what happens things start to
go wrong because as developers we have a
tendency of doing that so it's very
important to keep things readable right
if you start to have too many functions
pipelining one after another it looks
great at first filter Map Reduce filter
first at aggregate reduce whatever
whatever whatever and then all of that
beautifulness of let's try and write
correct concise comprehensive code turns
into what the hell is going on right and
it's important to keep things readable
here's a tweet I saw right this is um
lambdas came to Java 8 now you can argue
whether that's readable or not you can
argue whether it's performance or not
but I have started to see like you know
pipelining of functions one after
another and then again we go back to yes
we're avoiding state yes whatever but
now we've got to have this mental module
in our mind of what exactly is it doing
how can we solve that problem well
refactor to a function right and then if
we reuse that function compose it so
talking about performance what about
performance when you start to call with
functions and you say let's start to
talk with primitives and functions and
functions a function the functions call
function the function called functions
so on and so forth the first thing that
comes to mind is like my call stack
right my call stack is going to be like
this is not going to be performing code
absolutely but probably before that your
database is not performant and the way
you do your threading model for your
request is probably not performing
before you hit the kind of the
all starting right so here's an example
of the Fibonacci and you've all run this
and you all know that if you run it off
to around 20 it just you can go make a
coffee come back take a shower whatever
it's still waiting but it's very
comprehensible right it's very easy to
understand here's an iterative approach
that is basically the same thing but
harder to understand yes there's a
technique that some languages have by
default which is called memoization now
remember when we were talking about pure
functions I said basically if you have
referential transparency what you could
do is pull out that function and put a
lookup table why don't we create that
lookup table here's a very naive
approach to creating that lookup table
all we're doing is saying if I call this
function with this parameter just get it
from my lookup table of course you can
extend this to kind of do it at a
broader level with any function but if
you run this and you run the iterative
approach of Fibonacci you can't tell the
difference to the right I mean surely if
you run a profiling it might be a
fraction faster but you can't notice it
another yes
yes
well not really no I mean there's some
languages provide this out of the box a
compiler level yeah but this is more to
explain the technique of what
memorization recursion and tell calls is
this function recursive is it recursive
okay is it telco recursive what is tell
cool
yeah so the last thing that function
should call is itself right here it's
not because it's calling the
multiplication right what you can do is
you can take recursive functions and
convert them to tell Cole recursive so
here I've done a telco recursive
function factorial right and then in the
case of Colleen what it allows you to is
to decorate that as a tail recursive
cool right so you can add an annotation
what it's a directive which says tell
cell recursive and then what that means
is that the bytecode basically is
translated into a loop instead of
actually a recursive call there's other
techniques that languages can do like in
lining for instance if there is no state
being appellate there is no closure it
can just in line the function call right
so some of these things you would do at
a language level some of these things
you would do it the compiler would do
but it very much depends again you know
not to worry so much about that
premature optimization aspect of it okay
and then of course if you start to avoid
state you can start to enable parallel
processing right now I don't have to
worry about state now I don't have to
worry about mutation I can easily think
less about what happens if this runs in
parallel now I've gone through a whole
bunch of examples of refactoring and
taking existing code etc and we've seen
the primitive things in all of that and
what about all the scary stuff right
what about all those things that you
here so when I started to look in
functional programming I came across
this phrase and monad is just a monoid
in the category of endo functors and I
said you know what that's it I'm done
serious and I said screw this I'm
and it is true that like a lot of times
in the in the and I said as a joke like
to be part of the in crowd but you do
like hang out with people that do
functional programming and sometimes you
know they're talking and like you speak
English you know I'm like and that
actually shiz you away sometimes in
learning things and the reason that i
gave did this actual presentation was
because i looked at functional
programming from a different way and I
thought okay how is this going to help
me do I need to learn what a monad is I
want to mono I did and what an endo
functor is and what category theory is
do I need to know that in order to make
use of this and not really is it good to
know that absolutely but that shouldn't
be the thing that pushes you away right
first realistically at the end of the
day it's about what value does it give
to us and ultimately how can it help our
applications how can it help in our
daily work and from their own
investigate more and learn more and I'm
by no means at all an expert in this but
let's break this down a little bit
quickly okay a monad is just a moment in
the category of end of Uncas how many of
you here understand this okay cool so
come up and explain it
so no no no I was afraid yeah yeah I'm
going to skip it real fast because he's
going to sell you all wrong so go away
category theory consists of sets of
objects and functions which they call
morphisms and then morphisms goes from
one object to another so you have funk
sets and you have functions and then
morphisms and then you have morphisms
that go from one object to another I'm
really good at reading now these
morphisms have some properties and there
can be as composed and associative right
and there must be an identity morphism
and now start to think about all of
those things that came into play you
know composing functions etc right and
one of the important aspects of function
composition is that the input of the the
output of the type has to be the same as
the type of the input of the other one
exception ok so given this what is a
functor functor maps one category to
another so i take that XY f gof image
and I map it to another one right but
the important aspect is when it does
that properties need to be conserved so
example a function is a collection
functor is a collection of a whereby you
can apply function a to b to result in a
collection of B map is an example of a
functor now an endo functor is nothing
more than a functor where the original
resulting categories are the same so an
endo functor is going from the type
system to the same time system for
instance what is the Monod it consists
of a set and an identity element and an
operation and it has to satisfy these
properties so basic simple maths
right examples number and + operations
what is a Mona also known as the Kleiss
Lee triple
just with that you can impress someone
so it consists of an endo functor that
goes from x to x and then a bind
operation and an identity that satisfy
certain laws and you like great apart
from impressing someone why why why do I
need this why do I need monads why do I
even need this so as you know what is
the most pure functional language in the
world not frigging Oscar what yes lambda
calculus
and what is the what is the aspect of
Haskell nothing lambdas right but it's
pure in that it doesn't also state right
it has no side effects which when
designing is fantastic when you come to
use your like right did anybody think
what we could do with this
so the point there is that if you do not
want to alter state there was need to to
basically have side effects without
destroying the pureness of the of the
language and that's where they came with
the Mon Act which is basically a way to
there's different monads and there's
that the world Mon at the state Mona
that basically allows you to represent a
new state so each time is like a new
representation of what you're doing so
when I write line to a console that's
just like a completely new thing right
and there's examples of monads like
maybe monad which is kind of like option
in Scala list Mon a dynamo writer will
state mon at handling state changes IO
monad for handling io effects which was
one of the reasons that it came about in
Haskell now again I'm no by no means an
expert in this but I did find that
functional programming did where and by
functional programming I mean starting
to use more functions provide value to
me in writing more concise code so in
summary I keep saying this embrace
functions as primitive elements focus on
writing less your own code and this is
really important really don't write so
much code all of this filter map all of
these basically boil down to the
primitives of four for each all of these
things they're all the same but it's not
your code you don't have to test it
right it's already there for you focus
on writing more descriptive code and
this is also important because as you
start to do these things with functional
programming you enter this world of
starting to write code that you no
longer understand I'll give you an
example in.net we have a tool called
resharper which has a functionality
called convert to link and when link
came out we basically you could take
your for for each for loops and have if
statements inside there and it could
take a really complicated for loop and
you would hit alt enter and it will
convert it to link
functional what happened after about a
year and a half we ended up with code
bases that nobody could understand so in
the next version we introduce another
function which was convert link to
iterative
which wasn't control-z right point being
that as developers we really like to
take things to the limit and abuse it
and make it really bad which is good as
well right because it keeps us in
business so but try you know this does
open up many does but it also opens up
many potential issues focus on writing
deterministic code again I have tried to
limit the amount of unit testing that I
need to do to really strictly what is
necessary and in fact i favored
integration tests over unit tests so if
i can make it run fast i'll make it run
fast and nowadays you can make things
run fast if not you just fire up a
couple of docker containers throw them
in amazon and pay the bills and of
course rocket science it's not but it's
very when you start to get into other
aspects of it and all of the things of
category theory it is it's not easy
either but to sum up if i had to say one
word to go away with this I wouldn't
because it's two words
actually it's three words on a colon
functions colon embrace them okay some
books the little schemer if any of you
have read it it's the version of this
little Lisp er there's different
versions of it it's very easy what it's
not actually it's easy to start with and
then it starts to get a complex complex
very good read it's about two Mouse's
and it's like a cartoon learn you a
haskell which there's a PDF version of
it or you can go online and learn read
that for free and phocion functional
programming Java which is very good for
the Java crowd here which is by Venkat
and talks about functional programming
using Java 8 okay and with that we're
done and now you can really go and
listen to Elton John</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>