<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The invokedynamic Instruction in 45 Minutes | Coder Coacher - Coaching Coders</title><meta content="The invokedynamic Instruction in 45 Minutes - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The invokedynamic Instruction in 45 Minutes</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qaf8sHjeQ2g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is invokedynamic in 45 minutes and
that is has been when I've done this
talk in the past kind of grossly
optimistic so having the full hour is
nice we'll have a little bit more time
to explore this a little bit take it and
take it slowly and as I say with all my
talks
if you see something along the way that
confuses you a little bit just shout
something out raise a hand and we'll see
if we can address your confusion okay
so we're gonna talk about invoke dynamic
from one end to the other
basically information about me been
popping around various companies doing
JRuby work for the most part but in the
process of working on JRuby also getting
to know the JVM very well working with
the JVM team to add features at api's
libraries enhancements and then changes
to the JVM itself that could help
support JRuby so we've done a lot of
work to try and improve the JVM for
languages and is because of a lot of our
work and a lot of work of other language
implementers that we've got
invokedynamic today and I'm pretty sure
that we were the first adopter of
invokedynamic we actually had support
for it we started using it early in the
draft development long before the API
was even settled helped to figure out
what made it work and what didn't and
then helpto settled the whole API down
okay so this was 2011 shortly before the
Java 7 release I believe or 2012 yeah I
think of 2011
anyway invokedynamic is the most
important addition to Java in years I
still believe this this really
completely changes what we can do with
the JVM and what we can do with the
platform rather than having a very
fairly narrow set of things we could do
with JVM bytecode we can now kind of
define our own way for operations to
work and that's what hopefully I'll show
today so a little history the JVM
authors actually in the original JVM
specification did mention the
possibility that someday other languages
might run in this platform they didn't
have any intent to to design it around
being a universal VM or around having
lots of languages but they made it
possible they figured there's probably
something that might happen in the
future
over the years language authors
definitely have targeted the JVM these
days there are literally hundreds of
different jvm languages you know a lot
of the more common ones like groovy
Scala JRuby closure and so on but there
are hundreds of languages and probably
every language you've ever heard of has
an implementation on the JVM by somebody
perhaps two or three the the problem
though is that the JVM was kind of a
mismatch for a lot of these languages
especially when it came to languages
with alternative typing systems dynamic
calls dynamic dispatch you kind of had
to shoehorn the language into the JVM
and now of course you can make the JVM
do anything it's a turing-complete
machine and it can implement anything
that you want it to but it required a
lot of tricks and sometimes there were
JVM features that were really difficult
to provide like dynamic dispatch like
some of the optimizations that we need
to do for for dynamic languages so there
was a lot of stuff that we wanted in the
JVM that we couldn't do if we look at
some jvm languages through the years
early on there were implementations of
Python and JavaScript even before 2000
the j python and rhino projects were
around and and the many others over the
years it's continued to snowball and
every new language that comes out
somebody feels the need to put it on the
JVM there wasn't any official backing
for this by Sun Microsystems until
probably 2006 or so 2006 they hired me
and the other JRuby guy Tom Anna BOE to
come in work on JRuby and started
thinking about what the future of the
platform as a multi language platform
might look like so jsr 292 invokedynamic
had been kind of popping bopping around
for a little while I had a couple
different leads never really seemed to
get anywhere in about 2007 though after
we came on board
it was rebooted we got a dynamic
language fan on the JVM team John Rose
working on it with us and really started
redesigning it and has been put and
turning it into something generally
useful something that could could
support many types of languages long
into the future of the JVM and then of
course in 2011 it actually shipped as
part of Java 7 so what is invoke dynamic
this is a question that that people ask
me off
it's a question that I ask people to
like just to find out what they actually
think it is and usually the first
response that I get is oh that's some
dynamic language thing it doesn't help
me at all it doesn't do anything for
Java actually in 2011 when Java 7 came
out and they had to pull back features
like lambda pull back features like
modularity people complain people were
upset that there was only a few features
in Java 7 and probably the biggest one
that was being talked about was invoke
dynamic something that would never be
useful for Java and had no direct effect
on them well it's not really the case
dynamic dispatch and dynamic types is
one possible use for invoke dynamic and
it's certainly a good use but there are
lots of other ones so that's not the one
that we're gonna we're gonna worry about
now so then it says something about
invoke it must be some sort of new way
to do method invocation dynamic method
invocation or other types like I say
that is one possible use for it but
there's a lot of other tricks you can do
with it
so we'll not go with that definition
either and then say well at least it's a
new bytecode and that is true that's
part of the story there is a new
bytecode in the JVM called invoke
dynamic but there's a whole lot of other
work that's gone on around invoke
dynamic around the the plumbing required
to support it and in the JVM to make it
optimize well so there's more to it than
that as well what I've been kind of
going with is that invoke dynamic is
essentially a user-definable bytecode
it's a it's a bytecode that tells the
JVM I'm going to determine what happens
at this point in the code and then you
go off and optimize it like you would
with any other piece of java code so
it's a user to final a bytecode with
this other plumbing behind it method
pointers and adapters in the form of the
method handles API so you give the JVM a
pointer to your code plum it all
together with these reflection like
method pointers and then it goes off and
optimizes it it allows you to be part of
the whole JVM process the whole JVM
optimization and dispatch process so we
look at invoke dynamic it's got this
user-defined bytecode as 1/2
it has method pointers as the other half
and in actual invokedynamic terms that
is the bytecode and a bootstrap method
that the JVM calls plus method handles
that you use to tie it all together so
I'm going to show a lot of code here all
the code is available on my github
project indeed deep dive you can take a
look there run the examples try it out
on any Java seven Java eight build and
kind of and probably the the more
entertaining way to go through this is
actually debugging through some of the
invokedynamic stuff and seeing how it
dispatches where it goes sir all right
so we'll talk about method handles
method handles probably the most
concrete part of this some needs you can
actually use and see from java code
method handles as I mentioned they
provide method pointers field pointers
array pointers basically different ways
to have an endpoint passing some data
into a function and getting a result
back getting a value from a field
setting a field and so on but around
that in order to sort of build up a
functional object you can do some
argument manipulation you can change do
some flow control branching operations
and whatnot and probably the most
important part is is that the JVM can
see method handles as kind of a native
native instruction a native intermediate
form that it can optimize as if it were
bytecode as if it were any other piece
of java code but you can
programmatically tie this all together
without actually generating bytecode
yourself all right
so looking at the package java.lang
invoke the main classes that you'll see
here our method handle which is that in
vocable pointer function object that
you'll be able to dispatch to method
type which represents a a set of
arguments coming into a method and a
return value from that method that's all
it really is a signature essentially and
then method handles which is a utility
class for getting instances of a method
handle a pointer to a function wrapping
it with some argument handling and so on
starting with method handles there is an
inner class they're called lookup and
there's two ways that you can get an act
get access to this the lookup method
basically gives you a factory for
creating method handles function
pointers that
see any any method at this particular
point in the code so if you do this
within your own class this lookup object
can look up private fields can look up
private methods and give that back to
you as a callable object it's a way to
kind of expose internals if you want
from within your own code or if you're
doing dynamic invocation to be able to
call in to enter me internal calls
without having to do reflection tricks
the other one that's a little less
invasive is the public lookup call and
this does kind of what you'd expect it
gives you a way of looking up method
handles only for things
everybody could call public fields
public methods and so on so as far as
method pointers you can get the four
major types of method methods in the in
the JVM static methods virtual methods
which are instance methods on a concrete
type not against an interface and
actually I think use this for interfaces
as well find special which is for doing
super invitations or private invitations
and find constructor obviously is
forgetting a constructor reference and
then field pointers so you can get a
essentially a callable object similar to
a java.lang reflect field that allows
you to set and get fields a few examples
here so we have some example job at the
top doing system get property and also a
print line below that so we we use
method type to define a signature for
those two methods the get property
signature is that it returns a string
and it takes one string argument the
print line argument is that it returns
void and takes any object that's the
that's the signature we're using here we
use the lookup object to get static on
the system class so find static on the
system class with the name get property
using this method type using this
signature and then what we get is a get
property method handle a callable
function object that points at that
function very similar to reflection but
a little bit less
a little bit less cumbersome print line
method handle similar thing this is
actually an instance method so we do
find virtual here print stream class the
method print line using that signature
and down at the bottom you can see we
are able to invoke both of those very
much like a method object alright some
more examples here will actually get
access to a field yes right there no
one's ever asked that question and so I
took the slide out that explains why I
have to do the cast here and now someone
did alright so if it's a little it's a
little tricky to explain but this the
the invoke method here on method handle
is kind of special it was a feature
added for Java 7 rather than having a
single signature like like a java.lang
reflect method that returns object takes
an array of objects what you gets put
into the bytecode is the actual types in
the code at that point and they need to
match all the way through this is one
way that the JVM is able to optimize it
as a regular call without boxing it in
an array without boxing numeric values
so here because system.out.print line
takes an object the signature we're
using if i was to just try to pass the
string it would not be able to invoke it
at runtime it would say these signatures
don't match your trying to call an
object method handle with a string
object but by putting the cast in here
it actually emits the object version of
it and then it will call right through
it's a it's a kind of a weird concept
there's also a you'll see in later
examples and invoke with arguments and a
couple other invokes that don't have
this same special property but they will
end up boxing the arguments in two
numeric boxes or into an array to pass
them through so it's it's kind of a
sneaky way to get the JVM to call these
method handles with the actual types
that you're passing at that point rather
than converting them to something
simpler alright and you'll see those
casts throughout until I get to the
other invokes so here's actually getting
access to a field so we've got our
system out field access above and
example very similar to getting a method
handle or a method pointer fine static
getter
we want to get that field off of system
class the field name is out and it's a
print stream simple enough and then
invoking that handle gives us access to
that that print stream object oh using
an instance field here a little bit more
different little different example we've
got our little structure up there with
just a public name field we'll create an
instance of it we've got our name setter
my struct get the name field string and
then invoke it against an object so the
first argument to this invoke ends up
being the structure itself and the
second argument is setting it all right
so now we've got various ways that we
can get these handles like I'm like a
java.lang reflect method or field now if
you were going to do some argument
changes before you called the method or
manipulate an argument before you pass
it into the field you'd need to have
that code everywhere you were doing the
invocation or perhaps a utility method
somewhere the method handles API
provides ways to just sort of keep
wrapping layering on onto that on top of
that handle argument manipulation moving
them around doing branching logic and
we'll walk through a couple of these
examples so you can see how it works so
first of all argument juggling allows
you to insert into that call an argument
drop an argument that you're not
concerned about or reorder them in some
way permute them in a way you can also
filter the arguments which takes each
argument and modifies it and then
continues to pass it on for example up
casing every string now we'll see some
examples of that in a second folding
basically takes all of the arguments
does some calculation and then adds the
return value back into the call path and
then casting obviously if you want to
change the types along the way there's
also splatting spreading for doing VAR
args kind of stuff so taking a look here
if we've got the math.min function that
we're calling it takes two arguments
normal
but we know we're always going to be
doing a min comparison against some
given value
maybe it's integer that max value and in
this case we don't want to have to pass
that in every time we call against this
handle so we can insert that max value
argument into the B our argument here
and then our handle only requires one
argument at that point we can just call
it with a single value and it already
has the B parameter bound into it we'll
see what this actually looks like so
we're going to use our get property
method handle from before and our print
line method handle from before so now we
want to get a we want a method handle
that every time you call it it just gets
the current Java home or guess what Java
home is set to so we knew that get
property takes one argument a string
we're going to insert an argument into
that method handle at the zero position
just saying Java home and what we get is
a method handle that will always just go
do get property Java dot home without
having to add that argument in yourself
this one's probably a little bit more
useful we want to take our print line
method handle and create basically a
system.out.print line method handle that
always does system.out.print line every
time we invoke it rather than having to
go get the field and then do the call so
we take our print line method handle and
in the zero argument which is the object
we're calling against the print stream
we insert system dot out and then we get
a method handle that every time we call
it it immediately just goes to
system.out.print line for us
here's SC I mentioned the invoke with
arguments a little bit simpler way of
doing the call so this is always going
to be the get property Java dot home and
this invoked oops
and the second invoke here is always
going to be doing system.out.print line
yeah front row
all right so the question is is this
just a convenience or is it actually
optimized Amol doesn't do a better job
at the JVM this this all actually does
optimize at the JVM level so after doing
all of these transmutations here
everywhere that you're going to call
against this handle it'll look as though
look to the JVM as though you've
actually got system.out.print line at
that point in the code so it allows you
to have a function that the JVM can see
all the way through but you can still
pass it around as an object sort of like
java.lang reflect method that's that's a
big goal of this is that unlike
java.lang reflect stuff the JVM can see
through it and can optimize it directly
good question
all right so filtering an argument I
mentioned making a modification to
arguments as they go through so now it
turns out that that what we actually
want to do is check min math dot min of
divide of the half half of what a is we
want to divide it by two every time so
what we can do is we can filter it and
instead of passing whatever a argument
and B argument it'll be a divided by two
and the B argument passed into this
that's what a filtering an example of
filtering so we'll continue with our
other examples here we've got a little
function object that basically turns any
string to uppercase okay this is this is
what we would do if we were going to
write it in Java up here at the top we'd
have our little upper case of fire class
and we pass strings into it and it would
turn them into uppercase for us a little
utility function and now obviously if
you're going to write every one of these
little utilities as a Java class we'd
have a thousand little tiny Java classes
it's much easier and more efficient and
simpler to just use the method handle
API build our little function objects
with that so let's take a look at what
that looks like we want a to uppercase
method handle that will always uppercase
the string it's passed so we're going to
find virtual on the string class to
uppercase method and since we're calling
it against itself all it does is return
a string because it's a fine virtual it
knows that there's going to be a self
argue
past in the current string object
alright so now we're going to make we
could turn this into just object an
object so that we can pass any arguments
into it that's a little bit of a detail
there I won't go into so and then we
wanted to actually tie this into our
print line method handle so I want a
print line method handle that always
goes to system out and always up cases
whatever argument you pass it all in one
handle one one function object so up
case print line method handle we're
going to filter the arguments filter the
arguments being passed into system out
print line using our to upper case
handle and then the result is a print
line that will always go to system out
and always upper case it's argument when
pass through still all in one one
function object and optimizable by the
JVM and I know this is dumb down low
here but all that is at the bottom is we
call it and it prints out the uppercase
version of this string so you can see
how we kind of start layering on more
and more utilities in here rather than
having to generate bytecode for this we
can programmatically build up some
function that does lots of different
argument manipulations lots of different
extra calls and have a still have a
simple function object that JVM can
optimize all right
I mentioned folding as well so we want
to actually compare a with a over two we
want to just be able to pass one
argument in but be able to compare these
using the min function and we don't have
to have to pass in a over two every time
so we can actually pass the a argument
into this function fold function take
the a over two value insert it back into
the argument list and the fold is a
little bit more advanced than example
there are some examples in the the
repository if you want to take a look at
them but we won't go into detail with
that well go we'll move on to flow
control at this point so a lot of times
what you may have is there's two
different method targets that you want
to call based on some condition now you
could have your own piece of java code
for every one of those cases or you
could generate some byte code that would
do that logic for you but you can all
so do this as part of the method handle
API the the guard with test manipulation
here takes a test branch or a test
handle that basically returns boolean
passes all the arguments in does some
calculation and returns a boolean and
then a true path and a false path
another version of this is the switch
point have examples of both of these the
switch point is just an on or off branch
so it starts out going a true path and
then eventually you can switch it to the
off branch and the JVM optimizes it in a
kind of special way so branching based
on a test so we've got a test at the top
we're gonna do an equals comparison of
two two values two keys if it turns out
that they're equal we want to print out
yes if it turns out they're false we
want to print no and all we do all we
need is the three handles for printing
yes printing no and the Equality test
and we can bind them together with this
guard with test so we've got an example
of this here's some example Java of a
little utility function we might write
so you know our in our world we want to
kind of randomly confuse people about
whether strings are uppercase or
lowercase so we've got this little
utility that randomly will uppercase or
lowercase a string perhaps we've just
been fired and this is our last week at
work and we want to try and confuse all
the other developers that come after us
we could do this we could write this
code and sprinkle it into our code base
but you know it'd be much sneakier to
actually use method handles for this so
let's create this we've got our there's
a random boolean function here that's
not shown here that basically just does
random boolean whatever whatever the
call is on random to get that so here
we're going to get a static method we've
created this ahead of time the static
method called random boolean and it just
randomly returned true or false so we're
going to combine that with our to upper
case and to lower case method handles
you can imagine at or lower case that we
have we would have done off-screen here
somewhere so the test is up or down
always going to return a boolean value
the true path
is going to uppercase this string and
the false path is going to lowercase
this string so now we have in hand an
object that every time we call it it
will randomly uppercase or lowercase the
string we give it now we can combine
this again with our system.out.print
line method handle just using the same
filter logic we did before and now we
have an upper downer randomly upper
downer printer that will print out the
system.out.print line
randomly the uppercase or lowercase
version of the string all still
optimizable by the JVM and all still in
a single function object now I mentioned
the the switch point which is kind of a
branch that can only be turned off and
what this is you can kind of thing if
you try to think of use cases for this a
typical one is do I have if I have some
data cached is it still valid I would
like it to be as fast as possible up
until the point when that cache becomes
invalid and then I want to switch it off
and say go back to the original data
store recache that data so that's a
typical use for this and the JVM is able
to optimize that true path almost as
though there's no boolean check almost
as if there's no cash check at all you
can hit that as as fast as you can
there's only like one extra in assembly
instruction inserted into the native
code until you flip it off once you turn
that that switch off it goes back to the
default path you can recalculate and
update your cache again so an example of
this this one's a little bit more
illogical we've got our our upper case
and lower case or basically determined
based on a switch so at some point we're
going to flip it from doing uppercase to
lowercase so this is what the Java code
might look like and this is logically
pretty similar to what a switch point
does internally it has a volatile on
value that's checked all the time and
you can only turn it off now if we're
going to do this in the invokedynamic
api's we create a switch point and this
is our handle to basically turn that
boolean check off or turn it to false
we've got our switch point upper lower
switch and it's a similar guard with
test method except that only takes the
true path and the false path and the
true path will be called until it's
turned off so you see the first two
calls here it uppercases them we use the
switch point invalidate all method to
turn these switch points off and from
then on it will only do the lowercase
version so again cache invalidation when
it optimizes at the JVM level it
actually is kind of it's much faster
than volatile actually uses JVM
optimization D optimization tricks to
make this a very fast check you know it
comes into play more with some of the
dynamic languages or if you're building
an interesting caching system there are
exception
like in here for exception handling I'm
not going to go through a detailed
example of this but we have if we got
some handle that we know does something
dangerous it may throw an exception we
want to deal with it we can actually
handle that as part of the method handle
API and this is actually a really cool
really cool thing because normally with
java.lang reflect method you'd be
getting all sorts of exceptions out of
it they'd be wrapped up everywhere
you're gonna call this you'd have to
handle them differently if you know what
logic you want to wrap around this
function call for a particular exception
you can wrap it with another handle that
knows how to take care of that exception
logic and recover from it properly or
report it to a log or something like
that okay so that's the method handle
API and like I say that's the more
concrete part that's the one you can
play with from Java code actually see it
work try it out on your own libraries
and and have it in hand the byte codes a
little bit more intangible so so we'll
go into this for the the last half of
the talk all right so a little JVM 101
JVM has about 200 out codes in it
10 or or depending on how you count 16
of these or what I would call endpoints
and what do we mean by endpoints well
endpoints are essentially anything in
the code that
is like the terminal point of a call or
a terminal point of an invocation you
might be getting arguments you might be
passing passing arguments through but
eventually you're going to have to do
one of these things to actually
accomplish something in the JVM you're
gonna have to make a method call
somewhere you're gonna have to set or
get a field somewhere or you're gonna
have to get something in and out of
array if you never did any of these
things no one would ever see anything
your program does so I kind of call
these like the real functional end
points of the JVM and pretty much all
Java code revolves around these end
points everything else is just just a
overhead stack manipulation local
variables flow control all this stuff
all of it just sort of funnels data
through to one of the endpoints that we
have available some of the problem is
that the JVM specification before Java 7
recommended to find these 200 op codes
and that was pretty much what we were
stuck with if you needed something above
and beyond what those byte codes
provided like a dynamic invocation for
example you're just kind of stuck and
there was no way to do it so that was
where jsr 292 the invokedynamic jsr came
in user definable byte code with a lot
of freedom to define what the JVM is
supposed to do at that point Plus this
whole API of method handles method
pointers and adapters that you could
wire it all together with so you get a
byte code where the JVM asks for your
method handle chain and you give it back
it knows how to optimize it directly all
right so let's look at a few simple
pieces of Java code here we've got the
four different invocation types so the
static methods at the top some virtual
methods interface invitations and then
at the bottom special which you know
most people don't notice isn't really
any different but super calls private
calls and constructor calls are all
considered invoke special and these all
boil down to four existing for classic
invocation bytecodes invokes static
invoke virtual invoke interface and
invoke special and like I say these are
the only ones you really had in kind of
had to find your own way to rig up other
types of dispatch
multiple dispatch or dynamic dispatch or
anything else and the funny thing that
you realize once you look at these a
little bit more closely is that all four
of these operations largely have the
same set of operations there's four five
six six things that they all do that's
very similar from funk from invocation
to invocation most of them check that
we've got the right type of object in
hand they'll check if you've got the
right arguments if it matches up with
the target method we're calling probably
do some caching and optimization
internally and then eventually invoke
that method now it will be nice if we
could just re redo these pieces and
insert our own logic into this process
or take a piece of this logic out and
that's largely what invokedynamic was
intended to do it gives you that
invocation entry point but you can
decide how to wire up all of those
intermediate steps different ways of
doing the method lookup different ways
of checking the argument types and so on
we look at this a bit more graphically
look at it guys it's kind of like a
switchboard so up at the top we've got
our invoke dynamic byte code a call
comes in the JVM reroutes that to a
bootstrap method which is a piece of
code piece of java code that we've
written that knows how to handle this
particular invocation the bootstrap
method does the method handle
manipulation you saw earlier wires up
some particular sequence of method
handles and calls argument manipulation
and so on that represents this
particular call that gets passed back to
the JVM as the target the the Cawley
that we've been looking for and then at
this point the JVM can actually dispatch
straight from the invoke dynamic byte
code to the method handles it doesn't
have to go through this whole cycle
every time it does it once you wire it
up and from then on it's a straight on
dispatch to that method handle chain and
even better all the rest of this just
fades away and as far as the JVM is
concerned this is now like a direct java
to java call and it can optimize it that
way all right so now actually putting
these two halves together putting the
byte code side with the method handle
side will take
look at some examples here now the tools
I'm using hopefully not most folks know
object webs ASM library pretty much the
de facto standard bytecode manipulation
library that's available today and
actually in JDK 8 is going to be rolled
and an internal API because they need it
they want it for internal stuff I'm also
using jet script which is sort of a Java
DSL for doing byte code generation
little less cumbersome a little little
less verbose than doing ASM directly
you'll see some examples that'll show
how kind of kind of nice and clean and
invoke binder is an API that I wrote
that wraps the method handle logic
making it a little bit more fluent a
little bit more human to do that
sequence of argument manipulations and
other transformations ok so the first
example we'll have is just trivially
binding a method to an invoke dynamic
byte code okay so the one class I didn't
talk about yet is call site and call
site is basically just a holder for a
method handle it's something that the
the bootstrap method gives back to the
JVM to say here is a representation of
that call with a method handle all set
to go in it and then that's how the JVM
decides all right I bind this side to
that side then I do my invocation I can
do my optimization through there all
right our first example this is the
function that we eventually want to call
yeah upfront yes so at the bottom here I
say constant mutable or volatile
depending on how depending on how you're
doing that invocation depending on how
you want to wire up that invoke dynamic
byte code you might want it to always go
to the same target which would be a
constant call site you might want the
target to change perhaps depending on
the arguments coming in or the type of
objects being called against which would
be mutable you need to be able to change
it over time and then there's volatile
which means that you want that change to
be immediately visible across all
threads as well so you can change the
method that's being called and no any
thread that's in the process of doing
that invocation is going to see it
immediately a lot some examples of
constant immutable here
so this is the function we want to call
the foo method here is just going to
increment a counter and print out hello
world number one number two number three
and so on so here is a little bit of
jate script we're going to create a new
runnable class we're generating a
runnable class as raw bytecode and the
Jade script here in the middle allows us
to kind of just use the the JVM bytecode
z' as functions so we're going to do an
invoke dynamic the invoke dynamic is
going to you have the the method name it
that it's calling against as foo it
takes a string or it returns a string
that's all it does and then we've got
this ASM handle which I'll get to into
in a minute that's how actually how it
finds the bootstrap logic once we've got
that string we'll print it out in return
you'll only see this once because it's
kind of cumbersome and it's part of the
the ASM API this is basically how you do
a method handle that's going to be
emitted into the bytecode directly
rather than as an object at runtime in
our case it's just a simple bootstrap
method it returns a call site it gets a
lookup invoke dynamic passes a lookup
object into you that basically limits
what you can see as far as looking up
methods the string will be the Foo
method name and the method type will be
that it returns string just as we saw in
the bytecode before so this is our
bootstrap method and this is what the
JVM will call the first time it
encounters that invoke dynamic it
returns it returns a call site takes a
lookup string name and the method type
just like I showed in the in the
previous slide and what we're going to
do here is we're just we've only got one
target that this call is ever going to
bind to so we're going to return a
constant call site it has to be
initialized to the method handle right
away and it never changes and we're
gonna find the static method with that
name foo on our current class and so at
this point the JVM has everything it
needs to turn that invoke dynamic into a
call directly to the foo function and it
will optimize it as though it were
written that way in the Java code even
though it was dynamic
looked up at run-time so our first call
this one actually will hit the bootstrap
and you can see it step through the code
all subsequent calls go straight through
to the foo method alright so the second
example is if we actually want to be
able to change what methods called at
run time perhaps at the dynamic dynamic
language and depending on which target
object it is there's going to be a
different method to look up so we're
gonna use a mutable call site to
basically just switch between two
targets for this simple example so
instead of using a constant call site we
use mutable call site that's the call
site we give back to the JVM and then
we're able to change it at runtime from
one target to another and the JVM still
sees it as doing the normal invocation
all right so here's our two methods that
we're gonna call we've got a first
method that prints out first and a
second method that prints out second and
there's some details here that I'll show
you a little bit later here is our
actual bytecode and the one we want to
invoke the first time is the first
method so invoke dynamic first these
don't return anything and we've got it
wired up to our bootstrap we'll skip
that one so here is the actual mutable
call site bootstrap again same signature
for the bootstrap logic but this time we
create a new mutable call site and the
first time it's called we want it to
just do the the first method and that
would be the one that was passed in here
so this is the name for the
invokedynamic
passed in here we look that up fine
static and the additional fund here the
little detail here is that we're going
to pass in the lookup and the mutable
call site as well because we want that
first method to be able to switch it
back to the second and the second method
needs to be able to switch it back to
the first so we're adding in some
additional arguments we insert those
arguments here so it actually has the
lookup object and the mutable call site
set that target and then return it now
the JVM will go ahead and
dispatch and the first time it goes
through it'll call the first method and
here's the here's the version with
invoke binder a little bit simpler to
follow here the signature is void we're
going to insert at the zero argument
will look up in the mutable call site
and then do the invoke static on our
first method so let's take a look at
first so now rather than just returning
void and taking no arguments it's a
little bit different than it looked
before it takes that lookup takes that
mutable call site and the first thing
it's gonna do is it's gonna look up the
second method it's gonna switch to the
other one change the target so that it's
second and then do its logic so we've
got our printing out of first here at
the bottom the second version is almost
exactly the same except that it switches
back to the first call and so both of
these basically just go back and forth
bouncing between the two methods each
time changing the call site to point at
a different a different target all right
so the last example here we're actually
going to take this all the way to doing
a little a simple scripting language
that does dynamic dispatch dynamically
looks up methods at runtime so here we
are with our stupid script language it
has very few operations I'm sure it's
not Turing complete but we'll walk
through the walkthrough because it's a
nice little example so the the main
operations here we can push a string on
to the stack we can do a call with some
number of arguments which will pop those
arguments back off the stack and then we
can define a function that takes one or
two arguments as well there's also one
built-in function already there for you
the print function which just does a
since the system.out.print line so our
implementation I'm not gonna walk
through all of it because there's a lot
of parsing details there's a little bit
of compiler details we'll look at the
key parts but it is again all in that
repository if you want to look at a very
stringent ation of a dynamic language
using invoke dynamic so here's a simple
script in stupid script push hello world
push print do send that takes one
argument so it pops the method name off
the stack pops the one argument and then
goes out and figures out what print is
supposed to do a little bit more
advanced example here defining a holo
method that does that for us and then
invoking it and there's our actual call
to the holo method doesn't take any
arguments so we push the name of the
function send with us with no arguments
and it will do our holo call here is the
main body of our stupid script
interpreter it's so stupid it only looks
at the single file on the file system so
it looks up this file it'll run it
through a parser which it's it's pure
genius it uses only string dot split
it's it's a it's amazing parser I don't
write parsers so that's that's the best
I'm going to do for now and then it
evokes the compiler to produce a
compiled running part here we're
switching on the different types of ast
nodes that have come out of our parser
if it's a push we're just going to do
the JVM level push of that value if it's
a def zero we're gonna compile a
function definition that takes no
arguments if it's a def one we're gonna
do a compile that takes one of a
function that takes one argument now the
interesting one is actually the send the
dynamic dispatch here so depending on
what value is passed or what value is
passed in for the number of arguments we
parse that integer we know what the
arity is how many arguments to pop off
the stack now in this is a little bit of
detail we've got the always going to be
called on the current object so we pull
our self object off the stack and then
we have our invoke dynamics here so if
it's zero arguments we're gonna do this
send that returns void takes that takes
the method name and just and and the
object that we're actually calling it's
our self the other version it takes an
additional argument for this string
popped off the stack so two different
invoke dynamics and they both use this
dine line bootstrap and that's where the
magic actually happens that's our
bootstrap method that figures out what
function to call so here's our bootstrap
very similar to the ones that we saw
before
we're passing in the name again whatever
the function that is that's being called
so this is using invoked by invoke
binder this time again what we're going
to do for the first time we're just
going to GU bind it to our send
implementation which does the actual
dynamic method lookup now here's our two
built-ins nothing too fancy there and
then the final piece here the
interesting piece is actually figuring
out what the method is we want to call
so we've got our send implementation it
takes it takes as arguments the name of
a function and our our self object our
script object if it's print well we know
we want to go directly to our print
object for our print function on the
stupid script class so that's an easy
one if it's not print it's not one of
the built-in functions that we've got
available we need to look it up and we
do our we look at our self class look at
the script object itself using that name
find the function bind it in to the call
site down here and we've got our dynamic
invocation for stupid script all wired
together with just a few instructions
from invokedynamic alright
so I know there's a lot to follow
through you can take a look at this in
the repository and and see all the same
code and feel free to ping me or email
me about this stuff too I would
recommend if you want to look into this
stuff more and you're not quite at the
level where you want to implement your
own language start playing with method
handles it's a very simple way to get
into the API they're actually going to
be used for a lot more in the future
they're used internally for the Java 8
lambda support they're going to be used
for additional JVM features if you want
to get into the point where you're
generating invoke dynamic the look for a
JVM bytecode for dummies it's a talk
that I gave on how to do JVM bytecode
generation all the details you need to
know about it and of course you can look
at the code and see how I'm actually
doing it for stupid script and feel free
to ask questions I am willing to answer
any questions online or grab me at the
conference or if you see me anywhere
else
that's all I've got thank you all right
ah right okay so I don't think I have
that the question is can I show where
the functions are actually being defined
and that is kind of that was kind of
brushed under the carpet here but let's
actually go to the code directly we've
got plenty of time to take a look at it
you can just do this live all right
let's bring it up
okay go away where is it
sometimes the mac mirroring does unusual
things with windows gather that is come
back
Oh what is this guy down here
whoa well that was a strange thing to do
with it alright so now we can actually
open this project up and I should yeah
exactly
Indy deep dive there we go okay so we'll
go into our stupid script logic here so
there is the code that I showed before
that just does the parsing and the
compilation will go step through the
compile here that part is not as
interesting as this one and okay so
defining a method here deaf zero and
deaf one basically just calls back into
the compiler at that point and says
create a new method with this name so
passing in the node argument and the
node children argument is the name of
the function and the children are all of
the the elements inside the function
body and that does this is a jate script
logic define a new method create a new
method in the bytecode it's just going
to be public it's going to have the
standard signature of either one our
zero arguments or one arguments with
this name the jet script logic for
creating a body of code create a new
code block load all the arguments that
we've got coming into this function and
then go back into the emit again and
then emit the next level of byte code
for this body of code and then
eventually a void return and then of
course the emit is what we saw before it
goes back into push send and so on so a
pretty trivial to actually just create
that all it needs to do is say jump out
of the current method we're defining
start a new one go back through the
compiler cycle and then back off again
and we continue from where we were so
it's actually just straight down in the
code
the stupid script is pretty stupid so if
you define two functions with the same
name
it'll-it'll happily do it but when it
tries to load it the JVM level I don't
think it'll be too happy it'll actually
blow up when it loads the class we run
back here
right so I was using method handle going
to increase performance one of the
primary goals of method handle was that
it would be faster than java.lang
reflect method at the very least which
is you know not not a huge goal it's
pretty slow and I believe on recent
builds of Java 7 and on the the Java 8
bills that are available that is the
case now finally it's taken a while to
get there taking a while to get the JVM
to actually be able to see through
method handles and optimize them well
it's that is the intent and depending on
which version of Java of Java 7 or Java
8 you're running on that will be the
case but it something you can't have to
test for yourself to see if it's
actually faster yet when you do it with
invokedynamic however it is definitely
faster the main reason why it isn't
faster in general is because the JVM
kind of has difficulty optimizing a
chain of method handles that's getting
passed all over the place
whereas with invoke dynamic of its chain
of method handles that goes to a single
call site it's all anchored there it can
see straight through it and it optimizes
it a whole lot better so it's getting
there for general purpose use but the
goal is that it would be basically as
fast as just having a generated piece of
java code in hand up front here
all right so the question is once you've
got that call site bound up the JVM can
go straight through
what's the mechanisms that it's using to
do that internally the implementation of
how it does that is kind of changed in
versions of Java seven before update
forty all the method handles were native
code and so from a call site through the
method handles to a target the the JVM
JIT actually had to have special case
logic to know it's this kind of method
Handler to that one and then it would
emit it into the native assembly code at
that point you could see that in the
assembly dumps but there would be no
other way to see it in u4t and in the
java eight side of side of things the
the the method handles actually are just
JVM bytecode internally it generates
little stubs all along the way that it
can optimize as though it's regular Java
calls and I think there are some hidden
flags that you can set if you look at
the internal implementation of method
handle there's something called a lambda
form you can trace that through in the
the jdk code base and there are some
flags you can set that I believe will
dump out the bytecode it's creating for
this normally shouldn't need to worry
about it because there's gonna be quite
a bit of bytecode that you're gonna see
it dump out behind the scenes but it is
actually doing that now yeah
correct so they just ascension that
those properties are in the java.lang
invoke method handles you can look at
the source for that and see how to turn
on dumping for what the method handles
are but actually generating internally
over here
yeah so if you're using an obfuscator
like ProGuard does it have the same
problems as with reflection of seeing
methods yeah so the invokedynamic you're
gonna have the same sort of dynamic
dispatch problems you do with reflection
or with a dynamic language a static
analyzer like ProGuard is not going to
be able to see through those and
necessarily know which method you want
to call there's it's possible that with
the java 8 lambda stuff where you can
actually get method references that
might be a way to more statically bind
the the dynamic call sites you can
actually have a method reference that
shows up in code that ProGuard had
actually be able to see that turns into
a method handle then that you can use
for dynamic calls but right now there
would be no way for you to statically
get a method handle in a way that that
static analysis tools to be able to see
it yeah
a way to identify annotated methods with
this no see that's one difference that
had this has with reflection the method
handle API is intended to give you
basically just an in vocable object
there's almost no metadata that comes
along with that to say you know what
class this came from what annotations it
has on it what argument names it might
have none of that stuff is available in
the method handles API you'd still have
to use reflection to get access to that
is there a way to connected both
together yes there actually is on the
method handles class or on the lookup
class I forget which one it is there is
a method called unreflecting a method or
a field and turn it into the equivalent
method handle so if you've already got
some reflection logic and you want to
switch that over to be using method
handles that's a quick way to start
doing it over here
if you're not using dynamic invocation
before what would be a scenario to give
this a try
well like I say playing around with the
method handle stuff is a quick way to
get into the API and that's where the
bulk of the fun comes from the invoke
dynamics side there are other types of
dispatch that would be interesting like
calling a different method depending on
which arguments are passed the JVM
doesn't really do that it's statically
picks a target that it's going to call
at a given call site when you compile
the code but you might want to say if
it's a string argument call along this
path if it's a list argument call along
that path the caching opportunities that
I mentioned if you had for example a
very expensive data structure that you
wanted to calculate only once and then
optimizes though we're like a final
value at that point you can omit invoke
dynamic code that will create that
structure once bind it forever to the
call site and then it's really fast from
that point on you can do it all
dynamically at runtime but it's still
optimized as really well though those
are kind of the key examples and if you
look through it if you look through the
the code base that I have here some of
those might kind of be reminiscent of
things that you do in might be doing
generating Java code for generating
little function objects for might give
you some ideas of what you can do with
it
other questions yeah
mm-hmm all right so there any plans to
expand the lambda stuff to be a little
bit more like a like an eval or treating
data code is data and so on not that I
know of they they've largely treated
lambda as a static way of creating you
know logically it is anonymous inner
classes under the covers it uses invoke
dynamic and a lot of other tricks to
optimize well maybe some of you saw
Brian gets his talk earlier it goes
under the covers to show it actually is
happening there but it is still intended
to be a static feature for Java that
said there are a number of JCP community
members Java fans and some of the lambda
folks themselves that would like to see
Java gain uh at least an escape hatch
for doing dynamic invocation and
possibly looking at you know what would
it take for us to put something like C
sharps dynamic type into Java or other
ways of kind of an escape hatch from
static typing so it's possible it's out
there but there's nothing that's being
worked on at the moment that I know of
and that looks like it's about 2 o'clock
so thanks very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>