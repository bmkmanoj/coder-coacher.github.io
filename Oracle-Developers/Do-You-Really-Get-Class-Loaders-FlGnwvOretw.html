<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Do You Really Get Class Loaders? | Coder Coacher - Coaching Coders</title><meta content="Do You Really Get Class Loaders? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Do You Really Get Class Loaders?</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FlGnwvOretw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">with three days into Java 1 I'm sure
your brains are about as saturated with
content as it can be so so let's let's
try and improve that by throwing more at
you
this is Java class later do you really
get Java class loaders my name's Simon
maple I work for a company called zero
turn around if you wanted to follow me
on Twitter I'm @sj meatball
so I ran quite a bit on that so Who am I
xib Emma of around 1012 years doing a
websphere application server development
and you WebSphere users in the past
happy WebSphere users come on one two
IBM a--'s okay so I used to work from
versions for of WebSphere up to version
8.5 and also the new Liberty profile
which is an awesome awesome cool
addition now I'm the Technical
Evangelist for zero turnaround happily
married little boy he's two and a half
he keeps me very busy when I'm not
traveling the world so we're gonna start
with a bit of light-hearted fun and
they'll give you some clues to a film
and if you think you know the answer as
to which which film this is describing
shout it out so in this film in the
first five minutes there are 400 murders
Saving Private Ryan no there is a
kidnapping as well in the first five
minutes a shark attack Donald Duck was
that
a shark attack shooter nope a near
electrocution jaws and their suffocation
Finding Nemo there we go
how's that yeah I think I've watched
this film about five hundred times with
my little boy now I always skip the
first five minutes okay let's get into
the topic so the reason and the reasons
they're a turn around over have
presented this this topic for about
going on six years now it's always a
really popular topic is because of Jay
Robin in in creating a product like Jay
Rubin which has really really deep
connections in the class loaders we've
learned a lot about class levels more
than any sane person should ever learn
about class learners there's been a
whole load of integrations particularly
with application servers so websphere
application server for example has over
250 class loaders and we've had to
integrate durable in all of these class
loaders doing a lot of bytecode weaving
so this is where this session has come
out from and this is what we're gonna
talk about today we'll start talking
about the basics of class loaders the
class data API how you would use it talk
about some of the issues that you will
see in class loaders when you move into
the kind of enterprise world then we'll
look at some problems and solutions so a
whole bunch of exceptions as to what you
might see some of them look like obvious
class lighting issues others look like
just random exceptions and even funny
exceptions I'll show you my favorite
Java exception and we'll look at how we
can diagnose that how you how can you
find more information about what that
exception is and potentially how to fix
it and we'll talk about leaking class
loaders as well so we'll start off with
the basics then who's used the class
loader API before so to create a class
directly okay not many that's that's
that's a good thing because while the
class library PII is it can be you know
reasonably simple you should only really
use the class letter API if you if you
absolutely have a need to it's not it's
not the kind of thing you would you
would just you know use in everyday code
typically when you when you want to load
a class you do it you do it implicitly
right this is this is how you would
actually load it explicitly so on the
class letter API a low class would
define class both provides you with that
with a class object you pass in a string
to load class load classes is pretty
much the most well used method on the on
the class library PI you pass in a
string and the string is your package
name as well as your class name and if
the class loader has it on its has this
caller class can find this class on the
class path it will return you back a
class objects that you can then
instantiate the defined class is very
similar but rather than the the class
that they're looking on your ap looking
on the class path for a specific
resource or class you actually pass in
the byte array of that class and it will
load from from that parameter not really
used as much as load class now get
resource and get resources are really
really cool methods basically they're
used for data gathering so if you have a
class on on your class path and you want
to get information about that you might
call get resource and it'll pass you a
URL of where that resource is located on
this class path get resources will get
you an enumeration so it'll give you a
full list of all the classes it could
find and get parent really defined the
structure of class loaders at runtime
class loaders are very hierarchical so
typically a class will prefer to go to a
class loader will prefer to go to its
parent first before trying to load
locally there are typically many many
different levels of class loaders and
the idea is it's nicer to load classes
from the highest class loader you can
find rather than loading them in all of
the the lower class class notice that
we'll see some problems as to what would
happen
if you did you know do the the the
format the latter so get parent is a is
a well used one as well so example zero
the basic example when you're trying to
load a class in this case we're trying
to load Class B we will load a class
when it's the first time you'll you
actually see it and the first time
you'll come across it in this scope so
for example which class loader here is
going to load Class B Class A that's
that's the correct answer it all depends
on scope okay so that the the the class
light of that loads Class B is going to
be the same class loader that loaded the
class in which this this this reference
to B it is inside so in this case Class
B is in the scope of class a so we're
going to go to class eighties class
loader first and effectively make a call
to say a get class loader dot load class
okay this is an important this is an
important part as well
every class has a link to its class
loader and every class loader has a
reference to its to every class that it
creates I'm sure I'm gonna fall over
very soon on this so so please do you
take a photo and tweet it if if ID okay
so this is implicit class loading if B
was to then be loaded by some you know
entirely other class sorry if a
reference to B would be you know
somewhere wildly different and the class
that hasn't seen this class before it
would itself need to load B as well so
you could have multiple multiple B
classes being loaded in different places
by different class loaders okay
so that's fairly straightforward and
what would typically happen in a java SE
style environment is if you were to have
if you were to have a hierarchical class
loader so you have many class loaders
which each have parents you would
typically always call get parent first
before looking on your local class path
so essentially you go right up to the
top till there is no other you know
parent for that class loader and you
will try to load the class there if that
class loader can load then it will
return the class and it will turn it all
the way back down the call stack and you
get your class if it can't find the
class on on your on your class path then
it will go back down the stack and and
try the next one so in this case if you
just imagine this is a diagram of class
loaders and we tried to make a request
to load a class here either implicitly
or explicitly we will typically go to
the parent class loader so the parent
class letter till we're at the top and
tried to load the class there if we can
load it we load it and everything's good
otherwise we try the next down and try
and load the plus there next down and so
forth that way any of these any of these
class loaders they they don't need to
load at the same class we just have one
class loader here that loads a single
instance of a single type of that class
and everyone uses that same that same
class so that's amazingly
straightforward and simple
so of course life's not like that in
Java EE we have web class loaders so now
these are imagine these are class
loaders for every box here we'll have a
web class loader in each of these Wars
application class loaders potentially
and a container class loader so this is
kind of like our shared class later in
the container right this is kind of like
your tongue Caleb for example in the war
class loaders you're gonna have things
like your your webbing plib you're gonna
have your class's directory where where
you know things are going to exist on
that class path so we have different
class paths and depending on the
container that you're running in you
will either look locally from the web in
from the web class loader or you will
try to go to your parent class loader
first so I'm sure loads of people on Tom
care right hands up Tomcat hey not too
many actually quite a few
so for Tomcat the default behavior is
always to load locally first from the
web in from the web class loader so if I
was in a server in this war here and I
just wanted to
to class I would look in my classes
directory and my weapons lived first
before going up to the to my parent
class loader if I could find something
if I could find the resource in the
webbing flip or classes directory then I
would return that and then instantiate
and so forth if I can't find it that's
when I go to my parent and the
application class part the application
class data will actually go to their
parent as well so it's only the web in
the web class loader that looks locally
first if you're using something like
WebSphere then WebSphere will actually
always prefer parent so even in the even
in the war file here even in this web
class loader it will go to the parent
parent first and then carry on going
down and of course you can switch this
so that you can prefer local or prefer
parent it's typically a switch that is
done on a container so it would be the
web container in WebSphere that you
would make that switch yes yeah so it'll
go so the question was if it couldn't
find so this is this is the case of the
WebSphere example right where we look
for a class here we go up to app 1 up to
container so we're using both the shared
class loader
if both container or of container and
the application class loaders can't find
the class we would then yes go right
back down to the to the web in to the
web class loader and look on that class
parts and we will we will try to look
for the class on all class paths of the
class nodes but just in different
different orders no it would never go to
war - no no sir it's not really because
understand it it's so I guess I guess in
in the in the specifications it's it's
kind of a little bit fluffy as to what
should be the exact standard the reason
the reason both options are there is
because let's say in websphere we have a
a log mechanism here for actually using
WebSphere logging if you
to use a different logger in your war
file okay and you don't want to use this
logger you want to prefer local so I can
include all my extra logging you know
log4j or whatever it is in wrapping in
my in my war file and that way it'll
it'll always use you know those those
resources above its above its WebSphere
versions so that's that's why this has
come about typically if you don't need
to override that it's it's typically
better to to want to always go to your
parent but where you want to override
these resources because of you know you
want to use a different version or so on
JPA is another is another good example
of that
then then you would leave as it is so as
it is in the switch of how the ordering
so so so the quite the question is would
you could can you you can use decide
parent first or parent asks on a
specific class rather than all the
classes in that container the answer
sadly is no any other questions how do
you switch to local to parent first you
do it on the container so they're
typically be a flag on a servlet
container or something like that in in
say websphere or whatever and you'll
just set it to true restart your
container and then then you'll switch
between their the types okay right so we
essentially have covered class letters
have parent class letters until you get
to the absolute system class learner and
classify desire Jess
classes themselves right they're just
classes and objects the parent is
usually consulted first but when we are
in a web module very often local classes
are searched with a higher priority and
every war module of an air will have its
own class later as well obviously if you
wanted to delve into OSGi any OSGi uses
quite a few okay so with OSGi it's
actually quite different where your
class loader is actually on a per bundle
and the class path is defined by you
know effectively
how your how your bundle connects into
the framework with all the other bundles
you know what's available at the time is
built up per bundle okay so we're going
to show you now some some problems we're
going to show you some exceptions and
we'll have a look at how we can how we
can fix them and we're going to have
some some fun questions and see see how
we get on so here I am in eclipse and
I've got no we're not
right here we are in Eclipse so here we
are in Eclipse I've got my my my
servlets here five sir let's test one
two five and in this servlet I'm going
to simply do a very very simple thing I
was gonna when it's invoked I'm gonna
out dot print util 1 dot say hello
youthful one exists it has a say hello
on it so pretty straightforward don't
expect anything to go wrong but life is
not that simple we get an exception and
as exception is no class def found error
has anyone never as a one not seen this
that I'm not saying this this week okay
obviously there's no class on any of the
class loader class pass we've searched
right through the stack of the class
loaders and we can't find this class so
we get this most annoying error so what
do we do let's have a look I can come
here I'm going to comment that out and
what I'm going to do is I'm going to
grab test one and the reason I'm
grabbing test one is because we're I try
and create util one we're in the scope
of test one right that the servlet is
called test one we want to grab the
servlets class loader and we want to
look for the resource test1 so we grab
test ones class loader and we cast it to
a URL class loader as anyone heard of
URL class loaders a couple of people URL
class loader is really really useful for
debugging and the reason is when we cast
it to a URL class loader we can make we
can invoke a method called get URLs and
we'll get you're aware what get urls
provides us with is all the urls of all
the locations of where the class data
looks on the class path so i'm gonna
save this and with the magic of jribble
automatic reload so this is this is the
full list of paths on a class path and
we can see that we have the webbing
classes to see
demo jar and I as I developed the code I
know it should have been in that CL demo
jar so let's go to that jar location
let's go to that jar location here's the
jar if I jar - TV F there we go we can
see that class doesn't exist but we know
exactly what the class load is doing and
that's a really key thing to do when you
get these kind of exceptions and you
want to diagnose them don't try to
eliminate all of your assumptions we
really want to see what's happening from
the class loader level so let's ask the
class loader what it can see and what
it's actually looking at because very
often encode what you think the class
that is doing what you think the system
is doing is actually very very different
to what the system is actually doing yes
sir so yes but the problem is if you do
that the eating the class part the Java
class path is just a flat class path
right so whatever is first on the class
path is what it's gonna pick and you
can't you can't change the mechanism of
or you know order halfway through it has
to be all of one or the other just just
otherwise would go crazy
okay so let's have a look at what we can
you want which tools we can use so what
tools we have at our disposal not enough
classes we get a class nor found
exception or a no class staff found
error what we can do is very often ID
class look up try and find which jar it
should be in and try and add that to the
class path a find star dot jar - exact
charm one of the deliver of the class
path
so pretty much search the entire
universe for that class on your on your
on your machine and then and then add
that jar the the saner way to do it
would be URL class letter don't get URLs
to see you
exactly what is on your class path and
contain a specific logs sometimes can
help okay our next a next test - test -
so what we're gonna do here is this time
going to create util - and we know here
that we can see you till - utility your
classes there on the class path so util
to say hello util - say hello just
returns a string hello so that's what we
should get let's run this and see what
happens this time we get a no such
method error util to say hello so why
are we getting this when we can clearly
see that the method exists the wrong
version of the job possibly it could be
the wrong version of the job another way
another problem that I always had was
that I had multiple versions of that jar
on my on my class path and because the
way Java works with this flat class path
it'll always search and stop at the very
first one okay so the first time it
finds that jar the first time it finds
that resource that class that's the
class it will load and and yet I used to
have loads of fun with this when I was
working as a developer IBM and because I
was a cowboy developer what I what I
used to do is I used to name my my jars
with an underscore sometimes right at
the start because that's always going to
be the highest on the class path for
that directory so there's a so there's a
cowboy tip for you but so what we want
to do now is we want to remove our
assumptions okay so what is the class
loader actually doing so we go back to
our code and what we're gonna do is
we're gonna comment this out oops
uncomment this so what gonna do is we go
to test to grab test tube's class loader
because that is the scope which we are
in when we load util - we're going to
call get resource we know util to exists
on the class path so we know it actually
has a URL and we know that because it
has picked a version it's just not the
version that we compiled against so we
get R is we call get resource and we're
trying to get the resource
of you till to we're replacing dots or
slashes and adding a dot class
so what we're actually doing is that is
getting a full full path to this to this
resource on our on our on our file
system okay so I make that save now
let's rerun our test and here we can see
it is indeed in this in this demo SEL
demo jar jar and it exists in that soap
Ling slash util to dot class so we know
this is the exact class that our class
loader is loading okay
I can I can draw minus x VF sealed demo
util to lock class and if I does
everyone anyone interested in bytecode
here it's a strange question isn't
anyone interested in my kit so does
anyone know how to read the bytecode of
a class file Java P exactly so what I
use is Java P util two dot class and
essentially from that we can see you
know what's actually in this in this
Java class file we can see it's a public
class named util - it has a default
constructor which we get upon Java seen
this this job resource and that's it we
have we have no say hello whatever that
whatever the method name was so we can
we can see yes sir so sorry say again
oh okay thank you so that the the
general is just saying does everyone
here that know so there's a there's a
there's a shortcut for that on the could
you could you repeat the name there's a
shortcut on class and get protection
domain that will give you the same the
same results okay so one of the other
things I'm going to quickly show you is
I'm going to grab you till three dot
class and I'm gonna job app that just
because I know that does have a say
hello method in it so this is what we
actually should have seen and I think if
I do because I'm - see there we go
for those of you who are interested in a
little bit more hardcore bytecode if you
if you job up - see you actually get the
you actually get the instructions of
what's actually happening so in our in
our util through if I invoke invoked
special invokes special is is is method
that's used to to only call constructors
and we have here I'll say hello method
where we're doing a load of the string
hello and returning that string so for
those of you who are interested in that
there's I'm sure there's a good bedtime
read for some of your classes okay right
let's go to test three now now I told
you I was gonna share with you my my
most favorite exception of all time this
is it so here what we're doing is we're
calling a okay we're Java developers
right so there's only one thing there's
only one thing we love more than coffee
and that's that's factories right so
what we're gonna do is going to do the
Java way I'll cool into I'm going to
create a new factory class factory three
and I call instance untyped instance
untyped will return something of type
util three and it's gonna return it as
an object so when we get back in our
test3 code we're going to cast to a util
three and we're going to call say hello
on that resource so pretty
straightforward don't expect anything to
go wrong well we're going to see my
favorite exception
now class classed exception util 3
cannot be cast to you till three no
laughs okay so any ideas why why this is
happening there are two util threes in
the class path no different different
class laters this is a thing cause I
want to have it seen this exception
quite a few when you when you when you
saw it what was the first thing you did
did you just go for a coffee and think
this is way too early for me I'm right
so first of all let's let's watch me
dish we diagnose it first or shall we
so we describe let's describe it first
this is the best one to describe it okay
so this is what's happening we have our
web class loader and we have our shared
class loader so this web class loader is
as you have sinned a jar on V on the web
in flip and on our class's directory we
also have a shared class letter this is
the Tomcat Lib directory so the first
thing we do here is we make an
invocation to try and create factory
three so we look on our class path for
factory three we're a web class loader
running in Tomcat so as a result we're
going to look local first so we try and
find in our web in flip and in our in
our class in our classes directory we
try and find an instance of factory or
class called Factory we can't find it
it's not on our class buff so we go to
our parent yeah parent does have factory
three so our parent loads it and returns
factory three back and you can create
the object and so forth so we then call
instance untight instance untyped tries
to create a new util three class or
nearly util three objects but it's never
seen this util three before so it's
going to load it first now this is the
key we load it because it because this
is this code is in factory three we load
it with the same class loader that that
we use to load factory three which
happen to be
the shared classloader so we ask the
shared class later first can you find
you till three on your class path yes we
can
so we load this version of do till three
from our shared class loader and return
that now back in back in test three we
get our you till three object and we try
and cast it to a you tool three but over
here in this scope we've never heard of
you till three so we're gonna load first
so we go to our web class loader and
this is the this is the key right we're
looking a local first if we'd have gone
to parent would have just we've already
loaded this so we just use that you that
same version of you till three but we're
not we always look local first here so
yes we can find a version of util three
here so we will return that and use that
so we're actually running here with two
different versions two different classes
that have been loaded by two different
class loaders and this is where we get
our this is where we get our exception
why won't why won't this work well a
class has an identity of three things a
class name a package name and the class
loader that loaded it those three things
are key to its identity if any one of
those are different irrespective of how
similar how identical the bytecode is if
any of those are different it will
consider it an entire different class as
a result we'll get a class cast
exception so while the diagnosis that we
kept back whether you know walk that the
message that we get back from the JVM is
absolutely ridiculous that's actually
you know it thinks these are two classes
totally different so that's what's
happening now that's not that's our
assumption ok we need to remove our or
all of our assumptions and try and
understand what is happening in our code
so no not you let's come back here in
test three we're gonna comment out this
line
there we go I'm comment at this line so
what we're going to do is we're gonna
grab test three and factory three okay
those are the two places that are that
are that are using you till three we're
gonna grab them to we're going to grab
the the class loader and call get
resource passing in util threes package
name and class name we're going to do
the replacing of dots of slashes add a
dot class so we can see where these two
different class loaders are looking to
load the same class so let me save that
and rerun our test okay and we get two
different locations so our first one I
think first one was test wasn't maybe
test our first one is actually looking
in the CL demo jar jar and we grab you
till three from there so our first one
is actually invoking this code this is
this is the this is the bytecode that
we're that we're using for the first one
our second one is actually in our shared
jar so this is in the Tomcat Lib just
you know listen to our other class
loader that is using it so okay what do
we do how do we fix this any ideas
you can you can't force it to use a
particular class like a particular class
that you choose but the neater way is
just to remove the fact that there are
two versions right
does it need do you need to have a
version locally if you're actually using
something in your shared class like that
or can you just pull everything do you
need to pull the factory up so the
easiest way to get them to avoid these
is to is to be try and try and be as
sensible as you can in the packaging so
that your your resources you don't have
results is all over the place okay it's
always nicer to go up to the shared
class plot loader as well because
otherwise if you have you know ten Wars
you know you don't want every single war
to necessarily load a certain at their
own classes
if you just use the shared class loader
then you let you load it once and all
the wars can use from that shared class
loader and you avoid the chances of
getting this kind of situation I'm also
going to show you a couple of others
from whatever time not to that I'll show
you a couple of others yes sir to create
two singleton classes it would it would
happen in exactly the same way yeah yeah
you can do it with the singleton class
just as easily as any class really
doesn't matter what it's doing it's just
any class ok so I'm going to show you
test for actually I'll show you test
five test five is a funny one this is
this is the kind of this is the kind of
exception that you get and you and you
start to question your sanity what we're
effectively gonna do now is we're gonna
is we're gonna call factory three and
we're going to we're going to call a
different method called instance package
an instance package is exactly the same
it returns a you till three class as an
object but there is no there is no
public modifier on here this is a
package wide modifier so we have to be
in the same package to call this call
this method we don't have a package
specified here we don't have a package
specified in our in our test either so
we're in the same package this should
work right well let's run this through
we get an exception and illegal acts
era okay so so for what this is telling
us is it doesn't believe these two
classes reside in the same Pat in the
same package okay the reason is we
talked about the identity of a class
being three things class name package
name and their Envy an ID of the class
loader that loads the class packages are
exactly the same okay
package name and class letter name so
effectively it's considering its
considering these as two entirely
different packages and this is this is
the kind of exception that when I when I
get I'd try and just rebuild my
application where you deploy my
application still get the same thing
okay
let's do it again and again and again
after about the fifth time I'm thinking
this is definitely the code that I'm
running I don't understand what's wrong
anyone seen this before yeah cuz of you
and you thought you're crazy right yeah
okay so another another example let's
drop back down to four tests for another
example here is where what we're
actually doing is we're calling factory
three dot instance so there's no cast
here okay so in factory three dot
instance we're actually returning
something of tight util three so that
there is no need to cast that if we
actually run this we just get a
different exception a linkage area this
time okay so yeah there is no class cast
here because we're not doing a class
class cast but they're actually here's a
class cast happening under the covers
you can actually just break that down to
say you know this version of util this
version of you till three I'm actually
gonna cast to my version of you till
three and that's where it breaks under
the covers okay oops
any questions so far yes sir yes as the
judgment in the front mentioned you can
you can actually choose which class like
the loads your class so you can actually
say grab a specific class later maybe
grab the class later from factory three
and say I want you to now load this you
tool three here and then I'll do the
cast there no and then you're screwed
quite plainly okay so class like the
leaks class let it leaks is a really
really important thing because as I
mentioned before class loaders have a
link to every single class they create
and there's a link from the class back
up to the class loader so as soon as we
leak a class loader we're actually
leaking every single class that created
and any static content in that class as
well so I'm sure a whole bunch of you
when you're using something like Tomcat
we'll try and it your kind of republish
is pretty often when a class loader and
a class loader is very well named
because you can only load with the class
there was no unload there was no reload
on the API so what a class has been
loaded when a class has been loaded it's
there for life it's there for the
lifetime of that class loader so to do
your republish in your in your
application what you actually have to do
is destroy the whole hierarchy of your
old class loader so all the objects all
the classes and all the class loaders
and then recreate the new hierarchy with
all your you know class loaders and
effectively then create your new class
create you create all your new objects
and potentially move state from one to
the next and this is oh this is a really
tricky procedure that very very rarely
works which is why after several times
that you try your republishes you get
you're out of memories right you get
your poem Jones and you actually have to
recycle the server interestingly where
the way I was showing you there with
when I was using J rebel to do that make
those changes and see them instantly we
would never actually throw any class
loaders away what we actually do what we
actually do is say I'm going to own an
instrument class loaders themselves I'm
gonna do the reload of the classes in my
Jarl coat so what we're not doing what
we're never doing is throwing away the
class loaders and recreating them so
yeah as I mentioned every single time
you load a class later you could
potentially be shipping a whole a whole
bunch of of different classes and their
state and their and and that can be
pretty horrific let's let's do a quick
demo of that okay so there aren't enough
application servers in the world so we
have created our own and in this
application server what we're doing is
we're going through a while loop so when
I run this we'll go through a while loop
and we're creating a new instance of our
web app in our web app Factory because
the factories are cool right after that
we call web app dot message which is
going to return us some text we
increment a counter on that web app and
then we sleep for a second and then we
carry on doing that let's have a look at
web app very very briefly oh nope not
that we're about here we go so web app
here has a counter message is just a
version one right now and we call plus
plus in our while in our while loop so
we increment our counter every single
time so pretty straightforward
where I am going to also show you is our
web app Factory because we do some
interesting things here in our web app
Factory where is it here you know about
factory when we actually try and create
our instance or the class what we do is
we have this temp class loader and this
every time we look up a new instance of
this class we're actually going to
create a new class loader so we're
effectively
throwing our entire previous hierarchy
of class loaders away creating our new
class loader and then loading a new
class
so every time we goes for that worldly
we create a new class loader we load the
class again from you know the the class
that is existing on our file system and
we invoke so if I was to run this run
first to run this week out version one
equals zero and the reason we're not
actually incrementing our counter is
because we're using an entirely new
class every single time every single
time we go through that cycle we create
a new class loader and a new class so as
state is being lost every single time
but because we are creating a new class
loader every single time and this is
being this is being created from scratch
what I could actually do is change from
version one to version two and then all
of a sudden in our console we can see at
that point about the at that point we're
actually now using our new class so we
can actually make changes and reload
them live almost a little bit like
terrible but you know with this throwing
away of our class loaders now if we
wanted to pull some state from our
previous class to a new class as we go
through the wallet we can we can also do
that but what we want to do is before we
throw away that class we want to grab
its state and copy it across to our to
our new instance so I'm going to let's
stop this briefly so I'm going to go to
interface and I'm going to add a new
method which is a copy method takes in a
web app and in my web app now this is a
great new method of development by the
way this is you've all heard of agile
development this is development via
uncoding it's is surprisingly productive
so what we do in this in our new web app
copy method is we take our old web app
that we get passed in we
grab its counter and we assign it to our
counter so we're just pulling that state
across so the last thing I need to do is
in my app server before I as I create my
new instance what I'm going to do is I'm
going to call copy passing in the
previous instance and save that so now
if I was to run this now we got our
increments and just just to show you
that we are in fact throwing that away
still I can even change my version back
to version 1 and there's our new version
of our of our class continually
continually updating with the state now
this is all very well and good but it's
not always this simple to kind of you
know make these changes and update that
live like you know with these with these
Tomcat Ori publishers because very often
there's a leak and this leak is going to
be very aptly named as leak sadly it's
not normally as easy as this to work out
where the leak is but I'm going to
create a new method called leak and what
we're going to do is every single time
we copy state from one class to the next
we're actually going to call a leak
method which makes which holds a
reference to the previous to the
previous class so now we've got a
reference all our previous stuff can't
be garbage collected and you'll notice
that in my app sorry here it is in my
web app factory class we have a cache
which is quite a big number and this is
going to this is going to be reflective
of the number of classes static classes
that our class letter is potentially
hanging on to ok so as we leaked our
class loader as we leaked our class we
leaked our class loader as we leaked our
class loader we link all classes that
that class loader has ever created so
let's run this again
and there we go it's running I can if I
am quick enough still change my still
change my version now get and bang I've
done this session too many times I know
exactly where this crashes okay we've
got an out of memory error and we out of
memory error is you know that class line
that we just leaked how can we test this
well we're all awesome Java developers
aren't we so what we actually have done
is in our run config we have added an
argument which says heap dump on out of
memory error really everyone heard of
this quite a few people really really
really useful to have this so that when
your production app server goes down
with an out of memory error or something
that you actually have some indication
of what happened before it died so what
we can do is look at the file that was
created and in this case it was Java
pid' seven nine six six so if I was to
refresh this project as a refresh
refresh we have yeah we have seven seven
nine six six there we go I can open that
using the Eclipse
I think it's called memory manager or
something like that and all of a sudden
in here if I click on no I didn't want
to click that I click on the Dominator
tree at the Dom tree I can now see
everything that was all everything that
was created in my in my in my JVM before
it died and interestingly I can see
what's what's keeping hold of the heap
in this column and I can see that 120
Meg there is is sitting in this in this
class letter and I can dig down
constantly looking at the the number of
the bigger number on the right and all
of a sudden now we're seeing a number of
eight meg Meg objects and if I dig down
a little bit deeper we can see there's a
cache ok so there's a there's a long of
101 million one
yes or another and this is effectively
all the classes that representation of
all the classes that our class letter
has created okay so yeah
Lincoln class loaders is extremely bad
almost as bad or pretty much probably
worse than low blow cleaner than leaking
classes in in your code okay so that's
pretty much that's pretty much the
session takeaway is first of all
validate your assumptions class loaders
are not great for doing what you expect
them to do so always use the use of the
get resource methods particularly in
understanding where what is happening
under the covers the class loaders
actually is pretty much very very easy
and straightforward to do but not very
great isolation yeah isolation is good
for processes but it's the I guess the
one thing that we're not going to have
in Java and also Jarrell rocks okay so
if you found the session fun and you've
learned something please do fill out the
surveys I would love to see where I can
improve where I can't improve where I'm
awesome I always I always love hearing
that so yeah do you fill out the survey
if you didn't enjoy the session and you
want to claim your 60 minutes back if
you use J rebel it's a Productivity tool
you'll get your time back in no time
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>