<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Authentication as a Microservice | Coder Coacher - Coaching Coders</title><meta content="Authentication as a Microservice - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Authentication as a Microservice</b></h2><h5 class="post__date">2018-02-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SLc3cTlypwM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right people will probably start
trickling in but we can go ahead and get
fired up so mmm
this talk is covering authentication as
a micro service and all my talks are
interactive so don't feel like you need
to wait and hold questions to the end
jump in at any time raise your hand
whatever just start talking it doesn't
matter you can interrupt me we can kind
of get derailed and go down you know
paths and cover different topics
whatever you guys want to do so it's
really about you guys today right just
quick background on me so my name's
Brian hunter Ellie I'm the CEO of Umbra
soft I started the company about ten
years ago
I've been coding for professionally for
about 20 years now but I started coding
when I was like eight on an Apple 2e so
yeah that's cool but yet you know I I've
been doing this for 20 years and and
I've worked at variety companies like BA
in Orbitz yada yada sort of cut my teeth
on really big systems back in the day we
are doing micro servers was before it
was called micro services so this is
called service-oriented architecture and
then I got rebranded as micro services
but this was even before that
all right so in the beginning right so
let's start off in the beginning what
I'm gonna do is I'm going to go through
what we used to do and sort of what
we're doing now and we'll talk about
pros and cons of each so the monolith
right so here's a very standard example
of your classic monolith you'll have you
know mobile web doesn't matter and it's
all talking to one massive back-end all
right so here's the database back-end
I I just created a little to-do app as
an example but you know it could be
anything so in this case we've got some
users users might have some roles and
then we have the u2 dues for each user
all right so here's our two views table
pretty straight forwards got text ID you
had a yachtie it's got a foreign key to
users and so that's that's the key here
all right so let's go ahead and login an
old-school style and this is actually
not old-school like a lot of people say
it's old-school it's not people still do
this all the time it's fine but what we
would do is we would hit slash login and
we get back HTML right so that would be
your login form and then what we're
gonna do is we're going to fill out our
credentials and we're in a post and it's
gonna hit the backend it's gonna
authenticate against the database make
sure your user credentials are correct
create a session and then what it's
going to do is it's going to store that
user object in the session and then pass
back a session ID so that normally comes
back is like a cookie right and then
you'll get a 302 redirect to wherever
you're going in the app all right so in
this very classic pattern so then after
we have that then what we do is we go
call slash to deuce all right that's
where we got redirected to and we're
going to pass in with that request the
session ID and so then the session ID is
going to be linked up by the backend I'm
going to go fetch out that user session
we're going to pull that user app object
out of the session and we're going to
use it to go fetch that users to dues
and return all of that as HTML straight
forward this is what our old-school to
do look like right so we're just doing a
select on the table and we're using our
foreign key okay so this this works on
everything a lot of people say is like
oh sessions are old and clunky and you
know it actually it works for everything
and it just depends on how you actually
use sessions but you can use them on
single page web apps you can use my
mobile apps you can basically use them
on anything cookies have been around for
a very long time they're hard to steal
they're hard to forge like this stuff
just works but there's some pain points
with it
it's very stateful so all of our
backends have to know about sessions we
either have to have a big huge cache or
we have to store sessions in the
database and purge them you know you can
you can see that as you scale and you
have thousands and thousands of requests
per second it's gonna fall on its face
right there it's just very challenging
to handle we do a lot of load balancing
we do a lot of session pinning all right
so you'll go through a load balancer and
you'll get stuck to one server
it's called session pinning so that's
that's a lot of the issues as well as
the big database so the classic example
I used to say is a
in the Orbitz days we had one database
for all of Orbitz and I remember when we
upgraded the server because it kept
running out of RAM so we bought a 128
gig of ram and that was in like 2004 and
it cost us almost $200,000 for the ram
so just because we wanted to scale our
single monolithic database so big
problems when you do that anyway so
we're ripping all this stuff apart and
we're refactoring so this is what it
looks like now again simple to do
example what I did is I went ahead and
just broke out two api's so I know I
have a user API and I have my to do API
it's the most basic form of
micro-services this you can even break
this up further if you really wanted to
but I'm keeping it simple alright so
what I did also is I broke out two
different databases I might as well make
each database separate because your user
database might have different semantics
than you have to do database hence the
beauty of micro-services all right so
now we refactor our tables we have the
exact same user tables in our user
database and now our to do database is
really simple just has one table for our
two days right so here's our new to do
table definition and so you'll notice
there's no foreign key so we'll get to
that a little later but we we have to
decouple these things were microservices
so we have to break that relationship
all right so let's walk through how we
manage login with our new microservices
so first thing we're gonna do is we're
gonna post the login right I'm gonna
send that user data and we're gonna get
authenticated against the database we
get our user object the same way we did
before
except we're not going to create a
session right
stateless let's see if we can go
stateless so what are we gonna send back
let's go ahead and send that user object
back is just JSON hmm see what happens
all right so now we've got a user object
is JSON it's got my user ID and my email
address and my roles and yadda-yadda
okay I appreciate forward so now I'm
gonna go fetch my to Do's so I'm gonna
do a get to slash to do's and I'm gonna
send in my user ID 42 sweet it goes and
fetches my city's
and it sends them back as JSON hmm
pretty simple it's just a simple API so
I'm good right okay obviously this
doesn't work and then super broken
because what I'm gonna do is I'm gonna
go change I you know I I can watch his
requests are being made just like the
rest of us right I can see what API is
being called so I just figured out oh
they're calling user ID of 42 well I'll
just put on user ID of 1 right it's
totally straightforward so anyone know
what user ID 1 is mmm or super user root
right admin so yeah we can totally mess
with the admin of this system that'll be
awesome I can go in every morning he'll
put in get milk and I'll just check it
off he'll forget every day you'll never
get milk right so like obviously this is
super insecure but it's sort of the
first evolution of like ok how are we
going to deal with calling these API is
in authentication right so how do we fix
this so first step will generate a token
so rather than passing back a user ID
we're gonna back pass back a token so
there's two types of tokens opaque and
structured and in this case it's opaque
opaque meaning it's just a big huge
string of garbage it has has no meaning
it's really just a big int at the end of
the day and it might be based 64 encoded
or it might be a UUID hex encoded we
don't care it really is just a very very
large number we send that back to the
phone and then when we're doing it to do
lookup we send back the token okay in
order for this all to hook up we still
need the user object because we don't
know the users ID all right it's not in
the token and the token isn't it because
we thought we figured out that was easy
to hack so instead we have to create a
new API on the user system in order to
give us the user object based on a token
so this is called a token exchange give
me a token
I'll give you user data right ok so
there's you know this is happens and a
lot of people write this into their
systems and this has been sort of a
classic token based methodology when we
are going service-oriented architecture
and then micro-services it requires a
user to token mapping probably in the
database my
be in memory you know whatever these get
really chatty so every time you're doing
anything with the user you have to go
exchange the token for a user object so
it's chatty and now we've magically
coupled all of our services to one
service which is our user API so it can
be really cumbersome right it can be
really dangerous this is actually hmm
you know this still happens in the wild
a lot of production systems have this
and it's easy just go look at your
cookies and see if they're structured or
not you'll know which systems have this
solution versus jots and we'll talk
about that in a second but yeah I mean
it's it's this is sort of again a first
evolution or a second I guess now and
it's you know can be there's a lot of
overhead and a lot of issues with it
all right so what's the solution that we
came up with okay well we said okay well
let's make a structured token let's make
the token not just be a string of
characters
let's actually make it have data so when
we go and we authenticate against the
user API we created JSON web token these
are just JSON hmm I bundle it up and I
pass it back to the mobile app and now I
can use that JSON web token to call my
to do API and look the user up pretty
simple so these are structured so to
keep that in mind and they're verifiable
and I'll talk about that in a second all
right so what are they so these these
are just simply base64 encoded JSON just
essentially all they are and I'll get to
the structure and how they all work but
it's JSON so you can put anything you
want in it and it's it some of it is
well defined and then it's free form as
well you can basically put any
information you want in it and the nice
thing about this is they're signed so
we're gonna use either a shared secret
signing algorithm like a CH Mac or we're
gonna use a public key private key
signing algorithm like RSA and what that
allows me to do is it allows me to say
hey did you really create that JSON web
token and this the server will give me
either the shared secret or the public
key and I can verify that it was
generated by an authoritative source
right because it's it's a normal
cryptographic signature
all right so here's what a job looks
like it's broken into three parts and
they're separated by periods okay so the
first part is called the header it's
base64 encoded JSON and it contains some
very well defined pieces of information
the middle part is called the body and
again base64 encoded JSON and then the
final part down the bottom there is the
signature so that's either an RSA or an
H Max signature and that's what allows
us to take this job and verify that it
came from a correct source and hasn't
been hacked
so this basically becomes our portable
unit of identity all right so here's
what the header looks like if I base64
decode that so I have two claims in
there I have no idea why the people that
wrote the specification insisted on
using three characters it's like they're
stuck in like the 80s and like you know
UNIX systems or something but all the
defined claims in the specification are
three characters so the first one is
type this is a JA oh sorry that's
another thing the specification defines
how it's pronounced you pronounced JWT
JA and then in the algorithm so in this
case I'm using RSA public key private
key with 256 hash okay so here's the
body again base64 encoded and JSON if I
decode it I have a couple of well-known
claims so the first one is called issuer
that's basically the thing that
generated this jot expiration number of
seconds since you know January 1st 1970
and that's the instant that this thing
expires so remember we we took all the
bytes from the JSON and then we sign
them so once you create a jot the
expiration can't be changed so it has a
very different semantics than sessions
so just kind of keep that in the back of
your head if I have a jot it will expire
it doesn't it's not a sliding window
which means every time you touch it it
gets extended like a session does it
doesn't work like that it has a very
definitive expiration instant and that's
defined inside the jot and it's required
the audience that's essentially who this
is intended for usually that's like an
application ID or a client ID the
subject Who am I
that's my user ID and then the last two
are just totally freeform I just made
them up so I put in my name and I put in
some roles so this is awesome so now I
can actually put in my roles for this
audience and the application can
actually verify that those are valid and
then use those in code right so I don't
have to go back to another system and
say like hey give me the users roles
it's all part of the job so we can start
stuffing rolls and other authorization
information inside the job so thinking
pretty powerful all right and then
here's my RSA signature just a base64
encoded garbage mmm all right so here's
what the new to-do looks like it's our
the to do select so I'm selecting from
the two news table and then I'm using
the ID that I got out of the job I don't
need to go back to the user API I don't
need to make sure that this job is good
I don't need to do any of that I just
grab the ID right out of it and I use it
for a select and you can pass these jots
anywhere you want you can send them to
your neighbor you can send them over
here you can put them in this server to
sort the data it doesn't matter they're
totally portable all right so we can
look at a little bit of code let's flip
over intellij all right so let's take a
look really quick we can look at a
couple of things but let's look at our
authentication and how we're going to
actually or sorry authorization how
we're going to actually call a to do API
and determine whether or not this user
is allowed to to make that request and
then get the user ID out of that jot and
use it okay so here's a route sorry it
snowed you know some people hate node I
particularly am NOT a huge fan but this
is what we wrote it in as an example
alright so this is a route this is an
Express route inside node and it's just
a slash to do is exactly like I showed
before
and the first thing I'm gonna do is I'm
gonna decode the jot all right so I'm
gonna come in here and I'm gonna to code
my jot and so we are we stick our jots
in an authorization header so it comes
in in the HTTP header pretty
straightforward most people do this the
only difference that we tell everyone to
do over what most people are doing
currently is that for the authorization
scheme we don't use bearer because bear
is a little innocuous right you don't
know it could be you know it could be a
sam'l token it could be a Kerberos
ticket it could be an OAuth token it
could be an access to you don't know
what it is so we're like okay well why
don't we just tell you what it is it's a
job so we use the jot prefix of the jot
schema so some people recommend that you
do this others say and then and I'll use
bear you know I'll leave it up to you
but we like jot it's well defined and
then we just decode it so the decoding
function is pretty straightforward I'm
gonna split it on period I get three
parts out if I don't I'm gonna freak out
I grab my header base64 decode it grab
my payload my body and then I do a
little a couple of checks you can ignore
this code I'll get to that later
and then here's where I do the
verification so in this case I you know
have an RSA public key private key in
this case I have my public key so I'm
gonna grab it out and I'm gonna verify
that the jot is valid using that final
piece of it which is part two and these
are all open source pardon me libraries
you can go grab them all right so if
it's verified I'm gonna go ahead and
decode it
check my expiration date down here
I might do a not before check this is
another well-known claim you can say
this job will be good later not before
and then when I'm done that return it so
pretty straightforward it just comes
back as JSON as in Jace you know just an
object in JavaScript so if I hop back
out okay that was my decode method hop
back out again so in this case what I'm
gonna do is I'm gonna use the JA to see
whether or not this user has a specific
role can he retrieve his own - duze
right no stupid role but whatever it's
fun alright so I hop into that and this
is where I can go ahead and I can check
you know my roles and we can do a bunch
of stuff here but this is the key lines
of code right here like those three
lines that's where I'm checking my role
so because I'm trusts I've trusted the
John I verified that the signature was
accurate it's RSA signed I'm good then I
can trust those roles I know they were
generated by the identity manager the
person you know the place that you
logged into so that's it and then now
that I'm done I'm good I can use my
decoded jot I can get my subject out and
I can go retrieve my two days right
there any questions thus far I'm just
gonna keep firing away all right let's
keep Rocking all right so there's a
couple of jot hacks yep
yeah all right yeah so this application
the question was where did I store the
the token where is it
in this case the the app was storing it
in local storage there's a couple of
there's Mathare today bring up with
local stores they say it can be pretty
dangerous for tokens these are signed
they're hard to manipulate so I agree
local storage can be a little dangerous
like somebody could take your jaw and
they start calling api's on your behalf
so a cookie is usually the best way so
just uses HTTP only cookie so you can't
access it from JavaScript and then
you're fine because then you get it for
free every time you make an API call you
get your cookies sent across right
another thing I have another talk not
today but you know you can find it
online or you can email me and I send it
to you and that's all about like API
gateways and so how do you front things
so that you can do a lot of this
authorization and authentication on the
front side rather than having to do it
in every single API so I can talk about
that as well afterwards if you guys want
yep oh all right so when you're the
first time you're authenticating right
you're logging in so yeah so you're
gonna basically collect whatever data
you need for your back-end so in most
cases that's going to be an email
address and a password some people might
use like in our say certificate you can
use another ticket from another
ticketing system right or you can use
another exchange token so like you might
say hey I have this token from Google
can you use it and it'll say yep I got
it thanks for the token and it'll
exchange the tokens so there's lots of
ways to authenticate users the most
classic one is just email and password
alright so the classic hack then Oh yep
sort of so there's always an exchange
that goes on between applications so a
jot is defined by three bits of data
sometimes for the person it's for the
application it's for and the device it's
on so if you have a jot for let's say
your website and you want to take
somebody over to the forum you need to
exchange it for a jot for the forum so
usually there's an exchange process so
like in our case we have a an API called
you know slash API slash dot slash
exchange you pass in a job for one app
and you get a job for another and the
the only reason you do that is because
you want to know the roles for that user
and the other app right Sam any other
questions
good questions all right
everyone can complain when this first
came out about how insecure it was and
don't use jots they're horrible and
really the one main hack that everyone
sort of came dreamed up which is not
really reality was what we call the none
algorithm hack Sojat specification
allows and none algorithm so if you
remember in our header we had olga hog
and then RSA 256 you can just say none
and then you don't need a signature so
here's the hack I take my original jot I
strip off my signature I decode the
header and I change algorithm to none i
encode my header and I jam it back in
okay this is a valid job totally valid
according to the specification and then
what I can do is I can just take the
payload in the body and I can change
whatever I want use different IDs I can
give myself whatever roles I want all
right so this is always the one that
people complain about so there's an easy
fix
I'm just only don't allow none genius
right so every implementation I've ever
seen the first line of code is like if
algorithm equals none you know
error so it's one if statement okay
there's one other one that has come up
recently I don't think it's ever been
exploited but it's possible and what it
does is it allows you to flip the
semantics between RSA public key private
key and H Mac and what what you can do
is you can actually take the public key
which is well known and published like
right now I can go get Google's public
key it's just you know there's a very
well-known URL it'll return you the
public key and get Facebook's and
Twitter's and everybody's what happens
if I took that public key and tried to
fool the server into thinking it was the
H max secret and so it looks like this
okay so here's our jot all right so if
you see I have my algorithm as RSA and I
have this public key okay I'm just gonna
go ahead and I'm gonna flip the
algorithm to H Mac instead now if the
server is dumb enough whoops
to say okay well I have this key that
I've been generating things with and
maybe I'll just use that as the shared
secret yeah that'll work
and if it'll actually verify the
signature using the public key you can
get you you can exploit the server you
can basically fool the server into
thinking that the bit of information
that's publicly known which is the
public key is actually a shared secret I
don't think this has ever happened in
practice but it isn't one exploit that
people sort of have mentioned as
possible and they're the easy way to fix
it is just don't be dumb when you look
up your keys if you're going to look up
a key make sure that you store the type
of key it is this is an RSA public key
this is an H Mac secret right so then
when you get an augur of them that says
H Mac and you're like no no that's
that's a public key I'm not gonna use
that symbol fixed so just be smarter
about your keys
all right Arthur verification so this is
the most common method this allows me to
generate a jot and send it anywhere in
the world I can share my public key with
anybody and they can use it to validate
my jot they can also use it to exchange
it for one of their jots and this is a
classic way that like Facebook Twitter
you know etc etc LinkedIn everybody's
moving to this as a methodology forcing
400 auth for federated login right which
essentially means go over there
login come back with a little bit of
information that is verifiable like a
jot and then I'll use that to set you up
in my system all right so it looks like
this so this guy down here the to-do API
needs the public key he needs to be able
to verify that that jot was signed by an
authoritative source so I can just drop
it in a file on the hard disk and you
can just load it up and just use it all
right so that's one way that sucks if
the key changes gotta go bounce all your
servers so instead what a lot of people
do is they just write a little API and
then you can go ask your user API hey
I'm starting up and what's the public
key just download it it's the API might
return something like this so just
returns your public key and then you can
just use that public key to do
validation to do key verification okay
this comes up quite a bit what happens
if I have multiple keys like a lot of
people will rotate keys so they'll keep
the last three keys in rotation at a new
key like every couple of months and then
take the last and the fourth one and
drop it off right so you slowly rotate
your keys over time well that's going to
require you to tell the jot validator
which key to use so what the spec says
it says go ahead and add this little
header called ke ID which is your key ID
and instead of returning one key from
the API to get the public keys you
return multiple keys and they're just
that's just a hash so 42 is the one that
I specified in my ke ID and then 42 is
mat public key so now I can have
multiple public keys and they just have
their a unique identifier
so simple and then when you're going to
do your verification you just look it up
from the hash and you say oh I'm using
that key I'm using key 42 any questions
on that stuff all right I got a ton of
information we can keep rockin C what's
my time
how much got plenty of time crazy all
right so refresh tokens
remember that jots are short-lived
they're only designed to last for like
minutes hours are long refresh tokens on
the other hand are designed to last for
a very long time like days weeks months
so who here has google jack gmail then
everybody pretty much all right
anyone have mfa you turned on two-factor
hopefully everyone all right go everyone
go home right now or get on your phones
immediately we're gonna take a break
well you guys you know turn on that fat
MFA just do it it's it's almost a
requirement now especially for folks in
our field just go in it's super easy
just turn on MFA in Google and it'll
push you a code so if you don't have MFA
enabled and and does everyone know what
MFA stands for sorry I'm using acronyms
a multi-factor authentication right okay
so if you don't have an enable Google
will leave you logged in basically
forever like you'll never have to
re-authenticate as long as you keep your
browser open or you don't shut your
computer down or anything like that
the second you enable two-factor or MFA
you get about a two-week window and then
eventually Google will kick you out and
say enter the code again so it's kind of
annoying but it's gonna save you a
headache if your account ever gets
hacked so the way that everybody does
this is through refresh tokens so what
I'm going to do is I'm going to generate
a big opaque token it's not going to
have any data and it's just going to be
a big mess of garbage I'm gonna hand it
back to you and then what you can do is
you can use your refresh token to create
new jots so it looks a little something
like this so after we authenticated and
we push the jot back to the mobile phone
that little gray circle behind the
mirror on top of the user is the jot and
then I generate another token these are
it's hard to see I'm sure the back is
really small but I generated a new token
called the Refresh token and so the user
API has to store it somewhere but then
what I do is I push that refresh token
back to the phone and this phone can
store it all right so refresh tokens
need to be extremely well secured these
are basically you if anyone gets your
refresh token they can generate jots for
you until it expires weeks day you know
months I mean who knows it could be a
very very long time so if you're
building an app and you're implementing
refresh tokens make sure they go into
secure storage if you're doing you know
any form of mobile cookies are okay as
long as they're you know JavaScript list
cookies in a web app just secure the
secure as much as you possibly can all
right so this is a funny story so I
wanted to make sure I spelled revocation
correctly and so when I came up I found
this death metal band and then I was
giving this talk in Denver
I got two months ago and this dude comes
up and he's like dude revocation is
playing tonight down the streets I was
like you're kidding
like we're going we're totally going to
see these guys so yeah not the death
metal band
it's slash logout right so how are we
gonna manage logout so all we need to
really do for logout is we need to
revoke the Refresh tokens so when we log
out we're going to add a new logout API
to our user API our user system and when
you call it all I do is I delete your
refresh tokens because that's really all
I care about I know that jots are gonna
expire because they're short-lived only
a couple of minutes all I care about is
that you're not allowed to use the same
refresh token until he can keep getting
more jots all right so you just kill all
the refresh tokens make sure that you
have a really large sort of kill all for
this because the worst thing that's you
know gonna happen is that you know let's
say there's a breach you want a big kill
switch and you just hit it and it
basically for logs
everybody out shuts everything down so
yeah the users have to
getting in they might be annoyed but at
least you know that breach wasn't
escalated so we always tell people make
a big old log out button log out every
one button and you might you know want
to make sure that the person who's gonna
hit it has the right permissions to do
that but just make a big log out button
alright so let's talk a little bit now
about deleting users alright so we've
covered jots and you remember that we
broke the link between the user table
and the jews table alright so we don't
have that link anymore so I'm gonna go
delete this user totally fine in the
user database but I don't have my
Cascade on delete anymore bummer
so we're gonna have to handle this some
way so one way that a lot of folks have
dreamed up is the global delete so you
basically make an app that calls every
API in your entire system and cause
delete on it for a specific user it
works it's a little brute force and
every time you write a new API you gotta
make sure you meant that delete system
but you know whenever it works there's
another way you can start generating
events alright so your user API can fire
an event that said like hey this users
been deleted and it gets broadcast out
it can even go on a like a you know
kafka topic right you just blast it out
everyone listens for it and then they
take it and they they run with it
so let's look at that MMH
and I got to pull it up and remember my
keystrokes did it alright so let's take
a look at our web hook alright so here's
my web hook can everybody see that yeah
it's a decent size not great
oops lost it sorry alright so first
things first you're calling a web hook
make sure whoever's calling you is
authenticated they have access to
actually make this invocation because
you're deleting data in this case so you
better have like an authorization header
or a certificate or something because
otherwise somebody hacks your web hooks
and boom like I can wreak havoc if you
give me 30 minutes I'll delete
everything in your system all right so
be careful with these things and really
implement security on your web hooks the
same way you would implement security on
any other part of your api's especially
your user api's so in this case I'm
checking my super secret authentication
key of API key if I don't have it I'm
just gonna say ok 403 you know get out
of here if I do have it we have a couple
of different types of events let's look
at the second one first here's our user
delete event so that is an event that's
going to come from our user API and tell
us that a user was deleted the body of
that event is going to have the user ID
all right and so once I have the user ID
I'm good I just delete his two dues so
pretty straightforward in terms of the
way that we're going to allow these
services to be orchestrated now if you
want to get real crazy you can implement
transactions around this so what you can
do is you can say okay I'm an about to
delete a user from the user database
before I do that I'm going to start a
transaction call all my web hooks make
sure they all succeed and then I'm going
to commit the transaction if any of them
fail just roll back the transaction and
allow the user to try to be deleted
again right so all of your web hooks
should be safe against multiple calls at
any time they should be able to handle
invalid data that comes in or old data
so keep that in mind all right let's go
on back here alright so one of the
classic questions that always comes up
can i revoke JW TS sorta not really
so remember jots are designed to be
portable units of identity they're not
designed really to be like stored in the
database and managed by your identity
system your user API as I call it but
there's a kind of some cool little hacks
that we've come up with to make this
possible so here's what we sort of
devised and it actually works I'll show
you in a second when you log out what
you do is you delete all your refresh
tokens right well what happens if I fire
an event out to all my other systems to
say hey this specific user has had a
refresh token revoked those other
systems can watch for that event and
then they'll know that certain jots are
now invalid because they were generated
at a certain point in time all right so
let's assume I haven't updated this for
a few months sorry let's assume it's
November 9th 2017 at exactly 1:00 12:47
p.m. hmm
we know our jots that was just created
like just now will expire in exactly 30
minutes so it'll expire at 1:40 - if I
created a jot one second ago right it'll
expire one second before that so one
forty two forty six okay therefore we
can say all shots that have an
expiration that's before this instance
are now no longer valid because we know
the refresh token that was being used to
generate them is no longer valid
right so it's all time-based and it
looks like this alright so Oh again I'm
apologizing they say one so one twelve
forty seven two one forty two forty
seven in this case is six everything in
the red is dead
so if I created a jot at any point in
them or sorry if any jot has an
expiration that's in the red it's now
garbage right because we know the
Refresh token that was used to generate
them as toast everything in the green is
good and everything in the blue is
already expired so we don't care makes
sense bringing in all right all right so
let's take a look at how to implement
this because it's actually really really
simple very few lines of code
alright so here's my event so I have my
jot dot refresh token dot revoke event
so I know the the thing that's coming in
is the duration of my jots because
that'll give me my window so I know
right now to some duration is going to
be invalid I'm trying to build that red
line so I grab that information from the
request and then I just wrote this
little JWT manager and I can say revoke
so for this user ID you know 42 or
whatever it might be
I'm gonna revoke his jots so this is
again pretty straightforward so I just I
have a big hash it's static its global
and it says for this user ID here's the
duration sorry here's the cutoff which
is that last little part of that red
line everything after this is OK
everything before this is bad
makes sense
alright let's quick go take a look at
hard to do again yep
yes there are a lot of folks that sort
of have said that let's store refresh
tokens and jobs in a repo and that's
another possible solution as well it
requires a little bit more scale
depending on how you go about it and
like right here to store all this token
all right so let's go back here we
decoded our jot we one of the JWT to
code and then down here I believe it's
here nope sorry wrong spot authorized
yeah okay so in my authorize I've
decoded the jot I verified it signatures
correct I now have a valid jot now I
just need to figure out if it's been
revoked
you know quote-unquote so what I do is I
actually go into this that JWT manager
that's storing our cache of revoked
instance and cut-offs and I just ask of
it as if it's valid so I grab the
subject which in this case is the user
ID I see if they have an expiration
instant and if they do because if that
jot is before now it's bad if it's after
sorry after that instant it's good so
again that's the part of the red line
right everything before is bad
everything after is good so that's what
this check is doing right here pretty
simple all right let's see it in action
which time do we have five minutes ish
ten
all right that's a real login all right
so I'm going to login to this little
example this is my to-do app the one
that we've been looking at we built it
for IBM and keep forgetting to change
the logos and I'm gonna log into our IDP
our user API alright so this is our user
API interface alright so here we go so
now I'm into two John's account
so John's logged in over here John Doe
alright if you notice that I have down
here section called sessions really what
that means is they're just refresh
tokens so this is just a list of all the
refresh tokens for John what I'm gonna
do and if all goes according to plan
nothing you know it's not it's not a
real presentation unless your demo
messes up once or twice right all right
so I'm gonna delete my session ok
refresh token has been deleted if I flip
over to my terminal down here
I should get a little message here that
says revoking JWT for user for this many
seconds I don't know if you can see
that's really small I apologize so I got
that call from or into my web hook and
then I wrote it into my little cache
so now if I flip back over to my web
browser I'm in my to Do's I hit a
refresh and I'm logged out right because
I know the jot that I had in my browser
is stored in a cookie had an expiration
instant that was invalid it hadn't
expired it was just invalid according to
my little cache so if you're building
like highly distributed systems you're
dealing with a lot of api's firing off
these events and storing these caches is
actually pretty simple to do and it
allows you to do orchestration without a
lot of data flying around your network
to validate these things because the
worst thing you want to do is every time
you go call an API you don't want to be
constantly calling back to the user
service checking if these things are
valid right because it defeats the
purpose of jots which is to D couple
everything and reduce your network
chatter
Yeah right I mean you store you
basically
sure yeah so in our example what we do
is we store a log of logins so we store
those separate than refresh tokens and
jots because this is an audit trail so
like depending on where industry you're
in you might have to rate you might be
regulated by these things storing logins
is also a really valuable piece of data
right so we actually store all logins
for all time which for some clients is
really big yeah
well excellent so the question was if
the user closes they're out there and
you know basically like inherently is
locked out how should we get rid of the
Refresh go things right well it depends
on if it's a cookie and that could be
big perch when you close your browser
then the Refresh token just magically
gone because in the Google example or
Facebook or whatever there
our implementations are colonies we do
research that means others work and
actually if you if you have an app close
event and we believe they're 70 because
we did the worst thing that's gonna
happen is amusing
so in API called it would be the single
Refresh token on our system
the Pirates
and it's a single person
so yeah we do
we do close events and we just call
there's we have slash api / ja / revoke
and you pass in either the token itself
or the user ID in which case it deletes
all the users refresh tokens Sam all
right where were we alright a couple of
other things so when is a user logged in
alright so this is kind of an important
thing to reconcile depending on how your
application is going to work so what
happens if the user logs in and you're
forcing them to change their password
are they really logged in I'd say no
some people say yes it's up to you but
in my mind you should force them to
update their password before they
actually can log in and use the app
right because it's a security thing so
in order to handle that you might need
to implement a system whereby you can
have users in a partially logged in
state or a non logged in state with a
token that they can use later to auto
login so it kind of looks like this so
you would post to the user API again we
validate that they are in the database
and everything's good but we notice that
the system is saying that they require a
password change so we don't want to send
back a job because once you have a jot
all bets are off you now have access to
any API that takes a jot so don't send
back a jot instead what you can do is
you can pass back a huge big ID or some
monster ID and you can use that later
after they've changed their password to
log them in or if you want to be real
nasty and like you know peeve your users
off after they changed their password
force them to log in again with the new
password so lots of options
so this is how it looks so after I
change my password I exchange my ID for
a jot and then I get a push to jot back
to them to the app all right two-factor
right this is a big one you're logging
in and you have MFA enabled and should
you be logged in so no right because MFA
is actually the login the first part of
it is login kind of but not really it's
just like are you sure you are who you
say you are okay now you can login like
yes okay I've authenticated that you are
in the database with a password that you
might have be the only person that knows
or it might have been leaked and you
might have been breached then I'm gonna
actually allow you to login
hence the two-factor right or the MFA so
similarly post to login hit the user API
we authenticate them against the
database and we say yes you're you or at
least you're you you're someone who has
this who knows your email address and
password so we don't send back a job
then we do a push out to our push or we
can do an API call out to our push
service it pushes a code to our phone
and so now the phone has that ID that we
sent in this again usually these are
just huge strings of data right they're
just big opaque tokens so the phone has
our big opaque ID or a big opaque token
plus the MFA code I push both of those
back to the user API and the user API
validates both pieces of data and says
yep okay now you're really you and it
logs you in and it returns a job make
sense all right what happens if your
email is not verified so this really
depends
you can log them in with a limited set
of roles you could not log them in and
yeah yeah my over and probably over but
that's fine
so anyway same system you can decide
whether or not you want to send back a
job you might send back a job with no
roles and that's what a lot of folks do
so that's it thank you for coming if you
guys have questions come up and see me I
can stand outside if somebody's going to
use this room afterwards as well so
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>