<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cloud Native DevOps for Node.js applications | Coder Coacher - Coaching Coders</title><meta content="Cloud Native DevOps for Node.js applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Cloud Native DevOps for Node.js applications</b></h2><h5 class="post__date">2017-12-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/guEpQ44e0q0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi welcome to cloud native DevOps for
node.js applications
my name is Abhishek Gupta and I am a
product manager at Oracle although I do
not intend to show you any unreleased
product feature today but I would
request you to not make any purchasing
decisions based on my presentation here
is a high-level overview of what we are
going to cover today to set the context
I will start with a general introduction
to cloud native applications and DevOps
then we'll look at some of the basics of
nodejs
followed by an example application which
involves building a restful api using
expressed rjs and the node Oracle db2
iver then we'll look at node.js micro
services deployed and running on top of
Oracle cloud and finally a demo again on
top of Oracle cloud but this time with a
focus on continuous integration and
continuous deployment of your node.js
micro service so let's dive in cloud
native is nothing but an architectural
style at the end of the day for building
applications to run in a cloud
environment it was pioneered by these
consumer-facing web scale you know large
internet scale companies like Netflix
Amazon Twitter Facebook Boober etc whose
whose core business really was was
technology itself right now the USP of
these cloud native style applications is
the fact that they can extract em if
designed properly designed and built
properly they can actually extract
maximum value from what the cloud
actually has to offer and and these are
things like the ability to consume
anything as a service scalable in
structure a viable cost model where you
pay for what you utilize and so on and
so forth
right and and the primary motivation
behind you know this this style of
development has really been you know
continuous in innovation and faster
time-to-market right and but you have to
remember that in order to enjoy these
some of these benefits or advantages
which I just mentioned you need to keep
in mind that some of the design
paradigms of cloud native applications
are quite different from the ones which
you used to develop earlier or maybe you
you know the ones which you still
develop you know within your own data
center you know so-called monolithic
applications right so you have to
remember or bear in mind that cloud
native applications would by and large
be distributed in nature now that means
that there will be multiple instances of
of your applications running across
different virtualized environments VMs
data centers or even across availability
zones or even countries or continents
for that matter right and and another
key requirement for cloud native
applications is is the fact that they
need to be designed so that they are
robust and resilient to to any
infrastructure 'el you know issues or
changes whatsoever okay
and another key thing which you have to
bear in mind is the fact in terms of
automation and and this includes your
continuous integration and continuous
deployment pipeline this is something
which we'll discuss in detail in this
particular presentation now cloud native
applications are they often tend to
overlap with what are called a 12 factor
style of development or 12 factor style
microservices right and again even this
twelve factor you know style application
they are nothing but a bunch of common
guidelines or sort of patterns for these
SAS style application software as a
service applications and and these were
actually compiled you know the roots go
back to Adam begins and other folks from
from Heroku as a result of their
experiences by working on that platform
itself by by the platform I mean Haruko
itself right and if you note this if you
if you notice some of these these twelve
principles many of them resonate
extremely well with some of the inherent
cloud native concepts such as
horizontally you know scalable and
stateless application externalized
configuration treating your services
like databases queues as as resources
stock streaming and and something as
common as source code control for that
matter right and and I'll be touching
upon you know some of these topics in
the in the upcoming slides a common way
of categorizing application of service
teams is is by segregating them into
development and operations groups now
everything is good as long as there are
no issues but whenever things go wrong
there things like fingers are pointed
there blame games and at the end of the
day frustration is imminent now DevOps
seeks to actually change if not all at
least some of some of this by aligning
these previously disparate teams
together towards a common goal
right so developers continue to do what
they do best right they continue to
focus on their strengths which is to
develop new features and the operation
teams who have more experience with the
actual infrastructure platform they
continue to keep the lights on and work
towards keeping the system's stable fast
available etc right but the ultimate
goal
of DevOps is to bridge the gap between
these two teams so by allowing the
development teams to get access to the
same technologies that the ops team uses
and by letting the operation teams you
know giving them insight into code build
processes in giving them access to
information which they need in terms of
what changes were made to the code
what's coming up with that coming up in
the next release etcetera right so these
are the kind of things which are
required to to bridge that gap between
between these two these two groups in
general now this definition has been
very conveniently copied from Wikipedia
it's a rather lengthy one but but of
course I'll focus on just the key
aspects so I was just talking about the
big cultural shift which is required to
adopt a ops in general but from a
technical point of view
DevOps talks about this circle which
consists of multiple steps which include
planning your product coding it going
through the building tests releasing it
deploying it and finally operating and
actually monitoring it in production and
based on the feedback which you get you
continue to develop and add features
etcetera right if you're aware of
familiar with the agile development
methodology you will realize that these
are the same things which even the agile
you know mindset or the agile
development methodology aims at simply
but node.js is a server-side runtime for
JavaScript it's belt on Chrome's v8
JavaScript engine which is supposed to
be one of the best engines out there
notice uses an event-driven and
non-blocking i/o model and it comes
along with NPM
node package manager which is one of the
largest repositories of open source
libraries in the world now some of the
benefits of using node are the first one
is if if you're already familiar with
JavaScript and if you're using it for
the front-end then it makes a lot of
sense to utilize the same language for
the backend and middle-tier as well
right and another key benefit is the
fact that node.js itself is is highly
scalable and efficient due to its
asynchronous operating model now here is
an overview of the common architectural
paradigms which all the node.js
applications are built upon now the
JavaScript code all the JavaScript code
actually runs in a single thread called
the main thread now the calls which are
made are handled in an asynchronous
fashion so they either end up in a event
loop or they are executed within the
node.js thread pool right then the
operation is complete they call that
function which you had initially
supplied it would be then added to the
event or the callback queue and they
would eventually end up or or rather
they would make their way through to the
main thread for the execution itself now
here is a quick overview of some of the
tools and frameworks which are common in
the node.js microservices landscape
right now I have categorized them into
four more four main buckets which are no
rest and HTTP based communication you
know inter-process communication
basically service to service
asynchronous you know messaging based
interactions data management and then
things like you know micro services
chassis or of some of the foundational
services process managers etcetera right
so so let's let's quickly run through
these
these tools and frameworks expressed
Jess is actually web framework and and
it it it works as a foundation for a lot
of other web frameworks on node.js out
there rest if I as the name suggests
it's very focused on on designing and
building rest EPA's themselves Kraken
Jess is actually a layer on top of
expressed yes itself and what it does is
provides more structure and nothing's
like convention over configuration happy
jess is is created by Walmart and it's
actually an alternative to Express Jess
and it offers a lot of lot of modules
out of the box but just just by default
right moving to the asynchronous
messaging based libraries the Kafka node
and node readers are are no surprises
there they are they're used for their
actually libraries for communicating
with Kafka and Redis respectively now
mqp lib it can be used to communicate
with any any AMQP compatible broker such
as RabbitMQ and again the same thing
goes for amplitude MQTT as well ws is
actually meant for WebSockets WebSocket
based communication that's what this
node.js left really does for data
management there are a few frameworks as
well including node over m2 and sequel
eyes which which support look they
commonly support MySQL post to a MongoDB
and and Redis as well right and a bunch
of other other databases as well node
Oracle DB of course it's it's it's an
interesting and open source driver for
the Oracle database itself and you will
see this in action in upcoming parts of
the presentation water line is actually
the default ORM used in the sales
framework and it actually provides
uniform api for for again accessing
delicacies like post created
Swango etc Seneca and Hydra are the
components which from the or provide the
capabilities within you know what is
called a micro services Joshy right
so they actually aim to solve some of
the common micro services development
concerns like service discovery interest
service communication health check
monitoring so on and so forth and
process managers are actually required
for production grade node applications
and there's no way you can run you know
it's it's very difficult rather to run a
high quality production grade node
application without these process
managers right so namely p.m. do and
strongloop they tend to take care of
tasks such as automatic failure handling
controlling the cluster runtime
performance resource consumption
monitoring etcetera thing like that
now let's double click and zoom in to
some of the areas or components of extra
storge s itself now I am just going to
go through these four modules we can
express dot J's because they attend
they're they're very commonly used at
they they form the foundation of what
spray expressed or J's actually offers
right so to start with routing now it is
simply the task of mapping client
requests which are sent to a particular
e or an end point along with of course
the HTTP method itself so get post
etcetera and these are actually mapped
to the right implementation or the
handler function itself i middleware are
nothing but a bunch of or rather a chain
of functions which have access to the
request and response context so that
information is available to them and
they can actually mutate this
information and invoke other middleware
the subsequent middleware in in the
chain templating engines again these are
very common so if you are if you are
aware or familiar with the
the C style of doing things that is the
modelview country controller frameworks
so typically what you have is these
template files which template engine
actually populate at runtime with the
actual values okay and some of the
popular template engines which work with
expressjs are mustache EGS etcetera now
expressjs also contains a debugging
module which is used to internally log
information about things like you know
routing matches middleware functions
etcetera now the real use speed of
expressjs is the fact that it is generic
a generic enough to cover a wide variety
of use cases but yet minimalist enough
to not really obscure developers from
from the node.js language itself now
let's take a look at a simple yet
practical node.js application on Oracle
cloud now this is an employee management
app which exposes a REST API on one end
and on the other hand it uses data
within the Oracle database cloud service
using the node Oracle DB traverse we
will look at some of the details of this
driver in the upcoming slides for now
this is how the REST API looks and how
it is implemented with expressed or j/s
so we define routes to handle our client
web requests and these routes actually
consists of the URI itself the HTTP verb
and of course our implementation which
is kept in this particular slide so we
have different operations for our
employee management application which
map very well with the HTTP works for
example in this case the post HTTP verb
is used to create a new employee the get
verb is used to get all the employee
details from the Oracle database the
other get get verb which is which is a
variation on top of the the previous one
gives you the flexibility to
search based on a particular criteria
put is actually used to update the
details of an employee and delete as as
is pretty evident is used to delete the
employee from the Oracle database so
this is how the arrest API looks like
when implemented with expressed on chair
so note Oracle DB which is used to
interface with the Oracle database cloud
service in this case so this is actually
an open-source driver for nodejs or for
Oracle database of course right
it is quite feature-rich and of course
since it is open-source I would
encourage you to go and check it out on
github as well as on NPM and just a
quick note that this driver leverages
OCI article call interface which in
itself is a wrapper a sea-based wrapper
on top of Oracle database but this is
how a typical implementation looks like
so in our case in the case of our
employee management application we
implement the get all employee
functionality in this manner so we using
the node oracle DB driver we get hold of
a connection or handled to our Oracle
database cloud service and then we
execute our article way which in this
case happens to be select star from
employee not surprisingly and then we I
trade over the results and create a JSON
payload which we then finally pushed to
our client and of course we follow the
best practices and release the
connection at the end of our call so
it's pretty simple and and this is how
our typical implementation looks like or
at a global typical flow looks like when
using the in order to DB driver now if
you recall our discussion of cloud
native applications and well factors
style applications some of the points
which I mentioned it would be good for
you to understand how this application
our our sample application embraces
some of those capabilities or some of
those points right so to start with it's
a stateless application exposes a REST
API and for persistent state it uses the
Oracle database in this case the Oracle
database itself is consumed as a service
as a declaratively configured service
just-just-just as any other external
resources should ideally be consumed in
a cloud native world the application
itself is highly available and it is
horizontally horizontally scalable in
the sense that you can add remove
instances as required and the load
balancing would be taken care of
automatically by the platform and you
will see some of the so you will see
this example in action in the demo of
witches going to come up later in this
presentation from a configuration
standpoint everything is stored in
environment variables including the
Oracle database connection details and
the way it binds to the port in this
case we are dollar port environment
variable etcetera and some of the other
parts which again will be covered in the
demo include the management of the code
itself right so source code management
as well as the continuous integration
and continuous deployment now here is a
buzzword compliant introduction to
Oracle application container cloud I'll
let you soak this in and expand upon
some of these points in the upcoming
slides
Oracle application container cloud is
built to deploy and run well factor
style cloud native applications and
micro services it is polyglot in nature
meaning it supports multiple languages
as well as run times including nodejs
Java SE job ie PHP Python Ruby as well
as go your applications actually run
within docker containers but docker is
not actually exposed or abstracted to
the user
things like container orchestration
scheduling placement etc are taken care
of by the platform you have the
capability to vertically and
horizontally scalar application now
Oracle application container cloud is
flexible and open yet it is very closely
and tightly integrated with the Oracle
as ecosystem which means that you can
easily integrate with Oracle cloud
services using application container job
now here's a runtime view of
applications running within this
platform you have complete tenant
isolation and as I said your
applications actually run within docker
containers and you can scale out
horizontally right but there is this
load balancer to make things easier for
you you don't have to configure this
load balancer as such it it is
automatically going to take care of
distributing the load between multiple
instances of your applications and on
the right what's highlighted is is the
tied integration through the Oracle paas
ecosystem as I as I just mentioned which
includes services like Oracle database
cloud service Oracle event have cloud
service Java cloud service so on and so
forth
build zip and deploy really this is the
simplified mantra of Oracle application
container cloud now what does this
really mean
in the build part you would assemble
your application say for a node.js
application it would mean npm install
they for a java application you might
say and VN clean install it doesn't
really matter and then all you really do
is convert your application into a zip
file now the zip file would contain your
application its dependencies and and and
some deployment descriptors which is
actually encapsulated within a json file
called manifest structures on and then
all you need to do is to push this zip
file to the cloud and you have multiple
options there you can obviously do it
through the console but we have a CLI a
rest-based API as well as integration to
see ICD platforms including the one with
a nordic cloud which you will see very
soon now let's talk about Oracle
developer cloud I hope you remember this
illustration from one of my previous
slides the good part is that Oracle
developer cloud actually helps you
through the majority of these phases or
stages of this particular cycle
beginning from the planning stages of
the project to the actual coding and the
implementation along with the building
testing and the release cycle to of
course the deployment to your production
test or staging environments the operate
and monitoring stages are actually
handled by specialized or without
services now the functionality or the
features of Oracle developer cloud can
largely be bucketed into two two
categories starting with the code
management and the continuous
integration side of the house there is a
source code management feature which is
largely handled by git repositories and
then there is build automation for the
languages including Java for which you
can use and maven or griddle and NPM for
node etc you can also use a generic
shell command or talk to Oracle database
using sequel CL we also have continuous
integration engine as well as a
deployment automation component built in
within Oracle developer cloud now coming
to collaborative team-based agile
development there are a bunch of
features in Oracle developer cloud for
this as well so starting with issue
tracker activity stream collaborative
code review as well as some of the agile
development features as well now here is
where the entire story really comes
together starting with the moment the
developer actually pushes the code in to
get repository within Oracle developer
cloud and then it kicks off a build and
zip phase within again Oracle developer
cloud and then the continuous
integration and deployment engine kicks
in which finally pushes the application
to its deployment platform in this case
it is Oracle application catenaccio
alright let's look at a demo now
right now I'm in the landing screen for
Oracle application container cloud as
you can see I have my node.js
application deployed over here the node
runtime version is a dot 1.4 to be
precise and here is the URL of our
application now I'm going to click on
the name of the application to go into
the details section here as you can
notice here is an overview of our
application we have two instances one
memory of GP allocated to it we can
scale this up if you wanted to I am NOT
going to actually do this right now
and we can also scale this out to say
three or four or more instances I'll say
cancel for now moving forward if you
notice we have again the details for
each of these instances they are labeled
we have dot one n vector two
respectively and here are their memory
consumptions if we move into the
deployment section we will see some more
details associated with this particular
application so basically some of the
things which we see here are the archive
name this was the name of our zip file
which we deploy to our application
container cloud and these are the
contents of our manifest or JSON and I'm
gonna show this in the demo after some
time so this is our launch command to
bootstrap our no J's application and the
topology as I said two instances and one
gigabyte of memory the interesting thing
to notice here is the service finding or
the dependency declaration on Oracle
database cloud service
which is named quite interestingly my
name pronounced in Reverse basically so
this has been explicitly declared within
deployment JSON so that Oracle
application container cloud can bind to
this database cloud service instance at
runtime and be able to invoke its its
various functionalities like checking
data from a table etc here is the
database cloud service instance which I
was just talking about right so we are
right now in the Oracle database cloud
service landing page now let's run our
application so as I said this is the
publicly accessible URL for our employee
management application so if I click on
this right now if you notice this is our
application we just got open it's a very
simple one not not really flashy but
hopefully good enough to explain the
point in terms of its integration with
Oracle database cloud service as well as
some of the other cloud native aspects
which we previously discussed so here
are a bunch of employees which are
seated within the database right now we
should be able to see the details for
them for any of the employee for that
matter now let's go ahead and add a new
employee Abbie shake birthdate title and
department and I'll say add ok so looks
like this was successful and here are
the details which were entered now let's
go back to our database and query it to
confirm that this indeed got pushed to
Oracle database cloud service so
let's give it a few seconds for the
database query to get executed and then
we should be able to confirm that the
record indeed got seeded within our
database instance okay there seems to be
a minor hiccup but I think it should be
alright
never mind so if you notice the exact
same records which I entered the new
employee details were in fact pushed to
the database so why don't we go back and
delete this employee right now so
Abhishek Gupta is going to be deleted
right away so I hid the employee name
and I say delete say okay alright our
view is refreshed our nodejs application
view but what about the database by hit
refresh so okay if you notice this time
around that the employee in fact got
deleted from the database okay so now
that we have looked at ECC s database
cloud service as well as the application
demo let's move on to the CI CD set of
things that is continuous in integration
as well as continuous deployment using
the integration between Oracle developer
cloud and Oracle application container
law so to begin with let's make a change
to our application so if you already saw
that the header here or not theater the
the main title here is cloud EMP app now
let's go to be index dot HTML and change
things up a bit
so I I don't like this I'm going to
change this to something better so cloud
employees application and what's up with
these people anyway so they are
employees so let's change that as well
now that we have made this change let's
push it to our get repository in Oracle
developer cloud and I'll show that to
you in the next part of the demo but for
now just understand that I have a
project set up within Oracle developer
cloud which has a git repository which
hosts this source code okay so let me
first commit this updated landing page
message and we do a get push to the
upstream repository as I mention earlier
so let's give it a few seconds and there
you go
our change has indeed been pushed now
let's move over to Oracle developer
cloud now here is the landing page of
Oracle developer cloud service and what
you see here is the top-level project
which is aptly named Oracle code demo
project and if I go into this project
what you now see is the landing project
page which highlights in a timeline
style all the activities which have you
know beam being executed on this
particular project obviously I have done
my homework so obviously you see that I
have done a lot of testing and
activities on this particular piece of
demo so that's that in terms of the code
itself I was just talking about this a
few seconds back that there is this git
repository oh let me just go back and
highlight this as well so this is the
git repository I was talking about
no DAP torque it in this case and this
is natively hosted within Oracle
developer cloud service this is not an
external data repository as such
although you have the ability to import
from external git repositories directly
into Oracle developer cloud coming back
to the code section slight slight delay
there my apologies
so this is the code here so it consists
of the server dot j s which which is our
node JS business logic along with of
course our Express framework and our
static pages that is our index dot HTML
etc and this is the one which we had
just updated and if you remember the
commit message which I had mentioned
updated landing page message and so so
this is this is the change which we
actually just made right so this was in
fact pushed back into our git repository
and as I mentioned earlier Oracle
developer cloud service has two main
components one is the code repository as
well as the CI CD engine and the other
is the collaborative agile base team
development capabilities so the issue
tracker the the agile dashboard as well
as this wiki are a part are are a part
of that particular agile development and
the collaborative team development
capabilities within Oracle developer
cloud now let's move on to a you know
couple of important sections which are
very important from a CI CD continuous
integration and continuous deployment
pipeline which which I'm trying to
highlight through this demo here so
let's go into the build section so so if
you see there is a build job called node
EMP - Build
which I had configured and if you see it
in fact got triggered three minutes ago
which was not very long back and this
actually was as a result of me pushing
that code into the git repository the
one which we just updated so if I go
into the configuration for this
particular build job you will see why
that happened so this is the main page
where we define the name the build
parameter section not being used but
it's it's interesting nonetheless the
important part is the source control so
here is where we link our build up
configuration to the kit repository
which I just mentioned some time back
and here is the trigger section so what
we have done here is configured Oracle
developer cloud to pull our kit
repository at regular intervals so that
if there is any update this particular
build job would automatically get to
that and that's that's what happened in
this case as well and I'll and I'll
prove that to you in in a second moving
on to build steps in our case we are
executing two steps as part of building
the package for this particular
application for deployment on Oracle
application container cloud the first
step is NPM install it pulls all the
dependencies from NPM of course and
finally here is this execute shell
command to zip up all our application
related dependencies into one goober zip
called apt or zip what do we want to
include in the zip this course are no
J's module our static code which
includes CSS and HTML our node modules
folder which got created as a result of
our npm install and our packaged or json
so all these contents would be bundled
into this zip and finally deployed to
Oracle application container cloud now
coming back to the topic of our build
job execution so if you notice here that
the update which we had pushed actually
resulted in the trigger of this
particular build job the one which I
just demonstrated to you right now if we
go into the deployment section this is
the component which is configured within
developer cloud which is actually
responsible for pushing this application
zip file into application container
route now let's look at some of the
details of this configuration so I'm
going to say edit configuration just to
show you some of the details here so
these are the properties are the are the
details of the application container
cloud instance in this case it is it is
one of the instances which I am using of
course and we have a couple of options
in terms of how this deployment itself
will get triggered so in this case I
have chosen on demand on purpose so that
I can demonstrate some of the
capabilities to you we could have chosen
automatic and then what would have
happened is that this deployment
deployment job would have gotten
triggered automatically right after a
successful completion of the build job
right but in this case I want to trigger
this manually so the on demand choice in
this case this is the name of the build
job which I just showed to you and let
me choose the latest build artifact so
that it contains our updated code are
updated logic right and that's our
artifact AB dot zip and this is the
manifest or JSON which I was referring
to earlier right which has the the
bootstrapping command and the rolling
primont mode and I'm going to talk about
this in a second here and here is our
deployment or days on which which talks
about the binding as well as the
topology in this case it's two instances
and 1gb of memory so when I say save and
deploy what it will do is trigger and up
an update to application continue and if
you if you notice here it saves
deployment started just now so if we go
over to application container cloud here
and hit refresh you would notice very
soon
that a new release deployment has been
initiated right now so if we go over to
this side of our application you would
notice here in in the in progress
activity section that a new instance a
standby instance of our application is
being deployed now what's the deal with
the standby instance if you noticed that
within our deployment configuration what
we had was the mode was set to rolling
what that means is that we have two
instances here but not all the instances
not both of these instances will be
bought down together to ensure that our
at least one of our instance is live and
serving traffic for our end users so
essentially what would happen is that
the deployment update process would be
slightly lengthier but then our uptime
will be higher or 100% in this case
because our application will never
technically be down so if you'll notice
application container cloud spawned
standby instances of this particular
application just so that our our end
user experience does not get affected so
if I if I invoke my application again so
you see
that the deployment is still happening
but our application is still live up and
running ready to serve traffic once this
entire cycle is completed by that I mean
that both our application instances the
new ones are up and running we would
continue to see the older version but
our application will be life right so if
I if I hit the application now if you
notice now we have the new version of
our application deployed completely and
this is evident by the change in in
these two messages right here now it
says cloud employees application and
employees instead of cloud EMP app and
people over here and at the end of the
day and these were the set of processes
which were executed I'm just repeating
for your convenience so what we did what
application container cloud did was to
spawn standby instances for your
application and finally roll them over
to new set of instances just just so
that we are our uptime is 100% and our
application is always life all right
that's all I have for you in this
presentation before I sign off I would
like you to check out these resources
including Oracle developers on Twitter
as well as medium thank you and goodbye</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>