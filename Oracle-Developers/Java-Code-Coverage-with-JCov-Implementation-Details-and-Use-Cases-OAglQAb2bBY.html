<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java Code Coverage with JCov: Implementation Details and Use Cases | Coder Coacher - Coaching Coders</title><meta content="Java Code Coverage with JCov: Implementation Details and Use Cases - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java Code Coverage with JCov: Implementation Details and Use Cases</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OAglQAb2bBY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so let's get it started
that's me called Shura despite whatever
it says outside it
they got my last name twice for whatever
reason man yeah I'm working as a test
architect for Oracle JDK basically
taking care about technical aspects of
testing or a co-op and GDK which
involves many things but these people
did do make the Jake off tool which I'm
about to talk about to make it happen
and they do fix it and do introduce new
features into it and they helped every
slide a lot okay so I'm from Oracle
don't believe whatever I say so actually
there are two main parts today and the
first part I will be telling how to get
the data is Jake off okay there are
different ways to do it and there are
different options and you can get
different kind of data out of it I will
be talking about that so the first part
about Jake off the second part which is
actually number three is how can you use
the data and it more or less applied to
take off because I can do all that with
Jacob but I could do it some of it
without Jake off you can do it with
other tools which trick off is just
convenient right and this is so the
second part is about like my experience
of using cheat code
and this first part about how Jacob for
someone can you do it about it we
actually got into argument as to what is
what would be more interesting I guess
there's two different kinds of people so
for some maybe usage will be more
interesting for some beta the the
implementation of it so I'll try to
power was to the best I could
so Jacob is a stands for Java coverage
right
no surprise here and it's a coverage
tool which is used for JDK for jck and
for whatever we do internally
okay whatever whenever I do it we don't
need to do code coverage analysis that's
what we use nothing else and it's not a
new tool okay the reason I'm talking
about it is because it went open-source
this year so it's available for
everybody now right it didn't make sense
to talk about this before it does make
sense to talk about now
so 1996 so Java is what 20
this year so it took less than a year or
maybe here
for guys to realize that they need a
tool which is good ever since this is
what we are using internally and so on
and then in our core rate and it went
just open-source this year and so we
have been inventing they released Majin
what release model for it so they're
kind of releases although they're not
binary religious this torso is which you
can download and use okay yeah the point
is we are using it for G 4 gdk9 right
now ok we have to we have to while we
develop in GDP right we have to do the
called courage analysis we do it for the
GDK which has been in development and so
Jacob has to play catch-up so far it's
been successful and we are using it
right now so it's a 2 which is always on
top Russians do get sentimental a little
bit every now and then so these are the
people who contributed ok and those also
most Muslim are Russians Hey she so
happened yeah the point I'm trying to
make there and there are not a lot of
people who are working on Jacob this is
not huge - right this is relatively
small 21.5 engineer on average all these
19 years of development is many people
okay so just to just to agree on terms
because the the same the same terms
could be you know understood different
about different people
under code coverage I mean and the
general meant that the sets of code the
portion of source code which get
exercised in execution of this product
right most often would remain under code
coverage is how much code is in what
code is executed in testing okay
we're testing she's to specify it as set
of activities to make sure that the
product is working as expected
okay right again different understanding
of what testing could be this is this is
what I'm using other possible usages of
perish information probably and I'm not
using it this way but probably is you
know to run it in production collect the
data of how it is used or some like that
do it in like wad testing stress testing
collect this information
it's still really but it's not what I'm
talking about so okay now let's build
real stuff so I will start this a real
simple example then we'll try to get
people to want it under the hood to
figure out how it's working and then
I'll explain different features of Jacob
which allows you to give different you
know perspectives on the data so yeah
simplicity this case I have the slides
they actually do spell the syntax of
Chekhov but I'm not going to be using
them much if time permits I will be
using the shell scripts and execute of
the shell scripts but these slides you
can later use for a reference if try to
remember what was the option sure talked
about switches to the slicing sound okay
so with that let me just switch to the
shell is it fun to build enough okay and
the simplest answer is a different
window okay that's probably too much
right
so basically this is what I do
so the enth basically sends up sets of
environments such as path Java home and
the Jacob channel location stuff like
that we don't need to see that so first
I call an instrument command from Jacob
I'm passing my bytecode and I am putting
my instrumented bytecode in this
directory it's very simple very straight
for the code is very simple
also I have three classes here I have
point which is interface I have point
imple which is simple implementation
which two integer x and y right get in
Gators and setters and I have a line
which contains two points and has you
know get then get started to get in the
exception that that's about it that's
about the code and I have like four
tests that set does get around this
point right so I instrument the code
right and then there I run the test as
usual the my tests contain my own method
so alright the test as usual which is
staging Jake of jar into the cross pass
and then I generate the report okay not
very impressive demo actually but ok so
basically this is called garbage
information for our for our code so this
line it's not current and then there's
point info which is covered point is an
interface it doesn't have any code so we
don't have it here
another impressive so far right let's
never let's use this to figure out how
it's working so if we do Java P and I
wanted to Java T on point in pull okay
so
our eye specialist let's take the
original version first non instrumented
version so I'm opening with Joey showing
non instrumented version so set set X
looks like this right nothing no not
surprised here I'll load I will put
field return that's what it does it's
all interested now if we take a look on
the instrument version we see that set X
looks exactly like that at the end right
this stuff but then there is one static
code okay and there is some magic index
which as you can see is increasing it's
8 here and 9 here 10 later so it's a
unique you need to identify off a block
within with instrumented code that's
what it is so if it if if somebody have
trouble regions Java P output this is
what actually going on in Java language
okay so a static call is it is injected
into the bytecode all there is to it now
the code is also very simple if you take
a look on it it just increases the
counter and producer value and then in
an array that's all there is to it so
the performance impact of this
instrumentation apparently very low
although I'm still in the argument which
the check of people who guys trying to
convince them to do the direct
incremental the array rather than a
static call we need to collect this data
it's not easy to get real to get this
performance impact reliably actually to
measure it so we are not convinced it
needs to be done now at the end that
needs to save the data of course and
again no magic here VM shut down hook
which save the data that's all there is
to it again so now let's take look on
the data ok
so data is an XML file so you can easily
parse it although it may change right
the format may change I mean there is no
guarantees and it's a mail file you
would see that there is a package within
package there are another package and
then there are classes and there are
methods right well the method is just
describes where the blocks start and end
and there is count ok count one and one
of the things has count yes come zeros
it count one is right here it
right this one hold on
yeah count one okay so you can use this
data directly but rather use it to Jake
oh okay yeah performance impact so
performance impact on the bump in the
counters of course is slow very low but
we haven't been able to measure it
exactly there is a very big performance
performance impact on saving the data
though it could be so big you aren't
able to execute the test rates
I'll talk about that about particular
examples but there is a very secure you
can do it with no significant impact to
save the data but they'll talk about it
later also and of course you have a
performance impact on a poor generation
and the report analysis and test
development right but that's what it is
for so yet so they talked about that
already
yeah so back to the simplest use case
that's what we did last time it's
actually incomplete for the next reason
they are only get information about the
cold bytecode which was loaded into the
VM since there is some kind of dynamic
Claudian happening under the hood like
which happens to modern applications
here and there over always right
this code is not gonna be collected
there so and it's actually may happen
then extra call this collect that I'll
show example of that later so what you
what you need to do is you need to
create a template that's what it's
called in in Jakob template template is
an XML file which describes all the code
you want to measure
you know the coverage for okay you could
do that by by this one of these two
commands it could be created during
instrumentation or explicitly and it's a
regular Jakob data file you can merge it
with the rest it's only count equals 0
always otherwise it's just a regular
file ok so to correct the use case all
it's gonna gonna show the same result
actually so I'm not gonna do it just for
the sake of time basically to correct it
we need to generate the template
highlighted in blue here
and apply it emerge it with the results
that's all there is to it well in our
example that we actually get all our
code loaded so it doesn't make sense to
rerun they stop it's gonna be the same
as before
okay now but we actually what we
actually want to do is we actually want
to only check the coverage for our
product code which is in our case is
this package right and not the test
package okay so to get that let me open
the simplest filtering yeah
so to get that I add this option which
is stands for include and I add this
option which stands for EPS cleared
right just for the sake of it I exclude
another class in the in the report
generation okay so this option is used
for a merge and Instrumentation
regeneration also so if we run it we're
gonna see less less code we're gonna see
only one class which was left here with
no surprising results other other than
that it's all clear alright now that
that was basic so far so far what result
is showing I think every every tool
could do that okay no let's try other
stuff alright so there's an option yes
I'm afraid I don't hear it could you
could call the special until the end the
first section it's okay I'll answer yes
so yeah where was I the dynamic
instrumentation yeah so there is an
option rather than modifying the
instrumental be the bytecode before
execution you could do it on the fly we
do it with the Java agent which Devi
imagined demo dynamic okay basically you
just specify Java agent without first of
all I'm writing on non instrumented code
I specified Java agent and I run the
test usually right I simply add one more
option and it's gonna be interesting
right now because what happens is all
the code gets instrumented well how
called law that including the platform
itself okay
and that's why it's taking a little bit
longer there are options to limit the
instrumentation set of classes on the
dynamics termination also but so this
code I'm sorry this is a wrong report
hey you know what let me just you're on
it oh yeah okay
so Your Honor on what test and I
generate the report from the results
tomorrow yes all is called
like Java IO like these classes were
used during execute in our example well
this is interesting
but that's not really what we are doing
right we need to limit and so we have to
remember that we had a template right so
we're gonna apply the template or before
yes
apply the template did the second
portion of this slide and that's a
different filter it obvious or nurture
okay so I basically generate the
template by this command and I merge it
and this time I provided with desh t
option which tells merger that only care
about called mentions in the template
throw throw everything else away and add
whatever is in the template and the
result okay and the generate the report
it's gonna work no surprise here
it's taking a little bit longer
yeah whatever we expect it okay so
that's that that was the dynamic
instrumentation now there are pros and
cons right of the two approaches study
of instrumentation versus the name
instrumentation with study of
instrumentation you could prepare your
product so for the test system whatever
the test environment you have it looks
exactly the same as the real thing right
is the original thing with the exception
that you need to add the Jarrod Jarrah
check off classes to the class pass but
there is actually an option to inject
Jake off classes right into your
application I mean we do that for GDK
okay so there's no difference for tests
this unit under standard a test
instrumented code but the the process of
the dynamic instrumentation on the other
head is that you don't have to change
the product right so you can test test
the product as this only a dynamically
instrumented code on the fly and also
code coverage collected for all code
instrumented colleges have just shown
test so you have to you'll have to do
different changes to the test
environment if you use this so that
diamond interpretation is a little bit
slower because of the cosmology the
instrumentation on the cost alone again
cause Logan is a little bit long so
that's about it otherwise they're
irreplaceable okay so now about file a
waste of our bit saving data into a file
okay
so there's another way to do it with
Jacob it's called network grabber
network is really a network you can run
it on a local machine which which is a
good idea to do to avoid network white
agency but in a in an ideal case you
could round the grabber on some net on
some machine and run the test and other
machines and just feel the code coverage
data to it okay so if we take a look on
my example its
scrapper I guess yeah I started the
grabber
okay in this original in a fork a fourth
day script here and then I started my
test and she's still in Jake oh that is
gonna be a rapper okay Java agency code
grabber and around my test is usual with
on unusual in non instrumented code okay
and then I have Q it should have been
called stop remember Russians did it so
that's not how I meant it I meant that
because it's if it's Russians the
morning sometimes of okay they and I
have a few few more examples of that so
anyway it should be stopped I am you
know organism over this also anyway I
stopped the grabber it collects the
results and then I just generate the
report three ago way okay so it's gonna
work so it starts the grabbers see their
message
so grabber started on this port this
host and then the test runs and then
basically report is the same okay so
that's the grabber so in terms of
performance right away right a
performance impact on the executed test
rather than lodging result of similar
file the data file merging and saving
data file or just saving data file it's
just fits what I would collect data fits
over a network so it may be an it in
cases I'll show examples in in some
cases is just very very important next
few child Jake off this is another
example Russian engineers inventing a
warden it's called test scales actually
it makes no sense whatsoever but that's
what the scale is actually individual
test origin which is trying to replace
it with some other name so in some cases
you really want to know which test cover
which code and I'll be showing use cases
for this one right of course you can run
every test separately and collectors all
separately and store than simple but net
then what what are you gonna do with it
right so jig off supports it in this way
in the result XML you actually get a bit
mask written in a hex format it's
actually could be compressed if you
provide the proper option but this is
straight away to see it so this is the
code coverage taken out of Java ability
see it and this you know every bit in
this must
response to one test okay and so as you
can see not every test in java.awt tests
it creates a component which is kind of
interesting but well maybe we're in
talking about
right now so the data stored here there
are appropriate options of course to do
that so let me show that
Timo's skills file yeah
so first version is to save scales into
file so there's information about the
coverage by different tests needs to
Herodotus it needs to get somehow to the
merger right there are two ways to do it
one way is to merge different results
there is data files where every data
file waste will correspond to to a
different test this is what I do right
now I execute test set right and then I
save the data file I execute test gate
yet and then I self identify they could
they put line a sub directories that's
still gonna work fine and then I merge I
tell the merger to use scales as the
output
I tell them to put to output the order
in which it merges files into this file
so I know which which file is which bit
in that bit mask right in a proper order
and then and then that's it that's
basically what I'm doing here so it
looks the same or however if you take a
look under the hood right these tests
hit this class well do the more
information will be needed from the from
the from the test case section from the
individual test errors you need to know
which lines are hit by which tests right
there is no practical way to show this
information in a static HTML it's just
it's just there is no way to do it
basically we've considered all the
possibilities and so the the Jacob
reports Anna couldn't have to show this
information so if you want to do program
Alice's you'll have to for now you'll
have an I'll talk about it on the last
slide on my presentation for now you'll
have to create a homegrown solution of
some kind which is what I did okay and
so that so does everybody so so could
everybody because the report is open
right from the
the test form from the file from a
perspective have already shown how it's
stored so it's just a bell
so with grabber the other way to get the
test information is with the test case
information it is Ribera which is same
all scales crabber which is this and
this particular test the case I ran two
different tests in the different VMs and
every time I specify the type of test
name property given its name of the test
ok so when the grabber wanted that data
will be fed to the ground bearer
it will also the grabber will let know
what test is running right now okay and
you can run on the same VM test and just
to switch this this property on why I
mean this can be the same but for
purpose of this exercise I did that
there is also gonna be the same sign
I've been around are only the yes only
the test names gonna be looking
different I saw images to it as grabber
starts and then executes one test and
another test and then we generate the
report
yeah so it's gonna be the test names
which I set up over there
it's what it is can you see it actually
yeah
all right test scales that's what we've
just talked about okay next the next
feature yes
no it doesn't know anything about this
method it doesn't know anything about
this Collison she's knows that within
this VM whatever code is Runyan we call
tests yet there is no test method in the
picture okay it's just some confusion
okay this is the cookery report you get
the test set method called set method of
point in pull this one okay it doesn't
matter the distance show is not the G
unit test or anything it's just the main
the class or the main methods right now
it doesn't matter so from the test code
you reach this code in the in the in
they are implemented the product right
and that's what gets reflected okay and
when we wait to let it know which test
is running I am exactly doing that I am
saying a Jacob this is what what my test
is called whatever I'm running right now
is called this test set
yes but that depends on your in your
environment right if you use J unit
you'll have to do one thing if you use
something else you'll have to do some
other PIM well I'll get to it later okay
so I don't have the exact exact a good
story on that but I'll talk about
whatever is there so next in this field
coverage what field were you know
requested during execution and the
question is how do you get this
information right there is no cold well
you could instrument the code which is
using the field actually so to do it I'm
using this fields basically all there is
to it to do is say Jacob hey include
fields right and it's in a template of
also include fields okay and so when you
do that don't do that and while there is
a bug against Jake off report type of
report it doesn't show filter filter
which but the field coverage is they in
the data which is what I'm going to show
in a second
any second now yes
come on okay so now the results contain
fields and if as you can see the
counters count this one so one field was
exercised during testing oh well this is
done by I'm sorry
Java B this is done by by an insurgent
more instructions into the byte code so
basically before get field we call the
static method which which told Chekov
that the field is gonna be accessed
right now this is a unique ID again okay
field coverage so you can see which
field are accessories and testing going
further down abstract API coverage same
questionnaire there is no code in
obstructive how did detect what coverage
of an extra abstract API well the idea
is that if any of the well it will
cement the : code basically the code
which is calling abstract lipe same as
for fields do you say abstract on you
say abstract on and arrested the same
right but you need to compile your you
need to instrument your tests if you do
that otherwise the calls from test over
lost their abstract in this what I
wanted to do
okay so now we have point pointing is an
interface and point is a gettext method
and it was called during the execution
you know you know it's abstract method
out it yeah
it was one of its implementations
effective it was called okay save points
next future Jacob
by default the data is saved on the exit
of the DM I just shown right sometimes
it's just too bad because what if we M
crashes right what if you want to get
results over there like for your
homegrown testing of our test test
harness or formerly for modified as far
as you want to drop coverage for every
protocol test at the at the moment it
ends right for example there is option
called save save beginners and save at
end
tamal the most safe points right yes so
basically you just say save beginning
that means again Russians save data at
the beginning of a method and this
method which you point here by name or
by signature get instrumented and
instructions are edited to save the data
at the you know entering this method
stage okay I need to and they quickly
run through the boring part and the
interesting one
okay what do you have yeah okay so one
more feature and then it's going to be
more interesting it's a direct carriage
this is a general argument is what the
weather you need to weather should
consider code tested if it's not been
called directly from tests if it's
called but indirectly barrage by some
other code right something some things
some people think that it you could only
call it test it if it's called from test
because that's where you control how you
call it and the other people say no
let's County written because the report
looks better
so basically Jacob could allow you to do
that
okay and there are two ways actually to
do it you could instrument this the test
code or not instrumented test code so in
your invocation feature Russians
any rotation feature means
only the code from the calls which are
going from outside instrumented code are
gonna be considered well it so inner
invocation means invocation don't count
invocation within the instrumented code
okay there are options to do that there
is some instrumentation right here I
could show that the script I actually do
need to show a script not to run it at
least say more inner invocation right so
now we only get reported see a lion has
get start method and it was created from
tests well then get start method it is
calling point yet I'm sorry get start X
right well then it get start exits its
put its calling get x over the point
info but this code is not marked is
covered because it's an inner invocation
right so the other way to do it is to is
to is called caller include which is
basically telling Jake off on the
instrumentation face right here CI
stands for color include what are the
colors are cat tests right this consider
colors and rest
don't tons consider cause that's the
semantics of it it it leaves the gives
the same result of instrumentation is a
little bit different in this case you
need to instrument the test code and the
instrumentation when it goes right on
the end of the test code in this case
okay as is every everywhere else of
course - okay
those were the features distinguishing
which I consider to be distinguished and
for me features for Chekov and I'll
mention couple of more during the second
part of the presentation so just to
recap what we've talked about decide
yeah so you need just just let me go
through it decide on dynamic versus
static constant instrumentation I mean
up to you up to your environment save
data every now and then because if my
question you lose it you may use file
but if you reuse the same file for every
test it's gonna keep growing it's gonna
be huge and impossible to do if you use
separate files for us the the merge
scripts takes weeks to run weeks I'm not
kidding just know doesn't work use
grabber grabber is good okay for big
test suites which contains of
thousands of this yeah so and to recap
what we've talked about instrument
dynamically statically save date until
file into a grabber you could do
individual test coverage you could do
abstract API coverage you could the
field coverage or you could save data at
different moments and you could do
direct coverage those are few features I
talked about in the first part if there
are questions to the first part let's
take like a few minutes okay I'll take
two questions how about that yes yes
yeah the Sonia no you can run it on gel
foil the I don't even worry support for
foil right now but you've been a little
jar file I'm using it on classes just to
have the bytecode
ready for Java P but actually you can
replace with jar files and that's gonna
work just fine it's actually has a
target called product Easter right here
which actually instrument a set of chars
I'm not gonna talk about this just
because of it time limits just just to
say more there is more to what I thought
it to Jake well then I just mentioned
okay the blue ones I mentioned there or
going to mention the rest of the images
don't even mention because there is not
enough time and for those which I did
talk about was for template generation I
only mentioned the blue ones okay there
are more same for instrumentation only
the blue ones same for merger comment
okay
you'll have the slides you can you know
this is actually put a few usage
information on take off anyway so a
little bit reformatted so when try to
apply to open JDK it's really easy it's
this much code that's what it is to do
it for open JDK to color it for coverage
for open JDK so you generate the
template you start grabber you use GT
reg to actually run test jitter each
test harness
whether you know or not it for four pin
GDK and then it just to collect the data
that's all there is to it and I I do
have the script is gonna run take some
time to visit you tells just in the
beginning I've shown data rate
open Java no oh it's it differently no
yeah this one so this is the this is the
Coker information for for a job Java I
hope I pitch by Java I all tests there
are more tests and more packages just
for the sake of showing it to limit it
to some meaningful information as you
see we don't hit 100 some courage and we
shouldn't and this in the second part
okay after I'd done this open JDK I'll
talk about that
so a really easy few comments with
grabber if you won't do it to is file
it's still possible well mr. static
instrumentation grabber is different you
can use static instrumentation or a
dynamic instrumentation independently on
whether you use a grab your file it's
replaceable okay all of it so you could
do it with static instrumentation there
is a special command which instruments
Java Runtime environment in it injects
necessary classes in 30 Jahre that's how
it works adjudicate is gonna work
differently for gdk9 which I'm not going
into today so open JDK really simple are
now interesting for me interesting part
is I gonna start with talking about 100%
coverage do we need it and then is it
justifiable is it meaningful what does
it say one percent coverage then I'll go
on with how do you prioritize it is
development okay and there are a couple
of generic generic ways I'm suggesting
to do it and then I will talk about
tracking code coverage over time on over
different test series more or less okay
so a purely economical look on the code
coverage
values so for block coverage right the
black line it reflects the cost of
testing cost of test development
actually so the higher you go on code
coverage on blog coverage more expensive
it is to develop this I don't know how
exactly it looks and maybe this
different product by product but
something that it's supposed to grow at
the end because grow faster because it's
harder to develop tests okay all it is
easily reachable code you
you can easily get like for NetBeans
simply starting on beans netbiz hits for
40% of coding come on
so at the red line showing defect
detection rate and it believed to go
like this right so the closer to the end
you get less bugs per per percent of
percentage of coverage my speculation on
this is that what you have left is like
exception handlers which are very simple
okay I don't know what is true it's just
my speculation but I think it's this
explanation there's not much data after
90 percent there is not the data before
50 percent is not interesting at all so
that's why I limit it like this now so
the cost of testing is the money you
spend right different detection rate
multiply the cost of defect for the
company is the money or in or rather do
not lose okay
so you take 1 you subtract that from the
first one and that's where you want to
be right I'm not able to do that for my
products I was never able to do that
this is too hard I don't know where we
want to be okay
based on that I am NOT aiming not
suggesting always in a system of not
getting any target on book on
implementation courage 70 60 who knows
right well for some practical senses
let's let's talk about the different
aspect of it what does it prove so you
have one heart because percent of low
coverage let's take a look on this code
it this is a simple method which is
supposed to verify whether the parameter
is zero or not okay and it has a bar
right here so now let's develop test for
it we develop test we pass value 1 as a
parameter we'll hit this line we'll hit
this line this line and this line and
you'll get what we've expected so we got
the test suite consisting on one test we
get 100% pass rate of it's this suit
it's always working we get 100% ball
coverage right but the back is still
there right smart people would say yeah
yeah you need branch coverage here of
course yes sure let's do branch coverage
this is another example this is this
code is supposed to verify whether the
will is
positive okay it compares to null and
makes a decision but know not to know
and that's a balk right it compares to
some other way so we do pass one hit
this line hit this line expected result
passed - one expected result so result
is the same we have this suite
consisting of two tests we get 100%
block coverage you'll get one obscene
branch coverage test suite is always
passing the bug is still there right
some people would say yeah you need data
coverage well believe me and I will link
the slides at the end that doesn't help
either I have examples on all that it's
just aside a little bit outside of this
presentation because Jacob could only do
branch and block coverage from product
for this particular subject okay so what
you end up is a bunch of incorrect code
where it's it's really a lot so you
don't know where to start this the
program alright so I'm suggesting two
ways to deal with this first take a
subset of the code cache information
which you need to cover in full whether
you need to be you need to be able to
justify that and the second one is you
can rank the uncovered code by different
characteristics are going to show a few
example of it first example is public
API so whenever I put in a library or an
SDK provides public API it needs to be
carrot and test 100% right well this
let's just stick for stick to this
statement right now we'll talk about it
later and whether it should stop send a
public a packet from public America
which doesn't prove anything
it's not sufficient but it's necessary
if you stare is this edge with this
statement you could do it with jack off
generate reporters only the public API
it's good but it's rather blunt because
how does jack off know what is public
API even Fuji dk8
where I have this definition all the
public and protected API and Java and
Java expect atures even that is not
accurate because there are constants
come some classes which are commended
for years right and all G gdk9 is going
to be completely crazy because there are
going to be modules Gigi code doesn't
know and at this moment we hit at this
point we hit a limit of
what we can do is Jake off as a common
line tool okay now it has some API and
SPI so yeah I'm not gonna show this code
do this all the time you could write
your code with this API so basically
load data and perform operations on such
as zero-calorie to remove something you
don't need and stuff like that you
create a Java code and you do that okay
you will do many things but just to step
back whatever I talked about public API
right is good only the good public API
is abstract right so how about it well
we have the way up the counting abstract
feature of j-curve abstract on a charge
a cough so you could do that the problem
is still there because an abstract call
abstract method is gonna be considered
current if any of its implementation hit
that's not what we want actually not
from jdk testing perspective that's what
we want from gck test in perspective but
it's a separate conversation which I'm
not going to so yeah so determine I have
the jungle I have for this is public API
implementation which are the
implementations of public API well if on
that example when I solution of the
publicly brave iterator
returned from iterator method right from
where an ArrayList I am actually looking
on on a private in your class okay so
the actual iterator returned for this
array list is going to be private in
your class how do I get that those
methods right that's that's one idea to
do that and I can get it just to just as
a proof of concept the day before
yesterday I just created this from
scratch just to show that it's possible
we do have this code and in this system
but it's hard to pull it over so I
decided okay let's let me try to do it
from scratch oh I almost forgot this
always a check of API for I didn't do it
for quite some period of time
so and in like in less than an hour I
was able to do that so and I can show
the code I think after this session
because we might be right out of time so
an interesting an interesting class here
to open is the data input stream oh now
object and for I'm sorry and I'm just
waiting here city object and position so
what is you see in the report is for
example this one big input stream vision
in their private in your class of the
object input stream and it's read close
available methods are implementation of
an oven and put stream abstract methods
actually so these are order overridden
methods these are effectively the
implementation of poverty pay so you're
taking the public API abstract or not
and fold it for this you find in all the
methods which implement or override all
of that okay that's one thing you could
do it you one thing you could do I
didn't know whether you could go that
far it should go that far for your
application alright so I don't know I
want to skip this yeah that's what I
talked about and just show this all
right so now interesting part why get
into argument argument is reduce some gk
development engineers with them could be
unnamed as to whether we need to cover
public IP or not and they have a good
point
so if we take a look on the like file
yeah so get pumped method this is the
OPA GDK source for Java IO file take a
look on this method do we really have to
develop test for that well from
compatibility perspective we should
write but from an implementation
perspective we still maybe maybe should
should develop test for it but is this
is developing test for this method more
important than development is for other
methods right no because it's simple
right you just can see it with your eyes
that it's that it's working right right
now so we should
that from from from the you know the
methods which we need to cover first in
public API so some code is just due to
simple to care about it in the first
round okay such as one light line
langauges to overload method
calling method with the same name
specifying one parameter I mean it's
it's it's working we know that right we
know that they can see that with my eyes
also there are code reviews etc etc so
we end up remained up not doing that
then it's not possible to test
everything actually they take a look on
the hash code hash code needs to be
tested right of course no question asked
but how do we test it in part of the
open JDK regression test you there is no
reliable way to do it the regression
test it is supposed to run fast ok so
the hash code should not be covered in
the opportunity relation to see yeah
okay and so what's better would happen
if there is an X there is a bug in in an
exception constructor another exception
is it that bad so the argument is that
maybe not all code is that important
even the public API so it's Jake off you
could do all that and I am going to
open-source my code which is do you mean
some time to do that and I I'm actually
gonna show it right now I have a script
which does all just talked about and
it's called same API Sh so I'm filtering
out simple Gators setters I'm filtering
out exception methods I'm filtering out
stuff like that so again I have the few
reports open for me
so in this report this is this is the
whole public API for Java I hope I catch
it right we have 160 something methods
uncover it in the public API from that
we subtract what is this getters and
setters right this methods which are
like the one I mentioned
give get path right we may not really
need to develop this for ok straight
away maybe later
and this one is covered but there are
some which are not
current because if you go to over you
the coverage of these Gators is like 43%
it's only seven okay for the whole JDK
number is bigger okay for this is just
say alright
overloading which is one method call
another method by specifying one
parameter that's that's again that's
some more Lord and Master five foot
buffer input stream there is an
overloaded constructor okay it's
probably adding some parameter then
calling another constructor right for
exception I feel that exception that
what what the end what we end it with is
this line just closed this one's okay
section other so okay
so we had one hundred sixteen eight
methods to cover and now we only have
120 so those methods the rest of a
matter which we filled out on but now
the question is how did I do this route
how did they discover Gators and there
is a piece of code right here I guess
basically with awesome I am checking
that this method okay it's not getting
better
my ID is netbeans so anyway
I'm shaking the bytecode of the method
right that's what it is and so I'm able
to discover the Gators and same for the
other things something said this current
on based on signature or name or some
like that but this time is it's bipolar
so there's the same saying public API
concept saying public API coverage
concept I promise I'll open open this
code as part of Jacob so okay so now
public API is only for libraries right
what do you do for that for other things
right with what if you develop a product
which doesn't have a public API well you
could you could select different things
in this and that's what what I did for
NetBeans back then checking the UI
coverage so every element of UI of a
product needs to be instance initiated
at least once during testing okay hard
to argue every dialogue needs to be
shown at least one once during testing
and stuff like that so for NetBeans I
was I was actually achieving coverage of
user actions in swing everything is in
action right so I was able to filter out
actions so every action needs to be
performed at least once and there's a
success story because we find missing
test cases implemented missing test
cases we find found a dead code and the
thrown it away
it's just went really well one example
so for a particular product you may do
something you may need to do something
different in MVC controller typically
contains very very little of boilerplate
code so it's a good target for 100%
coverage that's what the order I did for
another product once it made sense okay
okay so that that was about selecting
different subsets you had you'll have to
really figure out one for your own so
for for NetBeans people support we
counted people elements coverage why not
write stuff like that it could be
anything at the end you still live we
still left with a lot of uncovered code
which ones do you do develop code tests
for
for I'm sorry it was clumsy
so actually what I'm suggesting is to
rank the code carriage information based
on other characteristics of source code
so a new code is better be tested before
it goes to customer old code is already
probably tested by the customer or not
needed by anybody okay so why would you
spend time on that one
so prioritize by age by number of
changes any change to the source code
introduces a risk of a new a regression
right so you can you know bump up
priority for those which have many
changes bug density the more bugs found
there there is likely more or maybe more
will be introduced it is fixed fixes
code complexity that's obvious right the
more complex code has probability higher
probability you have bugs so put it in
one form or assign a coefficient to
every particular cluster it's it's what
I've just said right norm it by the quad
carriage that's the way I did it we we
didn't complete the loop but at least I
had the tool to use we haven't been able
to use it for different reasons okay it
did something if it doesn't work for the
next release adjust their coefficients
that's what I'm suggesting to do okay
last thing is called carriage monitoring
you do know you do need to know how it
is going with your your code right in
time are you improving or not which test
suite is better than there is one test
with this bread vendor have to see it
etc etc so company you can compare it to
test Suites on the same not the same
byte code by simply issuing this command
of Jayco giving given to two arguments
compare compared to SH yes and it'll
create this report for you where we have
three first run your second okay and
it's actually comparing here I'm
comparing very very not relevant set of
tests so I give a little bit coverage so
this this constructor was cold by the
first
set of tests but not code by the serum
test set of tests whether with when we
try to compare courage for two different
builds it's getting troublesome because
the bytecode is different there is no
way to mix in much they stop between two
different bills what Jacob offers is a
is a option called - loose blocks which
basically drop in all the block
information from the from the from the
data file only living the meta
description methods you could match
based on signature okay and I'll be so
you can do that I will not show the demo
because so the limit of the time you
only have the methods in the data file
whatever you the Jacob reports are good
but for practical purposes you need you
need to be able to decide which one
tester it is which the suit is better
than the other decided in a mechanical
way not looking the reports and
comparing the report every time right so
with the jerk-off API we want limited
subtraction which we will open source so
where you can take courage from one
built and from one test suite and
subtract from them they talk from from
that the code cache from the other tests
it okay it's it's really simple straight
source code you can do it on your own
not even wait for me the other
publication is this base reduction of
the application of the J curve which is
it's a bad idea to throw away any test
but it may be a good idea not to run all
the tests that often so some tests you
may run not that often
okay this code coverage information is
perfect for that
unfortunally for now Jekyll don't
provide this capability so you have to
load the Jacob files and Rohde through
the API figure out which tests to draw
basically take courage for one test
subtracted from the overall coverage if
it doesn't change then this test you may
run not at often okay almost done very
good on time using the data what we've
talked about 100% courage is it needed
is it possible economical aspect
remember what does it mean
getting subsets which you need to cover
now
cent I talked about public API you I can
controller coverage there could be
anything anything I will take off all of
that is simple relatively monitor
encourage in time comprehend test Suites
etc why have a con homegrown database
which I wrote for that okay when we
store their results because the static
HTML reports is just not good enough
okay and I'll talk about that in a
second prioritizing this development by
ranking be uncovered code comparing test
Suites comparing runs that's what they
talked about more information it's open
source it's over there
right I linked a few so basically the
demo I would do here is just go to
Firefox and say Jake off da that's all
we need to know okay oh and this is
Ricky and it is how to build Jake off
right on the first to Google page okay
now the second part which I talked about
the coverage metrics etc etc go to
SlideShare and search for pragmatic code
coverage those are my slides which
described all that in details or drop me
an email my email is on there and those
flights also okay well we'll talk about
it
okay so last lasting hard-on last last
most lasting we are playing next rule is
quote quote release yeah this is what we
are thinking about there is currently no
plugin for Jake oh for 3ds kinda sucks
we're gonna develop maven maybe
something else we're gonna develop a
database which I talked about store
results built by built-in and compare to
get you know the trends out of it and
statistics out of it to select tests to
do the ranking also so basically you
take that you should check off you
supply your auxilary information into it
through some kind of interface such as
age of the call or whatever and it it
the way you could discard the more
important code and we're gonna the air
you're gonna we're gonna introduce the
tool for test based reduction also these
are the ones we're thinking about well
I'm saying we I'm not gonna be doing
that
she's gonna be thinking we guys to do it
more or less but if you have more ideas
I mean it's it's almost source first do
it yourself or just there open the mail
to the guys and we'll consider it okay
this is this is all I wanted to do I
wanted to talk about what many more
things with there is no time for that so
this is all for now thank you and we
have two minutes for questions I always
yeah I always describe subject and full
I know that there are no questions thank
you yeah give me a second give me
anything
yes where's the caller include feature
you can do that we'll call the callers
or this module and they call whatever
this module and you can do that yes we
you could relate you could do the
internal dependencies courage yes it's
interesting feature I didn't think about
that thank you
yes scripts no only the slides there is
no no no way from it all to make them
available basically the slides gonna be
available on also installation what it
sits in the QBs we thought about it yeah</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>