<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON6923   Finatra: The Fast, Testable Scala Services Framework That Powers Twitter | Coder Coacher - Coaching Coders</title><meta content="CON6923   Finatra: The Fast, Testable Scala Services Framework That Powers Twitter - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CON6923   Finatra: The Fast, Testable Scala Services Framework That Powers Twitter</b></h2><h5 class="post__date">2015-12-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jdINjBISCFs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone thanks for coming my name is
Steve cosenza here's my coworker Chris
Coco we both are engineers at Twitter
and women creators and maintain an
assemblyman entreprise for those of you
hoping to get to lunch I promise I will
not difficult time with a half hour I'll
leave some time for younger questions
and Titans beer so how many of you then
I'm teams that had strongly the best
thing
and how many of you have been on the
receiving end of buggy software as all
of you guys to know in today's world
software testing effects elements so
over the years have had a good fortune
of leaving several teams ready to
deliver extremely high quality and well
tested software and I consistently found
that the enabler to creating these pests
effective teams was to make writing
comprehensive tests simple and quite
frankly fun so today I'm here to talk
about the recently open source the
National Library which helps for
engineers right high performance high
quality and well tested software but
before nine weeks the details let's
first answer question some many neurons
the question of what's with the weird
name not sure so there's a rationale by
the name and the name is actually the
combination
onliners the start of our name comes
from the Finnegan liner which is
Twitter's library for writing highly
concurrent services um junior mantra is
built on top of enable and both are
written in style which is the most
widely used server-side language enter
and enables not just used a Twitter and
on screen you can see a sample and other
companies short easy connect
the end of our name comes from movies
popular natural iron which defines a new
cell for making it easy to write web
applications now for not sure does not
share any code with signature but we do
share their philosophies of simplicity
and mingles so they're at you take the
high-performance traiga library combine
it with the simplicity in ableism of a
snatcher library you get fo not sure
which makes building applications on top
of Twitter so good source that an
absolute joy fanara e1 started in 2012
it was a side project by q Twitter
engineers it was developed completely
and get up from the beginning quickly
gained a following to you its simplicity
in 2013 myself and my coworker Chris
started work privatizing an API to
deliver data access some key and of
course partners and ate cat
accessibility is a major concern ours so
we need to write some additional cooling
make it easy to write the types of tasks
you wanna throw
and to do that we became the furniture
of acute affairs and started reciting it
Miranda the support testability about a
year later in 2014 we released
photography to internally at Twitter for
other teams to use and then we started
working in our next few half weeks
making version table research that
culminated in april of this year when we
release their first milestone to get up
and made in central and about two months
later connacher b2 is declared Twitter's
production framework for all knew each
GP services and finally just last month
we released the full 200 to release to
get up
all that'll work contra not sure is done
in Twitter's internal depository but we
do say all changes weekly together or
developed under the action to license
and we accept for questioning okay so
I've now like to discuss three main
topics related to founder with the first
event being teach earnest so I mentioned
earlier that testing was a major reason
why we created Sinatra details you're
probably asking yourself now what's
future distant future testing is a name
given to a style of testing we found to
be particularly useful it combines
elements ambarish investing in process
component testing and atom processor
core investor a typical feature test
uses test levels to replace external
components and usually there's one
feature test for every customer facing
environment so let's say creating a user
by posting to the /g complain that would
be a good requirement that bigger penis
now a feature test normally works by
performing blackbox assertions where the
issue requests and the survey responses
however a future tests can also perform
white box assertions against internal
plastic note a feature pest is not an
end-to-end test because we use these
tests doubles and places external
components and that's really important
to making sure feature test remains fast
and deterministic
okay so you're good choice now between
right future tests and a more
traditional unit or regression test you
may be asking which one would you write
which one would you rank first so for my
team the answers if you're developing a
new customer facing feature you only try
to future fest purse and this is really
nice because regressions customer-facing
aggressions are immediately detected
writer writing because it and it makes
for factory release because you have a
fast from the customers perspective now
we're not the only project that we use
the feature test first methodology and
the current the FDA CTO of typesafe
which is the company behind scholar he
had this to say he was
in our tests philosophy and future test
is something we must have it's a test
that verifies that something we want to
build works and works as expected if you
don't have a feature test you might not
even have a feature so you now have to
ask yourself what is this feature that's
look like a nun screen you can see one
this is an example of writing a feature
test for an HTTP service so we use an
invented HTTP server to rat are sir we
can then call methods on it in this case
we called an HTTP post method we specify
the path where we want the request ago
we specify what the request looks like
are expected ok response and then in
this case we expect the response we JSON
and reflect the inline Jason
excessive
or so now let's look just generally
speaking the quality is that any good
test will have so first a good
test-retest it's not fast you can't run
a continuously all right
saving a good test needs to be
deterministic not flaking otherwise
you're not going to trust the test and
everybody fails just might cause a
necessary churn trying to track down
next a good test has to actually catch
bugs so that means it needs to be
asserting the right things in the right
places and finally a good test needs to
be easy to write and easy to maintain
otherwise enough of them will not be
written and your test coverage is going
to suffer so now let's look at a real
world example so my team is responsible
for the nip engagement API which was
just released last week at flight we're
super excited and to test that API we
use a test suite primarily composed of
feature tests so on the top of the
screen you could see this test suite
running in RI da we have about eighty
eight tests and they run in only seven
seconds and on the bottom of the screen
you could see the test coverage that
we're able to achieve so we're able to
get ninety nine point six percent
statement level coverage using this test
suite okay so a couple things worth
noting here first test coverage means
nothing if you're not asserting the
right things in the right places however
we do believe having good test coverage
is a prerequisite if you want to be able
to catch bugs before they hit production
second these tests are higher level than
a traditional unit test however because
they run quickly they can be run
consistently whenever you're writing new
code and that mitigates many of the cons
often associated with higher level tests
which can only be run periodically
throughout the day second I mentioned
this earlier refactorings become an
absolute joy with future tests because
they tend to be extremely non-parental
which means when you change and refactor
some internal classes you rarely need to
change your future tests which is really
nice ok so now on to the second topic
so for the second topic I'd like to
discuss dependency injection frameworks
so as many of you in the audience
already know dependency injection is
simply a design pattern that seeks to be
couple of class from the Croatian or
look up of its dependencies and
dependency injection is nice because it
makes classes unit test of all so you
can see it in a variety of programming
languages and a variety of frameworks
now since it's simply a design pattern
of course it can be done manually so the
question becomes why do we need a
framework and for that let me introduce
you to dependency injections
arch-nemesis which is boilerplate oops
boiler foot so boilerplate are the
sections of code that you have to copy
in many different places with little to
no change Joshua Bloch the author
effective Java describes boilerplate as
being ugly annoying an error-prone I
definitely agree with that so in order
to eliminate boilerplate the question
becomes what can we do and the problem
really becomes as your application grows
the amount of boilerplate also quickly
grows so you're in this kind of
conundrum where dependency injection is
good for us it makes things testable but
we don't want to get this tech debt a
boilerplate
okay so one of the things we can do is
enlist the help of dependency injection
framework one of the key things that
these frameworks are going to do is
they're going to eliminate boilerplate
related to object construction that's
just what they do second dependency
injection frameworks provide a nice
consistent methodology for configuring
your classes throughout your throughout
your service and finally dependency
injection frameworks facilitate seamless
integration and feature testing because
it makes it really easy to swap test
doubles into various parts of your
application during testing and we're not
the only Scala framework to adopt the
dependency injection framework primarily
for the purposes of testing so the play
framework if you guys aren't familiar is
a popular web framework on the JVM
targeting Scala and Java and they
recently adopted a tendency injection
framework specifically for the purposes
of testing their tech lead had this to
say the main advantage that dependency
injection brings is not realized until
you start writing tests once you move on
to integration testing this is where
play can start to realize the advantages
of dependency injection
so we decided we wanted to have
furniture include out-of-the-box support
for dependency injection if you chose to
use it and we decided on a sr 3 30 which
defines a simple set of annotations that
any JVM language can choose to use for
implementation we chose Google juice due
to its simplicity popularity and
maturity on the JVM on screen you can
see what these jsr 3 30 annotations look
like on the top you'll notice and at
singleton this signals to furniture and
juice I only want a single controller to
ever be created a line below you'll see
the at inject annotation this is on the
constructor of that class so in Scala
you can add the at inject from the top
there and all of those parameters those
are the class constructor and that's
basically it that just signals the
finish orange juice when you create this
class i also wish for these dependencies
the user repository the search service
and the engagement service i wish for
those to be provided to me so now that
we have a properly annotated class let's
look at how we add that to our server in
this example we're an HTTP server so
we're servers just going to extend the
HTTP server class we then provide a list
of juice modules that have the
configuration for some of the classes we
want to inject in this case the user
repository search service and engagement
service and then we override the
configure HTTP method in here we could
specify a list of filters and a list of
controllers who wish to serve
notice that there's minimal to no
boilerplate in adding these filters and
controllers we simply add them by type
and juice then does the heavy lifting to
create them and to create the
dependencies that these classes need so
it's really nice
I mentioned also that dependency
injection frameworks facilitate seamless
integration and feature testing and
here's our example of using juices
support for replacing classes with test
doubles so under the bind mocks comment
you can see an app bind annotation what
this tells juice is I wish to replace
the real database client with a mock of
that client in this case we use mockito
to create the buck similarly instead of
using the real HTTP client we use a mock
HTTP client we then configure if you
don't mind we then configure the mocks
in this setup mock section and that's
simply getting the desired behavior at
the desired time alright the third topic
I want to discuss today is consistency
so furniture enables a consistent look
and feel to various application types
that you may want to create and this
extends anywhere from creating a command
line utility to a long-running server
let's say that's listening from a
message queue to an HTTP service to a
thrift service so to demonstrate that
consistency on screen you can see an
example of creating a thrift service
using fenêtre
notice now instead of extending the HTTP
server class we now extend the thrift
server class but otherwise pretty
consistent look you specify your modules
in this case the same modules that we
used in the HTTP service we override
configure thrift instead of configure
hdb and we specify a list of filters and
that we specify different service who
wish to serve the consistency also
allows us if we wanted to create a
server that's both so on screen you can
now see a server that extends both HTTP
server and thrift server again same look
set a joose modules you may even notice
we're able to reuse some of the same
filters across the different service
types that's really nice now you may be
asking yourself why would anyone want to
actually do this be both thrift and HTTP
and we found there were several teams at
Twitter that wanted to create you eyes
for accessing some of the internal state
of the threat servers that were
maintaining so before fenêtre they had
to learn two completely different ways
to configure the thrift server versus
HTTP server but with fenêtre there's
now consistent experience across the
book
the consistency also extends to feature
testing so here's an example of feature
testing a thrift server in this case we
now use an embedded thrift server to
wrap a real thrift server we then obtain
a client from it and then we can make
calls and assert their responses the
consistency also applies across
languages so on screen you could see an
example of creating a java-based HTTP
server and while of course the java
syntax is slightly different than the
scala sintex you'll notice the same
concept we're supplying a list of juice
modules and these are the same juice
modules that can be used in Scala and
then we override configure HTTP we add
our filters we add our controller not
only that you also get a consistent
experience creating your controllers and
if you're able to use Java 8 s new
lambda syntax the consistency is even
greater so in the top of the screen you
can see an example of a scala based
controller and on the bottom of the
screen is the same controller written in
java using lambdas
alright so now that we've discussed
feature testing dependency injection
frameworks and consistency I'm going to
walk through a little n tent example to
see how the pieces fit together so for
this example we're going to create an
API and that API is going to return a
user's most popular tweets given a time
range will call this API the popular
tweets API and will define popularity by
the number of impressions and the number
of engagements that each tweet has
received so the requirements from your
product manager are as follows we want
to accept the post request for the / AP
I / popular endpoint an API key is going
to be set in a header the request is
going to contain a JSON body with a
start field at an end field and both
they're going to be ISO 8601 formatted
if the request is valid return a 200
response in the response return a JSON
body we're going to return the start and
end and then a list of tweets and
popularity order so now that we have a
requirements let's first write a feature
nest and here you can see basically the
same feature test we showed earlier but
since we haven't written any production
code yet you'll notice that we just use
a blank HTTP server at the top will fill
the simulator so now we run this test
and of course it bells we haven't
written any code yet however we now have
a compiling failing tests that we can
use throughout the implementation of
this feature all right so let's start by
first parsing the request furnitures
approach to parsing JSON is to create a
case class that mirrors the structure of
the JSON you on so in this case on the
Left you could see the JSON that we want
to parse there's a start and end and on
the right you could see the class it has
a start field it's a date time and an
end field which is the date time you'll
also notice that there's an appt pastime
annotation that's a validation
annotation and that signals to fenêtre
that these times have to occur in the
past they wouldn't really make sense if
they were in the future in addition to
that you'll see an app header not empty
API key and what this signals is the API
key that's going to come from the
request header and when you validate
that field make sure it's not an empty
string it has to actually be populated
generating JSON is a similar concept we
create a case class to mirror the
structure of the JSON wanna generate so
in the left you can see the JSON that we
need / requirements on the right a case
glass with a start field and enfield and
a sequence of tweets okay so now let's
look at how we would get the data for
this API and we're going to use two of
Twitter's new api's for this the first
is the full archive search api that will
let us get a user's tweets for a given
time range among other things and the
second api is the engagement api which
give it a tweet ID will return the
impressions engagements that tweet has
received so now let's look at what a
controller would look like that would
make calls to these two services then on
screen you can see that so similar to
prior examples were a controller we want
to be a singleton there's only one that
will ever be created we put in at Jack
to wish for it to participate in
dependency injection and then in the
middle of the screen you'll see the
Sinatra style dsl for defining your
routes so in this case there's an HTTP
method which is a post we then specify
the path which you wish to handle / AP I
/ popular and then the body of that post
will contain a call back the callback
will contain a request and that request
is going to be the custom request we
just created that knows how to parse the
JSON that's incoming
in the body of the callback you can see
how finagle handles the combination of
non blocking operations so this is using
scala's for comprehension syntax and
what you want to note here is all three
of these calls the call to the user
repository the call to search service
the call the engagement service those
are all calling external services
they're going to return non-blocking
futures but using scholars for
comprehensions and finagles elegant
handling of these cup of these futures
we can chain these operations together
without nested callbacks or other
boilerplate it's really nice if all
three of these calls successfully
succeed we then yield an API response
and this is the response we created that
will turn into the JSON that we desire
this controller then will get added to a
server you'll notice and configure HCP
we add a set of common filters that most
servers will want to have and then we
add our controller we then update our
feature tests then instead of the blank
HTTP server we now use the real popular
API server that we just created and now
we could rerun our test but this time it
fails again but it failed for a
different reason it failed because a
resolver was not found for this data API
flag and while this error is a bit
cryptic this is finagle telling us that
it tried to connect to an external
service that was defined with a data API
flag but we didn't tell it how to find
that service and to fix this we need to
use a test double in place of the real
classes that are trying to make remote
calls so for that we use our at bind
annotation and now that we have at bind
replacing the database client and the
HTTP client with mocks when you run that
test again it will succeed ok so we've
seen kind of a happy day path a valid
request hitting our system let's write
one additional test of what an invalid
request would look like and in this
example we'll have a start field that's
not valid an end field which is
occurring in the future and you'll
notice we're not setting the header that
passes the API key anymore
when we run this test it succeeds so
furniture was able to determine that
this request was invalid now one thing
worth noting here if you look at the
error message that was returned with
this 400 bad request furniture did not
stop at the first error but instead
accumulated all the errors so not only
did it tell us that the header wasn't
found but also told us that the start
was not a valid ISO 8601 and it told us
that the enfield was not in the past
so I've really enjoyed walking through
some of the features and motivations of
fenêtre here with you today we first
talked about fenêtre support for future
tests with make it easy to write a
comprehensive test of your service we
then looked at our built-in support for
dependency injection which we showed
eliminates boilerplate and facilitates
integration and feature testing we then
looked at consistency and how furniture
enables a common look and feel across
the spectrum of applications and finally
we looked at an intent example of how
these pieces kind of fit together so for
all of you in the audience that are able
to try a new framework either at work or
for a side project at home please visit
our github page try out our examples and
provide us with any feedback you may
have and for everyone I'd encourage you
to try a feature test approach to
testing your software we found it work
for many of us at twitter and i think it
could also work for many of you so thank
and then yeah curse and I are here to
answer any questions you may have the
main reason is that all of our RPC
services at Twitter are built using
finagle and using finagle gives us a
nice consistent experience for doing
things like stats and having common
admin pages a common way comment
lifecycle so we basically needed a
service that was built on top of finagle
yeah play uses akka and that's not
supported at Twitter right now yeah
come on the dr would it be possible that
some of the springs
right now the core of fenêtre is
dependent on juice so if you use the jsr
through 30 annotations you don't have to
necessarily know you're using juice but
yeah right now we're pretty tied into
that as an implementation we it is worth
noting we would love to consider using
dagger to but dagger does not support
scala at the moment
data access No
you could ideally you would want to use
some library that was non blocking
finagle does offer some support for
protocols like my sequel and postgres
you certainly can manage your own kind
of future pools if you are using a
blocking library but the best experience
you would get is if you were using
finagle throughout
yeah to DB server and all that stuff
assume it's going to be independent
different class of
yes so the question was related to the
different service types and how they
would fit into a container sofa not sure
of being built on top of finagle means
that each one of these servers are
standalone so these do not run inside of
a servlet container the output of a
phenom project is a zip file or a jar
that you can run locally it uses nettie
underneath finagle uses Neddy yeah so
kind of the stack is Neddy finagle
Twitter server sinatra
Oh
three
three bites
wait
too why is it good to write a test Oh
the question was related to why tests
having all three of the fields being
invalid in the same test the reasoning
would be it would simulate a customer
use case a customer when they have a bad
request might have several things wrong
in that request and we'd rather not just
say the one thing that failed because
then they'd fix that one thing come back
again and we say oh we also have to fix
this so if we're able to detect all the
things that are wrong we want to be able
to tell them all at one time but you
certainly could also test that
individual things being wrong would be
detected
yeah kind of at the point where you have
a feature test it's then up to you to
decide if you'll get value out of more
fine-grain tests so if there's a
particular component that you want to
specialize on you know feel free to
write integration tests or unit tests of
that but yeah the the key thing we found
is having that feature test their first
to kind of cover the comprehensive case
is really powerful and really helps
anyone else
so far as as far as a request processing
and marketing is concerned I missed it
understand but like let's say for the
start date
the fact that it has to be like guys or
whatever it was
an innovation or something that
something is provided by
yeah basically since we use the
date-time there that was a joda date
time so by default there's integration
with Jackson which we use to parser JSON
that will parse an ISO 8601 for you if
you want it to support other formats you
could plug in D serializers for specific
types yeah
alright well thank you guys will be
around after if you want to come up ask
any additional questions we also have
stickers up here if you guys want yes
and we have stickers yeah yeah thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>