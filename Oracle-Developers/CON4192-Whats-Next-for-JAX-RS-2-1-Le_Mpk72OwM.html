<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON4192   What’s Next for JAX RS 2 1? | Coder Coacher - Coaching Coders</title><meta content="CON4192   What’s Next for JAX RS 2 1? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CON4192   What’s Next for JAX RS 2 1?</b></h2><h5 class="post__date">2015-12-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Le_Mpk72OwM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome my name is Santiago Vegas
Goodson and I'm the coast fact lead for
jax-rs to that one also jax-rs to do
without we finished for EE 7 the jsr
number is 370 and today I'm going to
give you a quick introduction about the
things that we're thinking about for two
dot one so I'd like to start with the
safe harbor statement basically says
that you shouldn't make any
life-or-death decisions based on what
I'm going to tell you here today or even
worse job hiring decisions based on what
I've tell you today but serious been a
little bit more serious everything that
I'm going to tell you today is subject
to change we're a little bit behind with
respect to the other j-stars we're
hoping to get the ADR done by the end of
the year but we'll see how it goes now
Before we jump into to that one I like
to do a quick recap of Jack's Rs 20 how
many of you have used jax-rs 20 place
your hand Wow almost everybody that's
awesome okay so let's go quickly over
what we've introduced into that 0n and
then we can see how it connects with the
things that we're thinking for to the
one so these are sort of the major
releases in other words these are sort
of the major features that we have for
this very large release that we had into
that oh we've introduced a number of
different things the first one is a new
java client api which what was
interesting is that in jax-rs one it was
an on goal to have a client api but by
the time we go to jax arrested oh we got
a lot of requests for it so we introduce
one and i think most people like it i
hope so we've also introduced the notion
of filters and interceptors the goal
here was to try to address cross-cutting
concerns in applications so that you can
move that logic into into the correct
location in addition we integrated with
the validation api which was rather new
at the time so that you can validate any
data coming in or out of jax-rs resource
we've created a new
configuration API I don't know how many
of you have looked at it but it was
pretty difficult to configure jax-ur as
one I think it's a lot better in jax or
s2 and this covers both the server api
and the client api we also added some
basic support for hypermedia in the form
of link headers we've had requests to
add a little bit more around hypermedia
but frankly has been a little bit
difficult to do so I would love to get
some feedback on that at the end of the
talk if I can and finally we've done
some work around asynchronous processing
which is what it's going to connect with
some of the things that we're going to
be talking about today so very quickly I
just wanted to show you a diagram for
the Jack's arrest to server pipeline
these diagrams have been lifted off the
specification the PDF document that's
why they're black and white and they
basically highlight all the new things
that have been introduced into that I'll
say if we start from the right top
corner when we get a request and we'll
remember looking at the server side here
we have a number of different filter
change that the request is going to go
through the first one is the so-called
pre-match filter chain which we execute
before doing the matching algorithm in
jax-rs which means that any
transformation you apply to the request
at that point is going may have an
impact on the way the request is matched
so for example if you change the HTTP
method or you change the accept header
that's that may have an impact on the
request matching algorithm after that
there's the so-called container request
chain where the request is going to be
further filtered until we get to the
actual method invocation of your
resource so once that's done the
application if there's an entity that
needs to be read the application is
going to request that entity to be read
and for that we use the extension point
that has been around since Jack's res 1
which is the message for e-readers but
the addition in 20 was the filter and
Tory the interest interceptor chain so
that you can intercept that call and do
additional processing while reading the
entity and then looking at the second
part of it there is the container
response chain where the response is
going to be filtered
and before we write the response back to
the client we once again have the
ability to intercept the calls to the
message body writer right before the
entity is written and you may have seen
some examples of interceptors for doing
things like compression or any any task
like that now looking at the client
pipeline it's a little bit it's similar
of course there is no matching here
therefore there is no pre-matching
filter chain but in essence everything
else stays the same we have a request
chain a response chain we have message
for the readers and writers just like we
had in jax-rs one but we also have the
addition of the Interceptor chains for
the client all right so that was a very
quick introduction to jacks or s2 and
let's look at the things that we're
planning for the next version there's
sort of the topic for this new version
is to include some of the what we call
modern features into jax-rs and improve
some of the features that were
introduced into that out so these are
the ones that we're thinking about and
we're currently discussing as part of
the expert group the first one is
reactive programming and this comes
because asing programming is really hard
and we're trying to make it as easy as
possible for you to do that with jax-rs
and we'll see what are the ideas that we
have coming around reactive programming
the second one is non-blocking i/o
there's a certain class of application
so that need really fine control over
blood / input output and we think we can
address that in jax-rs just like
certainly did in the last release and
the third one is server sent events
super sensitive event is an interesting
technology that a lot of people confuse
with WebSockets but we'll see today that
they're they're different and they fit
much nicer into a jax-rs API then work
probably anywhere else and finally we
have alignment with Jason B and NBC
these are two specifications two new
specifications in Java EE eight if
you're interested I'm interested about
nvc I'm going to be talking about it
tomorrow all right so let's start with
the reactive programming and we're going
to throw that the basic motivation for
reactive programming is that a sink
programming is really hard and using
reactive api's it's a little bit simpler
and we'll see some examples of how that
works so let's do a quick recap again on
on what are the features that we have
available today for a scene programming
in jax-rs and that's going to help us
understand where we're going with this
idea so on the server side as part of 20
we introduced to new things a new
annotation call-out suspended and a new
type called a sink response these two
really go hand in hand you have to use
them together at this point the idea of
the odd suspended annotation was to
create an extension point but so far we
haven't found that another use for it so
it's it's really the async response what
you're using in the case of the server
side and the idea is that you have a
request thread in which your resource
method is called but you're going to be
telling the jax-rs run time that you you
don't want to return a response in that
very same thread you're going to free
that thread back to the container and
you're going to use another threat to
return the response at a later point in
time and I believe I have an example of
that and then on the client side which
is really the topic of today and how it
connects to reactive we added support
for future and for it which is part of
the JDK and also we created a new class
called invocation call back to support
to better support a sink so let's have a
quick look at how these two constructs
work today starting with future we're
looking at the client API this is the
focus for this section I just think put
the first few lines this sort of the
boilerplate code to make sure that we're
all in the same page we start with a
client we from the client we create a
target and once we have a target we can
initiate our request in jax-rs so the
way that works is we start from the
target we say using the fluent api we
create a request and then at that point
we need to select which is the invoker
that we're planning on using normally if
you don't specify an invoker then it's
going to be synchronous and that's all
you get now if you specify an invoker as
we do here which is called a sink as
part of our flu and call then we're
switching from sink to a sink and then
we specify the get as we normally do in
the sink case together with the type
that we're expecting back from this
resource but instead of getting a string
we're going to get a future string so
here's Anna synchronous computation that
is some time in the
future is going to is going to give us a
string well this is great so we do we
continue doing our processing we don't
want to block but at some point we need
the data coming from this asynchronous
computation and at the point the future
API is going to basically force us to do
a get and who can tell me what happens
when you do a get and the future is not
the present yet it blocks so it sort of
defeats the purpose of everything we've
done so far right so this is not ideal
it works in some cases but not in all of
the cases and that's why we also
introduced well let me sit back and say
there are some ways that you can avoid
the blocking obviously you can check to
see if the values available you can wait
for a few milliseconds and then come
back and check again but at the end of
the day you're doing polling you're
wasting cycles so it's not really what
we want to do so for that purpose for
that reason I should say we also
introduced the invocation callback
mechanism and this invocation callback
mechanism is very similar to what you
would do in javascript no Jas or some of
those languages that are very much
callback based so rather than waiting or
having to do a get on a future what we
can do is we can specify a call back and
just wait until we get called back the
way we do that is rather than saying
that we want to string we actually pass
an instance of invocation callback that
expects a string when we do our method
invocation in this case I get so the
invocation callback classes I or
interface i should say has two methods
completed and failed the completed one
is going to be called when the
asynchronous computation completes
successfully in the parameter we're
going to get is the string that we
requested and similarly if there's some
sort of error then fail is going to be
called and we're going to get our
throwable so this looks pretty good we
don't have the problem of the blocking
with futures but unfortunately it isn't
perfect let's say that we want to do
more than one asynchronous computation
in fact let's say that we want to do a
composition of two asynchronous
computations we do the first one we
obtain the value we get from the first
one and then we initiate a second
asynchronous computation well we can
certainly do that but it's going to look
like
this so we start with a target one and
we specify an invocation call back and
then when the invocation complete we're
going to initiate a second asynchronous
computation in this case using the value
of the first one this is what a
composition would be for the sake of the
examples of the example we're just
passing the user as a header but it
could be you know passed anywhere else
we do a sink and then we have to pass a
second invocation call back and then
when we finally complete the second
invocation call back then we can print
the final the final valliant and what
we're trying to do here is we're
assuming there is some sort of user or
customer from which we need to get a
quote so we first obtain information
about the user and then we get the quote
that is specific to the user now
obviously you can see what the problem
is here things are getting more and more
unreadable and of course if we had more
than two computations then things will
be even worse in other words if you
happen to be writing code at line I'm
sorry I'd call them 125 in your editor
then there's likely to be a problem so
we need something better than this so
let's see what are the kind of things
that that we want to do with the
synchronous computations well you can
think about Ana synchronous computation
sort of a first class object and and you
can have an algebra around it you can
compose multiple computations if you
have an array of those computations you
can wait for all of them to be done or
you can wait for only one of them to be
completed you can compose them you can
combine them you can wait there's a
number of different things you can do to
them unfortunately there is an
improvement to the future API in jdk 8
and it's called completa bellucci has
anyone used completa belief uture before
okay a few so the name doesn't really
tell what completa bellucci is all about
the name completa beliefs eze that you
can specify a value if the value never
comes to you but there's actually a
whole algebra a whole number of
operations that you can do to compose
these completa Belize come from a base
class of completa below call completion
stage so what we're planning to do for
in jax-rs is to essentially add support
for this so that you can use that api
and combine the synchronous computations
using that api rather than having
to nest invocation callbacks so how
would it look like it would look
something like this so we're going back
to the same example of getting a user
information about a user and then
getting a quote for that user so the
first part is what we call see as one
here completion stage and remember I
just as I just said completion stage
just based I for complete able future so
just think of it as being the same thing
for the for the sake of this example and
what we do is we introduce a new invoker
as part of the fluent api so rather than
using dot a sink we're going to use our
X to indicate where we want to use our
reactive API in this case everything
else is the same as before but the
difference is that now we have a
completion stage and we can use the
completion stage API to combine this
asynchronous computations so for example
we can say CS 1 dot then compose and
then specify another lambda they are of
course we're in jdk r8 we can use lambda
and then call the result of all that
composition cs2 okay so now we we
managed to take two things and combine
them into one that we call cs2 and now
as we did in the previous example we do
need to wait for CHD to complete so we
can say cs2 dot then accept and get the
quote pro for that particular user and
finally print it out so but this is
essentially the same code that I show
you before with invocation callbacks but
hopefully a little bit more readable
than the nested computations that i
showed the nested invocation callbacks
so this is one of the ideas that we have
going for jax-rs it's a very small
improvement for jax-rs but it opens the
door to use the to using the complete
able future API which is very powerful
but wait there's more there's other
reactive api's people may have used
something called RX java a few times is
a very popular one it was designed by
netflix we're also thinking of providing
an extension point so that you can plug
in your favorite reactive api and and
you can use something other than
completa belief uture and the idea here
is that we can do that by simply
overriding this rx method and then
having you provide an invoker for that
for that new API so for the case of RX
java the main type they are it's called
observable rather than completion stage
and then it would be very easy for
either the obligation developer or the
person that is implementing the jax-rs
code to do an extension something like
this where the RX invoker is implemented
and the observable invoker works for
that other API that you have ok so it's
very unlikely that this is going to be
part of the standard the standard is
only going to talk about JDK 8 API
completa bellucci but it's very likely
that implementations of jax-rs are going
to support additional api's ok so now
I'm going to stop for maybe three
minutes and talk about an idea that we
sort of discuss internally never shared
with the expert group and then realize
that it really doesn't belong in jax or
as but i think is a very interesting
idea that some other people developing
reactive api scan can probably look at
and it can benefit jax-rs as well as
some other api's so even with a reactive
programming it's still a little bit
difficult to understand how things need
to be composed and how synchronous
computations need to be carried out so
what if we could do this declaratively
what if we could say i want this
computation to finish before this other
computation and then essentially just
create an object and throw it into some
sort of processor and have that process
or make sure that everything is combined
and composed in the right way well some
of our experiments show that you can
actually do that as I said it wouldn't
really belong in jax-rs because it's a
sort of a more general concept but I
thought it was interesting to look at as
part of this presentation so suppose we
have something like this and this is
something that you're going to start
seeing more and more as you move into
microservices where you're consuming
data from multiple places so suppose we
have these five tasks that we need to
execute in the final tasks that we call
a here it's producing a result now the
key part of this diagram is just showing
the dependencies between the tasks so we
have tasked DNE that are need to be
completed before the task see
is started just like before when we did
the composition and then tasks C&amp;amp;B need
to be completed before a is started so
of course we can use the reactive API
and the completa bellucci API to make
all the right compositions and make sure
that everything works but what if we
could do it a little bit more
declaratively as I said before so we
think you could do something like this
we call this a declarative handler and
what we do is we just use a number of
annotations to inform the system what
are the things that are essentially
leaves in that diagram and what are the
things that are intermediate nodes and
therefore require the other values to be
present before they need to be before
they started so let's start with a
simple thing so we have an annotation
called final result and this is the one
that is going to produce obviously the
final result and that depends on the
result produced by a so in this case the
method is very simple the result has
already been provided by a we don't do
any additional transformation and we
just return it now if you remember from
the previous diagram be DNE were leaf
tasks so they had no dependencies so for
that for each of them we define a new
method called a partial result and we
label them with the name of the task in
this case so this is not particularly
interesting but it's just how we build
the entire pipeline what's a little bit
more interesting is what happens with
the other two now if you remember in
order to start see we needed to have the
values for D and E and the way we can
specify that is using parameters right
we do that all the time we say in order
to execute see then I need to have the
partial result for D and the partial
result for E and for the sake of this
example I'm assuming that all the values
that we're computing our strings but it
could be anything of course and then
once you get those values then we can
start the computation for C and
essentially the same for a ok so the
idea is that we just define this diagram
that I showed you before using code and
using annotations and if we had a
processor for this then all we would
need to do is to say something like this
create the instance of the processor and
then just either pass an instance of the
handler or the class reference to the
handler or whatever it may be and the
process handler would actually take care
of all the the
reactive API combinations so this is an
idea that we thought we could probably
make part of jax-rs as well to make it
even easier but then we realized it
really doesn't belong Jack stressed
because it's a more general technique
that other people can use so i don't
know if this is implemented in any
reactive API but if any of you is
working on one you should think about it
okay so the next topic I like to talk
about today is non-blocking i/o so
non-blocking i/o something interesting I
wouldn't say for all the jax-rs
applications but for a certain class of
jax-rs applications that need a little
bit more control over input output
essentially those are the type of
applications that require higher
throughput and for which the normal
blocking io that we provide is
insufficient and there's a little bit of
precedence to supporting these type of
applications in jax-rs there is a class
in jax-rs that has been around since
version one called streaming output now
I don't know if anyone has ever used
this class because most people end up
using message Modi readers and writers
and streaming output is essentially a
replacement for a message for a writer
let me just show you an example of how
this works so this is an example of a
resource method in jax-rs two or even
one I would say so when we return a
response we're using the response
builder API and as part of our entity
rather than specifying an entity which
is what we normally do and then the
entity gets mapped to a stream using a
message for a writer we create an
instance of this streaming output and we
pass it along and the streaming output
has a single method called right and
essentially what happens is that when
jax-rs needs to write the entity rather
than using a message body writer is just
going to call back on this method that
you specify here and this gives you full
control over the output stream and you
can write the bytes directly yourself
now this is all great except that it's
it's still blocking the output stream
that you get here it's going to block if
it needs the block and you have no
control over it however we can still
take this I
guia in this sort of paradigm to extend
it to how we could do non-blocking i/o
and jax-rs and this that's sort of the
direction where we're going so this is
an example of a very simple way of doing
non-blocking i/o and jax-rs in a similar
style we would do with streaming output
well first of all we have lambdas we're
running on JDK 8 so we don't want to use
those ugly inner classes anymore so we
use the nice arrow here to indicate that
we're going to get an output stream and
you're going to write to it that's the
first difference the obvious syntactic
difference but there's also a semantic
difference here semantic difference is
that when we're doing on blocking I yo
you should think of this as being a
handler that can get called multiple
times not necessarily one time as it was
before so essentially any time the
system is ready to write some data to
the network you're going to get invoked
indicating yes go ahead and write data
so you go ahead and write your data and
that's not going to block it's going to
be guaranteed not to block but then you
have to indicate back to the runtime
where whether there's more data that you
need to write or not so this is in
essence the same thing that was done in
servlet 3-door o with a non-blocking API
but sort of modified to fit nicer into
the jax-rs API so in this example we
just check if there's more data that
would return true and otherwise where we
turn the false to indicate that we're
done and all the data is going to be
written but this is a very simple
example let's look at a more interesting
example to see how this would actually
work in practice so let's assume that we
want to do a file upload using a jack
using jax-rs so we have a resource in
jax-rs which is annotated with post
because we're doing a we're doing an
upload we say that it consumes an octet
stream which is what we're going to be
doing and then we inject three
parameters in in our in our method the
first one is a query parameter which is
the path we're going to be assuming that
this file is going to be stored in a
path although we're going to store it in
memory for this to make the example a
little bit shorter we're also going to
inject request request this a class in
jax-rs that has been around since 1 dot
out but we're extending it to to better
support non-blocking i/o and finally
we're going to
an async response we're going to return
this asynchronously because this is
going to be called multiple times as i
said before now other than that we are
going to create an output stream that's
where we're going to write the file
again just to make the example simple
and we need a buffer as we normally do
when we read and write so this is the
actual code the actual code has a single
handler in this case is a reader handler
and the reader handler I'm only going to
talk about the two calls that we have
here highlighted in red because I think
it's pretty straightforward and we don't
need to explain line by line but
essentially the input stream that we get
when we're reading remember we're doing
an upload has a method to indicate
whether you read everything and and
that's call is finished and if it is
then you do whatever work you need to do
in this case we we store the file and we
also resumed the response remember we
started an asynchronous response
otherwise what we do is we just read
from the air and again and again we're
guaranteed not to block when we're doing
the read and then we write back into an
in memory buffer and of course this is a
reader handler which means that it will
be it called multiple times and the last
time it's called is finish is going to
be true but again notice that we're
we're keeping the same syntax in the
same style as we did with streaming
output except that we move to lambdas
but everything else remains the same all
right so how would the client look like
well the client needs to be extended in
a similar manner and the way it's going
to work is something along this lines
again this is all subject to change as I
said at the beginning so we start with a
client we create our input stream where
we're going to be reading the file and
we set up everything that it's necessary
we create the target the request we
indicate that we're going to be
uploading an octet stream so so far is
everything things that you've already
know and then this is the new stuff
first of all we have a new modifier for
the invoker that we're going to be using
remember before we talked about the
invoker for RX this is another invoker
for niño and then we do the post and
obviously because we're doing the upload
here is where we need to specify a
writer handler and this is just one
variation of different overloaded
methods that are going to be a
with these functional interfaces there
will be others that you can register to
manage errors and in the case of reading
there's also going to be another handler
that you can register for completion if
you don't want to check completion
directly on the stream and just like
before you can you can write the data
and then you have to specify whether
there's more data to be written or not
okay so quick recap on niño so far I've
talked about resource methods and nioh
but that's only half of the story the
only reason that's I'm talking about
that is because it's the only half that
we have figured out so far so for the
other half you're going to have to wait
a little bit but the other half is going
to be related to message what a readers
and writers of course if you don't want
to write things directly and you want to
continue to use entities and the entity
mapping mechanism already available in
jax-rs you want to continue to use
message for your readers and writers and
you want those to use niño it's so
unclear how that's going to look like
possibly there's going to be a new
interface in the reactor style of
interface where you have something like
on event on complete and on error and
message body readers and writers are
going to be able to implement those
interfaces and use the niño that way
but that hasn't been decided okay so
with that I'm going to step into server
sent events and I like to start by
making sure that everybody understand
what SSC is and what are the difference
between SSC and web sockets I believe
people are still confused most of the
time about this first of all just like
WebSockets sses a w3c standard that is
part of the html5 set of specifications
it defines JavaScript API the name of
the object is event source and it also
defines a media type called tech / event
stream now the difference between SSC
and web sockets the first one is that
SSC is server push only so we can only
send data from the server to the client
and that's it and the other big
difference is that it runs completely
over HTTP web sockets does HTTP for the
initial handshake but after
that is essentially a TCP connection so
this is why yes SC fits better in jax-rs
and web sockets required a completely
different API which we already provided
as part of e 7 also there's no
necessarily a correlation between or
what we normally call a request in a
response there is no such thing as a
request for the layer with a response in
the case of web sockets now of course se
what's good about it any any time we had
to do something like what sse provides
before we resorted to doing some sort of
polling either short polling long
polling that was very inefficient in the
in the long polling case what we did is
we open the connection we waited for the
server to send some data when the data
came in we put possibly close the
connection then created a new connection
to do the same thing over and over so
we're creating and closing connections
all the time and short polling is even
worse we just pulled the server to see
if there's any data available if it's
not then we'll try that again later now
with SSC we also have a complete format
for the data for the stream and it looks
something like this there's essentially
a keyword there's actually four keyword
keywords defining the in the spec the
two more important ones are event and
data so event indicates the name for an
event and data is some data that you
associate with that event so in the
first example here we have the name of
the event is Java 115 and the data is
which can be sent in multiple snippet
it's must not miss the jax-rs
presentation which because you didn't
and then the other event here is late
party and the data associated with that
is that we need to drink a lot of free
beer there's a some other event types or
i should say keywords like ID and last
event ID that are used whenever the
connection gets drop and needs to be
resumed but we're going to skip those
four for the sake of this presentation
so let me show you how this would look
like in jax-rs and why we think it fits
nicely in jax or s first of all jax-rs
is all about resources right and
resources have representations and we do
all the content negotiation to obtain
the right representation and given that
we have a new media type then we can
extend that sister
and say well this is just another
representation for our resource it
happens to be a stream so let us
consider the following example and we'll
see how we can code this using jax-rs or
the future jax-rs i should say so in
this example we have four clients one of
them is a rest client and the other ones
are going to be as a see client and this
already shows one of the advantages of
incorporating this into jax-rs we can
use the exact same resource class to
talk to sort of multiple different
clients I mean you can think of all of
them has been raised clients of course
but I just want to make the difference
here so that you understand why we why
we code the way the way we do so the
same jax-rs resource class will be used
to for the rest line to put a message
and then and then to take that message
and broadcast that message to all the
sse clients that's sort of the the idea
behind the example and you can think of
any collaboration api doing something
like that you push some data to the
server and then you send that data back
to all the clients i want to listen to
that data and it's a lot easier to do it
with SOC than it is using long polling
and things like that so let's take a
look at the at the API and how this may
look like so we are in jax-rs so we
define our resource class you've seen
this a million times we annotate that
with that path which makes it our route
resource class and then in this
particular case we have a constructor
for the class for the resource and we're
using CDI injection into this resource
to inject a new class called SSE context
and we'll see you later when we finish
the example why this is important and
that from from that SSE context we're
going to store that reference and we're
also going to create a broadcaster in
this case sometimes you're talking just
21 SSE client and you don't need to do
the broadcaster step but in this case
we're assuming there's more than one so
it's quite convenient to do it this way
all right so then we're going to have to
resources in this class the first
resource is going to be for the SSC
client and the second resource is going
to be for the rest line that is going to
be pushing the message so for the SSC
clients is the the one that you see on
the slide here it's a get
and it produces tech / event stream
which is the media type for SOC it also
returns a new type in in jax-rs to the
one call an SSC event output the reason
we need to return this new type is
because that's the way Jack the jax-rs
runtime understands that there is an SSC
client on the other end and what we do
there is very simple we simply create
this class and we register the class
with our broadcaster which means that
every time a new connection comes in to
this particular resource the connection
is going to be left open and that
connection is going to be registered
with a broadcaster so the later on
whenever a message comes in we can go
through the list of broadcasters and
send the message to everyone okay so
just imagine every time we do a get then
the connection stays open and jax-rs
takes care that that happens and then
messages are going to be thrown sent
through that open connection so how does
the other part of this implementation
look like so here's the rest part this
is the same class I just split it into
so that you can you can try to read the
code a little bit better so rather than
doing I get we're doing a put in this
case and we're consuming to explain
we're assuming the messages are just
plain strengths and then all we need to
do is create an event we need to create
an SS even so that we can send it to the
broadcaster and to all the open
connections that we have so there's
going to be a small fluent api to create
as we normally do in jax-rs to create
the SSC event in this case we don't
actually named the event we just use the
data part of it and we are then once the
event is created we can use our
broadcaster to send that event to all
the clients to all the CC clients that
are listening now since most of you are
familiar with jax-rs you may be thinking
well but what about scoped the default
scope in jax-rs is request scope which
means that every time we access our
resource we create a new instance of the
class now that's where the context comes
in so if I stay back to the to the
previous slide we're doing the injection
of the context so jax-rs is taking care
making sure that the context that is
injected is the right context regardless
of the scope in other words the SSE
context is going to outlive their
request scope so that you can
talk to the right client so essentially
there's quite a bit of logic going on in
the background to make sure that
everything works and everything is
connected to the open connections the
way it should ok so we also plan to do a
client api for SSC in other words extend
the client the jax-rs client api to
support SSC and this is going to come in
two flavors either a push or a pull I've
been doing a lot of examples with sort
of push style so I decided to switch to
pull style even though here you have the
problems of potentially blocking but the
essence is the same as before anytime
you do I get in the client API you
specify the type of which what you
expect to get back so there's a new type
called an SSC event inputstream and
that's what you're going to get back if
you via Slee specify that type and in
this case all we need to do is just
while there are more events to be read
in other words while the connection is
not closed then we keep reading the
event and print the data if you remember
in the in the server case we didn't
actually named the event so we care that
was about the data and of course if
there are no events were going to be
blocking on the read so this is going to
be the blocking case if you want to do
the push style you know it's similar to
other push ap is that you may have seen
before where you have methods that get
called back whenever the the event
becomes available okay and with that we
are almost done and so let's do a quick
review and we can move on to the Q&amp;amp;A so
jax-rs to that one it's a it's a dot
release so we don't well don't expect to
put as many features as we did in jax or
s2 and we're focusing on these modern
features that at least that's the way we
we call them niño SSC and reactive
we're targeting an early draft by the
end of this year we hope we can get
there as I said at the beginning we're a
little bit behind just like Java EE
eight this is going to require JDK 8 and
you can you can probably see why we're
using lambdas extensively functional
interfaces in our api's for the first
time and would also rely pretty heavily
on completa below that you can do the
reactor
part and finally I want to conclude by
saying that if you're interesting in any
of these topics you should subscribe to
the user alias and all the communication
all the expert group communication is is
sent to this alias is forwarded to the
alias so that you can participate in any
of those conversations and with that I
think we're ready for the Q&amp;amp;A and you
have we have a few minutes for it so any
questions are you excited or
disappointed is there anything that you
think that we should be doing in
addition to what I presented today do
you like what we've done so far we
actually all work with the completion
stage in the Indy API more than completa
bellucci I just call it complete most
people know about the complete oval
future and not the completion stage but
when you work with the API is going to
be completion stage yeah
ya know we haven't talked to anybody
about it in fact this is the first time
I presented do you think that would be
useful so is anyone working on our
reactive API being a developer in on any
of the reactive API is out there that's
unfortunate yeah yeah you mean like
reactive streams and things like that
right
right well we can always add a new thing
a new name in the you know yeah yeah
yeah yeah I honestly we haven't looked
at it I know it I know it's in the works
but we haven't looked at it maybe maybe
we should Thanks I mean for us jdk nine
is way in the future right so jdk 8 is
what we're going to be basing on yeah
yeah no but we would like to hear more
about hypermedia it's it's an area that
we wanted to do a lot of things in
jax-rs too and then we found it to be
really difficult it's one thing to do it
at the application level and but it's
much harder to the framework level so an
example of that is we identify these two
types of links the header links and this
what we call structure links which is
the things that you put in your
representations and we wanted to better
support structure links but it was
extremely difficult to do it so that's
in it there are going to be some minor
changes in the API just sort of
Corrections and things but but nothing
new other than link has anyone ever used
link headers you have it's not a very
popular feature unfortunately yeah
so yeah say that again so how does the
client know that the the connection is
open or yeah well it's a TCP connection
so it's not UDP or anything like that
there is there is no mechanism for you
to know but you can if you need
something like that possibly you need to
do WebSockets because that's a way the
client could tell the client the server
back that it received that this is about
streaming data essentially you think
about stock quote you know if you miss
one it doesn't matter you get the next
one right yeah I'm sorry can you speak
up a little bit more in a cluster setup
it's a good question we don't we haven't
really thought at the API level how to
do it you mean because you have the you
have the notion of state that you need
to you need to share yeah yeah you would
have to deal with it at sort of the
application layer at this point I think
yep
I hope so I nobody asks me for the slide
which was strange usually they do but
i'll i'll pass them along or otherwise
you know you can always google me and
find my email and send me an email send
them to and again everything i said
today is very preliminary so you know
don't don't start writing applications
just yet yeah yeah okay i'll try to do
that you mean what-what api in
particular do you have in mind s señor
you would use its you you can use the
event source in javascript let's say it
should work perfectly fine i mean that's
that's why it's a standard absolutely
nothing it's all part of the standard
yeah we're sticking to html5 standard
for that any other questions ya know
there are some ideas about this in
Jersey the reference implementation as
extensions but they're all a little bit
different to the API that I showed you
today so Jersey supports SSC it supports
a little bit of reactive okay so you can
start playing with jersey with those
extensions but there unfortunately oh
they are all a little bit different from
what I showed you today so you won't
have the portability once jax-rs to the
one comes in and and to be honest with
you all everything that i showed you
today we started the discussion of all
this maybe a month ago in the expert
group so that's why we don't have an
implementation yet
alright if there are any more questions
thank you very much for attending</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>