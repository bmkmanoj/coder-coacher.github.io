<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON6086   The Java EE 8 Opportunity | Coder Coacher - Coaching Coders</title><meta content="CON6086   The Java EE 8 Opportunity - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON6086   The Java EE 8 Opportunity</b></h2><h5 class="post__date">2015-12-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Vg5eJZQRZRM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">last day of the booths javaone is nearly
done it's kind of sad go so quickly you
can't seem to barely get your head above
water when you're in it and then you're
afterwards you're totally tired and you
miss it it's pretty crazy so how's
everyone doing yeah great I see Carlos
is still wearing his party one shirt
from last night you know you should wash
that thing ok so I'm David Blevins I've
been participating in the Java EE
specifications for quite a long time
ejb3 first spec so on so forth I usually
give two kinds of talks at javaone so
this is my disclaimer I try to give a
talk at least one talk about something
that I feel is getting ignored like an
existing technology that's
underrepresented I've done that talk and
then I always try to do a second talk
which you know get myself into a lot of
trouble and and submit to present things
that don't yet exist or or I think
should should exist and you know that
that second class of talk is this talk
and that's the one that gets me into the
most trouble because you know of course
I have to deliver on all that stuff but
it's fun because it guarantees that
we're all going to see something that
you haven't seen before because it
didn't exist prior to two weeks ago so a
lot of the stuff is just kind of
interesting ideas on what could be done
in eight specifically because of the
changes in Java 8 and I guess this is
sort of a continuation of a talk I did
last year was you know got java ee game
changers and intent was to go from past
present to future and i got partway into
the future and i wasn't able to show a
lot of the really cool stuff so let me
would left me with this desire to come
back and finish the job you know if you
want to take a picture of this slide
this is that's that's basically the
central thesis of that last year's talk
here is the rationalization if you look
at Java EE over the course of the last
day 15 years you'll notice that there
are basically two eras of Java EE there
is the XML era where we did everything
with tons of tons and tons of deployment
descriptors and then when annotations
came along it pretty much made us really
do and rewrite all of our api's we
didn't see it in the very first
specification java ee 5 we saw just ejb3
come up with some annotations in the you
know in that spec a lot of them of
course but servlets didn't have any jsf
didn't have any and so on it wasn't
until EE 6 that basically all of the API
kind of got rewritten and a lot of new
ones that couldn't really have existed
before came about so jax-rs fantastic
example that bean validation would be
absolutely a nightmare without
annotations CDI of course is a really
great example of annotations really
really affecting the the api's and then
of course you know jpa all these things
were really difficult to do prior to
annotations all our attempts at like
persistence with xml-based descriptors
just totally failed horrifically and I
really feel that with the changes in
Java 8 we have the opportunity to really
take a look at these api's again and see
if we can change them in some
fundamental ways that further reduces
the kind of ceremony we have to do when
we write applications and so we're going
to explore some of that I have some
predictions I have my predictions are
we're going to shift from declarative to
programmatic annotations are very
declarative type of approach lambdas and
method references are very you know run
it install it do it all at runtime kind
of a thing I think there will be a
definite
act on interceptors it won't kill them
it may actually make them maybe more
frequent but just in a different kind of
mutated fashion and I think we have the
opportunity to shift things from the
bean side of all things over to having
more decisions made by the code
consuming that stuff so I'll show
examples of all this but that's some
debts and high level thing it bears
mentioning this aspect of this
opportunity that we have in front of us
when the XML to annotation transition
happened the JCP was still a closed
entity the JCP has had some very
significant changes over the last ten
years and they basically result in now
we have a fully open system and when
this opportunity is in front of us we
all have the opportunity to participate
in the definition and creation of these
new specifications so unlike before when
you know we had to kind of choked down
ee under a certain profile in a certain
shape and just you know take it as it is
now we have the opportunity to
legitimately redo lots of EE and have a
open say and how that happens and so if
you've heard any of my talk sleep you
know that I'm basically going to tell
you if you don't vote you can't complain
it's one of those types of things so get
involved in the specs we do have some
definite changes that we could make so
here we go we're going to start small so
I've got a little example of how you
might test some code now that has
security requirements so here we have a
little ejb
it's got some rolls allowed on it we got
employee and manager and we have permit
all so one who uses java ee security in
any roles allowed fashion at all okay
like three hands alright well the spec
leads right there so tell them what you
want and we'll get it in and for the
rest of you for the two of you who do
who's who's testing your security no
okay like that's good that's good that's
some effort you know I mean you haven't
fully given up and that's the first step
better than it being the last step so
we're going to show you how to do that
this is actually quite easy so this is a
technique that we've been using for
quite a while and when lambdas came
around you can you can clearly see how
much it's screened so what we do is we
have this local interface called caller
this is a very old example it actually
egb three-point Oh compliant before
being interfaces came along we annotate
this being with run as and we have one
beam for running as manager one beam for
running as employee and then we inject
those into the top of our test case and
then we go ahead and pass a callable
into those beans and that allows us to
pass the logic of the code we want to
run into the beam where it will be as
the annotation implies run as the
manager and as I say this is like ejb3
point 0 compliant but it still runs
okay there we go and here's how you
might do that and this is something you
can do existing in a little cleaner
fashion using lambdas so we have our
same same movies being same annotations
on it now we have a manager being
employee bean they don't implement any
interface because you don't need that
this is modernized and we simply take a
call what we call call on it and then
now we can pass in a lambda and avoid
the inner class real small step it's
very iterative it's not groundbreaking
but it is really clean and you can
actually go ahead and test your code
under many security identities quite
easily and you just plumb the code right
into the method wrap it with a lambda
throw it into a beam and now you can
execute that so here we're executing as
manager here we're executing it as
employee and we expect that the delete
will fail because the employee doesn't
have the permission to call the Delete
on the session bean and we'll go ahead
and run it just so we can take advantage
of the code that actually exists okay
and so again very iterative we're going
to show the method reference version and
this is basically to kind of get
everybody familiar with what I don't
know if everybody audience knows has
worked with lambdas and method
references who's using Java 8 okay so
I'm glad I'm doing this so the syntax
difference is quite small but here is
where it's a little more fun this is
what's called a method reference so
effectively what happens is whether you
pass a lambda or method reference that
compiler turns it into a static method
that's on the class so if it's if it's a
method there already that it compiler
doesn't have to do anything if it's a
lambda that the compiler would generate
effectively a method for it internally
when you pass this into the run method
that takes callable the vm will actually
dynamically create a class around it and
then pass it in as a callable into the
method so it's a lot of syntactic sugar
what the result is well less syntax for
you and so here's the same example now
we're saying run as manager and now
we're passing it a method into our being
and saying telling our beam to run this
method as this person we go ahead and
run that just we can see it executes and
there we go
so this is all possible right now with
what's available in java ee 7 i haven't
done anything that's significantly
different but we have taken advantage of
Java 8 language features to make the
syntax a lot easier to digest passing
around who would want to write a lot of
test cases that had you know 16 million
inner classes wrapped in callable
probably nobody it probably would be
enough to deter you from actually doing
any testing with security whereas if you
could just plumb the code right into the
method or if you had some code that was
reusable just kind of pass it in maybe
you have not just manager as run as
maybe you have manager and you know CFO
or something like that you could test
the same thing test as manager test as
CF CFO and then you would make a CFO
beam annotate it with run as CFO and you
could check to see if it would fail or
pass and you could actually literally
gitam lee test all the roles that were
required and if someone removed a
required roll your tests would break and
you would spot the change and you'd say
hey why you changing the security
requirements you can't do it by yourself
so if it would be very great way to do
that so
here's sort of a more fun perspective on
what we can do with method references
and this is a this is one of my
favorites so here is the ejb 3.1
schedule API this is the dynamic version
of it that allows you to pass in
effectively a cron trigger made at
runtime you create a calendar time were
with it and then this thing will fire at
a regular interval which would basically
what is specified in the class so this
is obvious is a joke here we have a we
have a farmer being that runs all his
corn jobs he plants the seeds in in the
spring and then harvest is them in the
fall and of course if you know any jokes
about farmers they have to check on
their daughters all the time so this one
will will run that method every hour of
every minute of every second of every
day so this is going to basically this
test case is going to see if we can you
know get at least four invocations
within five seconds and if we do then it
passes so I'll just run it the thing
that's kind of a bummer about this
version of it there is an actual act
schedule annotation and when you use
that you can have many many timeout
methods in your bean class and with just
with the annotation on top of them and
it's very easy but when you want to use
the programmatic way of doing it you get
one at time out method and all the
timers funnel into that and if you
actually want to do very different logic
you need to split them back out in some
way and this is kind of a pain in the
butt
so
effectively here's the ad timeout method
and as you can see we're passing it a
little bit of state in this thing called
the timer config and the timer config is
basically this this object is passed
into the at time out method when the
event occurs but at that moment we don't
really know what's going on we just have
to use the state we passed in to figure
out what to do and so you really have no
choice but to do this ugly sort of
if-else type of a thing and it's kind of
a pain in the butt ideally using our
friends lambdas and method references I
would want to say invoke this method
when this timeout occurs let me pass you
that method so here's some code that
kind of gets as close to that first of
all show you the the desired outcome the
desired outcome would be our complicated
code over here becomes this now when we
create a timer we give the schedule we
pass the actual method that we want to
have invoked we no longer have that big
at timeout and we just have the methods
that we want to have invoked and we
don't have to you know route them to the
methods individually this would be the
desired outcome this will of course
require us to change the timer interface
so that it can take this magical thing
right here which is a function it's a
new class in Java 8 and it's part of the
new functional API concept in Java 8 and
so what we're able to do is basically
say here I'm passing you a function when
this timer occurs and voc this function
and so that would be the really ideal
solution we can't quite get there yet in
seven and e7 in in EE eight we could
potentially add this type of method
signature so that you could pass in you
actual method references here's a trick
I found that works in EE 7 the timer
config takes a serializable object which
is a real pain in the butt because
method references are abided by default
not serializable there's a little-known
trick that was added also in ie8 or Java
8 you can multicast now so we're
basically casting our plant the corn
method to runnable and serializable and
as i mentioned earlier the vm the JVM
will basically dynamically create an
object around our method to basically
fit it into this method as the duck
target which is you know accepts a
callable or accept a function so when it
does that the dynamic object that it
creates will implement both serializable
and the target interface that we want so
if you do this and this will work in the
you 7 in java ee 7 it provided you're
running on Java 8 of course you can pass
all of your method references into the
timer config and get past the
serializable check because if you look
at the constructor of this thing it must
have a serializable so now in our at
time out method we simply grab the timer
info which is our persistent data was
our string before and now instead of our
string we're going to cast that to a
runnable and we're going to run it and
so now we get the ability to route to
many methods and pass the method in that
we wanted and we don't have to have that
if block and ideally we wouldn't have to
do this kind of crazy timer config thing
but that's our that's our compromise for
now so let's actually go ahead and run
this thing
ok
and then it waits five seconds and exits
okay so there we go we actually got the
idea to kind of work in IE 7 which is
very cool but this is sort of on one of
my higher priorities to try and get into
a EA to not have to know this trickery
to get it in okay so asynchronous
methods with functions this is another
area that can be quite fun so here we
have an ejb that has an asynchronous
method add job the job calls do some
heavy lifting asynchronously and it
waits five seconds a netid exits and to
run it we basically invoke this thing
add job several times which in total
would be you know over 30 seconds of
waiting but in the actual running
because it's an async bean will only
have to wait about 10 so the interesting
thing is if there was some discussion in
the ejb 3.1 expert group when at
asynchronous was added and I very very
distinctly recall Carlo de Wolfe saying
why are we making it only the components
choice whether or not a method should be
asynchronous why can't the client choose
that it wants to invoke something
asynchronously and I'm a lot of us kind
of agreed with them we just couldn't
figure out a way to make that happen so
for lack of better ideas we just said
well this is the best we can do right
now we put at asynchronous into the API
you can slap it on a method but yes the
person who creates the business logic
has to decide for all consumers if that
business logic should be asynchronous or
synchronous
and you as the caller just live with it
you don't get to you don't get to have
any site in that process at all things
are a little bit different now with Java
8 syntax and the thesis and the moral of
this of all this stuff is in Java 8
logic is mobile you no longer need to
slap annotations on it you can push it
to some place else that does the thing
that you want to do and wrap all this
logic with code rather than with
annotations code is dynamic and
programmatic annotations are declarative
if you're going to do everything
declaratively by nature the components
side is making the choices and decisions
but you want to do it programmatically
and allow the client to make the
decisions you got to change the way the
API works so here we have the component
gets to decide perspective of the world
now we're going to try a different way
this method is not even used bravely
refactoring my coat on stage I trust my
tools it's gray I know I don't use it so
it's okay all right so I've got the same
method do heavy lifting it waits for the
same five seconds but i have no
synchronous or asynchronous contract on
this at all i make myself one utility
being that takes several flavors of java
8 functional interfaces for my computing
pleasure and then I change my code ever
so slightly I inject the target logic
and my ability to invoke things
asynchronously and me the test case I as
the client I get to go ahead and pass a
lambda in that invokes this method and
gives me back the same future object
that I had before and the implementation
of this is nothing more than
boilerplate return the thing and invoke
it asynchronously we're still using the
containers ability to invoke things
asynchronously but we've cleverly moved
it to just a simple utility being we
only need one of in our entire
application and now we have the ability
to invoke everything asynchronously
bypassing method methods through it so I
can go ahead and voc this and I'll
basically get the same processing time
on the output which is about 10 seconds
so I've gone ahead and added several
flavors of Java 8 syntax into this so
you can kind of see and compare and
contrast them I have it's running both
my methods okay so this one takes
effectively a supplier the contract of
supplier as a functional interface and
Java 8 is when you call it it produces
something it gives you an instance of
something and so we've cast our do some
heavy lifting method to it because it
produces string and so it is able the vm
is able to make it fit the method
signature of i take a supplier now we
have to wrap this with a lambda and just
so i can help you understand this this
is what i do to learn all the time i do
like this new supplier string processor
do some heavy lifting and i forgot what
i had in there was a red blue no was red
thank you for the people are paying more
attention than I ok so this is the
boilerplate code that I would have to
have in like a Java 7 and before syntax
and this is why i love about IntelliJ so
you can take that great text and you can
say that there we go replace with lambda
and it deletes all of the boilerplate
but by the way this inner class is
effectively what the vm is creating on
the fly when this cast happens but you
don't need it so we end up with that and
that's basically with the book with the
rapper removed and now we're passing
this is still not fancy like a method
reference this is still a piece of logic
with a method call in it inside our our
go method here's another flavor where we
pass the method reference and then
separately an arg this version of it
uses the function interface which has an
apply method that takes a single input
and produces a single output and so it
just gives us another choice ok well
let's do some really cool stuff that we
can't really do in
let's try this one so bean validation
this is the one that really got me
started on this topic here's how bean
validation looks and this is a future
thing you cannot do this in java ee 7 i
have implemented an apache being
validation so we will see it work
completely in bean validation you create
an annotation that basically will
validate that the object passed by it
adheres to the constraints it defines
who's using bean validation at all okay
who's never really had the time to look
at being validation it right okay
what he said I guess that's more than
almost all the hands okay so the concept
of being validation if you want to have
a here's I'll show you the test case
first bean validation and you can see my
clever little testing technique bean
validation means you you know gives you
the ability to annotate fields of being
and then when they went when the
validator runs it will validate that the
data in the field adheres to the
constraint defined by the bean
validation annotation so here we're
saying we made up our own executable
annotation and we're saying is the file
that is the value of executable actually
executable and it basically is your
constraints job to return a true or
false and I you know because I'm I like
to write real tests you got to have a
negative in with every positive you
can't just test a happy path or you'll
find yourself on the very unhappy path
in production I have a test that has a
non readable or not executable file and
this should fail so if I go ahead and
run this will see that whipped by real
quick there we go and so I have made
several kind of really simple bean
validation annotations that you might
find in the real world to do various
simple tests on files so we can have
them as we can have an annotation that
checks to see if it's executable if it's
writable if it's readable if it's a
directory and if exists or not to do
this unfortunately requires quite a lot
of boilerplate code which one is this
okay we've got this annotation we have
to supply a constraint and the
constraint I've got this method here I'm
were forced to implement that doesn't do
anything for me and all the garbage is
really just to have that
I executed so every annotation that I
write every bean validation annotation
right my job is to produce a boolean
given the object that I need to test and
that's all I have to do but I got to
write a whole class for all these things
all the time and that's kind of a lot of
ceremony with just one two three four
five being validation annotations I have
to have completely separate constraint
classes to wrap one silly if statement
it's a lot of ceremony to have to cheat
to stomach so here's the first thing
that we're going to do too there is a
thing in E in Java 8 that allows you to
declare that certain methods have
default implementations of interfaces
who is aware that you could say at
default in an interface and then that
method is no longer have to be
implemented okay so we're taking
advantage of that by making the
initialize method of the standard
constraint validator a default method so
it has implementation and then we no
longer have to include this in our
declared declaration of our constraint
validator the trick of course is
the second thing is that we add another
method because we're not using this
particular bit of context in the
majority of our calls we had a
convenience method that will simply call
this and invoke this single arg method
and we do this because that will allow
us to tiptoe towards using Java above
it's the function interface that has the
apply syntax that has the single
argument that produces a single output
this method now adheres to that syntax
so yes our things are very very tiny but
we still have to have all the classes
because we haven't yet created a way to
bind all of these various methods into
the constraints so this is sort of an
interim step this all runs
this is something we probably had what
it would have a very high chance of
getting into the bean validation API
something that basically allowed us to
mutate you know basically mutating the
constraint validator interface so that
had these two methods that's this is
probably very high likelihood eighty
percent what I'm going to show you next
is lower likelihood because I had to
make a total hack in order to get it to
work but I wanted to see the idea
actually all the way through and so what
I did was I further hacked the let me
close this stuff up further hacked the
factory that creates the bean validation
stuff it's now on the bottom of my test
boilerplate I grab the constraint
validator factory which has the job of
basically telling you where you can get
the constraint validation instances and
instead of telling them where I just
pass in method references that I cast to
my functional interface so now instead
of having my constraint validator that
had a class that wrapped the ease
directory method I pass the is directory
method right into the bean validation
API and hook it up to this dirt to the
directory annotation and same for
executable exists readable writable and
I do this all of this register API that
I kind of invented I made this up this
does not exist currently in being
validation but if it did we could do
something like this and basically take
advantage of method references to avoid
the need to create all these additional
classes to simply wrap what is a
function which is effectively a
functional API
when we do that we can now completely
delete all of the boilerplate code that
was around those methods leaving us just
with the annotations now go ahead and
run this
boom so this actually is a like I say
this is a kind of a hacked up version of
apache bean Val that I that I you know
tore into the guts of just to see if
this idea would even pan out but it
really says to me that we just deleted
like five boilerplate classes and before
that those five boiler plate classes had
two methods each so we deleted like ten
methods and we took advantage of the
built-in boolean I take something I
return a boolean do you think that
there's a lot of code and vm that takes
an argument returns a boolean yeah do
you want to wrap every single one of
them with a constraint validation
probably not this is kind of like the
whole property editor saying you know in
the early days of the vm you had to have
a property editor to take a string and
turn in a strongly type object and then
see and then Jack's arrest sort kind of
showed us hey why don't we just do a
convention over configuration and if it
has a public constructor we'll call it
if it has a static method that takes a
string and returns one of itself will
call that now we don't need any property
editors anymore same thing is waiting
for us on the bean validation side so
some small things while we're on the
topic of callbacks
here we go it's going to do a little
quiz around and focus 4 interceptors
allows you to intercept a you know a
method so who's familiar with a round
invoke who's ever used an interceptor
okay all right now remember then no your
hands who can tell me what the method
signature is required syntax required is
for around invoke mm-hmm and what's the
return value and exceptions okay anybody
else have any different bets okay and
then our same args and same return value
or different and return okay we got two
choices anybody want to present a third
ok we have a quiet person in the back
who says the third but doesn't want to
say it okay the actual one is you are
correct you were really close you were
really close this is the actual syntax
okay we're going to do another quiz one
this one's harder this is the bonus
round after completion allows you to see
when a transaction is done and take some
action what is the syntax for that one
we have to spec leads in the room I
think one person in the room should be
able to say something no not no pressure
guys anybody want to take a shot what's
the what's the return value
okay we got it we got it we got a bet on
void and the incoming argument okay the
exception if any okay this is the actual
syntax of that method and this reminds
me of another conversation we had in ie6
and I very distinctly or rather eat five
I very distinctly recall bill Shan and
getting quite upset over us introducing
this kind of syntax into the api's he's
saying no one will ever be able to
remember how to do those things what is
the big deal with making people
implement an interface and we are like
we love annotations interfaces suck we
won rare rare times that anybody wins an
argument over against Bill Shannon and
it's a mistake unfortunately it's not
quite the greatest thing so now that we
have default interfaces a default
methods interfaces come on slide leave
ok so my computer locked up oh it has I
can't even go right around look oh
that's very unfortunate alright
well frozen laptop
okay I see if I can jolt this thing yeah
and of course you can't tab over to that
thing does anyone know how I've never
learned that part of the mac tab to the
right everyone we're gonna do it the
hard way we're gonna do a really hard
way 5 4 3 2 1 okay anybody know any
jokes hey we can't tell farmer jokes at
javaone not on stage okay you know do
you think this would not happen when you
have a brand new laptop you'd think so
and you know I made a joke on Twitter
that you think it's a good idea for me
to upgrade to El Capitan right before
javaone and then I didn't and I still
get bit how's that fair okay
what is the deal
I want if we can use oh now it's booting
ever so slowly I was going to say I've
checked all the stuff in the github so
we could just grab somebody else's
laptop all right yay is that the same
resolution okay oh it's going to open up
absolutely everything that I had open
you're going to see what code I had for
lunch okay so this would be a total
breath of fresh air an interface that
has your post construct and your pre
destroy you simply annotate it with
these methods and they're annotated with
default so you implement the interface
and you would only have to implement the
one method that you wanted in terms of
lifecycle callbacks it's not such a hard
thing to remember those but for other
things like our very wonderful
transaction synchronization we would do
it like this and then there you go you
could implement this interface all the
methods are optional and then you would
only have to override the one or two
that you are interested in now we no
longer have to you know scare ourselves
away from interfaces anymore and just
using annotation approaches we could
actually kind of introduce back to mana
Tate some interfaces into a little bit
of our coding because we do have an
interface based contract with the
container and nobody wants to have to
have to look this up every time they use
that annotation I look them up on a
regular basis if I can't remember them I
don't know how anybody else is going to
remember they might deal with this stuff
all the time so there are numerous
examples of how this could be done what
we know where this could affect the
the you know the API is here's a pretty
fun one so we have a rounded voc who
remembers who can list me for more
around advices that are that exist in
Java Iggy okay we got to around timeout
he said I got around and fell around
timeout anybody okay who knew that there
were this many you can intercept the
construction you can intercept the post
construct you can intercept the pre
destroy so they're actually five in
total and the fact that we don't have an
interface it simply combines them all
into one so you can see them is a really
big issue in fact a CDI seen used this
one very very very very heavily all of
the inner all the inner you know
injection that scene did was basically
wrapping this thing grabbing the
instance out of the invocation context
get being a good object target what
gives you the beam instance and then
cause lots and lots of setters let's the
post construct go and so therefore the
container would call post construct seem
would finish the job in an interceptor
that did the post construct and off you
off you went as they say in some parts
of the world Bob's your uncle which I
don't know what parts of the world those
are but a friend said to the other day
and now it's stuck in my head anybody's
ever heard that one Australia okay
awesome so here's one that would really
really really like who is really sick of
having to implement the init method of
of the servlet filter interface yeah I'm
kind of sick of that one and
why don't we have this kind of an
interface a sub interface that does the
cast in a different in a default method
and then gives us another one that
actually gives us an httpservletrequest
rather than a simple server request
small things that we could do with
default methods to make our interface is
better you know simple pleasures right
it's not groundbreaking but it would
really you know I wouldn't I hate to
have to cast all the time I hate that
all my filters are like six lines of
code before I've done anything so
there's lots we can do in the api's with
default methods here's a rather fun way
to end this interceptors so here is what
interceptors look like now we've got a
blue interceptor it's going to look at
the invocation context and it's going to
change the arguments and was going to if
we pass in a list it's going to add some
items to the list so on so forth all the
interceptors do that and then we have
effectively a being here that's got all
our three of our interceptors on it it's
got red blue and green and again we
don't need this safe delete is awesome
okay so when this business method is
invoked we're going to have in order red
blue and green interceptors getting get
called the output we're expecting
according to our tests business method
takes a string and returns a string in
an int and returns a list of strings so
we're going to pass in the question what
is 6 times 9 and we're going to expect
to get the answer 42 back so some people
get the joke and some people don't
Douglas Adams
okay and then we'll have basically the
interceptor stack should look like this
the before should be red green blue
orange than the business method and then
orange blue green red in reverse so this
is what you can do today this is
standard CDI interceptors and we run
this and it goes ahead and run but again
this is things declared on the component
the component is deciding what actions
what things need to be applied and we
want to try and shake up things a little
bit and make the client be able to
decide these things what would that look
like so first thing that we're going to
do and this is where we started to get
it we're really starting to get into
heavy customizations of the underlying
server first thing we're going to is
going I took the interceptor stack
implementation out of open ejb and I
hacked it up really heavily I made this
functional interface called invoke so
that way we have effectively a target
like function and like supplier that we
were using in our other method
references so that we can do a round
advice and a method and cast it to an
interceptor without having to have an
interceptor class I made a kind of light
weight stack object that takes an
interception and then it calls in a very
reflection like fashion and invoke so
now we have our interceptors look like
this we no longer have our interceptor
binding the annotations that we had
before they're gone we don't need them
those are for binding the interceptors
to the component and we're going to
build this stack up at runtime and again
with this method so happily I don't
completely clean my code before I get on
stage so now we no longer have any
annotations on this thing that buying
any interceptors at all this
is a plain java object like any you
might find in any piece of code so we're
going to go ahead and use this you know
theoretically interceptor stack thing
and we're going to go ad ad ad ad and
then we have a lambda for the invoke and
we're going to get a similar response
back other than now we get 54 as the
answer of 6 times 9 because there's
really no way to mutate those arguments
like we can with true interceptors we're
actually passing in a black box method
into that invoke and we can't see what
is inside it so we can run this and it
will work but yeah as I say we're only
sort of part way there so two things we
lose our ability to see the arguments
which is how things like being
validation can validate the arguments as
they go into your methods and you know
being able to say new anything is not
very java ee we gotta hide new from you
completely because that's what we do so
we got to fix both of those things so
here is the kind of clever compromise
we at wrong direction there we go we
have a streams like builder so we say
intercept of it's kind of like saying
stream of and we get this the of returns
an intercept abble we pass in the
methods that we want to have wrap our
invocation then we call build and that
gets us an instance of a wrapped
instance of this so now we have a canvas
being that is baked is basically a proxy
around the beam that we passed in and
when we invoke this proxy all of our
interceptors will happen and we can do
the argument manipulation that we used
to do and now we're two siding what we
want to wrap on the client side which is
really really cool because we have a few
api's that try to add interceptors in
like the jacks or s 2 point 0 client API
wants you to be able to you know take
and do actions against the arguments
that are passed before they're sent off
to the server and on the server side you
have an interceptor stack as well and
the interesting historical note is that
interceptors came from jboss jboss at
the time had both client-side
interceptors and server-side
interceptors server-side interceptors
were added to the specs client-side
interceptors were left by the wayside
and that does mean that you have an
asymmetry now you can't be fully
symmetric and if you have things that
you need to do undo on the on the server
side you need to do them on the client
side of course so now you have to do
them all before you pass them in and
this does kind of ruin the fun in some
regards so with method references we now
have the potential to actually kind of
cast any method that takes in invocation
context and returns object to an
interceptor and we just need some way to
build this up so if we had this in the
standard API that all container
kind of had to implement this intercept
Belov builder type of a thing and it
returned effectively a proxy we would be
able to do this now there's there's one
thing I will note is that you're not
going to want to build this thing every
time that you're going to want to use
the canvas being or whatever being
you're actually probably still going to
want to put this logic somewhere and so
we're mulling it over and thought of
thought about for a while and was like
what could we do to make this like more
consumable one word producers CDI
producers are the perfect place to get
this accomplished so we have a third or
fourth in this series where we take and
just simply create a pro CD I producer
bean we create the Interceptor stack
their dynamically using a flavor of
other instances that we just go ahead
and create beings that we've gotten
injected into ourselves and our own this
which is this is this method is now in
interceptor to know I like it
highlighted orange okay anyway so we
actually went ahead and implemented this
thank you a lot to Jonathan gallimore
who wrote the kind of local bean proxy
code in in open ejb and SAT with me last
night I'd like 2am and wrote the proxy
portion of this and we kind of this is
really you know last you know last
minute so but the cool thing is now our
test is no longer even seeing the
interceptors that are kind of behind the
proxy before they go into the container
our test just gets from CDI a canvas
bean and we go ahead and invoke it like
a plain old object and it's intercepted
so we run this oh there we go
abracadabra it works so this is a really
cool thing there's some subtle
implications of this that are kind of
easy to miss that close that one whereas
keynote had it open Oh closed it
ok
okay so here's the impact of
interceptors of this style of using
interceptors one in CDI interceptors
usually have to be declared in the beans
XML unless you're going to go so to some
crazy lengths to write an extension to
add them in in very fancy ways that's a
pain in the butt you still have to have
that beans XML it's not fun you you
would not need the Interceptor binding
annotation anymore which I personally
don't enjoy I've taken the work to
implement the Interceptor but then I got
to go ahead and make an annotation for
every interceptor that I create I got to
create them I got to implement the
interception method I gotta create a
binding annotation I got to put the
binding annotation on the Interceptor
then I got to put the binding annotation
on everything that wants to use that
interceptor and that is a lot of
ceremony for one method call it's a lot
of work it I'm lazy and that's just you
know not very fun so we would be able to
code the order of the interceptors
definitively encode we could add these
things dynamically at runtime when the
container boots without having to do
marry fancy things at all and in fact we
could actually have one class with many
interception methods that did standard
things like put transaction around
advice put security around advice put
all these around advices we could have
them in one class we don't have to
dedicate you know five different classes
for five different styles of
interception you could actually
consolidate all that code and completely
put it in one in one spot there's just a
lot of interesting things that could be
done we we really didn't even touch the
tip of the cool things that we could do
with Java 8 and the impact it could have
on our api's we're very used to thinking
you know in a in a client-side
perspective one quick one that I'll show
you just before we go this one doesn't
run
but in CDI observers so here's how an
observer looks right now in CDI you have
observes you consume an object and I
gave you a hint and you return void and
that's basically the contract of an
observer well there is this thing built
in called consumer and it's a new part
of Java 8 and it's accepts an object so
why can't I just declare my observers
like this so the interesting idea that
we could potentially do is give you a
call back in the JVM you know in the CGI
boot process where you could add add an
observer that simply was a functional
implementation of consumer something
that consumed any argument here's how
that might look in code
i'm going to add an observer that will
look for any events that were of type
uri and i would just be able to call you
or i if i had on tour to collect them in
a list i would be able to do as easily
as this list dot add is a consume
implements effectively consumer because
it is a method that returns void and
takes one of something as an argument
and so therefore we can actually cast
list dot add to consumer and i got to
get cut off here but that is the that is
the potential there is a supplier
interface and if we allowed producers to
be suppliers we could even do things
like this potentially we take our list
and we collect all the events that are
of type uri and then we make that
available to the application by making a
producer that simply returns that list
into the inked into the cgi ecosystem
crazy subtle things so i got to wrap up
but i'll leave you with this we have the
opportunity for high-impact things that
are now things are declarative now and
only duel but with annotations could be
done in code programmatically we have
the opportunity to shape to shift things
from components side sinking to caller
side thinking and let the caller make
the choices of how the logic should flow
in every case that we came up with we
eliminated crazy amounts of boilerplate
because all over java ee we have these
classes that implement these contracts
and in that contract is often just one
method those are begging to be redone in
functional style and all those classes
melt away and third and the last part is
logic is mobile you can move it around
and pass it around say hey and vocalist
in a transaction hey vote and focus
asynchronously you don't need to think
about those things when you create the
logic anymore the impact of this
opportunity is that of course now these
things which were just plain old
interfaces are going to have a lot of
default implementations in the code it
will grow we kind of have this clean
EAP I right now or the interfaces don't
have much in there but we will start to
see things like if you look at the
streams class which is an interface Java
stream streams it's is a just like
hundreds like a thousand five hundred
lines of code and it's an interface so
we might see some of those things in EE
if we go down this row which is very
foreign territory for us the other one
we might see some lifecycle compromises
to be made I propose the observes thing
to the CD expert group and a couple
people responded immediately saying that
is so aunty CDI we couldn't possibly
ever do that we need to control the life
cycle all right well if you make that
one compromise you can do really awesome
things so it will also take all of our
brains in order to really see all of the
opportunities that are out there they're
so much low-hanging fruit start looking
at the api's differently with what could
be done because we're in the middle of a
spec round right now the doors open for
us being able to actually add these
things into EE so take a fresh
perspective on everything that you're
looking at every day and go what if I
could make this functional there's lots
of fun that could be had all right I
gotta go because they're waiting outside
for the next round to come in so thank
you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>