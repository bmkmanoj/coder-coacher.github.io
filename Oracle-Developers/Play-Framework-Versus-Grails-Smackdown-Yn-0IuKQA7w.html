<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Play Framework Versus Grails Smackdown | Coder Coacher - Coaching Coders</title><meta content="Play Framework Versus Grails Smackdown - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Play Framework Versus Grails Smackdown</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Yn-0IuKQA7w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright welcome everyone thanks for
coming this is the play versus Grail
smackdown I'm James Ward I work it
typesafe on typesafe activator and play
I'm Matt right well i may add you I
consultant i work with various clients
whoever needs my help nice so um let's
start out here oh we got a little bit
that you wore the wrong shirt it was
trying to match you because I knew you
always were flat not just plaid pearl
snaps all right so so this is a
smackdown what we did is we created two
different applications the same
application with two different
frameworks and so we decided to use play
and grails and kind of compare a
head-to-head some of our things in our
experiences building these apps these
were created about a year ago so so
we've been through now a number of
upgrades on them and been able to
experience the changes over time with
these with these frameworks and so
that's been fun to see we'll talk more
about that later so why did we choose to
to pick to compare grills and play it's
not because i work for typesafe because
actually when we created the these apps
i didn't work for typesafe I was pretty
new to play so so why did we choose
rails and play and just to set the
record straight neither one of us had an
extensive background in grails or play
we could you know I could have taken
place he could have taken Grail so it
was pretty even keel when we started and
yeah yes I think the the core driver
about why we chose these is that they're
hyped as being the most productive and
performant Java frameworks that there
are today so that's why we wanted to
test mountains in a real-world scenario
so the the app that we built it's called
happy trails and or what's called happy
trails now it's called uber tracks
and we wanted to kind of exercise a
number of different parts of the
different frameworks and so we we tried
out a bunch of different pieces and
tried to build really an intent
application and then see how it went and
one of the things that we've had people
ask is did you do much with JavaScript
something like backbone or angularjs
mixed in there and we explicitly did not
because those frameworks there's there's
nothing in them that you know makes it
easier to do angular it makes it easier
to do background so we wanted to stick
to server-side templating let's go that
route so these are these are all the
different features that we wanted to add
form validation data pagination
basically things you would normally need
within an application so we had some
stretch goals to like being able to do
search and photo upload to s3 and some
other things so we'll see how far we got
here so our schedule our tentative
schedule building these apps was to have
a week for doing the data model and then
have a week for creating kind of the the
way that we map urls to the controllers
and that data layer mapping and then a
week to do the controllers and
authentication a week to do views and
then a week for miscellaneous polish so
we we actually spent quite a bit of time
building these applications who really
wanted it to be something more than just
a hello world exercise so I think we did
we did pretty well on the the schedule i
think you know both of us got a little
sidetracked with day jobs and stuff when
we when we did this but but if we did
probably spend about five weeks time
actually on each of these applications
as we went through and i think some of
us hit some stretch goals i guess we'll
get into that later but some of us
didn't okay so let's start with a quick
little intro to play so first of all how
many people here have used play before
cool that's great
how people if you scrillz pretty pretty
similar spring-mvc struts alright cool
intersting so for those of you that
aren't familiar with play play is a
modern web framework it's for Java and
Scala so you use you can use both Java
and Scala to write the backend of your
code and it supports asynchronous i/o so
you can do reactive programming with
play and it supports things like web
sockets asset compilers and those sorts
of things so some of my favorite
features are it features that just hit
refresh workflow so when you make
changes you just hit refresh in your
browser and then you see your changes
you don't have to redeploy anything
reload anything restart anything just
all happens so it's actually compiling
your your server side code in your
templates and even your JavaScript and
you're less it's compiling all that
underneath the covers so you just hit
refresh in your browser you see all your
changes play also is uses type-safe
languages one of the type safe the
company behind it is all about being
type safe and your languages and so
that's really one of the core features
of play is that where we have a kind of
very dynamic feeling experience and just
being able to hit refresh but it's still
using the type safe languages so that
you have a compiler that's doing work
for you you can manage large code bases
those sorts of things also play is
restful by default so you don't have to
do anything special to do rest and play
play is rest it's all it's based totally
on a restful style way of building
applications it's stateless so you can
scale it horizontally just by adding new
nodes to it it's reacted so it supports
a sink and non-blocking i/o and that's
for regular requests that's for web
sockets that's for really any requests
that you do in play can be an async and
non blocking request supports asset
compilers for like less compiling to CSS
CoffeeScript compiling to JavaScript so
on has first-class Jason support the
Jason support in Java is just really
just Jackson with a thin layer on top of
it and then the in
the scholar world with play they
actually have a really powerful API it
doesn't use reflection for doing Jason
it's pretty nice then you can get
started with with play through some
activator templates activator is a tool
that types they've created that has now
30 template applications in it so
there's a lot of good sample
applications and tutorials in there to
help you get started and then finally
we've got some big names now using using
play in some big ways linkedin Gawker
and a number of other people using play
okay so that's your intro to play any
questions before we go into an intro to
grails okay so Grails is often been
noted as basically a ruby on rails for
the JDM and that's what I riginal II
started out shortly groovy on Rails and
they actually made a change name so they
came up with grails and it's basically
you know a full stack framework that
allows you to very easily using the
groovy language to create web
applications and write hardly any code
at all most importantly it's powered by
spring nice my top 10 favorite features
first of all its documentation it's been
around for so long six or seven years
that there's plenty of good information
on Rails and how to use it how to use
its plugins interestingly enough one of
the exercises that we did for this
presentation in particular was upgrading
to grails 230 which is actually in my
mind more like 30 they made a lot of
async changes they
a few API changes and and so there is
some issues with the documentation and
plugins being outdated clean urls you
get that with a lot of nice frameworks
these days forum which is a wrapper
around hibernate so you basically get
very easy persistence you just call save
on an object list on an object and you
can use that to talk back to your
database it's got a great idea support
the zero turn around feature where you
don't have to actually compile anything
excellent testing sport complete with
jam is really nice integration for
functional testing groovy GSP's the
thing that I blew away play with on this
was front-end optimization and that's
largely because of the resource
optimizer so if you've done any work on
the front end and you've wanted to make
your website fast chances are that
you've minimized your JavaScript you've
concatenated together you minimize your
CSS that's all built into grams so you
right except for files but it outputs
one file and does all that minification
geez a big for us that's great nice as
good on and in the last one instant
appointment on Heroku that's true for
all the two dot versions what I found
with 23 is I had two pork their bill
pack this morning to get it working and
I'd still can't deploy so I'm gonna I
might take her out if your app is down
my app is down bummer did right
good where's the bell on that thank you
thank you all right so here's our setup
that we used for building these
applications IntelliJ for development
get up for source control cloudbees for
doing CI so we set up auto CI on
cloudbees and then Heroku for our
production apps and we are pretty nice
work flow where whenever we push into
github it automatically kicks off a CI
build on cloudbees and then when that
build completes successfully in the Test
complete then automatically deploys on
Heroku so we have a continuous delivery
pipeline that allows us to iterate
pretty quickly when we're updating these
apps unless of course you break your out
Bennett doesn't upgrade correctly that's
just 23 all the other versions are fine
great so the other thing that we did we
wanted to keep it real world thank you
so we we actually hired a QA person
because I was writing integration tests
i'm using Jeb and you know verifying
that our workflow was was you know doing
like we wanted it to but we didn't
actually have eyeballs to you know
ensure if you entered you know a comment
with HTML in it that it would actually
work so we hired a QA person we had to
do a number of iterations of catered
couple hundred bucks and she went
through and made sure both apps you know
all the features work like they should
and and I think that is you know just
something I've learned from experience
if you have a QA department that all
they do is automation they don't
actually manually test anything then you
know I don't know if it's getting tested
properly so that worked really well and
then we also use browser mob which is
out called like Neustar web performance
to do load testing of the apps and you
know hammer on them and basically figure
out when they would fall over and
actually exercise the entire application
as if it's being loaded in a real
browser I think I do actually load it in
a real browser whereas some of the other
load tests that we did we're just
hitting like a single request just a
single part of the applications and not
exercising the full kind of experience
right and the real browsers was a
spending yes it's like a hundred dollars
to run
test there so i still owe you some beer
for that yeah yeah alright so we're
going to walk through some of the
differences in the code between the Play
application and the Grails application i
did use java and JPA for the for the
Play application you could also use
Scala and so that would make a
difference I've been trying to work on a
new Scala version but haven't finished
it yet so okay so let's walk through
some of the stuff so database Grails so
with hibernate pretty easy you got what
two lines of code their URL and DB
create so that's setting up a data
source and in grails yeah so in play
there the default persistence actually I
is using evening not JP a soybean is one
of the persistence options that you can
use in play with Java so so evening it's
a lot like jpa uses the same annotations
and stuff it creates evolutions for you
so you don't have to write your
evolutions by an or this you have to
write your first version your evolutions
by hand you have to write subsequent
changes by hand and then let's see the
play two supports multiple data sources
if you use play one that was one of the
limitations and play one as you can only
have one data source which is kind of
silly so this is an example of just the
the two dots equal script when I added
an admin function to the application I
had to do a schema changed I had to
write the sequel for me but setting up
the data sources you know just as simple
as it is in grails so we we deployed on
Heroku in the default data store on
Heroku is postgres so we we both had to
go through a little bit of work to to
set up post grass and use post grass
instead of my sequel you could of course
use my sequel on on Heroku as well but
one of the tricks that I the problems
that I ran into is that the evolution
scripts when they get created they get
created for the database that you're
using and then they get stored into the
into SCM and so at first i was using
like h2 locally and then deploy non
postgres and then I ran it to some
issues because there was differ
is in the the sequel sin taxes between
the two so my evolutions were created
for it for h2 and then they were being
applied on a Postgres database so I
eventually switched to just using
postgres in both places so that helped
with that so when we originally wrote
this you worked for Heroku that's right
I think that's why this sliding that's
why the sliders are like pumped on the
9.1 support I'm so pumped on 9.1 it's
amazing I don't remember Lee remember
what was in 9.1 but you notice how long
his description of the database was and
how short my noise zing go with the with
grails and URL mapping it's very easy
there's just a URL mapping step ruby
file and you basically in there you have
full control on whether you want you
know certain URL to go to a certain
controller or a certain action and
you'll see at the top there there's the
defaults which are controller name
method name you go to and it works just
like you would want the web framework to
work so you're all mapping for play it's
pretty similar there's declarative
mapping where you declare your mapping
between the the verb the path and then
the controller that's going to handle
the request one of the nice things about
the URL mapping and play is that it's
type-safe everywhere the can be typed
safe and play it's going to be typesafe
so if you make an error in this file
then the compiler is going to tell you
that you made an error and that's a
pretty nice thing another nice thing
that that play does by compiling this is
that it compiles a reverse routing table
so in your code whenever you reference a
route you use the compiled reverse route
table and so then if you have to
refactor your URLs then it's going to
automatically change all the references
to those URLs so that part's pretty nice
in play so with grails on when you
create your model objects that's
basically the backend of your
application are you creating his
controllers and then models and the
models do all the persistence for you
all the properties that you put in there
you know
have string name string description
string date all those are persisted by
default unless you markham transient and
then to do constraints and validation
you just have a constraints block and
then the mappings are for one too many
and you know many to one or has many and
belongs to makes it really easy to
basically configure hibernate anyone
that's done that in XML or with
annotations you'll appreciate what
Grails offers there and then if you need
to override certain methods to do
something before an object gets inserted
or before it gets updated or before it
gets deleted you just override methods
and works really nicely and easy so I'm
play it's the e-beam plus the jpa
annotations and you can put your
constraint annotations just like you
normally do with jpa right in your beans
and then when you do a mapping of a form
request to the bean then it will give
you your validation error so you can
pull those out and display those so
pretty similar supports lazy loading
unless you're in a scholar template i
think they fix that bug actually that
might work now with grails controllers
not much code you just have a death in
the method name and then you have your
parameters which you automatically have
access to if you have you can populate
an object from those parameters here's
just showing you how you can do
pagination and so it automatically you
know grabs the region's right here using
region list and then grabs the comments
and makes those available to the model
and then the page can render those
very easily so pretty similar in play
these are stateless controllers so
that's one thing that when you're doing
security it's all done in a stateless
way one of the issues that Grails ran
into is that his security was actually
stateful so when he ran his app on
multiple servers initially it wasn't
able to handle a request to go to one
server and then they wouldn't be there
and so that was something you had to
manage you had to deal with today right
yeah so in play because it's all
stateless you don't have those sorts of
problems you can just scale horizontally
and easy to put behind a load balancer
do it that way yeah but you had to write
your own security and authentication
mechanism um I did have to write a bit
of my own stuff yeah it's true all right
I'll take it so um rails the views are
GSP's groovy server pages a lot like
jsps and they have you no tags like you
can see here at G set tag similar to see
set create link all these kind of
basically ancillary messages that are
available for you to use and then the
layout state support system like site
mesh where basically you have a layout
that rapture page and then all you
author is just the body of the page and
then that gets sucked into the parent
and then the optimized resources that
allows you basically to you know
concatenate minify your JavaScript and
CSS so in play the default templating
language server-side templating language
is Scala you can swap that out actually
for GSP or for Java or other types of
templating languages but the the default
one scala so that's one I used and it's
a pretty simple template language it's
one of the nice things about it is that
it's kind of functionally based so you
can compose together your UIs in in
pieces and then and then pull them in
and compose them together functionally
so that part was pretty nice and they're
also type safe so one of the other
places where play the compiler is do
work and letting you know if you screwed
something up it won't let you know if
you screwed up your HTML because that
part isn't typesafe but any of the
actual Scala code in your template if
you screw it up then the compiler will
tell you that you have an error so if
you're writing a job app and play and
you're using job help you still have to
learn Scala for the template you don't
have to you could use a Java templating
language and play but the skull of
language that you use in templates is
pretty basic you know it's like fours
and ifs and those sorts of expressions
so it's not real complex Scala you know
it would be like any other any
templating language has a language
structure and they just chose Scala
because that was what they thought would
be cool for a template in language and
how did the users like that that's a
good question users play users what do
you think of Scala templates love it
sweet yeah thank you guys
so grails for validation you saw earlier
how we had those constraints to find on
our model objects once you have that you
basically call save and and then your
object will be populated with an errors
so you can see here we have this new
route and then we call route in sand
save and if that fails then basically it
passes that route instance back and on
there there's uh there's these errors
that are part of it and then you
basically display them for each one so
it gives a real nice API for actually
capturing errors and displaying those
back to the user play is pretty similar
it has these form helpers that you use
in the templates and those will pull the
error messages out of the flash scope
just like Grails does and allow you to
display them on the page so pretty
similar their IT support and grails for
IntelliJ is awesome you basically can do
everything right in the IDE this is for
girls to two rails 23 not so much bummer
dude gotta wait a little bit to upgrade
right I think there's a little
conference driven development going on
with 23 that's right they released it at
spring 12 weeks ago right yeah so
conference driven development okay play
support in ids is great you can generate
your stub files for either eclipse or
IntelliJ from the command line surround
play idea or play eclipse one of the
really nice things about play is that
you're using it if you use it with Java
then Java is really well supported in ID
so of course that translate to working
really well in play you can do debugging
through the remote debugger and then
there's I think there was limited
testing the idea I think that's been
been since improved and there's also now
a play to plug in for IntelliJ that I
use all the time and it's a fantastic
plugin really adds a lot of helper
support for knowledge of a play
application knowing what the routes file
syntax should be like and those sorts of
things so so that's part of only part of
the commercial edition of IntelliJ but
definitely worth it definitely makes me
more productive
building playoffs and I was going to
mention that the debugging support for
Grails is similarly awesome and a lot of
its just IntelliJ I think more so than
don't know anything else it's great that
the spring source oh this yes yeah but
then you got to use Eclipse and okay we
we did these scheduled jobs in the
application to nightly send updates and
good and with grails it was pretty easy
i just used that basically a court
scheduler you can see here i have a
daily region digest email so the idea
there is that if anyone adds new regions
or new routes to region on our
application that it would send you an
email and say hey you know someone had
some new trails if you wanted to look at
them you can see there's a cron trigger
it says hey you know start and run every
five seconds and this execute method
just basically runs grab them all looks
at mc's if there's any new ones and then
sends out an email so it was really easy
dad so pretty simple in that case but
the one use case that he didn't address
is when he's running on multiple nodes
and so then the court scheduler would
actually run on all the nodes that are
up and running and people will get
multiple emails so I you know recognize
that that was a limitation you'd have
and I did it a little bit better
mine was done in like five minutes
here's tequila
so Heroku has a scheduler that will run
a scheduled job on a single node and so
that's what I used for mine and so I I
created basically a static void main
that the Heroku scheduler will run
nightly and so that that avoids the
problem of running on multiple nodes you
can of course use quartz with jdbc which
will help you which will help deal with
that concurrency scheduling problem but
I chose to do it the Heroku way and then
another thing we want to add was a and
XML feet so an atom feed of the data so
people could subscribe to that and see
any updates if anyone out of new trails
there's a peets plugin for Grails and
basically all you need to do is I added
a feed method to my controller and then
you can see here i find the region by
SEO name and then here's just the api
for rendering that specifies the p-type
title link description and it's just an
example of you know Ruby's nice API for
for doing you know feat and and that
feed plugin cause me and some issues
when upgrading to that three but luckily
there's new version and it all works now
nice so play actually it read the future
and it knew that Google Reader was going
to die and so they don't have a feed
plugin instead I had to do things
manually because we wanted to get that
feature into the app even though no one
uses RSS anymore so I'm kidding kidding
I use our RSS all the time okay so we I
used the Rome library which made it
pretty easy to set up a feed but it
wasn't as easy as a plugin then for
email with grails you can see here
there's a mail service that comes with
it
configure it and then you can send an
email to subject body co done what's a
burr tracks today spelled wrong oh you
know that shows up we're done it's a
browser issue yeah it's crossing no
email and play their there is a mailer
plugin for play as well so that's what I
used and then I hooked it up to sin grid
which is a service a like smtp as a
service and use that so it's pretty
simple to set that up figure it photo
upload and grails how'd that go time
come on why do you busy like upgrading
plugins okay alright so photo upload and
play I did get it uploading to Amazon s3
was pretty easy to to set that up using
the Amazon API and doing the upload
basically i'm uploading to the play
server and then uploading to s3 one of
the things that i could do in the future
to make that better is is you can do
even like a reactive upload which does
network pushback on the upload and until
s3 can you know catch up with the bytes
that are coming in so and that just
bruiser preserves resources as your
users are doing uploads you don't have
to upload the whole file and then upload
it again somewhere else you can stream
it through thank you that sounds good
huh yeah next version will have that
wait what about the stretch goal of
search did you search stabbing is urgent
so I just installed this plugin and
wrong my ass oh oh that's good man I
just
I just forced my users to search in
Google like a little sensor so for
testing with grails the unit test
support is excellent they have this test
for annotation as well as mocking for
model objects and that makes it very
easy to basically have you know a test
that tests all the logic of your model
object test your constraints test the
validation that works and then you can
also test you your own mappings
integration testing with groovy test
case and functional testing with Jeb JEB
does separate from Grails but it's
basically a wraparound selenium and it
makes selenium JPI a little bit easier
to use a lot less code to write and then
it runs you know in Chrome or Firefox or
now they have phantom jas support that
kind of works mostly and and you know
that's a selenium feature but Grails
integrates nicely with it test and play
was was I think equally cool worked well
they have great support for testing kind
of all the different parts of an
application you can test your routes
directly you can test your controllers
directly you can test your templates
directly directly and that made it
pretty nice to do pretty thorough
testing of all the different parts of
the application demo data with grails
one of the things that we did is they
have this bootstrap file that you can
use when you start out and basically say
hey if there's no users in the database
go ahead and add a few in there
those are mostly just for you know our
demo purposes but it very easily you can
see the API creates new objects and then
just call save on them pretty similar
way to do demo data and play you just
you can write it in in Java I wrote my
dental data loading in Java and just
call it when there's when that loads up
in dub mode and doesn't have any users
so pretty simple configuration with
grails there's a config groovy file and
the rails app conf directory and you
just specify you know dot notation on
what you want to configure there and
then within your application it's very
easily get that configuration
information so it's all in one spot and
it's easy to access config and play is
using the type safe config library so
this is what akka and play both used to
manage configuration it's pretty
powerful configuration library but has
pretty simple syntax similar to the
Grail syntax with dot notation and it's
kind of a JSON Mike syntax for doing
configuration you can specify different
configuration parameters in different
environments so I have a prod
configuration file that i use on Heroku
and i'm running a production to connect
to my production servers rather than
like localhost for my database and that
sort of thing and you can tell that the
the environments that both play and
grails have you know they kind of got
from rails but you see that in
in more figure projects now i think java
ee has support for environments and as
does spring so it's a concept that's
kind of permeated throughout yeah
environment variables are back
authentication with grails it was as
easy as loading the spring scare to you
i plug in all i do is specify that in
the file installs it and a few
configuration settings and boom I could
log in I can talk to ldap if I wanted
not only that but I had the ability like
sign up new users password reset
everything like that the only thing I
didn't like about it is that is it it's
from back when jQuery UI was popular
alright so the ants can own it we kind
of use bootstrap and skin it a little
bit but you know those pages are or that
old look at feel is your authentication
working now well my abs not sure if it
was up with your authentication be
working farruko could handle two dot 3
SB work nice so authentication in play
the authentication bits pretty easy but
there isn't maybe there's a plug-in that
exists now but when i wrote this there
wasn't a plug-in that would do all the
like user management features and
password reset decide to write a bunch
of that stuff myself as matt said he
used his zinger already but yeah so one
of the nice things about play in the way
that it does security like i said before
is that it's stateless and so you can
scale out horizontally when you when you
do play the controllers remain stateless
whereas the controllers and grails when
you use security become stateful and
isn't the other nice thing that you got
your release bumps like way up because
you had so many security vulnerabilities
this yet
make event too okay so that was the rest
of the code comparison we also upgraded
these apps a few times and the most
recently we up I upgraded my up from
play 21 to 22 and overall the process
was super simple there was a couple
small API changes that were well
documented and and then the the main
pain that I had and variable had as well
when we were upgrading is that Heroku
didn't yet support the new versions that
we upgraded to because leavers play was
just released like a week ago and the
new release of Grails was released like
two weeks ago so so who hasn't caught up
to that yet but we were able to mostly
get it working because people had the
community had already kind of created
support for the play the new play
version and in your case where I helped
you get the the Grails built back on
Heroku right rich but I don't know what
it is with broken Grails but um but the
last time we did this was just six
months ago I had to get them that java 7
sport they didn't have yet they didn't
support Grails at the time so they're a
little behind and even this time the
only way that I adjusted the build pack
for 2 dot 3 to work was increased the
time out that took to download it so
apparently i got you know 10 or 20
megabytes bigger it took a little longer
but we've still seen this issue where it
doesn't start on ROP right now gets like
so close and then times out at 60
seconds before 2 dot 3 of Grails I had
no issues upgrading ever it was
basically Grails upgrade check it in you
know a few files got changed but no
issues so this is the first time I've
actually had any issues with the rails
and upgrades Thanks okay so we wanted to
go through some of the actual kind of
comparisons of the applications some
analytical comparisons of the different
applications so first why slow so bike
uber tracks calm is uh is the Grails app
and you'll see there the overall
performance score from white slows and
95
hardly any HTTP requests there's a you
know expires headers there's
everything's compressed with gzip i
integrated with Cloud Foundry from
amazon for the CDN that was super easy
to do basically one line and a config
file and I tested it again this morning
this one's a little outdated there was
99 so it doesn't get much better than
that 99 if you want we're able to get
you two in 99 he's consulting he is
available play was a bee and I didn't
test this lately to see if I have made
any improvements but all right I got to
be expires headers know Jesus PageSpeed
you know it's just another look at it
this is Chrome's tool you can see there
I got a 93 out of 100 what did you get
4900 enable compression I could have
done that yeah so play 2 dot 2 has gzip
support now I could have done it yeah I
screwed up my biood going off too much
all right lines of code comparison this
is a grails is that you see there groovy
it's got 49 files and 1800 lines for
play we have let's see 45 files you'll
see that there's some Scala I think
that's my build config files there are
some sequel files HTML files mostly java
files and total lines of code 2251 so so
much for being all in one language and
getting right everything in the same
language right right
we did a bunch of load testing with
browser hop and browser mobs old name
now it's a new star web performance and
that basically set up a couple monitors
first of all and then we realized those
costs a lot so we stopped running those
but we did a bunch of load tests
basically for like 10 minutes at a time
and we did it with different dinos so
per okra is a concept of you know dinos
but they really like web servers right
and so we started out with one then we
scaled up to five at one point and just
saw how the apps did so load testing
with one guy know you can see here
Grails got 9300 transactions play only
got 6300 we had seven failures date but
the objects created by Grails is one
hundred and two thousand and playhead
63,000 so it's a good less objects
created but as many transactions okay
and this was a while ago so we haven't
updated these particular pests this is
March yeah so not the latest versions of
the a frame works but pretty close you
can see some of the performance
characteristics there over time data
throughput 15 eggs per second that's on
grails yep and then play was 20 eggs
play yeah some eggs yeah uh-huh
with five dinos blade is a little bit
better you can see the transactions at
11,000 vs 12,000 almost 13 two failures
vs 4 which is funny because you know we
had like seven or eight last time so
less failures and then about the same
number of objects created this is Grails
play it a little better yeah cool so
this is back in March we ran some a B
Apache bench load tests and I I had
shoved in right at the last moment a
nice little optimization to basically
cash everything in the application and
in-memory cache and so I like totally
blew Mount away and in the requests per
second hitting the home page so just the
home page which makes a few database
calls and renders the page it doesn't
actually load like any JavaScript or CSS
rights justice you know command line
yeah yeah so that was like 21 or 22
hundred requests per second you know is
nice you know using that in memory cache
everything was great i was i was really
stomping all over grills at that point
wait for it we reran the tests after
some changes that we made today and then
one of the things we realized about our
last test even though we both had a
caching we didn't have it like
distributed cache so you know you cash
on one side you cash in another but they
might be out of sync so one of the
things we did today was ad what's it
called memcache yeah I'm gadget so we
external a memcache here is the add on
on Heroku right so it's a Roku add-on
and what I assume for the Grails one if
it could be up is that it would share
the session so if you logged in one it
would work on the other for yours it
actually does caching up the whole thing
and in grails has a separate cash for
like its hibernate objects so I'd have
to configure that to use memcache to try
that I'll get the way update it didn't
work but what you'll notice here is we
could barely even get above 250 requests
per second when we actually had more
real-world app that had you know cash
distribution going into it if we made
these a bit more stainless where we
didn't need that then you get the
thousand or two thousand requests per
second yeah so it turns out that the
overhead of going across the network to
memcache for everything that we are
cashing which worked great when it was
all in memory but once we had to go
across the network then we took a
serious dive in performance so kind of
an interesting real world scenario there
that caching doesn't always save you at
least distributed caching so if you can
if you can have caching that is ok if
it's out of sync across nodes then
that's going to be a lot better because
then you could use an in-memory cache
but point when you have to have a
synchronized cash crossed all your nodes
then then you're going to take a nice
hit running locally it was interesting
so I ran the same benchmark locally on
my on my laptop and I was able to get
even with the external memcache I was
able to get 1,700 requests per second
hitting my local memcache so there's
certainly a lot of network overhead
that's that's going into these numbers
looking so bad and then this was a
hundred dollar test alright he's family
ran a cost us under dollar so it wasn't
so bad at first because new star game is
like five hundred dollars credit for
mentioning them and so with the bike
dinos 100 users and these are real
browser users basically they fire up you
know amazon
in different parts of the country Hugh
silentium and drive the browser we got
ten thousand transactions for rails only
one failure seven thousand zero failures
so I can live with the one failure and
this is this is something we had a lot
of fun with which loads faster calm
you'll see there I'm like sixty one
percent faster then I ran it again and I
was seventy-eight percent faster not the
most reliable is all day long yeah are
you showing that you know it's totally
random the internet isn't a lot of
variables there yeah but fun to play
with I also ran a bunch of tests using a
Hawass zap tool so basically a test for
a lot of security vulnerabilities in
these applications and you know sees if
if there's places where you know things
can happen and how it does that is it
you know kind of brute forces attack and
you know if there's inputs that can put
in it puts those in and then see so it
comes out on the other side so this is
against the Grails app you can see here
there's some cross-site scripting
reflective there's a sequel injection
and I think the sequel injection is
actually because if they did something
it would you know bring up a stack trace
and so that's a warning sign as far as
security is concerned I had the password
autocomplete in the browser so i didn't
have that turned off and then there was
an ex content type options header
missing so we were able to run this and
then go and pick some of those also in
grails 23 there's a whole new section on
how you can disable cross-site scripting
and do a lot of security enhancements
employee with play out of the box he did
pretty good there is no password
autocomplete and
content-type header so nice work nice
way to go play alright so we wanted to
also look at kind of some of the
ecosystem stuff around playing around
Grails and compare those so first up
jobs so you can see here there's a on
dice.com there's quite a few Grails jobs
on many play a lot of spring so we put
spring in there just to kind of compare
monster you can see it's dying no one
uses it anymore and then indeed is kind
of reflection of how many jobs are out
there right and how they've increased
over the years and there's a ton of
spring MVC there's a lot of people
hiring for Grails not so much for play
and you can kind of look at that two
ways one is well you know I should learn
it because there's plenty of jobs second
maybe you should learn it because there
aren't many jobs and then you can pump
your rate up to do one of the few that
knows it so that's right google i just
saw a tweet that Apple is hiring a Play
Developer so I song with these struts to
you know look help us poured our struts
up to play linkedin skills this is
number of people that if you search if
they have it on their profile so you can
see there's a ton of people you know
that that do know or have grails on
there somewhere play a lot of times it's
tough to search for this one right so we
did play framework in quotes and hope
people use that but there's only about
5,000 people that are currently the
knowledgeable in place a could be a
niche
right and then spring MVC I mean one of
the interesting things is that rails and
spring MVC are pretty close so you know
people probably if you know Grails you
to say you know spring MVC so it could
be a lot of overlap there but a lot of
skills trends Google's done well or
Grails is done well over the years you
can to play kind of catching up yeah
please catching it that's nice but not
that much so that's is that the absolute
and that's the absolute so absolute job
trends you see girls is on the decline
play on the rise
and this this one is actually surprising
for us when we first start taking these
statistics you can see they're up at the
top grails was was the third of the
traffic is play and that play has been
steadily decreasing over time this year
it's cuz of stack overflow people are
getting smarter not using mailing lists
the girls actually be play for the first
time in July and years so what happened
was there some security issue now that
was you in August that's right books on
Amazon 34 play currently and 11 for
Grails actually um play for Scala just
just came out was just for this
candidate okay thank you and then play
for job as the other one it's on is
there's like play cookbook that's it but
they're so good they're just so good you
don't need any others this is surprising
the the last time we looked at releases
for the year rails is pretty good I
think probably because the spring
sorcerer now it's pivotal you know has
like a monthly or every two months
release cycle so they're always pumping
out new releases and play was like once
a quarter or once every six months and
you can see here they've stepped it up
quite a bit so they're both you know
doing regular releases in as long as I
really seamless and you can just pop in
a new version you know why not no that's
one thing that played two dot one did a
lot better job of is remaining
compatible API compatible throughout the
dot releases in the plate on one cycle
dose last year okay
grails stackoverflow questions grills
has like 13 thousand questions on stack
overflow play has just over 5,000 hacker
news I like this one when play was
released play 20 was released hacker
news the the news item on their had a
hundred and ninety five votes how many
did the grails 20 release once baby 69
see and I just saw you know play to dot
to was just released a week ago and so
again on hacker news i think i had about
a hundred votes how many did the grails
to dot 3 release developers typically
just getting done so they're
sitting there like not waiting card to
compile you know oh alright some
conclusions from a co perspective we
thought they're very similar frameworks
they had a lot of similar concepts i
think the biggest one right is that that
play you know says we're statically
typed and grail says they were dynamic
in a groovy and you know works really
well but at the same time you know both
appeal to different people different
ways I'm the plugin ecosystem is
excellent but at the same time what I've
seen through the upgrades over the last
couple years is that is that the plugins
get outdated people don't update them so
you know when you have a large plugin
ecosystem if people aren't maintaining
them it can quickly become something
that hurts rather than helps tdd style
development was easy with both we found
that if we wrote the test first we
actually developed faster and then you
like the you know the type safety and
play two is awesome so some of the
statistical analysis conclusions grails
has better out-of-the-box support for
for doing the optimizations that you see
through the why slow and the page speed
charts and grails had less lines of code
you know I don't think anybody would
argue that Java is not more robust than
the groovy or scholar would be the
Apache bench this is our updated results
from today with the externalize Cashin
pretty similar I think because both of
the apple apps are now just totally
gated on talking to that external
memcache system so so pretty pretty poor
performance you know with with all those
network requests to memcache and we were
thinking about changing that last line
the caching significantly hurts as you
notice our numbers where is like 250
request a second today last time when we
did it we were able to take from 250 to
thousands because we added caching and
but we didn't realize that we weren't
sinking the cash so yeah so it's
interesting play is difficult to search
for the official name of play is now
play framework with a space no ! so
hopefully that helps the searchability
of play going forward and rails has been
around for a lot longer so it's
naturally more mature it's you know got
a pretty heavy release cycle around it
play we've seen has some momentum issues
I think personally a lot of it's because
they they said hey play one's great
everyone got on that bandwagon they said
hey we're going to rewrite it check out
the new one and everyone is like huh and
so they're kind of working through that
it's interesting that more people know
where this is outdated based on my last
slide but the last time we gathered
stats in March there were more
people in new rails and spring MVC play
a hat three times the mailing list
traffic but the gap is narrowing and as
far as documentation questions we had
similar experience like it certainly
helps that we knew some of the people
that worked on these frameworks so we
could ask them questions I'm sure the
Grails folks got annoyed with me after
on this last session I think we both had
to send a few stack overflow of
questions or Middlemiss questions when
we were building these apps for things
that we ran into that were just kind of
unexpected and that indicated that there
are some gaps in the documentation and
so documentation is certainly always
evolving but there's i would say that
both of them have gaps currently in
their documentation right and that last
one the outdated documentation there's
so much stuff for Grails now and it's
been around for you know six seven years
that you'll find stuff on how to do in
grails lon and you don't know if its
latest version so that happens with any
successful framework are they no
playhouse way more hype on hacker news
well and because of you right what what
do you mean there's no like Grails
evangelist that travels around talked
about dude I build software now cool
well we still have eight minutes left
for questions so if anybody has any
questions about anything shoot it out or
any comments any feedback on your own
experiences go ahead
we we originally did that so the very
first version of the application we did
no caching and we're just hitting the
database and I think I vaguely remember
that our numbers were about the same as
they are now well and there was a
there's a big stink if you see on that
first slide when we first did the
presentation grails was quite a bit
better than play to the sense that you
know the play guys are like oh you
didn't configure your database like this
but the configuration block was like you
know 50 lines of code but then you were
like twice as fast yeah so you know that
to me said hey out of the box you're
going to be slow and now that we kind of
did that it's a lot faster but yeah you
can tell the caching I think what we
found today with that slow down that
doesn't seem right like we must have
messed up my butt it could be we have a
single thread like a single connection
to the mem cache server when we could
have more some rest because caching
should help so in 2 dot 3 that was one
of the biggest things I'm he asked if
Grails head sink for her support for any
sink and non blocking and 2003 they did
at that in reactive programming so you
can very easily configure that now it's
similar API to it play has yep yeah play
is all based on a reactive async and
unblocking request model for for regular
requests and for web sockets and I want
to do sorry come back to the load
testing thing real quick load testing to
get load testing right is really hard
like it was really hard for us to
isolate like where problems were like is
it problems with the way that we're
running the test and so what's one thing
I'd recommend you look at is tech
empower search for tech and power
they've done these benchmarks where they
take a bunch of different web frameworks
and they have similar applications and
different ways to test the application
they've been doing a good job kind of
keeping these up to date / time and
provide a really good kind of sweet of
testing a bunch of different web
application framework so check out the
tech and power benchmark so tech Tec HTM
pou are pou ER teck teck th e CH vm
power second power yeah
but he was going to add a slide on that
but girls one so you decide not to yeah
the reason was is because play too well
so Grails beat play Java but didn't be
placed Scala and so in two dot play two
dot to which the tekken power benchmarks
haven't been upgraded to yet the play
java is now on par with the place kala
so we should be better in the next
release of their benchmarks which are
coming out soon yeah
Lee turning around so fast yep is it
materia to market
yeah so it's a good question so yes play
plate 2 is only a couple years old now
and so it's a pretty new framework it's
it's very similar to play one but it was
pretty much rewritten from scratch with
play to you so it's it's a pretty young
framework what happened with play is
that typesafe the company behind scala
and akka acquired the the play
technology is open source but they
basically own now the copyright or
whatever it is and so now typesafe is
the company that's investing in play and
making it better and so since type-safe
got behind play which happened about a
year ago the the play usage especially
in the enterprise's exploded and because
of that play has also had two to reach
maturity very quickly and so two dot one
was really kind of the first kind of I
would say mature release of play and now
we're at 22 which adds some features and
improves a few things ads like gzip
support to die to isn't a big feature
release which fits well with enterprise
needs so I think I think because
typesafe is now behind play that's
getting a lot better good
yeah yeah good question so you can use
anything you want the default is e beam
with Java and a enormous Scala but you
could plug in any persistence framework
you wanted to play and if you want to
play with it you can you know grab our
source and fork it and try yeah we
actually had someone that did a spring
MVC version but we never lets her inch
market yeah we should check that up yes
I'm I've been working on a scala
addition to this application that
scholar with reactive Mongo so reactive
Mongo is a synced non-blocking to Mongo
and i think that the performance of that
should be pretty great but I haven't
finished the app yet so I can't say for
sure so the next time we do this talk
you will have the reactive smackdown so
its ports in this there's certainly a
MongoDB driver and it does do no SQL I
haven't played with it much but is there
yep
yeah it's you could plug in anything
it's I don't know if there's a plug-in
that would make it easy to configure and
start up the I baddest service in in
play but you could certainly plug in any
library you want any jar that you want
to use you can plug into play yeah yeah
I mean it's if it's just a library that
you can make calls to and get data in
and out of then it should work fine with
play yeah any other questions about
anything believe we have one of the
groovy developers in the room Jake speak
to that
what
and they believe they've added a lot of
static typing features a bedroom a plus
plus and some on static typing don't
like that
go
and is there it was there any connection
between groovy and the new spring boot
stuff
nice that's awesome so if you didn't
hear that you can write spring MVC
applications and 140 characters now with
spring fruit and groovy that's cool so
maybe we'll have to do a spring boot
version of this app so okay any last
questions a little more time all right
well thanks for coming hope that was
useful for you and will be around for
another question</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>