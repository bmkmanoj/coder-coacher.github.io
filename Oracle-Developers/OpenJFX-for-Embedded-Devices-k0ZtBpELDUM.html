<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>OpenJFX for Embedded Devices | Coder Coacher - Coaching Coders</title><meta content="OpenJFX for Embedded Devices - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>OpenJFX for Embedded Devices</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/k0ZtBpELDUM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today's session we're going to talk
about developing for open jfx for
embedded devices I've got three main
topics in my presentation I'm going to
give a generic introduction to open J
effects in case there's anybody who's
not familiar with it I'm going to talk
about briefly about developing for open
J effects in general and then I'm going
to talk about specifically what's
different about developing for open J
effects on embedded devices and then I
have a small demonstration at the end so
what is open j FX open J effects is an
open source project currently runs on
Windows Mac Linux embedded embedded
meaning mostly arm devices iOS and
Android the main line development
repository is now completely open sort
almost completely open source
there's no for a while we had an Oracle
had an internal repository we were
committing our code and and dumping it
out to open source now just like any
open J effects committer Oracle employs
commits directly to the open source
repository we have a governance model we
have a wiki with a lot of inference
there is a lot of information on the
open jfx wiki particularly around
embedded platforms so if you have some
questions afterwards you can find a lot
of information there about the platforms
that we support and some information
about platforms we don't officially
support but we happen to have worked
with we have a mailing lists I encourage
anybody who's interested in getting
involved the first step best first step
join the mailing list everybody at
Oracle who works on JavaFX is reading
that mailing list and a lot of people
who don't work on JavaFX so if you have
a question that's the best place to
start we have a blood system if you have
something specific that you'd like to
see addressed a feature you'd like to
see added an issue that you'd like to
see address
baile jeera again it's the best way to
get attention because everybody's
looking at it we also have a very active
community we've got the community
contributed Android and iOS ports
there's a lot of activity going on there
is still a very small portion of code
that out of our control remains closed
and that's the t2k font library we no
longer require t2k to do an open jfx
build you can build using the pen go
free type libraries instead and you can
get a complete working Java FX build out
of the open jfx repository so this is
not a stopper now I'm going to talk a
little bit about developing for open J
effects in general open J effects is
organized into modules these are not to
be confused with JDK modules we're not
quite there yet their organizational
units of code graphics fonts controls
they're all found under our team modules
they have a common directory structure
so once you look at one you kind of know
how they all work we have source main we
have Docs Java native resources tests
tests resources and we have those those
directories exist for each and every
module and here are the month the main
modules that we have alts right now all
of the embedded specific code lives in
the graphics module every all the other
parts of JavaFX are platform agnostic so
we use the same controls that you would
use on desktop on an embedded device we
I would say 97% of the code in the
graphics repository is shared between
desktop and embedded it's really a
pretty small percentage of code that's
different for embedded devices and it
has mainly to do with the way that we
initialize screens graphics drivers
cursors and input devices
we use Gradle for our bill we we
switched over to Gradle a couple years
back because previously we were using
ant and it was just getting the build
maintenance was becoming a real
nightmare and the build was really slow
when we switched from Gradle we went
from about it speaking from my personal
experience on my machine at home a
35-minute build to about a five-minute
bill so it was a fantastic improvement
in terms of readability and
maintainability big big plus there so I
know there are there are some issues
with Gradle we discussed some of these
were discussed in a different session
yesterday we are not planning to move
away from Gradle anytime soon despite
these despite the the issues around
versioning and things of that nature
it's it's so far such a great
improvement over what we had before
there's no way we'll go back so how do
you build open jfx step one you got to
get the prerequisite tools for your
platform I'm not going to go into too
much detail I freely confess I don't
regularly build open J effects for
desktop most of what I do I do in I do
in the Linux virtual machine the
embedded for me I build all the embedded
stuff cross build on a desktop Linux
platform so whatever tools you need this
again this is documented on on the open
jfx wiki for your particular platform
you need a JDK binary you need Gradle
then you need to go out and clone the
open J effects arty repository and it's
really as simple as that you go into the
RT repository you Gradle whatever I
believe the default build right now is
building the SDK and that's it it just
works so how do you run open jfx after
you build it you've already got your JDK
that you used to build but what you want
to do now is run your JDK but you need
to override the extension library path
so that you pick up the stuff that you
just built and not the
version of JavaFX that ship with the jdk
now as someone who develops a lot in in
this space i actually go into my jdk and
delete the JavaFX stuff that makes it
easier for me I don't have to do this on
the command line every time you don't
need to do that you can just use the
command line switch that's in there to
point at you're at the libraries and jfx
RTR that you just built otherwise you
get really frustrating issues you wonder
why you don't see any changes in your
code we keep rebuilding and rebuilding
it it's because you're pointing to the
old jfx libraries that ship with your
JDK we have a lot of tests available for
open GFX there's unit tests there are
some general functional and performance
tests and there are some sample
applications now it doesn't look like a
lot of sample applications but if any of
you have ever run ensembl eight it's
like 8,000 applications in one it's a
little slow on some of the embedded
platforms but you can run it I've run it
on a Raspberry Pi I've run it on a
boundary I've run it on a free scale it
runs just fine little slow starting up
it may not be entirely responsive but it
gives you a huge range of stuff in Java
FX that you can check out we support the
three major IV es IntelliJ Eclipse
NetBeans there are project files checked
into the repository all you have to do
is open them one caveat you need to do
one command-line build outside of your
repository before you'll be able to
build from inside your IDE there's some
dependency files that for whatever
reason we can't generate properly from
inside the IDE so one command-line bill
after that you can build and run from
inside your IDE so how do you get
involved in open GFX outlined here some
of the roles that we have to find in the
project as I mentioned your first step
sign up for the mailing list start
watching the traffic on the mailing list
you can post ideas ask questions post
small patches
if you're interested in being a
contributor where you can contribute
directly you don't have to find a
sponsor to take your patch and put it
into the repository for you you can sign
a contributor agreement typically we
require I think it's something like ten
contributions made through a sponsor
before you can be considered as a
contributor author you have a user ID
and you have write access you can do
code reviews committer work with the
team release code at this time we don't
have anybody outside of Oracle doing
authoring or committing we do have we do
have quite a few outside committers or
sorry contributors reviewers those are
particular people on the JavaFX team
that are targeted as being qualified to
review code and to review patches and
bug fixes in certain areas on the open
jfx wiki you can find who the reviewers
are for particular sections of code and
sponsors the main role that a sponsor
plays is helping somebody outside of
Oracle who wants to become a contributor
who wants to become a committer so again
as I mentioned your first step is to
join the mailing list decide what it is
you want to contribute to JavaFX
and talk about it on the mailing list
find a sponsor who from the component
owners list so whoever owns the section
of code that you're interested in
working in get in touch with them and
ask them you know ask them to help you
get your code into Java FX once you once
you sort of got an agreement in place
with your sponsor you'll need to go into
gear up and create an issue so that we
can track your work we try to do
everything in JIRA we'll start a
discussion on the mailing list but when
we get down to talking about actual code
contributions we want a record of that
we don't want people to have to go back
and look at mailing lists archives to
understand development decisions that
were made around a certain issue so we
really try
to get everything that we can into JIRA
we don't always succeed it's a it's a
newer process for us but that's the goal
the goal is to capture all the relevant
discussion around a particular issue to
week or feature in the JIRA so that we
have historical information if we need
to go back later and look at it so what
are the bugs tweaks and features what
does that mean
a feature is a chunk a big chunk of new
works usually it takes more than two
weeks to write this would be something
like adding a new control if you want to
add a new platform that would definitely
be a feature but week something smaller
you want to add a command line argument
to control an API that already exists
that's that's a tweak if you wanted to
actually add a feature to say control
the amount of texture memory that would
definitely be a feature not a tweak but
if we already have a methodology in
place to control the texture memory and
you just need a command line switch to
turn it on and off that would be a tweak
above pretty obvious the defect in the
code we consider any performance issues
to be bugs so you work with your sponsor
we recommend that you start with
something small
don't try to contribute a feature as
your first piece pick us look through
deira we have many many many bugs to
choose from ranging from little tiny
bitty bugs to great big giant difficult
bugs pick something small relatively
straightforward we have a lot of bugs
that for whatever reason they're lower
on our priority list we may not get to
them for some time it doesn't mean
they're not important it doesn't mean
they shouldn't be fixed so pick one of
those work on get a patch for it if you
have just a small patch one or two files
you can attach it to the JIRA if you're
going to be modifying
five or six files you should probably
use web Rev you can post a link to your
web Rev in the JIRA again we track all
that historical data
request a code review from your
component owner use the open JDK code
review process again everything's
outlined on the wiki you would need to
request a special API review for public
or protected API changes I would highly
recommend if you're interested in
something like that start the discussion
on the mailing list get some buy-in
before you start working on it don't
just post a web Rev I won't say it won't
get attention you're much more likely to
have success in a venture like that if
you could some buy-in beforehand and
people can guide you you know mistakes
to avoid things that you want to take
into consideration before you start
working on it tracking progress in open
jfx geo dashboards are a great way to do
that open jfx as part of the Oracle JDK
now you can see our release milestones
weekly builds all that information is
publicly available now and you can track
like I said all the features and bugs
that we're working on our in our JIRA
public you can sign up for an account
you can look at and you can track
progress that way so what's different
about developing for embedded devices in
open genefex
you have to cross build mainly we have
we support what we have documented on
the open jfx wiki is how to cross build
for open GFX arm heart float primarily
that's because JDK 8 for arm only
supports arm heart float clone the
repository get the tools for your
platform you need a cross compiler any
include files that are going to be
necessary for your platform target
libraries that you want to link against
there are different ways that you can
get these tools we do have a generic
version an arm v6 heart float tool chain
that you can download from inside the
repository using the shell script that I
pointed to up there
this will install Debian packages and in
our compiler into the cross lips
directory at the same level as your open
GFX repository your mileage may vary
this may be all that you need to build
for some platforms often we find there
are a couple platform specific headers
or some libraries it all depends how the
drivers written and what platform you're
using for a lot of arm float parts herb
arm v6 higher flow platforms this will
just work but not always we don't
guarantee that it's a good place to
start
now you're ready to build as I mentioned
before t2k font library remains closed
source you can't build against that in
open GFX you can now use pango free type
instead this lets you get an entire
working open Java FX stack forearm out
of the open jfx repository so once we
support the core modules base graphics
controls FX ml well do we not support we
don't support media currently although
there are some efforts going on in that
direction we know that there's a lot of
interest in seeing media on embedded
devices we don't support integration
with swing 8 SWT there's not currently
any work going on in that area if that's
something you're interested in seeing on
an embedded platform I would encourage
you to start a discussion on the mailing
list about that currently we don't
support the WebKit again there's there's
not really any efforts going on in that
area right now if it's something you're
interested in bringing up on the mailing
list
see what kind of discussion comes out of
it platforms that we know work it's the
8 u6 release we are supportive platform
was the Freescale imx6 known to work
platforms meaning we did some minimal
amount of testing to verify that the
binary does in fact start up and for the
most part it works raspberry pi and the
beagleboard-xm the open jfx
contains notes on these platforms and a
couple other platforms that we don't
officially support but that we happen to
know work that includes the boundary
device the Odroid u3 I don't know if
we've tested on the ODE right x3 yet so
I'm not sure if that one works but the
u3 works and the boundary works so if
you're interested in adding another
platform what kind of requirements do we
have we use a full-screen frame buffer
configuration for JavaFX embedded we
require some platform specific
initialization for egl to use the frame
buffer this is the sticky point so so
there are usually two big stumbling
blocks when we add any platform
the first one is acquiring an operating
system with all the necessary drivers
and headers that you need it sounds
really simple it's not that simple
often what we end up having to do is we
start with the Yocto or a Ubuntu
distribution and then we contact a
vendor and we have to hand plug in some
vendor specific drivers and libraries so
that we can use the accelerated graphics
the pieces that usually need to be
ported on a new platform in terms of the
embedded the initialization of egl
almost I haven't seen two platforms yet
that initialized egl quite the same way
hardware cursor again I haven't seen two
platforms where you can do it in exactly
the same way we what our preference is
if you have frame buffer min if you have
layer management on your device we like
to use that it gives you the most
performant and really the simplest
solution you can also do on some
platforms we have a cursor that's
actually integrated into the main frame
buffer that's what we do if we integrate
with x11 we just use the x11 cursor we
do require that you use part float ABI
so that you can run on JDK
forearm if you were interested in
porting to a soft low platform you could
certainly do that but you're going to
have to in addition to building your own
open jfx you're gonna have to build your
own OpenJDK as well because there aren't
any publicly available soft load
versions of jdk 8/4 arm okay so I'm
going to talk a little bit about a
particular device which is the boundary
SLI mx6 it's this little guy right here
I'm sure they'll see you are familiar
with this board choose a Linux
distribution we've been working with the
guys from boundary and they have kindly
provided us a wonderful easy to use
Ubuntu image can obtain it from their
website you have to click through and
sign some agreements but it's freely
downloadable there's a link to it on the
open jfx wiki it has all the drivers
that you need there's a couple you have
to do one sudo apt-get install after you
boot up the platform and then you're
good to go
so download the image write it to an SD
card I'm not going to demonstrate this
piece I'm sure you guys all know how to
create an SD card if you don't there are
instructions on the open jfx wiki also
know it takes a long time to download
this and it takes several minutes to
write it to an SD card which is pretty
boring to watch so okay when you start
the image up it's going to run the x11
version of the e GL libraries they the
boundary guys support two different
versions of e GL x11 and frame buffer
their default is x11 we want to use the
frame buffer so this is this is what I
refer to you need to do I did this just
last week and I noticed that the version
number of the frame buffer libraries has
changed since they released this image
so before you try to download them
you're gonna need to do a sudo apt-get
update so that it updates the
version numbers of the packages that
you're trying to download you need to
shut down light diem and then you need
to install the frame buffer version of
the hardware accelerated libraries once
you do that
you do not have to stop like DM to run
job FX you just have to do that to
install the correct libraries you can
also switch back and forth if you want
to use the x11
libraries for some things and you want
to use the frame buffer libraries for
other things you can use apt-get to
switch back and forth there are some in
some commentary about this on the open
jfx wiki I assume that most people who
are gonna develop on this platform are
going to switch over to the frame buffer
libraries and just stay there but if you
don't want to do that it's easy enough
to switch back and forth you do need to
be running when you run Java if JavaFX
you need to be root we require right
access to some system files to do our
input device management we're working on
a way to get around that but for right
now the simplest solution just run this
root either su or org you sudo when you
run Java FX so you've got your image now
you've got the frame buffer
hardware-accelerated libraries installed
now you need to install JDK 8 for armor
float you can go download that drop it
on your box you have a couple options
for how you manage things here I
personally find it easier I maintain a
JDK a four-armed installation on my
Linux box and I mount it remotely on my
devices this is because I have a whole
slew of devices I might work on a
particular board for a week or two and
then I may be on 4 different boards in
two days it's just easier for me to not
have to remember what's on this board
what's on this board I leave it all on
my desktop and then I can you know if I
have a change that I want to test on 4
different boards I just mount that
directory on each board go through to my
testing what have you
it also means I don't have to be copying
a bunch of stuff over to these SD cards
as you all probably know the SD cards
are a little yeah they have a limited
lifespan so unless you mess with them
the better copy so so once you've
installed your JDK forearm whether
you're installing it right on the device
or whether your remote mounting it from
your desktop you're going to need to
take your open jfx build and you can
either point to it from the command line
like I showed before use the
- D Java textures or do what I do which
is just copy your J fxrt and the arm
libraries right into your jdk forearm
that way you don't have to remember the
command-line switch now you're ready to
run and now i have short demo let's hope
this works
what i'm going to show here is a home
healthcare demo which is developed by a
third-party company for oracle and it
runs quite nicely on our boundary maybe
I think what's happened is my boundary
screen has gone to sleep and I'm not
sure if I can wake it up in this
configuration oh there we go okay this
is one of the bugs that we have an open
J effects embedded you can actually go
into JIRA and you'll see there are two
two separate ears open about how the
heck do we deal with screen blanking we
kind of been banging our heads against
the wall for a couple days over this
things should work now we don't coop we
don't on particularly on the boundary
device we find that it's actually very
difficult to detect when the screen is
blanked and we haven't had a lot of luck
figuring out how to unblock the screen
from within JavaFX so if the screen
blanks while JavaFX is running and you
don't have anything that's listening to
input you really can't unblinking we're
working on it what I'm going to do here
is turn on some simulation data so that
when I connect to these various screens
you'll actually see a simulated stream
of data and what we have here is
actually four separate demos
demonstrating some different ideas for
piped use open J effects and how you
could use open GFX embedded in the home
healthcare market
so what you can see here is a an example
of a patient monitoring device the
monitoring pulse rate heart rate oxygen
level activity level and I've actually
run this demo on I've run it on the
Odroid I've run it on the boundary
device I've run it on the Raspberry Pi
and it works on all three the only
limitations for this particular demo
it's written for it for a specific
screen resolution so that's a
application limitation that's not a
limitation of the platform and here's
another example this is a little bit
more interesting this would be something
you might see for example you've been
recently discharged from the hospital
they want to do some home monitoring for
a week or a day or several hours they're
going to take samples of your blood
pressure and your pulse every two
minutes and actually relay this back to
the hospital or they're going to record
it on a medical device and do periodic
uploads or your nurse will come out and
check it or what have you
here you can see an example of some
patient information along with some
patient monitoring this is more
something you would see as an electronic
chart in a hospital
and then last but not least this is more
of a fitness tracker this one doesn't
actually oh it does have some live data
so an example of something that you
might use at home as you're trying to
improve your health and fitness that's
what I have prepared for today does
anybody have any questions or is there
something else you'd like to see this is
the only platform that I brought with me
today so I can't show you this
particular demo on different platforms I
can show other applications on this
platform I can answer any questions that
you have yes this is just a demo so
right now it doesn't go anywhere you
could imagine so so obviously one of the
use cases for Oracle IOT in general is
home health care in that particular
scenario you would see a device like
this you know an end-user device running
JavaFX
taking the information communicate to an
IOT gateway and that would in turn
transfer the information back to the
hospital in the absence of Oracle IOT
one could imagine that sorry he just
decided to start doing virus skinny you
could imagine that it would record data
for a certain amount of time and either
upload it in a batch or you would have a
home healthcare worker come out and take
a look at it right and again it would
depend on the particular scenario that
you were looking to implement there's
obviously a lot of concern over
transmitting information like this over
the Internet I'm not attempting to
address the end-to-end solution for home
health care in this particular talk more
focusing on how do we do the user
interface on the endpoint in this case
yes
can you be a little bit more specific on
what you're looking for so as I
mentioned in the beginning of the talk
open day affects embedded uses the same
rendering pipeline that opens a affects
desktop uses we in on embedded platforms
we're using OpenGL ES our desktop
platforms we're using OpenGL I think
that we just require 1.1 or better I
don't have to look at the specific api's
that we're using in terms of frame
buffer swapping in very general terms
prism which is the name of the JavaFX
render renders everything to a back
buffer and then we swap it to the screen
so in how it gets swapped to the screen
depends a lot on which platform you're
using all the embedded platforms that we
currently support we're using egl to
just call swap buffers and that's how we
get the back buffer to the front buffer
desktop platforms depending on what
you're doing are integrated with the
operating system and the window manager
so how you get the buffer swaps is
different on Windows and Mac no you're
not rear-ending the whole scene it's a
persistent back buffer so you read your
all the parts of the scene that are
marked dirty so prism is actually
maintaining its own back buffer that way
we don't have to because as you know or
as you may know typically when you do an
OpenGL swap depending on the platform
you're running on you lose read you lose
the backup actor swap its undefined
what's left in there unless you turn on
persistent back buffer and that's a
pretty big for performance hit on those
platforms so prison maintains its own
back buffer what's it to the screen each
on each rendering pulse it only draws
the part of the screen that needs the
parts of the screen
need to be refreshed so prism has its
own dirty region tracking and we have
some optimizations to the OpenGL yep yes
I'm sorry say it one more time there
this is the relation so JavaFX open jfx
means you built it
JavaFX means oracle built it and
released it so what you it's the same
software stack it's exactly the same we
build JavaFX
the JavaFX that ships with the jdk is
built out of the open jfx repository the
only difference is when we release it we
certify that it's gone through this
amount of testing bla bla bla bla bla
when you build it obviously we don't
test it you're responsible for testing
it but it's the same codebase any other
questions
well thanks everybody for coming I know
it's early in the morning that I
appreciate people getting up you have to
see this</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>