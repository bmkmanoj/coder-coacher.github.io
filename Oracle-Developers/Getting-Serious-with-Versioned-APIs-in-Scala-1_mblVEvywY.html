<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Getting Serious with Versioned APIs in Scala | Coder Coacher - Coaching Coders</title><meta content="Getting Serious with Versioned APIs in Scala - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Getting Serious with Versioned APIs in Scala</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1_mblVEvywY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well thanks for coming everyone my name
is Derek Isaacson and I'm the director
of development for lucidchart com this
is getting serious with versioned api's
and scala so a little bit about myself I
have an undergraduate degree in
electrical engineering from Brigham
Young University I ended up going
working in the industry at amazon so i
do in software development working on
one of their tier 1 services I've said
it better get a computer science degree
if I'm gonna work in software so i ended
up going to masters and specializing in
distributed systems of the master's
program there as i learned some
techniques from my program advisor David
sheraton some of his material inspired
the content for this talk today after
that I worked at Microsoft Silicon
Valley office I built a social and
community platform for them for the
being calm team and then I worked at a
business intelligence startup trying to
build a biz new business intelligence
experience for users at domo and now i'm
at lucidchart so tell you a little bit
about lucidchart we're an online
diagramming application we all users to
create mind maps and flowcharts and for
us computer scientists all the
architecture diagrams right so we like
to build all kinds of diagrams even for
things like org charts and floor plans
and about six months ago we did a study
of our users looked at demographic data
we looked at how they were using the
product how long are using the product
by the different paid tears we have and
we download an expensive data
visualization tool and tried to use it
to analyze our data so this is a
visualization we were able to generate
and we looked at it and we studied in
what we realized that people live in big
cities so like any kind of like any kind
of diagram like this it that's all you
really know right but it was interesting
for me I'm kind of new to lucidchart
have been here nine months and I didn't
know a whole lot about lucid chart and
our users we're about three or three
years old we're an aspirational company
we see ourselves a young startup with a
lot more to grow than what we would
chief today but it was interesting to
see that we actually have global uses of
our app already even though we're this
company located in Salt Lake City Utah
launched initially North America but
we've grown on right in work hope to
grow a lot more so what this is
measuring
actually ours people spend creating
lucidchart diagrams and we split it out
by Tears you can see are paid tears
green our free users or orange so that
was that was actually the one insightful
thing which is to simply see that hey
yeah we do have use it across the globe
using our app now what we often need to
do we're building applications of
applications there's there's some kind
of evolution that happens we need to
adapt to changing environment there's at
the classic scaling problems right that
are really fun to talk about it on a
horizontal scale and vertical scaling
and we're going to have increased usage
could of course our business is growing
not only that but even if we can nail
the use cases we initially come up with
for our app we almost always have change
of use cases there's new features to add
users find innovative ways to use our
products and I web apps so we want to be
able to evolve our application somehow
and that's going to be the goal of this
talk today we're going to discover how
we can effectively architect our systems
for evolvability we would actually
design an end of the product and we're
going to do that using using this
restful style of architecture so a
little bit about lucid chart again this
is the history of lucid chart many of
you could probably tell a very similar
story initially our our app is as
heavily JavaScript where software
software as a service application you
can cradle your diagrams the browser or
Corey electoral property has
traditionally been almost a quarter
million lines of JavaScript that help us
create do some complex business logics
not just manipulating the Dom or
actually rendering all of our own fonts
and doing transformations and rotations
of blocks and text so our back-end is
pretty simple we use PHP we use a cake
framework talk to a single my sequel
database pretty basic it's all we needed
it worked for the time but we've grown
kind of like our little map showed us
earlier and so we ended up deciding
about 18 months ago that we need to pull
apart-er system and we decided to
actually rewrite it the system not on
cake but in not in cake and PHP but in
Scala and the play framework now my VP
of engineering is actually joined us
here today there's Brian Pugh he'll be
doing a session tomorrow at 3pm
on some of the architectural decisions
and the actual technology decisions
between behind play moving to scala and
cake to PHP our cake to play but what's
important for us today is simply that
moving to play framework helped us use a
more restful architectural style and one
of the benefits of rest is actually
evolvability so that's what we're
gaining here we've split this cake PHP
application for us lucidchart this is
we've got user service font service PDF
service sure many of your applications
look very similar we got chard and
replicated databases my sequel and no
sequel and we're trying to make our
system so it will evolve for hope for
the next 10 years of our company I like
to start out with first to taking an
expansive view of web services I find
whenever I present about it web service
is it helpful to first look at what are
they in a really broad broad perspective
so often we take for granted hey web
services to restful they return xml or
json they look like this the use OAuth
that's absolutely not true at all you
don't have to be restful they don't have
to have these parameters they don't have
to be XML formatted so let's walk
through a sample web system and let's
talk about common classification we make
is computer scientist we often say oh
this is a website or this is a web
service so let's walk through my sample
we'll call it a mapping application and
let's see try to try to answer for
ourselves whether or not this is a
website or a web service so we've got a
set of servers and they're responding
with XML to some set of clients on some
difference in the nodes and those
clients take it that XML they parse out
there's probably some IDs to other
resources in it so they're going to go
parse out these IDs and I got to go make
other HTTP requests so back to our same
web server let's say for those
additional resources now these requests
they're going to have some
authentication tokens there's some
caching information about how the client
can caption or whether or not they
return from cash there's content type
negotiation so I want my data returned
to this format there's air status codes
course some time something fails and
clients kind of parse the error result
sometimes it going to retry it maybe I'm
going to as a client I'm going to
parse out some user-friendly error
message so i can give that user now the
format's these additional responses
summer xml but some are jpeg some other
formats all kinds of data i'm getting
now I've got as a client I've got all my
data and I'm going to go through a
complex pipeline of rendering lay out
some tools I said it originally was
mapping it got probably map tiles and
the layout and render it ins big image
I'm going to display to the user so
which is it which is this is it a
website or web service is both I mean
least that's how I hope it sounded like
to you these steps is what a web
cepstral what a web browser goes through
in order to render a web page and yet I
kind of try to describe it talking about
XML and oooff tokens that's often what
we do building web services right there
really is no different difference and
the first time I came across this idea
was by reading restful web services is a
great book by Sam Ruby and Leonard
Richardson there really is no nothing
special about an HTTP request that makes
it a web service there's no feel there's
no header is no content type there
really nothing special it's just a web
service for me it's just HTTP in fact
HTTP is just an application layer
protocol the transport protocols TCP
right so HTTP is the application layer
protocol the web and and it can be ours
and what we're going to see today is
when we actually do not use HTTP as an
application layer protocol but we tunnel
some custom homegrown application
protocol inside of HTTP we're actually
building a little bit more brittle
commonly called RPC style interface so
they arc okay so i can't call my thing a
web service and this website and they're
not different so what is a web service
so think about some common web services
we all use in the system today there's
very common popular web services in the
world at lucidchart we're built on
amazon.com and tell me shot some other
web services people of use you like give
me some amazon web services then sure
someone's use AWS give me something in
AWS you like okay raise your I'll you
don't have to say anything raise your
hand if you use AWS
have used it whew all right I get a
little more background then so AWS is a
set of web services Amazon pioneered
this field but they built all kinds of a
whole suite of services that most
commonly uses on-demand instances
on-demand servers it's called ec2
Elastic Compute cloud and it also
created database storage in terms of s3
to no sequel datastore they have dns
services or call route 53 they have
something called relational database
service all it is is my sequels of
service other popular database or on
lines and web services are the hosted
Mongo database services again no sequel
data services there's logging services
that actually don't even use TCP they
use UDP let's talk to some central
logging server you can put online and
start to parse you're logged blogad
result there's SMTP services we actually
use them at lucidchart be powerful to
help you some analytic looks around your
mailings you're sending out so what's
common among all these web services well
the only protocol we've really got
common why our web services that I just
listed here DNS smtp log services over
UDP millencolin one is IP here so when I
talk about web services I often think
it's find it powerful to think of a web
service as nothing more than something
that runs over IP it for this very
reason we can draw the model of the
internet like this and it's called the
skinny waist the internet for that very
reason everything done might be a lot of
services there's nothing more special
about that there's lots of different
approaches and styles we can take not
everything has to look like these XML
with these OAuth tokens so I've lost my
list here but there's several different
types of web services that people have
built over the years traditionally
people try to build distributed
computing systems by looking at what we
do well as programmers now what is the
most common operation we do read from
memory perhaps I reacts as a variable or
accessing memory and people several
decades ago said hey can we make
distributed computation and accessing
distributed data simply look
memory read wouldn't that be pretty cool
right i mean how easy would that be and
they looked and said hey we're already
swelling memory out to disk and r OS
lets us build a swap in memory and
access it without the program even
knowing that that's occurred well why
can't we simply do that with these
distributed nodes so they built these
systems distributed memory they worked
they got them to run there was some
performance problems I'm obviously you
try to read an integer and suddenly it
takes 200 milliseconds rather than takes
rather than taking two microseconds
that's a problem right how do you build
a system in that environment is kind of
hard how do you lock a system when you
have some kind of concurrency how do you
handle the semantics of a read that
fails mean none of us have ever coated
that I'm going to assume no one has ever
code assistant where I tried to access a
variable and you couldn't do it in your
program because someone felt it doesn't
happen all right so some semantic
problems and we evolved beyond that you
know the academics publish their
research papers moved on and so we went
to RPC services and hey if we're you
know we're going to move past accessing
memory that's a little too simplistic
well programmers we're good at creating
functions and accessing functions we can
do procedure calls all day long you know
it's the first thing we learn in
computer science 101 so how about we
build a strip computing by simply making
these remote procedure calls and they do
that and they worked you know we've all
seen soap systems they were they're fine
there are some semantic problems again
you got the same issues like how often
do we talk about our front side bus
failing for one second every 17 minutes
so no one's ever heard of that right and
yet that is a ninety-nine point nine
percent availability timeline which is a
great standard if you do some
distributed systems a large application
but we never have our front side bus
fail for a whole second every 17 minutes
we see it simply doesn't happen not only
that but if your front side bus does
fail suddenly you've got face sharing
and you never get X your execution
suddenly halts your you as the caller
don't execute any more so the failure
modes are simplified RPC works people
who've all beyond that to kind of some
restful protocols and restful styles and
we'll discuss why how what some of the
benefits are of those other areas is
network file systems right we've common
commonly you still useful today there's
peer-to-peer systems we've all used
we've all seen systems like bittorrent
and there's research papers like cord
and Kadeem Lea one of my favorite to
startup called space monkey they build a
strippa do storage and the only reason
really you would use a peer-to-peer
system is if you're trying to one evade
the law or two if you're trying to mooch
resources off university right it's a
terrible architectural style it's
incredibly complicated but hey it's a
great business model if you can simply
get free computing and that's what some
of these businesses are in fact doing
the last one of my favorite is I have an
iPad at home and and I and I level use
knit but I actually use very little HTTP
on it i think i actually use a lot more
of the dash protocol for streaming
netflix my ipad simply a streaming
netflix player and I hope that Netflix
would never use rest to design their
system because it doesn't work well so
there's lots of different architectural
styles we can go for and we're going to
talk about what we do i'm going to
assume that in our applications for the
most part we're going to building
something that's similar to the web or
web applications and if we're going to
do that then the rest is actually a
highly effective architectural style
that we can choose and it's going to
give us a lot of evolved ability to
getting back to our versioning api's so
here's our you know here's a map of the
web today the internet which has
achieved the web is achieved internet
scale and in a year two thousand Roy
fielding publishes PhD dissertation and
he studied all these architectural
styles kind of like we just walk your
distributed memory RPC during media all
these different architectural styles and
he looked at why the well was accessible
and he identified four areas in which
the web was successful and then his
whole dissertation was why it was
successful and how can we apply those
same principles in our systems to build
scalable systems and and highly
adaptable and available extensible
system so the four areas he identified
were first was a low barrier to entry
and what he meant by that was that
anyone go on the web publishing content
right we can do it even if some other
pieces systems down there's distributed
management control i can go publish
stuff all day long we do it at
lucidchart we're on a two weeks from
cycle and we concept at our site we
don't have to go ask I an hour
someone else to go update our site for
us so it's incredibly has incredibly low
barrier to entry very powerful principle
another one is the ability to the web
has been successful at distributed
hypermedia is fun term and all I really
means is hey we have links and I have to
go and download content and control
information every time I access a link
how does the web make that kind of
computation performance is actually you
know huge distributed system there's
performance problems with that but the
web has been successful third is it's
reached Internet scale I mean obviously
it has so how did it achieve that goal
of scale and the fourth one is our goal
for today it's extensibility and what
what Roy ended up saying about
extensibility was this going back to how
lucidchart is scaling and I'm sure most
of your systems look very similar he
said while simplicity makes it possible
to deploy an initial implementation of a
distributive system extensibility allows
us to avoid getting stuck forever with
the limitations of what was deployed and
healed on he goes on to note that even
if we do nail the use case initially
that the requirements will change over
time just as society changes over time
so the rest of his thesis simply dives
into that how do we gain how do we
design our systems for for our purposes
of a extensibility or evolve ability in
his thesis he creates this table the
five components he identifies the five
components of rest where first is the
resource there's some logical resource
out there there's a user there is a
there's a book there is some some
document there's a report and it doesn't
it doesn't matter what how you represent
it when we transferred over the wire it
doesn't matter whether it's XML or JSON
or HTML is simply matters some logical
resource that different nodes and this
is someone access and the second one is
resource identifier there's a
representation that kind of mentioned
it's totally decoupled from our resource
there's metadata about it says how I am
representing it
and finally this control data there's
manipulation of the resource we want to
build and modify it we want to be able
to get it and access it and delete it
and we're going to need to cash it we're
going to need to worry about proxies and
firewalls or need about static or status
codes so these five components arrest
this is the exact table with the
exception that I've actually put it at a
column on the right about versioning so
that's simply that we're going to add
two we're going to add to the philly
dissertation we're just really going
where to put it and we're talked about
how your version each of these five
components of rest what fielding says
and this is what we're going to hear
about 12 times a day is that the central
feature that distinguishes the rest
architectural style from other network
based styles I think of that big list we
had of distributed memory and RPC and
dash protocol is is that rest emphasizes
a uniform interface between components
it goes on to talk about how we apply
the software principle of generality and
that when we do that implementations are
decoupled from the services they provide
which encourages independent
evolvability and so this is the uniform
interface of rest here and it's going to
I us a d couple of different components
and evolve those independently the first
one or two talk about is evolving the
resource and the piece of the uniform
interface we're going to take advantage
of is we're going to separate the
representation from the identity which
we already kind of looked at so at
lucidchart i mentioned we can create
floor plans and i've designed my condo
here basic condo beds two bedrooms
dining room living room and I so I
designed to lay out my floor plan I set
up my condo and living it for a while I
like it let me get tired and say I buy a
new TV and I actually don't need that
second bedroom actually always wanted a
home office so I'm going to give myself
a home office I'm going to swap my
living room and like my kitchen a dining
area and of course I planned this all
out ahead of time do my little floor
plan I'm diagramming guy anyway so I
actually want to kind of keep track of
by history lucidchart keeps track of a
full under reader history to persist
that with a document so what if i simply
exposed historical versions
of my resource my for plan through
different URLs and there's no reason I
can't do I right so I just say my home /
v1 my home / b2 we've separated the
resource representation we haven't
talked about XML at all right we haven't
talked about what this looks like when
it's transferred in some HTTP body we
just really follow your resource we've
actually created multiple resources oh
how do you do it straightforward great
two URLs to resource identifiers yeah
uh-huh for example if I if I shared a
URL that was lucid chart com / dog
slashed my home is that what you're
thinking about so the question was I so
I think the question was what do i do if
i share the link and then I break it
because I've changed it by adding
version numbers is that what you're
asking right so I've intentionally put
v1 and v2 on here from the beginning for
that very reason good question that's
actually let's look at that right here
so how do we evolve our resource
identifiers think that's your question
right very next one or arrest components
so we can actually design them to be
volleyball let's look at that so rest
says again what is it the uniform
interface is going to help you and the
principles we're going to use the
uniform interface are we're going to
separate we're gonna use hypermedia as
the engine of application state famous
buzz word from the paper i have a hard
time understanding what it really means
unless i just say hey we're these
hyperlinks and then the first one is a
uniform identification of resources
where to use the uniform interface we're
not going to put resource identification
elsewhere ahead or anything like that so
i'm actually going to use an example and
and i can I want to ask has anyone ever
written a client of an application have
them change their URLs and broken you
yeah pretty frustrating hind happen
doesn't loose chart a couple of weeks
ago we partner with a lot of online
applications we love our partners so i'm
actually not using them their example
day don't want to throw them under the
bus today at javaone but but they broke
they changed their urls and it broke us
and it was really messy of course how
does it always happen right for us they
called us a roast an email on thursday
night inside Oh sunday we're making this
change and you're going to be broken and
there's nothing you can do about it
really so what I ended up doing was I
had to change our system they had a URL
recipe they had given us originally and
there's some career parameter we'd have
put in something and they were changing
that and and there were could be any
backwards compatibility support or
window where they supported both URLs
and even though we asked for it they
said no
not only that but they have rebranding
of their tools and that happens time to
time right and they have SEO and so they
want to have change the path and the
URLs and actually changed their URLs in
a couple of ways so I broke us what
ended up doing was i sat in my home
sunday night after scrambling getting
our system updated i'll hit f5 on the
browser until i saw their system change
and they go and hit deploy as fast as i
can at least a chart and of course you
know nothing ever works and we were at i
seemed for a full day even though I'd
sit there hit and hit f5 as fast as I
could you know we have our users writing
into us right into customer support
sorry we're waiting for the partners a
change it's not our fault I swear but
you know you can't really say that the
users evil you've all had a similar
experience so what if I design a system
like this so this is much like what we
had with this one partner but we have
Bernards I'm talking about a lucid chart
diagram I upload an image of my condo
here my final result I like it just
excuse the fact that i've replaced my
big screen TV with the piano but i've
got some ID of my image i've uploaded
and a client can get that ID they parse
it out and how what do they have to do
from there well they've gotta go and use
my url recipe right they've got to go
and create lucidchart calm / IMG s last
one two three but i change it let's say
in our example we're going to move to a
CDN i want to change the hostname now
it's a perfectly reasonable for me thing
for me to do the service provider it's
going to provide better performance to
my clients but it breaks them right and
there's nothing you can do about it
maybe it can go through some complex
backwards compatibility cycle or I
support both URLs at the same time but
it's going to be really painful no
matter what the client has to change
that it change the url url recipe well
it's a really simple thing we can do to
avoid breaking our users and yet still
allow our URLs to change is simply to
use hypermedia hypermedia is an engine
of application state this is all it
means is that if we simply return the
URL there is no hard coded internal
lucidchart logic in our clients we don't
expose the implementation to them we're
just give them the URL no matter what
URL we give them it will be right now I
think your question originally what if
we share it and so on bookmarks it right
and that's absolutely valid that's why
we use URL right
urls right is very powerful there are
external IDs so first thing we are going
to do is we are going to do this and you
know our part had done this in the first
place we wouldn't have broken because we
didn't happen to cash this one URL this
would have been sufficient for for this
example we had a couple weeks ago but
we're going to go ahead and we're going
to still look at a uniform interface now
I'm going to take a little minor
digression who's ever seen a service
like this before where respond two
hundred okay and yet the response is
error not found I don't know I worked at
places were like what were you doing
guys you know hashtag fell all right at
least return 404 my client Elise can
understand that and besides if I do have
to send back error codes which of these
error codes is less likely to change the
standard one so okay first of all we're
going to use a uniform interface even
when we're returning error messages but
really solution through and redirects we
asked our partners to do this they told
us know and it's clear to the point
where like ok they're not going to do it
for us mark and ask why but I mentioned
it here so we'd never do it in the
industry not never but I even I myself
I'm guilty of all these things we don't
often do these simple things we simply
if we use hypermedia and we support the
uniform interface including permanent
redirects then our clients can update
their cash values and things don't have
to break and we can have a very seamless
backwards compatibility solution so
anyway that's that's URLs for you now
yeah
so the question is what I think about
using created my own error codes I think
what you're saying is use this uniform
status code feel but just create my own
numbers like 308 or something like that
right so you certainly can and the HTTP
interface which arrests have to be but
it is and it's wonderful so I don't know
why we've been around it it is
extensible certainly you can and and of
the two which do you think is better if
we were to use custom status code here
versus here what do you think would be
the benefit so certainly there are cases
I come across something I found out i'm
wrong afterward but i thought that there
isn't something in the uniform interface
a predefined field a predefined value
that i need and the uniform interface
certainly lets you extend it so it's
absolutely valid to extend it absolutely
and there are classes of error codes
probably familiar with four hundred or
three hundred 200 500 g i district so
you can certainly still follow that
uniform classification use the uniform
field perfectly valid to do it whenever
we the inspector right it's not a yes or
no do we follow it it's how much do we
follow it and the risk of simply moving
away from it is just moving away from
the interface and and losing some of the
benefits you know one of the beauties of
uniform interface all i need to pick up
and library off the shelf and you can
use it most of them pretty good about
our standing but it's perfectly valid
thing to do people do all the time and
it's one of the reasons that rest is
silly evolvable you know we we there's
new rfcs that define new we actually
just up the pass anyone heard of the
patch verb i just added a couple of
years ago actually very powerful HTTP
verb i recommend you go look it up we
won't look it up here but it evolves
itself HTTP and the fields and status
codes so
hypermedia with scala and play so let's
show a little bit of code we're all
developers here probably and this is
about Scala anyway at least it's in the
title our implementation is should be
totally decoupled from interface but hey
we want a bit we've got to be able to
build it right we're engineers so let's
talk about some user service client
wants to get on my user service and give
some URL slash user slash 123 for
example so this is a simple example that
shows you the power of the Play
Framework and what's helped us as we try
to create a new volleyball system
through the uniform interface so we have
a controller here using model view
controller pattern and and I've got my
get user right here so my rouse file
substandard routes file like there are
many frameworks says Matt this URL to
this function so down here I've got this
function my get user function and play
framework helps me parse out different
path parameters you know it's not
exposing the user we're not we this is
not a recipe exposed user this on the
server so it's perfectly fine for us to
have your our recipes there and what we
can do with play is play actually has a
nice library for generating hypermedia
you can say in my user profile I'm going
to return a link to some paid account i
have on my system some paid account
lucidchart perhaps that user is a member
of and because play we're using play to
map out all of our route some of our
mappings between handlers and URL that
knows about our URL structure and we can
simply go and ask our routes library for
a URL to that account and it's got a
nice templating language and part of
play so I go ahead and create my
template pass it my link and return to
the user give it a 200 okay here's the
actual view to give to the user and
regenerated hypermedia and three lines
very simple getting to the redirect
sample many frameworks have the same
support but again we went to the play
framework because it gave us a nice
robust support for the uniform interface
made it really simple to do not a lot of
boilerplate code here a client
requesting lucidchart commes les images
/ ID which we've moved or CDN already
and so we need to be able to redirect
the user to the permanent location so i
just simply add two line function inside
of here i create my new location the new
URL images de lucidchart calm and i send
a 3-1 redirect so the play frameworks
been really helpful for us in building
restful web services and evolve a bowl
web services makes it really simple to
do think generate hypermedia and and
follow uniform interface and status
codes so we have evolvable urls does
that answer your question kind of by the
I shared a URL and suddenly change it
and I broke
yeah so so what my intent we're doing
over here back boys I'm not going to go
all the way back there my intent was to
create multiple resources so they are
URLs or resource identifiers right so
you could imagine some they think what
we do if we have latest and over time
that URL identifies different resources
is it a resource identifier then is it a
complete resource identifier so the
uniform interface says the URL is the
actually I'll just put this right here
so if we make for URLs to be evolvable
the URLs has to be the resource identify
that is the uniform interface I guess
there's some implicit parameter that is
something some states changing on a
server and there's some pointer
interesting question about you know
latest resource but my intent which
create multiple resources and so so you
can share my intent with the floor plan
is I want to be able to share v1 or v2
is this interesting question about some
kind of soft link to some resource that
will be a pointer to but that pointer is
going to change over time and to a
question I don't have a good answer for
that one but yeah my intent was not to
do that my tent was I want to have
multiple resources these are distinct
resources but not not versions of the
representation I want to be able to hold
on to those forever and when I share v1
I intend to share who you want hey look
look what I lived in from october to
march through 2013 or marched october so
we're going to skip over the
representation right now the reason is
that's the most problematic for for my
experience most problematic piece of the
uniform interface to diversion and so
we're going a few more tools in our belt
before we actually tackle at one we're
going to go on to representation
meditated and metadata and control data
and again representation metadata is
what kind of media type of my using
right what metadata are we transferring
about the format of the body
control data caching like it says their
status codes the manipulation of the
resource that we're trying to perform in
a request so the HTTP 1.1 RFC that
actually roy fielding is a co-author of
contains 47 different header fields that
defines 47 different standard header
fields to describe a whole slew of
parameters about a request so just
walking through this sample request to
get user / 123 it actually look at this
we're including information about what
dns resolution the client went through
to connect to the server actually pretty
comes in pretty powerful or trying to
dinner and hypermedia so we could the
server can know what kind of DNS
resolution the client wants for his URLs
is information about the decline itself
here's content type negotiation which
we'll get into again later and it's
pretty powerful you can't you can
specify actually a preference of
different content types you want I'd
prefer text HTML if you can give it to
me server but if not i'll take
explication XHTML or just plain old
application xml there's information
about reusing the tcp connection how
powerful is that i can reuse my tcp
connection is all right there can
negotiate it without any out of bound
communication is caching information
timestamps i love timestamps i don't
know i don't have time stamps and
everything we do in computer science and
there's information about what kind of
proxies were traversed as the request
got to the server there's authentication
information this is actually an OAuth
token right there all that right there
so so what right yeah it's kind of nice
uniform interfaces we use
self-descriptive messages now who's ever
gotten into a situation where you're
trying where you're trying to modify
some web service and you look at an end
point and you don't know who's calling
it anyone had that happen yeah all right
here I had to go ask the question okay
who called the send point I'm going to
modify it and I need to not break them
you've had a look how successful were
you at finding out that answer not very
yeah yeah
yeah exactly I did that very thing like
a week ago a minor minor disclosure from
lucidchart it wasn't a major issue and
affected a few users actually changing
authentication and so some
authentication header and it's like I
saw it being set in a response somewhere
and I didn't know who was calling in I
tried asking around and I thought I knew
and it I broke a chrome app so his six
now if your user chrome app it works but
what a painful question to have to ask
look what we actually do if we use
self-descriptive messages and I for
example let's take actually go on to the
next one this is a server response and
I've got all kinds of header fields
let's look at actually the content
encoding G tip so let's say we're
returning application XML you've got
performance problems and a lot of us due
to the the size of our response and our
bandwidth issues we've gotten our server
so I want to start G zipping my response
now either I can go and try identify
every single client at this endpoint and
go and try say oh hey on you know
november seventeenth I'm gonna start G
zipping it and you've gotta go code to
that in your client and the only way
you're going to know about it is because
I'm gonna tell you in an email or
something like that and you go press the
button on your client to start unzipping
that one but no you don't have to do
that here I don't even have to know who
my clients are all the communication
about request is stateless everything is
contained in the requests itself I every
single client is going to know that I'm
G zipping it and you'd say well yeah
Derek that's kind of nice but I still
got to change my client well this is the
uniform interface all you have to do is
pull off a really good HTTP library and
this is the jvm world they're like six
seven or eight really good ones out
there and we can actually support most
of this interface right out of the box
with the one or two libraries so it's
actually really powerful principle I no
longer have to go and ask myself who my
clients go and coordinate this update
all the information is contained in the
request itself through self-descriptive
messages and some of the power that the
filling points out in his thesis about
this is what what it lets you do in
terms of evolution of your architecture
you can add proxies you have firewalls
you can add gateway servers
you can change content types content and
coatings you can change the support your
server has four keep-alive connections
you can change your server you can
change your caching you're caching
infrastructure all that can be
seamlessly handled without any kind of
out of band negotiation with your
clients so how do we evolve the resource
metadata in control day we looked at
self-descriptive messages actually
didn't get into the Uniform Resource
manipulation much just because of time
the all that really talks about is we're
going to use the standard methods a tell
tale that of web service is actually not
restful but a little bit more brittle
RPC style is when you see stuff like /
document / share I've got a verb in the
URL and yet I've got a verb inside my
request which one is it I don't know so
using the uniform uniform resource
manipulation simply says that we're
going to use the uniform methods and say
go look those up I mentioned the patch
or going to patch is a really cool one
lets you do a partial modification of an
object and again this is evolving that
without just a few years ago so we've
got most of our components version now
or designs 30 volleyball so we don't
have to put version numbers and most of
them pretty powerful idea we're using
URLs we're using hypermedia or using the
uniform status code self-descriptive
uniform headers of the big e
representation who here is is currently
developing your own a web service a lot
of us I do a lot of that at lucidchart
we're a small company so I kind of get
it get two and a half to do everything
and this is one where we see all kind of
stuff so I'm going to start out with
something I saw just a couple of weeks
ago lucidchart actually you an image
service we're returning an image to a
client so we're doing get / images / 123
and there's some standard boilerplate
headers and the in the HTTP response
that we all see right 200 ok you won't
put one I don't care content type
application XML yeah and here is our
response
we have response a response body and
look what we have we have a status field
we have an ID and looks like I've
embedded my image here I looked at that
and thought what kind of image is that
isn't a JPEG of P&amp;amp;G I didn't know and
luckily I was able to go and tap over on
our on my team mates shoulder and say
hey you know what what is this they
could tell me what is the normal client
going to do you know or what if I have
to develop this and what did I should do
all this on my own what if he's on
vacation no idea what that is I mean it
looks like it's probably Bay 64 encoded
right but I don't know so just compare
that with this this is island said Jones
oh hey why don't we just make it look
like this I don't why can't we just do
get images and the clients actually me
to say please give me a JPEG and it says
yes I gave you a JPEG I have a status
code and for the ideal we're going to
put the ID how did the user make the
requested they didn't have the ID in the
first place they already have an ID and
besides we don't even want to give them
this idea suddenly that's gonna if they
start parsing it and using it and we're
brittle again right so we already have
an ID and actually have left out
something there the time stamps and what
about a time stamp which last modified
timestamp filled in standard header so
we actually added a last modified time
staff from the body's not for more than
the JPEG and if I want to go ahead and
Bay 64 encoded I can but the
informations all right there which one
of these is more likely to change in a
breaking way pretty clear right the
homegrown solution I talked earlier
about how often we see web services that
use HTTP is a transport this is it I've
created my own application layer
protocol at credit my own status failed
my own ID my own content type and
encoding this really isn't content type
this is the content type of my
application layer protocol not my actual
resource I don't know what that is which
is going to change more my homegrown
application layer protocol or a HTTP I
mean we're on 1.1 been around for many
years this one is much more robust and
simpler I mean which do you want to use
the client this one or this one ouch you
know I want to parse XML to be able to
get an image and I use my HTTP library i
can say get me the body and i have the
image what kind is it it's jpg so we
went on to that and this is a little bit
of digression but putting out because so
often the problem with evolving our
representations is that it's not really
representation of the resource it's our
own homegrown application layer protocol
so use the uniform interface it's going
to help you so JPEGs yeah Derek that's
really easy you know I know about JPEGs
tiff file formats BMPs all these things
what I'm not returning those most of
time you know so I well I need to return
a book I've got some social service I
need user profiles I need a friend list
I need something else I need some
business intelligence report
microformats org is a great resource it
lists several microformats in the wild
today and actually links uses of those
formats in the wild also the internet
assigned numbers Authority actually
maintains a registry of media types and
once whenever I need to look up media
type you know how do i set the content
content type field as I posting
something to a server I go look there or
if I need to figure out okay I expose
some new resource in my system and is
there a standard media type I can use I
n is a great resource and I think I
looked the other day to give a rough
camp is over a thousand media types
registered with I am today and you can
even register your own so let's move on
to that because that's what most of us
do in building web services as we create
our own it's in our nature of Engineers
right we invent our own systems whether
or not we should we want to so I've in
my own user profile schema here some
JSON format I've got name phone email
photo I've actually embedded it right
here I'm member of these groups here's
some paid account i'm on Lucy char
perhaps whose books I've linked to don't
exist lucidchart but that's this profile
I like restful web services and rest of
practice you want to hear what what Roy
fielding was said about this he wrote a
blog post in 2008 and said I'm getting
frustrated by the number of people
calling any HTTP based interface a REST
API today's example is I filled up my
own here
that is our PC it screams our PC there's
so much coupling on display it's been
given an x rating what needs to be done
to make the rest architectural style
clear on the notion that hypertext is a
constraint in other words if the end in
an application state is not hypertext
driven it is not being driven by
hypertext then it cannot be restful it
cannot be a REST API period is there
some broken manual it needs to be fixed
and so it's kind of a fun event I always
loved reading that one so this is what
he's proposing is hypermedia I've still
got my resource um cohesive resource now
its name phone email but these ancillary
resources and secondary resources
replaced by links so I presenting this
sometimes people say yeah that's nice
Derek but I want the other one I don't
care if we call it rest fine we won't
call it rest I want the other one and
yeah I don't care if we call rest either
that's fine this is some internal web
service and I'll have to advertise I'm
not getting marketing out of the Faculty
of a rest service but look actually what
happened this is the user service right
what happens if I go and and suddenly I
ain't I've got some inconsistency in my
formatting of my way represent books
I've got some underscores in some places
a camel case and others so I go and
change books why do I break every single
user of the user service when I change
books it's really brittle right and this
is not rest this is coupling this is
cohesion this is nothing more than like
the basic kind of software engineering
practices that have nothing to do with
web services themselves why do we not
use tight coupling because it's brittle
what's less evolvable than a tightly
coupled tightly couple set of components
in a web service or any type of piece of
software yeah
thank you you're a plant no no not a
plat that as a wonderful question that's
what everyone says right absolutely
gentlemen and we're fielding pointed out
in his thesis there that were making a
trade off and that's what all but all
about was that's everything that we do
in engineering is it it's all about
trade-offs and engineering and effective
engineering is all about making sensible
trade-offs oh absolutely absolutely
right and he knows that that the rest
architectural style is not optimized for
every interaction well he says the rest
is optimized for the common for the
common case of the web and what I want I
found to be true is actually the common
case not just the web but even web
applications so let me tell you my own
little anecdote and and it's just an
anecdote as all it is I'm sure probably
similar to what you're dealing with but
what I've seen saw happen at a previous
employers made at rest service the main
client was a web browser and we had some
performance issues we actually were not
super restful and we call it a rest
service but you know some web service
and it was much more like the one on the
left the resource of the left it some
mega resource we put everything in it so
that we could make a single HTTP request
and get all of data we needed and I
looked at the end point that was
requested most frequently in her system
it was a user service and we I tie in
the responses and found it was taking
about 300 milliseconds to respond so he
actually d couple the system we didn't
actually even put hyperlinks in it we
didn't go so far as that which D couple
a little bit we found that most of the
time that we found that not every
request was using every piece of data
every piece of data we put in there this
mega resource any piece of data that
we'd ever need not every piece of data
that we always needed and again this is
just you know one example but what we
did was take we took that web service
response time 300 milliseconds and a 70
milliseconds again this is the most
frequently requested resource in our
application and
massive performance improvements
occurred that simple change now you know
Derek that you know we want all of it
and and what I found is a couple of a
couple of ways to to accommodate for
making multiple requests well one is
parallelizing right and parallel
computing is pretty pretty powerful
which these can be parallelized more
effectively well at one on the left
can't even pee relies that at all you
can paralyze the heck out of one on the
right now what's the common objection to
that hope you think of a problem with
that maybe you run into that yeah
absolutely yeah absolutely complexity is
yeah it's definitely the engineering
trade-off and complexity is one and
usually what i hear is will hate the
browser derek don't you know that
browsers only allow you to have six to
eight outstanding HTTP request any given
time so suddenly you've multiplied it
well yes we have multiplied it and if
every single request needs a lot data we
may not want to go this route absolutely
I mean it's all about trade-offs one
thing that we found that actually
optimize our system like I said is not
every requesting did all the data
additionally we could paralyze it and
when we did hit thread and ate out HTTP
request limit in our browsers how many
HTTP requests can you do see really in
70 milliseconds as opposed to 300
milliseconds I mean you get what you pay
for right what are you getting here and
what are you getting here if I'm getting
what I pay for that I must have paved a
lot more for calculating all these extra
fields and against anecdotally noticed
some no absolute rule but you do get
what you pay for is probably a fairly
reliable principle and if we're
calculating a ton of stuff we probably
paying for it and do we really want that
and what filling points out again is
that we're optimizing for the common
case of the web and I say web
applications so there's some granularity
that's optimal for any application
that's what you're just going to have to
work out in your application but think
about something to perform these
performance considerations that
you know the two requests don't take as
much time that you can parallel eyes the
heck out of the hypermedia one and a
third line i'll list before I move on is
which one of these can be more finely
tuned in terms of caching yeah why you
shaking your head yeah but what if i add
a new what if there's like a number of
bookmarks that people put on books right
yeah how am I invalidating my user
service our time books change so there's
actually a lot of performance tuning you
can do with some some cohesive resource
so thank you thank you for your question
so closing up now move real quickly we
have we have hypermedia we're using
custom standard media types but hey we
need to invent our own we want to
version them right so we're going to put
them in the URL well what's our goal our
goal is decoupling resource identity
from representation so that we can
evolve the representation do we do that
here or do we do the opposite we put the
first number of the URL why do we couple
those two together we want to do the
opposite and I think the only reason I
can think of why we always do this and
see this simply because we're all
familiar with manipulating URLs I mean
that my family members who are nothing
to do with technology and don't care
about they all know how to manipulate
URL so i think it's why we do it we put
off parameters and urls and it's easy to
make you late so we do it so I owe this
idea a proposed solution an approved
solution on this approach for versioning
our own custom media types to a blog
post called barely enough to org I
believe the gentleman's name is Peter
Williams's name early enough to or if
you want to look at his original blog
posts on it there's some fun ones he's
got some nice thoughts but I've got a
vendor specific I've got a vendor
specific media type my vendors
lucidchart and here's my xml diagram
I've media format I've represented this
diagram ass
the standard field view from interface
for specifying a media type is the
accept header and the content-type
header it's no reason you can't put a
media type in there if you as a service
provider want to support multiple media
types the way to do that is to use
accept header and the content-type
header a pretty simple straightforward
solution and hey what have we done we've
decoupled our resource identity from our
resource representation the resource
representation can evolve independently
we can bookmark that URL doesn't be
change and we've we've got a more
available architecture here so here we
go we fill in our table we're using the
uniform interface and I'll let I'll at
Roy fielding close he says the central
feature that distinguishes the rest
architectural style from other network
based Styles is its emphasis on a
uniform interface between components and
as we apply the principle of generality
which is kind of underlying principle
behind the whole uniform interface
implementations are decoupled from the
services they provide which encourages
independent evolvability so that's the
end of the material hopefully that helps
provide some strategies for designing an
e volatile architecture and I want to
get a few questions and and other or
someone has a comment or suggestion that
they found effective yeah
so so the question is what happens if a
resource does change you talk with the
resource representation of the actual
resource itself like so you're saying if
we're using a photo and the photo
changes now oh I see you're saying it's
some change so you're saying it we have
moved from one photo in my in my profile
and now I've got a multiple and I think
what you're getting at is that no matter
how you represent that it is going to
change because underlying the whole
resource type if you will underlying to
change that right so I mean I would cede
say initially use the resource
representation there's always going to
be some representation so first of all
if we use the uniform interface which
includes standard media formats one of
the benefits we gain is we gain amateur
design already and often that mature
design will take into account some of
these ideas like you're talking about
you know often I found if I I may not be
taken to the full features of some media
type initially you know i'm using adam
and i'm not using all the fields and
some I atom publishing protocol but over
time it is I've adopted some mature me
type that is ubiquitous on the web and
probably includes lots of use cases
beyond my support now so first of all
using uniform interface need room for me
type hopefully we don't have to evolve
it but if we do have to evolve it how do
we evolve the media type and you can
specify different version to
representation and you can do it that
way I mean the trick is is backwards
compatibility right in the end if you're
going to support multiple
representations you've got to change
your service which supports both of them
and you've got a code that in your
server but if you do it like this then
you least provide a backwards
compatibility window and you can say
okay as soon as you're learning to
deploy our system we're going to support
lose
diagram + xml for some window and please
start requesting dash V to within this
time window and you'll get the the new
representation and then new resource how
does that does that answer kind of what
you were getting at how I run into a
problem like this I run the problem with
roosters representations all the time I
honestly I haven't done this myself I
came across this solution recently my
personal philosophy on it is is if
you're providing for some backwards
compatibility window whether it's
changing a value mean changing changing
a field can be model the exact same can
be modeled simply by as the addition of
a new field and later deletion of an old
filled right so seems like I always end
up having to do that and even what I
kind of suggested earlier even if you're
calling a different media format you're
doing the same thing right you're adding
a new field you're removing it all and
then you're there some time period where
you got the old and a new field and then
after some deprecation period you remove
the old field so whether we caught some
new way or some new name or whatever I
don't know there's a solution for it
other than simply to do that but if
we're following uniform interface
hopefully we don't run doing into it and
if we do we're using media formats we're
using the center header field then we
have tools to allow us to request one of
the other and I don't think there's an
easy answer to it but I've but I think
there's yes is a I've never found a
solution others simply say okay I had a
new filled some period I got the old one
and then you remove the old Phil and
it's what we're doing with libraries
right it's not specific to the web any
other questions or comments think we got
one minute yeah
I don't know if you don't know if I
moved over I actually don't think I
don't think we would if we have I don't
think we would have put that accept
header the accept header is optional but
it's powerful if the server does support
multiple formats and the uniform
interface is that nothing should
constraint even if a server only
supports one format nothing could you
could strain it from accepting from
respondent multiple formats in the
future so we have done that there's
nothing in our new interface that would
constrain us such that we could not
return P&amp;amp;G if the client requested but
we actually haven't done that I said it
was a couple weeks ago and and I've had
other fires to fight itself well thank
you everyone for coming again my name is
Jerrica and we're lucidchart so</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>