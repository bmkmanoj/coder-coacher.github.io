<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Java Virtual Machine Is Over: The Polyglot Virtual Machine Is Here | Coder Coacher - Coaching Coders</title><meta content="The Java Virtual Machine Is Over: The Polyglot Virtual Machine Is Here - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Java Virtual Machine Is Over: The Polyglot Virtual Machine Is Here</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Bho2_KVj6DM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to my polyglot JVM session at
javaone I was asked to give something of
a more of an overview kind of level and
touch down at some certain tasty bits do
some evangelism about the JVM turning
into polling a platform and I was asked
to come up with a dramatic title so idea
the JVM is dead long live the polyglot
vm but just like my dog there the JVM is
not dead he's going to soon spring up
from its sleep as a cybernetically
enhanced polyglot runtime that does more
than just run java so stretching the
metaphors a bit also my belt buckle
broke this morning so I might drop my
pants at any minute in the case although
so thinking just a word to the wise all
legal don't pay any purchasing decisions
on anything I say today so Who am I I'm
Marcus lagergren I work for Oracle in
the Java language team I've been since I
came back to Oracle in 2011 I've been
working mostly with dynamic language
related issues on top of the JVM I rant
about JavaScript a lot on my Twitter and
more what I'm doing as well I've been
involved in that nice warm project I've
been involved little bit with the Avatar
jas folks it's plenty of sessions here
in this conference this week so mine is
more of a look what the JVM is turning
into and it's not my active choice to
wear the swedish football t-shirt here
this is I'm based in Stockholm Sweden
which is one of the three larger largest
engineering labs that we have in Oracle
at oracle so the agenda for the polyglot
vm talk is the introduction which i'm
giving you now and a little bit of
history of the vm languages and run
times going back to john mccarthy
because i'd like to talk about lisp and
show pictures of John McCarthy and i'll
talk about emerging languages and
language design on top of the JVM and
why the JDM well it's always been an
attractive platform to deploy things on
that are in Java has been since 95 96
Java 10 but why it's getting more and
more relevant now what people are doing
and the main facilitator on this on the
JVM level today as
java 7 is the invoked dynamic byte code
and the libraries around invoke dynamic
java.lang invoke who in this room has
done anything with invoke dynamic Oh
java.lang invoke we have a few hands who
mannequin can read how many can read
y'all the bytecode in here Oh got a few
answers it's good so hopefully this will
actually be the right level of
everything then and then I'll spend
about maybe a fifth of the presentation
talking about the nazarene project or
other sessions about this today for
instance at one o'clock in this room
Attila sega d my colleague will talk
about how to deploy javascript on the
JVM it's an interesting talk Jim Lasky
the multi-language lead in the Java
language team had an introduction to
nazrein let's not productized yesterday
and I'll talk a little bit about how we
are within Oracle within the OpenJDK
driving the evolution of the JVM from a
Java Runtime into a multi language
runtime through the da Vinci machine
project also known as the mov a
multi-language vm project so
introduction what are you really going
to talk about my colleague in Stockholm
said well the wrong time the JVM but I'm
talking about his transition into a
generic runtime ok he said so you're
going to talk about the universal Mita
execution environment that's exactly I
mean one sentence describes what you're
what you're going to talk about but it's
actually as simple as what the JVM is
becoming in the multi-language space
let's just say the multi language
runtime and since I've been involved up
with Nas horn and JavaScript on the JVM
and talk a lot to Charlie not around the
JRuby guys and so is especially it's
also the fastest growing field and stuff
being deployed on the JVM right now is
dynamic languages so history what is a
runtime anyway I mean we had a JVM where
J stands for Java that runs java that
compiles once and runs anywhere but
anything that you compiled to bytecode
will run on the JVM because that's what
the JVM specification says and there is
a JVM specification so excuse to show
picture of gentle McCarthy further Lisp
it goes back to Lisp in the 1950s or
actually it goes back to what his grad
students did at MIT 1962 which was the
first list compiler
which was a just-in-time compiler and
there may be language purists and
historians here Christian Wimmer
probably knows more about this than I do
in the historical background but as far
as I can tell from my extensive
Wikipedia research this was the first
jit ever and this was in 1962 so that's
pretty cool and another interesting
thing about the list of implementation
from the 60s is that it had automatic
memory management and I don't think we
saw that before either it implemented
garbage collection with reference
counting which we don't do today but it
had garbage collection and automatic
memory management which in fact made
this 1962 thing the first modern
adaptive runtime and we recognize things
in the JVM today from what dr. McCarthy
and his grad students did so he's one of
the Giants on whose shoulders were
standing today the other giant being of
course mr. Allan K Xerox PARC the father
of small talk who gave us things like
the first class library today we have a
large JDK which is our class library in
the JVM but studs not a new idea he gave
as the first visual GUI driven IDE and
is very true when I say that it's great
great great great great grandchild is
actually eclipse for better or for worse
what they did their lives on through
through some IBM years and and comes
back to haunt me every day in the 4-3
release with its low speed and with the
most interesting thing that came from
small talk even though it's not a novel
concept the small talk or even the first
concept is but is the bytecode small
clog had a right compile once run
anywhere bytecode that is the mostly
historically like thing that looks like
java bytecodes today there have been
several bytecodes attempt in several
intermediate formats but the small clock
bytecode sort of tie the sack together
and showed us what still existed modern
runtimes so we have McCarthy we have K
and then no one's really invented
anything new so for the historic review
I can stop here of course everything is
variations on a theme and ideas and
execution are very different things but
that's the historical retrospective
so emerging languages especially on the
JVM I also went to Wikipedia to do my
very professional research and came up
with about five slides of names for oh
you can't see that at all anyway it's
named for dynamic languages and some of
them are sort of recognizable as being
used widely in the industry and the rest
like yikes and cold cold fusion and
whatever I mean everyone is kathy's
designing a dynamic language is right
now and I could go on showing slides
we'll just names for dynamic languages
for this entire session and a lot of
them ronald g vm as well but there are
some things are definitely having a lot
of industry impact right now so why our
dynamic language is so hot today this is
a somewhat controversial slide and they
are easy to use they are indeed easy to
use it's very simple to code up a proof
of concept in Ruby or JavaScript or
hybridize it like Mazarin does there's
no explicit compile stage attenti to
think of that you write something you
redeploy it for small examples you can
actually get quite good code readability
I find that simple javascript is
actually and this is sort of anathema
for you to say but I find it easier to
read than Java which is rather
voluminous and large non simple
javascript is of course horrible so
small projects good readability short
development time don't try to use these
things for real kids it's my message as
someone from the Java team but I'm
probably be beaten up by JavaScript
fanatics that happens every once in a
while when I tell them the uncomfortable
truth but anyway we can be friends it's
also part of this message today and
because performance which used to be a
bottleneck in the dynamic language world
is actually getting good enough we have
academic research from oracle labs we
have a physical stuff availables product
now we have the invoke dynamic
construction we have native runtimes
like v8 from google let's show that you
can really execute dynamic language is
really quickly and there's plenty of
industry examples we had Ruby that
started out as a native interpreter and
JRuby which is like it runs wonderfully
on the JVM with man decades already of
effort in there and in use cases like
you're right stuff in Ruby compiled to
war file and drop it in your Java EE
cloud and just like great use K
where the JVM is a runtime can use to
enhance with you which you couldn't do
before with that c++ panel if that was
executing Ruby Python is really trendy
in the industry right now and this
jython of course running on the JVM
which has sadly been lacking in love
lately pi PI lomita Python interpreter
seems seems more hot but I mean there
was a very early effort to do this I
don't think they've done much with the
about dynamic which I'm getting to as
well its closure design is a JVM
language from the beginning which is
pretty cool taking off heavily groovy a
lot of Germans in the audience talked a
lot about groovy some reason it seems to
be a German thing Alex I'm not sure why
mm but it's the already on top of the
JVM and then of course of course we have
JavaScript which is everywhere and is
taking over the IT industry with with
all the round times ever all the Mozilla
monkeys and v8 and nasara and nitro and
rhino and I mean there's I also had a
slide full of JavaScript runtime names
here that I'm not going to bring up so
the industry mindset right now is this
and I don't have to understand it I
don't have to understand it that's not
part of my job description but it can't
be denied the javascript is spreading
like a forest fire right now through
throughly industry and and that the
attitude is this of the software
industry so what can we do to help like
to turn the JVM into a polyglot
platforms that you can deploy JavaScript
on it and even other dynamic languages
on it because the world is going in this
direction we can change our message to
run all the things on the JVM and that's
that's what the polyglot thing the
article is doing is all about so
slightly technical implementation slide
native runtimes write something in seara
c++ that executes Ruby or a pearl or
Python or Java Script classic way to do
it something to execute Java write that
in C++ to you got the JVM meet the
circular implementations right whatever
you're interpreting in itself which is
of course very cruel pi PI Python
written in python steal banks Common
Lisp Rubinius but I've actually started
rounding that I found there was a lot of
C++ code in there so it doesn't really
count small talk also you can put stuff
on top of an existing runtime which
could be CLR or it could be the JVM and
of course we're here today we're
interested in putting stuff on top of
the JVM and how how we can help out how
we can facilitate that so it says
dynamic language is a lot of my slide
headers and and this is a bit dynamic
language heavy because most emerging JVM
language is today stuff that people put
up in the JVM that is in Java I've used
the term alien languages as well non
Java languages are dynamic as opposed to
what well as opposed to non dynamic
language is I guess whatever that means
so so this is a little bit hairy to get
into definitions here well we have a
runtime it does stuff I mean who cares
but ok let's try to to formalize it a
bit it is there a formal definition of a
dynamic language turns out that they're
pretty much isn't but there are many
common characteristics you have things
like loose types you just declare a void
of the current in this is X I put
something in it you have dynamic
bindings you will like a compile-time so
things are resolved at runtime rather
than compile time all the linkage is
done at runtime and you usually have
compared to two like none or less
dynamic language is quite a liberal
ready finishing policy of things you can
redefine and modify class if you have
classes or function at anywhere during
the runtime reassign anything some
languages even allow you to reassign
reassign like built-in functions like
like Java scripts where you can for
instance say that Matt sign always
returns 17 and it's perfectly okay so
there's a more liberal religion policy
and and if you implement math sign in
the JVM GDK specification tells you that
this is how it behaves I don't need to
know anything else but when you're
implementing a dynamic language you have
to check that has some idiot overwritten
sign every time it's called so there is
some overhead there and that's one of
the reasons when I'm getting into the
invoke dynamic thing how you can do this
more quickly co typically equals data
well does that as well
when you work with Java and lambdas in
Java 8 you typically have an evil rebel
which is like a evaluation loop where
you can access language interact with
the language from the command line you
typically have automatic memory
management I've never heard of and talk
about a dynamic language not saying that
has no automatic memory management but
well who knows but the border is a bit
fuzzy because you can extend the runtime
you can extend Java a Java program at
runtime to you can load new classes you
can subclass stuff you can get mobile
code into the system over the network
you can do a lot of stuff that you can't
do with your like compiled C program so
maybe the dynamic prefix doesn't matter
so much when you have a runtime as a
platform like that does your garbage
collection your cogeneration for you and
handles all these things that can handle
the things change at runtime things
change it run time if you're not hacking
see and handle it I mean that's pretty
much all there is about I don't want to
do want to stress the distinction
between dynamic and underlying dynamic
language is so much because maybe it
doesn't really exist maybe it's just
like here is the runtime here is a
platform you can deploy stuff to it in a
format it understands which leads us to
the next section which is about putting
the language on top of the JVM and this
doesn't necessarily have to be an
existing language like Ruby or
JavaScript and obviously not because we
see so many new language being invented
we see like coughlin and Ceylon and like
stuff that people are doing in their
parents basements on the Internet so why
why would you choose the JVM as a
platform to deploy a dynamic language on
or a Latin language on well obviously
the JVM gives you very much for free you
get automatic memory management you have
garbage collectors in the JVM that have
man decades in the making you don't need
to implement them from scratch for your
automatic memory management language if
you can serve stuff up a bytecode
hopefully the jets which are also man
decades in the making will be able to
generate efficient code from them you
don't have to write your own code
generators masochist like I am preferred
to do that but not many people are like
that and we should be dry for that
parallelism is a
implicit or explicit or provided in the
JVM so you can use it expose it in any
way to whatever language you're
deploying using the underlying Java
concurrency mechanisms or whatever
hybridization is my favorite point
because I started out being really
skeptical to hybridization writing parts
of the language in Java for example with
Mazarin rock JavaScript engine you can
just use the JavaScript thing a p.i java
x scripting and called Java call
anything in the JDK from JavaScript and
also vice versa which I thought I mean
this is ugly but it turned out it was
really incredibly powerful when we did
avatar jsuis significantly shorten
develop in time by being able to
hybridize things with the existing JDK
like this so this also if you look at is
also another thing you get for free you
get the JDK for free it's all there you
can reach it so to summarize this man
decades of high-tech in a platform that
was originally designed to run Java and
if we just give you some tools you can
run whatever you want on it hopefully
efficiently to at least that's the
gospel I'm here to preach so one point
to prove this would be just looking at
code based complexity here we have for
JavaScript runtimes the two left ones
are written in Java as Mozilla rhino and
Nas horn Oracle Nasrin and then to the
right we have two sequels plus
javascript implementations which is
Mozilla spider monkey and Google v8 and
on the y-axis we have a number of lines
of code so we can see it is like in
factored form five different for
complete compliant JavaScript
implementations if you're writing Java I
have a JVM like a difference of course
memory management and cogeneration and
everything that's in the native run
times that we don't need to write so if
it were all about code complexity it
would be totally worth it to to use the
JVM as your platform and as David
wheeler said we can solve all problems
in computer science just by adding a
another level of indirection so we're
done sounds good implement it serve up
some bite go for the JVM and people have
been doing this since 1996 it doesn't
need to be Java it's just be bytecode
and they've been doing it a lot a lot I
had three
like this too but I had to be a good
boring cutting and pasting various
language locusts after a while so it's
obviously people have tried to squeeze
stuff into the JVM in the form of byte
code for quite a long while but of
course there's a cooler air corollary
two-wheeler which is Henny said that you
can also have too many layers of
indirection and that's what sort of
breaks it also the api's can be thought
of I'm known for my horrible metaphors
here but try to bear with me although
the indirection layer api's can be
thought of like holes in the interaction
layer through which through which you
place your your API calls and sometimes
those holes simply aren't the right size
for what you want to do what your
language might not have characteristics
that you can express it well as Java
bytecode but there are different levels
of hard and maybe your language is a
square peg and you have a round hole or
maybe you have an oval hole in the DVM
on the round peg it just fits there so
Scala is a fairly good fit to something
I've said fairly good because I mean
Scala wants def desperately wants tail
call optimization to be implemented in
the JVM which is something we looking at
in the ml vm project Scala desperately
wants interface injection to be
implemented in the JVM for traits which
were looking at in the hemel vm project
so I know all about this also I was at
the Java language summit 2013 and
actually got a good talk about what
Scala see does to bytecode to make Scala
and typing work and that left me with
some mental scars so so a fairly good
fit is actually stretching it a bit ok
but let's let's say this better than
Ruby or JavaScript because they are at
first glance with their type lessness
and their complete dynamism completely
lousy things to deploy a JVM meant to
run Java but there is help so
concentrating on JavaScript which I will
use my examples here why is it hard well
because Java bytecode it says Java there
it's java bytecode it was it was done to
compile Joe into something that would
write once run anywhere originally well
originally it was done to like run
remote controls and stuff so so it's
it's amazing that it's still alive as an
intermediate
format and and java bytecode the JDM
specification tells us about things like
classes and methods and size limitations
were code and has strong types
everywhere byte code has five strong
type since lungs floats doubles objects
which makes absolutely no sense in
JavaScript so language is that you want
to deploy on the JVM they can be much
more dynamic than Java much looser types
and different linkage models so not
every language has exactly five strong
types this is a java method that adds
two integers together that our
parameters takes an integer a takes an
integer be it returns to some of them as
an integer you see in three times in
this slide very simple Java program we
know what a Java int is it's a 32-bit
integer it overflows if a and B are too
large and will turn into negative
integer and it's extremely well defined
what this thing does if you were to
force bytecode to put doubles into this
method you will have a verifier because
i would break the java sandbox model
this is the web method that works on
java integers in java compiling it to
bytecode looks like this you don't have
to understand in detail what it does but
it turns into four instructions that
loads the parameters adds them together
and returns them these instructions are
all prefixed with I which means that
they are exclusively in constructions
only work on stainles so that's java
bytecode for you we're already bumping
into trouble now when i'm trying to
implement this thing in javascript which
looks like this i don't see a single int
anywhere a and b can be floats or
doubles or strings or objects or numbers
with over rhythm value of the change
global state because javascript is from
the devil but so so there's no way i can
just compile this 2 to 4 byte codes at
work on int's so so there's really not a
clear answer how to solve this if I were
to do this as byte code of course i can
write an interpreter for javascript and
run it on the JVM and solve it that way
but if we want to solve it the byte good
way it's it's hard because I mean it's a
big problem with the types in the
bytecode and no types in the language
the other problem that is hard is that
you can reassign stuff like the math
sign example is the extreme but you
typically things change at runtime to a
much larger extent in a dynamic language
than they do in a static one
you can replace a function with another
one just by signing something to it you
have call sites to change you have
guards in Ruby you can add fields to it
to a class in the middle of code and
then you probably have to change that
representation etcetera it's a lot of
strange stuff going on which makes it
possible or necessary to replace code
without a code quickly and so it's hard
to swap out code without a code in the
Java Virtual Machine you have a method
call somewhere you pretty much have to
regenerate that class or subclass the
method or like new class loader magic or
build a dispatch table and using vogue
interface for different versions of the
code or whatever in traditional Java to
say the simple thing that we want to say
that a used to call be but now a call
see and if you're programming see you
just like change a function pointer and
you're done and by Theo really didn't
have this mechanism before invoke
dynamic which it now does so this is the
other big problem I mean there are
thousands of problems deploying dynamic
languages on the JVM as byte code but
the two big ones are the loose types and
that you need to slow pop things quickly
all the time so the extra indirection
layer cost us performance can't we work
around it yeah we can be passive and
just wait of course because the JVM is
getting better all the time both the
Jets and the GCS are being improved the
compiler team are looking at byte code
that comes from alien languages like
JavaScript which hotspot really wasn't
optimized for from the beginning and
they learn how to make it run faster GCS
are getting better all the time so just
by waiting you probably get performance
but you can also be active I mean you
you need some mechanism to punch through
this indirection layer to get the right
size holes for whatever you're trying to
accomplish with your language on the JVM
you need the JVM to help you with some
kind of generic mechanism to accomplish
what's trying to do so there are
actually tools these days as of Java 7
to punch through the indirection layer
and with risk of being weirding you out
here I will obviously the invoke dynamic
is my ice pick that's what I use to put
any hole in the interaction layer where
I want it dynamically change type and
that's the most powerful of the
multi-language to
that we've been given it's been with us
since Java 7 and it's been totally
rewritten for 7u40 which came out two
weeks ago or so and it's the way to do
custom data access in the virtual
machine for Nam Java code but a Java
used as well in July they'll talk a bit
about that so to introduce invoke
dynamic what it is it's the first new
byte code in the bio specification since
the beginning which is saying something
of its importance there are several
invoke byte codes that do Java stylee
vocations think all static methods with
invoke static virtual methods with
invoke virtual interface methods with
invoke interface and private methods
constructors and stuff with invoke
special so now we have something called
invoke dynamic which seems to look like
a typical call but it's more than that
because it can implement calls let break
the constraints of Java call linkage you
can have your own custom linkage
completely at runtime you can implement
calls in the GBM in bytecode it look
like function pointers just reset the
target of an EVO dynamic you don't need
to recompile a method and the JVM will
figure that out you can implement custom
data access you can easily book dynamic
for like things that aren't calls per se
and I'll show you some example of this
but the whole point is that when I do
all these things the dynamic language is
want to do lose types changing targets
of call sites you can use invoke dynamic
to do this I will show you how and the
JBL we'll see we'll see what you're
doing instead of that strange interface
based dispatch table that you were
building and can optimize this so since
since not all of you were familiar with
invoke dynamic it's good or they had
these slides that illustrate like the
life cycle of an invoke dynamic bytecode
how it works in the JVM when it executes
sit and what's going on so study they
want to call method a dynamically
because you want to be able to exchange
it with a call to method be later
without recompiling the function you
create an EVOC dynamic bytecode in the
bytecode you're emitting this is normal
not something that Java Sea outputs for
java well we recently started doing it
for certain things in lambdas in Java 8
but for
dynamics the dynamic languages are the
main use case so when the JVM execute
the invoke dynamic code for the first
time it does one call this I only
happens the first time to something
called a bootstrap method which is a
method that you write in java i will
show you an example that sets up a call
site that tells this invoke dynamic
where it goes what should it call what's
my destination target so it calls at
once and the bootstrap method returns
something called a call site which is
from the java.lang invoke package and a
call site represents the position in the
program where the invoked dynamic byte
code is the coal that it does the coal
site and this is the last one don't
worry it contains a target which is an
opaque way of representing the function
pointers where the code goes which is
called a method handle so if I a calls
method be there will be a method handle
to be here in the initial call site a
bootstrap method can look like this it
takes a look up mechanism so you can you
can figure out like where calls go to
you can look up any method anything in
the JDK anything that you generate
yourself it takes name string it takes a
method type saying what does the Java
code look like does it take like two
int's and return a void or whatever and
then you can send any amount to meet a
data mita info from the bytecode where
you're compiling the invoke dynamic only
it's constant at compile time you can
send anything in there so in this
example what I'm doing is I'm asking my
look up can you find me a static method
in this class where the bootstrap is
defined called name which matches this
type and I get back a method handle
which is just a function point you're
going to this method I wrap it in in the
subclass of coal site which I'm free
tube to redefine and return it and there
are mutable call sites which means I can
reset this target in the JVM and there
are constant call sites which basically
means that yeah I will forever return
this thing go ahead and optimize an
inline it now and this is my version of
mutable call site i can put say subclass
immutable call site and put a profile
encounter in there so i know how many
times this method have been cold and if
it's called a lot i can like optimize it
or whatever it provides a very flexible
neck
to manipulate call sites that you could
have before so the mutable call site in
the constant cold sides you can set and
get targets in the mutable one well
because get the target which gives you
this method handle which represents well
this call from a goes to B get be from
get targets you can do a lot of nice
logic with this method handle you can
weave logic into the method handle
without writing any Java code or writing
any byte code you can add a guard to it
that says split this method handling too
if this is true call a otherwise called
be and that in turn will turn into a
third method handle you can filter the
arguments you can box all arguments and
come into it you can print and stuff you
can opt apply any operation and any
arguments by adding a filter which will
give you another method handle which
represents what you were calling with
filters on the arguments you can filter
return values whatever you get back at a
filter for debugging add a system out
print line as a return value filter and
you'll have another method handle you
haven't written any code you just sell
like here's a filter which calling this
existing method you can force method
house to call others by changing the
number of arguments if you have a method
I'm not going to get too deep into this
you have a mechanism called a switch
point that allows to replace a call that
goes from one place to another by Justin
validating the switch point and all
threads will see that so you can swap
out code really efficiently using
mechanism from the java.lang invoke
package and representing methods methods
howls so JavaScript example and this is
my ADD method again and we only know the
parameter types at runtime the compiler
has no idea if this is an int adder or
an object out or a string at or it can
be everything at the same time actually
and we want to result by calling add
with the result of two other methods who
we know nothing about we call add G&amp;amp;G we
don't know what they do they can return
an object they can return an int of
course we hope in the case of JavaScript
that this is an int adder because then
we could implement it very efficiently
with bytecode we'd like to implement it
like this like this java method that i
showed you with like four byte codes
that return in sand work only on ends
but if we're wrong if G returns a string
it might have to look like this to work
in Java I mean this will always work in
Java for everything because it'll take
objects and I've implemented the ad
operator in JavaScript which is well
defined by the JavaScript spec which is
probably 200 byte codes and I'll box and
unboxed I'll do everything doesn't add
one string concatenation whatever so the
lower one will always work but it's
going to be incredibly slow if we do
like 10 million integer ads then then
it's really horrible to try to do it
this way even though it conservatively
will work so one thing you can do in is
to add int guard like turn this method
handle odd goes to the add method in
JavaScript into a combined method handle
a chicks the argument as if they're
interested in tether if there are
objects use the object adders you define
a predicate that chicks two parameters
that they're integers we're only working
with books types here which is another
story it's also slow I'm just trying to
make a point how to create the guards
you create a combined method handle
called add with capital letters using
method hell's Gard with test apply the
int guard to the arguments and if it's
true call a dint otherwise call add
object the guard you can also put a
counter in there and said now you've not
now we've been wrong like a thousand
times stop the garden just call add
objects it's never going to get better
anything can be done by like sub cussing
call sites so hopefully this will call
in a dint alot and we pretend that
hotspot magically it removes all the
boxing's which it doesn't but hopefully
soon we have to be a little bit more
optimistic I'm just giving you an
example of how to weave guards together
may have method handles together with
guards and logic without actually
writing any bytecode anywhere now the
JavaScript example have a square method
you have a multiply method that
multiplies whatever you send in with two
and returns it and you have some
computation that takes the square of X
plus multiplier X which is 2 times X and
typically these are all invoke dynamics
because in JavaScript this is perfectly
possible someone comes in between sooner
or later in the run time Andrea science
multiply to something that does x times
3 instead of x times 2 and compute still
has to work so we immediately have to go
in
swap out the call site to multiply so
the next call to compute what will still
work and do what what what what it's
supposed to do and we can use for
example the switch point mechanism for
that I detected that i overrode multiply
in my name space and I can trigger a
switch pointing validation and magically
this invoked dynamic that goes to
multiply will now go to the new multiply
function hotspot well of course not
immediately optimize this it will notice
soup something changed and then if this
goes on for a while it will profile it
an inline it again so hopefully we'll
take a short performance hit here and if
people don't keep reassigning multiply
all the time we should be just fine this
should be just like in line usually the
multiplication in line nothing else
which is very far from like what jruby
did 10 years ago without invoke dynamic
with interface coal-based dispatch
mechanisms because that's all they had
to work with before invoke dynamic
another use case for the custom data
access that you get is is lazy consulate
in Los initialization consider the case
that you have like one final value which
is a static final thing in Java only you
don't have it but when the runtime start
it could be like a database value that
read from the database a couple of
minutes in but you still want it to have
static final semantics because this
value is calculated once and it remains
immutable and you don't want anyone to
go in and mess around with it you can
solve that with method handles and
invoke dynamic too I can create a new
constant call site from the indeed that
initializes the database basically say I
want a method returns a constant of the
type data with like low data from
databases is the current contents which
is something that that returns a data
class instance and this is actually
faster or more final in the final field
if you if you really read the Java
language semantics carefully this will
this will be final with final semantics
forever even though you initially
initialize it at runtime so it's pretty
cool and Java 8 is that also uses invoke
dynamic I don't have time to go into it
in too much detail but a lot of lambda
delegate errs that use in denial it
didn't before and we finally got the
performance working well there are
thanks to or
wonderful performance team in Russia so
that was the technical very quickly run
through invoke dynamic land part of my
presentations plenty of resources online
and I post links on my Twitter so I'm
going to talk about nazarone a little
bit which is the pure JavaScript runtime
written in java using a VOC dynamic that
we released with we're releasing with
Java 8 so nas one generates bytecode any
VOC dynamics are everywhere because of
the dynamic nature of JavaScript every
getter every sector everything has to be
invoked dynamic and it performs
somewhere in the order of 2 to 10 times
better than right now everything is
better than ryan norwall knows but i
mean it's a really figure it's hard to
quantify it's in jdk 8 it is one hundred
percent ECMAScript compliant which means
it is a JavaScript platform you can call
itself JavaScript and we were the first
in the world to do that I think others
caught up but it's pretty cool that we
managed to do that and we spend a lot of
time creating a well thought through
security model because this certainly
has not been the case for Rhino
throughout the years some exploits there
so nasrin started as an invoker Amik
proof of concept would invoke dynamic be
fast enough what would the use cases be
what would we need why should we do
javascript well rhino is still alive
today after 18 years and the reason for
that is that even though it's really
slow and getting long in the tooth it's
jsr 223 job x scripting api that people
want this hybridization programming that
i said was a major selling point and the
amount of feedback we got him from our
blogs and like on the net and what
people are doing with Nassau and more
than confirms that this actually was a
very good guess people wanted this
hybridized way of doing things which
would be impossible in the native
runtime like v8 or or spider monkey or
whatever they called so NASA would
replace right now for for java 8 and we
will continue with performance work
because it's a lot of work to be done
I'll talk about that too this is Rio
this is nice or new and modern so yes
question no that's all I know and and
it's it's 10 so we'll see what which
Syria takes it it's really interesting
to see what people do with Nas weren't
already I had a few demos but I wanted
time to show them but i think i tella
had a few demos for his afternoon
session there yep and and whenever we
see something cool we posed in with
Mazarin blog so so that's why he picked
javascript basically it's extremely
dynamic everything has to be implemented
by invoke dynamic and we want to replace
right now and there were a lot of JVM
issues serving up alien invoke dynamic
rich bytecode to a JVM that was used to
compiling java bytecode one of them was
in lining hotspot was really bad
originally at inlining and speed was
really slow with invoke dynamic and
compiler engineers worked on it and it
got a lot better still stuff to do
there's a lot of metadata created by
using VOC dynamic things that we need to
figure out and there's an ongoing we no
longer under staff there so we're really
working on getting the final stuff out
of the invoke dynamic implementation we
have full ECMAScript compliance first in
the world this is the ECM a test Suites
the first run we actually passed 11,000
something tests so it's a valid
JavaScript platform this is
embarrassingly to say really old
performance slide against Rhino
normalized and Ryan of the blue bars and
Mazarin is the white horse and the
octane benchmarks were much better now
it's gone back and forth a bit because
we're hybridized with the JVM of course
JVM does stuff and we do stuff and we
kick performance around a bit but this
is just the beginning for performance
for the killer apps like a ver to rjs
when you can access java libs directly
and stuff performance is already
adequate and people haven't complained
but of course like in the performance
benchmark world you always have to find
whatever is the spec JVM 98 of what
you're measuring and for for javascript
it's the octane benchmarks so we are
looking at those two as of August were
actually no longer on the staff of
performance it's been a security heavy
spring that's all I can comment
on which has led to some some lack of
resources in the the performance area
hopefully that is no longer the case so
we're actually trying i went to the Java
language summit and I have some links to
talk i did there later in the slide i
was actually possible to get native like
performance using invoke dynamic
provided to do the correct thing in the
JVM and provide either the correct thing
with your bytecode and me and attila
we've been working on this port for
almost a month now haven't seen much
sunshine and and we definitely think
it's architectural possible now by being
a little bit less conservative with the
type model and currently inside now sore
and then doing a lot of JVM work and
invoke dynamic and we have some
wonderful guys looking at that so
instead of like what is the widest type
i can get away with that's probably a
double for a javascript number doing
things like that to the bytecode you
assume that everything is int and like
figure out a way to take a hit if you're
wrong with the performance this is quite
technical and if anyone is interested i
will gladly refer to my java language
some it slides instead but it's about
changing stuff in the vm intrinsic lying
math functions so they turn into short
assembly sequences looking at having
work dynamic is implemented tweaking the
inlining working a lot with boxing which
is one of the weak areas in hot spot
right now but we did a very initial
proof-of-concept on how we could improve
performance in lazarum with bytecode and
invoke dynamic so we broke out like a
computationally intensive method from
one of the octane benchmarks and NS is
the hottest method in the crypto
benchmark i think in turn it into micro
benchmark in ran nazareth from jdk 8
rhino dated in 34 seconds nasrin did in
10 seconds vatt in 1.3 seconds being a
good native runtime so we added a type
structure like that was more optimistic
assume we're working with ins and
rollback stuff if we wrong and we get
down from 10 to 5.8 seconds so that was
quite a good run we intensify took java
methods in the JVM and turn them into
short well-known assembly sequences
especially in the math package for
additions that may overflow in java but
may not in javascript because then you
have to take a wider type get more than
another second
and looked at the in lining and figure
out who was a bit broken when it came to
certain virtual calls into JVM hacked
about that hack that for about a day get
down 2.5 seconds and and this is just
like a week and a half playing around
the proof-of-concept code yes yes in
inlining means when you call function be
from function a there's some overhead
when you when you execute the call you
have to put stuff on the stack and you
have to store state loose registers like
youth code and then return and if you
absorb be into a pretending it's one big
method instead it usually runs faster
this is not practical to do like it's
not something you should do when you
write code but it's something that the
compiler does for you because it's a lot
faster so it's the mother of all
optimizations basically if you bring
stuff from a nap a call into a larger
method you can do a lot of optimizations
on the combined result the larger method
that actually shrinks it further night
was originally so just by this is like
waking the half JVM hacking so we're
currently doing a performance push to
get this working properly the hardest
part is rolling stuff back when you're
wrong and changing it to a bigger type
but also that it was possible in
bytecode it turned out which if you if
you're interested you can check out my
talk nozzle and war stories from Java
language summer 2013 this July and put
the slides up and there's video on the
media network if you're interested in
detail how to actually reach native like
performance with white cows and invoke
dynamic it's not it's not easy and it
requires some some JVM work but it's
extremely promising that that we got
this far it is quickly from a brainchild
that we had in like june filled three
white boards and got down to it and like
got two guys in the compiler team to
kick around and didn't eat or sleep for
a couple of weeks and then I mean we're
well our way so this is quite
interesting like then then we can speak
of the performance the indirection layer
will shrink and you will still have a
fifth of this code based thing for bars
that I showed you now swearing is being
used for a lot already adequate for a
lot of stuff already avatar Jas
announced this this Java one server side
JavaScript
on the JVM which is a faithful
implementation of the node programming
model which is pretty much everything I
can see without violating various
copyrights I think for writing
enterprise applications in Java and
JavaScript and again java ex scripting
we have seamless integration with
existing Java libraries you have
parallelism from the JVM background Java
threads avatar JS is very small it's
like well and a half Meg's fits well in
the Java EE cloud as well as the
embedded space last jungle one we had a
demo when we ran this on a raspberry pi
it looked significantly different then
I'm not sure if it's still possible but
it totally deployed and worked also Naz
a'ren Nazarene is also like a meg and a
half jar file pure Java this is pretty
nice so it's open source you can check
it out and further proof concept Jim
spent three weeks hacking amita debugger
writing at naz a'ren debugger in la's
horn and showed it that his session
yesterday and it's pretty cool actually
I encourage you to check out the code
there as well because it was really
simple to get it done and now some
reason the OpenJDK it's open source
Hackett's we're working on performance
now at both an asthma and the JVM we
wanted to contribute functionality
testing performance analysis whatever
libraries you have browser simulation
frameworks applications optimizations
and community effort we'd love for you
to check this out and post your findings
tweet to us or email us or check out the
organized room blog where we try to post
more and more all the cool stuff we find
that people are doing I'll just quickly
wrap up with a da Vinci machine project
couple of slides which is the
multi-language effort not just
JavaScript and now Soren but how we turn
the JVM into this polygon platform where
I started can we do better than the ice
pick yes we can we can reshape the holes
in the abstraction layer so let's
continue building our future JVM
basically the da Vinci machine project
the ml vm project is an incubator an
open-source incubator for JVM futures
everyone can look at it everything is
online it contains a lot of code
fragments in the form of mercurial
patches for proposed features and things
migrate occasionally from the MLBAM
development into the OpenJDK this is
wearing
dynamic was born for instance if we have
a standard in the feature release plan
and everything's been discussed in the
jsr and so on things make it into the
the jvm so this is where the multi
language runtime effort is is being done
in the OpenJDK and there's a mailing
list that you can join if you're
interested in this it's a lot of
interesting patches in the da vinci
machinery pose in the best co routines
there's interface injection there's tail
call optimization that's sadly been
lacking for a while with any interaction
there's tuple types that's Method hot
swapping is plenty our plenty of
multi-language stuff there that you
could check out so it's not just invoke
dynamic the JVM is actually involving to
becoming the multi language runtime and
and where we want everyone to help out
with that I'm running out of time so
thank you very much for listening yes
question / me a typical optimization
yeah I have no idea what the status of
that enamel of em right now actually I
would suggest to join the mailing list
and check out and check it out i'm
afraid we haven't I'm afraid nothing
much has happened on that patch for for
a while but I would like for it to
happen should be some scholar guys
somewhere yes
Oh
so how could that be applied to other
packages that's very specific to the
Java collection
Oh
well some some tricks can always be
reused between languages that's one of
the things we hope that this effort will
bring in the future is some kind of
library ification of things for for
multi-language implementers yes yes yes
we lazily generate a lot of methods that
we don't want to like we don't know if
we need using invoke dynamics so it has
many uses it's like a very good Swiss
Army knife for that kind of thing
supporting all these multiple languages
is like a lot of people are starting to
write a different length of the geology
of you yeah like why are you guys like
you know like motivating other
developers to the right other stuff
besides job at so in because the market
wanted it amber evil I don't know I mean
it's a III was actually i was also as I
said really skeptical to hybridize
applications from the beginning but now
I think it's kind of cool especially
considering how quickly avatar jeaious
got up and running with with this proof
it's the node like the server-side
framework that we announced yesterday
and that couldn't have been developed as
nearly as fast as it was if we hadn't
been able to like do JS or two to three
write some parts in JavaScript so I
admit makes me feel a little bit queasy
too I I willingly admit that yes yep
yeah so and you have a port mesh for you
to buy it keep them or not yet we have a
lot of people who like play with your FX
canvases and like pretend the real
canvases and then cool stuff so I mean
contribute no not in the short time no
but the killer apps are things like
avatar yes in the in the beginning I
think yeah you're getting the demos
Attila we can do them offline maybe I
don't have anything on my machine so
check check out the nasara blog you got
like plenty of demos there yeah start
with the blog and what we tweet stuff
and send us email to the list there's a
Nazarene dev list and like ask questions
yes Attila know we might think I'm we're
using the Dinah link library for for
interacting with with the JVM with all
the types and bindings and everything
but we don't have any annotation right
now yes that's wrong no I don't know I
mean that's really the i'm a bit
manipulator you shouldn't be asking all
these like IT industry questions about
scripting languages to me
no choice choice Python Java screen that
is not for me to answer I'm sorry yep
like when I'm writing JavaScript i'm
generally writing browser for the client
right yep in manipulating the Dom and
stuff but can you can you do that with
ashwin like an you have access to the
Dom API and do that because that's when
I notice when I'm writing the most
amount of Java yep I don't see why not
so I come from the low end of Nasr and I
don't do all the high-end API stuff but
I mean these people around you can talk
to about your needs because we're really
interested in hearing about that so
let's find a slackline
we hope we can get get to that point
pretty soon I mean we're working right
hard now to get probably won't be that
for for java 8 but is going to be
significantly faster than is right now
yeah well it's all about shapes so yes
I don't think that I don't think we have
any plans for efficient supporting data
k 7 which is weird because I would like
to lambda phi all the code but I can't
but soon all right I think we're running
out of time and that's one more yeah yes
with with the wet the hybridization
looks a little bit different the way you
look up types in Java and access them
but otherwise it should be fairly simple
to port we took the Java serviceability
agent is written in JavaScript some
reason important to use an asura it was
like half an hour of work so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>