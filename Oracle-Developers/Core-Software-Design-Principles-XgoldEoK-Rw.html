<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Core Software Design Principles | Coder Coacher - Coaching Coders</title><meta content="Core Software Design Principles - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Core Software Design Principles</b></h2><h5 class="post__date">2016-09-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XgoldEoK-Rw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right good morning welcome to the
session on core software design
principles my name is Venkat Subramanyam
I want to talk a little bit about some
of the principles that I find to be
extremely valuable in programming so
talk a little bit about why we should
talk about some of these principles and
then I'll talk a little bit about where
we see them often and then and then the
principles themselves the best time to
ask questions or make comments is when
you have it so please don't wait till
the end any time is a great time for
questions comments just draw me a clinch
and ask a question delighted to hear
what you have to say so most often as
programmers we often hear people talk
about design patterns design patterns is
everywhere we see but I find that it's
really not as a good idea to really
focus on design patterns because it's
quite possible that we may actually end
up using the wrong patterns sometimes
and using a wrong pattern there's no
worse way to really make the code more
difficult and hard to maintain and more
complex when we end up using the wrong
patterns so how do we really get into
this mode where we know what really good
design pattern to use well it turns out
as it was learning design patterns I was
practicing design patterns I noticed
there was a common theme a team of
design principles the underpinnings of
each of these design patterns very
rarely when we learn about design
patterns we spend time on these design
principles but if we do we begin to
realize there are forces behind each of
these design patterns and these often
end up being what are called these
design principles and by asking what
design principle really plays a very
vital role in a context and then trying
to figure out if a design pattern really
addresses that particular design
principle we have a way to know whether
we are really applying a design pattern
that is appropriate for the situation on
hand for example so I find that design
patterns are very helpful by design
principles are even more remarkably
useful than patterns themselves because
those are extremely fundamental now none
of these patterns are really new or
rather none of these principles are
really rather new but they are pretty
timeless I can talk about these for
another 20 years and yet they continue
to make sense and that's one of the
reasons why I want to really talk about
it and when I work with teams of
developers when I do code review and do
a lot of code reviews often time a code
review is not about the
syntax my code review is about oh let's
go ahead and make this code really dry
or let's go ahead and use the single
responsibility principle over here oh
wait a minute we are violating the OCP
or open-closed principle at this point
so these are really good points for
discussion and learning about these
principles makes us more effective in
communicating for example when you talk
to somebody you could tell them hey take
this particular class you can override
this method over here and then implement
this method with the same signature or
you would rather say hey dude let's
apply polymorphism in a similar way when
you communicate with people if you say
let's apply single responsibility here
or let's apply a Lascar substitution
principle here it becomes a nice oh cab
you Larry because you're communicating
more effectively what you're trying to
tell them in terms of what principle
that you want to follow and what
particular problem you want address so
where do we normally see them well I see
that designed to be actually a two-phase
to design approach and I normally split
my design into two phases one is called
a strategic design and the other is
called more of a tactical design a
strategic design is a very high-level
design idea now one of the problems we
run into often time is programmers don't
spend enough time thinking about a
problem and they start coding and that
becomes really hard for us to take it in
a proper direction so in a strategic
design phase I often spend time thinking
about the problem and drawing some
diagrams and classes knowing very well
that everything I do at this stage would
probably be wrong but it's important for
us to go through that notion and think
through the problem element the tactical
design phase I often apply test-driven
development and I start writing code you
user using a series of automated test
cases and those often drive their design
for me well the point I'm making here is
that I see these principles to be
extremely invaluable in the tactical
design phase so when I write automated
test cases and I want to emphasize this
to me writing automatic test case is not
a mechanical process
I'm not sitting there and writing test
cases that's the least interesting part
the main objective is for me to let the
test that I write drive the design of my
code so I would write
deston ask myself what are some of the
design implications of this particular
code I'm trying to tease out by writing
this test cases and during that time
often I bring up the discussions about
some of these principles that we're
going to talk about here so I find them
to be extremely valuable on a day to day
basis so why use them the reason I use
these principles are in general I've
noticed that these principles have
actually made the design a lot more
lightweight more practical more
pragmatic and and more extensible in the
long run because these are quick
indicators of smells in the design and
by knowing these things we can make the
design a lot better over time and of
course like I said I use them often
during the tactical design phase doing
test-driven development and during the
discussions and code reviews we use this
very often so I want to talk about some
really core design principles today that
can be extremely valuable
the first principle I want to start with
is a principle talked about in the
pragmatic programmer known as the DRI
principle so the DRI principle basically
don't repeat yourself is a principle we
often mistake as talking about code
duplication well it is called
duplication but it's not just code
duplication the DRI principle actually
talks about duplication of effort and
not just a duplication of code of course
duplication of code is something we see
quite often but we got to go beyond that
so as an example if we are writing a
piece of code and and the DRI principle
essentially says that every piece of
knowledge in a system should have a
single unambiguous authoritative
representation in the system so it
literally says that every piece of
knowledge well we are knowledge workers
we implement the rules and checks and
balances and logic in our code all the
time and when we are implementing this
code it's our responsibility to make
sure that every piece of knowledge is in
a single unambiguous authoritative
representation so in other words we
shouldn't be duplicating this across
different parts of the system sometimes
code duplication is what we see very
often
very evidently we certainly want to
remove it but it's really hard I
remember this one day I was programming
and I wanted to implement a certain
feature I wrote a piece of code and I
wrote a piece of test and I wrote a
piece of code to pass it and about two
minutes later I thought to myself that
went through other really smooth and
quake which means I probably did
something wrong so I wanted to see what
I just did and I went back and looked at
the code and I was shocked I had just
duplicated the code and moved on I have
to tell you that that was a temporary
insanity definitely I would not have
done this I'd have been conscious right
and it is easy to duplicate code and not
even realize it I realize it often time
and we got to remove it well I was
working with the team of developers and
one guy said to me that every two months
he fixes the same bugs he fixed once ago
and I said oh my gosh does somebody put
back the bug in the code after you fix
it every two months to keep you employed
he said no I wish it was true but we
keep discovering these bugs because this
code is duplicated in so many places I
said how do you feel about it that sucks
and I asked him when you do find this
duplication you take a few minutes and
we you refactor the code and you remove
the duplication right and he thought for
a minute and it said that's a great idea
well wait a minute if we're not removing
the duplication we never have an end to
it so we have to take the time to take
care of this constantly well so one of
the questions I would ask is why do I
want to remove duplication in code
why should I really care about it so the
reason is if you write a better quality
code I'm gonna try to type here so
quality code there's only one reason in
my opinion you really want to do this if
you write a better quality code the
future you if I know how to type future
future you will thank you and that is
the only reason in my opinion right so
the only reason to really write this oh
I know I write a lot of bad code I'm a
human what can I say so but occasionally
I would write some really good code and
when I would look at this code three or
four months later when I'm trying to
make a change to where my proverbial
hand will
walk you know it's race over and Padma
is in the back and say good job that day
Venkat right and that is I think it's
extremely important for us to really
write a better quality code because it
really becomes better over time in the
future and with the DRI principle
there's something we need to keep in
mind it's not the duplication of code
alone but the duplication of effort as
well this is all these things we do for
example what if you change a particular
database schema and then you change as a
result a particular model class and a
few controllers and a few of you we
could argue and say that's life in the
big city what can I do well that could
be a duplication of effort after all
because that change trickles through the
system to give you an example I was
working with a company recently and they
have a Java back-end and their customers
the they have a huge number of business
rules and they would get huge volume of
data that a user would enter and they
would have to do validations on the data
before they accept a particular
processing this was a java-based
back-end system they were doing this on
the Java back-end well the customers
started complaining because they would
enter all this data and then submit only
to receive a boatload of you know error
saying you have violated all these rules
so they wanted to do this validation as
you would imagine on the front end
well the front end programmers who just
sit about two feet away from the back
end programmers said well you guys can
do it your way
we are going to do this in JavaScript
you know where this is going well about
six months went by the rules are
implemented in Java and the same rules
are implemented in JavaScript now for
the next several months what they are
doing is they are fixing bugs they would
fix something in the front end it's
inconsistent with the back end they
would fix something in the back end it's
inconsistent with the front end and
they're sitting there scratching their
head what do we do about it well you
could argue wait a minute these are two
different languages and running in two
different environment so that's not
duplication well in fact it is violation
of the DRI principle because every piece
of knowledge should be there in one in
one place what's the answer well I know
we don't really like code generations
often time but there are times when
maybe
that's the right answer if we can't
represent that piece of knowledge in one
form and generate the Java code from it
and generate the JavaScript code from it
then when we go down to modify it even
though during runtime it resides in the
server side and also on the different
client sides but that source of
knowledge is in one single place and we
will go to one place as a human being to
modify it not multiple locations so that
is why it's extremely important for us
to think about the DRI principle are not
violated that is something we should
definitely keep in mind the next
principle I want to talk about here is
another one of my favorite principles is
the yagna principle the yagna principle
stands for you aren't going to need it
well I change this principle just a
little bit because when I go to
developers and tell them you're not
gonna need it they get apprehensive so I
normally put the little yet in the very
end I say you're not gonna need it yet
and they are like very happy now okay
how can I do this tomorrow if that is
the case and then just say the same
thing the next day so the point really
is we're not going to need it and if you
ask me what do I do for a living these
days unfortunately I spend more time in
removing code than adding code so when I
walk into companies and when I leave
they have a lot less code than used to
have in the beginning we do so much of
coding that is really not necessary and
we can get rid of so many pieces of code
I was doing code reviews this morning
for example I was looking at piece of
code and saying you don't need this you
don't need this you don't need this
remove remove remove remove and when you
are done removing all of that you have a
lot less code now why do I want to write
a lot of less code well the reason is
very simple this is what I'm sure you
would agree I define as the experience
of a software programmer what is the
experience of a software programmer you
get somebody who's fresh out of school
at 8:15 in the morning you ask them
where they are going they'll tell you
I'm going to work to write a lot of code
and then wait for 15 years as the same
person where you're going at 8:15 in the
morning they're going to say I'm going
to work so I can stop these people in
writing a lot of code right and that is
what experience really is we begin to
realize that the more
Corby right the more difficult it is to
maintain it hands down the code you did
not write has the fewest number of bugs
in it we don't have to maintain that
stupid code if we don't write it so we
want to really minimize the amount of
code B right so let's not implement
features that are not important let's
not implement stuff that doesn't
contribute direct value you know what if
it is really really needed it can come
in later on and and the the courage to
postpone that to a later time is
something extremely important so to
minimize it and say I don't need this
right now I can come back to this later
where they need it is is is something we
should really try to do as much as we
can but one of the principles I want to
talk about now is a principle we all
have heard about but I firmly believe
that most of us are confused about this
principle and the reason we are confused
about it is it's really hard to put our
fingers on and say what that really
means well we say every piece of
knowledge should have
I'm sorry every code should have a
single responsibility well and then you
hear people tell you if your code if
your function takes multiple parameters
even two or if you have an if statement
in the code then it's a violation of
single responsibility and then I look at
that and say really then I can't write
any code at all right so it really
confuses me when I hear things like this
what does it really mean by a single
responsibility principle and and it
turns out that we are really looking at
this very wrong so let's talk talk about
this for a minute now we all have seen
long methods let me ask you this
question
raise your hand please if you do believe
in this who here thinks writing long
methods is a great idea
not a single person raised the hand
usually there's one person and I would
ask them why and they would say because
it gives better performance not that
they are wrong but the last thing they
were right is when Nixon was the
president a lot of things have changed
since then right so that's not really
true anymore okay great but let me ask
you a different question
how many of you have seen long methods
at a code at work have you seen long
methods
hands go up almost every hand goes up
right so this is called a cognitive
dissonance everybody knows not to do
this and yet there are long methods at
work and I know why that is the case you
guys didn't do it because I asked you a
few minutes ago and you said no I don't
believe it so why would you write long
methods but the sad story is the people
writing long methods are at work today
making those methods longer as we speak
right so what do we do about it so we
know this is not a good idea nobody here
believes it yet we see it well let's
talk about this for just a minute if you
will let's talk about long methods so we
all can agree long methods are evil but
why is the question let's think about a
few reasons so fire away what are the
reasons why you think long methods are a
bad idea
please go ahead just speak up oh but my
goodness what a wonderful thing hard to
test you have this very long method the
number of permutation and combination
through which you have to go through it
becomes almost impossible to test it I
eventually you say you know what release
this in good faith if it doesn't work
your users will tell you right so it's
really hard for us to test the piece of
code we kind of give up on it what are
the reasons fire away oh sweet so code
duplication in fact this is an
double-edged sword
you have this long method and you look
at this long method but you're looking
at the right in the middle it's like
Dare right and that metal is really hard
- my hands are frozen here sorry
so hard to reuse so it's very hard to
reuse this piece of code and because
it's hard to read use what do you
normally have forced to do copy and
paste it somewhere else making that
other method longer as well right so it
leads to duplication leads to poor reuse
as well yes sir how difficult to
understand so let's talk about that for
a minute
the people who are hired to maintain
this code they are not called
programmers they're called victims right
so you'll get hired and you're like why
me
I was a hired on this project so let's
talk about this for a minute what's the
longest method you have seen throw a
number at me yes sir
800 lines of code 1,000 this feels like
it this feels like a really bad action
isn't it
I had a 6,000 anybody else can beat it I
was in that works Belgium and right from
the darkness of the room came a voice he
said 40,000 I'm like where do you work
in hell and and he came back to speak to
me and I could see in his eyes he was
not lying so this is hard stuff isn't it
so anyways it's really hard to
understand how do you maintain such a
piece of code any other reasons yes sir
Oh bugs everywhere right and and fails a
lot
it is very brittle and it becomes really
messy other reasons too many verbs you
said okay
so a lack lacks cohesion right so
cohesion you're participating in another
word cohesion is where it is not focused
and does too many things and also one
more thing is normally long methods
don't come alone they invite other
things to the party right
so as highly cohesion and between these
two you can see how this is a diagonal
opposite of good design good design
wants high cohesion and low coupling
long methods are the diagonal opposite
to it one more reasons yes sir
oh we're difficult to add difficult to
change and add features whatever that
you do you don't want to be touching
that it becomes a very brittle we can
keep going with this there are so many
other reasons so the reasons are
extremely clear but yet we see people
write long methods even today come on
this is 2016 we can be doing this right
in this year right so I have one last
suggestion for you
you know this person at work who writes
long methods who is still at work today
so how do you
since that person don't write long
methods I'm gonna give you one last
suggestion to try so go to work on
Monday don't speak a word just sit down
and start coding this person who writes
long methods comes to you and says hey
how's it going how is your weekend I
mean you could tell them how your
weekend was you could tell them hey the
weekend was great I went to the movies
on Saturday went to the park on Sunday
but don't say that instead say oh the
weekend at seven o clock on Saturday I
got in the car turned on the ignition
pulled the car out took a left turn took
a right turn when two kilometers took a
right turn went to the stops and just
keep going like this for a while after a
while your friend says have you gone mad
you say no I thought I'll tell you how
my weekend was like the way you write
code right so the point really is when
you talk to when you when you talk to
people how do you talk to people you
don't tell them about every single step
you took yeah instead you tell them
major knowledge chunks I went to the
park on Saturday Sunday to the movies I
could ask you or really what part did
you go to I don't care about the movie
after all oh the wandering of the Main
Street really is it family-friendly oh
yes well what are the activities notice
what what what we just did we started
drilling down into one knowledge space
completely ignoring the other so it
turns out if that is why we talk to
people guess what we are doing in
writing code we are communicating to
fellow developers so when you write good
code you are telling implicitly I love
you I like to work with you right and
that is the reason to write a better
quality code is because we care about
people that we work with so as a result
that's a way we communicate so the next
question is okay we all agreed long
methods are bad idea let's give this a
try I'm gonna say 200 lines of code is
long do you agree okay how about a
hundred I said I get mostly as some said
no fifty a few were yeses are twenty
you see this kid keeps going down and
you if you say 20 is good the Ruby guys
are like are you silly
right and then you say 8 and the closer
guys are like are you guys out of your
mind
right so there's no way to compete with
this lines of code so it turns out yeah
the lines of code doesn't help well
here's another idea somebody said Oh a
function is not long if you can show the
entire function in one screen and the
minute somebody heard this they said oh
really what's your font size so there is
no way to help this right so how do we
go about solving this well it turns out
we are totally looking at the wrong then
the word a single responsibility
principle and the word long functions is
really not about the length of the
functions after all we had just got it
tore wrong we keep counting the number
of lines of code and we get confused
about it it is not the lines of code
that makes a function long it's a number
of levels of abstraction in a function
that makes a function really long so
what you really want to do is slack no
no no not physically we're not talking
about doing this to the fellow
developers but to think about the so
called slap or the single level of
abstraction principle so the single
level of abstraction principle says
every function that you write must be
focused on a single level of abstraction
this is why I love metaphors if you're
asking me what did I do over the weekend
went to the park went to the movies is
at a single level of abstraction I'm not
telling you anything about the park I'm
not telling you anything about the movie
and in the middle I didn't mix up mix
about the little flavor that I admired
on the way so the point really is to be
focused on a single level of abstraction
and when we do then we are interested in
that level of abstraction we can dig
into it this also answers a lot of times
to me the question about how small a
function should be I don't want too many
small functions well the answer really
is what is your level of abstraction and
if you grow by abstractions it
comes a lot easier well the realization
it came to this was not too long ago
somebody looked at a piece of code and
they said well this particular function
is reading all this data and instructing
this data to be displayed and I would
argue this is not a single
responsibility principle and I was like
well why would you say this and they
said because it's two responsibility and
that's when I begin to realize we got
this totally wrong we really need to
think about the abstraction and to me
that function was phenomenally good
because it focused on a single
abstraction I am here at my level
getting the data and sending it where it
can be displayed I that's my level of
abstraction I'm not getting into any of
those details anymore at this time is
extremely important so having said that
we really want to think about the slab
principle and then worked with the slab
principle as much as we can and for this
we want this to be using what's called a
composed method pattern so when we write
the code the code becomes a nice story
to tell and you're reading the code and
it tells you step one step two step
three step four it becomes a lot easier
to read and understand what the code is
doing and it becomes a story telling and
that becomes very easy to work with it
and that's basically what we want to
work towards so once we talked about
this let's move on to the next principle
here which is the open closed principle
this is one of my favorite principles
created by Bertrand Meyer and he said
that every software module it could be a
function could be a class whatever it
could be he says every software module
should be open for extension but it
should be closed from modification well
that looks a little puzzling how could
it be open to do something new and
different but it's closed so that you
don't actually change it well that's
where extensibility really comes in so
in other words if a code is tightly
coupled it becomes really hard to extend
it and make changes to it in the future
so we want to really move towards a low
coupling let's look at an example real
quick to see what this really means over
here so I have a car class extremely
simple example and I have a car with the
iana engine and I'm just printing out
what that car is
whole lot of code right now it prints
the pier and the engine in the bottom
for us that's what you see right here so
that's great so far very easy well
moving a little forward what if I really
want to make a copy of this car so I
could say car du equals new car and we
could say car two and then of course I
want an output car to this of course
should be car one so I want to output
the car - well Java immediately says no
we can't do it why not because Java does
not have copy constructor now why
doesn't Java have a copy constructor
well because C++ gave copy constructor
and it really caused a lot of problems
so Java said no more cons to copy
constructor for you so it doesn't have
that well so how do I make a copy of
this particular object after all well we
could use a clone method well clone
method has its own problems we'll talk
about that in just a few minutes so I
want to really write a copy constructor
for this particular car so I'm gonna say
create a copy constructor we'll say
other and what am I gonna do here I'm
gonna say here equals other dot year
after all I want to just set that into
the year of the car so I'm gonna say in
this case this is going to be other dot
here well what about the engine well
engine equals to clearly don't want to
say other dart engine so it's a new
engine and I'll say other dart engine
over here to create it well okay so
that's great so far we can go ahead and
create those two and we can use it great
but then the question is what about this
one well that doesn't have a copy
constructor so let's go back here and
say here is a copy constructor for you
and it really is not doing a whole lot
in this example which is just fine for
now our purposes so we made a copy of
that
well now what happens when we go back
and run the code you can see that in
this case that we have two cars oh wait
a minute
so I wanted to really emphasize it's
private okay so in this case of course
when I go back and run this you can see
that it does give you that two different
values for the hash code and we know if
the hash codes are different we know the
objects are different if they are the
same then the objects could be different
but we don't care about it because it's
not the same okay so in this case of
course we proven that these two are two
different objects where
what could go potentially wrong let's
say a few months goes by and we decide
to implement what's called a turbo
engine well that's great we have a new
little turbo engine on over hand what
are we going to do with this turbo
engine let's implement the turbo engine
right here and of course that implements
the engine interface we won the
constructor to be written we want the
copy constructor to be written we don't
care about the to string method the one
in the base is good enough for us so the
question is will the compiler I love you
to compile and run this code and the
answer is yes because turbo engine in
Hertz from engine and car is expecting
an engine but when you run this code
unfortunately notice we got a little
cheated here the first car has a turbo
engine but the second car only has a
engine so this is gonna be really a
vexing problem so what do we do to fix
it well I've got a really brilliant idea
to fix it I can come in here and I can
quickly say if the other dot engine is
an instance of turbo engine then I can
do the following right and I can say
else right here oops so if I can say
else and then I can do the rest of the
code right there well okay that's one
approach so it's got to be engine equals
to new turbo engine and then this is
going to be a turbo engine and then of
course is gonna be other dart engine so
we can go ahead and write it that way
now of course if I go back and run this
little code you can see that worked so
what do you think of this idea brilliant
wonderful are you're laughing well you
should always have a positive attitude
okay so think about this as job security
right because every time we add a new
type of class we come back and you know
change it I'm sure you have seen your
share of instance often code around
right and of course the only thing that
can be worse than instance off is that
instance off is long and duplicated
everywhere in the code right then it
becomes double jeopardy well clearly
this is not going to be fun what do we
do well Java says well why don't you use
a clone method so we could say other
dart engine is equal to other dot engine
engine
and then we could say a dart clone and
then we would do the cloning well it
turns out clone has a problem in itself
if you're curious why clone is a bad
idea take a look at effective Java they
tell you not to use clone so I won't go
that route we don't want to focus on
that right now
so I'll write my own clone method to get
around the real problem is the way clone
is implemented within job are not that
clone is bad all the time so what am I
going to do what I'm gonna write a
public over here engine and I'm gonna
write a clone method and then of course
in this case what do we do when it turns
out we can actually make this extensible
by using a clone method but like I said
the javis clone is not very effective so
what can I do well I can make the copy
constructor protected and then I can
simply say return in this case new and
then I can say engine this and then I
can turn around and call the protected
copy constructor in a similar way what I
could do is in the turbo engine I can
make the copy constructor protected as
well and then implement the clone but in
this case return a turbo engine instead
of an engine a little bit of a
duplication of code but there are ways
to remove it if you're interested you
can dig into that more
but the point really is we have removed
the duplication quite a bit do move the
Messier quite a bit by following the
open-closed principle so if I go back
and run this code you can see oops no
didn't see that okay so if I want to go
back and try this code obviously I want
to set this here so other dart engine
dart clone I'm gonna clone this engine
and then set this into this in this
engine not the other engine for other
engine okay so as a result you can see
in this case you can you have the copy
but the beauty of this code would be if
a word I introduce let's say a piston
engine tomorrow and I'm going to now go
back and create a piston engine and then
of course in this case I have a copy
constructor I also have a constructor
for this engine well thank goodness I
don't have to make any further change I
want to go back and run it now well did
I do this properly the copy and paste
doesn't help so in this case of course
that's the duplication we want to remove
so return oh the clone method of course
so here's the clone method and return a
new in this case piston-engine and then
this so I'll leave it as a homework for
you to remove this duplication right
here so you don't have to really use the
clone at all a little clue is you can
reflect use reflection to do that pretty
easily and keep the code right so the
beauty of this is if you want to write
this you never have to implement another
piece of code now think about this for a
minute if you ask a programmer what kind
of design pattern they would use they're
gonna throw answers that you like
abstract factory factory method
prototype pattern well okay but why are
we doing all of that we could take
several sentences to explain it or we
can fire back saying we want to follow
open-closed principle right so all these
factory sorry all these creational
patterns have one underlying design
principles behind it and that is the
open closed principle we want to make
the code extensible so it becomes really
easy to talk about this and see whether
a pattern is useful or well so open
closed principle says that a software
module doesn't have to change physically
in order to be extensible well that's
great so far but is it true that then we
should never use things like instants
off well the short answer is it's
perfectly okay to use instance of as
long as that piece of code doesn't have
to keep changing every time we introduce
a new class in our hierarchy so as long
as the change so you want to go after
the reason to do it which is to minimize
change why because after your system
constantly changes and and that is one
thing we really got to keep in mind and
we want to minimize that change over
time so that the modules can change
independent of each other and you don't
want the change to ripple through well
that's great but the next principle is
also a favorite principle for me but
this comes back to really focusing on
one area which is inheritance so let's
carve Barbara Liskov wrote this
principle and she said that we should
really use inheritance only when we
really mean substitutability inheritance
is one of the most misused
concepts in programming and bottle
Escoffier says do not use inheritance
unless you really mean to provide for
substitutability and she says if your
intention really is to reuse a piece of
code then use composition or delegation
and don't use inheritance so let's think
about this a little bit further so
inheritance so should a class let's say
shoot up Class B inherit from a that's
the first question so the answer to that
is if you want an object of B to be used
wherever an object of a is used then use
so then use inheritance so so this is a
very stringent rule if you really think
about it so if you want an object to be
to be used wherever an object of a is
used then and only then use inheritance
so on the other hand if you want to use
an object of object of a in the making
of the object of B well then use
delegation so the question then is
always why why shouldn't I really do
this why should I care about emphasizing
this well the reason is actually fairly
simple to think about and the reason is
substitutability increases the burden on
us so if you are a user of an object
well if you're a user for an object
there is nothing to bind you with the
respect to that relationship you come in
you use it you leave you're happy but if
you're inheriting from a class you are
taking the responsibility even more
whether you know it or not whether you
like it or not and that responsibility
is that every advertised so advertised a
behavior of the base class should be
haunt honored so bite so honored by the
derived class so that is basically one
of the
things you take on on your hands when
you do this so every are advertised
behavior of the base class should be
honored by the derived class whether you
don't have an option whether you want to
do this or not it's forced upon you and
you have to sit there and split your
hair and think about various different
permutation and combination through
which this base class could be used
otherwise we could get into trouble so
this leads to something even more so I
derived the class so this goes on to say
class I'm gonna move this a little up
here so that Class A service should
require no more and promise no less than
the corresponding service of the base
class so you can see that it keeps
increasing the burden on you so now the
minute you come in to write an
implementation it doesn't matter what
you have internally from an external
view I should not be able to tell the
difference between your base class and
your derived class if I can tell the
difference between them you're failing
will scoffs substitution principle so
this is a lot of burden you have to
carry when you use inheritance and when
you think about it that way you would
not want to really use that much of
inheritance let's think about this a
little bit further we all can agree upon
and say inheritance is a bad idea don't
use it as much be very selective use it
only for substitutability
and and so we can you know emphasize
that so use inheritance only for
substitutability so and not for
reusability so reuse should just really
use delegation inheritance should really
be substitutability
now here's one problem to think about
I'm sure everybody in this room would
read more and think about this more and
we all will come to the conclusion
absolutely inheritance we don't want to
use it I often we definitely want to use
delegation and then we close our
articles we go back to Java IDE what are
we going to do use inheritance right so
why are we going to do that well the
reason is actually very simple there is
so much force in front of us do you do
the wrong thing this is
the viscosity so let's think about this
for a minute suppose I have a class
called
a and I have a function let's say public
void f1 doesn't matter what these
functions do and public int f2 and I
have these two functions now we are told
right now
class let's say so the given problem is
write a Class B and they want you to
have function f1 f2 and f3 where F 1 and
F 2 are the same functions in a so
obviously we can write f3 very quickly
not a problem
then comes the temptation hey I have
this f1 and f2 look how cool this is all
I have to do is extend a isn't that
wonderful
I didn't have to do anything well wait a
minute yes you didn't have to do
anything but now you're carried a burden
with you everywhere the object of B can
be used it can be used the after B can
be used you have to comply to the
expectations of a now and that was not
your intention
now you're forced into it well how do
you solve this problem one way to solve
this problem is to say a object equals
nu a and then you write public over here
let's say void f1 and then you can say
object Dart f1 and then you are going to
say public law into f2 and then you are
going to say return object art f2 well
if you notice here now we are no longer
violating the Liskov substitution
principle because we no longer are using
inheritance because we didn't mean to
use it in the first place but there is a
bit of a bad news here you had to do all
the typing and you had to write all that
method well ok what do you do to solve
the problem I got two answers for you
you can get somebody who is really fast
in typing right so they can type it away
and walk away you could do that or you
can use an IDE it appears that this
problem is so prevalent that there is
actually a refactoring facility called
replace inheritance with delegation go
figure
so you can just click on that and before
you could blink your eyes it can do the
work for you so you can pretend like
nothing happened so the point really is
you can do either one of those
but unfortunately though we traded one
for another didn't we
we don't have Liskov substitution
principle problem now but guess what
design principles are being violated now
that's correct beautiful thank you a dry
principle we had to duplicate our effort
tomorrow you come and add a method to a
you got to change be potentially or even
worse you change the signature of a
method and a this.b isn't dead in water
now you got to come back and change it
right so that's one problem now you
gotta ask yourselves okay now I'm stuck
between a rock and a hard place should I
violate Lascaux certain principle or
should I violate the dry principle my
answer is if you're given a choice like
that you always want to violate a
principle that affects you and not the
user of your class because if you
violate Liskov separation principle the
user of your class is gonna complain to
you and if you violate the right
principle you complain to yourself the
second one is easier to deal with right
so that is basically the yardstick I use
is to do it but of course ideally it
would be so cool if we don't have to
violate either one of them would it be
cool let's see how we can do this this
is where languages can come back and
help us so here I have a class called
worker and the color class worker has a
method called work as you would guess
this is a groovy code and I'm gonna say
working right here so let's make sure
this is actually working so let's say
define worker equals new worker and then
of course work heard art work let's just
mix your result set up and working
nicely so there you go that's working
but I'm gonna create a class called
manager as you would imagine manager
does absolutely nothing so in this case
of course this is just a class I have in
front of me but I'm going to say define
a bob equals new manager and I'm gonna
say Bob dot work no that's the alien
concept for a manager right but this
manager is absolutely smart this manager
says I can do it and what does the
manager do the manager quietly walks
over here and saves worker and then in
this case let's call it as Vic
is equal to new worker so we have
created a little worker object but good
management as I said is very smart so
the manager says hey you worker I Got
News for you and he simply says delegate
so you can see in this case that manager
is getting the work done but you know
who's really doing the work so the point
really is you can use nice delegation so
as a result for example today if you go
back here and say you know create a
report and if in this case you have a
report well notice we're not violating
the DRI principle are the open closed
principle anymore because we can say bob
dot report and we got a report flowing
out as we can see right there very
easily from bob so this gives you an
idea about how we can use nice
delegation model I believe there is a
project called project Lombok which does
this for Java as well so you could do
something like this in different using
annotations if you will you could
benefit from something like that
so the point really is you want to
really remove these kinds of effort and
and by using some amount of effort you
can try to you know address more
principles along the way and make things
better so I could give you a few
examples of this let's talk about a
violator a good where LSP is honored and
where LSP is violated in Java you cannot
make a method protected or private in
the bay in the derived class if it is
public in the base class in other words
you cannot restrict further well why
let's go solution principle in Java you
cannot take a ArrayList of base and you
cannot pass array list of derived where
an ArrayList of base is expected so if
you have ArrayList of fruit in a
function and you want to pass an
ArrayList of banana it won't let you do
it
why let's graph solution principle these
will really give trouble when you go
through that kind of substitutability so
it doesn't substitute a collection of
derived from the collection of base
thankfully and there are ways to change
those things in different languages we
call this covariation covariance and
contravariance customization and we do
this because the scoff subscription
principal rules in these areas so
language design
often pay notice doulas Casselton
principal at least if they are awake
just to give you an example of this
there's a major violation of Lascaux
supreme principle or at least was in
java which we are trying to quietly you
know remove and that is the stat class
well remember what a stack is a stack is
a LIFO elastin first out but
unfortunately though if you notice a
stack class in Java what does the stack
going to do well if you look at the
stack for a second let's go to the code
here nota stack extends vector well wait
a minute a vector you can insert and
remove elements anywhere you want to on
a stack though you can only put on the
top and remove from the top what's the
consequence of this the consequence is
this the intention here is to reuse a
vector in the making of a stack but
inheritance what does it do well imagine
for a minute he has a function that
works with the vector he inserts and
removes elements let's say he has a
function that also rosie's a vector and
what does he do he takes the vector and
passes through the gentleman next to him
well what am I gonna do I take a stack
and I send it to him what does he do he
says hey nice vector and he passes the
vector down and he inserts elements
arbitrarily then I come back from the
method call I look at the stack and say
how's it going and the stack is limping
and says don't ever do this to me right
because it's it's invariant was
completely violated right and that is a
big problem because the stack was not
intended to be treated as a vector so we
should avoid kind of situations like
this violation of this Constitution
principle well the last thing I want to
talk to you about quickly is the
dependency inversion principle I would
say this is probably the principle we
use the most when we program especially
if we ever want to be couple and also
when we do you know test-driven
development because tyranny becomes
extremely hard when we deal with real
dependencies so we often decouple so I'm
going to explain a dependency inversion
principle but even without writing a
single line of code by giving you an
example I'm going to give you an example
of my first trip to Norway back in 2001
I I'm there a lot these days to teach
classes but that was my very first trip
teacher Java cores in 2001 so I've
learned in the in on a Sunday and I go
to this hotel and and I was kind of
surprised this hotel didn't have any
coffee machine so I went to the
reception and said hey there's no coffee
machine in hotels I stayed they always
give me a coffee machine where I can
make really bad coffee how come I can't
you know troubled her so much that she
gave me her coffee maker and said keep
it with y'all take it at the end of the
week so I was very happy now I have
coffee machine well it was time to sleep
I'm a person who goes to bed pretty
early I'm early to bed early to wake and
I wanted to go to bed and I looked
around this was this time before the
cellphone days and laptop DS so I'm
about to go to bed I look around I was
in a state of panic
there was no clock in the room so here's
the poor venket looks around them there
is no clock in the room so I went
downstairs and she rolled her eyes and
said what's it now and I said what's the
problem with this inner region what else
maybe there's no nothing that starts
with the C no coffeemaker no clock and
and she looked at me and said tell me
why you need a clock after all for God's
sake and I said well I need a clock
because by my bedside I have a clog and
early in the morning it makes its a
horrible noise I can never sleep again
for the rest of the day I want a clock
to wake me up
she looked even more confused and said I
don't understand you would need an alarm
to wake you up not a clock I said don't
get me technical on me lady
right so the point really is here she's
right I need an alarm not a clock and I
said yeah you were right I need an alarm
not a clock but I don't have one and she
said did you turn on the TV I said oh no
no I don't watch TV she said this week
you will go back to your room and turn
on the TV so I went on the TV this was a
novel idea to turn on the TV so I find
that remote and I click it on and the PD
says welcome to this hotel vent kit this
is you were alarmed to Ana was very
fascinated by this that there's actually
an alarm in a TV once in a while it's
good to turn on the TV so I said this is
awesome but you've got to keep in mind
I'm a TDD guy I'm not going to trust the
TV that is gonna do the alarm so I set
the alarm for about 2 minutes for later
turned it off and I went to brush my
teeth came back and guess what it's on I
said no no I want to really make sure
it's working so I said it for another
minute but I noticed a bit of a
discrepancy
here don't ask me why but I changed the
channel and I turned it off but it came
back to CNN anyway just noted that down
maybe it's some day I can come back to
test the TV well the point is I was
gonna command this just imagine this I'm
in this dark room and I sleep really
well I never have jet lag I'm sleeping
really well and now I hear a voice I'm
in a dark room can you imagine waking up
in a dark room and the voice keeps
increasing now I'm like where am i I
don't remember where I am why is
somebody in my room why are they talking
and I get up and I was in a state of
panic because in front of me in the TV
there's a guy with a suspender hello
this is Larry King life can you imagine
waking up to Larry King life in the
morning well evening here morning there
well I was in trouble I turn off the TV
after have to find the remote and I
thought to myself I gotta side this back
into this anyway right so I thought
about this and the Norwegian hotel clerk
taught me about dependency inversion
principle she said
well rank it you've anchored concrete
human should not talk to a concrete
class called Clarke Venkat should really
talk to you what an alarm she said well
that's great so it turns out that the PV
was a wonderful implementation of alarm
well you just saw this here a UML
diagram in notepad okay
so right there is the alarm
implementation from the TV as you can
see and that is basically what I did
well you as you can imagine I'm not a
big fan of that kind of alarm so that
night I got down to implementing my own
alarm in my computer and a computer
could be an alarm well these days my you
know smart phone is my alarm and you can
come up with several different alarms
and you can switch between them well
there's your dependency inversion
principle and of course if I want to
make sure that things are working fine I
could even use a marked alarm as well
into this mix and we can use any one of
those for our test testing purposes as
you would imagine so that becomes a lot
easier to work with
so dependency inversion principle is one
of the things we use quite often I
definitely say
that there is something interesting and
weird about the dependency inversion
principle and the open-closed principle
I often say that they kind of play like
a good cop and a bad cop so oftentimes
I'm trying not to violate the
open-closed principle but I oftentimes
end up using the dependency inversion
principle you know in some cases so I
often I'm trying to avoid violating the
open-closed principle on the other hand
really favoring and using dependency
inversion principle when I do automated
testing I use dependency inversion
principle quite often when I'm trying to
switch between multiple service
providers I used to put it in motion
principle when you are using frameworks
or tools that provide dependency
inversion or IOC you are literally using
dependency inversion principle so this
is probably one of the most widely used
principles ever that we use well I did
talk about a few principles and you I'm
sure heard about this thing called the
solid principle somewhat it's been just
a minute on this
well the solid principle really a single
responsibility principle open-closed
principle Liskov sufficient principle
and the dependency inversion principle I
quite did not talk about this I in solid
it stands for interface segregation
principle and I often feel that that's
really another rebranding of cohesion
except the interface level but I also
talked about the DRI principle and the
yagna principle maybe you can call this
as dye sold principle than solid
principle if you want to call acronyms
with it so solid principles are nice but
I think there's more to things than just
being solid there are other principles
that we need to think about and also a
different twist on some of these
principles because we often kind of look
at these principles but they don't quite
you know connect we don't connect to
them but thinking a little deeper about
them can be very helpful to find out
what those are like I mentioned earlier
I use these principles all the time
in every day of design activity every
day of code reviews every day of
communicating with software developers
we use this vocabulary of these design
principles and that helps really well to
write a better quality code as well
these principles I feel are rather
timeless when it comes to what we can do
and that's one of the reasons I use them
very often I hope you do too and I hope
that you found this useful thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>