<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Create Effective Tests or Create Excuses — Testing the Java EE Way | Coder Coacher - Coaching Coders</title><meta content="Create Effective Tests or Create Excuses — Testing the Java EE Way - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Create Effective Tests or Create Excuses — Testing the Java EE Way</b></h2><h5 class="post__date">2018-04-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/z-ABmJZPsnA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">times it's a little bit well it takes a
little bit too much time to maintain
tests so for example if you change
production code and then you have to
change your test that this it's kind of
unproductive that this kind of like
takes too much time or if you think so
ends up ok ok so let's see we're gonna
change that hopefully in that session so
I am very welcome I'm very happy to be
here
my name is Sebastian I'm a Java EE
consultant author and trainer I'm a book
author and a wrote last year wrote a
book on modern Java EE applications I'm
from Germany
so I'm German and this is my second trip
actually to India I've been in India
last year and now there's the first time
to Bangalore and I'm very happy to be
here so there's a little bit about
myself I do a lot of Java Enterprise
things a lot of enterprise and
development and I hire I help companies
to improve their proof to enterprise
technology that is my book that I wrote
last year about architecting modern Java
EE applications or how to write Java EE
applications in a somewhat modern way
and to show that is indeed possible to
write well modern Java EE and she a few
more things about myself so don't worry
there won't be too much slides here I do
some consulting work some workshops and
training for enterprises on topics like
this for example for enterprise testing
how to do that in an effective way can
we visit my website if you like and yeah
what about testing testing applications
so just a few things in advance there is
some kind of testing pyramid if you know
that so about unit tests and integration
tests end to end test on the answer on
and so forth and first of all what I
want what I want to focus on are
end-to-end tests that means testing an
application that is running in ideally
the same way as a would run in
production and testing our business
logic there whether that application
behaves in their way as expected right
so we will not focus on unit testing or
tests like testing a single component
whatever that is single class or a
couple of coherent components no we want
to test our application in the same way
as it would run in production for a
couple of reasons and I want to focus on
that first and I want to show that show
you how that is possible in a in an
effective way and especially if you use
containers such as docker and container
orchestrations that such as kubernetes
because how these technologies will help
you they're doing all the setup doing
the definitions of how your environment
look like and help you to while
construct these tests in a maintainable
way all right so what I have here is an
application that is deployed to
kubernetes cluster or actually to
applications that is called coffee shop
so maybe you know I like coffee so this
is a Java EE application job e7
application actually two of them
that will run in while in a kubernetes
cluster that cluster doesn't actually
matter but we have two applications and
we are writing that coffee shop
application or actually I already wrote
it and now we want to test that from an
end-to-end perspective and how that
looks like is that we have our coffee
shop application that's talks internal
to your database and while a user
connects to that application via HTTP
all right and now this will be a little
bit too simple because then we what we
would do to test that we we write an
external test in that test we connect by
HTTP to that application see what it
what it does see what the response looks
like and that's it to make it a little
bit more complicated that application
should now also communicate with another
with a second application right and that
second application actually will be
communicated with in an asynchronous way
so not immediately otherwise that would
also be kind of easier to test we send a
request
afterwards we get a response and then
the second system will be involved but
now this will be done in an asynchronous
way so actually we have a so-called
coffee processor that will be will talk
to in an asynchronous way so what we do
is as a user we create some coffee
orders we want to order a new coffee at
our coffee
shop right and then it takes some time
to make that coffee there is a second
system in wolf that is called the coffee
processor and that will process our
coffee while asynchronously so the user
actually afterwards have to come back
and then ask for the coffee now this
creates a certain challenge for the test
because then while we have to test if
the asynchronous C works right if that
system later on was called in a correct
way the second system so this is one we
want to test right and any questions by
the way if you have any questions like
any time just just feel free to ask
otherwise I'll show you just briefly
some coats and quick walkthrough to that
that is the first application we only
will have a look at that application
that we want to test so like in unit
tests we focus on one unit one class
mostly everything else will be marked
away similarly we now want to test our
coffee shop example not anything else
but our coffee shop application how it
would run as it wouldn't run like in
production later on in order to do that
there is the coffee shop project and
it's a little bit small but I can show
you let's start from the jax-rs resource
so actually we have objects or as
applications or there will be a nation
the end point that is called resources
here and we have a boundary where we can
well order some some coffee so we can
post some jason-2 or this resource and
so on and so forth and ultimately there
is a resource here resource method so we
can create a coffee order and then we
have a coffee shop while that orders
some coffee
that saves the order to a database and
done the user can come back later and
now the asynchronous approach is that
later on at some point that coffee order
will be sent to the coffee processor
system right in a synchronous way we
don't know how that works as a user we
don't see it we just get the immediate
response but if we come back later using
the same URI we will see an update and
now this is what we want to test but
actually first of all we can create that
coffee order in the system using the
same HTTP approach as we would do using
a client
and then later on we also want to see
that the whole update process works so
that the order actually was sent to the
coffee processor system and now the
reason why we want to test that using an
end-to-end test first or why I want to
focus on these m2m tests first is if he
would test that using a unit test or
let's say some kind of integration
component test on a code level this is
fine to test some business logic but
ultimately doing that we're not sure if
our application works then in production
right for example if we change something
here in the jax-rs resource I do
something with the post or I require
some HTTP header or I changed a JSON
schema whatever then still my unit test
or my component test would pass through
but if I deploy it then to production
well that test fails because something
even if it's just a tiny small change
doesn't work anymore if a client wants
to connect using HTTP if a clients want
to send this and that JSON data well
then it doesn't work and this is also
the reason why I always tell companies
if you can test the same thing the exact
same thing that runs in production in
your test environments because if that
tests passes and you've done everything
right then it will work in production
because there are no changes if there
are some changes in the configuration
the changes in the code that will run
the changes and what you actually test
well then you can't really be sure and
now image the container in the test
environment is the same image and
nothing can change right and if that is
the case well then we're pretty sure
that we want a run and it will work
later on in production so actually how
that works is we have a kubernetes
cluster here and these two services
let's call them then are basically
abstracted by so called kubernetes
services so what that is is we have a
coffee shop our application that then
talks to something that is a service it
looks like basically a DNS so internally
it does a dns resolution we talk to a
logical name a nicely readable coffee
processor name and internally in the
cluster well that will route to my
docker container
that is running there which is fine
because what we're doing then in a test
in a system test is we basically swap
that out so if you think of unit tests
and component tests we test one unit and
that unit will talk to a mark right such
as mopey dough or something like that
right and now on a system test level we
can do the fire up a mock server instead
that just acts as if it were the
external system but then we can control
it within the system test we can see if
the correct response and a request was
sent there and so on and so forth so how
that looks like in the code is as
follows that now we have an order
processor that is basically a managed
bean that will well communicate with the
external system with the coffee-shop
processor there was there before so what
it does it does an HTTP connection to
just and this is the nice story about
the kubernetes environment about the
container orchestration just the logical
name coffee processor and whatever that
is depends on the environment on
production it will be the coffee
processor there's the production Kaffee
processor on my system test environment
that will be the coffee processor which
is my mark server and I don't have to
change or reconfigure my application
which is a really nice way how that
integrates so I always talk to a cofee
processor I don't know what it's running
but I don't care because right now I
only want to test my coffee shop example
application well and this is then how it
connects for the external system that
then responds and then if that for
example it does here order processing if
then updates the store status and saves
that to the database well it has the new
status of my order in place how that
looks like now is I have a docker file
so basically what I do I build up my
application let's do this in a second so
I have this project running here and
since this is a maven project I can do a
maven built a maven clean package for
example oh very good
I'm in the wrong project I should do the
coffee shop this was not a maven project
may even claim package and then it will
build my coffee shop application and
ultimately I have a thin wall file that
will be placed in the darker image so
how that looks like is I have a base
image that now is a private registry of
my own that comes with white fly
I use white fly here but for that simple
example it actually doesn't matter and
then in a thin deployment approach I
only add my waffle the coffee shop
waffle and then that's it
so let's do this I do a darker build
right with my docker container I call
this like that coffee shop and then I
have well a lot of them as you can see I
will use the version one darker tech one
and then it will just build that it's
super fast because it's a thin waffle
approach so actually my wall file is
very small it has like 26 kilobytes so I
built that and then I have to push it
that means it will end up at my registry
otherwise I can't access it and I hope
now the Wi-Fi works yes very good
question if I created a very new image
why is there something that was already
there before well that comes from the
base image here darker image darker file
I only have two steps right that results
in two layers which is not true because
the base image actually also contains of
a couple of steps so what you just saw
of all all these layers actually these
layers already come from the base image
so that was the base image that has been
transmitted before that wasn't changed
that comes from the company or something
else and now my own image what I just
did is I created I edit one more layer
that is this line I just copied my wall
file as well this is a new layer and
that's sufficient from my cases so I
have my whole application in one thin
wah file that only contains my business
code my compiled Java classes that will
be edit then I built a new docker image
for this by the way all these layers
before already exist so they don't have
to be rebuild they don't have to be
retransmitted that's that's good it
saves a lot of time and when I push it
only that would changed will be
retransmitted so this is why only you
see that has been pushed if I do this
again then already everything will be on
my server and it says already exists
done even faster if I rebuild it
well then again the latest layer will
change and now if I want to run this in
my environment again I could run this
locally but then locally I would have to
setup that external system as well right
because my docker container will wants
to communicate with something that is
called coffee processor so a bad idea in
this case is to let it run in a
kubernetes environment so I have a
kubernetes cluster installed here on my
computer with mini cube so that already
contains something coop control get
parts parts are basically well an
abstraction around the container so pot
is more or less running while one or
more running docker containers and they
are abstracted away by so-called
services so I have a service coffee shop
and I have a service coffee processor
these are my two systems and then I also
have running parts running containers
these are the actual running workloads
that run my coffee shop system and also
the external coffee processor so in
order how to show you how that was
created is that I have some kubernetes
llamó files who of you has used Canaries
before hands up okay well a few so Yama
files these look like that it's the way
how these kubernetes resources all the
things you saw in the diagram before are
created basically what I want to do is I
have a darker image and I want to run it
right so I say I want to have a
so-called pot or here an abstraction a
deployment that deploys so and so many
instances actually 1:1 replica of my
application I could say - and then it
will fire up to docker containers that's
it
and in order to access it I will need a
so called service and that service is
actually the reason why I can do
look up if I look into the coffee
processor why I can do the look up by a
DNS you saw HTTP coffee processor port
8080 this is exactly this and that is
the reason why then kubernetes can while
routers to different actual running
workloads and why I can swap this in a
system test environment so this is the
nice story about that and I want if I
want to deploy that infrastructure as
code I just tell my cluster hey by the
way here's the llamo file do it I can do
this cube control apply just say
anything you find in that Yama file
please apply it to the cluster that's
under deployment production and it's
already there nothing changed but it saw
service coffee processor okay deployment
ingress service coffee shop this is what
you just saw and the deployment as well
so we'll fire that up if I look again
it's still running so I can access it
using there is how does it look like yes
I can basically create a new coffee
order with any rest client so this is
now the user the user accesses the
system to create a new order I use curl
using a local oops a local your I this
is this goes to my laptop and it says
alright work to or 1 created a new
resource has been created by the way
it's under this location so let's have a
look into this location also with curl
that's pretty print this I have a new
coffee that I just created I wanted to
have a new coffee order I want to order
a espresso with coffee beans that come
from Colombia that country and now it
has been finished what is that the
status that status is the one that
changes so I initially create that order
then it would be created you didn't saw
that because in the meantime it was
already with the timer it was already
asynchronously talking to the external
system so if I ask again oh now it's
already collected so how the status is I
first create a coffee order then it will
be finished at some point and then if
the client the coffee drinker collects a
coffee then it will be collected and
this is now to see that the external
system that the communication works
because how the status is updated is by
asking the external system so now we can
see that it works but of course we do
not trust this this is manual work this
was not a manual test right I created a
new order and I saw okay what does it
work using this Jason that I just fired
up using origin Colombia type espresso
and so on and so forth this was a manual
test I fired that Jason against my
application and now I saw what the
response is what I want to do that in an
automated way including waiting for the
external system
so actually what what I want to do is
that I want to fire up that system test
I want to create a test that connects to
my coffee shop example application that
I just did using curl but in an
automated way and then it will talk to a
mark server so not the actual production
system that I just talked to but the
mark server that is running an assistant
test environment and now that's the
interesting thing using the system test
I can then similar to unit tests that I
can control the mark server I can say
now please respond in that way now
please respond in this way now say
finish now say collected now say that
status for this response and so on and
so forth similar to a mark and on a unit
test level I can now do this on a system
test level and how that works is just
briefly
I write a system test and usually let's
let me close that I write them in a
separate project because I want to
access the system from the outside I do
not want to you know reuse any existing
production code because then I change
code on both sides and I don't see if it
if test breaks because I did some
changes for example in the resource and
then I don't know that my tests actually
should have braked if the client still
connects using using the old approach so
actually what I have is I have a coffee
order system test which is still empty
so I would just create that right now by
doing so I want to show you how I
usually create tests because this is
very important
who of you uses copy and paste to
maintain existing tests ends up who of
you has has used you know you have a
test case oh this is how it looks like
copy and paste change three things okay
and now a new test case paste it again
change three things and now if some
functionality changes that's bad because
you have to change a lot of places all
of the copy and paste places where you
insert at that code and this is exactly
the reason why we have non maintainable
tests right this is exactly the reason
why most developers don't like testing
because it's annoying I changed
something in the production code like
five minutes and now I spent two hours
maintaining my test with all the copy
and paste that's no bad idea yes
question the IDE that's IntelliJ it's
IntelliJ with a very big font and
actually inclusion so let's say I am
using J unit 5 here I have one test case
create where if I order so what I want
to do is I want to create an order and I
want to verify if that works same thing
like I did in curl right I create a new
order from the outside using HTTP and
then I want to verify if it has been
created now if I would say
and I'm deliberately writing in comments
first I'm not writing any code first of
all that's creative brain work I don't
want to implement it yet I want to think
about what am I want what do you want to
test which coffee order do I want to
create have HTTP 200 okay and so on and
so forth what is the difference the
second example is way too much well way
too low level low level information I
don't care about that if I construct my
test scenarios I really want to ask
myself what am I going to test I going
to create a new coffee order and then
I'm going to verify if that coffee order
has listened that information however
that is created is a different story and
that will be a different concern that
will be crafted using a different
delegate a different component where my
information will be contained because
what happens if I create that example
using code that sent some HTTP does some
post does some HTTP is status checking
now my protocol changes from HTTP to
something else or my JSON format changes
and I have hundreds of lines where I
write Jason origin something like that
it's not maintainable a bad idea and it
violates the single point of
responsibility principle and this is
ultimately what I'm talking about you
have to take quality code quality
concerns into into account if you're
writing test code and this is very
important because mostly people say oh
it's just test code copy-paste doesn't
matter right no but this will not run in
production it doesn't really matter if
you have a high code quality it does
matter because you will have to change
that test code and it should be
maintainable so this is why you should
start with while having in mind what you
actually want to test and this is why I
advise people to start with even on
paper start with the rough idea first
start with comments and then implement
well what you actually want to test and
what you can do then is and this is not
forbidden this is actually a good idea
to write delegates here create another
class in you
test scope that is for example a coffee
or the system and that will include all
the methods that actually implement this
so then you're just calling methods
create an order however you do that
different story that can change
I don't care here this is my test
scenario the test scenario it just says
create an order with the following
information then verify the order with
the following information and so on and
so forth and now the other component
will actually implement it there it will
be coded how to do it how to do the HTTP
lookup and so on and so forth and I
created something already for you so
let's do some whoops
some implementation where I included two
delegates that I call coffee order
system and processor system what is that
these are two other classes in my test
scope that now include that
functionality how I want to test this
how I want to implement how I create for
example a coffee order and then as you
can see this is now the implementation
of my first test scenario not how it is
done on the lower level but how I want
to test scenario to test I create a
coffee order an espresso from Columbia
and then I say coffee order system
please create an order however you do
that and now well you don't you should
take into consideration that you don't
craft any leaky abstractions so here I
don't care about HTTP I want I don't
want to know about HTTP the only thing I
have while here is your eye this is
basically the identification of my
coffee order this is fine that this is a
URI I get to your eye back and then it
says okay well please load now the order
with that your ISO access the system and
verify if all the information is correct
right so what it does it accesses the
second or the second system no sorry the
first system again using the second
component and then I check well if all
the information is correct so basically
if the type matches and the origin
matches that is the actual test and then
also verify if now I have one more order
so it will access the coffee orders a
system first it checks for the size of
the coffee orders and actually
afterwards it will check that it has one
more right same story if I want to
create an order and now this becomes
more interesting I now create an order
what I did before using curl and now I
ask well does the processing work so now
internally does my application
communicate with the external system in
a correct way so I wait I create the
order then I wait until the external
system will be called and this is now a
little bit more difficult so I create an
order such as I did before fine and now
I tell my processor system
by the way if any order comes in with
that your ride and please respond in the
following way because my external system
I will show you in a second how that's
implemented is now a mock server this is
not the actual system this is now just a
mock and I will have to tell it how that
works so anyway if that your I comes in
please respond accordingly please
respond using that status first status
is preparing now the coffee order will
be prepared right then by the way I can
verify again if the information was
inserted correctly alright and now I
will wait for the processing and load
the order again this is a private method
also not this is not forbidden actually
a very good idea to craft some methods
that implement your logic it will tell
the system now wait for the invocation
this is now well required because I have
this asynchronous processing and I
actually do want to wait until that has
been called including a timeout of
course otherwise the test will run
forever but I want to make sure if that
was called accordingly and if so then
please ask the coffee or the system
again and we turn my coffee order
because now the status should be updated
right and then we are here we check for
the preparing status this is the second
status and then afterwards this is the
one you saw we check whether it's been
finished and if all that works then we
can be sure that the communication with
the second system works because the
status will only be updated if we can't
communicate accordingly right and I can
show you now how that is implemented
using the second system that is the
processor system what it does it uses
wire mark that is one implementation of
such a mark on a system level to connect
against my watermark system that well
runs under coffee processor in a test
scope with my local kubernetes cluster I
will fire that up in a second and then
it says well if somebody accesses this
is now the UI that my system will access
if somebody accesses the
please respond accordingly using that
Jason and that is then the information
that my system expects to say well send
something equal to this is the order and
this is the following status and so on
and so forth that code is now wiremock
code so it will tell it basically if
that is requested using HTTP then
respond accordingly
using that jason in my case basically it
tells the system how to respond and now
the public method that i will call is
this one wait for invocation it
basically well has a timeout it will
wait for 1 minute because this is now
known to my system i have to know how
fast my system normally is it has a
timer for i think it's 10 seconds and
then it will wait accordingly if well
you see extract ID if something has been
called using that your i so if that uri
has been requested and also if that
status was correct basically it tells us
has my system be called correctly using
the correct jason and everything how you
would expect it and if that works well
we can move on and this is also how my
component of my first system works you
probably already assume that this is
basically what i did using curl right I
access my first system I use Jack's rest
here because Jack's arrests already
ships with Java EE it doesn't matter you
can use any HTTP client actually all
these tests can be constructed in any
technology of your choice right because
they are system tests they have nothing
to do with your production code they run
externally this is also important to
mention I for example I'm crafting
orders here as that is a Java pocho that
I will use to serialize the Jason this
is a different one deliberately than the
production code the production order
looks as follows it has well way more
stuff in it it has JPA mappings i don't
need that in a in my system test
actually I don't want to know in my
system test if that's mapped using Java
II using
they using something else that's not
part of the test the application has to
work in the correct way however that is
done right and also it has some proper
types for example for the coffee type
which is an enum and so on and so forth
in my test that here doesn't matter also
I just sent some strings that can
totally be fine if the correct strings
are sent back so that can be simplified
alright if all that works then we can be
sure that now the system works this is
basically an automated approach of what
I showed using curl so in order to test
that well I have to see whether my
system test is running now it's not
running yet these are all the pots that
run on my kubernetes cluster you see
they're not of a lot of other so-called
namespaces so what I will do I will now
fire up my system test environment how
does it look like well it's very similar
to my production environment the only
difference is my processor you saw the
difference between here and there is on
the bottom I use a mock instead of the
correct system so the system test
environment looks exactly the same but
it's of course deployed to another
namespace so these two don't collide and
also this is the same as if I would use
another kubernetes cluster right but I
only have one so I deploy both to the
same using another namespace but it
doesn't matter
and that processor is almost the same
but it uses a different image it
actually is not the coffee processor
image it's a monk that is wire mark same
thing that I used in my code and this
will be communicated with using my
system test having that set our fire up
the deployment for the system test and
then it will create all these things it
will now create since I'm just firing
that up a new service a new deployment
and so on and so forth for my system
test scope so if I now ask to give me
the parts for my system test namespace
it will say well these things are
running they are not fully started up
yet this will take a second
and well in a couple of moments
hopefully my coffee shop and my coffee
processor are up and running and then I
can connect to them using my end-to-end
test so what the end-to-end test is do
is doing is you already saw that here it
connects to this is now the test scope
of my kubernetes cluster - now that
coffee shop in the test scope and then
it will fire up all these things all
right now it's running and ready that
means I can fire up my test so what it
does the application the coffee shop
application runs in the same way as it
would run in production and down there
you it's a little bit small but it's
first of all running the first test
grade where if I order what it does it
will connect against and that already
was green you will connect against the
system that is compared to be fast
because it connects against the system
the system will store the status I ask
the system again for the status if the
status matches fine now the second one
takes longer why because actually I have
to wait I have to wait at least twice I
create this the coffee order I where if
I if the coffee order was correct
all right now it waits for the second
system to get the status - for the
second system to be called by the first
system because this is what I actually
wanted to test it says wait as long as I
get that request for in this external
system right and now I have a big Jason
array and I check well JSON object I
sent that jason by that post and i see
if i get status 201 created back and i
safety location that is now this uri and
then I use that location to do an HTTP
GET and so on and so forth again and
again and again if then the you write
changes or if this JSON schema changes
it's a lot of work and this is what
makes taste test so hard to maintain in
this case it's easy to maintain if I
want to change some test scenario
information I do it here if I want to
say do some cappuccino instead of the
espresso do it here
done
Noelle's that is just that test scenario
or if I say even big changes like
exchange HTTP against something else
some other communication form it doesn't
matter because there is an interface in
that well not a Java interface but that
class the interface doesn't contain any
HTTP information so I just say create an
order for that pojo and I get a URI back
well in this case it will be DUI for the
identification but if for example I
changed Jason for XML for something else
if I change the HTTP information the
status codes it's only in that class and
the tests are maintainable for me to to
edit alright just very quick note on
component tests this is now another
level of tests that I briefly introduced
in or not briefly that I introduced in
my book as well for how to make code
level tests also a little bit
maintainable who of you has used j-unit
together with mojito and yeah a lot of
you and you know depending on how your
Makita setup looks like it's either a
little bit inflexible or a lot of work
to do right you always have to write
mark mark here mark it there or you use
annotations but then the annotations
don't always work with if you do some
more complex dependency injection so
they're not always the same beans are
injected and so on and so forth so
basically what I have I have this coffee
shop and this is not the system now this
is code level so these are two classes
Java classes I have the coffee shop
class that is now my boundary that is
basically the entry point for my use
cases if I want to create an order you
see it's called here and that will use
well any other beans so in order to
write a component test an integration
test code level test if you like I
basically could well instantiate that
class and then say please do a mark on
that system right on that order
processor system but that is a lot of
work and that well will be done for one
test and then I have to repeat myself
all over again it's the same story
how I solve that here is or how I
created that here is now this is another
project this is not the system test
project but actually in my real code
project as I will use a so called
component test what is basically I have
a coffee-shop component that is now an
extension of my class of my coffee shop
class the same is true for my Oda shop
or the shop processor for the other
marriage being the reason why I'm doing
that is so I will set up all the marks
and all the wiring what would be the
dependency injection in my in my
enhanced class in my subclass so that
will extend the coffee shop and it will
well reset my dependencies using either
a mark or another component that has
been provided by the constructor so
actually I can now and that's the idea
behind component test I can now fire up
a test scenario why I let's say want to
instantiate that class instantiate that
class as well but for this class I use a
mock or I instantiate all of these
classes and so on and so forth depending
on how your test scenario looks like
because if you want to have a more
complex scenario with a little bit of
integration more than just unit tests
then at some point let's say you want to
setup all the classes all the production
code for the overall business use case
from the boundary down to all of the
controls or however you call them but
not for the external system not for the
gateway or not for the entity manager
stuff like that so where you want to
have fine control on which you at which
instances you want to am create and
which instances you will mark and by
doing so this is for example the
component for my order processor this
will mark all the jax-rs instantiation
here you will again be more effective
and more maintainable because now on
these subclasses you can introduce more
methods you can for example say where if
I create order this is of course test
code this is not in a production code
matters and this is already the most
important thing you want to consider
and craft session layers and separations
of concerns these principles though this
is what we've done right we created some
code comments first or on paper and then
on a lower abstraction layer in our case
on a different class we implemented how
we do things right our test scenario is
just like what we want to do what we
want to test
reusable test components like you saw
for example for component tests or also
for the system test scope are very
helpful as well
and in general fast feedback I always
write this versus completeness so this
is very important to take into
consideration of course you want your
tests to run fast but also you want to
test your tests to cover as much as
possible and this is the reason why I
mostly advise to write and to end tests
for systems that are already up and
running because these tests are usually
very fast if you use to your system that
is for example deployed by kubernetes
you can deploy it very fast and also
while you just access your system you
don't have to fire up and embed it
container for example all over again you
just use your system in a proper test
scenario and last thing to mention I
didn't use any other test frameworks
here then plane to unit and I know a lot
of developers are big fans of spark
testing or groovy or Scala test
frameworks and I'm not against to use
these frameworks although I didn't use
them in that talk but I just want to
bond which is very helpful but this is
just the first very thin layer if you
have a lot of complex and components in
place you need to craft them in order to
be maintainable this is what I did by
creating a couple of classes and this
was just an easy a simple example so the
more complex your business logic gets
from my experience the more it matters
that you have a proper test code quality
and the lesson matters if for the very
last layer for your test scenario you
have nice frameworks in place or not
this is my opinion on that but I can
guarantee you if you care about test
code quality then you will have more
maintainable tests and ultimately it
will be fun again to write test code
thank you very much for your attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>