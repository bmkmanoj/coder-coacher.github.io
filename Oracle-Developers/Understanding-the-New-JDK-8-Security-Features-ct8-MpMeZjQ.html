<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Understanding the New JDK 8 Security Features | Coder Coacher - Coaching Coders</title><meta content="Understanding the New JDK 8 Security Features - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Understanding the New JDK 8 Security Features</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ct8-MpMeZjQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right hello and welcome to my
session on understanding the new JDK 8
security features my name is Shawn Mao
and I'm the tech lead of the Java
security library statement here at
Oracle so my agenda for today I'm first
going to start off with a little bit of
a high-level brief overview of Java SE
security so for those of you that aren't
not that familiar with Java SE security
this should be helpful and for the rest
of you hopefully it will be helpful as
well I'm then going to spend the bulk of
my talk about the new JDK 8 security
features there's a lot of new features
in JDK 8 that are related to security
and I'll talk a little bit about a
couple of features that were added in
the JDK Update releases and we'll take a
sneak peek at some things we're thinking
about for JDK 9 so it's still early in
the planning stages so it's still a
great time to hear your input and then
we'll conclude and show pointers to more
information there should be 5 to 10
minutes left at the end for Q&amp;amp;A as well
okay so overview of Java SE security so
this is a conceptual diagram of the
different pieces that make up Java SE
security can basically be broken down
into three different areas hello still
on yeah ok at the lower layer you have
your Java language at runtime security
and so these are the things that the
constructs in the language that that
help you write write secure programs and
also things like the security manager
that help provide a safe environment for
running applications and then we have a
large set of API some libraries above
that everything from cryptography all
the way up to XML signature I'll go into
the each of those in a little bit more
detail and then we finally we have a
small set of tools for managing security
so for Java language and runtimes
security well as you may know that Java
platform was designed with security in
mind the language itself is type safe
has automatic memory management so you
have to be concerned with managing
memory dealing with function pointers
and things like that you can concentrate
on your code and at least in general
helps it create more safe robust code
the language itself also has various
access modifiers so you can choose how
to decide how you want your class
implementations what kind of access so
you have things like private package
private protected public final and so
forth now as classes are loaded there's
a bytecode verifier that checks that
byte codes are well-formed and do not
violate various rules and as those
classes are loaded they're assigned to
things called protection domains and
this is based on certain characteristics
of the code such as where it originated
from and whether or not it is signed and
then finally at runtime you can
optionally enable a security manager and
the job of a security manager is to
govern access to security sensitive
operations these access roles are
determined by the security policy which
can be configured by an administrator
usually but a user could also configure
it as well and this is in the policy you
can assign permissions to different
parts of the code these are then
injected into those protection domains
and that's what the security manager
uses to choose whether to allow those
operations
so and then we have a large set of
security api's in libraries so you can
actually build security into your
applications these API span a wide range
of areas
everything from cryptography so things
like message digests digital signatures
ciphers we have api's for public key
infrastructure so parsing and validating
certificates and certificate chains we
have api's for SSL and TLS otherwise
known as j SSE we have an API for this
simple authentication and session layer
I believe it stands for then we have an
API for jazz which is our Offutt
authentication and authorization service
and this allows you to build things like
single sign-on solutions you can plug in
different login mechanisms from
different and implement a single sign-on
solution that way we also have an API
for gssapi that's a standard api defined
by the ITF and our implementation of
that is Kerberos underneath that and
then finally we have an API for
verifying and generating xml signatures
all of these API SR abstracts such that
we allow you multiple implementations of
algorithms to be plugged in underneath
and you still use the same API at the
top layer these algorithms are
implemented in service providers and
plugged in via a standard service
provider interface and the JDK includes
a default set of service providers
covering a comprehensive set of
algorithms so most everything that you'd
ever want to use is there but you can
still use a third party algorithm if you
want or implement your own
and then finally we support a small set
of tools at the top for managing
security we have the key tool utility
command line tool for managing keys
stores of certificates and keys we have
the jar signer tool command line tool
for verifying and signing jars and the
policy tool which is a graphical user
interface tool for editing policy files
so that helps you avoid things like
syntax errors in the policy file format
okay so new JDK 8 security features most
of you have heard of lambda but actually
not many of you probably know that
there's actually 13 new security
features in JDK 8 in my abstract I said
there was 11 but I actually did a
recount and there's actually 13 so these
new features span the entire security
stack all the way from the Security
Manager up through the api's and
libraries and we even at that have
enhanced the tools to take advantage of
some of those features the two areas
that we spent a lot of time improving in
JDK 8 with a crypto area and the SSL TLS
area so this is just the highlights I'm
going to be going into these in more
detail but for crypto 2 significant
improvements we've done is we've added
support for hardware accelerated crypto
performance improvements and this
dramatically improves the performance of
certain algorithms which I'll show you
later
we've also added support for new and
stronger algorithms so we're trying to
keep up with this industry standard and
make sure that you have the strongest
and best support available for you and
in SSL TLS we've improved our secure
out-of-the-box defaults we've added
support for the server name indication
extension and we've added support for
new GCM cipher suits
but wait there's more we've also had
better support for certificate
revocation mechanisms so things like
OCSP and CR ELLs we've improved our
Kerberos delegation support and we have
new api's for limiting codes privileges
to only what is necessary to perform a
security sensitive operation this is a
really cool security sensitive feature
which I'll talk about it a little bit
later and many more and more smaller
enhancements these are actual lists of
the 13 new security features all
identified by a Jeff a JDK enhancement
proposal I'm not going to read them off
because I'm gonna be going into them in
a lot more detail throughout the
presentation so if it'll be apparent
which ones I'm talking about but the
slides are up on the Java one site so if
you do want to refer back to this list
you can download them and look at that
so here's the first seven and these are
the next six
okay I do want to go back to that
diagram that I presented earlier and
show you a couple of interesting things
so what I do that I took the feature is
all the features the night and I plugged
them into the area that they they most
mostly apply to and as you'll see this
works we've spent a lot of time
improving crypto that's really a big
area that we worked on for JDK 8 but
there's also a small scattering of
features throughout as a couple in the
security security manager layer this one
in PKI one an SSL 20 Kerberos there's a
couple that's span a couple different
areas so they they kind of touch two
areas so this just gives you a flavor of
what what we've improved in JDK okay
with that let's talk about the features
I'm going to talk about the the what the
each feature is what its benefits are
and for a lot of them are also going to
give you a code sample I'm going to
start off in the crypto area because
that's where most of the features lie
okay so the first one is pretty easy
we'll start off with simple one-shot
2:24 message digests so we added support
for shot 224 this is basically a
truncated version of shot 256 message
digests which you might be familiar with
the difference here is that the computed
hash is 224 bits instead of 256 and so
basically does shot 256 and then just
chops off the last 32 bits it provides
112 bits of security which is the same
as 2 key Triple DES and this is not a
very commonly used algorithm but it does
it or may provide a sweet spot for use
cases that benefit from the smaller
digest size and overall have a a
security level of 112 bits of security
we've had its support for the shot to 24
message digests and related algorithms
shot to 24 message digests and the
different signature alguns with RSA DSA
or ECDSA and an H max shot to 24 mac
algorithm so this completes our support
for the shot to family we support all
variants to 24 256 384 and 512 being the
strongest
and JDK we also need up made a number of
improvements to our secure random API
and implementations if you work on
secure yet in any level whatsoever you
probably know that strong random numbers
are critical for many cryptographic
functions so what we did was we added a
new method to secure random class called
get instance strong and what this method
does is it automatically finds a
strongest random number generator on the
implement JDK platform and returns that
to you and the benefit of this is it
reduces your chances of accidentally
picking a weak generator so prior to
this you might have just been using this
secure random default constructor but
that actually returns the first
implementation from the configured list
of security providers that's not always
the strongest one available or you might
have been using the get instance methods
and specifying your own algorithm name
but you have to find out what the name
of the algorithm and it may not be the
same on on Windows it could be different
on Solaris so this new method hides all
that complexity for you and just one one
single method call I'll show you an
example of how that works and then we've
also added new native PRNG blocking and
native PRNG non-blocking secure random
implementations on unix platforms so if
you're on a unix if your applications on
a unix platform and you know you want to
read from dev random or a w random you
can specify these algorithms directly
okay so here's my first simple example
using the new API so the first thing we
do is we call get instant strong this
returns the strongest secure random
implementation on on the platform and
then we want to we want to create that
key pair an RSA key pair which depends
on a good secure random generator so we
do is we call it get instance method key
pair generator specify the RSA algorithm
this returns a key pair generator object
we then call the initialize method
specifying 2048 that's the size of the
key pair we want and we pass in our own
secure random object so we guarantee
that it's going to be using the
strongest one rather than one the
implementation would choose on its own
and you'll note that many of our API is
contain such overloaded methods that
allow you to pass in your own secure
random object so you can have control
over that
okay another another improvement we made
to JDK is JK's we've strengthened our
DSA and diffie-hellman support we've
added support for generating 2048-bit
ds8 key pairs and diffie-hellman public
key pairs you can use either API or you
can use the key tool command-line
utility to generate the key pairs it's
generally known now that 1024 bit public
keys are no longer recommended for use
NIST has has come out with guidelines
the last few years saying that you
should move forward to 2048 bit or
stronger key parents so we already had
support for that in RSA but we hadn't
had added it for DSA so now we've done
that in JDK 8 and we've also added
support for the shot to 24 with DSA and
shot 256 with DSA signature algorithms
and here's an example generating a
2048-bit DSA key pair and signing some
data with the sha-256 DSA algorithm
first thing we want to do is call the
getting some method of the keeper
generator specified DSA is our algorithm
and then initialize it specifying the
size of the key pair we want to generate
2048 now DSA key pair generation
consists of two phases you generate the
domain parameters and then you generate
the key pair yourself you can generate
you can create the domain parameters
yourself if you want and pass them in
using this overloaded method if you
don't though we will generate them for
you so if you want more control you can
you can do it yourself
then to actually generate the key pair
you call the generate key pair method
and it returns the key pair and we
signed some data with sha-256 with DSA
algorithm to do that we call the get
instance method of the signature class
specify the algorithm we want to use
sha-256 with BSA next we call the anit
sign method and we want to sign with our
private key so we want to sign with the
private key half of our key pair and
validate or verify with our public key
and then we specify that data we
actually want to sign so this we're just
signing the classic hello world message
and then finally we call a sign method
this calculates the signature and
returns it in a byte array so this could
be pretty pretty basic stuff it's not
you might be already familiar with that
but that's a good example of using that
new feature okay let's switch gears and
talk performance so another really cool
feature that we added in JDK is hardware
accelerated AES crypto performance so
the way this works is the hotspot
compiler now generates intrinsics for a
AES instructions on 32-bit and 64-bit
x86 systems if they support such
instructions so if you're running on an
x86 x86 system and it has built-in
hardware instructions for AES the
hotspot compiler will actually replace
the original bytes codes with these
hardware instructions so that runs
directly on the hardware this provides
significant performance improvement on
x86 systems the intrinsics are triggered
when a cipher with the whenever a cipher
with AES algorithm is created so
whenever you call cipher get instance
AES or to get the most performance you
want to use cipher block chaining mode
so cipher get instance AES with cipher
block chaining this particular
enhancement is implemented in the Sun JC
provider what that means is on Windows
if you're using Windows or Linux it
should work out out of the box if your
system supports it however if using
Solaris on x86 you may need to reorder
the providers in order to get that
performance boost and that's because the
Sun jce provider is lower a little it's
not as high in the preference order as
the other platforms so it may pick up a
algorithm that is not as fast now if
you're wondering about SPARC we've added
the same intrinsic for SPARC systems in
8u 20 which I'll talk about a little
later
so here's a little bit of chart as to
the actual speed up or throughput
increase in throughput you can see this
first of all this is on an x86 system
I'm using AES 128 bit encryption cipher
block chaining mode and the message size
is 10,000 bytes so as you can see
encryption this is no intrinsic and this
is intrinsic so it's about the
throughput is going up about five or six
times
decryption we see an increase maybe 15
to 20 times does anyone know why
decryption is better I think I heard it
yet so in decryption you can paralyze
the algorithm you can actually break it
down for encryption you can't do that
with CBC but decryption you can so this
was on a four core system so it's able
to you're able to get even more speed up
on to the decryption as it uses each of
the four CPUs to do so that's pretty
cool
okay next crypto feature we added was
support for authenticated AES GCM cipher
mode so GCM stands for goliaths counter
mode and it's an efficient symmetric key
block cipher mode that also supports a
EAD
or authenticated encryption and
associated data so what this means is
you can provide both data integrity and
confidentiality in a single cipher
operation using the same key GCM can
also perform better than other block
cipher modes such as CBC so when we add
intrinsic for GCM which were working on
for jdk 9 the numbers are going to be
off the chart because you can get
paralyzed both the encryption and
decryption mode and get and get really
really fast performance so basically in
GCM you have your plaintext you can and
your cipher text and then you have an
authentication tag over both the
plaintext and cipher texts in JDK 7 we
enhanced the cipher API to support a EAD
so we added new api's but we didn't have
time to provide an implementation so you
pretty much had to use a third party or
implement your own in jetty Kate we
fixed that and we've now included GCM
mode for a pas implementation in the JDK
so here's an example of how to use it we
use the cipher class we call it get
instance method specify the algorithm
yes we're using 128-bit encryption keys
Sam mode and no padding we then call the
Ennead method and one initialized it for
encryption mode and passing our key now
again you could use your own parameters
here but I'm not if you want that you
can call the overloaded method and pass
in your own parameters if you do use you
own your parameters though it's critical
that you specify a different
initialization value vector or nonce
each for each complete GCM encryption
operation the security is depends on
that so it's really important so I
recommend just letting us do it you're
letting the implementation handle it for
you if you don't need that level of
control then we call the the update aad
method with the message that we want
authenticated or integrity protected so
we don't really we want to do we want
this message to say it's coming from
Duke but we don't want that to be
confidential we're not too concerned
about that and then we call encrypt with
the message that we want and call the do
final method which the message we want
to keep confidential so Duke is saying
meet me for coffee tomorrow at 1:00 p.m.
should probably say where did where he
wants to meet but it's it's it example
and this actually then encrypts the data
and then also produces that
authentication tag and returns it all in
a single byte array to decrypt that we
actually we just basically reverse the
steps we initialize the cipher for
decryption mode passing the key and the
parameters that were used in the
encryption step we call update aad with
the message we want to authenticate
which is Duke and then we call do final
on the ciphertext if everything goes as
expected
we'll get the message meet me for coffee
tomorrow at 1:00 p.m.
okay one last crypto feature I want to
talk about is stronger algorithms for a
password based encryption otherwise
known as PvE so PBE is based on pkcs
number five the standard and includes
three different things key derivation
functions so taking a password and
deriving a strong key from it such that
it's very hard to attack three things
like a dictionary attack encryption
schemes so taking that strong key and
encrypting some data with it and then
message authentication code producing a
Mac from that strong key now the support
for PBE as of JDK 7 was lacking - just
to put it mildly
who's based on an older pkcs5 standard
and used things like md5 and and des and
you know older weaker algorithms I don't
recommend using those algorithms are
still in the JDK but I don't recommend
using them anymore so JDK 8 adds more
secure algorithm is based on pkcs5
version 2.1 we've added support for
secret key factories these are the long
algorithm names that are hard to
remember but these are the new new ones
with the stronger sha variants and then
we have this stronger cipher algorithms
with again stronger sha variants and aes
128 256 bit encryption and a new Mac
algorithm with stronger sha variants as
well
so here's an example of how you would
derive a strong key from a password and
then encrypt some data with it so the
first thing we're doing is we're reading
a password from the system console and
then we create a pv pv key spec object
containing that password we then need to
convert that to a secret key so we call
the get instance method of the secret
key factory specifying the encryption
algorithm that we're gonna be using PV
with H max sha-256 and AES 128 bit once
we get the secret key factory we then
call the generate secret method and pass
it in the pv key spec object now it's
really important here this is just an
intermediate step this key is not strong
there's different algorithms if you
wanted to to create a strong key the
algorithm that you would specify here is
the pbkdf2 strong key so don't take this
secret key and store it anywhere where
it could be subject to a dictionary
attack so now we want to cook some data
first thing we do is call the get
instance method of the cipher class pass
it in the same algorithm that we
specified up here initialize it for
encryption mode and then pass in the PvE
key that we created here and then
finally we encrypt encrypt some data I
call the do final method with some
confidential data that we want to
encrypt this actually then takes that
PvE key generates a strong key from it
encrypts the data and returns it in a
ciphertext array
okay let's switch gears now and talk
about TLS and SSL so in the tls/ssl area
we've done a couple of new features
we've added support for the AE ad cipher
Suites so this is support for the GCM
based TLS cipher suites to find an RFC
is fifty to eighty eight fifty to eighty
nine and fifty four thirty this is
pretty much known to be the best cipher
suite right now to use with TLS you get
the best security the best performance
although it's not yet ubiquitous it
depends on TLS 1.2 which is still being
slowly - poit but you know it's it's
happening quicker and quicker so I think
you know in the next couple years or so
you should be able to depend on it you
know everywhere I should should probably
be support it this leverages the
authenticated TCM cipher mode that I
talked about earlier so underneath the
hood we're just calling the jce API and
the GCM mote that I talked about earlier
the new suites include various versions
I won't go into them in detail but you
can look at the cipher suites table for
all the different cipher suites that we
support
the other major TLS enhancement we had
NJT Kate with support for the server
name indication TLS extension
now the sni extension is used to
indicate the host name of the server the
client wants to establish a session with
so this is really useful when you have a
TLS server that has multiple multiple
domains that share the same IP address
and this is becoming very common in
virtual hosting and cloud computing
requirements so each server domain that
has the different host name also has a
different certificate which
authenticates that host name so it needs
to pass a different certificate to the
client so several new GS is epi jss the
api's have been deveined to support sni
let's look at an example how to use it
so on the client side first thing you
need to do is create your ssl socket we
do that by calling the get default
method of the ssl socket factory then
calling a crate socket method with the
IP address we want to connect to and the
port which is 443 we then need to
specify the hostname of that IP address
that we want to connect to let me do
that we use the new class sni hostname
and in this case where we want to
connect to WX ample comm then we need to
get the parameters the SSL parameters
with socket and set that call the set
server names with a list of those server
name S&amp;amp;I server names in this case
there's only a single sni server name
that we that were interested in and then
finally we have to reset those
parameters back on the socket by calling
the set ssl parameters method and now
we're ready to start the handshake so we
call the start handshake method and wait
for the server on the server side
server creates its server socket calls
the get default method of the SSL server
socket factory and then calls the create
server socket method specifying the port
who wants to listen on and that returns
an SSL service server socket instance
then we need to specify the server needs
to specify ok these are the host names
that I support and it does this by
calling the a new method of a new class
called great s and I'm a sure and this
takes a regular expression of the host
names that it supports so in this case
this host supports WX ample comm or w WX
ample org and we do a similar thing as
we did before we get the SSL parameters
we call the set s ni mattres with a list
of s and i mattres and then we reset
those parameters back on the server
socket and now we're ready to accept a
connection from the client we call the
accept method and underneath the hood
when it gets the connection from the
client it's smart enough to know to to
pick choose the right certificate to
authenticate back to the client so all
that happens under the hood
and just a few other notable tls/ssl han
Smits
these are things like improving
out-of-the-box security and adding a few
bells and whistles here and there so the
first major thing actually really is
that we've enabled TLS 1.1 and 1.2 by
default on the client so you no longer
have to explicitly enable it as part of
a setup the client already passes that
you know it's enabled by default on a
client and that overall
right away improves your security both
of those protocols have added a lot of
security enhancements however if you do
want to tweak it you can use the new
system property JDK TLS client protocol
system property to change those default
protocols the other notable enhancement
we've done is we've added support for a
server cipher suite preference so a
server can now choose which cipher suite
they want to use rather than the subject
to what the clients most preferred one
is which may not be strong enough for
their for their own needs so there's a
new method called set used cipher Suites
order on the SSL parameters class that
allows you to set up the preference
order of the cipher suites and finally
we've increased the strength of the
ephemeral diffie-hellman parameters the
default has been increased from 768 bits
to 1,024 bits and you can even increase
it to something stronger like 2048 using
that system property
okay so there's a few other interesting
JDK 8 security features I'd like to talk
about in a couple of different areas so
in the keystore area the key Story API
is used to access a storage facility of
certificates and keys and we've made a
number of enhancements first we've
enabled the strong PBE algorithms that I
talked about earlier password-based
encryption x' so now you can actually
use them to protect key store entries so
we've added a new constructor to the
keystore password protection class that
allows you to specify a strong PBG
algorithm so if you want to encrypt a
key with a password you can use one of
those really strong algorithms I talked
about earlier and it will be very you
know with much better security we've
also added a new key store entry
attribute API for storing metadata with
entries so some key stores such as
pkcs12 allow you to actually put
additional data in with the entries so
now you can actually access them with
this API you can both retrieve that data
or store additional data we've also
added a new domain key store type what
this actually does is it allows several
key stores to be aggregated and viewed
as a single key store using the key
store API and this is a pretty cool
feature I'll show you an example just
how useful it might be and finally we've
enhanced our pkcs12 key store
implementation it now can support
trusted certificate entries and secret
key entries so it's now a full-fledged
key store that can support everything
that the jks key store can do so here's
an example of a domain key store and how
you would use it the first thing you
have to do is write a dks config file
and basically this is going to show you
list out the number of key stores that
you want to aggregate and I did this
example on my other laptop which is
running a boon to
and what I did was I created a a file a
domain name ditto boom - and what I
wanted to do is create a single key
store containing all the root CA certs
in Oracle's JDK and all the ones that
are in Ubuntu's JDK and so I listed out
the each of those key stores what type
they are and then a path name to them
and Oracle's JK and a mbutu's JK you
know some of the treat certificates the
same but there's also different ones
that are in each version of the JDK so
here's what I can do here's how I can
use it I create a key store call the get
instance method and pass it the new dks
key type key store tight and then I
create a URI basically pointing to the
dks config file and then I called a load
method of key store pass it in a new
instance of a new API in JDK called
domain load store parameter it takes the
URI and a map the map is actually a
mapping of the passwords needed for each
key store in this case the passwords are
actually optional
for those CA certs file so I can specify
an empty map now let's say I wanted to
validate a certificate chain but I want
to use all the trust anchors in both key
stores I want to make sure that I get
the maximum number of recent root
certificates in both J decays so I can
do that by creating a peak experimenters
instance passing in the key store then
call creating a cert path validator of
the peak Hicks type and then validate a
certificate chain using those parameters
and that will iterate over all the the
trust anchors until it finds one
hopefully finds one that it can use to
establish trust in that certificate
chain
okay another thing we've done in the pka
PKI air is we've added a new peak
extravagant checker API which allows you
to set various revocation checking
parameters so in the previous version of
JDK 7 you really had very little control
over how revocation checking was done so
this new API allows you to have a little
bit more control over that you can
perform the check using OCSP or CRLs or
both the default is to try OCSP first
then fall back and try to find a CR l
we've also added support for soft fail
behavior so this is something that web
browsers support if the if the
revocation check cannot be performed
because of a network issue maybe the
OCSP server is overloaded or you're
behind some sort of firewall and you
can't get to the revocation server well
then it's not treated as a hard failure
the certificate chain will still be
allowed to to succeed and validate
however since that is a security
sensitive setting the default is off you
have to enable it explicitly and then
there's an option where you can say I
only want to check the end entity's
certificate but of course that's another
security sensitive option so the default
is to check every certificate in the
chain for revocation so here's a simple
example of actually enabling the soft
fail we could assert path day a
validator for the pickax algorithm we
then call this new method called get
revocation checker on cert pat validator
cast it to a peak Hicks revocation
checker and then we can call some
methods on that we can call the set
options method and specify that we want
to enable the soft fail option which is
an enum and then next we validate a
certificate chain we create a peak
experimenters object but then we have to
call an add surpass checker method on
the parameters object with the PKK's
revocation check but we just setup and
that tells the the surpass checking
algorithm use this revocation checker
instead of our default implementation
and then we call the validate method
pass it in a certification path and the
parameters if everything goes as
expected we get a surpass validate or
result back now let's say though you're
curious yet soft fail enabled but you
want to know if any of those
certificates the revocation check
couldn't be performed because of an
issue so you can go back on the P kicks
revocation checker and call the soft
fail exceptions method and that will
return any exceptions that were
generated and you might want to show
these in sort of security dialogue
warning and leave it up to the user to
choose whether they want to proceed of
course hopefully the user will be smart
enough to choose the right answer
so next slide support for a Microsoft
service for user Kerberos five
extensions I'll just run through this
really quickly these basically these two
extensions allow a service to obtain a
Kerberos service ticket on behalf of
another client so this is really useful
where you have a client that doesn't
have Kerberos on it but it needs to
access a kerberized service so it can
talk to an interim service that can use
these extensions to delegate the
credentials and allow you to access that
back-end service
okay last but certainly not least is
called limited ooh privileged so you
might be a familiar with the access
controller and the do privilege method
this basically allows trusted code to
perform a security sensitive operation
on behalf of untrusted code that's
that's calling those those api's in jdk
8 we've added new new variants of those
methods that take a list of limiting
permissions and the reason this is
useful is that these new methods allow
code to assert a subset of its granted
permissions so this allows code to
better adhere to the principle of least
privilege if that if the code that you
have inside the do privilege it only
needs to get a single system property
that's security sensitive you can say
I'm going to assert a single permission
just to just to read that system
property and this overall reduces the
risk of excessive permissions being
available if there is a bug in that code
so previously it would assert all the
permissions that you have just to read
that system property which is not really
a good idea and it's also useful when
you need to assert some permissions
while allowing others to continue the
stack block these are best shown through
a couple of examples so here's a very
simple example we want to read a system
property this is trusted Co you want to
read system property the user home and
the reason that's sensitive is it
because it could have the user's name it
could have details of the the file
system so it needs to be protected by a
permission check these a lambda
expression to do that and you see our
last argument we're actually just
specifying the permission that is needed
to read that system property and no more
here's a more advanced example let's say
we were designing an API called open
stream the user can pass in a URL and we
return an input stream to the content
that URL now we wanted we want to allow
any it's it's usually from a sandbox
sort of policy it's usually okay for a
code to make connections back to the
origin it came from so we allow we do
this in a we wrap the operation and do
privileged and we allow anybody that
calls this to make a connection back to
the origin that they came from so if I
if I have an applet from phu kham and I
call this API and I'm passing in a URL
that that that originates that phu kham
and then we allow that that action to
take place however let's say foo.com
passes in this applet passes in
example.com this permission check will
fail but the permission check will
proceed as if the do privilege wasn't
invoked at all it will walk up the stack
to see if the caller has a permission or
you know as many callers as there are on
the stack to see if they have a
permission to connect to you example
comm and so this kind of allows you to
create some interesting api's you could
have maybe a policy at a higher level
that allows a host to connect to other
hosts depending on some sort of cross
domain policy file or something like
that so
it's it's probably you know justjust
talking about this would probably take a
little bit more time but that's that's
that's the general idea behind that okay
a few other notable JDK 8 enhancements
before we wrap up and talk about JDK 8
you 20 at 9:00 we've added a new caller
sensitive annotation for marking color
sensitive methods so these these are
very these are security sensitive
methods allows us to track and audit
them more carefully we've disabled x.509
certificates with RSA keys less than
1024 bits those are pretty much known to
be insecure so if you have a certificate
chain containing one of them they'll be
blocked by default we've also disabled
Kerberos five DES encryption types by
default and we've enhanced our sazzle
and gssapi s2 support
unbounded servers so this is similar to
this server name indication extension
you can now use those api's to connect
to servers that might support more than
one hostname and for more information
you can see the security guides for all
the list of enhancements that we added
okay just a couple features in jk8
update both related to performance in 8u
20 as I alluded to earlier we added
support for intrinsics AES intrinsics on
Solaris SPARC so you're gonna get the
same speed-up that I saw the showed
earlier that I demonstrated earlier 8u
40 which is targeted be released next
March we're continuing on that trend and
we're adding intrinsic stew improve shop
performance on SPARC and a few JDK 9
security features we're thinking about
so in the area of cryptography we're
gonna continue to look at more intrinsic
s-- we're focusing on GCM mode so we
want to add hardware crypto acceleration
route PCM mode on both x86 and SPARC
systems we also want to transition the
default key store type from jks to
pkcs12 so jks has been the default key
store type since whenever we introduced
the key store API probably in 1.1 or 1.2
but it's it's always been a proprietary
format it doesn't interoperate with any
other systems so we want to transition
that to pkcs12 it also allows us to
bring in new new algorithms more easily
pika sis 12 is based on a standard and
it's evolving over time in tls/ssl we
want to add support for Datagram TLS so
running TLS directly over UDP we also
want to add support for OCSP stapling so
this is where the server the TLS server
is responsible for checking revocation
of its certificates attaching the OCSP
response to one of the TLS handshake
messages and this gives a great
performance boost because then the
client doesn't have to go out and make
the revocation check it can just check
the signature on the OCSP response
itself and we also want to add support
for the application layer protocol
negotiation extension that's a new TLS
extension it's it's gaining in
popularity as it's used by something
called speedy if you're if you're aware
of that
and finally we want to take a good hard
look at our security manager performance
and see if we can improve that you know
results it depends on the use case and
and different things but it's known to
add something like a 10 to 15 percent
overhead to your applications when you
run with the security manager we think
we can improve on that a lot we it
probably will never be zero but we'd
like to at least get to the point where
people don't run it because it's it
affects performance so just some
conclusion so security continues to be a
really important part of the JDK roadmap
JDK 8 delivered many important security
features improved performance improved
out-of-the-box security support for new
standards eight updates continues the
trend improving performance and JDK 9
security features are being discussed
and planned right now so please
participate and provide your feedback
and here is some information but one a
couple things I'll point out is the open
JDK security group is a great place to
get involved and hear about these new
features that were we're developing and
use that lista Jeffs and I have a blog
and a Twitter handle if you want to
follow for information on Java security
as well
and I do have to do the OL before you
all leave safe harbor statement and
that's it I think we have twenty ten
minutes for questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>