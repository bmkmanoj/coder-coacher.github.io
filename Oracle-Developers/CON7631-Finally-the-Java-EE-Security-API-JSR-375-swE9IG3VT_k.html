<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON7631   Finally, the Java EE Security API JSR 375 | Coder Coacher - Coaching Coders</title><meta content="CON7631   Finally, the Java EE Security API JSR 375 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON7631   Finally, the Java EE Security API JSR 375</b></h2><h5 class="post__date">2015-12-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/swE9IG3VT_k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning and welcome my name is Alex
kosowski and today I'm going to present
to you a jsr that we've been working on
called GSR 375
it's the EE security API KSR I am the
specification lead for the GRE also a
member of the Oracle WebLogic server
security team I just want to mention
first is the standard boilerplate slide
that everything I mentioned today will
just be for informational purposes
don't make any business decisions based
on what I'm telling you today so today
we're gonna talk about some areas about
this new GSR we'll start out by
mentioning what the motivations are
behind the new GSR then we'll talk about
the new GSR itself most of the
presentation will be spent on discussing
some of the ideas that the extra group
has mentioned has been discussing over
the last few months
then we'll mention about how you can get
involved if you're interested and then
finally we'll have some time for
questions at the end so the motivations
for the new jsr so why do we need a
security jsr in EE and you GSR for
security API well it all kind of began
the story began back in the summer of
2014 when the survey was sent out and
I'm sure some of you have seen this pie
chart before but basically they the EE
platform came up with you know just want
to know what do they what do you want to
see in EE 8 and they put out the survey
and there were 45 hundred responses and
that summer we saw this pie chart a lot
and one thing that popped out is pie
chart is that a fifth of the respondents
wanted to see improvements in security
actually 11% one to see security
simplifications and 8.2 percent wanted
to see improvements in security
interceptor so basically the idea was
we're getting the message that security
needs some help and we need to work on
security and the platform group was
trying to find somebody to meet up a
security jsr well what's wrong with Java
EE security well the community says and
here are some quotes I found online are
jean x who happens to be one of my
favorite bloggers says the ultimate goal
is to have basic security working
without the need of any
kind of vendor-specific configuration
deployment descriptors or whatever Reza
Raman is quoted as saying that the job
that each security model is problematic
in cloud Pass environments where
developers do not necessarily have easy
access to non-standard vendor vendor
runtime features and a self-contained
application is much easier to manage
what's wrong with Java EE security well
the e secure Java EE Security's viewed
is not portable it's viewed as abstract
it's confusing it's antiquated you know
the latest GSR in security was I believe
196 which is based on JDK 1-4 it doesn't
really fit in this new cloud paradigm
where app developers in that security
requires app server configuration and
this generally speaking it's losing
value to non-standard third-party
frameworks and once people move off the
e security and use these third-party
frameworks they're less likely to come
back to use easkey Java EE security so
what are we going to do well it's kind
of obvious what we like to do is we like
to plug the portability holes
we'd like to modernize the API in some
way by introducing programmatic aspects
like CDI expression language and also
make it useful make it more available to
work with lambda expressions we also
like to make it more app developer
friendly by having common security
configurations that don't really require
any server changes and also to have some
reasonable defaults and annotations so
that you don't have to do a lot of xml
configuration so let's go over the new
jsr a little bit it already has a
history the jsr started again as I
mentioned it was driven by that survey
back in the summer of 2014
within Oracle they were looking for
somebody to head up a new security GSR
so they came to the WebLogic security
team I volunteered for this job and I
kind of looked at the market and trying
to figure out what exactly is are the
problems with EE security and I had to
make a lot of proposals internally
Oracle to architects and engineers and
to on the WebLogic security group
eventually do some management and Oracle
eventually agreed to sponsor
a security jsr so as of August 2014 it
was approved with an Oracle by December
2014 it was approved by the JCP and then
the expert group nominations began the
expert group that we were looking for
we're gonna be a combination of three
different types of people we want to see
EE API veterans people had who had a lot
of experience with J SRS people who had
many years with struggling with the Java
EE security API because this is
primarily an API TSR we also knew that
there are lots of third party security
providers out there a lot of third party
security framework developers and
creators so we wanted to have some
people from the Java from people have
created these third-party frameworks so
we can like basically learn from their
knowledge learn from their mistakes and
incorporate some of the things that they
were working on into this new Java eve
TSR thirdly of course we need to have
people like myself where the java ee
platform security implementers had to be
involved like oracle Red Hat IBM so we
have some members of all three of those
different groups as members of our extra
group and then as of March 2015 we
started our expert group discussions the
expert group consists of 14 people at
this point there are people their names
you probably recognize I'm not gonna go
through all the names but they represent
both companies and individuals a lot of
them are bloggers as a lot of them have
created French security frameworks
and what was really interesting is that
there was a lot of pent-up kind of
demand I guess for a security framework
so there's a lot of a lot of ideas out
there that have been festering for years
and years and nobody really you know tap
into those ideas so the first month of
our expert group we had just as
explosion of ideas we had a lot of
activity on our mailing list and as a as
a spec lead it was kind of intimidating
because every day I'd wake up to like 50
emails right so you have you know a lot
of brainstorming going on
we had 237 messages on an expert group
mailing list in the month in that month
of March alone we had 81 commits and a
github playground for examples and
proposals and we had 24 tear issues just
in one month so we had a lot of activity
going on so for me I was like whoa
there's a lot of work but generally
speaking the roadmap for tip for the TSR
is this is pretty much the published ee8
roadmap is that we'll gonna we're gonna
we're attempting to complete the early
draft by the end of this year and then
why understanding it the early draft of
the sample we can actually have several
early drafts we're gonna try to complete
one early draft by end this year and
perhaps some others with a goal of
completing by having the whole thing
done by the first half of 2017 with the
rest of eight so the next area of the
program will be the majority of this
presentation which is all going over
some of the ideas of the expert group
we're considering and are proposing the
idea is kind of fall in these seven
epochs now on our on our jsr we have we
use JIRA we have epics where they
basically collect all these tasks
together and the ethics kind of fall
into these categories where we want to
first to find some terminology and make
sure that we have standard terminology
and then we want to come up with these
api's an API for authentication
mechanism identity store password
aliasing role permission assignment
security context and authorization
interceptors now it looks like a lot of
work right but we're trying to go across
the containers across all the different
areas we don't want to we're trying to
get all the low-hanging fruit you know
we're trying to there's a lot of things
have been they're easy to fix that we
want to kind of touch upon various areas
and just kind of you know
fix up everything in this one Oh
released that's relatively simple across
a lot of different areas now this list
doesn't mean anything to you you can
also look at it in a more graphical
point of view where an authentication
mechanism is something that takes a user
and great cha-cha so abstract user
credentials an identity store takes
those user credentials and tries to
validate them against some sort of
back-end persistence mechanism you have
authorization interceptors which
validate and an enforcement point on a
method let's say and it needs to have
access to a role or permission
assignment to determine what are the
permissions that that call current
caller has a security context is
basically you know their current
security context it might want to go off
and do logins they might want to go off
and check our current known users check
current role assignments and finally the
area password aliasing is kind of an
area on its own and that it's sort of a
utility so first they get a little bit
into terminology now you wonder you know
in a jsr the terminology is that first
part of aspect you see that you kind of
ignore it the glossary I know I know
what a principal is I notice subject is
it's okay but when we start our
discussions what we realize is that we
all had different terms for the same
kind of entities we had different we
were referring to we're all kind of we
all knew what we're talking about we all
knew that in some areas we called some
things we call one thing something is
called another thing so we realized when
we made if we read to make a really
container crossed container cross
container jsr that we really need to get
some consistency in the terms and be
able to have a constant consistent
vocabulary so and we realize there were
problems across various containers neay
where the same things were referred by
different names as well like for
instance that's something that gets
authenticated you know is that something
a user as in httpservletrequest get user
principle or is that thing a caller as
in the eg EJB context get caller
principle if we're going to create an
API we want to use one term not two
terms especially if we're going across
containers what is a group some people
say well obviously a group is a set of
users you know somebody else's say no no
group is a permission that's how I sign
groups and I get permission somebody
else will say well you know I sign
groups and roles and you know that it's
kind of kind of a
it's get the kind of synonyms of the
kind of not so we want to kind of clear
it clarify that a little bit too and
finally this is kind of a almost like a
joke on the TSR and that what is that
something where identities are stored
right we found a whole bunch of names
that basically mean the same thing this
is uh something that's called in
WebLogic a security provider it's also
called a realm it's called an auth
repository and off store jazz calls it a
login module it's called some places an
identity manager reson calls an
incentive cater a spring calls a tent
occation provider and then also it's
referred to as an identity provider so
all these terms meaning the same thing
so our first goal is to really come up
with some consistent terms and have it
be the official terms of our jsr in the
area the next area we're gonna talk
about is the API for authentication
mechanism now the use case here is an
application would be managing its own
users and groups an application would
need to authenticate those users in
order to assign roles and it would
Ascenta Kate those users based on some
application domain so application domain
model it also may be an application
wants to use authentication methods that
are not really supported on the base
server like Princeton for instance Open
ID Connect and once we all have a way to
add that authentication method for its
application and deploy with its
application on various servers even
though the server itself doesn't support
it also perhaps an applique of the
developer wants to use a portable EE
authentication standard that will work
from container to container container
without requiring any third-party
libraries currently there well there's
proprietary server support there is
third-party security frameworks that
provide authentication of course like
Shiro and stream security and then there
is a thing called Jasmine it's the Java
authentication service provider for
containers has anybody here you heard of
jazz vic has anybody here use Jasmine ok
good good ok great
and it's not surprising because Java
kind of kind of weird
so jessica is actually HSR it's jsr 196
it's currently in a maintenance release
and it's actively being maintained it is
a standardized portable thin low level
authentication framework that currently
exists and is currently usable within
servlets it's extensible from within an
application and that and it also
integrates right now with a container to
build the authenticated subject in a way
that the the server can deal with in
other words every server has its own
little subject format it will actually
have as a mechanism for it for it for
populating that subject in the server
specific way and it will also implement
most-most authentication method methods
corta jasper gives a thing called a
server off module a server off module is
really just an interface and it has five
methods which are pretty much
straightforward is what you'd expect you
have an initialized method you have a
method a method for validating a request
you have a method for determining some
metadata on support in terms of what is
this methods of module support you have
a method for securing a response and
then you have a cleanup method for
cleaning up the subject but the reason
why you probably have never heard of
jazz pick and it's not really that
popular is because to use Jazz fit as an
application developer you have to create
six classes you have to actually create
six different classes there's no other
way of doing it it's a completely an API
sort of interface and to do to install
traffic per application you have to
create a servlet context listener an
auth config Factory which then creates a
auth config provider which then creates
a server off config which then creates a
server all contexts which wraps up a
server off module right they actually
call this a factory factory factory sort
of pattern and when I spoke to the spec
lead about in a ygg goes way well they
say it's really meant for the server's
to deal with because they want a lot of
flexibility the servers but they never I
guess in the GSR I never got far to make
it really simple for applications so our
first proposal is to um for the for our
jsr is to build upon a spec and making
sure that when you want to install a
chassis API
Majestic module you just have to create
one class a servlet
context listener and in that one class
it would look something like this we
would create a helper called the JSP
caliper and what you would do is just
register you have a method like register
server often module where you would pass
your your Sam your server off module
which is in this case a token off module
they would probably be another parameter
for options you know paramah
parameters for the actual server off
module itself and then we just pass
along a server comment servlet context
and so in this way you can actually
register a Sam using programmatically
with one class and once we're talking
that want to just go down the road go
further and say what's this just define
an annotation so we were thinking
defining an annotation where you can
just define an annotation that would
that would declare what server off
module you want to use in your
application and then you just basically
name it there there would probably be
other other parameters on the annotation
but the idea is that we're investigating
seeing we can just use an annotation to
to specify a particular server off
module to use and your your application
now again what we're doing here
it's just building upon the existing
technology this is really not new in
terms of you know creating a new
authentication mechanism it's out there
already you can use it today it's just
that we're making it easier to use now
as I mentioned a server off module only
has five methods and you know five
minutes or five methods so in this
particular example of a basic
authentication server off module which
does basic authentication you have to
still infinite five methods and who
really wants to do that all the time so
jazz make itself has different profiles
there's actually defined profiles in the
spec where you can have a servlet
profile I think there's a jazz profile
now service service being very popular
you can leverage the servlet profile and
make certain certain assumptions about
that what defaults and what kind of
implementations you want to use kind of
like right out of the box and if we take
advantage of that we can actually
standardize on an abstract base class
that will help you along and create it
so that if you want to create a service
module you can just define one class one
method and what you'll see here is that
also the parameters on the parameters on
the Sam on the server oath module is
actually very generic there's no real
typing it's just like you know
passing around we're also adding in
passing in a server AHS
httpservletrequest and servlet response
and a special context that let you have
access to areas of the server requests
that are that are relevant to the
particular call additionally if you were
into as pic works you'd know that the
way that you get back information into
the into the container is using a
callback handler and this is a very
common pattern that's using Yui these
callback handlers and what you do
basically is to create an array and you
put your your data you want to put it
into this array and then you call a
special handlers that the container
gives you and then it will populate the
container with stuff in this case it'll
populate your container was the subject
information that you've you specified
after the authentication and that's also
a lot of it's like ten lines of code
right so we would make that simpler
instead of having that would typically
be at the end of the request in this
case and what we would do is make that
simpler by just having a method that
would assemble that for you
automatically and automatically return
the proper value for the servlet so in
this case even though we have a servlet
off module would have five methods and
these methods are relatively simple
we've reduced it now to one method and
even that one method we're doing things
that are pretty much boilerplate that
would just be ceremony actually in the
interface and simplifying it down to one
or two calls now these would be standard
helpers and this that means that these
things will be available on ie 8 now
once you go down that road you can see
how creating installing modules of
server wealth modules becomes very you
know very easy right because you just
have a module you have an annotation
boom you've got your your server off
module well that kind of opens up kind
of a market doesn't it because then you
can have third-party providers or open
source providers that want to create
these server off modules and you could
create say an open ID connects like
there is an open ID connect I have
actually use this actually an open ID
Connect Sam that you can just basically
specify you want to use this and it'll
just work and other things too like
Kerberos or whatever other type of
authentication mechanism you want to use
so that's kind of cool now we're not
going to actually we're talking we're
thinking in the jsr of
and rising Sam's sum Sam's but we're
going to see how time goes because
there's a lot of work and there might be
a later version the other thing too I've
also been some of the experts have
mentioned to me you know you want to
kind of let the community
consume the spec a little bit and get
some feedback and then this way we can
kind of work that in on the next version
too because there'll be things that come
out that we just don't even realize
finally in the authentication area we
wanted to find we want to take advantage
of this cool thing called CDI events of
course if you're familiar CDI you know
that CDI have these events and you can
register them with observers and there
are some standard events and
authentication which you really could
take advantage of you could there's a
you can take advantage of a post
authenticate event a pre authenticate
event a pre logout event and a post
logout event and you could using CDI you
just observe these events and then
you'll be tied into the authentication
mechanism and do things like tracking
the number of logged in users or maybe
tracking the number of failed login
attempts perhaps you're using some sort
of remote ID store to be able to do a
remote authentication and you want to
you want to mirror a local user while
you're doing the authentication you can
do that too or maybe perhaps you want to
do so load some application specific
user preferences upon a successful
authentication you could do that too
using this so you know using CDI CDI is
actually very good with security because
security for a context-based and so is
so is so a CDI so it has a really nice
synergy there the next area we're in a
weak sort of investigating is something
called an ID store so the use case here
is that again an application manages its
own users and groups it there's a need
to access a repository of identities
these are application to find identities
like users the users may be stored in
some applications specific repository
like an LDAP or database and they're
also users are managed by the
application without any access to any
server configuration there actually was
a survey question about this specific
item should we standardize on
requirements for simple security
providers and their configuration
security providers have you dig into the
question that's one of those term thing
that security providers actually refers
to it something like a Dendy stores and
65% say yes so we've decided to look
into this a little bit further currently
there's no Java EE support this is
something an area that was always
relegated to the server a server admin
you know the server admin would take
your deployed app and map a go a role to
a user and our group and it's all kind
of in the unnies on the server side it
was handled so right now it's only for
prior tarry server support for this and
of course third-party frameworks will
provide you with an API for users and
groups the idea behind an identity store
is just this you know this is an area
where you get to caller credentials
through some authentication mechanism
like a spec for instance then those
caller credentials were sent to the
identity store where they are validated
and the validations could occur by
either accessing a database or a file or
an LDAP or some other form it would be
an extensible interface and then in
return you would get if it's validated
you would get a caller name and groups
it was it was fails you get notification
that it's failed so that's basically the
operation when you dig into it in a more
interaction sort of point of view you
have a credential it would call a
validate method on the actual identity
store and then the identity store would
return a credential validation result
which would give you the current status
the caller name and then a list of
groups and the way this was looking code
identity store would be an alternative
CDI managed bean and what you and that
would be the standard identity stores
that we would we would define and what
you would do is you'd inject an identity
store then you we have also were
standardized them some credential types
so you can create a credential called a
caller name use caller name password
credentials now you notice it doesn't
say Pat user name because then in a
terminology section the eg expert group
decided that we're going to call them
callers because you can have people
logging in that aren't people they're
actually no devices or whatever so we're
calling it a caller so caller name
password credentials our paths are San
Shi ated you pass those credentials into
the stores validate method and outcomes
the results and that's all you have to
do and then you just interrogate that
result by saying you know is it valid
and it
valid you can pull out the caller name
and groups and then apply that now if
you're using Catholic you'd apply that
to a Jasper callback handler and it
would just go into the container at that
point and then from that point the
container knows and you can use it in
servlets or we know wherever and chit
and II want to use it and if it fails of
course you get a invalid response and
you could you can put up an error
message or whatever you want to do
whereas thinking for standardizing some
credential types as I mentioned they
work there would be a base credential
type called a credential which would
just basically be able to clear itself
and determine if do some have an API for
some self validation say like signature
checks and things like that then we
would have an extended standard type
called a caller name password credential
which would let you have a password
we're also thinking of defining a
standard basic authentication credential
since basically authentication is very
common you would want to just pass the
basic authentication header into the
credential and have have the standard
have the have the GE you know care apart
the the basic credential header and pull
out the username and password you know
it's all very common boilerplate code
why do you have to rewrite it a million
times and then also a token credential
now at this point that cook token took
the token credentials a little on we're
still working on it but the idea here is
that it would rat it would be a base
class to say a job you know job a JSON
web token or something like that and and
that's kind of that's alright it's kind
of a we're going with that but we have
to still develop that idea in terms of
identity stores we want to standardize a
few identity stores and these are really
if you see they're kind of math to
persistence mechanisms so perhaps a JSON
file identity store an LDAP identity
store a database identity store an
embedded identity store which actually
would be an identity store in an
annotation and then the Jazz at any
store which I'll talk about in a few
minutes and all these standards standard
any stores we were considering having
them be CDR CDI alternatives so what you
could do is you can in your CDI context
go into your bean XML and say you know
in deployment I want to use this one
yeah I want to use the file the JSON
file
sorry I'm gonna use the JSON file
identity store in development but when I
go to production I want to swap that out
and use a database at any store in
so you know it makes it so that you can
use the same code and the den they store
changes using CDI based on your your
deployment the way you would create
these things is that you'd have so it's
something like because it data source
definition annotation okay so we'd have
an LDAP identity store definition you
provide parameters about the LDAP
configuration
you know attach it to some class and
using a standardized CDI extension we
would create under the cover as a CEO I
mean a an in any store implementation
that's activated similarly for a JSON
identity store definition you have
something like that where you have a
file path and you know you need to
define some parameters for a JSON
identity store for an embedded identity
store now of course you don't want to
have embedded data in your code but if
you're you know quickly writing some
code you want to have some in a
development environment and you want to
have some users to test your application
you can create an annotation that would
have credentials you know names
passwords and groups all built in and
available for you to use and selectable
and then of course a database identity
store a definition where you provide
again datasource lookup information your
caller and group queries if depending on
how your configuration is maybe we want
to pass along a hash algorithm and hash
encoding scheme so and you probably know
if you've dealt with others third party
framework so you probably think it's
seen these things all before which is
great because this is you know de is
about standardization so we're trying to
pick the best of read out there and
trying to really bring that into the end
of a platform finally we have this this
thing called a chasse identity store now
who's heard of jazz jazz hands okay
great all right so jazz jazz is the java
authentication and authorization service
and jazz is a sort of a standard but
it's not a standard is a standard
framework for doing authorization and an
authentication with these things called
login modules but the problem is that
every server implements it a little
differently and every server populates
its subject a little differently so even
though there's supposed to be a standard
you really can't move a login module
from like a boss to WebLogic ivme they
just don't go across right and you know
so but dogs are people who've made
in jazz and in login modules even for
their own little throne applications so
we kind of thought it wouldn't be cool
to just kind of wrap up a jazz process
inside about jazz into its identity
store so that when you did a validated
method it would go through the Jazz
process where he would actually go and
call the login context and you pass in
on a parameter you would it would then
you know a perform login on each of the
login modules a login modules the module
is used in jazz that performs well
validation and other things so it will
go across and what you know of course
honor all the control flags that would
basically execute jazz but on over the
control flags and then eventually it
would commit and popularly you get a
populated cell you got a jazz so we also
have to standardize a way of how to get
that jazz subject you get the
information of the Jazz subject because
of course there's no standard around
that and that's something we discussed
about about two on the Oxford group but
we're it doesn't look like we're going
to standardize on that maybe well we're
working on that word but the closest
thing we came to is something called a
jazz subject principle resolver now this
is a class that would be part of that
would be used by the Jazz I did any
store that you could pass in you know
basically it's a kind of a call back
where you say I'm giving this subject
you just gave me after committing your
your your law your login module process
you know tell me which give me the
caller gave me the group's because I
don't know where they are in this
subject and it would you know basically
the implementation you get for jazz
would tell you you know not only get to
provide these login modules but you have
to also provide a jazz subject principle
resolver where it would tell you okay
here's we're caller and here's a group
then we can go on and pass it along into
the return value of the identity store
and that'll just work now with CDI
additionally if you saw the identity
store you only saw one method it was
just the validate method and you know
there might be other types of
interrogations you want to do with with
identity stores so we're also
considering on standardizing some
additional interfaces like a caller
store or call a roll store group store
these are these are this little
interfaces that add small and criminal
mixing methods so that if you want to do
some additional things with an identity
store you can they wouldn't be required
not on some some standard dinosaurs
would have them some would not but they
would be available in case you wanted
them and also if you notice this is all
read that all the interfaces for a 100
release will all be read only we're not
we're not at this point considering
doing any type of updates because and we
started going down that route but the
idea was that applications already have
a lot of optimized queries optimized way
to update updating their databases and
and any stores and we kind of thought if
we went down that path it would just be
a lot of work to figure that all out so
we kind of thought at this point for a
one-hour release we would just do handle
the credential validation and the read
only aspect of the identity store and
the reason why we're doing these
optional interfaces is because we want
to avoid a problem that Jack had a long
time ago an old an old server sort of
security interface where we have you
know we want to didn't want to have one
identity store that required you to
implement like 20 class 20 methods right
we wanted to be able to just feel that
mix in the capabilities that you need as
you're you know as you need it as
available so a quick example for how you
use these optional interfaces you
basically just say you know you have
methods for a caller stories have a get
callers method where you can have a
regular expression method regular
expression passed in and you get a list
of callers you know the regular
expression method for for groups to get
groups and then you could do this
interrogations like you know here's a
caller and a group and determine whether
that's true now this is this is not
going to the Kint container this is
really just a wrapper around your
persistence mechanism so it's you know
it's questionable whether not this is
that useful because if you're already
accessing your data store store directly
then maybe you just would continue to
get access to your data store directly
the next area we're going to think about
standardizing is an area of password
aliasing yeah use case here is that an
application uses password to access the
resources like LDAP and databases these
are our passwords that are stored
annotations and are also stored in out
and deployment descriptors you know of
course you don't want to store any
passwords in your endo deployment
scripters or your annotations so you
know you really kind of want to avoid
that problem but we definitely need an
ee a portable way to protect store
passwords
this was a survey question should we add
support for password aliases including
the ability to provision credentials
along with the application and about 58%
of respondents said yes and this
actually was a feature that was an EE 7
that was deferred out because of time
currently there's no EE support for this
in in Java EE although there are
proprietary server support right
GlassFish supports this and then when
you use third-party frameworks
you'll often see something like embedded
password encryption but nothing like
aliasing because it's not really
countenance to the Container so the way
it would look is something like this for
an annotation for instance and a data in
the data source definition annotation
rather than having this the password
right in line you would have something
like an expression that would be
resolved by the container at lazily so
you'd have a key an alias equal to a key
and that key would refer to a credential
store that would be deployed with your
application another dual of this would
be in deployment descriptors and in
deployment descriptor is you'd have for
instance a data source where the
password would be basically an alias
again an expression again that would be
resolved by the container also and the
way it would work is something like this
you know you'd have this alias the
container would then resolve it at the
last minute when it needed to be
resolved and then once it's been used it
would be cleared up out of a out of
memory space the aliases themselves will
be stored in an archive something like a
jks file that would be deployed with
your application that would be an
artifact and this artifact could be
manipulated with say like a key tool
kind of thing but we're not really
specifying that portion of it we're
going to make recommendations that kind
of falls outside the API realm but
that's kind of the idea of how it would
be used so it will be for configuration
for annotations and deployment
descriptors secure credentials we
archive for bundling the alias and the
actual password values with the
applications the platform would then
consume the country the credentials
archive upon deployment and then we
would specify some-some
standard tooling for crud operations on
the actual credential archive something
like a key tool operation the next area
in the API that we're going to explore
is the group the role and permission
assignment area so the use case here
again you can see this alive repeating
this a lot applications manage its own
users and groups an application needs to
assign roles like authorities and
permissions to users and groups based on
some application specific model these
users may be stored in applications for
specified repository and the users want
to be managed without the applications
under manage these users without any
type of access to server configuration
there was a certain question about this
- should we standardize group - role
mapping and about 70% of the people said
yes so it seems like it's a pretty
popular feature among application
developers there is no Java EE support
for this this falls into the traditional
you know the Java server administrator
takes care of this when you deploy your
app that they'll take care of the
mapping between your role and your group
and there's nothing wrong with that in
some situations is that we're trying to
now address the more application centric
type of developer and so there's only
proprietary server support and
third-party security frameworks however
do provide no role and authority
information api's which is what you'd
expect so the obvious answer is what we
could do is in web.xml
orthos kind of application standardized
deployment descriptor is have something
like a security role map built-in but
you can map role groups and roles now
these would be groups that are defined
by the user okay another thing that's
been very popular we actually had a lot
of discussions on it zero that we have
about this is a one-to-one group - role
mapping and this is something that's
actually standard in available I should
say in GlassFish where you'd say when I
define a group named admin or maybe more
resource base like printer a view
printer a printer view it would
automatically be the name of the role
that corresponds with that group
so in our previous example where I
mentioned you know you had an embedded
identity store definition this identity
stored actually does a little bit more
than just define it an identity store it
actually defines the permissions because
you'd have the call or an a in the
password and then the groups now if you
had one to one group to role mapping
enabled those groups are actually going
to be the role names and you'll be able
to define you know for your development
environment to be able to involve define
the permissions and the roles and what
that allows you to do is having
one-to-one group to role mapping it a
little bit more than just a convenience
it actually puts a lot more power in the
application developers hands and kind of
takes the server out of the loop so it
enables something called you know and
they enable you to do dynamic
application based roles so that for
instance you have an application that
has a bunch of root users that are you
know basic users on your application and
you want to convert them into Premium
users because they paid you know $9.99 a
month or something you can actually do
that using this mechanism with the
application and this is actually being
done now another using third-party
frameworks you can take your app and
your app we've done update its
application specific database domain
with the new groups and then the next
time the caller role the next time the
caller logs in Jasmine could use would
use we call in to the dentist or to
validate their credentials their
credentials would hit the same database
get the same groups assigned past those
credentials those groups and the color
name back to Jasper gasps Ruth uses its
already existing hook into containers to
go apply that to the container and now
since containers say that groups and
roles are the same boom your container
gets the new roles so it all kind of
it's actually a little extension of what
goes on now but allows you to have the
ability to have flexible dynamic
application roles role changes the next
area of if interest in our ESR is
something called a security context and
this kind of seems kind of obvious when
you first think about it you know an
application needs to access the security
API you know you want to be able to get
to the authenticated user you want to be
able to check roles you want to be able
to invoke a run as you know and the
application would need to have the same
API
the access to the security context
regardless of the container right if you
notice in different containers there are
different interfaces that kind of do the
same thing in currently in Java EE
there's no support for this every
container is kind of its own little
island however of course third-party
security frameworks do provide a
security context this is kind of core
into the way they work right you can
just access the security context and
find out you know different information
about your current logged in user so for
example in an EJB if you want to find
out if the current caller is in a role
you have to use a session context just
to interrogate the session context say
is this caller in a role right so your
code has to know where it's being called
if you're in a servlet you have to use
the HTTP servlet request and call is is
user enroll you know and ask the same
question so you have to know that you
know you're in a servlet and call a
different method and the cd-i being well
you can't do anything because there's no
security context class and the secure
and a CDI right now and in jax-rs there
actually is a defined security context
that you can use it only works within
jax-rs but it is you know a great a
great way to go but of course it's not
standard across the container and it
you'd use his caller and role to
determine the same kind of thing kind of
thing so what we're proposing is a
standardized security context it would
be a CDI bean that you could inject and
it would give you some of the
functionality that you'd expect you'd be
able to determine no get the current
user principle interrogate whether
another current user is in a role get
all the roles for a current user check
whether the nights
Ascenta kated actually invoke a login
with the authentication mechanism a
logout and do a run ass and there's some
other we're actually working on
developing this idea through but you
know there might be probably other
methods where add or delete this is kind
of a preliminary list and what you'd be
able to do with this managed secure it
managed bean security context is
anywhere in Java EE any managed bean
where the CDI servlet EJB jax-rs you'll
be able to inject yourself a injected
security context and be able to use one
method that would that would work across
all containers now effectively behind
the covers is actually probably going to
call back into the other functionality
depending on the container but this is
kind of a sod that gives you a nice a
nice uniform interface over that the
final idea area of ideas that I'd like
to talk to you about today is the area
of authentication all sorts
authorization interceptors the use case
here is that an application needs to
restrict specific methods to authorized
users the application model has there's
application model based rules to be able
to make acts that are needed to make
access decisions and simply a role is
not enough you know to having a role is
just a role its string you want to do
something a little bit more more
calculative so there was a survey
question about this should we should we
consider adding security interceptors to
Java EE eight 79% said yes and should we
simplify authorization by introducing
expression language enabled
authorization annotations and 67% said
yes so the seems to be something that's
wanted by the community currently EE
authorization has no rule-based
authorization it's only role based
however third-party frameworks do have
rule and role in permission based api's
so one example one idea would be to use
expression language expression language
has a nice string based language that
allows you to have access to managed
beans and CDI context and you can you
can actually have access to a security
context and invocation context and
create string string based expression
language based rules to evaluate at
every method access so in this
particular case not only do you check
for whether or not a manager has a role
but whether or not it's currently office
hours in order to transfer funds but
then you think well gee I don't put
strings all over my app you know it's
something to be really painted but to or
to manage
so we're thinking of also sanitizing a
may of centralizing this information
perhaps in an LDAP and having interface
of an LDAP or you could rather than
specify strings everywhere you make a
reference to a to some sort of LDAP
entry and attribute and be able to
access it that way
defining it with an annotation and then
you'd have a an annotation like like
this which is performing the same basic
function except this way you have a
reference to a rule a rule source and
then you make a specification for a
specific rule and index additionally
there's another area we're thinking of
standardizing something called an access
decision voter and you've probably seen
this in other frameworks this is kind of
the same idea and that's rule-based
except that it's a user-defined class
for making access decisions in this case
you'd have we have a standardized
annotation where you could pass in an
implementation of an access decision
voter if it if it returns if it's
functional interface returns true you'd
actually have that you have access to
that particular method an example of an
access decision of voter here is an
account access decision voter which
implements the access of student voter
interface it has a method called check
permission that would be part of the
interface and you would be given a
current calling context and from that
calling context you can you can make a
decision of whether or not you want to
allow that user to have act well a lot
of they call it have access to that
method if so then you can return a you
know no violation response and if not
then you can give the reason of why the
access would be denied so those are all
the ideas we have other ideas of course
and the problem is that we have a lot of
ideas and we only have a little bit of
time to do them all and I'm sure we can
think of a lot more reasons why you know
other things you might want to do with
it with the API but you know these are
the kind of a starting point that we
want to work from and try to develop
certainly if you have any if you have
any other suggestions you don't you know
you don't agree with some of the things
some of the directions are going on
please please get involved and let us
know
can contribute to our jsr we have a
project page
it's a JIRA Java project page java.net
project page it's kind of dashboard
tells us our current status where we are
with our with our GSR we also have a
user's list if you're interested in
subscribing to our users list please do
you get all the messages from the expert
list and then if you post questions
experts will get back to you also we
have a github playground with with our
proposals we have a lot of we have
proposals on most of these things our
latest proposals are having to do with
the identity store we actually have a
Google Doc on that which you can access
by the way from our project page our
project page actually has access to our
our github playground our Google Doc
folder which has a lot of proposals on
it and then we have like you know some
events and yes I guess it's basically it
but between all that you have a lot of
access to the kind of thoughts that are
going on some of the work that's going
on in the jsr so you know by all means
you can do some pull requests you can
you can let us know if you have any any
ideas submit some ideas if you're
interested in learning some more and
also getting involved and learning some
more about this stuff we're having a
boss tonight at the Hilton it'll be you
Ivar who is another expert group extra
group member and myself will be hosting
a boss tonight please show up if you're
interested I know it's competing with
the Java EE poff that was a scheduling
problem but please you know if you're a
real security geek and you interested in
this stuff please please stop by for
just we'll talk about this also on David
Blevins is another one of our expert
members he's going to have sort of a
related buff on on ee8 and kind of the
kind of thoughts and maybe you might you
might have on ee8 in terms of API
updates and I think he does mention our
API in there also so that's it thank you
very much any questions okay
was a call
SRP I'm not familiar with it may cross
site scripting okay I think those that
there actually is a JIRA on that on our
on our group and I think the way we were
going with that was that it's kind of
really specific to particular containers
like servlet I think is addressing it I
think MVC is interesting it directly
because their libraries are really
geared toward the media the actual
national transport media if it's
something that we can standardize at our
level they can also say cross
application across the platform we would
it just seems like it's really focused
on the particular particular protocol
you know I know that I know that the for
instance the spec leads from MVC and
sort of would have talked to us about it
but I think they've already have a lot
of things in place for that and I think
that's something they're working for ee8
so you know it's almost better for them
to focus on that because they can deal
with it in their own protocol right yes
yes actually that something that came up
and actually it's even even deploying
key stores together with it with the
with the application but with something
we're gonna look into the reason why I
specifically mentioned password aliasing
is because there was a feature that was
left over from EE 7 so I want to make
sure I dressed it but that would be that
would be something we'd have to look
into
some smaller containers so you know so
it would be passwords for actual for
keystore piece or axes keys P access
that kind of thing in a JK S key store
or whatever yeah okay well look into it
we have not thought about that I know
it's come up
I know it's come up in terms of being
able to standard oh okay I know it's
come up in terms of standardizing some
of the server off modules that we do in
authentication but I know and two-factor
authentication has definite come up also
in the discussions whether again the
first revision 1.0 is trying to get all
the easy stuff out of the way so I don't
know that'll be something will address
in 1.0 but it's something that's
definitely on the radar right okay like
I didn't like being able to do I then
assertion like that kind of thing well
you could do certificates using I think
jaspe collages support the certificate
so you could do that sent occation that
way right so you can create a server off
module that would be able to handle
certificates there's actually Adam so
you know traditionally in servlets you
have the you know the classic basic
digest form you know clients or
authentication that's built in and I
think there's a move either I think
we're trying to figure out whether this
is going to serve with spec or our spec
but basically I move to move that all
into standardized a spec sort of server
auth modules so that you know not you'll
be sort of in the same realm when you
wouldn't necessarily put it in your
circle it you put it actually in you
actually register a SAM it would use it
that way so yep
well there was a we were standardizing a
group troll mapping by in in the web.xml
- you know we're exploring to make to
make it so that it's a deployable
deployable artifact in in the actual
extended web.xml let's say that kind of
thing but you mean like other than that
only I cross to me like another domain
oh okay yes that would not be a 100
feature
I don't you mean yeah like like going to
another Dominica like a connect right
yes I know you mean yeah yeah yeah
that's a mean I yeah that's not
something we're gonna there's a lot the
whole the whole area of that of that you
know remote authentication some
interacting with identity stores using
Open ID connect you know auth - you know
that's those kind of standards we're not
going to try to attack in a 100 in one
container I know I know what you mean by
uh but that's not no we're not gonna
define something like that notnot 1:08
propagation I get any propagation that
kind of thing I like if you a rest call
and you want to make another rest call
and you you want to take it
authenticated token and move it along to
the next I know that's actually you know
that's kind of a hot that's the top is
being handled by all the commercial
service now - I think what logics
working on that right now so you know
once that becomes more of a stand I
think also there's a lot of standards
around that with rest in terms of
passing identity tokens around I mean
there are standard tokens like shots but
just in terms of being able to have an
authentication across using something
like an open idea Connect or it's maybe
something like an oauth2 kind of thing
you would um I don't think there really
are a lot of standards turned with just
going machine to machine like that
unless you know of one you know
until that's really kind of ironed out
we really can't pull it into our
standard right and as I said it's like
we're
do the simple stuff first I wanna yep
yep it's come up and we're going to have
bring to probably look in the beyond one
oh we own version one we're still
thinking about what we're gonna do with
one out but um multi-factor
authentication and how it actually works
if it can be done in a way that it can
be if you've done this to internet in
the Jass exam for instance then that
would be something that you know we did
some the third party could actually add
to EE and have it work but um we're not
really attacking considering attacking
that right away well it would just be I
guess the idea there's you'd have a
place to centrally store it so it would
be it's actually it's independent I
think of the web spec it would be
something that you would you have
another location
another replaces a way of accessing a
repository to to store those strings
right oh oh
okay right I understand right actually
will come into play with my performance
problems yeah I see a lot of performance
problems with the expression language
approach because you have to like
reparse that or you have to get you
something that milli you know you can
have like a lot of these method calls
you really want to reap our sin you know
reevaluate at all time right right
exactly right that's exactly right yes
right I
in line birthing field office I know
because then you look at the code you
don't know how things secured because
they moved or somewhere else but you
would put them in line that's an
adaptation then you know exactly the
rules and they say oh wait I can't
perform this function because I know
these rules change the definition that
rule right I think you'd have to you
have to be smart about you know giving
it a good name you know being able to
say you know give it like a resource or
resources action name something like
that that well as you get further down
that list there are things that are less
and less define like in a week we
forfeit terminology at authentication
mechanism at any store you know when you
get toward the bottom of the list we're
still it's like a lot of it kind of gets
lower cannot so okay
oh one more okay
I mean like additional caller attributes
okay there actually is an optional
interface the optional interface for
caller has an interface for call or
attributes as I get caller attributes or
something and then you can specify you
know what after if you wanted to get
back a collection okay all right great
all right oh it's uh it's well the focus
has been on servlets the expert group
okay this is all driven by the expert
group and all the expert groups have
been a lot of the works being done in
servlets it doesn't mean we're not going
to or not so we're not going to support
this in ejbs
it's just that you know i guess what you
see here if the I guess the each of
these are also see the i-beam so you'll
be able to do in some areas it depends
on the actual feature I guess like yeah
yes like an EJB you say well this user
has a certain role but this users coming
through this application and so that's a
different role so you might be one
interested in know what the caller
application is plus who the user is so
for me that's by compressing them you
just basically now they're the same
identity well any well in epi I mean in
naming the call in the user the API
basically uses these are that those
names interchangeably right there's no
separate concept right I mean it's just
basically the authenticated caller I
think it's the Technic eight identity is
called a caller or user just the
identity yeah right
well that that you still be able to do
that it's just that you know the API is
just gonna call them all callers
basically right all right Oh handling
tokens no no okay so it's just it's
there's a lot of standards around that
right so um you know the standard is if
we're gonna we'll provide facilities so
you can actually you know subclass and
create your own token handling because
we don't know what the rules are there's
no standard rules around token handling
like that right so we can provide a
token based credential that you can
actually think maybe it's a it also can
be extended as a shot you know if you
want to give that's what you're using
right some people don't even use jaws
right some people just use opaque
strings or something like that right so
um because there's no standard on that
we really can't do much about that but
what we can do is provide you with the
facilities to create your own sort of
sort of thing right and that's that's
kind of what we're trying to do again if
there was a standard we would we you
know I know there's a lot of work being
done in that respect a lot of that that
kind of work with rust and if there was
a standard around that we would latch on
to that but we can't you know this it's
so many different you know
customizations out there you really
can't know what's popular right yes yes
yes you'll be able to excel these
standard implementations are just
standard implementations you can create
your own identity store that accesses
some arbitrary back-end that does
whatever you want to do and you can just
you know we'll provide you a way of
making that available and you just
inject it and you can just select that
using a beam XML or something that's
that's the goal okay all right well
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>