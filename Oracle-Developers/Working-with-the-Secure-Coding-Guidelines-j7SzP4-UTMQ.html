<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Working with the Secure Coding Guidelines | Coder Coacher - Coaching Coders</title><meta content="Working with the Secure Coding Guidelines - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Working with the Secure Coding Guidelines</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/j7SzP4-UTMQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we are starting with a little
introduction then we go into
vulnerabilities then we talk about the
secure coding guidelines and the anti
Heather a little summary about those so
why learn about the risks of in secure
coding secure coding guidelines and the
anti patterns they address have to
consciously avoid such anti patterns to
help you to switch perspective to reduce
the attack surface that your application
may have and it's an invitation to think
like the attacker to anticipate what the
bad guys may want to do with your
application and your infrastructure and
for that you want to identify violations
of the guideline and the big spots you
help target audience so who have you our
programmers 90% okay
security guys five and the rest are risk
managers no cape so the risk managers
are not here today so let's dive what we
into what we want to avoid we want to
avoid vulnerabilities and
vulnerabilities often come from insecure
coding and why talk about
vulnerabilities why have this discussion
because computer security is hard the
attacker has to only find only find one
network flaw was the defender has to fix
every flaw which was
nice quote from the men versus strong
handshake and therefore as the
defenseman you always have to be aware
that only one thing can break your
entire protection environment and
enhance the attack surface so
vulnerability is a flaw or weakness that
could be exploited to violate the
systems security policy as written down
in the rc4
internet security and the courses can be
in the design for the assumptions in the
application architecture in the
implementation in secure programming
practices anti-patterns
or in the composition and setup for
example when the admin installs the
application on a Friday afternoon he may
just use the defaults and then go home
and then the application works what
types of vulnerabilities are out there
there are exploitable vulnerabilities
and security weaknesses what we call
them defense and depth issues the
exploitable vulnerabilities they always
have a direct impact they provide an
attacker with more privileges and they
should have has been assigned by a
policy that results in a breach of
confidentiality integrity availability
for example a buffer overflow or a heap
overflow that leads to an always
takeover is an exploitable vulnerability
there are security weaknesses which are
not directly exploitable
but you could have a chain of those and
so those can result in a exploitable
vulnerability or defensive type issue
can aggravate simpad often attack so for
example if you're not following the rule
of lease privileges you open gates to
attack us that shouldn't be open
keeping Java secure what can you do
there are security patch updates
critical patch updates that are released
that help you to keep Java secure there
are also security alerts issued whenever
fix cannot wait until the next CPU date
so keep in mind 15 October is your next
patch day and then we will have a nice
new Java version and with each CPU there
comes a list risk matrix and here you
see a risk entry from the risk matrix
which is for vulnerability and that has
a number CVE 2010 for 476 and who
remembers CVE 2010 for 476 it was issued
on Friday in February and it couldn't
wait for fix it was in double past
double back if you remember that and
that had bass call 5 it had Network
accessibility low complexity no
indication and we will read later
bothered guidelines and examples so how
can we avoid vulnerabilities there are
general principles so vulnerabilities
often come from anti patterns that you
have in your programming and you should
avoid those they may look beneficial in
the first place but they imply bad
consequences there are negative
counterparts to design patterns but as
they are bad examples I still have an
educational value for example if you
implement speed optimized methods but
you skip for example input validation
for security practices you should avoid
those anti patterns but they are not set
in stone and therefore there are
exceptions there's a telephone somewhere
make sure you understand the
consequences if you avoid them because
then your application will not be as
secure as it could be if you come from a
C C++ background there are also anti
patterns for example you in C++ you have
memory exploits heap and buffer
overflows
but the java runtime environments
manages memory safely it performs
automatic bounds checking on average has
no explicit to point arithmetic but the
java runtime environment often executes
unplugs therefore it must protect
against access to unauthorized resources
for example files or sockets that could
be very helpful for an integral
therefore it results a different set of
coding and appearances in C++ but if you
come later in this afternoon you will
read about C about J and ayah and we
will talk a little bit about how to
protect that
so how to write secure code where can
you find out about the now following
guidelines we have website out there
about secure coding guidelines currently
in the version 4.0 and we have a
self-training study which you could use
where you will be guided through the
chapters and you will find also some
questions and quizzes to check about
your learning process
so sometimes examples and tests give you
a little more backgrounds and the
guidelines itself also there are
guidelines available outside of our
website which for example at c-cert
secure coding Vicki or the cwe
enumeration with examples about bad
practices and anti patterns overpass a
top 10 list out and the source
organization also maintains lists which
are mostly based on cwe indeed
so going to the guidelines itself there
are different chapters we start with
fundamentals and we go into denial of
service
how to prevent denial of service how to
put that confidential information to
care about injection and inclusion how
to have safe accessibility and
extensibility to validate input
parameters care botton mutability have
object construction done safely
civilization D sterilization and finally
we have a chapter about access control
so these guidelines address the
top-level concerns when writing secure
code we now show an example former older
JDK release with every guideline
explained the problem and the attack
scenario and we describe what was done
in regard to secure coding guidelines OG
audience can go later and check the
reference online documentation
so fundamentals what do we have under
fundamentals why our parliaments
important these are more the meta rules
security vulnerabilities will never be
eliminated if you have rare designed
code it is easier to secure that code
and these privilege by design prevents
unsecure surprises so first guidelines
we have is to prepare obviously no flaws
rather than the obvious flaws which
means obviously this is secure or is it
insecure secure because you will never
go to the cheese or the gold or what
about that symbolism but how about this
one how long does it take to find out so
this is what you may count E or you may
find in production sometimes and some
may to an out secure and some may turn
out insecure but definitely you want to
avoid this question while the
application is in is in production so
better design such architectures in
contrast to these ones
while doing so design api's with
security in mind because metal fitting
security is difficult and error-prone
make a class a final as default to
prevent malicious subclass from adding
finalizes to do cloning overriding
random methods falling protected methods
also why avoid having to check whether
there are subclasses that override your
message in an unsafe manner by adequate
planning during design avoid application
because you want to maximize we use and
if you
dublicate code one of your copies may
have a bug and that may break you our
protection you are and will increase
your attack surface so avoid application
on multiple levels we use use libraries
deploy a jar only once if your
application server allow set and avoid
repeated code snippets to have a common
safe version of a jar deploy to your
application you want to restrict
privileges not all calling coding flaws
will be eliminated even if you have
rabid code Bell rabid code whenever
possible follow the principle of these
privileges and reduce publishers mean
that you have reduced impact of exports
therefore signed so fatty jars better
audits them before assigning them
elevated privileges
find established trust in those jars by
auditing those and apply Java secured
security mechanism for example with
who's a policy fire where would
restricts applications policy files or
if you call into third-party code which
was stood down protection domain that
would take privileges away from code
establish trust boundaries have a simple
API to clearly distinguish inside and
outside of your trust boundary what is
the code that is inside versa codes
outside so all these fundamental rules
are very simple to speak about what may
be harder to implement so keeps his
pictures in mind when you write your
application
many minimize the number of permission
checks prefer us single point of access
don't have multiple point of access to
have a consistent access policy use an
initial permission check then provides
our clients with immutable capability
objects and the capability objects and
will be the identities that is used
throughout the application of course if
you have a single point of access you
need to watch output performance
otherwise you if you're singing point of
access does not allow for the
performance you have the knowledge
service if you work with Java Enterprise
Edition considered to use just to have a
standard API that you can even reuse and
leverage on the functionality
if you want to have a consistent class
hierarchy you may want to encapsulate
things you want to group coherent
functionality there may be
implementation details that are
important to this to a specific
component but you which you don't want
to expose to other component therefore
don't expose implementation details
because it may subvert the internal
assumptions have a simple and stable
public API do not force the developers
to have changes all over and consider
builders and factories for abstraction
lifecycle control and invariance
checking so these were the fundamental
guidelines the guidelines that should
help you while design while thinking
about the build up of the application so
let's go a little bit more into
practical problems how could you avoid
denial of service denial of service can
be avoided by planning about protections
already in the design phase used one
passes if possible prefer it's our
communication strong passes over
civilization communication in overall do
not let the attackers bring down your
server because they use a communication
technique that is not suitable for the
application purpose
beware that activities may use this
proprietary sources what does it mean
for example you may have large image
processing so if you have a server
application and that accepts image data
be prepared that some funny guys may
send you images that have 5000 by 5,000
pixels and you want to compute a
thumbnail and that all of a sudden takes
5 minutes instead of 5 seconds so large
image processing may take time may take
away resources there may be integer
overflows you may have to think about
civilization may bring your complex
object graphs you have to your
application may have to digest if you
offer our functionality to decompression
make sure you have sensible defaults to
prevent zip bombs the bombs that may
explode inside memory and take away a
lot of valuable resources XML external
entity may also be a problem when
working with XML so be sure to have the
resolver set correctly if you are
passing and processing complex grammar
like expose or reg X there may be
problems with these expressions some
terminate very late or compute forever
if you have programming bugs in the
libraries this realisation may cause
problems when you have
object routes or if you have recursion
in those if you lock within appropriate
detail that may cause space problems on
your server and parsing corner cases can
cause infinite loops and that make you
keep your server busy for a while so in
short the attacker may send a relatively
small amount of data which causes your
program to allocate large amounts of
memories consume excessive CPU time so
what do we have here we have an example
for arms the JDK 6 and JDK 6 had a
problem with font functions and you
could for example define your own input
stream and put this input stream into
font create call and while the fun
create class the font class trusted the
input stream the input stream which you
could supply may never complete and as
fonts are placed on the hottest before
they will be processed you could cause
the applet or the application the
untrusted application that was put on
the victims machine to allocate all
available artist space so
and I put for certain operating systems
that would survive a reboot so you would
have to use a rescue disk to reboot that
machine
also we had a nice buck in the double
pass double API where you could send or
use a floating-point number and double
and that sent the JVM to an endless loop
and if you for example had a server like
a tomcat server and the Tomcat server
allowed double values in the Q value of
the get locale instruction in HTTP
request
so the Tomcat was calculating for the
number for a while and busy so with a
simple HTTP request you put cost in our
source of server infrastructures
but the problem was just off by one buck
which caused an infinite loop an endless
loop and after that was identified the
number didn't cause any harm anymore
coming to a confidential information you
should touch sensitive information from
exception
you should not lock in highly sense of
lock high sensitive information and
remove sensitive information from memory
after you why should you do that
don't let the attack us take your
secrets home and there could be a leak
of settings and passwords which you want
to avoid so there may be problems with
exceptions for example if you assume
that exceptions are harmless that may
contain sensitive data that could reveal
data about details of policy so some
configuration for example the i/o
exception may contain a pass that
implies a user identity file not found
exception could be misused to probe for
file system for the existence of files
robust technical information is not good
for debugging it's good for the bugging
but maybe not for Ge Ge production usage
so keep in mind that you use a decent
logging framework and you can adjust the
velocity without having a downtime
prefer to have a separate output
channels for system logging and apt
level auditing
in case you want to capture what
exceptions are being exposed by the
application so here we have again an
example from the font API we have a fake
font that starts with OTT Oh what would
that could they be what kind of format
is that that is an OpenType font and if
you would give the this string to the
font API what would you expect could
happen so we've seen in the previous
examples that funds our first persisted
on the hard disk in in the temp and wire
in the temp directory so what it did was
to omit the
the location of the temp directory in in
an exception and by that an attacker
could take an applet with this code and
find out about the temp directory on the
victims host so this would be a leak of
confidentiality about the system
configuration of the victim so the fix
removed all for the case of applets this
verbs information and just showed see
our text results II pass information you
do not want to lock a highly sensitive
information you want to have security
policy in place so password should not
be stored permanently in clear-text if
you want to have this encrypt this
standard api's and hash that with
assaults don't have these passwords in
clear-text around you want to limit the
exposure of those in memory
therefore strings may not be appropriate
prefer character arrays which allow to
clear the traces and you could keep the
information local and for that you don't
have to depend on garbage collection
because you can delete strings string
you can delete character arrays
immediately and don't have unsafe copies
lying around in
coming to injection and inclusion
don't let the attackers modify your code
and hijack your applications validate
data from untrusted sources prefer white
lists and use standard parcels use
generate a valid formatting avoid
dynamic SQL XML and HTML generation
requires care because there can be some
metadata included avoid any untrusted
data on the command line so all areas
where you have untrusted data meta
information from untrusted sources so if
you want to validate input from the
client be fair and to have very flexible
checks because attack us are very
creative and they always try with
underpowered values and escape
characters to circumvent your checks
therefore prefer white lists black
listing is useless against new attack
types that effects codes at posters
requests and delegates to some
components for example with other
Network protocols with SQL and you may
also delegate to shell script issuer to
validate where you have such boundaries
and of course when you work with C++
which Jay and I keep in mind there are
no memory automatic every bounce checks
that would help you so if the attacker
supplies a very high index make sure you
don't have an array access to this high
index without checking the a power
length of a part of the array so here we
have an example for neglecting valid a
valid input formatting we have class we
had back in jdk 1.4 the HTTP URL
connection and that allowed for a
certain request property to set a key
and value which was interesting because
you could inject embed other requests in
the original request in the except had a
year for example and for that you could
bypass security settings on the victim
host so you would have an original
request that would go outside but as you
have the embedded request on the which
is added here
also in the interest you have some
attack type which is called HTTP
response splitting and the web proxy
would be mirror that would reflect that
request to a host on the network so and
that would not be allowed from security
policy but it would have been injected
so make sure you check your input values
and don't allow such cases another
interesting case is with dynamic SQL so
we had a problem with JDBC in certain
setups for example if hsqldb is used as
a JDBC implementation there is the
possibility to connect wire tcp/ip to
this database and in je1 4209 there were
classes that allowed to compile code on
the fly that called java c 2
create XML stubs
so there was a problem with interpreting
untrusted code so hsqldb had command
that would called create alias and that
imported static Java methods directly
into SQL and those areas can be called
yrz select close so upon to14 208 c je
bundled salon and that contained a
package which allows you to replace as
easy java compiler that it used on the
fly for example with CMD XL and the
attacker could now replace this default
Java compiler which seemed DX and
execute arbitrary command lines on the
server for example so the attacker could
use JDP JDBC for example connect to Java
EE server which would then accept
the SQL request in the SQL request you
would have alias definition and that
alias definition would then go through
salon and call system exact and all you
would have to do is to write a short
text of SQL you see you have you have to
create tables that deserve requirement
from hsqldb you would set a certain
property you see you would export that
static method to SQL and call that from
SQL and you would create another alias
for the compiled message and by
executing that you could very good for
depends on rights of the user you could
do harm but here we only start notepad
with our cetera hosts so this is an
example to avoid execution of untrusted
code without proper checks
going to validating inputs requests
should be rejected earlier if they are
malformed prefer white lists regular
expression API scan helped to validate
string inputs very properly check for
escape values and out of bounds values
passed only validated import validates
formatting to sub components Rob native
methods in Java language whopper to
validate inputs to not even touch native
code to to avoid that it could have a
parsing error
define a native code as private to block
validation bypass and again reuse were
just libraries instead of writing ad hoc
code which could be buggy coming to
accessibility and extensibility why do
that we'd use a text surface assign the
least accessibility required to your
code prevent unwanted wanted
modifications of your codes
so therefore limit accessibility of
classes packages isolate called limit
the exposure of class Lola instances
limits the extensibility of class and
methods and understand how a superclass
would affect subclass behavior so for
example limit the extensibility of class
and methods we had a problem with
which dragon dropped in an earlier JDK
versions for an unsigned applet could
retrieve the direct information before
sit what actually occurs and while
dragging a graphic from one office
application we knew to another an applet
called sniffs that data and to exploit
that bark the attacker needed to
register the drop target class and
passed mime types that have passed to it
you are currently not anymore affected
by this part because it was fixed and
JDK 16 19 so we had this unsafe
accessibility the unsafe extension of
the drop target class where the attacker
could add his own hooks and then read
about the meta information that was in
the drag-and-drop information so you
would you would have two windows you
would drag from one window to the other
window to office windows and you have
the untrusted applet in the middle and
the untrusted applet in the middle would
now be able to read what you drag from
the one window to the other and you
would have a passive sniffer attack in
this case something you don't want to
give some rot privilege you don't want
to give to untrusted applets therefore
this was
this was fixed by checking whether the
application actually had clipboard
access and when the application does not
have the permission to access the
clipboard this action was no longer
possible
and that was fixed in decent drop target
it would have had made wooden of
impossible to find that the NOC target
as final because that would be an API
change and that was not possible in this
case another case was the provider class
the provider class in JDK 102 and
provider is security provider and that
extends properties and poverty's extend
to hash tables and as hash tables have
put and remove providers also have put
and remove but the provider extended set
with security checks
now in an updated version Angelika 102
there was an additional method added to
hash table so what would you expect
could be a problem here
yeah you could directly access without
passing through the security checks so
the provider was no longer asked for
removal because you could now directly
manipulate the internal data wires the
hash table entry set so and the tech I
could now bypass the security checks so
this is a problem because here it was
try to go after the idea of code reuse
but the disconnection of checks and data
led to a vulnerability so data was
belonging to provider and the check
rolls but it was stored in the hash
table class and the checks in the
provider class and this separation only
exists because provider was extended
from hash table but a provider is not
inherently a hash table more uses the
functionality of a hash table therefore
it should not extend that and
in a modern world it probably would
encapsulate hash-table to use that data
and guard the checks inside the same
class and not this past data and checks
so subclass cannot always guarantee
encapsulation as the superclass may
modify the behavior of methods that have
been of written the superclass may add
new methods security checks in
subclasses can be bypassed as we have
seen because the in event entry set
could be used to perform the removal of
the data which was sought to be
protected
so
the change was to have an immutable set
given back from entry set and also all
varietals that method to close at home
coming to chapter 5 input validation
input validation about expecting the
unexpected
therefore it's recommended to use white
lists whose input matrix or instrument
your application and may cause it to
perform malicious behavior prevent
attackers from taking over your control
flow therefore
vallah gate output from untrusted object
as input and validated so as at the
border validate or the input that comes
in and be creative and how to check that
here we have a class proxy class the
reflect proxy class and the proxy has
had a back in native message and when it
was called with over 65,000
interfaces non-public interfaces like a
java.awt conditional this method crashed
with a native exception with a native
crash
unfortunately proxy was it's civilized
world so you could send it in a
civilized board packet and calls it
remote denial of service by handcrafting
a civilized presentation of this class
so an attacker for example could use it
to terminate a remote je server for
example by injecting a seamless Posse
glass and adjacent viewstate or whatever
civilized will input the application
allowed so therefore do not expect users
to read and obey the source code
commands better implement checks check
all even unlikely violations in variants
ideally with white lists so in this
simple case just an interceptor was
implemented to check for sea lengths of
interfaces
so it would not go to this vulnerable
code part in the protectors in the
package private protected son class
input validation input modulation also
means to define Robert robust about
around native methods so if you see this
code is this a good Robin or could it be
improved so we have this method from
crc32 and crc32 has a byte buffer and
this can be updated by setting by giving
this method the byte array giving it an
offset in giving it two lengths so we
check if it's now then we throw a null
pointer exception then we go to the
every lengths check and what can be done
with the every lengths check do you see
some problems with that
so I see no hands yep yes
it's New Years Eve the correct answer
yes it's an integer overflow so if you
have integers sometimes you may be
tricked into believing that the value
spell of integers is unbounded because
if you add two integers together if you
add those they robbed at a specific
point at integer Max value and if you
would don't take this into account and
you pass that information to native code
you may bypass the bounds checking the
bounds checking that was anticipated to
be correct because you are your check
was was passed but off plus Lang was no
longer a positive value it was a
negative value because it overflowed so
a better way would be to rearrange the
comparison and move the lengths value to
the right side and utilize the entire
value space of integers in this case so
that was the fix that was introduced and
one for 102 and etre at other locations
also in the JRE so you are no longer
endangered by this back
mutability prefer immutability for value
types and many rules about immutability
why should you do that why should you
care about the mutability because the
runtime security relies on trust words
the objects used by privilege code that
won't give take us to modify those on
their behalf don't have untrusted
entities mutate your objects
so therefore what modifiable internal
States the couple install instead homes
if you just changes to the input values
don't have any references left to
untrusted data because the data may be
modified afterwards
therefore the accessor methods can apply
checks to beautiful static state
therefore have first have a security
check when setting the data and then
assign the data to your internal
structure so here we have the set data
message that does a security check first
and then assigns the data and to prevent
from modification outside of your class
you would want to not give the reference
to your bite every hour you want to hand
out clones because clones don't have the
raw is that they are modified afterwards
and you would have
malicious modifications inside similar
example from jelly k14 tool there was an
expose expose had a public function
table and the public function table
contained an array of functions for
example expose allows for addition
subtraction and all kinds of
mathematical functions and those were
listed in this M functions table so the
attacker code to replace the function
table which is own one and when you had
two applets in in a VM one applet coach
reaches an the expose input from the
other applet and woods and reach the
confidentiality of the other applet and
reach that data while pausing so you
would have a covert channel between
those applets
so sensitive static state could be
modified by untrusted code by replacing
the function tables the attacker gets
access to expose contents and you had a
covert channel which you could which
attacker could use to wiretap the data
process by expose and we can take away
from that static variables in system
called a global across C and via Java
Runtime environment and they can be used
to attack a different application
domains like old loading into different
class lowers and passings who have
context boundaries therefore make public
static fields finally makes them
immutable do not expose mutable statics
reduce the scope of non final static
fields Rob every access tweet public
statics family has constants and if
possible use a numbs their type safe
switchable and implicitly static final
and coming now to seven object
construction why should you care about
object construction to stay in charge of
the creation of critical object
instances do not attack us that control
critical classes you want to provide
exposing constructors and defend against
cloning of non final classes for example
and you also want to defend about
against
partially initialized instances of non
final classes especially a dangerous for
example the class loader and normally
you need a permission to create a class
loader but in jdk 102
you could apply a trick and store static
reference of a class Laura in in the
field and that would be filled
whenever finalized was called so if the
check failed you would have to wait for
finalization for the garbage collector
to set in and if your finalized class
your overwritten class loader woods and
assign your current instance to your
static placeholder CL in this case you
would still have a class loader which
you could use to load classes so
you could circumvent the classloader
permission just because you would catch
the instance during finalized so sewing
an exception from where constructor does
not always prevent partially initialized
instance from being quiet an attacker
can override finalized to obtain the
object so constructors that call in to
outside calls often Navy propagate
exceptions and leaking this can also
cause the same attack to occur so make
sure you declare a class as final if you
don't want to have such effects if
finalized can be overwritten ensure that
partially initialize instances are used
are unusable you want to have
initialized flag for example to prevent
access to the critical methods do not
set fields until all checks have
successfully completed you want to
defend against this and with Java SE 6 &amp;amp;
7 this no longer is a problem but you
would need to have the byte code at
level 6 at least
civilization and D civilization avoid
civilization for security sensitive
classes use XML DTD wherever positive
possible expect side-effects from
civilization and careless digitalization
can create objects instances you don't
want to have around so for example if
you have a big integer into a big
integer is civilized or
it has check in the constructor to cause
a second to be within specific bounds
but if you dis realize that from object
stream these bounds were not obeyed in
the with object message so you could
create big integers with illegal signal
values
so the default civilization mechanism
cannot apply automatically apply the
same input and parameter checks as in
the constructor
the attacker can create a malicious
civilization stream with invalid input
values that could create in village
objects therefore repeat the checks of
the constructor in the with object
message here we sent a set temp signal
we check for the allowed range and if
that is not the case we slow a stream
corrupted exception as and if all
succeeds we finally set to the value and
only in this case
now we come for the last but also an
important chapter the access control
chapter attackers prefer privileged
context to accept to execute the
malicious actions prefer his privileged
execution to grant just enough
permissions so here we work with access
controller especially with the two
privileged API to limit the permissions
granted to code we have an example for
um JDK 6 where a zone info was disabled
as iced with an excessive amount of
permissions so the instance was read
base for privileges and because the zone
info was defined in a Sun package
therefore you would require Sun package
accessory permissions but here in this
case all was swapped in a unlimited -
privilege block and as you may expect an
attacker would not sent its own info but
he would send a class loader for example
and use this information to bypass a
check because the code was these will
allow sizing the information with full
permissions so the fix was to set
to set these perpetual and set a very
small protection domains that only
contains that permission and you would
that apply to your call in the D
civilization so what do we learn from
all the rules we have seen if you follow
the secure coding guidelines you can
reduce vulnerabilities secure
programming from the outset should
concern all probe developers but if you
have vulnerabilities you will impact
confidentiality integrity availability
and you cannot wall back leak so always
validate your data do not try to auto
fix broken data and codings reject when
in doubt use whitelist do not reinvent
the wheel practice we use with standard
libraries reuse code is updated by
others you can work on the new features
and switch the perspective start
accessing new code first
are there any bypasses and consider a
textile test cases to check for possible
beaches of your software so conclusion
practice could reuse the last new code
layers new bucks and raise awareness
along the developers and now we have a
couple of minutes if you want to stay
for Christians yep because it has a
strict grammar and it does not allowed
to jump out of that grammar if you apply
a DTD passing for example you can
restrict what is passed but with this
realization you will never know what
kind of type comes along and it's you
have you offer too much functionality
it's the the power of the power and the
amount of reachable code and if you
expose if you have an application you
don't want you want to limit the amount
of reachable code and that's that's
better limited by others like XML
puzzles like as with the Java
civilization API
because potentially every civilized will
object is reachable with the
civilization API yeah that's why you
want to ever XML passes at stable for
example and that's reused by by the
community but the the exam the
civilization yeah yes I'm fully with you
to you want to avoid civilization and
you have to use a an alternative with
less reachable to your to your java code
and that's why Jason houses are a good
choice to yes no but not in the case
where you would expose Java methods wire
Jason like some with some hooks you
would offer if you use just the default
functionality in the puzzle yeah
questions
then thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>