<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introducing the Java Time API in JDK 8 | Coder Coacher - Coaching Coders</title><meta content="Introducing the Java Time API in JDK 8 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Introducing the Java Time API in JDK 8</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CtD9B9TU_cY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and welcome to this talk on jsr
310 introducing the API for JDK 8 I'm
Stephen Colburn from open camera and
this is Roger you are a cop okay so the
funny thing about time is the more you
look at it the more complicated it gets
it's just as you look at that picture it
gets more complicated and more
complicated more complicated so really
the goal of the jsr is to figure out how
to make that simple enough and
accessible enough for everybody so
subject to the JCP and normal Oracle
safe harbors the JDK 8 will have a new
date and time API this aims to replace
Java util date calendar time zone date
format and no need to use joda-time
it'll all just be included how are you
so really this is a new API it's it's
designed for and integrated into JDK 8
so it's built from scratch so it's
taking the ideas that came from
joda-time
and some you know years of effort but
it's a new it's a new API it's it's
fixing some of the mistakes from the
past take some new ideas and works
within the boundaries that the JDK has
which are different boundaries from an
open source project so the J's are the
JSI itself was kind of run as an open
source project it ended up on github
where there's now a nice pretty sort of
Java doc II type homepage with a few
user guide type things which hopefully
will get expanded over time the original
code was BSD license now it's an open
JDK it's just GPL licensed over 20,000
test cases where it's probably about
25,000 test cases hopefully that's good
enough and there is a back port
available for jdk 1.7 which I use in my
day job and seems to be good so what we
were trying to do was produce this sort
of comprehensive API to cover date and
time we needed to support these common
global calendars it needs to be
immutable
one of the things you've probably
spotted with all the lambdas going into
JDK 8 and all their functional
programming stuff in general is
immutability and parallelism they tend
to all flow together so having an
immutable date and time API will be a
good thing we also wanted it type safe
finding the right boundary for type
safety within Java was a challenge and
so in the end we've ended up with some
aspects of primitive not numbers summer
types a things you have to work with the
language to come up with the right
solution there it should be fairly self
documenting when you write some code
doing date and time stuff the end
resulting code should look like the
problem you were trying to solve
wherever possible again that's similar
to what Brian and Mark were showing in
the keynote yesterday and also we wanted
to be IDE friendly so some of the naming
conventions and designs are around
making it easy for you to find things
when you're just doing control space in
your IDE obviously it has to
interoperate with some existing classes
and we have to think about XML the
databases so that's the Royal
Observatory in Greenwich the home of
time in the UK so date and time they
kind of drive our lives yeah you came to
this presentation and it's at one
o'clock in the afternoon on whatever
today's date is I forgot yeah if they
drive out they drive our light and
people have been investigating date and
time for thousands of years so what this
means unfortunately is that the word
date and time they have lots of meanings
so actually you have to be quite we kind
of have to be very clear about what we
mean when we use these words so part of
the API design is actually I'm part of
what joda-time did was adding in sort of
class names and naming that allow you to
talk with your colleagues about
particular things so if you say I want a
local date if people know what you mean
so it does help people to communicate so
simple principles we wanted things to be
mutable we wanted to be fluent so it's
easy to read you needed to be clear so
if you have these Java doc you don't
want complicated Java doc each method
should do minimal amount of things it
turns out that kind of results and you
need quite strong control over state and
simple value types and we don't know
everything
you need to have the ability to plug in
your own weird wonderful ways and
looking at date and time a lovely clock
telling us a date does that make it a
clock or something else Canada
see words are very card when you talk
about this stuff so days and dates
they're basically stuff that's defined
by the Sun yeah we count them so we can
treat keep track of the seasons I mean
that's why we count dates and why we why
we group them into year is so that
farmers could control their crops I mean
that's that's where it all comes from
essentially so a calendar system is
about defining what the counting system
is how do we count them and a date it is
a label for an individual day within a
year now there are multiple calendar
systems around the world but the reality
is most of modern business uses a single
calendar system it's the eye it's the
what you probably think of as a
Gregorian calendar within existing JDK
code it's we refer to as the iso
calendar system basically means the
current rules for leap years applied for
all time both backwards in time and
forwards in time it's the simplest
possible calendar it meets all current
business applications pretty much
globally so we have a class called local
date and local date effectively it's a
representation of a year a month and a
day it includes nothing about time zones
it includes nothing about time of day
it's just the date so your birthday is
an ideal example of a local date this is
something that's quite hard to store in
Java today people often store midnight
in a Gregorian calendar which turns out
to be wrong because some places don't
have midnight once a year when daylight
savings time changes so you have got to
be careful using the existing API so we
got some code at the bottom we've got
here's an example of just creating a
local date using local date now here
we're creating one in 2013 September the
12th we can say whether it's before or
after something the to string format is
very simple that's the ISO 8601
standard format so very straightforward
to output and nice convenient methods to
check whether it's a leap year how long
a particular month is this kind of stuff
kinda don't need to say much more than
that
the methods kind of say what they do
we're all familiar enough with the
concepts that everybody should hopefully
be able to understand them so if you
want to manipulate these things we have
to start with remembering again they're
immutable so that means that it's just
like coding to uppercase on a string you
know you have to assign the result to a
new variable otherwise you're not gonna
see any with any effect so we've got
these nice methods we've got for example
date dot plus months - days so that's
going to take the original date add on
three months and then subtract add a
comment says what it does you don't have
to think too much about it you can
instead of setters we have with methods
so you just say with day of month so
that will take the original date keep
the year
keep the month but change the day of the
month to be the first month or change
the month to be ten or change the month
to be October obviously if you use the
month enum then it's going to be easier
to read than just using ten but at least
January is one and December is twelve
which is always a good thing I find so
sometimes these things get a bit more
complicated so we have these sort of
things we think of when we're doing date
and time manipulation like you want to
get the last day of the month or you
want to gain next Tuesday this kind of
thing and so we have built this adjust a
concept so the temporal wheel adjuster
is an interface it works well within
sort of the lambda it's a functional
interface in terms of lambdas so it's an
interface with a single method although
you won't tend to use lambdas here it
allows you to do so if that was
necessary in practical terms what you
will end up doing is using these
predefined constants like last day of
the month the great thing though is that
you can you know if you statically
import them then your code really starts
looking great so what we end up with is
saying take the original date and return
me a new date
with the last day of the month so you
know if it's February it'll return you
the 28th the February 29th of every
depending on whether it's leap year if
it's June it'll return you the 30th of
June again your code looks like what
your business problem was with the next
Tuesday
so whatever the next Tuesday is after
now you'll get back a date which is the
next Tuesday or you can write your own
to create one next third Friday so the
first two are provided by the JDK this
one you could write and provide yourself
simply by interpreting the interface of
course we don't just deal with dates we
also deal with times so in the API in
general we use the word time to refer to
time within a day again as I say it's
there's a lot of naming issues we have
to deal with so this is like a standard
definition
what's your watch telling you what's a
wall clock telling you measure the
measures from midnight 24-hour clock and
so obviously it's now 1300 in the
afternoon I've got to bear that in mind
so our java class here is local time so
this is local time it does not include
any reference to a date does not include
any reference to a time zone so
effectively it's during hours minutes
and seconds 1330 shop operator opening
hours the time shown on an alarm clock
you can imagine the kind of use cases
you might use this for again our code
examples you can create the current time
you could say if the arrow is greater
than 12 or create an instance from a
particular time of day 13:30 before or
after and again a nice simple to string
one thing you might notice up front is
that we store nanoseconds accuracy so
everything you've done up till now in
Java has been milliseconds in general
jsr 310 is storing nanoseconds which
matches what sort of the big heavy
databases like to store doesn't mean you
can get nanosecond accuracy out of
anything but at least we're not gonna
lose any data again we've got the same
kind of methods for manipulating stuff
plus hours minus minutes with methods to
set particular fields we've also got
this bottom exam
or here which can be quite tricky in
Java so we got truncated too so you can
if you've got a time of day which is
like 13 15 and 30 point 6 7 3 seconds if
you do truncate it 2 seconds it'll drop
the milliseconds and nanoseconds parts
and you'll just end up with the seconds
so useful kind of feature so what do you
do if you've got a local date and got a
local time well you can scrunch them
together and you get our local date time
that's literally all it is it's an
object that holds a local date object
and a local time object together so it's
has storage basically for year month day
hour minute second and it has all those
nice methods we've just saw we've just
seen but allows you to deal with dates
and times as well together
again we still got no time zones here's
an example so create an instance we're
creating an instance here of 2013 in
September the 12th again at 1:30 in the
afternoon we can add days you can
subtract hours we can use next Tuesday
all the kind of stuff we've been talking
about so far typical example there
what's the local date time a flight
takes off so my flight over from London
took off at 10:35 in the morning on
September the 19th you can store that in
that object
so I'll pick it up from here so we've so
far we've talked about the sort of the
ISO calendar systems and of course as
Steven mentioned many of them you know
the worlds of operate site on a common
basis but we have requirements in the
JDK and and in businesses for other
calendars and so there's a separate part
of the API which is delegated and sort
of dedicated to these more extensible
and and customized calendars and it's
part of the JDK release we're supporting
the garage Japanese Mingo and Thai
Buddhist calendars and but they really
only affect the date part of the the
chronology but to introduce additional
calendars one of the things you need is
you need a concept of the chronology you
know the part of the calendar system
that apply that tells you you know how
many what the year is how to convert
from you know ISO years for egg asleep
mostly calendars is they are internally
we're all based around this notion of an
epoch day which is 1970 and so there's a
good mapping from that can be done from
the ISO calendars to the other calendars
which is embodied in this chronology
object the selection of calendars can be
done using sort of direct naming of the
chronology there's a way to configure
the calendar choices or sort of look
them up by based on the bcp 47 locale
extensions in the cases where you need
to customize it externally to the
application and in addition to the
normal iso year month and day
the internationalized calendars have the
concept of an era which comes into play
most particularly in the japanese
calendar but other calendars as well
segment the the time space so just a bit
of an example of how you would look up
the chronology for the Thai Buddhist
calendar externally now the chronology
is not yet a date it's used as a factory
to create dates but once you have the
chronology you can create a date of the
appropriate type
and so let me move on here so but the
API for the four typically when you're
using with these applications you have a
couple of choices if you really are
dealing with a particular kind of
chronology there's you know there is a
tie Buddhist date it's got the same kind
of methods that you expect to find on
the ISO calendars but it clearly is
typesafe and strongly typed as for the
particular calendar you're using and
includes the concept of an era so if
you're writing an application that's
particular to that chronology that you
should use the particular type and
there's some examples at the bottom you
can do the same kinds of things you can
do with the the main calendar API what
time is it now you can convert in the
bottom case the from method is a signal
to sort of convert from one type to
another
and here you can creating a Menengah
date from the local date in the case of
rewriting application that has to
compute on dates but doesn't really know
what kind of chronology it's going to
deal with there's a more more a little
bit more abstract API more general API
that embodies the date as this notion of
a chronological date and chronological
date includes an explicit reference to
the type to the chronology type and uses
the chronology as the factory for a cron
Aloka date but it's because there are a
number of pitfalls in dealing with other
chronologies sort of very generally it's
a little bit harder to use as an API
it's a bit more that pickier about the
functionality so just to make the hole
type hierarchy tied together the local
date which Stephen introduced is a
implements Khurana local date so the the
ISO date is a subtype of all of that and
you can use it interchangeably where
needed but as I mentioned you know
dealing with international these other
calendars there are pitfalls and
many of them are about the assumptions
that that people make about the
calendars and a lot of bugs a brazilian
resulted over the years some of the
Oracle people who have had the Internet
applications in the in the date area
have sort of had to stumble over
converting something where a developer
had made an assumption about the
calendar and it turned out not to be
true so some of the examples of things
that are sort of improper assumptions
are how many months are there in a year
well it turns out there a number of
calendars in which there are 13 you
don't want to be adding 12 in this API
that's a bad idea
there is a there's an odd year or plus
years method and there actually there's
a plus method that takes the year as the
argument you can safely assume I think
that weeks have seven days but that's
just an example of the kinds of things
you don't want to do anytime you find
actually probably true with the ISO API
if you find yourself hard coding numbers
literals in an API with times and dates
you're probably doing a problem it's
just you've made code that's it's gonna
be fragile so that's just sort of a
warning that you'll probably see some
other examples when you get into working
at it with the chrono API of places
there where it's the right tool for a
particular set of jobs but it's kind of
a niche thing so moving on to time zones
as Stephen introduced in the notion of
date and time without a time zone it's a
very localized but of course if you want
to deal with any time around the world
you have to be you have to be able to
tag things with the time zone so Java
dot time API 310 introduces a different
API for dealing with time zones but it
has to embody you know exactly with the
sort of reflect the information that's
in the common time zone database and so
there are types that allow you to deal
with to lookup time zones by name to
query when the transitions happen in the
time zones some places use daylight
savings time frequently
sometimes they're places where the time
zone database changes more quickly and
you have to pay attention but that's
embodied in in the API in a you know
time zone API I don't specifically know
what's going on there the as pointed out
the time zone database is maintained
it's affected by political decisions as
well as sort of other aspects so it's a
bit more fluid and it's not really in
any one person's control yeah I mean
it's literally the case that if Syria
broke in two and became two countries
and those two countries started having
different times on their wall clocks at
that point there would be two different
time zone IDs in the database that's
that's no different to what we do today
the JDK is already updated all the time
with time zone information it's it's the
same principle as you know Oracle
supplies a patch file basically and you
run that against the dedicate right
yeah the maintenance of the time zone
database is sort of this continuation I
mean it's been going on for years and it
will continue to with you know new if
there are new identifiers is that people
have to use in applications or be will
you know so be it
so there's standard formats for the time
zone names and offsets so a time zone is
basically a an offset and it also has
information behind the covers for
daylight savings time
so 3:10 is sort of separated this into a
distinct type of stuff with several
types there are there's sort of the
named time zones which are represented
by zone ID there if you're fixed if you
have some many applications you know
exactly what your offset is from from
Greenwich and a zone offset type
encapsulate some fixed offset this is
the one that is frequently used in
databases where
most databases don't really know about
time zones but they're able to deal with
offsets and then the zone rules type is
provides the access to sort of all the
details of all the transitions and the
particular offsets and all of the
different zone IDs so it's probably more
detail than you really need to know as I
mentioned zone offset it's just a fixed
offset from from GMT and ranges from you
know plus or minus 18 hours
pretty straightforward coding
representation and I was talking out of
turn but the zone IDs obviously cover
the name zones and and are attached can
be attached with this fairly simple
lookup syntax of common forms so sort of
pulling it back together with the local
time there is this the type zone
date/time takes a local time date/time
and combines it with with a zone ID so
that you can fully express not only
where that time occurs relative to GMT
but the offset from GMP in single object
and again this this type is you know
easy to use and that it has no plus days
and minus hours you can use the same
kind of adjusters to modify the dates or
the times and it's so it's just as
fluent and and flexible as the the types
without the without the time zone and
it's two string format you know we sort
of fully exposes the date the time and
the time zone as part of the whole
complexity of time zones there are gaps
and overlaps and the so when you're
looking you can when you formulate a
particular zone date and time you need
to be aware that depending on when it's
evaluated the the time that's
represented may skip a bit playing of
this plus days of one may tries to
retain the sort of the fixed offset but
if they're turns out to be a daylight
savings time transition other parts of
the time they may change you know the
time may change as a result but
similarly if you add an hour
you know if it turns out that you're
going you know from one o'clock that
from one o'clock to 2 o'clock at the
same time that the time zone DST is
changing you're gonna add it'll actually
change by the expected amount but not by
the sort of arithmetic amount if you
really need to know sort of what's gonna
happen when and the time zone database
you can you know look up particular time
zone at a particular time you can ask
the rules own rules database you know
what what's the type of transition
that's at that point of time and it'll
tell you whether it's a gap or an
overlap and how much the time is it sort
of you know fully closes the zone time
zone database similarly if you're
working Wesley with a similar with a
simpler time that our date and time that
just needs the offset there's a offset
date time class that embodies a fixed
offset with the local time and this is
one of the easiest sort of matches the
forms that are in dated most databases
in an XML in the API and I've been just
one other plug there is there is so
there's provisions in the Java excuse
that are in the JDK that map they use
extensions of Java util date and time to
convert in and out of the offset date
time and local date times so there's a
bridge to the database functions and
there's updates to JDBC that allow as
part of getting you know getting data in
and out of databases to use the three
ten types but it depends on the
particular database driver you can
express the notion that you want to get
a three ten time and date out of in and
out of the database but you need a
particular driver to function the worst
of the database to make it to realize
that anyway the next section is on
instance and
so that's an atomic clock in case you
were wondering that's the thing that
actually counts the individual second
and what really determines how time
progresses these days so instance
themselves so instance is the word we're
using to represent an instantaneous
point in time so if I clap my hands now
now those were two separate instance in
time we can we can declare them as a
number of nanoseconds that since 1974
each of those two claps of the hand and
you know we can record that as such and
we can say the second clap of the hand
was later than the first clap of the
hand so they're instance they're points
in time it's the kind of thing you want
to do when you when you're doing logging
you want to say this this logging event
occurred at a particular instant in time
so generally with these things time down
is not particularly relevant you only
really want to care about yeah you
typically want to record your logging
timestamps against the UTC so that
they're all consistent across servers
wherever they are so we have a Java
class it's called instant it's during
the nanosecond since 1970 and this is
kind of the closer to equivalent we've
got to Java util date I mean that Java
util date when it was first written
obviously had these other methods like
get a year and get a month but those
have been deprecated since JDK 1.1 so if
you actually even all those methods all
Java util date has been used for in the
last 10-15 years is just an instant in
time despite its name instance is
therefore the closest replacement so as
we had before you can do instant dot now
we can have a second instant now and
these are likely to be well the second
ones likely to be later than the first
one
so therefore instant to will be after
instant one again there are relatively
few methods on instant because all you
should really be doing is using some
them to record an instance and to
compare whether it is before or after
another instant then we've got amounts
of time
so an amount of time is something like
six years or nine months or thirty 2.4
seconds so these are nothing to do with
dates or time of day or wall clocks or
anything like that they're just a
straightforward amount of physical
quantity so we have two classes to
represent this we have the Java class
duration which is a time-based amount so
this is recording nanoseconds but we
express it as hours minutes seconds and
nanoseconds and it has some support for
24 hour days so you can create a
duration instant from a number of hours
you could multiply a duration by three
add on a number of minutes etc and then
down here at the bottom we're showing
how if you've got a local date/time
object or any of the others own date
time local time objects all the other
ones you can just add a duration to it
so again you can imagine your code will
look quite nice you might have some kind
of repeating things that you do every
hour and a half so you set up a duration
object of an hour-and-a-half and you use
that to add on all the time
no because Jew duration represents a
number of nanoseconds the the hours the
hours so when you create a duration of
hours of six hours it's six hours but
when you actually store it in the object
it's just a number of nanoseconds so
when you are multiplying it you're
multiplying the number of nanoseconds by
three and obviously
six hours multiplied by three is the
same as six hours in nanoseconds
multiplied by three so it doesn't really
make much difference the second class
we've got is period so period is a date
based amount of time so this one is
based on years months and days it's not
based on anything else and those years
months and days refer to the iso
calendar system so they're not tied to
any other calendar system so we can
create a period of nine months of six
days and there are our particular iso
8601 representations which are shown in
the comments on the right there again if
you have a local date/time object you
can add those amounts on now if you
follow closely you'll notice you could
have a duration of one day and a period
of one day
and those things are subtly different
because a duration of one day is always
equal to 24 hours but a period of one
day
is logically equal to warm day so if you
have a daylight savings gap or overlap
then a period of one day
could actually be 23 hours or 25 hours
depending on what the situation is so
there's a distinction between those two
concepts and in the API as a whole there
are a selection of other classes which
represent things that sometimes come up
in dates and times so we have a year
class which represents a year we have a
year month which represents just a year
and a month those credit-card expiry
dates on your credit card that's a year
in a month just combined a month day the
famous example is always the Brazilian
birthday because they don't like to tell
you how old they are there's a month
enum just an enum representing this
twelve months of the year and day of the
week and you
I'm representing Monday to Sunday so
there's your big picture summary of the
main classes in the API and the things
on the right are the two string formats
that each of those classes present so
because the two string formats are based
on the ISO 8601 international standard
they're all quite interchangeable and
quite useful and they though that
standard effectively also dries what the
classes represent so as you can see
basically you have a local date if a
local time local date time combines
those two you have an offset time which
just adds the offset from Greenwich on
the end offset date time combines those
and then by the time you get up to zone
date/time you've added every last piece
of information in and you fully define
where you stand
remember that picture up front where I
said time gets more and more complicated
the more you look at it where leap
seconds is a classic example of that 23
59 60 yes that is a time that sometimes
occurs according to the UTC standard
which is the standard that those atomic
clocks basically pump out so atomic
clocks measure si seconds system
internacional which is the standard
means of measuring all units and
measurement around the world and that
length of the second is absolutely fixed
it never ever changes but the length of
the day varies so if you've got
something fixed like a second and you've
got something varying like a day you've
got a problem to how to tie those two
things together and so more complicated
than there is the fact that astronomers
tell us the earth is actually slowing
down so the length of the day is getting
a little bit longer all the time so a
day is not equal to 24 hours or 60
minutes of 60 seconds real days are
slightly longer than that and so UTC
inserts these concept of leap seconds so
roughly once every 18 months you get one
extra second it'll occur on the
last day in June or the last day in
December and computers don't like leap
seconds because they're very they occur
very irregularly they're not predictable
then we're not told about them until
about five months in advance not very
good situations really so Java counts
milliseconds from 1970 what does this
mean well that's fun as well cause you
see the definition of UTC only started
in 1970 to spot the problem and yes the
definition of Java milliseconds also
assumes that there are exactly 86,400
seconds per day so it's the definition
of Java milliseconds which we've all
been using for goodness knows how long
doesn't work with leap seconds so what
do you do around a leap second well Java
just currently ignores the problem we do
a little bit better than ignoring the
problem kind of so what we do is we
define a Java time scale so there's a
time scale dedicated to Java now and
it's relative to civil time scale so
have these rules midday in the Java time
scale is always the same as midday on
the civil time scale a civil time scale
would just mean what are typical clocks
going to be other times match as best as
possible and we define the Java time
scale in two 86,400 seconds and but I
didn't say si seconds I just said
seconds so really there there are
subdivision of the day which we can call
seconds and we also fully define what
1970 means what this really means in
summary is you can ignore leap seconds
in practical terms the specification is
written such that if a leap second
occurs there's a particular smoothing
function that's meant to occur during a
leap second so a Java second is is like
one thousandth longer than si atomic
second during the smoothing period and
that's that's Chi we kind of get over
the get over the definition but since
it's kind of impossible for Java today
to actually get hold of that accurate
information
again it's kind of moot release only if
you've got hold of a very accurate clock
would you care about this kind of stuff
this isn't dissimilar to what Google
does they have their own smoothing
function which does pretty much the same
concept so intubation what about all our
existing classes well the date calendar
SQL classes and time zone there are
methods to convert to and from jsr 310
but the old class is not going to be
deprecated but you can think of them as
deprecated I'll let you think of them as
deprecated okay so J's are three ten
classes they don't reference the old
classes so you could imagine a future
world in ten years time where we got rid
of Java util date and Java util can
endure entirely and you'd only have a
new stuff great you know we can dream so
ISO 8601 as I've kind of been saying as
we go through all the classes have to
string formats that are based on ISO
8601 so this is nice and easy if you're
if you're writing and interchanging with
things like XML or databases all of
these other kind of stuff which takes in
ISO exit so one is their standard
formats you kind of don't have to do
anything you can just do two string and
you'll get a suitable format which is
great
databases as Roger mentioned earlier the
JDBC standard has been upgraded so you
kind of can it interoperate with it
providing the vendor and the driver has
done something about it and odds and
ends
cool
so we've got all these different classes
we talked about a local date local time
local date time offset time obviously
when you have lots of different types
you need nice ways to kind of move from
one type to another type so we've got
these at methods so as I said early
right early on that we try and make it
IDE friendly so apt method you can do at
control space and you'll see a selection
of methods which you can do to join the
class which you're currently on with
another class so here's our top example
we've got we create a year object and
then you can say at month March and that
will return a combined object of type
year month and then you take the Year
month object and you call the app day
method and that will return a local date
now I would never recommend that you
actually write this line of code in your
own code because you're going to have to
create two objects which you throw away
you might as well just create a local
data object directly but if you have a
year object or it might be a month
object from some other part of your code
these app methods come in very useful so
here's an example here you can take a
date you can add a time to it and you'll
get a local date time and then if you
take that local date time you can add an
offset to it and you'll get back an
offset date time remembering course
everything's immutable so we're always
returning a new object so here this case
we're taking the original date object
and we're calling at start of day in the
London timezone now why is it not called
at midnight or something like that well
because sometimes midnight to 1:00
o'clock doesn't occur because of
daylight savings time
so it's start of day just means the
earliest available time of day on the
date so it's taking care of that kind of
detail for you without you having to
worry about it and our last example here
we've got an instant object and we can
again just add the time zone to it which
will give us our zone date/time now in
all the examples we've talked about so
far we've got current time through this
now method taking no arguments but
course the current time of day depends
on your timezone
now there now method with no arguments
is basically about using the default
timezone of your JDK which for a lot of
smaller application is going to be
sufficient but if you're doing a bigger
application you probably want to specify
what the timezone is when you're saying
what the current time is plus we've got
other requirements we need to be able to
stop time for test cases maybe change
time slowly run time faster so we have
this concept of a clock which basically
allows you to access the current time
for an object it also allows us to do
inversion of control so your classic
injection of stuff so wherever you've
seen a now method with no arguments
there'll also be a now method taking a
clock object and because you've got that
object you can pass in a clock which is
the system time based on the system
current time Milly's or you've got a
clock object which might be based on
some other time so it just deals with
the situation for you so here's how you
might one way how you might inject it
you might actually insert a clock inject
a clock object using your favorite
dependency injection framework and then
you can just do local date now using the
clock to do whatever the stuff you're
wanting to do and of course what that
means is if you're writing a test case
you could inject a clock that's fixed
that stopped and therefore your test
case isn't dependent on the current time
we have formatting and parsing so as we
said before all the standard to string
formats are based on ISO 8601 but we've
also got pattern based formatting so if
you've used simple date format you know
why why why why mmdd type formats the
same thing is available there are a few
minor tweaks to the letters because
we're resyncing with the cldr standard
which actually defines the pattern
letters so there's another standard
involved there plus we have more
advanced formats of our builder class so
if you find the pattern letters aren't
sufficient you can use date/time form
a builder which allows you all sorts of
detailed controls right down into the
into the low levels of formatting and
obviously again we've got all these
different types so we need some kind of
unification system so most of you won't
ever need to worry too much about these
but there are these interfaces temporal
temporal axis ER and for field temporal
unit and Paul amount and these basically
form a low-level framework of interfaces
which allow all the different classes to
interoperate now the key point I want to
get across is if you're using the Java
collections framework you were typically
writing your code list l equals new
ArrayList so you have an interface on
the left-hand side and you have the
concrete class on the right hand side
with the DES with a Java time framework
you should be put in the concrete class
on both the left-hand side and the
right-hand side so ignore these
interfaces don't put temporal as your
variable type right put local date is
your variable type put zone date time is
your variable type don't put in portal
you'll find you won't want to because
these interfaces don't have nearly as
many nice methods so that you really
wouldn't like putting this on the
left-hand side but don't and and don't
and basically don't declare temporal as
a variable type as a method argument or
this kind of thing or a return type true
method unless you're writing something
really low-level in like a low-level
framework and then you might find it
appropriate for example our formatting
and parsing framework deals in terms of
temporals but that's because formatting
and parsing is very low-level can you
calculate the number of days between two
dates in Java today how many hits are
there on Stack Overflow or other stuff
programming sites to figure that
question out unfortunately with JSON 310
there'll be a bit bored now because you
just write days dot between date one day
to two
it's a bit too simple really
or you can create a period between two
objects which will calculate the number
of years months and days between two
objects quite nice really and yes it is
extensible as we set up front five
different ways basically all the various
parts the system can be extended but you
need to read the Java contracts again
not something any of you are probably
going to like not be likely to do but it
does allow us to have open source
projects which could write their own
calendar systems or their own
definitions of time if you want to have
a 28 day month for some reason you could
you could set that kind of thing up and
so in summary jsr 310 is a new date and
time API for jdk 1.6 gpf hard with
constrictions it's effectively complete
you can help us make sure it's bug free
it may have 25,000 tests but that
doesn't mean that there's not still
something lurking in there deep in the
depths try out a jdk 1.6 and open the
main list these days the mainly is open
JDK that should have got updated you can
help write documentation there's a user
guide site being built again that's just
on github you can send pull requests for
additional documentation to help
everybody around the world there's
another session on Wednesday which is
converting to the new date and time API
where we look into basically his his a
date class here's a calendar class what
do we do with them and also mention
joda-time
briefly as well a couple of links there
and time for questions anybody got any
questions for us
the question is the JCP process might
require us to have a renewal ballot if
they do well so be it and
JCP has all sorts of strange restrict
restrictions I don't tend to worry about
that any other questions yep i christen
these are the slides available online
I think the slides are going to be
available online I think all JavaOne
slides are going to be available online
after the conference finishes yeah here
you're asking what's driving and
conversion as in yes so the second
session is going to be basically saying
given a Java util date object or job you
to calendar object if you want to change
your code what might you do to better
better prepare yourself for the new API
yeah it's mostly a set of worked
examples I mean there's no there's no
requirement to modify code or to upgrade
it from Java calendar it's just we
obviously think it's a good idea yeah
it's not being deprecated so the
question is if you have January the 31st
and you add a month what happens you
don't get an exception you get the last
day of February yeah so it's where it's
the last day of February so yeah no it
it doesn't go to March the first or
March the second it if you think about
it you were asking to process the month
field so you expect to be one month
later and we just have to fix the day to
be valid because basically there are no
invalid objects so you have to we have
to fix it one way or another and that's
how it that's the solution adopted a
similar kind of problem occurs with with
zone date/time with time zones because
obviously if you end up if you add a
month or add a day and you end up in the
middle of a daylight savings gap what do
you do so rather than throw an exception
which causes all sorts of problems that
developers don't test for we just move
you forward a bit which might not be
exactly what you want but at least year
at least you're not getting the
exception and blowing up your whole
program which is usually what solutions
I think we were over there next
okay yeah so the question is if you've
got a date and time object in London can
you get a date and time object in Los
Angeles and yes there are there's nice
methods because you actually have two
choices do you want the same local date
and time but in a different time zone or
do you want the same instance in time
with a different time zone and so you
have the choice of methods and it'll put
them alongside you both methods
alongside each other in the IDE so it
will make you obvious that you have to
make a choice I think it's with zone
with zone same instance and with zone
same local depending on which one you
want basically
so the questions about short
abbreviations things like PDT and PSD
and this kind of stuff so if you
actually read the specification for
java.util timezone it says basically
these things were a very bad idea to be
in Java in the first place and we think
we should have removed them but we
couldn't so we have removed them kind of
so if you actually request something
like PST from the zone ID class you
won't get it but there's a second method
of section factory method where you can
patent it pass in a map of conversions
and we pre supply some conversions so we
pre supply a map from PST to America
slash Los Angeles so if you want to do
the conversion from PSD you have to pass
in PST and this map and then you'll get
out a suitable answer so we kind of
handle the situation but without soiling
ourselves with the old IDs the parser if
you're parsing a string into a zone
date/time I think the parser actually
will accept you a predefined set of
abbreviations
yeah but the pausing situation is
slightly different because in parsing we
get data from cldr and we manipulate it
in that way so it's a different a
different mechanism for creating a zone
ID yeah but you need to basically you
need to be very aware of it and in some
cases be very explicit that that's what
you're doing
yeah in general use America slash Los
Angeles ok
and you bring out something
you would have to use the formatter yeah
so if you use the formatter and use the
specific format string that is the short
name format string for the time zone
you'll get out PST well and the other
observation is if you have a zone date
time you can get a local time out of it
and then print that which does date time
which doesn't have the zone on it yeah
yeah you'd have to use the formatter
yeah short ideas for matter generally
yeah yeah I think it will give you the
next occurrence of Tuesday after today
so we actually have we actually have
four methods there's next next or same
previous previous or same so if you say
next Monday it'll get your weeks time if
you say next or same Monday or to get
you today and the same for previous and
previous or saying
so the question is can you get a time
zone out of an instant object and why
does that does it make sense without a
time zone so an instant object does not
have a time zone and an instant object
does not need a time zone because all it
really is is the number of nanoseconds
since 1970 UTC so there's no requirement
for a time zone for that definition it's
simply a large number of nanoseconds
it's always UTC yeah right yeah so it's
basically you know the to string format
of instance could be a ridiculously long
number but that wouldn't be very human
readable so to make it easy we print out
the human readable net actually
year-month-day but always in UTC it's a
human readable help yeah I think we've
got two more questions I think blue was
first
okay so the question is internally
within a local date object and a local
time object what do they store are they
a UTC variant or are they genuine
they're genuine if you actually go to a
local data object it has an int value
for a year a short value for month and a
short value for day of month and that's
all its doors so
so if you wanted to store a date object
in UTC what class would you use I think
you probably use the zone date time
because in general if you or possibly
office or possibly offset date time if
you're talking about databases offset
date time is is really useful if you
don't need all the complications of
daylight savings time switches yeah
that's what offset date time is best at
if you go and look in a typical database
all it actually has is the time and an
offset from Greenwich it doesn't know
anything about daylight savings time so
that's what offset date time is used for
and so to store a date at UTC that's the
closest match is offset day time
so the question is can you do anything
with a system clock in Java with the API
we haven't changed system current time
release so a system current time Milly
still does exactly the same as what it
did before what we've done is add in
this abstraction clock which is the
abstract class which is built on top of
system current time lilies but you could
implement it yourself to do whatever you
wanted so if you wanted to have a clock
implementation that's based on an NTP
same source
that's perfectly doable we haven't
provided one but it's perfectly doable
and the great thing about that in theory
is the NTP does tell you when leap
seconds are going to occur at least it
does in your theory doesn't always
actually accurately tell you but hey you
know and so if an NTP source did
accurately tell you when the next leap
second was going to be in advance you
could actually implement the smoothing
function which is defined in the API but
we haven't done that we provided the
instructions to do it and we've provided
the classes to do it but we haven't
actually done it one of the reasons sort
of not to do it is that it would be
really awkward if there were two api's
in Java that had different notion of
what time was and even if you kept you
know if Java util date had a different
notion of current time than Java de time
that would be a problem
furthermore you get another level of
problems if the the Java processes if
Linux time or Windows time is different
than the Java version of time so the
problem is a bit intractable but you
have to push it down to your original
clock source to really solve the problem
and keep the whole platform be
consistent yeah I mean in an ideal world
what might happen in the future well
leap seconds might get abolished this
has been talked about for a number of
years I'm not sure I'm in favor of it
but it would make life easier for a lot
of people certainly or you could have
the low level operating systems around
the world all the major vendors could
actually implement something properly
for either smooth out leap seconds or
tells applications like us detailed
information about deep seconds so those
are kind of the two major choices of
what could happen if you
given where we sit now it's all a bit
woolly and so we're a bit yeah
but woolly in a sensible way I yep
no no the questions about nano nano time
so there's the system current time
Milly's which is an actual date and time
and current nanos the nano time that's
in system it doesn't really have any
great meaning it has no relationship to
date and time asynchronous yeah it's so
if you had a system that had a that
actually had an accurate clock up
through the operating system you could
you could read somebody could
reimplemented
java.util system so that you had a
consistent accurate with the resolution
that you desire but the general purpose
operating systems they don't have the
resolution to do accurate nanoseconds I
think it's generally recognized of the
easiest way to get a nanosecond accurate
time today is through GPS which seems a
bit weird but apparently that's that's
the best way I've not investigated it
much but yeah but that's the kind of
thing it's like we don't want to in the
JDK provided to each GPS implementation
the clock class but somebody can you
know probably there's an open source
project great you know sounds good to me
I don't see more questions the moment so
thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>