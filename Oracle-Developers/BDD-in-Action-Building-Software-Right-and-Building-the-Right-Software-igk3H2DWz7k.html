<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>BDD in Action: Building Software Right and Building the Right Software | Coder Coacher - Coaching Coders</title><meta content="BDD in Action: Building Software Right and Building the Right Software - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>BDD in Action: Building Software Right and Building the Right Software</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/igk3H2DWz7k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay let's rock and roll miyamoto
musashi anyone know who he was one or
two famous Japanese swordsman from the
16th century probably the best Japanese
swordsman ever no it fought 60-yard
joules and never lost story about him
there's one time he had to fight a duel
of the Niland was challenged to a duel
so off he went on his boat had some guy
rowing rowing this boat across the
wasn't a serious just to Chen Albert
crossed some water to get to this island
now if you know anything about Japanese
swordsmanship samurai they have two
swords have one thought about so long
they have another short sword that's so
long on the way across
he picks up an oar he takes his short
sword and he carves the ore into the
shape of a very long sword made out of
wood he leaves his long sword on the
boat and uses the ore to fight in the
duel which is very vexing for the other
guy obviously so obviously he wins
because he went on to fight another
number of jewels the reason he did that
was that the other guy was known for
using a particular special type of sword
which was much longer than your average
thought so he left he shorter is shorter
a long sword on the boat and used to
Noreen said and won the won the jewel in
software as in dueling it's not just a
question of having the right tools it's
a question of knowing what tool to use
for the right job and to being a knowing
how to use the tool as well my name is
John smart I do a lot of work
in agile technical consulting so test
automation behavior-driven development
continuous delivery TDD and so forth and
today we're going to be taking a look at
what behavior driven development is so
an overview of BDD
from the top right down to the bottom so
what BDD is what a typical BDD workflow
looks like there are lots of variations
with just one example of what it might
look like what maybe there isn't what
tools are out there that you can use
when you should use them when you
shouldn't how some of a few tricks and
tips and best practices for automation
as far as BDD goes and if we have time
we'll have a look at a few gotchas of
how to apply BDD in real environments so
a lot of what I'm going to be talking
about it's based on the work I do in a
day to day environment so there may be a
few real-world examples coming up who
has heard of BDD yeah it's kind of a
loaded question wasn't it Hill users BDD
quite a few cool so what exactly is BDD
so Dan North who invented BDD came up
with this definition there are few other
variations with Kyoto gave a good one
too which is a little bit similar but
shorter so BBD in essence it's the idea
of using examples to build up a shared
understanding of requirements about
features that matter DVD is about starts
with a conversation starts with
collaboration BVDs not using cucumber or
J behave or spec flow BDD is a
collaboration exercise the tools come
afterwards
skewer with me while I get my slides
working properly so BBD is first and
foremost a collaboration technique it's
about understanding what features have
value and understanding how to deliver
that value in an optimal time that is
effectively it's at the heart of agile
development as well but it's a very
important part of BDD it's about trying
to figure out what where the value comes
from in the features of delivering half
of a lot of applications I've seen this
in several studies internal studies and
publicly available studies about half
the lines of code that are written in a
large application are never executed in
production that's a real bummer because
you're writing there's half half of the
lines of code you're right you could be
on the beach
it's not about identifying what bits of
code what bits of features actually
delivering the value getting feedback on
that and it's not a that's not a
waterfall approach it's not sit down
think of the value then do it it's an
incremental discovery approach it's all
about discovering the value not defining
discovery the only way you could
discover isn't by collaboration by
conversation and by feedback that is
really important can't emphasize that
enough
but there is an automation aspect you
see manually verifying that your
application does what you think it
should do it gets a bit boring after
after the Taurus restorations that gets
old
so automation can really help you to
speed up the feedback cycle it's like
test-driven development who does TDD
yeah quite a few so the beauty of TDD is
a fast feedback cycle if you can if
you're getting feedback cycle in seconds
TDD works well if it were if you need
several minutes to get feedback in TDD
it starts to lose its edge
so in high-level BDD you're not getting
minutes in feedback cycles but you're
getting fast feedback cycle nevertheless
and you're getting feedback much earlier
than if you had to wait to deliver a
full feature and that's really important
so the automation side of it helps
accelerate both the time you can get
feedback and the time it takes to push
your software out into production
so that is really important but on the
other hand automation is only useful
when it is contributing to driving out
features that you can get into
production quickly if automation takes
longer to maintain and is harder work to
write then the benefit you're getting
from the feedback then you're doing it
wrong so automation is not a cure for
everything you're going to do it right
to get the benefits of it now a lot of
you are doing TDD that's great
BDD if you apply the principles of BBD
to TVD it makes that a lot easier and a
lot more effective to work with it
removes the test coverage requirement
that I see in a lot of places you don't
need to worry about test coverage when
you're doing BDD seriously you can
forget about it you don't need it it's a
sort of nice gap you look at it from
Thomas and I yeah it'll basically I look
and I try and figure out why but
naturally if you're doing BDD and then
low-level BDD or some people just say
doing good TDD it becomes very natural
to have a high efficient test coverage
effective test coverage enough tests to
be comfortable confident and know more
so that leads into basically building
the software right building high quality
software if you're trying to deliver
fast you can't deliver fast if you're
not confident that the software won't
crash when you deploy it every time
that's where six-week testing cycles
come from because you're not confident
that your software can be pushed out
fast enough so when you've got a
combination of BDD and TDD or BDD at the
high level to know that you're building
requirement building the requirements
that have
and then at EDD level where you know
that your what you're building won't
break you can get a very high degree of
confidence and you can get that velocity
and part of the confidence also comes
from the idea of living documentation so
getting feedback in the form of reports
that are actually meaningful that's a
tricky bit you've got to figure out how
to do reports that are actually useful
in feedback not just for developers but
for testers for BA for everyone else so
in a nutshell very quickly what what do
we mean when you talk about BDD so in a
non BDD process I'd say this one you
could say this looks like waterfall but
happens in that jar to writing a story
it's just at the story level you come up
with some requirement so be a ricer
requirement as a word document or as a
story card or whatever developer goes in
turns out those requirements into code
the tester turns those requirements into
test cases you build something you
deliver it and it gets to the business
now the problem is that there is a lot
of opportunity for misunderstandings and
assumptions that misunderstood or
forgotten or things that are just
neglected things people forgot to
mention there are a lot of opportunities
for things to go wrong and that's what
BBD know agile tries to get around that
with the whole story is a calm place
holder for conversation and so forth
beauty beat was great the large extent
formalizes that idea so rather than the
BA coming up with the story and say here
you work that's a oversimplification but
you get the idea in a BDD approach you
use technique often called the screamy
goes where you get together with a story
or two developer tester be a product
owner if they're around talk through the
stories talk through examples of the
stories try and understand the
justification for a particular story the
values
that's supposed to be delivering and you
describe you describe these requirements
that are coming out of this story in the
form of acceptance criteria and in a
typical three amigos session you don't
go out of the three amigos session until
you have acceptance criteria which you
would be in a position to automate if
you wanted to them whether that be
gherkin or just concrete examples it
doesn't really matter but you want to be
in a position where you can actually
have concrete tangible acceptance
criteria things that would be directly
translatable or that can be executed
straight away I do three amigos sessions
where we're doing the cucumber or J
behaviors or SPECT flow requirements in
the session someone's typing them out
and once you do that these acceptance
criteria guide the developer and they
guide the tester as well
Chester uses the scenarios to know what
was supposed to what is meant to have
been built developer uses them to know
whether what they are building is
actually accurate
and it start is the starting point for
the TDD process if you're doing TDD and
the results when you automate them the
results test results that come out of
that act as living documentation to
guide the process to guide the project
and give the BA an idea of what's going
on give the product owner an idea of
what's going on so in a nutshell what
we're talking about the specifications
that are elaborated collectively the the
question
so the question is where does the three
amigo session happen inside a sprinter
before the sprint the answer like all
good questions is it depends some teams
will do it slightly before a sprint
starts so it can feed into if you know
what story thing in a tree you do it
before the sprint so it will feed into
the sprint planning sessions sometimes
you'll have a sprint you come up with a
story and say okay we're ready to look
at this now in the middle of the sprint
let's pick it up into a three amigo
session and enough out the details so it
does depend slightly before it's quite
good for planning but sometimes you
won't have time to go through them all
yes question
there's an analyst proceeded to complete
so the question is can you have a
separate meeting where the business and
us talks to the product owner and then
the business analyst talks to the
developer and tester in the 3ma oh yes
you can do that as well
that were that can work as well as long
as the business owner analyst can
effectively proxy the information if the
because what happens is be ace and that
the testers and developers will have
questions during this it that's the BA
doesn't come into those sessions with a
set of requirements the VA comes with a
set of high-level stories and nuts
through them don't work through them to
get the concrete examples you're not
delivering specifications you're
collaboratively discovering
specifications and part of that process
is saying okay we think we want to do
this but why do we want to do that is it
the best way to deliver value are there
other ways why what would what are the
impact of that what how how would there
be other alternative ways of delivering
that same value that we could do maybe
faster you've got to let that discovery
process happen and when you do that
there are a lot of questions that go
back and forth between the devs and the
testers and the BAS and the BAS have got
to be in a position to answer those
questions so the BA if you're doing it
that way the BAS could have a very
in-depth knowledge of the of the
requirements of the business
requirements otherwise they'll just
spend their time going back and forth to
the B it back to the business okay so I
want to have a quick look at a workflow
so this is a little application that
I've a sample application that's in the
BB D in action book to some extent it's
a frequent flyer application so it's
standard sort of frequent flyer business
case the more you fly the more points
you get so you can buy more tickets so
the business goal is to get people to
buy more tickets you always have a
business goal really important got to
know what the business goal is so that
you can actually know that any feature
you building relates to that business
goal from a business goal you're going
to have certain capabilities the
capability is the ability of the
business to deliver a goal may or may
not be with software
typically a capability could conceivably
be done without software but it's going
to be more efficient if you do it with
software maybe you can do frequent flop
the frequent flyer existed before web
websites so you could you could have a
frequent flyer program by mail and with
telephone and all the rest but it will
work better if you use technology
probably so these are the capabilities
we're trying to develop you come up with
some capabilities things like you want
to be able to earn points you want to be
able to spend points view how many
points you've earned and so forth from
those capabilities you derive features
so this is what we call feature
injection you're not coming up with a
random list of features and saying I
wonder if that'd be useful you starting
off with the capabilities that you need
to deliver a business goal come out with
features that will help deliver those
capabilities and then analyzing how
those features will actually contribute
because not all features are equal not
all features deliver value in the same
way so when you derive features from
capabilities mapping back to goals you
can get a much clearer idea of hey is
this useful or not what what are we
doing this for am I going too fast or
are we we're good so what do you have
your features take a feature and you
come up with your acceptance criteria
acceptance criteria are concrete
examples effect essentially concrete
examples that you use to test your
understanding of the requirements to
test the assumptions to flush out
invalid assumptions so here I got an
examining you need two points per two
points per kilometer so there are some
assumptions there is that points earned
or two point spent can that change will
it change depending on the status of the
frequent-flyer are there special deals
what happens if we get frequent flyer
points from other program
when you come up you come up come into a
three-meter session with examples like
that and then you nut through them you
work through them and try and figure out
are there any assumptions you haven't
covered that's where the three amigos is
about trying to work out what
assumptions you have not thought of
trying to come up with counter examples
try to come up with examples that will
break your picture your mental model of
the requirement and for each example you
can come up with a concrete more
concrete version of that example in the
form of often an automated test so here
we've got a gherkin type syntax where
you want to figure out how many points
you need to go for a particular
destination so already we've clarified
this is apparently the points you need
to go to a destination not the points
you earned from traveling which is our
going to be a different scenario and
we've got some concrete values so I've
got different departure and destination
and the required points and from that
example those examples a testers are
very good at come out with counter
examples in this case they might come up
with some examples where the distance is
not actually the real distance so you
have to make some sort of special case
for certain routes or something now from
those acceptance criteria who's used
tools like cucumber or G behave off so
there this will be familiar if you've
used that sort of tool here you can if
you're using that sort of tool you can
drive test Kay automated test cases from
those acceptance criteria mapping back
to the text in the acceptance criteria
and from them you can then derive the
accept the your application code now the
application code sometimes you can write
it directly sometimes you can just say
hey this acceptance criteria we're happy
with this let's just it's one line it's
a one-liner just do
but often you'll transcribe part of it
into more detailed low-level specs
low-level specifications in the forms of
what's conventionally known as unit
tests I don't really like the word unit
test anymore because my distinction
between unit testing in integration test
is increasingly fuzzy and context based
so I basically will do write the test
that I need to write which is the most
convenient for me at this point of time
to verify whatever requirement I'm
trying to elaborate or whatever API I'm
trying to define maybe I need to mock
everything out maybe I'll go direct to
the database I don't really care it
doesn't make that much of a difference
time is really the main factor if the
test is going to be really slow then
I'll try mock stuff out or if I if it's
complex and I want to isolate a bit of
logic but what I'm saying is I'm
thinking more in terms of on writing
specifications and then whether it's a
unit test or an integration test that's
an implementation detail what I'm really
doing is writing a specification for a
low-level API and we'll look later on
yes with questions
when I say the question rules would I be
writing specifications for unit tests
that's kind of the other way around my
unit tests are specifications it's just
at their specifications for classes and
components not for webpages so this is a
required point should be calculated
based on route distance that's a
specification how's that specification
implemented we'll have got two points
calculator class which uses our route
repository which in this case I've
knocked out and here I described if I go
calculator points equals point
calculator calculator points required
between and then the departure
destination here I'm discovering the API
that I would like to that's TDD style I
discovered the API that I would like to
have I defined the API here I'm
specifying my API and then I implement
the API to make it work that's what I
mean by writing specifications in the
unit tests at any level you're writing
specifications it's just a matter of are
you writing specifications for the
application as a whole or for more
detailed part of the application it's
always writing specifications and
documenting specifications you're always
documenting behavior if you're not
documenting behavior the unit test is
pointless really because if you're not
documenting behavior what do you do if
the unit test breaks if the unit test
breaks and you don't know why it breaks
or what it's supposed to be proving you
might as well just delete the unit test
a unit test should be clear enough so
that you go and look at the test it's
broken you say root were required points
should be calculated based on route
distance ship doesn't work it's wrong
disk calculating on two times the
distance yes question
so the question is should the the units
and integration test be aligned with
scenarios the answer is absolutely yes
unit tests and integration tests are
derived from the business goal that
you'll which pass through the scenarios
if you're writing unit tests for
something else why are you writing it
what business goal you try and what
feature you're implementing it
implementing sorry I have seen teams and
make up time to degree so I have seen
teams that have written code cover test
for code coverage where it will do
things like throw an exception try catch
check that the exception has a message
that you just threw gets you code
coverage so yeah oh that's why I'm
saying if you do this approach where
you're driving your unit and integration
test from the scenarios you don't need
to worry about code coverage code
coverage is about spotting things that
you've forgotten that have gotten
mislaid that have got refactored out of
necessity you might have done some
refactoring and suddenly a piece of code
is no longer than this no longer
required so it's got no code coverage so
oh I can delete that
that's what code coverage is for in this
context you don't need code code does Co
coverage doesn't tell you very much
really it only tells you what has not
been what code has not been exercised
during your test it doesn't tell you
what code has been tested not very well
the only thing that tells you what code
has been tested is the tests the quality
of the tests so you need to be able to
understand how the tests demonstrate
that an API does something so what are
we actually getting out of these other
than working code details from your high
level requirements you're going to think
end up with views on where your
application is at from a functional
point of view so what's being delivered
in terms of what acceptance criteria are
automating what acceptance criteria
passing so this is a people got a high
level view aggregated by capability but
you also have a description at the low
level description of how each story or
each feature has been tested so
different views are useful to different
people yes from a product owner
standpoint you get the you know that the
feature is work in progress because then
depending and then you realize you know
that the feature if it's green it means
that it's been delivered because he
accept this criteria pass so I may need
some more manual testing for usability
of user experience but fundamentally
it's been delivered so you're going to
have different reports based on
different levels of detail so I think I
have a slide at the end if I don't I'll
include on what tools are actually used
in this demo but you go basically the
idea is you want to come up with an
acceptance set of acceptance reports
acceptance criteria reports living
documentation that communicate what you
want to get out of so tools are cucumber
and J behave unfortunately a pretty poor
at reporting which is a shame but there
are tools this one's called Thucydides
there are tools out there that do that
can help you do proper reporting out of
the after the acceptance criteria
but as I was saying earlier you also get
reporting so to speak documentation for
developers so this this is a scenario we
saw earlier I think yes it is that is
technical documentation that explains
how your API works that explains how
your application works that's the point
of it it's worked examples of your
application code so don't write unit
tests because you want to test a method
write unit tests because you want to
illustrate how you think your the API is
going to be used
you're basically documenting your
thought process the thought process that
goes through your head when you write
the code that's the idea of this sort of
testing you can even get to release type
reporting so if you can categorize
acceptance criteria by capability or by
feature you can also categorize it by
release the iteration must print what
acceptance criteria what features are
due for this release and where is it
even got a six months or a year long
project there can be a lot of stories in
there you want to be able to drill down
into what you're working on at a
particular point in time for it to be
meaningful at this point in time so when
you're coming up with your living
documentation strategy you want to take
all all that into account
so tools what tool should we use first
thing you want to remember is that
always remember the tool will be useless
if you don't get the collaboration right
if you don't get an understanding of
what features he's trying to build and
what value you're trying to get out of
the application automation will go off
in the wrong direction and be relatively
useless will be worse than useless
it will be an overhead you don't want
your automation being an overhead if
automation is overhead you have to
rethink it and wonder why's that an
overhead is there a way we can stop
being an overhead it shouldn't be well
so it's a little bit of an overhead but
to me a massive overhead and the key to
doing that is knowing your audience who
are you talking to yes question
so the question is or comment that the
more automation you have the more
expensive refactoring can get true and
you've got to put your engineering hat
on and figure out strategies to as you
do how do you make your application code
easier to refactor same techniques laser
abstraction don't repeat yourself same
sort of techniques in apply it as normal
software engineering you apply to
automation if you write all your tests
as one level test scripts that will be
hellishly hard to maintain if you do use
page objects components reusable steps
reusable libraries it makes it a bit
easier yes it depends some to your point
in the high level acceptance criteria
you're interested in the business the
scenarios of the significance of the
business field validation is probably
not may be entering a date that has a
significant impact on the business
calculation maybe that is so maybe that
validation is important say there it can
be duplication with the unit tests not a
problem I don't mind a bit of
duplication with the unit tests because
it's different audiences unit tests are
to document your API the high level
acceptance tests are to provide feedback
to the large broader team about where
you're out yes another question
so sometime QAR the question is q wave
will often come up with lots of
educators they're very good at that and
it's that's part of their value getting
though all those educators some of the
edge cases will be regrouped into a
signal it can be regrouped into a single
case some of them will be things that
you want to report on others you can say
okay we'll test this at the unit testing
level you've got to build up confidence
with the testers to say okay we've got
this covered
we'll test that at unit testing or the
testers find it very important to know
that if you've got a table you add two
or three lines not a big deal as long as
it's not a web test it's a web test
you'd hesitate a bit so you will get
edge cases and you want to cover them
you just I'm not saying don't cover edge
cases you can't you're allowed to cover
edge cases don't go crazy on it don't go
overboard don't do every possible
combination or every field value being
entered on a form the more you get well
very edge cases usually aren't that hard
as far as maintenance goes because
they're just variations on a flow it's
more the performance the speedy impact
so we've got two basic categories of
tools you've got your high level tools
your j-bay is your cucumbers your spec
flows lucid it is which are more further
reporting side for non developers as
well as developers so about
communicating where your where your
project is that where the features are
out in the development process but
communicating at a higher level so these
effectively they're more complicated to
write they involve higher maintenance
because they're harder to write
typically I say you don't want to write
all your tests as acceptance tests at
this level but there are effectively
techniques so for those if you aren't
familiar with the tools in G behave for
example here we've got an example with J
behave each line of code maps to an
annotated method call cucumber syntax is
very
slightly different and instead of in
this example J behave example we've got
you can see there's pointy brackets and
variable names in the string in cucumber
you get regular expressions now one
night thing about cucumber is if you're
working with Jarboe it's like Jay
behaved you need to have a method name
and the name of the string a bit of
duplication there if you're working with
who's familiar with groovy a few if you
like groovy then you can do use cucumber
and groovy and in groovy you're allowed
to have text just just strings as method
names so rather than having an
annotation based on the on top of a
method name you actually have the string
so you have given a member has a status
of whatever that's your method name so
you avoid that duplication so that's
kind of cool so set of these is what we
saw earlier on the tool that will
produce the reports that's basically a
living documentation tool that helps you
produce aggregate reports from the
acceptance criteria and also helps you
structure the acceptance criteria in a
maintainable way so typically use it
with something like J behave or cucumber
or you can even use it with J unit I
dunno chains that do bdd acceptance
criteria with J unit which is done an
example here basically what you do is
you have a method which is the
acceptance criteria and inside you have
steps for the given when then SEC and
each method a step method is reported as
a separate step in the in the test
process it's not as elegant as I find is
just a raw text but there are teams that
like doing it that way can said I want
the overhead of the feature files and
you still get the reporting value well
you don't get is a feature file that a
tester or a be a can can write or work
with but you still get the same sort of
reporting similar reporting
I didn't want to
here we go today in a nutshell what are
we trying to get out of a high-level DVD
- what do you how would you choose one
you want your high-level bdd tool to
talk to the business to produce results
reports that the business can understand
now that's really important not as
simple as it seems because a standard
test result report with a whole list of
test results is pretty useless to the
business it's way too detailed you want
you need aggregation to have any at
least at the feature level or preferably
higher to be useful to the business but
for testers you want to be able to drill
down so they need to be able to drill
down into the details you want this sort
of tool to integrate with the build
pipeline in fact you cannot have this
sort of tool will not work if you can't
that's why it tools like the the HP
tools his name I can never remember not
quality Center the other thing they
don't work for this other than the fact
that they're unmaintainable and they
silo the test process and they encourage
rubbish tests
they don't work because he can't fit
very very hard to fit them into a build
pipeline you want to be able to have
your Jenkins build pipeline we just have
the acceptance test that's a job and to
make it part of the flow so that means
it needs to be in version control your
tests need to be part of the version
control so there are tools by Fitness
which typically a wiki based problem
with that's nice does anyone could edit
it but the problem is if it's not in
version control it's harder you don't
know what tests relate to what
particular version so continuous
delivery becomes quite tricky you need a
set of acceptance criteria to match our
particular release of your application
and if you have to go back to a previous
release you have to know what acceptance
criteria were executed for that release
the other side of it is you need to
integrate with the broader
infrastructure of your development
environment so if you're using JIRA or
rally or whatever you need to have be
able to relate back to the story cards
in JIRA or really derive the
requirements from those story cards
report on the requirements that are
documented in JIRA or rally or whatever
relate directly directly back to those
requirements so you don't have to
duplicate the the information because
it's all about collaboration yes
question
so the question is can you put the
scenarios in JIRA or rally or should
they be in version control they have to
be in version control otherwise you
can't version them so there are plugins
for JIRA for example that let you put
the given when then scenarios in in the
JIRA cards I find that really doesn't
work in practice because it's just not
convenient just not practical for a
developer to refactor and work with yeah
well that's the experience I have as
well so it really does need to be in
version control you can relate often
what you do is you put a tags on an
issue tag or something that relates back
to the JIRA card and then tie in the
reports that way that's what I usually
do but you need the scenarios to be in
version control so in a nutshell if you
want to take away one thing for how to
make your test more maintainable use
layers layers do wonders for making your
high-level acceptance criteria
maintainable so what we saw earlier on
we didn't see this example but it's an
example from the same app you're given
when then as a business flow you're
given when then is not a test script if
you've got a given when then was 10 or
20 wins or 10 or 20 then that's not a
scenario that's a test script and test
scripts are hard to maintain it's not
their job it's not the job of a given
when thenns to say given I enter J Jane
in the name and Smith in the family name
and 30 in the age and that won't work
it's really hard to maintain you want
very high-level business flow you want
it to be detailed in the business goals
but general in the implementation talk
about what and not how then underneath
in the details you're going to have in
the step definitions there you're going
to go a little bit further down but he's
still not these step definitions aren't
reused
much they reused with the scenarios but
you don't have different variations so
you only you still want them fairly high
level so typically you're going to have
another level down where you're going to
the details so here we've calculated the
points needed for from a departure to a
destination and in the details there you
enter a depart destination city a
departure City and calculate the points
and then in the actual page the page
object so it's everyone familiar the
page object model so the idea of page
objects is you encapsulate the logic of
a web page or a component of a web page
into a class and hide away all the web
driver details in that class so you
don't if you have to change things you
only have to change it there and so this
would be a typical method within a page
object right down the lower level if any
other test has to access or any other
scenario has to do a get calculated
points it will always come here so
that's your own if that changes that's
the only place you need to change no
matter how many tests you have yes
question yes so the question is at the
very bottom layer is where selenium
comes into play yes absolutely this is
the bottom layer here is using selenium
so that dollar required points it's a so
under the hood there's webdriver
yes
level when you're receiving em so the
question is at the top level how do you
know that the in the reports have you
know that that actually gets tested in
detail you me in the test report so test
reports we saw you might have noticed
you can drill down in the given went
then you'd then open up the given went
lens and see what steps were executed
what screenshots were played through and
so forth so you need to be able to have
that a high-level view in the test
report but then be able to drill down
into the details when you need to you're
absolutely right you do need sometimes a
test or in particular needs to be able
to say yeah sure okay and check the
status how'd you do it yeah yeah so
that's what I alluded to earlier on with
those reports you drill down into the
details and see the screenshots yes
and he giveth dropped archaea okay
he uses calculating his status once
agency right so you saw that 100%
education you would probably talk about
educators in the Surrey Amigo session
make them so the question is what do you
do with educators how do you know where
the edge cases are have been catered for
and so the three amigos session will
cover significant edge cases that's the
point of it and you can make a judgment
call and whether you want which ones you
want to automate at this level which
ones you want to leave to the unit tests
so you do will get coverage of the edge
cases the important ones the ones that
the business is interested in you'll
have another thing that so the question
is what's the best practice for edge
cases so this is in a feature file you'd
have I typically have one feature file
for happy day scenarios in another
feature file for edge cases another feed
one scenario rather for happy day and
one one or more scenarios for edge cases
you'll see in the yes you'll see so the
question is if an inch case files does
the acceptance criteria file and yes it
will appear as broken if there is an
edge case broken so in a nutshell what
we're trying to do here is the other tip
if you want to take away on writing
maintainable tippers criteria is go easy
on the UI tests because they are
complicated to write and hard to
maintain and faecal if your browser runs
out of memory your tests will break
you'll have to dig down to figure out
why their firefox gets updated
automatically as they do sometimes it'll
break and you'll have to figure out why
they'll pain so you don't want to go
over what on the edge tasters the reflex
of testers is generally to test with it
whereas from the UI perspective if you
want to question that put that into
question do you really need to test
through the UI oftentimes you don't
oftentimes you can test directly against
the API all those point calculations one
scenario through the UI it's probably
enough if you got lots of variations
just do it through the API because the
API test will be much faster and more
reliable
so the question is how to use BDD for UI
testing you start with the high level
business goals like I was saying there
individual bits and then in the steps
that I was showing you there you
actually flesh out how you step through
the screens start in the details the
implementation of the tests how you
actually deliver that feature but in the
high level you have the goal that you're
trying to achieve absolutely the steps
so the steps are speaking to speaking to
the webpages and the third third tip is
when know when not to test know when not
to automate there's some things that are
not useful to automate not a lot but
there are some things will be
objectively too much overhead or too
hard to set up or too much you are
paying to be to add much value
automating you can just do it manually
not a big deal
just know be aware of it you don't have
to automate everything automate the
valuable stuff first and then you can as
you get better at the automation you can
automate more stuff you don't have to
automate everything the value is in the
conversation
understanding what delete value you've
got to deliver automation is a bonus so
at the lower level just run through a
few of the tools at the low level TDD
stile TDD level BDD which the dear big
differences these tests are aimed at
developers other developers who are
documenting your thought process your
code for other developers your writing
technical documentation you can do that
with j-unit so here's an example of a
JUnit test
the trick is write the method names and
the class names in a way that explains
what behavior you're documenting rather
than what test or what method you're
testing so here we're saying what are we
saying should instantiate database
to standard airport airports says what
the application is expected to do Spock
so if you're into groovy Spock is a
really nice it's my preferred way of
doing this sort of low-level test just
because it's so lightweight and
expressive so we saw this example
earlier on where you set up mocks in a
very simple way or doing data-driven
tests with tables so this sort of you
know Spock is really worth investigating
if you know if you have any inclination
it's a good way to play around groovy as
well it makes very readable
specification as a method suggesting
text so a blue you look at a glance you
can see what a API is suppose to be
doing if you're not into grooving you
prefer Java right there's a tool called
Lam to behave as well which it's more
aspect style but gives you a more
descriptive way of describe specifying
your low-level requirements so in aspect
style you saying rather than saying give
it away and you say it should do this it
should do that and so lambda behave uses
some funky job rate stuff to let you
write fairly fluent descriptions of
behavior I find it more wordy than Spock
but still it's it's fairly new it's
quite nice idea so the low-level tools
the important thing of a low-level tools
it's going to be developer since its
developer centric it's got to be
developer friendly but at the same time
it's got to be readable so you've got to
be able to look at a low level
specification and know what that that
what the unit test was meant to do what
behavior of subscribing and what you're
supposed to do if it breaks so if you
think in terms of your writing
specifications or writing technical
documentation for your API you're not
writing tests
that's a good start no matter what tool
you're using and the tools you may need
several because if you're doing
angularjs you might be using protractor
or Jasmine you need to choose the tool
that's most appropriate for the
technology stack so before just the last
thing I want to cover is a few anti
patterns that I see sometimes the first
AV pattern that I find is when the BA
writes the scenarios it sounds like it's
the same thing but if the ba rights are
scenarios delivers them to the three
amigos fashion you're not doing
discovery you're not discovering the
requirements you're reviewing the
requirements and reviewing your document
you all know it's a whole different
ballgame to actually collaborating on
building up a document you don't get
it's good feedback that's already done
I'm not gonna touch it but yeah it looks
good okay next but if you if you come
with just a few examples yeah we think
it should do this should be based on
distance let's see
distance were calculated or travel it's
what do you mean by distance you get a
conversation so in bas we'll have to do
homework sometimes with you don't want
bas writing the scenarios upfront second
anti-patterns the opposite I've seen
this yeah we were doing BDD bill over
there he's a tester he does all these
testing cucumber no that's not BVD
can be very useful but it's a whole
different approach it's whole different
thing if you're writing test for a
legacy application in cucumber know why
you're doing it there may be good
reasons to do it you may be documenting
writing regression tests for an existing
system documenting behavior but know why
you're doing it's not BDD BDD is
collaboratively discovering the
requirements and then doing the
automation
third one is the three amigos you get
together have a bit of a chat and then
go as a room and forget everything you
said three amigos you want to come up
with your concrete examples want to come
up with if possible executable scenarios
or at least connect at least actionable
scenarios otherwise it's a bit of a
waste of time and the fourth one is this
gets even experienced BDD teams
sometimes because it's easy to do you
get scenarios that a to UI centric to UI
focused or to focus on the water not the
why and the how or the how rather than
what I should say focused on okay we'll
get this screen went to these details
then we'll do this and then why are you
doing that again I've seen teams creep
up with this even experienced teams so
be wary when you start to have scenarios
like that scenario should be short and
concise maybe four or five maximum lines
if it gets much longer than that that's
a bad sign so that's my Big Daddy
gotchas just a plug I'll be doing a book
signing tomorrow at 12:30 in the
bookstore somewhere around upstairs
Benny I want so signed a book and I
think we have four minutes left for any
remaining questions yes one
so how the specification by example how
does specification by example the later
BDD it's another word for high-level BDD
in a nutshell
how do you make sure teams or reusing
existing that's a good question
spec flow net tool actually has a report
that lists all the variations of names
of steps and you can say oh there are
ten variations of the frequent flyer
should exist that might be a sign that
people aren't reusing steps so there are
reports that help do that but it is
something you need to basically it's do
code review yes
what is the advantage having a developer
working with an analyst rather than
analyst working in pairs different
perspectives saying we testers here
different perspective developers will
leave a more technical angle on how
analysts may have an idea or how to
build something with developers may have
a very different idea saying we test as
testers will be more critical they'll be
able to say hey this is rubbish you
forgot this case that's about different
perspectives yes what's a good way to
start BDD as a team just start with the
three amigo sessions don't worry about
the automation yes so if you put your
features in the code repository what are
you put in your story in the story you
put basically headlines for the
scenarios that will be in the feature
files basically notes for okay these are
the examples we want to work through
with the acceptance criteria and then
you'll have typically an annotation in
your scenarios that map back to the
story
yes last chunk last question so that the
given where the scenarios are British on
the UI site the strategies are using
layers page objects not writing too many
of them
and then there are skill there's a skill
required at this at the webdriver level
way knowing what to wait for for example
knowing when to wait when not to wait
how to wait that's typically that's well
that's a that's a bad sign that means
they don't know what they're waiting for
so the tests become brittle because
you're just waiting for something you
don't know what you're waiting say wait
one second but if it takes a bit more
than one second you're out of luck now
which often happens on virtual
environments yeah there is skill
webdriver skill that's important plus
the straight the layering there the be
there the biggest elements pairing
developers and testers that can help and
avoid having too many new artists
okay I think we're out of time I'll be
hanging around afterwards anyway thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>