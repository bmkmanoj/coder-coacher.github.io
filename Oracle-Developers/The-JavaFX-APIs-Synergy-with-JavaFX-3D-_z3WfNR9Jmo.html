<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The JavaFX API’s Synergy with JavaFX 3D | Coder Coacher - Coaching Coders</title><meta content="The JavaFX API’s Synergy with JavaFX 3D - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>The JavaFX API’s Synergy with JavaFX 3D</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_z3WfNR9Jmo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Joe and Grayson and I'm a
graphics engineer on the JavaFX
development team and I'm going to be
talking to you about synergy with our
new 3d API alexander is on the way
should be here in a little bit he's a
software engineer works on the demos
very very good at doing javafx stuff and
he's also an avid drummer too so this
talk is about stuff you can do with
javafx today you can go you can download
the builds that we release and you can
all the stuff we're showing you you
could you could code up today and do it
today I'm going to talk about why
synergy is important especially with
api's the as we go along we'll be
reviewing the parts of the AP is that
we're using hopefully you're familiar
with with most of them if not then
that's ok then we'll be talking about
some of the demos later on in the other
half of the talk so what do I mean by
synergy in this case we're going to deal
with more than one part of our API we're
going to do something awesome and it's
not going to be complex you know when
when you're coding up things you know
lots of people there's our games out
there a pearl golf is one of them where
you try to do as much as you can and as
few lines of code as possible with pearl
that gets ugly but you know in javafx
there are tons and tons of different
parts of our API from images to to you
know media to canvas and rendering
kind of like html5 kind of rendering 23
and now we have 3d it's just it's
limitless and web view its limit
limitless the the things you can do and
so I'm going to focus on come the
synergy between kind of two parts of our
API its kind there's going to be a
recurring theme that you'll kind of pick
up on as as the talk goes on and the
first part is the JavaFX 8p api java
flex 8 api without 3d and that is mostly
i'm going to just consider that mostly
as it as a 2d render in general terms
and it can be hardware accelerated as
well the other part of the api is the 3d
api that comes with javafx 8 and with
this 3d API you can render 3d content
you can render using lights you can
render meshes you have camera nodes and
with with subscene you can have embed 3d
content so we'll be getting to that as
we go along
so the first thing I'm the first part of
the API that we're going to use is
canvas and canvas was introduced in
javafx 22 and it's a custom texture that
you can draw 2 and you get a graphics
context from it and it's very similar to
like an html5 canvas where you know you
called G dot fill wrecked and you know
guida apply effects set effect there are
many draw commands from the graphics
context and it's kind of it's different
in the sense that us apart from the
regular scene graph where you would you
know create a circle node or a rectangle
and then add that to the scene graph
with canvas you create a canvas you add
that to the scene graph and then you get
a graphics context from it and then you
can draw rectangles and effects using
the graphics context so here is a little
example of what you can do with with
canvas this is a carbon fiber pattern
that I wrote and there's some code there
on the left kind of going through how
you would get the graphics context is
just a small canvas it's 300 by 300 and
then the top left of that that pattern
there is that kind of rectangular
gradient going from top to bottom that's
how that was created there with the fill
wrecked and then I set the fill as the
kind of the blackish to gray gradient
for for carbon fiber and all will go
over the the rest of that when we show
the demos so the next part is snapshot
this was also introduced in 22
and it quite literally renders an ode to
an image and so you can maybe see where
we're going with this we are going to
well here's an example of how one might
use snapshot there are some parameters
there a lot of times what I'm when I'm
doing like snapshot of of a node I try
to choose a color that stands out a lot
especially if I'm trying to cover the
entire image with my node that way if I
miss pixels then those speeds like
glaring at me like for the example green
if I miss some pixels in that pattern of
that canvas then I would see green
pixels there and I would know hey wait
my filling of my rectangle is not quite
right so that's that's something you can
do then all you can also pass in a
perspective camera or a camera for the
snapshot and then the second second
parameter is a writable image that that
you can supply so let's take a snapshot
of this this carbon fiber pattern and
you can see there but that line of code
pretty much does that and returns an
image and then next we are going to set
that image that we got IMG right there
is the the image of the snapshot that we
just got and we're going to use image
pattern on another canvas and the zero
zero point four point four true is an
anchor rectangle which kind of shrinks
the it shrinks the pattern and makes it
you know tile excuse me makes it tile
across the entire the entire canvas and
then we're just drawing a rectangle or
issuing a rectangle fill rectangle
commands across the entire canvas
and you can actually get a pretty
compelling carbon fiber texture there
looks pretty good so what are we going
to do with that well and using the 3d
API we're going to talk about mesh fuse
and a mesh view represents a 3d surface
in the scene graph and that's specified
by mesh and here's an example of how you
might create a mesh view fairly simple
you'll notice that mesh use a node so we
can transform it translate x and y and z
and rotate it and then we add it to the
scene graph at the bottom there you'll
also notice that we're setting a
material a faun material and that's our
next that's our next part of the API and
happens to be a pivotal one for this for
this talk and so a material describes
the way a 3d surface is rendered and
this is actually not you know this is
not only for javafx this has to do with
just general graphics usually materials
contain textures colors and whatnot and
when applied to a mesh when you render
it describes the color of the pixels on
the mesh so what are we going to do oh
of course here's an example of file
material you can see we have diffuse
color specular color bump map diffuse
map and specular map now here is the key
material takes regular old javafx images
so we just created an image with
snapshot and so if we using those two
parts of the API we can
snapshot that canvas of the the carbon
fiber texture that we had earlier and
you can see where we're just passing in
default snapshot parameters and then we
are creating a new file material and
we're static setting the diffuse map of
the snapshot at image that we just got
of the carbon fiber texture and we're
setting that material in the mesh view
and we get a carbon-fiber texture on our
sphere there now this is this is a
recurring this will be a recurring theme
but there's tons of stuff you can do
with this and not only can you apply
textures that you generate beforehand
but you can generate text you can
generate a snapshot of canvas on the fly
and so in order in what that gets you is
that you can paint on a model and we get
that by adding picking and then in the
picking handler you can see here and if
you can see that in the back but you get
you can get intersected this distance
you can get the face the node the point
and the text cord of the pic result of
what you picked and so that can help you
you know you'll see in a little bit that
helps you get lots of different results
I'm sure I'm not going too fast
so just before we continue we'll review
a little bit about the mesh data layout
because this can be a gotcha if you're
trying to to get at your triangle data
and you're not familiar with the layout
of the the data so there are three
arrays there's a point array up at the
top and this is this isn't triangle mesh
and the layout is XYZ XYZ and you'll see
those little lines below that the second
XYZ there that is the num components per
point and that is that is a value that
you can get from triangle mesh and then
you'll see the next one is our texture
coordinates and those are laid out UV UV
and the second component the the two
bars there a show that that's the num
components / text chord and then the
final is the faces array and those have
p 1 t 1 p 2 t 2 p 3 t3 and that entire
block there is numb components / face
and so those values are in dec indices
into the soapy one would be the index
into the triangle mesh when T 1 would be
the index into the the texture the
texture array and that will be important
later on so here is quite a bit of code
here but it's fairly simple we're just
getting the the value of the x y&amp;amp;z and
wilshire i'll show you and later on what
the what this code is good for but you
can see there where we're getting the
triangle mesh num components / face and
we're multiplying that
by num components per point to get to
get the data that we need there
so what do we do with the with the pic
result well we're going to sew so we're
going to use the UVs that we get from
the pic result you can see up there at
the top get intersected text cord that's
going to review the text cord that we
pick on and then we're going to we're
going to multiply that by the canvases
width and height and so in UV in texture
space it goes from 0 to 1 on the Y and X
and so if we multiply that by say say
you pick it right in the middle of your
your movies and your model and you get
point five point five and then you have
a 300 by 300 canvas and you want to draw
on the middle and if you're going to
apply that canvas later on to your model
then you just multiply it by the canvas
width and height that puts you at 150
150 and then you're right smack in the
middle and then there's just a simple
example there of you know setting a
setting a fill for a just a color and
you know that color could that could be
anything that be gradient or anything
but in this case it's just a solid color
of a brush and then we are filling an
oval and the if you were to just draw an
oval at the position that you you have
their ovals are drawn from the origin
from where you fill it is in the top
left so if you if if you were to have a
tablet for example and you were painting
on your model that it would be kind of
annoying if you press down on and your
oval was like offset where your where
you press down so what we're doing here
is we're taking the size of our our
brush which is just this paint cursor
which you'll see later and we're
subtracting it
half of it so that it offsets it and so
that when you hit when you click the
Oval is centered on your on your pic
result and then it's just a matter of
excuse me what's a matter of calling
snapshot and and setting it as a diffuse
map and then we set the material as null
on them reset it again to make sure that
it gets updated now and another thing to
note is well we'll get to it later but
but snapshot is is not free it takes
there's there's quite a bit going on
there in terms of rendering so calling
it in a in a picking in a pic result and
a mouse drag event for example is
expensive but we we can optimize it and
we'll i'll show you in a later on when
what that's like so another hint is when
you pick on a 3d model the pic result
that you get the point 3d that you get
is in local coordinate space so you have
to remember to multiply that point by
the nodes nodes local to seen transform
and then that gets it into the proper
space that you that you would want if
you if you want and so you can see down
there that code is is doing that right
there
so we will just demo that in a little
bit so you don't have to use canvas for
setting your images you can use writable
image as well and writable image doesn't
have a graphics context but if you just
need to do pixel bashing if you have a
per pixel algorithm that you want to do
then writable image is just fine and so
a perfect example of that is converting
a height map to a normal map and in
javafx you can we can do that and I have
an example here so really quickly for
those of you not familiar a height map
is a raster image used to store values
such as surface elevation data and a
normal map is a technique for faking
lighting of bumps and dents and that
that data is obviously stored in a
texture as well and so here is an
example on the Left we have a height map
and on the right we have a tangent space
normal map which is what javafx takes
and those are not this from the same
source those are two different those are
two different from two different things
but yeah so step one we're going to
supply our height map luckily the carbon
fiber texture that we created earlier
was just black and light pretty much
gray which is fine and so we're going to
get a pixel reader from that image and
then fill it up with into height pixels
there for some pixel bashing
and then we're going to mash some pixels
we're going to iterate through I didn't
put all the code there but this is this
is a code that you can you can look up
algorithms on the internet for doing it
but basically you compare the the
intensity of the points relative to the
point you're looking at and that
describes to you the change in elevation
or the change in height of the surface
and then you can construct a normal that
kind of points in a particular way based
on on those values and so you can see
there there's some there's snippets of
code there and then finally you're going
to get the normal and then the the
you're going to generate you're going to
put it in the normal pixels and then
you'll generate your Z and with normal
maps it's kind of since normal maps
don't really define an elevation that's
the key difference here normal maps
define a direction and so or a normal
defines a direction and normal has a
bunch of a normal map has a bunch of
normals so you have to kind of make up
your own Z and there's a couple ways of
doing it but this was the way that I was
chosen and so the result you get is
right here know if you can see that very
well may be a little bit but that's the
normal map that's generated from the
carbon fiber texture and maybe a good
rule of thumb is you know since the
carbon fiber texture is mostly gray and
not white that's why you know that's
very very subtle here but you can kind
of see the little like facets in the
carbon fiber there
so we'll also show that a little bit the
so next oh that we already went over
that so next thing I'm going to talk
about is procedural images so just what
you saw earlier when we were drawing on
on the on the canvas on the 3d model we
were just doing a fill of an oval there
was nothing really intelligent going on
there but you know you're not you're not
limited in that moment of time you're
not limited to just drawing an oval you
can you can in fact in it of anything in
this talk this is the most limitless
thing you can do because of snapshot and
because of canvas you can literally
create any type of 2d brush you could
ever possibly imagine I'm going to show
an example of color spray but you know
there's also things like shapes tips and
so it like like calligraphy pens and
stuff and so if you wanted to do like a
calligraphy pen then you could just
render a rectangle or just rotate it and
control how it rotates as you as you
move and that's kind of be like brush
dynamics and photoshop you can also you
know if you have a tablet and you get
pen pressure you can also control the
size of your your your oval based on the
pen pressure another kind of
experimental thing that I didn't really
get a chance to try was 3d shape brushes
and I don't know if any of you've ever
seen this but there are some brushes
where you can you basically take a mesh
and you print you basically stamp the
mesh on a texture and then as you as you
move your your mouse or your your
pen it rotates the mesh or does
something to the mesh that that
basically produces a chain or a rope or
or whatever and if you're intelligent
about it you can you can rotate it in a
controlled manner so that you get a nice
like link chain or you get a nice like
curved rope or so or something like that
and you can definitely you can
definitely do that with this because you
just snap shot a 3d shape or snapshot
your content like a group or something
and then Justin apply it intelligently
and then another thing too is paths we
have passed so you could render a path
and then create a brush of for a path
and then we have we also have effects
too so so yeah if any of you would ever
be interested in doing this this kind of
stuff this is there's tons of things you
could you could create here so the one
that I chose to do was color spray and
this it allows for subtle kind of
addition to the color of a texture you
know your your skin is considered to be
semi-transparent and so when you're
drawing skin you know you could put a
base color of like a tan color and then
you know they're there hints of red and
their hints of dark brown and freckles
and what not and you know if you if you
put like an opacity with with something
like this then you can kind of add very
slight color to it to get to get your
effect and so with with the color spray
what I did is every time I received a
mouse event and and this is another
example of where it can be improved
which we'll get to in a moment but the
color spray
is is generated using a canvas and we
just randomly we select the this region
inside the canvas there the canvas is
black and we fill a bunch of circles
with a transparent gradient radial
gradient from the scent from the center
ish and then we turn that function it
into a function that returns a image we
basically snapshot this well so we had
one version the first version snapshot
at it and then the second version since
we were just snapshotting it and then
drawing it as a sub image on the canvas
we actually just turned that function
into taking a graphics context and then
we just drew this brush on the original
canvas as opposed to calling snapshot
twice because you know you don't want to
call shut snapshot if you don't have to
and then every time we drag we basically
draw random randomly drawn more circles
and you get your color spray and the
nice thing about this is you have
complete control over what you're doing
you can control the the range of the
size of the the circles you control how
many circles you're drawing you can
control the color you can control their
opacity you can control the type of
gradient they have you can do all kinds
of stuff you can in if you don't want to
color spray circles you could color
spray colored spray squares it doesn't
really matter but the point here is is
that you have snapshot and you have mesh
view that are your avenue for getting
your texture on to a mesh and it allows
you to focus on doing things that that
can help you get maybe you're going for
an art look or maybe you're going for a
specific design it could help you
achieve that fairly quickly actually
so will show that demo in a moment so
performance so like I said earlier API
synergy can be expensive and the perfect
example of that is this API canvas dot
snapshot turns into that and that's not
even that's not even if that's just a
fraction of it but you know the the
synergy comes at a cost some sometimes
in this case were we're leveraging a
part of the API that's you know excuse
me but we're using for real time and you
know rendering into an image can be
expensive so how do we how do we address
that well there are several things you
can do one of them being like I just
described a little bit earlier is you
call you call snapshot as as few times
as possible and then also you don't you
don't have to do it and you know that
implying you don't have to do that on
each mouseevent you could instead do it
on each frame just in case you get
multiple mouse events on a frame or you
know you maybe maybe you get a mouse
event that's not on your model or not
you know you don't need so you can just
do it in an animation timer another
thing is you want to keep an eye on your
texture size the the textures that we
we've been using in our and our demo
which you'll see is three are there 300
by 300 and they're fairly small I was
using a 2048 x 2048 texture earlier to
just just to see you know the difference
in in quality and
you know if you if you play around with
those numbers you can actually get a
pretty good quality and for pretty cheap
and then also if you're using writable
images you want to reuse those as much
as possible because because creating
image data every frame or every event
can be pretty expensive and so you want
to definitely not not do that if you
don't have to so we got a 3d you I demo
and then let's see so I'm going to do a
quick QA and Alexander should be here
any second so and then we can go over
the demo and that will that will take
some time so questions anybody yeah
yes you can you can scale them just fine
we so the the issue here why don't I go
back to the slide with the so so the
issue with with applying an image to a
mess for you like this is the the UVs
especially for this regular sphere they
stretch and compress at certain points
so you'll notice at the top of the
sphere there the the image is is really
like compacted and not evenly evenly
distributed and so they're all kinds of
projection like things you can do to
make it look better but you definitely
can you definitely can't scale it and
you just depending on the quality or
going for yeah definitely definitely
works yeah nope you cannot use shaders
but what's interesting about this is
that you know shaders act as per pixel
well per pixel shaders at least act as
per pixel algorithms and so you can do
per pixel algorithms in a writable image
and it it you know you're not you're not
going to of course not gonna be able to
get nowhere near the performance of a
pixel shader but you know if you just
want to simulate maybe a static effect
or a static algorithm and try it out
then you definitely could could do that
and actually canvas acts as kind of a
because I under the under the covers
canvas is hardware accelerated so it
kind of acts like a kind of abstract
kind of shader where it kind of gives
you like draw commands but that that's
the closest that you
get using the API yeah
no that that code is just a function in
Java mm-hmm yep yep yep
yes yes yeah I mean we used it on
basically everything here and it was
fine so
chemistry
no no you can actually create you can
actually get a writable image without
canvas just from an image right so so
yeah you would have to write you just
bash the pixels canvases is provide you
with a little bit with the graphics
context which allows you to do like draw
commands and stuff so yeah another thing
to note is that the what was it
so the the normal map here there there
are multiple ways you can generate
generate one and the effects you can get
very depending on the intensity of your
Z that you calculate for example and you
know the effect in in FX at least for
this carbon fiber image it really is a
poor example of a converting a texture
to a normal map just because they're the
really the only change in in dense or or
shape is on the edges there and and the
the thing is is that the the gradient
there is to the algorithm doesn't really
pick up on that shape very well and so I
guess I guess I guess I could be
improved the algorithm itself could be
approved to put improved upon to where
it kind of takes that subtlety into
account and it might not be very perfect
either
yeah there's a kind of question about
just a general question about which take
the sound is going to try to small
minecraft okay the 16
right so i would actually so so the
thing about minecraft is that the the
materials there aren't that many of them
but they are you like the Minecraft
world is huge so actually what I would
probably do is come up with some data
structure to hold the material and the
parts of it and then I would I would
paint on it and then export it and maybe
using XML or something like that and
then kind of store it in this like
global data structure and then and then
use that to does that the second I
answer your question may be a little bit
yeah right so you could use like a
right right so so so there's there's a
couple things you can do you could have
a canvas / side I don't know if you'd
need that because in Minecraft there's
the the sides and then the top and the
bottom and so maybe you'd have like a
canvas three canvases so one canvas for
all of the sides and then 11 canvas for
the top of one canvas for the bottom and
then you when you're done so you might
be able to manipulate the the UVs and
store it into one texture and that
actually might be an intelligent thing
especially if you if you you probably
want to custom make your box so that it
uses one texture and actually if you
wanted to really go crazy then you could
create a texture atlas and so you could
have multiple you could have multiple
materials refer to the same texture and
just have the box you vide a certain way
and then you know box one could be you
feed for the top left and boxed two
could be you vide for the top right and
then if you kind of intelligently manage
it like that you you're using one
texture and for multiple boxes but you
generated them using this method so that
that actually probably be the best way
to do it right because one thing about
Minecraft that I'm pretty sure is that
the textures are static so the which
helps a lot you can generate them
beforehand and then upload them and then
your performances is great but are we
are you ready you done yes we're ready
to demo all right so yeah
because there's been time between right
yeah yeah absolutely absolutely so let's
go ahead and run show the canvas carpet
already shown oh yeah you're good good
canvas yeah that's fine he's right now
so you have the carbon fiber picture or
texture I don't worry about so this is
our painter app and you can see the the
bump map algorithm that I showed you is
the bump map it or the normal map is
being applied applied here just like
just like I showed you with a diffuse
texture and you can see as we rotate the
light you can see the little grooves and
the curves in it and on the left there
you can see the the actual normal map
now I showed you in the in the or no
that's the diffuse month isn't it so
yeah never mind that's the diffuse map
but if we were to display the normal map
on the app it would be very very subtle
you pretty much wouldn't really see
anything but the the pic result I was
telling you when you get the the
intersected point and it was in local
coordinate space or you needed to you
needed a transfer transform it to get
the correct coordinate let's use for
that that cursor right there and so that
that cursor is rotated based upon the
the point that it gets and I basically
construct a surface normal because no
effects doesn't have normals yet but you
see the the cursor is aligning itself to
the normal of the surface
and so when when you click and drag you
can see that we're drawing on the canvas
and the just from the algorithm I showed
you and we have a blue color and again
is making a nice little face and there
we go and so it rotates around like a
regular texture and you can you can
export that texture and you don't have
to worry about UV mapping because it's
the UVs are already mapped and you're
just painting on what you already want
and you'll also notice that the
performance is you know I've been saying
you had a watch out for performance you
gotta watch out for performance but it's
actually 60 frames a second so it's not
too bad and we have a programmer you I
at the top and you can like select the
color but so really quickly I will just
go well actually maybe we could go into
the code and show them the dragged and
show what the handler they've been
handling okay sure how much time do we
have left oh yeah we got some time if
you have any questions or you want to
see anything feel free to ask you
so the shades of it so the lighting that
you see here is all under the hood we
haven't exposed any shaders or anything
like that right right right and so the
fun material that you see there there
are a bunch of shaders under the hood
that have different states for oh you're
using a bump map or there's a shader for
that and then if you're not using a bump
map there's a differentiator for that
and so there's there's a dozen shaders
or so for each one each state yeah
I'm sorry sailor again should be I yeah
I think it is yeah the normals look ah
so like I said earlier the the
application of the texture to the sphere
is not intelligent so it when when we
fill that oval we're on the canvas we're
filling it in a flat space texture space
but the second we wrap that texture
around the sphere it it works because
the UVs are stretched and so the same
applies to the the normal the normal map
because the normal map was generated
from the the carbon carbon fiber texture
there's some
Maya files another a lot better so yeah
I show through to you I or I yeah but
you should I sec want to show the color
spray okay so like I said earlier the
color spray you sure yes well show will
show the this is the logic for it when
we drag we regenerate it pretty pretty
straightforward actually nothing too
complicated and then we're just directly
drawing on the canvas here and you can
see there's a color spray many of you
you all use paint it's a priest it's not
nothing special but but it's right there
and you know you can you can you know
work in some color and create a pretty
pretty convincing you know we're going
to artist but I mean you can like I said
with the skin example you could you can
create a pretty compelling skin texture
with with color spray and opacity yeah
so why don't we go back here so this is
remember this is how the canvas was
applied to the mesh view we took a
snapshot of the canvas and then applied
it here this this probably suffices to
show you the carbon fiber because it
that the app looks exactly
exactly and actually I have the code for
that here so this is within the mouse
dragged event this code right here and
you can see that i'm getting the the pic
result and getting the intersected
coordinate multiplying it by the canvas
width and height which which takes the
UV and projects it on that point onto
the canvas and then setting a fill color
with the current color which is bound to
that color chooser up there and then
doing and then doing a fillable to
offset it so that it's centered and I'll
setting it there you can see that it's
just a tiny bit of math and then
snapshotting that and then applying it
yeah oh yeah so here's there's the
access code so yeah that's exactly what
I just reviewed and then for color spray
you can see that if we have they use the
use brush button then we just draw mask
and we pass in the graphics context and
it's applied there so and we also want
to show very cool the 3d you I demo that
Alex did maybe Alex you can speak to
that yeah we decided to go beyond what's
considered normal and put the whole set
of notes controls to as a texture on on
the mesh so you can see 3d surface here
animate it in time and you could also
actually select items and click on them
so that's a great example of synergy I
think yeah
okay so the idea is exactly the same as
before so we have a bunch of notes here
it's a table view while it's inside late
it has a bunch of notes so whenever
these nodes are ablated you can take a
snapshot of them and set it to as a
diffuse map for a mesh view so that's
one part and second part is to make this
to work so basically you need to
redirect Mouse events from from this
mesh view to the actual controls and we
had some problems here because yeah
there was a new territory even choice so
let me show you the code that we end up
with yeah it's a lot of comments here
let me remove some of them so maybe zoom
in a little so that they can see on that
oh yeah sure how can I control should be
dozen were funny 22 to zoom in a zombie
okay you want to see the code you can
come set up closer if you can't see it
but he'll you can just explain so in the
mouse event we first text yet sorry get
the intersection intersected texture
coordinate which means the coordinate
with in the 3d surface which is in
coordinates brace from 0 0 to 1 1 then
we multiply it by the control bounds so
we get the coordinates within that
control space and will create another
mouse event for that with new
coordinates which is basically copy of
the original one and then we basically
fire a new end for that and it works so
you can click and yeah so we we took a
bit of time trying to decide what's the
coolest 3d you I we could make and we
decided that we would just show this
energy and leave it to do you guys to do
do the hard part
yeah are you over game Q&amp;amp;A yeah ok now
we're good yeah we have another nice
example what you can do with 2d images
and 3d this is actually is used at a
performance test for our mesh
implementation so we have a change we
are changing images in a row for the for
the mesh view material so we're changing
diffuse maps and the same time we
animate the mesh view itself so kind of
the same concept as we seen before but
another a nice example of what can be
done with that and this is running on on
a intel right yeah you yeah so it's it's
you know 60 frames per second frames on
Intel's it's pretty good
alright well thank you very much if you
have any questions come up and ask</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>