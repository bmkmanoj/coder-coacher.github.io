<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON5107   Prepare for JDK 9 | Coder Coacher - Coaching Coders</title><meta content="CON5107   Prepare for JDK 9 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON5107   Prepare for JDK 9</b></h2><h5 class="post__date">2015-12-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nBAUaOoBdGU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to Java one and welcome to
this session on JD canine and my name is
Alan Bateman I'm working on the JDK for
a long time for the for the last two
years I've been working with mark and
others on the module system for jdk nine
so that's what we're going to be talking
about in this room today so we have four
sessions we're going to we're going to
be sticking in this room far and this
one is just going to be a prepare to
talk about what you might expect moving
from jdk to jdk nine and then we're
going to get into the module system and
have an introductory talk and advanced
talk and Alex Buckley is going to go do
a really really advanced talk under the
hood later on today all of these
sessions are in the same room if you're
interested in doing something hands-on
with the module system then come back
here for 8 30 tomorrow morning we're
going to have a hack session that's
going to be an informal and play around
with the with the jigsaw bills question
answers traditional kind of tutorial
bath style okay so I want to start by by
just getting a feel for what people know
about JT canine and maybe start by
asking and what what version of the JDK
folks are using all right already today
so hands up who's who's on jdk 8 today
which that's really good that's most
people who's still back on jdk 7 there's
a few people jdk six and as if should i
go back any further
so anytime we do this we often end up
going all the way back and there's
always one guy that'll put his hand up
to say he's still on 101 dot one I won't
do that today so I'm curious in other
show hands as to who has who has been
tracking what's going on in jdk nine
I've been looking at the Japs and okay
that's good who has been trying out the
the JDK download so we produce a build
every week a couple hands maybe 10 12
hands okay that's good who has been
brave enough to try some of the jigsaw
bills which are essentially the JDK 9
bills plus the module system okay two
four five six people may be okay all
right so we'll be talking in this room
for in the introduction advanced session
all budgets are so if you want to hear
more about that come along so just at a
high level just some goals about what
jdk nine and project chicks are are are
all about is it's all really about
making the platform more flexible and
scalable and it's all about about
scaling down to small configurations and
two containers that can run in in in the
cloud and so on it's it's all about
improving the security and the
maintainability of the platform and also
for library developers and so lots of
high level goals here and because it'll
be great if as a library maintainer to
be able to encapsulate your api's and
and be sure that there isn't any any
other libraries or applications making
use of them so just some background on
on the we called the modularity
landscape and so there's there's a
there's a JSR going on at the moment
called the Java platform module system
mark Reinhold was down on the frontier
is leading this GSR that's jsr and 376
that's going on in the java community
process that started earlier this year
and is actively working through some of
the big issues and under the design of
the of the module system and there will
be another jsr for java SE name itself
it's too early to start that that will
cover all of the the contents and all of
the smaller features and that that will
be going into java c 9
there's there's a bunch of what we call
jets and these are Java enhancement
products this is this is the way we work
within we know with within openjdk this
is where we work on the implementation
so I assume everyone knows that the
implementation is all done in the the
openjdk project in the open so there's a
bunch of these jets and also bit
confusing to have GSR numbers and jap
numbers so that so the jet numbers that
we have the cover things module related
or 200 2012 20 to 60 and 261 and 200
covers the the modular jdk so if you've
been to java one before you will have
seen mark and others show very spaghetti
diagrams of the jdk so the spare the
diagram is something that we've been
working to to clean up over the last
couple of years that has been a really
really long background effort to get it
to a sensible and clean module graph
that has taken taken a lot of effort
what we've done then is is we've
translated that module graph into the
source code layout and the build for the
JDK itself and that's what you have 201
is all about it's not something that you
actually see if you're just using the
bills but if you're working on the JDK
itself then that is a big big impact on
on the way you work because it's it's
it's it's how the code is organized how
it's built and so on and so thatthat's
thatthat's more internally looking to 20
then I'll be talking a little bit about
this a couple of slides on this today
this is this is about changing the the
output of the build and what the what we
know today is the GRE and and and the
JDK and how they're actually laid out
and as I said I'll cover cover those 260
is is deals with with the encapsulation
of internal api's have a couple of
slides on that today and 261 is is
really dealing with the implementation
of the module system and we be covering
some of that today okay so just just
some background about some of the
internally API so I just want to just
give a couple of background slides
before going through at a high level
what the changes are in the there is a
proposed for for java c 9 and jdk 9 so
the first thing is we just talked about
the api's and anyone that's used
the Java Sea api's or even the EAP eyes
will know that there are they all are
organized into the Java dot star package
or the Java X star for typically
historically for extensions Andy EAP is
a lot of javax star api's work their way
into java SE over over the years as well
as the as java sea grew there's then a
bunch of JDK specific api's and and this
is totally confusing for for most people
there are some JDK specific api's that
are documented they're supported and and
then there's a whole bunch of them that
are JDK internal knowin suppose to use
those if it's got internal in the name
then it probably means that you
shouldn't really be using it you're
you're on thin ice because it could
change it in at any time and then
there's then there's the the all the
unsupported API so some of these comes
on api's and JD case API is that I
mentioned earlier there in the
unsupported book but very very difficult
to to know which is in which bucket but
the Sun got star API is that was very
very clear they are always being once
unsupported and so mark actually dug out
a a web page which is it's not quite 20
years old but it's close to it I don't
know if anyone will actually recognize
this this is I'm sorry for folks at the
back you're not going to see the details
and all of this but this is this is this
is one of the documentation pages from
from the JDK 101 dot one documentation
bundle and it explains java dot star is
the api's you should be using son dad
star totally unsupported can change at
any time and so I've just highlighted
just part of the wording around that and
write down the bottom for those of the
back you won't be able to see it it's
just just the date this is this is 1996
so um so we warning in the documentation
about this for for a long time but who
reads the documentation now the compiler
has been warning about this since jdk
six and i'm curious who has actually
ever hands up who's actually ever seen a
job
see warning about using an internal AP I
know a few people have okay hands up who
ignores Java see warnings right okay so
I just want to talk about just general
compatibility this is just a couple a
couple high-level slides before we get
into things so they the general sort of
compatibility goals are if you run on a
particular version in the and you're
only using the supported api's then you
should be able to run on it and n plus
one without without any changes you do
you shouldn't even have to recompile I
think generally we've been quite quite
good at that some areas in the past
we've been a little bit poor about some
of the compatibilities between releases
but a lot of people have learned a lot
about compatibility over the years and I
think things have improved quite a lot
and so just to say oink there just about
supported api's there is a process for
removing supported api's it's a process
that isn't used all that often and what
given advance notice in a major release
then it is actually possible and nine
will be one of one time where we will
exercise this this right to to remove
some some api's these these api's i'll
talk about in in the later on and the
slides these have been deprecated for
some time they have been we've warned
about it in documentation going back in
many many years so there won't be too
much of a surprise I hope so just about
managing incompatibilities and this does
there's a whole spectrum of
compatibility issues that you get into a
AP I compatibility behavior and
compatibility and so on and if you ever
if you ever get a few minutes is Google
Joe Darcy's and blog about compatibility
and command incompatibilities and he's
it's a very good writer because he
actually puts everything into different
buckets and explains the landscape
they're quite well so anyone that's
actually working on a change and they
have to always consider whether there's
a possibility of breaking something is
this going to break someone from move
that's that when they try to recompile
our code because it's a source come in
compatible change is this something
that's going to break someone because
the binary compatibility issue or some
other behavior change there's does all
these things that you actually need to
to think about and everyone working
working on the JDK and this has really
really helped since we've moved to
OpenJDK because there's more eyes on the
code and there's more people thinking
about what what the impact of a change
might be is you always have to judge
judge the risk and when there's a
possibility that you're going to break
something is finding data to back up
what you're doing or are to support our
break your case for whatever change
you're trying to do we've always try to
communicate or early and vigorously and
so when something something needs to
change to get to get some API to rock
walk the right way or then it's
documented that this is going to change
and and there's always advance notice on
things and let's see couple of other
things is and when we're moving when
we're moving on supported api's then
people do actually spend some time
thinking about what the impact is
there's a whole bunch of interesting and
very tempting classes in some misc the
people tend to use and we have been very
very careful not to remove those over
the years yes they're unsupported but we
know that if we start removing some of
these things are changing them then it's
going to it's going to break somebody
that depends on them because we've never
enforced and and never have proper
encapsulation of those on internal api's
and when we do make changes and that are
incompatible changes there's typically
workarounds and my guess is that most
people won't realize that is that
there's a whole bunch of these weird
properties around the jdk for restoring
an old behavior so when things change
maybe in some update released because of
some are some security lease because of
some issue then sometimes you have to
you have to make changes and noelle we
know that some people will might depend
on on on this behavior so they're
typically some property to keep existing
code going and so it's the other thing
is release notes i'm curious actually
maybe show hands as to who ever actually
ever looks at the jdk release notes well
there's a few people okay that's that's
actually more hands than I expected
there's an excruciating amount of detail
goes into some of those release notes
because we're tracking all of the time
all of the changes are actually going on
almost little essay written up for some
of the different changes and they
eventually work their way into release
notes and but it's often years
afterwards that people actually when
they finding upgrade there were there's
some change they write and stack
overflow I've got this problem and then
oh well this is actually something we've
known about its been documented so what
I noticed is a lot of people don't read
them and that's very understandable
because you just want to be a block
grade and not have to inspect I'm
thinking about compatibility issues okay
and I want to talk about just about some
of the the incompatible changes in nine
so this is sort of a high-level list of
the things I want to spend time on I
want to talk about encapsulating the
internal api's I want to talk about
removing a small number of methods and
JCP supported api's I want to talk about
the structure of the JDK and talk about
removing a couple of features that
people might not know about I want to
talk about the version string change and
also the underscore so most the time I
want to talk about internal api's so
i'll start by showing this little graph
of this is an analysis of a of a number
of libraries is the number of Oracle
products and a bunch of open source and
libraries is what does but it's about
100 and 100 110 use in this particular
analysis so what we actually see here is
is there's there's a small number of
internal api's that are used a lot so
there's there's a hundred 125 usages of
some particular internal api and then
they dropped steeply then down and we
see there's like twenty five twenty
usages of some other internal classes
and then there's this big long tail of
all up to about 700 different internal
api's that are used by but by the
libraries in this analysis now I'm
curious who can actually guess what it
but you haven't seen the do you don't
have the list of libraries that are you
sir but I'm curious if anyone can
actually guess what might be at the that
the top there would 100 hundred
twenty-five usages
okay I hard unsafe by many many people
well in this analysis it turns out not
to be the case some misc base64 encoded
and it turns out that son mis gun safe
only made it to number two and this this
list and if I actually went down and
showed you the one that's underneath
that about 80 or 90 usages just on this
sample then it was actually some misc
base64 decoder so this one is a little
embarrassing we feed finally introduced
java.util base64 in in java c 8 and but
it's 10 years too late this is something
we should have put in a base64 encoded
decoder a long time ago okay so we've
got all that we know that there is
there's that there's all these usages
some are used a lot there's this big
long tail what we've done and you can
mark mostly for leading this effort here
is to try to categorize what these
internal AP is our and and there's
essentially two buckets there's the
non-critical api's and the critical AP
is that for in the non-critical AP is is
they don't show up on that that analysis
are if i download all of maven central
and i look at the usages I don't see
them there so there there's no evidence
that a lot of internal api's are used
it's also the bucket for a whole bunch
of AP eyes that are only used for
convenience and i would put base64 in
that there is no reason to ever have
used some misc base64 encode it was just
a convenience there they're all code
tends to use it because it was just
useful to have a it's just there then
there's the critical AP ice and this is
the functionality that would be
difficult or impossible to implement
outside the JDK so that's that that's
where you see son mis gun safe that's
where you see a couple of other and
critical in AP is so why don't I talk
about of it is the the high-level
proposal that's in JEP to 260 so I
mentioned Jeff 260 of the big
of the talk is and the high-level
proposal within this in this jet is to
encapsulate all the non-critical
internal ap is by default so
non-critical from the last slide is all
in all the internal ap is that are not
showing up in in these analysis is being
used and they're also the ones that that
people just use them for convenience we
were also proposing in this jet to not
encapsulate the critical internal api's
so that's the unsafe and I'll give you
the list of what the current proposal is
in a few minutes instead the proposal is
to deprecate them in nine and then
provide provide some kind of
replacements and plan to remove them in
the tenth time frame this is going to be
really really difficult and some of
these some of these internal EAP is how
we're gonna have supported
implementations or support api's and
i'll give you reference it later on in
the talk to paul Sanders's talk tomorrow
on on some misc on safety because that
is where the hardest problems are and we
it's a problem would be chipping away at
for for a long time so what are the
critical api so we're talking about not
encapsulating in in nine well this is
the list some misc on safe some of the
the signal handling some miss cleaner
and i don't know if anyone will admit to
using that here and how they use it and
and then there's there's a few there is
that there is there is there is a jap at
the moment for to introduce a stack
walking api it's possible that we may
not have 20 that that that the
reflection get caught our class may not
be needed in nine if there's a supported
api we will have to see and then there's
there's a bunch of serialization
libraries and things that use the
reflection factory in order to
instantiate objects without running
constructors and so on so that is what
the reflection factory is so this is the
proposal that's their image on the in
the current chip and there's some early
stages for refactoring to
to be able to move in this direction and
what we've asked is this is if there's
things to add to this list then come
along with a justification and some data
to support your case to get added added
to this list so now what I want to do is
given this characterization is go back
to the the graph i had a minute ago and
list down all of those internal AP is
that that that's where you dash will
came up in that graph and and these are
our color coded now for those in the
back it now is a good time to bring out
your binoculars and my apologies to
anyone that might be colorblind so what
we have here is color coded the names of
the classes and the of these so these
are the internal api's that were used by
that set of 100 110 different libraries
the EM it's hard for me to even read it
ok so the ones that are in this orange
are the critical AP is so second from
the top there you'll see son mis son mis
con safe there was 102 usages in that
particular data analysis you'll see some
reflect reflection factory there and
there's a few more them down there so
they're critically their critical api's
they will not be encapsulated in in in
the nine time frame then what we see is
the then the ones that are in this
purpley color these are non credit AP is
there is replacements for those in
either nine or older older releases so
right up the top we have our song misc
base64 and encoder third one down there
is decoder there in purple because you
it's hard to read this I know because
it's too much on the slide but it has up
there are eight beside it there is
actually a supportive API for base 64
encoding and decoding in jdk 8 there's
no reason for us to continue to have a
base64 encoder decoder in some misc
anymore just on that particular one is
as we gradually and replacing all the
usages in the JDK anyway over time so we
will
need this so there's a bunch of these
that are actually in red which might
don't fit in any into any of these but
these book as I've talked to today these
are these are really just non-critical
api's where there is no written there is
no replacement plant so there's a whole
bunch of these things as dessert in this
analysis you can actually see that
there's from where I'm standing here I
can see things like Khamsin org Apache
xpath internal so there's a whole bunch
of things that are actually making use
of internal classes within the the xml
code and so there's no replacement plan
for those so this is what this is what's
worth worth looking in more detail
sometime but don't worry we can't really
spend time on it today ok so what I do
want to talk about is how do you find
the usages of these internal AP is in
your own code so we have a tool in jdk 8
and it's improved in 9 called j tips i'm
curious for a show of hands as to who
has heard of jdubs maybe 10 12 people
have tried it okay so Jade EPS is is is
a simple command-line tool that does
static analysis of your of a bunch of
jar files and it tells you what they
depend on what classes they use it'll
warn you whether you're using internally
api's would infer for small number of
cases where there's where they're
supported replacements it makes a
suggestion as to what the replacement is
and so this is a very very useful useful
tool to have and there's also a maven
plugin that you can actually integrate
into your project to to run in your
build which is quite useful because you
can get it to do the static analysis on
your own code or you can actually get it
to to look at all your dependencies as
well to see whether they have any
dependencies and internally api's so as
I said this is injustice is in jdk 8 so
the tool has been there for a while we
did this as part of JEP 162 in the
eighth time frame which was Jeff sixties
162 was a big bucket of prepare for
module ization
issued tasks that we wanted to get done
and making the tools available was was
was one of those things so here's a
little example I haven't showed the
output i'll show the output on the next
slide so so i'm using one of the
GlassFish jar files as as as an example
and I'm not picking on glassfish I've
just just happens to me this is the
GlassFish is one of the is are good
friends of ours and they have a good
plan for removing their dependencies on
on on internal ap is so I'm quite i I
don't I don't need to embarrass showing
one of their jar files so I'm wearing
Jade eps here and the the option i'm
using is dash jdk internals jdk
internals is the option to jada to tell
to report any usages of jdk internal
api's so I'm running it on one other jar
files the security jar file and let's
see what the output is again my
apologies for this the font is small
here but so I'll have to just talk
through it so what we're seeing here is
it is and it's listing out a bunch of
classes that are in this glass fish jar
file that have dependencies and are
making have static references to send
out star api's this is this in this
particular case I think what what's
happened is this is an internal security
framework in the JDK and this this the
code in this jar file is making its
helping itself to to those classes so we
can see here the first one we see a
common enterprise common blah blah blah
and it's making use of some security
util object identifier and then go down
a bit and I see it's making use of some
security x 500 x 55 09 name and there's
a bunch of other order some that star
security PKS 11 ok so j tips is telling
me was is warning me about that and
right down at the bottom and it's just
making a suggestion here is this X 5 X 5
of 5 09 name actually has sorry x 4 x
500 name has
a supported API and x500 principle and
that's there since jdk one dot for you
may wash one to look at to considering
using that instead of the Sun that star
class and so this is useful because you
can actually run this on your own code
and get an idea what what expose you
have just just so nuts dari api's so
let's let's go and see what happens when
I run this code on a jigsaw build that
has the module system and strong
encapsulation what is going to happen
this code is going to run its going to
attempt to make use of the sundered star
API what will happen and this is what we
get this is a scary exception we're
close to Halloween so I don't feel
guilty showing scary exceptions and by
the way I have a number of scary
exceptions to show this one is an
illegal access error and that's bad when
you see a legal access error for those
of the back I'll just read it out we
have this class comes on security
enterprise security provider policy
rapper ignore the unnamed module we talk
about that today in the other sessions
cannot access some that star security
provider policy class in module java
based java base will be talking quite a
bit about in the session today that's
the actual core of core of the system
that's where this this policy file class
exists and and then the rest of the
exception says that some security
provider is not exported so this is just
saying this is this is the this the
classes in this package are fully
encapsulated in the base module it does
not export them there for this class
cannot use them so it fails at runtime I
have not attempted her to to recompile
this glassfish code I've just attempted
to it's built on seven or eight I've
tried it on on with jigsaw bills it
fails fails at runtime I'm not going to
show another another example and this
time at this time I'm picking on Gradle
and I my apologies if anyone from from
Gradle is in the in the audience this is
one where we attempt to build some just
in Java library with
gradle and i'm using 27 I know those
that there's a Tudor date and it failed
and this compile Java task fails and i
get this error could not create an
instance of type com some to Java C API
Java Sea tools now when I look at that
that looks to me that there's some
problem with it loading the compiler
it's not very clear but the try message
that Grail outputs tells you rerun it
with the stack trace option to get more
information okay i will do that and
we'll see what actually happens next
okay i'm going to run with the stack
trace option and i get more details now
there's actually i have not included all
that the details of the output here
because there's a big long stack trace
I've actually skimmed all the way down
to the to the exception cause this time
I'm getting a java.lang a legal access
exception which is the core reflection
equivalent of the job of the illegal
access error that I had in the previous
slide so let's read on the exception
more so we've got our or Gradle internal
reflect direct instantiate ur cannot
access class comes on tools Java C API
Java Sea tool in module JDK compiler ok
because module JDK compiler does not
export comes on tools API sorry Java C
API to ignore the unnamed when we talk
about that in the other okay so what we
have here is we there's obviously some
code in the in this Gradle Java Sea
compile task that is making use of this
unsupported API now normally when you
use Java see you use the javax tools API
but for whatever reason this is using
the comps on an API so this is what
happens when you attempt and this is
what core reflection because an
exception not an error this is actually
what happens yeah I don't like showing
scary messages with without also just
adding that we should not panic there is
a workaround to this we can't just here
we are Java platforms 20 years old
coming long wouldn't with the strong
capsulation module boundaries after 20
years you're going to break code so we
have to be we have to be careful and
there is a get-out-of-jail card which is
line option that will allow us to export
these otherwise on exported api's so
I'll go back to the GlassFish example
and glassfish example was using a whole
bunch of Sun security classes and the
command line option that I have that I
can use to export those internal ap is
is called X add exports you basically
give it a list of the modules what what
what api packages like to export ignore
the all unnamed we get into that later
on this but just just think about it
it's exporting it to to to all the code
on the classpath and i can list down any
of these api packages and that is our
way to get existing code using
internally AP is to work with modules
and without changing that code now I've
picked on glassfish a bit here and as I
said they are our friends and it turns
out they have been put including a bit
of work to understand all of this
they've got about 10 issues in their
JIRA to track the fixing these
dependencies and at some point so I've
just for those down the back this is
just a screen capture of their of their
juror which is this particular issue
with the Sun with the policy file
because that has to get has to get fixed
and they have a bunch of other ones as
well for for for all the issues that we
that we know about so just so just the
option again just to see what it is x
for x Ab exports just think about it is
breaking capsulation this is what the
syntax is the value of it is the source
module the package and who you're going
to export it to it looks a bit gross
there because I've listed down three or
four packages that are being used but
that's that's how to get all of those
API packages to at it to be exported and
allow that code to work unchanged
okay so that's that's a summary of this
the talking about the internal api's I
want to get back to the original agenda
items and the main the main thing is is
that we've been talking about modules
for a long long time we'll be talking
about encapsulation for a long long time
we're finally getting there and it's
going to be a little bit scary during
this transition we have workarounds and
we can keep existing code working until
it actually is updated ok so we talked
about some of the other changes so I'll
move on and talk about the AP is that we
want to remove in nine this is the list
it's only six methods and we'd be
warning about these for quite some time
and there's two methods in Java util
logging log manager they have better
replacements in in nine and there's four
methods in the in the pack 200 classes
we don't expect this will be a huge big
disruptive change and as I said they
have been flagged for removal for quite
some time the the GSR for java c 8
listed them down as for possible removal
and we have yet to find anything using
the pack 200 methods it's it does not
appear to be all that used the these
these methods for adding property change
listeners to the pack 200 was really
just for deployment type tools to be
able to track and the packing in the
unpacking we've yet to find some usage
when we do it we researched nabe maven
and we searched other places and other
big code corpuses to find usages of the
jam util logging log manager we found
very few less than five and so that's
actually quite good it's not thousands
of libraries using its really really
tiny and as I said there's actually
there is there is there is a replacement
to these okay I want to move on now and
just talk about the the the the binary
structure of the JDK and the Jerry but
I'll start from the bottom point is this
is something that is in the JDK nine
bills since last year this is a
disruptive chain
for tools is a disruptive change for
compilers and and we knew this would be
and so that was one of the motivations
for getting this into jdk nine early so
if you for those that put your hand up
using jdk nine and and trying out the
jdk nine bills already then you're
actually making use of this already so
there's a there's a bunch of there's a
bunch of motivations for this but and
one of them is is we wanted to adopt a
much more efficient way of storing the
classes and the resources in the jdk
we've always well since JDK 12 we've
used our ter and that is not a very
efficient way for storing the classes
there's a whole bunch of optimizations
that we can actually end up doing if we
can move to a more efficient format
moving to modules will completely blur
the historical distinction between what
we know as a JRE in the jdk if you sit
in some of these sessions today you will
actually see we'll be using a link or
tool to produce custom runtime images
that are composed of modules application
modules third-party libraries jdk
libraries we will you we will combine
those together with a linker to produce
a custom runtime image the historical
layout of what we know is the Jerry in
the JDK don't fit very well with with
that and so that's part of the part of
the mode of it part of the motivation
and it's not a technically an API it has
never been a supported interface to go
squirreling away in the in the in the
jdk image and fine ah there's tools that
gr i'll have a rummage around in there
or there's our TV are these other other
configuration files that's never been a
supported interface it's not really an
API well we have done and this is for
the first time ever is actually provided
now we supported way for tools and
compilers and ID's to be able to get at
the classes and the resources in the jdk
so we're going from from a sort of it
yes this is the way things work too
here's a new way that you can actually
do things and so that that would be good
going forward but this is a disruptive
change for the for for a number of a
number of tools if you want to read all
of the details of this then jeptoo 20 is
that is
the Jeff to Google okay so just as just
just that at a high level what what a
jdk looks like today so this is the jdk
image it's the one that has the tools
java sea and so on I don't know the full
history of this mark probably will
remember this kind of I think kind of
came about by accident back in the JDK
wound are two time frame the Jerry are
the wrong time has its own bin directory
with the with with with Java and various
other launchers in there it has the lib
directory with with rt gr gr and a bunch
of other jar files then the JDK encloses
that and also introduces a top-level bin
directory and a Lib directory and the
run time in the JDK was always been in
the JRE directory so what does this mean
well it actually means we've tube in
directories if you actually look at the
JDK we either have two copies we have
two copies of some of the launchers this
is really really odd-looking when you
see it for the first time this Java here
is a java here which java should i use
we've got the tools that you are open
this lid directory and then you've got
other another Lib directory down here
we've managed to serve to live with this
this this arrangement for for quite some
time and this is what this is what's
actually changing and this is what the
new layout is it's very very simple
there aren't live as I say completely
blurs Jerry and JDK there's a bin
directory where all the tools live
that's where you'll find Java that's
where you'll find java sea and all the
other any of the configuration files so
this is another big confusing part of
the JDK and the GRE layout is there's a
bunch of files in there that are
configured the runtime the security
policy file for example well when you
look down through a traditional jdk and
you start looking down in the lib
directory there's a whole bunch of other
files as well can i change that am i
allowed to change that will get
overridden a question marks over every
one of those files because we've never
properly documented what was what what
makes sense did it what is not meant to
be edited and so there's some
documentation pages that do cover it is
what would not in a very comprehensive
way so
this what this new layout does and this
new runtime modular images is anything
that is customizable is moved into the
conf directory all user editable
configuration has moved into the to the
conf directory the lib directory yes
there's a Lib directory in there but i'm
not saying what's in it because we need
to be able to change that going forward
so talked about having a more memory of
memory ficient and performant efficient
and sorry just a more efficient layout
for the classes and resources that's
where we'll be able to store those
classes and resources any other
optimizations and we need the
flexibility to be able to change that as
any time so that disappears into the lib
directory in some internal format so the
main things looking at this this this
this layout is there's no top-level
Jerry directory there's no RTR there's
no tools that you are now you can see
why this is a disruptive change because
there are tools out there that they look
at you have a home and they still have
look is there a Jerry directory in there
so that it's so that it can tell whether
it's running on a runtime or are a jdk
it starts looking for RT dejar because
it's a compiler it needs to be able to
find all the types that you want a
reference well there's no rgr so the API
that we have for those type of tools is
is a file system API and so we have a we
have a proper file system API in the
platform since since Java C 7 that's a
pluggable pluggable API and there is a
file system provider that can be used by
the tools to access the runtime image
and the good thing about it is it allows
JDK n minus 1 to access jdk in this
means that the ideas are the tools
running on a jdk H can access the
runtime image that is it is is a 9 so
this is this is really important because
a lot of the tools that you use the
eclipses intelligence and it means and
so on when you run them they're running
on they're running on a different jdk to
the jdk they're actually targeting ok
i'll move on and just talk a bit about a
couple of things that have been removed
does anyone know what hands up actually
who all knows what the indoor standards
override mechanism is 345 ok this is
this is removed as is the extension
mechanism who knows what the extension
mechanism is four or five hands as well
ok these the the indoor standards
override mechanism was all about being
able to replace our upgrade components
that are in the GDK or Java Sea it's
typically what the app servers use to so
that you run with an upgraded version of
jax-ws or jack's b or the common
annotations it's not something you
typically have to do with your in your
own application and libraries there's
also a bunch of stand-alone technologies
in the in the JCP that they work to
their own schedule they don't walk to
the to the to the same schedule as the
jdk and some people need to run with
upgraded versions of those so the
endorse standards over I reckon ISM was
the mechanism for for running with newer
versions of those don't stand alone
technologies and also running with newer
versions of of certain indoor standards
the OMG Corbett specifications the the
w3c Dom API so there's a couple of these
things that have worked into the Java
Sea api's over the years you need to be
able to run with upgraded versions of
them this was the mechanism to do this
the extension mechanism was it was a
real Miss feature which was allowed
libraries to basically be just dumped
into the JDK or JRE image and and be
being picked up and used and made
visible to all applications very very
problematic mechanism these things are
completely removed in in 9 we've warned
about them in da time frame there's a
much better mechanism in the jigsaw
bills for this which is called the
upgrade module mechanism which allows
components to be replaced and complete
module at a time and the completely
shadow then the version of the module
that is that is in the runtime image so
that actually works out quite well ok so
a couple of other changes just just just
just to mention is and
this is only just a small list of them
if you go to JEP 261 we have a
comprehensive list of the other things
that we know about and because we think
about compatibility for a long time so
the first thing is is and we've run into
a couple of couple cases of this where
we found code that that assumes that the
application or extension class loader is
URL class loader so this is a very
implementation-specific assumption that
they're actually making so they get the
system class loader blindly cast it to
the URL class loader and an attempt to
do something maybe maybe to extend it at
runtime or whatever so I'll show an
example of what this means in a few
minutes what we know is the boot class
path is completely gone options to
replace the book class button the
compiler to prepend and override classes
they are all they are all done there's
much better ways to do this with with
with modules the system properties that
back those are also gone so this is this
this will be something that that some
code will be will run into and we just
have to get over over all those issues
there's a bunch of order things but and
the google for Jeff 261 right down the
bottom of we have a we have everything
that we know about so far so just to
give an example of this is here's
another example in Grail and my
apologies to anyone that might be from
Gradle here is is I just just it's just
picking a few random things that we know
would be impacted by this so this is
running this is this is an exception and
running in Gradle where and i get i get
this exact classcastexception because
there is some code in there that is
blindly casting the class loader to your
to java.net.url class letter and it's
not an instance of that anymore this is
an implementation assumption now this is
this this is one that the grade of folks
are aware of its is this was an issue
tracking this and it's admitted this is
a hack and it's work around command line
limits there's a better way to do this
in nine with what's called arc file
support so in time we will see we would
hope that they would make you make use
of that and then get existing versions
too or getting your versions to work
okay and one other thing actually I
realize I'm showing a couple of scary
messages here is every single major
release we do a lot of implementation
changes and so irrespective of modules
irrespective of encapsulation they're
always changes going on and always tend
to trip up some code that makes
implementation assumptions it's just the
way things are and this is one we just
that we had to get through this
transition this is this is another
legacy thing that goes back to it to the
12 time frame and so I just want to
really mention this one is just this is
this is just one of these things that
that that happens when you make
implementation assumptions so if a
couple of slides here on the versioning
string scheme and it's the final thing
that our second one other thing after
this I want to talk about and I'm not
spending time here on the version string
John versus string change I see iris
Clark in the audience there you can
track her down and ask any question you
want about this I mostly just want to
create your awareness in this session
that this is something that's going on
in in them in the JDK timeframe and so
maybe in other show hands because we
haven't done that for a while how many
people think that the JDK versioning
scheme is totally confusing I'm
surprised because there's a motivation
the jet that I've actually like to read
out because I always was puts a smile on
my face is which release contains all
the most secure recent security fixes
jdk 7 update 55 or jdk 7 update 60 it
looks like update 60 is five releases
later than 55 so therefore it must
include more security fixes right that
conclusion is incorrect these two
releases contain both exactly the same
security fixes and it goes online to
explain how security fixes when they
come out increment the version by five
updates increment the version by 20 this
is really really confusing so this this
problem is finally being tackled and to
come up with a new a new scheme for for
m4 versioning the JDK so Jeff 220 is the
12 and
sorry to 23 is the jet to have to google
for that to get all of the details and
there's a change in the version scheme
will impact any code that looks at Jabba
that version that looks at the the sum
of the properties it may or may not
impact them depends how they actually
parse the the version string and so it's
just create some awareness of this this
version change is not in the JDK nine
bills yet and I'm not sure exactly when
it will go in but it's just something to
be aware if you're if you're using the
JDK nine bills 22 and try that once they
change so this is this is this is this
is taken from the JEP showing the the
the old and the new so we can see here
when JD canine goes out it in the old
days it would have been called 190 and
dash whatever the build number is and it
will actually change to be nine and then
there's a long version that has the
build number without the be in there and
then the short version is just 9m so you
best to actually just google the Jap and
read the details because it has the
before and after are the old in the new
and it actually makes it very very clear
the system properties is the is the one
to keep to keep an eye on if you have
any code that is looking at java dot
version and it's parsing that string ru
parsi correctly because the big thing is
is after 20 years one dot 0 is gone so
for 20 years we've gone from 10 to 11
and all the way through to 18 the one
dot 0 it's very very clear now in 2015
that the major version is actually what
we've been has been putting after the
one in previous releases so the main
thing and there's a couple of examples
are in the JEP and I'm sure if anyone
has any questions about iris she will
have have has data on things that she
has tried so far
because she's been trying out if our
order people have been trying out
different two different libraries and
products to see what might break and
think there's only a very very small
number of cases where it exposes some
bugs in the parsing okay so one final
order think that I would just want to
want to want to mention and this is
again this is not core to this present
this is not core to this presentation I
just want to create awareness of it for
those at the back there is an underscore
before no longer this is this is this is
an unusual one at least I find a very
strange and it's just a source
compatibility issue existing code is
using the underscore as an identifier
will continue to work it's just it won't
compile in nine if you're compiling your
code with eight and you're using an
underscore you will be getting this you
will be getting a warning and that
warning this just translates to an error
in nine so i just wanted to create an
awareness of that when you're thinking
about moving from from from eight to
nine okay so one of my final slides what
can you do to prepare for nine so the
most important thing and the most
disruptive change is encapsulation of
the internal api's and so we've got the
jade eps tool so it actually encourage
people to run with that and get creative
at least be aware if your own libraries
or libraries you're using are using
internal AP is because there may be some
issues there if you're moving 29 you may
have to go on and they haven't upgraded
or to remove those dependencies you may
have to be forced to run with a command
line option to work around us version
string just if you know that you've got
some code that is looking at java dot
version and path parsing is just check
check check that out to see how it will
work with the new versioning scheme the
underscore check for that and i don't
know if there's people here that work on
tools or compilers that might have
dependencies on the runtime image that
is something you can try out now with
the jdk nine bills
but as I said that's a disruptive change
your requires writing writing new code
to use the supported API to access the
image so it's just to be aware of that
and I would encourage people to try out
the JDK 9 bills and so it's a little bit
confusing but we have two trains of JT
nine bills we have the main line JT
canine bills and we have the jigsaw
bills which are legit canine bills plus
the module system so the module system
is not in jdk nine yet not clear when
we'll have to see how the the jsr
progresses and feedback from the from
people trying out the early access bills
and so two different downloads I have
the URLs to those in one of the last
slides so okay other sessions they
listed these at the beginning and so
we've got the intro the advanced and the
under the hood in this room today at
twelve thirty to thirty and 5 30 with
the hack session here tomorrow it would
be very very useful I don't know whether
the Wi-Fi could cope with people trying
to do everyone trying to download jigsaw
bills so if you download it today or
your hotel or whatever at home this
evening so that you're not overloading
the Wi-Fi in the morning just it so you
have it on your laptops to try it out
and Paul found us is giving a talk about
the Sun misc unsafe situation tomorrow
and at five-thirty and it has it down on
the schedule Hilton continental 123 I
don't know what whether that's one big
rumor haven't figured out which room yet
good beats it's around the corner there
okay more information so oh they came up
in blue and right so these are just the
URL to where the jigsaw pages the
mailing list and where you get the early
access bills what the JDK 9 bills and
the jigsaw bills if this is unreadable
just google for them you'll find it very
quickly this link here is important the
Jade eps link this has a page on how to
use jade eps and also has a big table of
usages of internal api's and possible
replacements and what plans are for some
of for placing some of those so that's
actually quite quite useful because I
brought up the versioning scheme it is
also a link to the jet 223 and I think
that is it so let's see so if you've got
questions I think the best thing is to
come up here there's no microphone but
I'm not going to hear people if they
shout from the back and because we're
being recorded I have to repeat the
question for the recording so and if
your questions now now is a good time
mark do you want to come up for the
questions
alright I don't think first questions
okay so you talked about new mechanisms
in 94 dealing with some of the things
that are currently a property eight is
there a strategy for like that help
libraries move to those without breaking
ability right so the question is is
there a strategy for libraries that want
to be able to target JD KH as well as
nine I think is that your question
gerald yeah right ok so I did not
mention multi version jars and so this
so multi version jars is a way to have a
library that has cut that has jdk six
specific code or JD canine specific code
and it does anyone know mark do you know
how to know is there any talk about
multi version gr I don't recall seeing
anything on the so Google for multi
version jar and that will actually
provide a way to be able to have code in
the one jar file that can target
multiple versions the phone turn down
here we go they are there that we
actually renamed the multi release jars
oh there is a there's a jet for them the
term multi version dry wind up being too
confusing
give any support from oracle or support
from someone else well okay so far for
the recording just the question is about
when to support for JD King 8 and so can
I don't want that I can't give an answer
no no no no we do have an idea but we're
just simple engineers Oracle's policy
for ending it's free support is well
documented on oracle com off and i don't
know where it is and i'm sorry i don't
remember exactly when it is but it's
it's a it's probably it's publicly
available information it's just not
something we think rice well yeah I
don't a guest and write and give you
wrong information but I I'm sure you can
find it ah great um you should in your
slides about Java Sea to some linking
errors or reflection if i'm not mistaken
this is included in the compiler api for
sauce coded it used to have Java doc
shouldn't it be an exported module then
because I remember there is javadoc for
this and what does okay so that what
does the Javadoc for this class say it
says right up at the top this is an
unsupported API so there there are some
Java Sea api's that are supported api's
that are some there or not and I think
this is one of the ones that's not so
that's why it's not exported
okay so the question is is this
presentation available online not yet
what I say it will be mentioned about
the RTR and charm city they were their
file system API s are there where's the
reference for those okay so the question
I don't know if we picked it up so the
question is about are ta are into that
you are going away what is the file
system API to use okay and this is all
documented in JEP 220 so what it is is
it's it's a file system provider and
that you can it ships as a jar file in
the jdk nine image and then what the
tool can do is it can use the file
system API that's java niÃ±o file file
system to open the target run time as a
file system and that file system then
you can see the top level there's those
modules and packages or injured view of
the file system and you can see all the
dark class file and all the resources in
there so that's an like an abstract
version yet
visualize yeah do you do you visualize
the jvm as the bunch of modules going
forward and if he is how the models will
be gypped like it will be a jar file or
it will be some other dot mod or
something like that well yes so the
question is do we envisage it as being a
bunch of module yes and we will be
showing slides in this room today where
we will show the module graph and we'll
talk about different the names of some
of the modules that are in there and
they won't be all jar files they're in
this internal format and that's already
been done in the JDK nine bills so no
there won't be any jar files in the in
the in the in the JDK download they're
all in this internal format what
everything is will be organized by
module and let the option to include a
particular model and then leave out the
other models of the JDK so question is
that okay well if i don't use i io
package can i just load only the
required model not the i/o modules
alright so the specific example around
the question what granularity here is is
so the the smallest you can go with
something we call the base module in
fact the next set of slides that we be
doing here will actually generate a
runtime image that only has the base
module in there that includes all the
core API is which include I oh there's
no way to remove some of the very very
core API is because they're used by but
just what everything in the JDK okay I
think we're out of times oh one more
question are we we still recording okay
this is not related to dick saw in the
end you mentioned that yelling
underscore as the identifier and also
seen this in HBase code so just curious
why the underscore was picked out oh do
you want to you want to do with that one
mark or maybe we should send your
attributed to one of the line tools
buffs yeah be under you go to the light
to meet the Lang's blank tools team
bought which i think is tonight but the
short story is as the language evolves
we strongly suspect that we will want to
give underscore a special meaning in
java just as it has in other languages
not maybe not necessarily exactly the
same meaning as it has in scala for
example and and yes we are aware that
there are some light as you know some
popular libraries that use underscore
which is why we deprecated it in eight
and started a compiler warnings then and
like you know and a9 it will actually be
an error so you know this is part of
evolving a platform sometimes to make
forward progress we do after break
things but we but we always give fair
warning ok I think we're we're done
thanks very much for coming along</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>