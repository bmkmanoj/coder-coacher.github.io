<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Making Your JavaFX Application Fly on the Raspberry Pi | Coder Coacher - Coaching Coders</title><meta content="Making Your JavaFX Application Fly on the Raspberry Pi - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Making Your JavaFX Application Fly on the Raspberry Pi</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/u5JD0QB-p1k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">to make sure you're in the right room
this is making your JavaFX application
fly on the Raspberry Pi standard legal
disclaimer sorry about it alrighty so I
have several things I'm gonna cover on
the agenda you'll see them as we hit
them alright first of all how many of
you own a Raspberry Pi mmm ok that means
I get to skip the other stuff a little
quicker but I do have some points all
I'd like to make along the line so
there's probably none of you who don't
know the stuff on here so let's move
forward if you saw the technical keynote
the Duke pad that was shown has a
Raspberry Pi inside of it and if you use
that lovely little little link you can
get to where all the designs and stuff
like that are the there's also a Duke
pad up in the demo Center you can play
with it a little bit one thing I find
really amazing is is Jasper the demo
King has once again done some pretty
amazing stuff on this relatively
underpowered device so let me just look
on the inside for a minute because while
most of you folks really know about it I
want to talk about something about how
this impacts me as a JavaFX developer ok
so we have a you know stats like it's
got a vid core for GPU and running at
this that and the other thing the really
interesting thing on this is coming up
because all of those stats when added
with a fully integrated raspbian
distribution gives us something that has
the overall performance of a 300
megahertz Pentium 2 with much much
swankier graphics so the actual in just
seconds let me get catch up my notes the
the GPU or CPU I'm sorry is roughly
equivalent of a 1990
and desktop machine the GPU itself is
much closer to a say 2007 GPU so there's
quite a bit of difference here but we're
still talking about a basically
underpowered device so how does it
really affect JavaFX
the RMB 6 the raw computes particularly
in the floating-point domain and all of
this effects are RAW processing
capability how many does that are the
other things that we can do particularly
in laying out the scene graph okay and
I'll show you a couple of other examples
in a moment of where it really really
affects us the slow memory of us affects
things like class and resource loading
which is going to be a big part of my
talk in a moment it also can limit the
the screen refresh rate because not only
do we have to get things into this but
that memory bus has to be used to update
the HDMI output the PI also has very
limited memory at least compared to what
most of us desktop folks think is normal
and reasonable add to that the CPU a GPU
have to share memory one of the common
things that people run into when they're
starting an FX application is they get a
rather unfortunately for right now
cryptic error message that basically
said I couldn't allocate a texture
because there is no texture memory to
allocate so one of the first things that
you need to do with the PI is to goosed
your memory split and the exact split a
lot of that will depend on the
application that you're trying to
develop ok and we have a fairly detailed
set up page that talks about some of
these things and how to get going on our
open JDK wiki
so I got a pie I got a distro what do I
need next
well se8 forearm okay this the this is a
preview of GF x 8 or JDK 8 with J
effects in it the one you're looking for
is the only arm one we have out there
which is for arm V six and seven and it
is a hard float ABI now why do I care
about the hard float API well it turns
out there's two basic flavors in the
embedded world right at the moment we're
coming from a soft float ABI which is
basically compiler settings okay and I
see the industry primarily moving to a
hard flow debut ABI question is most
people would say why do I care and I say
you really do care because I have the
same FX that'll run internally on both
the raspbian and the soft float version
which is wheezy if I remember correctly
the difference is significant on JavaFX
performance minimal ten percent overall
performance increasing and the
performance increase is not just because
FX is heavily floating-point internally
but also because the graphics drivers
themselves have been compiled with a
hard flow to ABI and so overall we're
getting a significant boost in speed and
we expect that to happen over time so
the only version of the JDK were a
forearm that we're providing for free
download is the hard float version
because we're looking forward
unfortunately there are some distress
off float like beagle where it's hard to
find decent hard float graphics drivers
or it's harder than heck to try to
integrate them which is basically the
same thing if you can't integrate them
they don't work right so for right now
the the distro that we support the board
we support for basically folks like you
who are playing around is the Raspberry
Pi even though it is somewhat
underpowered so the Java eight is
planned for release in 2014
other people who are more legal than I
had said more on the keynote I'll refer
you to them for actually when it comes
out alright so let's look at Java FX
embedded FX embedded is a proper subset
of what you find on the desktop but not
if not the same thing one thing that we
target and this is because the people
who will end up paying us money this is
what they want we go direct to a full
screen frame buffer okay a lot of people
out there might say well what about x11
and the answer is is the people are
going to pay us don't want x11 because
they don't want to pay for the
additional overhead and honestly on the
PI you don't want to pay for the
additional overhead either okay so we
draw a render directly to the frame
buffer and I provide the window manager
services that you would expect so you
could have multiple stages you can have
multiple windows things should just
behave pretty much the way they should
on a desktop only you don't get the
pretty decorations of a drag bar and
stuff like that because in an embedded
device the again going back to folks we
hope are gonna pay us a lot of money
they don't want that anyway okay so
direct rendering accelerated rendering
we actually do have a software fallback
but on these kind of devices you pretty
much don't want to go there anyway
we do have some special items honestly
these are now available on the desktop
as well because we use a common code
base but there we have a touch screen
support we believe we are closing in on
getting multi-touch right now there's
some filtering that we need to do
because honestly following multi-touch
it's like like standing in front of a
firehose you know with a guy you know
like they showin the riot demos and
stuff like that where you're being
thrown against a wall that's what
happens when someone puts three fingers
down and pulls it across the street the
data that is being thrown at the
application level is so great that it's
actually hard to keep up
at least on a device like this so we're
working on getting the filtering right
and it's almost there and again this is
going to be you know we're publishing a
an update to the JDK preview once a week
so you're you're getting the bleeding
edge we're giving you so virtual
keyboard this is another thing that it's
hard to get right it's on by default
with embedded it's not on by default on
desktop because hey who doesn't have a
keyboard hooked to their desktop right
but if you don't have a keyboard plugged
in we detect it and we'll put the
virtual keyboard up in its place there
are some things that were currently not
planning for our 8 release media mostly
because we need a board that has decent
drivers in it that's fast enough for
decoding and stuff like that PI it's not
quite there yet for speed and the beagle
yeah again it comes down to integration
of it web node mostly because we're
still working on it
interestingly enough you can build web
node and open GFX for the PI if you
really want to play with it not planned
ever is swing support ok and I'll tell
you why with some footprint stuff here
in a moment
so there's another version for
commercial partners of the of se it's
called se embedded and the difference is
is that it's more of a configurable
runtime and again our partners who are
trying to deploy this care about this a
lot ok because if you look down just the
compact one profile is
eleven megabytes of footprint and for
someone who cares about you know the
cost of that chip that they have to put
on to that device that they ship
millions of that number is a lot better
than a hundred and seventy Meg I think
is the full Jerry right now adding the
full compact profile and all of the JFX
were up of around 23 megabytes so again
this is the embedded product not the
downloaded JRE
Bob vendette who's in the back corner is
giving a more detailed talk on this
tomorrow probably with more accurate
numbers on the sizing anyway tomorrow at
11:30 so uh goes go listen to Bob he
he's got a lot more infor interesting
information about the embedded open G of
X we have documented how to rebuild open
J effects for the Raspberry Pi so if you
want to get in there and tinker and
contribute which I highly encourage you
to do that URL you can follow off of
there it'll tell you how to rebuild it
okay and we really do want people to
play with us all right assuming my eye
I've got my PI I got my raspbian I've
done my memory tweak I've downloaded the
JDK a preview I've unpacked it in slash
up that is how you run it it kind of
looks like desktop huh and even more fun
coming in se8 I mean sorry coming in
NetBeans 7.4 there's gonna be a lot of
other ways that you can launch an debug
on your Raspberry Pi from your desktop
and it just all works and every time I
see it I'm just amazed because this
isn't the embedded programming world I
remember which mostly involved large
sticks and whacking things until they
worked all right so let's get onto the
application for a second okay what's
what does it mean to
why well pretty much it comes down to
meeting user expectations right we need
something that's responsive and I've
heard the two to three second roll
honestly that's kind of too slow now it
used to be that if you click something
you know you a one one thousand two one
thousand what the heck is not working
here right okay it's a little quicker
than that and a lot of it depends
certain controls like on a virtual
keyboard you need to see feedback
quicker than that but if you're clicking
a button where you expect something to
happen you really do need to see some
sort of visual indication that
something's happening within that two to
three second range okay
we want visually smooth animations and
transitions and of course the busy
indicator and all of these are things
that I'm going to delve into just a
little bit more users have expectations
but frankly I get expectations too as a
developer I want a powerful scene graph
to be able to express quickly and easily
the application that I want to pass on
to my users
I want CSS so I can muck around with it
make it mine you know change the colors
change the you know the the boundary on
the app on a push button okay in
particularly for a kiosk application
which would be a very embedded target
you might want to customize that CSS a
lot because you need to meet your
customers look and feel okay I like my
timelines because I like animations
people expect animations right now they
want to see that things slide in and
trying to code that in swing that was a
challenge coding it in FX as I'll
mentioned here in a moment
and give you some examples is really
quite straightforward even on a pipe ok
tools to exist to assist us NetBeans
Eclipse all of these provided integrated
debugging right now it just were
okay expectations right we have to be
somewhat realistic because sometimes the
job requires a tractor-trailer and what
we have is a Ford Explorer to carry our
load can we do it in in the Ford
Explorer maybe but it may take longer
more trips to do what we need to do okay
and sometimes it's just not gonna work
you know a spinning 3d cube on the pie
okay you may have a real hard time
getting that to work just because
there's not enough CPU in there to do
that so we have trade-offs and you guys
have all seen this before every one of
you have seen this when you're
developing you've got time elapsed time
you've got memory remember I said
memories expensive on the pipe because
there isn't a lot of it
you've got developer ever how long has
it taken me to do what I need to do to
get the product out and make my
customers happy and also where the work
is performed all right how many of you
really understand the GFX user event
thread I see just a couple back there
yes okay it's if in effect it's the main
thread of JavaFX
a lot of JavaFX is single threaded but
that doesn't mean there aren't some
games that you can play to do some
multi-threaded stuff okay but generally
speaking if you're an application start
you're on the event thread if you're in
one of the GFX event handlers you're on
the event thread interesting enough that
event thread is also what does all the
scene graph layout and the animation and
transition timelines and also kicks off
a render job which happens off of the
user event thread
the reason I say all of this though if
you're in an event notification and you
decide to compute PI to the nth power or
something like that or you know do some
other long live task you are blocking
the user event thread which means that
key events can't get through which means
I can't in the internal scheduled the
next repaint so you can check if you're
on the the FX of n thread with the
platform is FX application thread
so I mentioned blocking is bad okay so
pretty much what we want to do on the
user event thread is do what we need to
do quickly and get off because if we do
that then it gives the application a
chance to be responsive by the way that
all of this I'm talking about applies on
the desktop as well
okay this none of this stuff is really
specific to the pie the pie just brings
it out because it's mean because it's
slow and because it's memory limited
okay
certain operations have to be on the
user event thread that means that if we
do things off on a worker thread there's
certain things that we need to come back
to the event thread and you can do that
using the platform run later with a
runnable that will come back on to the
event thread and you can use that to
change an active scene add remove nodes
things like that
worker threads I mean we need worker
threads if we're going to do long lived
operations that need to synchronize
later with JavaFX it performs work in
the background and how well it performs
in the background kind of depends on the
operating system Linux unfortunately we
can't nice it down to a lower priority
so you there's still some competition
with your main thread but still you can
get things into the background by doing
so again if you're doing the long-lived
operations you can improve the perceived
response time because you can handle
keys and other things like that does not
block the event thread and also we can
interrupt tasks that are no longer
required which is going to I'm going to
try to show that here in a moment with
my example so if you want to do a
background worker thread JavaFX has a
customized future task which is right
there it has some really good examples
in the Javadoc one thing that you need
to make sure you do and this is a very
common mistake I've only made it about
three times is with a worker thread you
need to make sure that when you create
the execution pool that the threads are
marked as daemon because otherwise what
happens is when FX exits Java doesn't
exit because it sees that there's an
active thread so by marking the thread
to daemon the user event thread exits
Java looks around and says oh just a
bunch of demons floating around here and
then we'll exit cleanly now this is a
really important thing to do so that
you're not scratching your head and
asking the forum groups what did I do
wrong
and again it's easy to make the mistake
I've only done it about three times all
right so let's get on to some real fun
stuff when an axe
takes its time the first thing you want
to do is let the user know that
something is going to take a while okay
because all of us have been trained you
know when that thing pops up whether
it's a spinning ball or whatever it says
hey I'm busy doing something but I'm not
dead yet
okay and since we all know what that is
when it comes up we know yeah yeah okay
we may not be happy about it but at
least we can go for it there's two
progress indicators and well the
progress indicator and the progress bar
which one you choose is largely a matter
of personal preference okay I'm going to
use the progress bar in my example here
shortly you want that on the screen as
soon as possible and then use your
worker threads to do your long lived
process so what kind of long live
process do our activity do I want to
talk about well I was thinking about
what application to do and one came up
to mine you know those lovely little
screens with an LCD are our frames with
an LCD that shows you your pictures I
figured I'd do one of those that ought
to be easy enough and not hard to do and
my camera the Pentax w9t there that I
take camping with me and kayaking it
puts out 12 megapixels that's a nice
sized image notice some other ones are
there for comparison the big one though
Nikon is really kind of set the bar as
about as far as you're going to
reasonably go at around 36 megapixels
which is a big image could you load one
of those on the PI hmm okay 12 megapixel
image unpacks 244 megabytes of RAM plus
an equivalent and OpenGL texture memory
that means that if I have the older
version of the PI at 128 mega memory I
can put three pictures in RAM and
nothing else and my particular use case
I want to have at least three in memory
depending on what's going on okay my
HDMI display at least the one I have at
home is a 1080p it's about eight megabit
of memory for that size plus the
corresponding OpenGL texture memory so
clearly at eight megabytes apiece I can
have a heck of a lot more images loaded
into memory so how do you do that FX has
a capability built-in to resize an image
and you give it a requested with a
requested height that's basically your
bounding box preserve ratio you probably
want to say true because otherwise you
get stretching artifacts and the last
one is a boolean for smooth and I
normally say yes to both preserve ratio
and smooth okay so I'm going to try to
load only the sides that's needed in my
case I decided that the size that was
needed is the screen size you could do
other games I've seen some of those
picture frames they'll load a slightly
bigger image and pan it around I didn't
do that this time so I'm just gonna go
for the the size of my screen decoding
time on a Raspberry Pi I'm seeing that
my 12 megapixel images somewhere between
five and seven seconds it's actually
closer to five to eight occasionally
going up to 13 on my beagle XM I'm
seeing it at about three to five seconds
so a slightly faster processor I guess
on my Mac over here which is an older
Mac that same image takes about a
quarter a second okay so again this goes
back to what do you have do you have
that semi do you have a Ford Explorer
maybe in this case it's more like a Yugo
so
I want to I have some options of loading
these images I obviously could load the
images before they're needed this
wouldn't work in my particular
application because I want to take a
random selection of images I don't know
if I have however much memory free
memory divided by eight
you know slots available I might need
more than that I might need less than I
don't know so for me loading all of the
images in this application isn't isn't
acceptable at a time it also would stop
my startup by quite a bit
so I could use background loading in
image itself it has a capability to do
that you say in its constructor that you
want to use background loading and then
you've put on a callback and you'll get
a progress callback for a couple of
reasons I decided not to do that you can
also go with custom worker threads that
gives you the greatest control and in my
case it also gave me the ability to
cancel a worker thread once I figured
out before it was done possibly that I
really didn't need it anymore problem
with custom worker threads is they are a
little bit more work but honestly not
too much more especially with the JavaFX
concurrent so other things that you can
do is you can build your scene graph
ahead of time again this is going to
cost you time either at startup or you
need to get your busy indicator up and
do it on on a background thread if you
have several screens that you're
toggling between tabs or pages you know
not actual little literal tabs but the
equivalent of tabs that you're cycling
through you can build those ahead of
time again it's a memory trade-off but
if you want a quick response when the
user clicks if you just want to see it
happened very quickly
then building it ahead of time and just
hiding it with setvisible is
a good way of doing that okay so some of
the things that I've done I build my
busy indicator ahead of time and other
than that my application really doesn't
do much of that but it's still something
that you want to consider especially if
you have a limited set of pages that
you're cycling through or if you have an
overlay that you want to have slide in
rather than you know having a user click
a button that you build the overlay and
then you slide it and the perceived lag
there it's probably going to be too
great so you build it ahead of time so
one caution when building a scene graph
on a worker thread you can build from
the top level node but you can't attach
it to the scene except on the user event
thread okay so I can decide to build in
layout but that last hookup has to be
done on these or event threat and once
that node is hooked on to the scene
you should only manipulate it from the
user event thread all right powerful
transitions I fell in love with these
because they are really slick and I'm
going to show you an example of one here
in a moment and we have a lot of them
that are built-in so these are basically
slick little mini effects that you can
use with your application for a very low
cost in developer time sorry here's one
of them cut and paste almost literally
from my code this is half of a two image
view fade in I create the transition I
set my starting and ending value in this
case I'm starting from not visible and
moving it to fully visible and I have an
unfinished that lets me know when it's
done and I have a little bit of stuff
that I want to do to reset so that I'm
ready for it the next time and then I
tell it to play and I do a the matching
one in Reverse for the other image view
the so this allows me to take to image
views that are stacked and one of them
fades to transparent and the other one
fades to opaque and you'll see that here
in a moment
running and again it's that's not a lot
of code try doing this in swing it's a
little bit more complicated all right
time to see it in action
Dave time to put your coding where your
mouth is right I wanted a simple
application to show some of this so I
created an application that given a list
in it as a command-line application
given a list of images will disciple
through them okay I want to have an auto
forward capability I also want to have
the ability to arrow through them and
again this is going to be running on a
Raspberry Pi with that 12 megapixel
images all of these are twelves
okay straight off of my camera which I
was going to wave around and I want my
feedback for a response criteria to be
met in other words I want to see the
ending indicator coming up quickly when
I need to and I want nifty transitions
this is a I used a stack layout so
there's two image views and a progress
bar so not not a terribly complex
application I have a worker thread using
the executor service to load my next
image and also to update the current
image if it's needed so if if I move
forward while the image is currently
being loaded I need to wait until that
image finishes before I actually update
my image view with that image okay if
it's already loaded I just can use it
and move forward so there's a little bit
of fussiness that that was necessary for
that okay all the images are there
alright let's go to that one there
okay it takes a moment to come up part
of that is class loading on the
Raspberry Pi because of the limited
memory bandwidth takes it a little bit -
oh that there goes so I have my progress
bar on the screen get it up fast right
I'm loading at this point a broken image
icon my current image and my next image
so there we had the transition okay and
you know the fun part of some of this is
trying to come up with images
well that's me and my wife and friend
out kayaking no copyright on this one
there's my auto Ford kicking in I have
it currently set at ten seconds again
I'm seeing about a second set second
load time but now let's abuse this thing
all right no progress indicator yet
well let's pound on this a little bit
okay I've just skipped forward five of
them it's gonna take a moment for it to
catch up first I have to cancel the next
image that was probably pending and then
I skipped through and because I'm
handling each key Ford well I keep
cueing up the next one and oh it fell
off the end of my three window and I had
to cancel it and so it takes a little
bit to catch up but notice I have my
progress bar up there and it's moving
it's not stalled okay so my user at
least has an idea that something going
on all right
any time ketchup I guess I shouldn't
have had six times
all right well that things thinking
about it this code I checked it into the
open jfx repo in the apps toys area it's
called FX slide show Oh see finally
caught up if you want to help me improve
it or use it and abuse it please feel
free but it is again part of the open
GFX free repo that's out there and at
this point any questions I'm a little
fast you can bring the lights up yeah
sorry okay so the question is is did I
profile the Linux kernel in are there
any room for improvement when I'm doing
this most of the time top is saying that
I'm hardly using any CPU at all there is
some while I'm loading the images but
the actual the rendering in the
transition is is very low there is
possibly some room for improvement but
it would only be with regards to memory
throughput and of course I could have
overclocked this and I decided as a
matter of honesty that I wouldn't do
that
the contact switches and Ryan okay right
yeah okay no I I really haven't gone
down that path it would be interesting
to look and see with you know as you
were saying with osv if some of the
contact switches because I believe there
are some contacts which is involved here
if nothing else because we're you know
reading from file yes it's it's possible
that it really could make a difference
it is interesting to see this running on
a desktop because you know even with a
large resolution display the amount of
time in decoding is really tiny versus
the time of decoding here so the the
bulk of this CPU operation is related to
file system access and in decoding the
byte stream so yes anything that you
could do at a low level to improve that
yeah that would that would make a huge
difference yeah yeah anyone else yeah
the Panda if you got a hard float with a
panda
you might just run have you tried it
recently I haven't looked to see in in
my world yes I want to collect them all
but manures in a day and this is where
we really need the community support and
by the way I'm going to plug my I have a
buff later this evening on porting to
new platforms primarily Linux plus style
platforms but still it's a Bob I need
help so like if there is a decent distro
for the panda that has the integrated
graphics stack then and someone has one
of those and wants to
play around with it I'd love to talk to
them and to try to guide them how to do
that
similarly there's a lot of other boards
out there that I just don't have time to
do the Samsung Arndale comes to mind I
don't have one and by the time it gets
through internal legal approval I may be
old and gray and it may be end of life
but still there's a reason we've put all
of it including the embedded stuff in
open GFX one of which is this point of
pride but we really do want to try to
architect what we've done in the JavaFX
embedded so that it's easy to port to
new platforms there is some sensitivity
to the OpenGL implementation
unfortunately OpenGL is a standard kind
of in particular initializing the GL
context to access the frame buffer not
using x11 isn't a standard which means
that you got to port it to every new
platform so but we we are trying to do
our best with the time we have available
to get more platforms on panda has an up
because it's a close cousin the Beagle
for the graphics it it has a more likely
chance of it working but again you have
that hard float thing and I can't tell
you how many weeks I've I've wasted
trying to get distros with then graphics
integrated and yeah that's the it's it's
really annoying the nice thing about the
pi is is that it's one-stop shopping you
go out you get the raspbian this distro
it just works for everything I want it
to do so and hopefully we'll be able to
work with some partners and announce in
the not-too-distant future more boards
that you can go out and buy and it'll
just work okay
it's interesting you ask that question
yeah it's been announced that that we
have a partnership with them and I would
expect some forward progress on that
very quickly having held in imx6 in my
hand and really enjoyed it yeah I have a
little bit of incentive to make me and
freescale really happy in via that the
rest of you guys happy with it too so
any other questions yeah yeah
right right okay so media is coming in
open jfx okay what you saw at the
keynote on the PI various people could
call that a cheat I would say it's a
effective use of development resources
but the way they did that is that media
is being rendered to a layer below GFX
so it's actually not going through GFX
part of this is because of the just the
raw capabilities of it what we want to
be able to do in FX is as is is take a
media stream and be able to take that
and manipulate it I mean you saw or
you've probably seen various things
around here where we can rotate and and
manipulate a video image so play it on a
on a spinning cube or something like
that I don't see that happening on on
the PI just because it's an underpowered
device it'll be interesting to see what
happens on something with a little more
power under the hood like an IMX it may
be capable of doing a nice spinning a
video Cuba that remains to be seen
so I said media and web node are not
part of embedded eight for this release
that doesn't mean that they won't be
available and open GFX and hopefully we
can be making some forward progress and
making those work with code X's that are
available on platform for decoding yeah
it's just partly it came down to a time
and an effort trade-off and that wasn't
one that ended up winning in the time
frame we have left to us so any other
questions all right there's two buffs
I'm going to remind you about later
there's a jfx meet the team at five
something rather and then there's the
porting to new platforms that's a little
bit later in the afternoon in the same
same room so come on and meet us thank
you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>