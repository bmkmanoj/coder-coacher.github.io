<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building Rich Visual Tools in Java | Coder Coacher - Coaching Coders</title><meta content="Building Rich Visual Tools in Java - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building Rich Visual Tools in Java</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0K0A0X_rqmA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">together with me today here or Yaroslav
Toa
he's the original NetBeans platform
architect and Senora reimers the the
member of the NetBeans dream team
I'm also the member of the NetBeans
dream team and today we will be showing
you how to use NetBeans platform to
create rich visual toast of course you
may use any other RCPS
and other tools and frameworks that we
are going to show you today using the
same principles but if we're today about
only about principles and show you
nothing our source code no damage that
you it's a pretty useless so how many of
you today have built a rich risotto
something that contains crabs okay so
many of you it's very good because you
you know we have experienced that and
you would know what the problems are and
how many of you plan to plan to build
visual tall okay that's very good the
thing with building visual tools is in
my experience while we develop and add
new features from time to time you have
to do a lot of rewriting and changing
the architecture of the applications
especially when you add new actions and
new features new objects to your model
so what we are going to talk show you
today is based on our experience in
building two applications with rich
visual UI when I say rich visual UI I
mean two things
okay so anyway I guess since you all
have experience and you built it we are
all well aware wise rich visual you are
important that's how you get your users
if they are about to choose between two
applications one with the nice visual UI
and one which might have better model
below but some less attractive UI they
will always choose the one with better
UI maybe not all but my rough yes this
is more than 70% of them so what we are
going to show you today is based on
visual library API which is a part of
NetBeans platform and we'll also discuss
when we will show you how to do the same
things with the Java ethics and we will
also talk about some issues with
building that thing in Java a fixed
because some things might not be right
but you as you are going to see there
are many nice things in Java ethics that
will make your life a lot easier and
also we will take a look at some demos
how to create a nice visualization based
on well known open source libraries like
Jeffrey chart and JJ Y 3d and the idea
that we started recently about creating
visualization API which yadda will help
us accomplish right so first I'm going
to show you a few demos first I'm going
to show you the new NetBeans UML plugin
that we are creating using visual
library then I'm going to show you your
visual editor which is visual editor for
neural networks and then I'm going to
show you the visualization API in action
also as a part of that neural network
application so let me see if this
started yes so here is the new UML
plugin as you see it looks like
NetBeans it's a better than this
platform
sorry no this is the other one this is
the one with them funny on that looks
okay this is for the UML okay we are
creating new project and we are creating
UML diagram project so you mode I come
to demo okay
so every rich visual application needs
to have these parts as you can see on
the screen usually there is some project
view and you need some kind of Explorer
view right and nice thing is that you
already have that creating inside the
NetBeans platform and you just have to
learn how to put your stuff into it so
here we have a wizard system new file
mistake then it's a new UML file and we
say new class diagram okay sorry
now we have this demo diagram here okay
now diagram is here our diagram will be
in this editor window and we have a
palette with those components on the
side then we can drag and drop like in
any UML - okay and I'm going to show you
how this design of this tool so top
component is a named class diagram okay
it is a class diagram and the twelve
diagram has a number of class diagram
components right okay it has so we are
going to create a relation between these
two using ctrl and dragging like this
and the relation is easy okay next this
class their own components represents
any component that is a part of a class
diagram and this is the design of the
model of this UML diagram so we have
three types which have press let's
compose
okay see this quest component interface
component in an engine component we
followed when you go for example new
file and you take a look at new Java
files you'll see Java class Java
interface in Java and Alex up is not of
interest to put in visual editor and our
philosophy was to put only the basic
things the things that developers really
need let me put this
oh no not interface okay right click
delete components it is also class we
have interface component okay and last
what you're going to put any one
component okay
and of course sorry this is a actually a
long relationship up there here we have
is relationships or we can drag and drop
right here is relationship and say
choose class diagram component and this
relation we are going to remove away so
right click right and remove it and then
say again oh sorry
other way relation type has name
components right so class diagram can
contains zero or in this case one or
more class diagram components so this is
using this tool in action and of course
you see this in Explorer view you can we
don't hear you haven't edit any fields
we can add fields for example name and
add method for example get name like and
do the string return type and do the
same with the other places and we can
right click and said generate code and
we get exception because all the things
are not done yet here so how do you
create something like this I'm going to
show you how it looks
the hood here's the UML project okay
here are its components and in this
module
uml model we have all domain classes all
classes they represent UML diagram
domain this is the these are those that
I've been drawing so far it's a class
diagram class direct component class
component and others then we have UML
visual model which contains widgets it's
a visual library implementation for
these visual components that are we
we're dragging and dropping right so
these are all widgets from visual
library and you create specific pieces
for example class widget interface
widget and annual widgets okay and we
have completely separated the domain
model which are those components and
from the widgets the top component of
the visual library is seen so you put
all the widgets go on onto the scene we
have also Explorer being tree view and
we have support for projects in this
model UML product type and UML file
types so this is pretty much the outline
what you need in your visual application
when you are building on top of NetBeans
platform of course in this specific case
we have another module named code
generator which generates code from the
diagrams so I'm going to show you a bit
from this one of those widgets for
example let's take class with it okay
first we did we
here we extend we have a base visit for
all classes class widget extends
component widget base which contains
name because every component on the
diagram has its name and some other
things and nice things with this visual
ivory is that you can very easily add
actions for exam
if you want to create select action or
move action or resize action or you want
to create different kinds of behaviors
like onmouseover on your site and so on
you have ready to use API which is by
the way pretty complex under the hood
but thanks to visual library it is very
easy for you to use it so now to put all
these pieces together I will show you
how this looks in a big picture okay
which is the design of a visual tool
this is how the whole this application
looks like so we have domain classes
which are the UML classes that I just I
was drawing then we have widgets okay
those are we are inheriting from visual
library and the adding actions and other
behavior we need and we have a container
for all those widgets that's a scene
where you drag and drop on the
components then of course we need to
define actions what happens when you do
something with your mouse over the
widget and I use this domain editor
which is one part which contains
operations on the model and it is a good
practice because you can invoke some
action either using the right-click menu
or you can drag and drop or some other
way some mouse gesture might maybe and
it is good practice to put them all in
one class so if you want to change the
detection you don't have to go to
multiple places in your application then
there is a palette of course you there
is polite API in NDS platform right it
is very easy to create either a palette
wizard I have a feeling it's not yeah
but your API itself is well documented
and it was I'm sure it was easy to use
it is easy to you know what was the
thing it is easy once you learn it
because you already know it it's easy
for you but when I start using it it
took me a while to figure out you know
look at this and look it there look at
the some examples and I can recommend
there is a book NetBeans product part
from Def 18 guide for version 7 which is
very good explanation how to use polite
API and the big improvement would be if
you could just keep a polite visit you
know because it could be done you just
hear that XML file right so it would be
really very easy for people to create
applications language well yeah
definitely the best way how you can
promote your API is to create good visit
yeah because that puts everyone up to
speed you basically start the
development quickly you have something
that works and then modifying it is much
easier when you have something that is
working for you that's true report an
enhancement it's great that you're
actually listening to us and one thing
that that might be tricky for me it was
is to think about interaction what
happens when you click what happens when
you right-click what happens when you
move because now those actions can be
really strange you can get really
strange behavior if you don't think
about when well and very unintuitive
interface so the similar thing we have
this is the second extra second
application that we've been doing using
visual library the similar thing that
we've been doing before is this neural
network application your studio and it
has similar parts maybe and if I could
okay so you
again the same parts we have a project
window here we have explorer window we
have some of our domain objects we have
neural networks here and let's say we
open one and here we get this graph view
of this neural network ok and we have
here we have palette with different
types of neurons layers by the way the
components that we put into neural
networks so we can see right click here
remove input connections and one more
layer and then add few neurons to it and
then do this and connect them all and
then we can play here Explorer view
select it and it should you get selected
here also yes and then we can also turn
on properties view ok and see the
properties of each item these two
applications they are different for
different domains but they all have same
parts and they are very similar in their
design and it would be also great if to
create some kind of a step-by-step
interactions a set of wizards to create
application like this you know so I want
a new visual application I ran few
wizards I describe my domain and I get a
visual application because all these
graphs all these visual representations
of your model are actually graphs and
the visual ivory was graph library in
its start so they already said
everything that I said about the UML
tool the same design we used for this
tool and that was the motivation for
actually doing this session and
explaining how to do it so you're
looking at having the kind of meter
graph model description
thing to easily create yeah such things
well yeah I mean you're just it's just a
question of how do you represent your
components these are simple images right
and how do you do layout okay it's
interaction so what can you do oh yeah
which of the components so how they're
interconnected how you can interact with
the connections between things of in the
graph so a lot of things you would have
to describe and simple wizard yeah well
I like the idea of building on top of a
simple graph library and add
functionality describing those things
yeah that's not a good idea yeah it's
definitely not possible to do it in a
single video you know but you can do the
basic framework you know and then just
to add stuff you need to it and all
other things should be the same you know
the things that are same in these two
applications could be generated in you
know because when I was doing one I was
looking from time to time in the other
one and copying and pasting the same
code so it should be well thought what
should be what is the basic framework
and what is the what are the features
that we should leave to implement in
additional but that's the idea okay so
that's all about the visual close and I
want to show you now the visualization
part for example we have here some data
that we are using to train your network
and we can visualize that data by
right-clicking and using visualize menu
okay so we can choose from 2d and 3d
visualizations okay this is the window
and we choose what what type of graph we
want to show in the scatter of series
and we say what is going to be on x-axis
and what is going to be on y-axis
and visualize okay so this is the
problem we are trying to stop to solve
visualize in 2d minutes so we can choose
different you can choose different
inputs for X Y axis and we hope you have
different views on the problem of course
then we can say way we can choose
visualize data in three dimensions and
use different types of graphs like this
so the these two dimensional graphs are
creating using Jeffrey chart okay and
these three dimensional are created
using j8y 3d and the thing that we done
is the three extracted api from these
libraries and created api that is used
by our application of a neural network
application but the same api can be used
in any other application that needs to
display two dimensional or three
dimensional graphs of course it is not
complete yet and there are some things
that should be moved out since we still
here dependency some dependencies and
available frameworks but i think that it
could be easily done so what is the
structure of your API basically what is
your structure structure of your model
nodes with positions no some connection
I have data provider and I have graph
factories okay so and both of those are
interfaces I can show it so of course I
must tell there are still some things
that should should go out okay here is
graph to the API
okay and here is data provided to thee
okay so here are the two methods that
are important these two will go out
metal get data which returns an array of
points 2d okay and these are the points
there should be displayed so you don't
care what kind of application you have
on the other item is it neural network
or somehow you just get an array of 2d
points and it goes to some chart Factory
of course you need additional object
which provides properties for showing
the graph and you said the title and the
other things and in just pops out so how
do you deal with this kind of firm it's
a leaky abstraction so I saw there was a
point 2d and it was java.awt ji-yong and
you keep probably packing and repacking
things from one type to another type so
you will have overhead and CPU and
memory usage so how do you take a lot
well I don't have a problem with points
2d you have it is not a Java class right
and it's everywhere so there should be
no problem with it
so I assume if you're using different 3d
systems at the backend you probably have
different types of 3d points so you end
up with having a yeah OpenGL joggle 3d
things or you have some 3d from some
other custom libraries 3d points so yeah
in the end you got XY that but I don't
know some use float for performing these
three floats okay
but much of some use three doubles yeah
as well so you need to pack it into a
class yes yes OPEC unpack and repack and
pack in and pick out it's called boxing
and other box yeah so yes it's not a
problem so yeah I think it works yeah we
think it works but I'm not sure do you
think
will be a performance issue so so what
we did it my day job we have us be on
some graphing library stuff and we
didn't want to depend on directly on the
api's so and we have one commercial
library and some back-end and we got AJ
free chart as a back-end and we figured
out that it's quite complex to manage
one API that fits both of those
different programming models and that's
part of why you have a one part that
makes it difficult is you have to pass
those things in so you're defining
everything in some abstract way and then
you just have magically to move it
around and pass it to the things and
then they are gone you don't see them
anymore you can't Nick that but they're
just gone in the graphing engine and I
think the the the benefit we have is we
abstract those complex api's so we just
scale down and say okay for our typical
use case we just need I don't know 10%
of all those forge a future things and
make them easy to use so some nice
factory codes so you don't have to know
about how to configure exist you just
put in what your business domain model
has values and everything else is
configured behind the scenes but that's
done a very customized thing for a one
business case for one from business
domain probably yeah so not very
portable so the approach in itself was
probably portable but not the written
code well guys while listening to you
one thing comes to my mind in that means
there is such data abstraction in the
NetBeans platform api's and you are well
known of the API so I guess you know
what what is that yes yes which one
visual library now visual I burn it
doesn't represent the data it represents
vision so I think this represents only
data notes notes yeah
so basically it
it's not 3d model it's just a dream oral
but in NetBeans we have obstruction of
any tree structure with nodes that can
have children and sub children and some
children each node can has some
properties we designed that based on
javabeans specification especially its
classical graphical version which deals
with containment of various beans but at
the end basically if you are using a pin
spot form application you can display
any tree structure in an abstract model
and then someone then can take this
model and display it as a tree someone
else can take it and display it as a
list for example or as a table as a tree
table it can be a property sheet showing
just properties of the selected object
so in NetBeans we have about 10
different views that basically deal with
the same model so something that should
be possible for 3d as well yeah so to
use the notes API as a base for just
inspiration just a very interesting idea
very interesting well I think the things
you sets when of course there are cases
when this approach might not be
appropriate it might create performance
issues you know but I'm sure that there
are many cases when it will really make
job easier for example you have a new
wizard and you say new graph for my
application I want to create new grrah
No and you if you have API you can
create for something you can create
visits for that right you can automate
creation and that that's the idea so
when do you want to show us what you
made
all right yeah so
and some jokes yeah so Swee we discussed
this
beforehand I said well you're doing a
lot of things and visual library is
really nice thing
but these days everybody is talking
about job effects so and visual library
in itself is not well tied into the
NetBeans platform in terms of API so
it's just a kind of Swing components in
the end so it's very very loosely
coupled to the epic platform so I
thought well what would happen if I
would try to to build something like
that in Java packs so and you can embed
job of axe and swings so so how to do
this so so my approach I've written for
up brother for another well demo thing I
just get rid of all the swing stuff on
top of the rapid platform and try to
start a pure FX version of it so it's
just a very very small project just just
baby steps but just trying to get fever
for what would be necessary and what
could be done and what you could reuse
and where there may be problems and to
figure out weakness a happiness
community can help out making transition
for special parts and more easy by
providing patches or ideas whatever so
it's just a well it's just just just a
game project so you just play with it so
and I took this and I got me yourself a
a graph library it's a young library and
it has this nice thing it decoupled the
visualization from the layout algorithm
so you just define your graph you say
layout it using whatever layout
algorithm are just available and what I
get back are java.awt Gian points okay
and I just add them back into the FX
version so we're now seeing here is is
just a small forest
that's a big bigger so you can see the
complete forest and there's three parts
of the view that you see here are
loosely coupled so they don't know each
other directly Jane doesn't know about
but there are things available that have
certain features so this big graph came
apart it just as well you can control me
if you like there's some feature
available and the global selection where
you can say okay
please use another layout so I can say I
go here and say oh I would just want the
route so and this component knows about
all the layouts that are available so as
you can see this works pretty well so
you can can't click there you can even
look unlucky you can even do select all
but with a keyboard shortcut you can
reset the selection so and you can see
the system is tracking there down there
the selected things
and you could do even more things so you
can do paths by lighting by varying the
the path algorithms getting back the
verticity the address for that and I'm
just highlighting stuff indeed in the UI
so all this is pure Java X it's all CSS
style so you can just well do anything
you want so the good thing is all those
are Java FX nodes so you can put
everything in there so you don't have to
be circles it could be rectangles oh and
could be even text fields so the thing
is you just have a graph layout and you
just have a component that just displays
this graph so it's a very it's not much
code to get this running so I had to
adopt a few things here and there but in
the end it's just a kind of graph view
control well they're just feed your
graph and your layout and your rendering
types in there and then you could
probably do a ton of things more like
adding context menus to the nodes you
provide
adding functionality photos so the idea
is now to say okay this looked me up
because it's automatically layout it and
I don't have any any interaction on the
manager yet so similar features the
visual library actually provides is all
nice things with moving things around or
making it easy to to add actions to move
things around so that part is probably
missing here but since that all this
JavaFX so and you don't have to so okay
so the difference the visual library
draw us into D so in the end you could
get real canvas style things and and it
can using this it can't paint components
as well so the swing components but
analysis of complete scene graph and you
have all the notes you can just do
everything that Java pick is able to do
are notes you can just do with your
notes so your vertices and your edges so
that's quite cool so then Zoran showed
me well I got a cool UML demo and said
okay come on I take that challenge and I
created a new one it's based on the same
code base the same same same thing same
graphic so it's automatically layout it
and that's probably why it's not looking
so good but you probably get the idea so
it's just now having package names and
labels so this is how to discover it I'm
going through the super interfaces of
class and then you go there and you
click there and you click there and you
type Zahran are you just go there and
say rename and go there hey
so this just works yeah it's just knows
I just stacked a textfield on the label
on top of each other moving whatever I
need to the front everything else it's
just gone and just using all things that
available what effects it's not a lot of
code so I think there's real benefit and
trying to to do those things and use
them inside NetBeans platform so taking
the idea of visual library that's swing
based just one step further so that was
the the the the idea here so so one
question
so are you reusing the scene graph in
this example yeah does it hold it the
structure basically the connections yeah
so so what I did is I got the graph as a
model and then i perfer for each element
and the graphs of reached British and
each edge I create a scene graph node
mm-hmm so so the scene graph is fairly
flat so you know just have a parent and
there are a lot of edges and vertices on
the same level
mm-hmm so yeah so and now with this more
complex control there so okay for each
versus I got more scene graph things
than that so scene graph gets more
complex but yeah so having everything so
for every thing you have there on your
on your on your graph on your UI you can
use everything that JavaFX provides on a
node or on your control I think it's a
very cool thing
well the same can be said about visual
library because you can embed swing
components into edges into nodes of
course yeah you guys originally wanted
me to say which approach is better
I can't do it I don't know I don't I can
it's hard for me to find the difference
well I think that there are lots of
things in Java fixes it's actually
missing to use it for application that
you know because if you can't move it
you know it's true that visual library
is missing lately out algorithms but we
seen that recently Tim Boudreau added
also from junk well and that's great
it's a very important because one of the
issues with visual library so that was
one of the the the well the main idea
things where I got this from was say
from from timbered oh so he did they say
grafting were combining the scruff
things and the individual library I
thought well if I'm rendering graphs so
why don't you the scene graph it felt
like like obvious so and yeah so they're
there I wouldn't say there is your
winner so it's a different kind of
approach it has other kinds of drawbacks
probably and it may be may be better
performance wise with all this rendering
and hardware acceleration you you get
for free but well yeah you have to
well visual I was already there and
provides a lot of functionality you you
don't get if you start writing your own
graph view control but well what are we
going to mention the EF fix application
you've been doing the show us yeah so I
just started a different different beast
here so that's the kind of visual VM
clone so talking about which
realizations talking about charts that
stuff so see it figured out my my UML
demo and you see and I can even like a
NetBeans a platform
I got a property sheet it's not that
nice probably let's see
not so just to explain the you're trying
to port the net be spread from to Java
ethics so it's called EF fig spread from
so yeah so the the the idea behind was
to see we got this big nice NetBeans
platform thing and everything a swing
and then we got jfx panel that was nice
so you could add FX into swing but you
still were confined because you could
not add swing into FX so now we got the
swing node that makes all this exercise
a bit more more obsolete so you can
combine in whatever direction you want
swing in FX so you could still go with
the window system from NetBeans and just
everything else every time component you
can just do an FX in the end there are
some small things you have to to be
aware of like property she'd renders
properties note properties and know
properties are being specification
following uses property editors from
swings so you have done to have those
swing property ages running in your FX
whatever property sheet view so you end
up with all those things you just you
just have to to take care that you know
what you're doing and you know where you
are ending up but I think the swing node
there's a whole lot of more
possibilities to to migrate swing code
to FX hours as it's very true for not
being platform applications so yeah
okay so the question is that some
different presentations about Java
effects and heard that the number of FX
nodes in in in the scene graph can
degrade performance so how that will
work with for example nodes API that has
a lot of objects in in itself and
renders a lot of objects how is the I
don't know so the so yeah so I probably
have to figure out you got nodes in the
scene graph and you get nails that
effectively shown and have to be
rendered and probably the major thing is
that the the number of nodes that are
actively part of what you're seeing
shouldn't exceed a special limit else
you might well get performance issues
but I think that's for a typical our CP
application shouldn't be a problem so
guys are talking about I know a couple
of thousand ten thousands of nodes for a
normal desktop machine so so I can add
that we used to have problems with with
huge numbers of nodes for example if you
are using nodes to NetBeans nodes to
represent three directory structure and
suddenly in one directory you have
10,000 files then expanding this
directory used to be very slow
for that we implemented some kind of
lazy lazy expansion mode that basically
it's enough to estimate how much object
is there going to be but then we create
just those that are visible so inspired
that we know there is going to be about
one for 10,000 nodes then we really
create only 50 if they are visible and
when you scroll we just create just the
portion that is next to value scroll
into so there can be even house in the
whole in the whole array of of nodes and
that significantly boosted performance
because originally expanding this
directory structure with for example C++
files took three minutes and then we
managed to get it to five seconds or
something like that which was acceptable
I think they that job ax team does the
same they called virtual flow and they
are just rendering if you have a a
ListView they're just rendering five
cells and everything else is just
virtual so they're just growing content
into this five five existing cells so
they don't do rubber-stamping like we
hadn't swing where they just paint all
those that are there no they just really
actively have those that you see but no
more but the drawback is that not all
models and things work that well with
that design so we figured out trying to
build a tree table view for for a heap
thing we figured out that getting a tree
to be more lazy well is actually not
that possible
so tables are very good lists are very
good and everything with trees some our
problems there but that's it's on the
table there's a gyro file for that and
we just have to find out a way how to to
get a comfortable change in there and
make that work so don't hold your breath
probably won't make eight so yes but the
idea it's the same idea I don't know
probably they copied it or
I don't know well it's just the same the
same pattern used it's mature yeah all
all the ideas happen well when there is
a time for some idea it happens in
multiple you had parallel any more
questions we get is it possible to
create some more advanced vision some
more advanced tools that will make
easier for to create visual application
at these platforms you know in your can
I answer the different question intense
my computer boots up on this camera of
this idea you know it's a PID eight very
interesting okay you see something okay
I don't see it on my screen but at least
you can see it so there was a question
about how to design a performant API as
a data source so how to how to make sure
that the point can be effectively
represented in your API or in someone
else API so one thing that came to my
mind is some form of using using
generics in something in an API design
pattern which I call which I call
singleton Iser basically that's about
you know in object-oriented programming
usually if you want to represent a poem
then you create a class PO end and you
put method get X into that class and get
Y into into that class and then we are
in trouble because for example java.awt
has different point the
JavaFX so instead of doing that what you
can do is to create an interface which
has all these methods which you would
otherwise put into the each instance of
point for example and accept a point in
this case it's a type parameter so I'm
not referencing here any existing point
this this is just a type parameter we
don't know what it is but then when the
application starts to work with that
start to create the model it can
actually ask the renderer to create the
right point for the rendering engine so
I have two implementation here I need to
click which may be hard but okay so when
you for example have a renderer which
uses a WT or swing then you can
basically implement the decouple
provider to really work with a WT point
so you fix the type parameter to be a WT
point and then implement those two
methods and everyone who is working with
with creating the data structure can
work with the original interface that
the couple provider but the instances
that get created are really those
effective ones for a WT rendering and
similarly here is a fixed point provider
so in case you want to render in effects
you just implement the same decouple
provider in an effective way and use the
point 2d and again this basically
eliminates the duplication and
conversions altogether so it just need a
create method on that and if you need to
create my thought
I realize that deal so basically there
needs to be a create my thoughts always
complain
I do it like this here needs to be a
method a factory method they are a
public point create double X double Y
and of course this will probably cause
errors so we need to press alt enter out
enter now you need to click here click
click in the space wow I managed to
break ha ha oh I see it it's on the
other side not in its on the other
monitor so now ok I generated the point
to create my thought and here of course
you do what's completely natural for
okay it's again on the other monitor so
I'm gonna rather type it point X Y it
doesn't have nothing here with point dot
something yeah oh yeah I see okay yeah
do double point to D double I think it's
pointy
okay the idea we don't good completion
I'm not able to type it but basically at
this way you can abstract and have
efficient data features that's good yeah
so so yeah I'm going to your yes I'm
going to add it to my graph API so I'll
be able to use no it's ap are you okay
no no don't use notes API down
heavyweight does it but this is this is
probably okay instead of using the point
to the abstract the abstract the
creation of the point and we'll be all
friends again
okay so you can expect it soon to be
available on the Java net and that's a
nice outcome of this decision any
questions
okay thank you for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>