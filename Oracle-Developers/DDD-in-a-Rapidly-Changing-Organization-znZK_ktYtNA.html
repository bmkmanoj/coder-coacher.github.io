<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>DDD in a Rapidly Changing Organization | Coder Coacher - Coaching Coders</title><meta content="DDD in a Rapidly Changing Organization - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>DDD in a Rapidly Changing Organization</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/znZK_ktYtNA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay should we start welcome everyone
thank you for coming this talk is about
my experiences with domain driven design
in an environment that's rapidly
changing around us hi brief company and
some of the things that we've learned
along the way about domain driven design
and domain and design in general mostly
through making lots of mistakes my name
is Benji I am a software developer based
in London you can look at my blog if you
want to save some of the things that I'm
interested in or if you're to heckle me
then I'm Benjy Weber on Twitter I first
became interested in domain driven
design about eight years ago now I was
frustrated by our inability to manage
complexity in things we were building
with rebuilding things seemingly as
complex as before we started rebuilding
them and a friend recommended over
kevins domain driven design book which I
found immensely useful and not long
after that I joined unruly well I'm now
working and really is a marketing
technology company we work on and we
build everything from tools for at
distribution online to tools that help
marketers compare how popular their
content is compared to their competitors
during their campaigns and and one of
the things that attracted me to unruly
was the extreme programming principles
they followed and the amount of care
that they had that they took towards the
quality of the code when i joined unruly
were any about 10 12 people in a single
office in london and within about two
years we'd grown to a hundred and twenty
ten times as big across maybe eight or
nine offices and we now think over 160
across 13 i'll say so things have grown
very rapidly
things changed along the way and they
introduced some challenges some of which
I'd like to talk about today the talks
in roughly two halves first I want to
talk about how I see domain-driven
design as fitting in with our extreme
programming practices and why I think
it's important and then after that I'd
like to go through some of the things
we've learned along the way over the
years by making mistakes what of what
have we learned about bein driven design
aim and hopefully finish off with some
positive examples of when things have
worked well but before we get started to
be useful to know a little bit about
your background so that I'm not either
confusing or boring you how many people
are familiar with extreme programming
okay about sixty percent or so and how
many people have read our Kevin's
domain-driven design book okay not so
many handful I really would recommend
everyone read this it's a packed full of
wisdom everything from good object
oriented design to effective
communication to team interaction
patterns so yes strongly recommend you
read that anyone read their small recent
book by born Vernon a couple of people
and this is I also recommend this it's a
immensely practical book if we'd had
this may be 5-10 years ago we wouldn't
have made a lot of mistakes i'm going to
talk about today
so how does domain-driven design and
extreme programming fit together well
for those of you who didn't put your
hands up extreme programming is a
development methodology it give it's
based on a set of values things like
simplicity feedback communication and it
gives us the set of practices that help
us work effectively things like
test-driven development pair programming
continuous integration having a customer
accessible in the team whom we can ask
questions of and having a work quickly
prioritized by the business and
continually improving the way in which
we do things it's a you prolly won't
recognize any to XP teams as being
exactly the same because it's not a
prescriptive practice it's a teams are
constantly improving the way in which
they work so one of the extreme
programming kind of principles is
embracing change I'm so some some teams
try to shield themselves from change by
methods such as having splints doing
which they can't change anything and to
let them focus on what they're building
we kind of take the opposite approach
where we like to embrace that change we
don't want to spend time building things
that we shouldn't be building if there's
something more important to be building
which means the things that we're doing
can change significantly from day to day
or week to week this adds an element of
disruption to more traditional
development practices and we kind of
embraced this throughout the whole
company we have a big ideas process
where anyone in the company can pitch
ideas to the senior people which can
sometimes change the entire direction of
our development team so it allows us to
work on the most important things all
the time but it does add an element of
disruption we're also able to deliver
things really rapidly every pair of
developers we do all of our work had
programmed every pair is deploying to
production five or six times a day on a
good day
and sometimes we go for having an idea a
concept to having it in production
delivering value in a matter of one or
two hours which is really valuable and
be able to deliver value to the business
but again it introduces another element
of disruption to development practices
and if you want to know how we can do
this my colleague Alex myself for doing
another top so Bobby where we'll go into
more detail on how this is possible oh
yeah question the talk tomorrow is
extreme continuous delivery it's at four
o'clock in here and I mentioned we do
pair programming and more than at we
tried rotate round who is pairing with
whom every at least once a day that
helps us collectively owned in the
system it means that everyone understand
so everything works but again adds
another element of disruption if I've
got a vision of the design of what I'm
building in my head and I swap out at
the pear or someone else pops in and
that's not being communicated
effectively then maybe that desired
vision will get lost so again another
element of dysfunction so you may be
thinking is this the ideal environment
for design we've got we're doing working
in very small chunks we haven't got a
lot of time to think about design we
have this one we were very small we
didn't have really domain experts to
draw one because a very small company
I'm and things were working on aren't
necessarily valid for very long before
the business direction changes it's a
bit of a problem with a small company
but also something that we embrace even
as we grow bigger and to suddenly
certain I think you'd be right so what
does extreme programming say about
design if it's introducing these
disruptive elements into our process
well it encourages us to keep our
designs simple which a lot of people
confuse with easy and actually the
inverse history it takes a lot of effort
to make simple
signs it encourages us that our designs
should be incremental so it as our
understanding of the model of what we're
building is improving we should be
refactoring our designs so that our
implementation matches our understanding
and also when we're building things we
should only be considering features that
we've already implemented and the world
we're currently adding not things that
we think we might be wanting to
implement at some point in the future
that probably won't Kent Beck in the
original explained book says this a
pizza lettuce invest in the design of
the system every day strive to make the
design of the system an excellent fit
the needs of the system that day when
your understanding of the best possible
design leaps forward work gradually and
persistently to bring your design back
into alignment with your understanding
which i think is a very challenging
statement I certainly don't manage every
day to be making sure that systems in
line with my understanding but i think
if we did then our designs would
genuinely get better over time rather
than slowly getting worse and leading
real to be real it so that's a bit about
XP how does it fit in with domain driven
design well yeah every heavens told us
in the book he said in the twelve
practices of extreme programming the
role of a system metaphor could be
fulfilled by a bit kritis language
projects should augment that language
with system metaphors and other
large-scale structures when they find
one that's fit as well does anyone know
what assistant metaphor is no they
weren't at all okay and system metaphor
is an idea from the XP explained book as
well I'm in the c3 project which kind of
birthday XP it was the project that Kent
Beck was writing about they were
building a payroll processing system but
apparently they use the metaphor of a
production line throughout their code to
make the code easier to understand for
people who are working on it so that
actually
became their domain language ubiquitous
language is really the core idea in
domain-driven design it's the idea that
you have a shared language that's used
by the team it's created by the team
together with domain experts customers
stakeholders users everyone that they're
having conversations with they have this
shared language and that pervades all
their conversations pervades the code
the domain model and all the artifacts
they're producing really so I think
evidence is saying it is best to use the
natural language that the team would be
using in conversations rather than
something artificial but in some cases
we need to supplement that so why bother
Eli be thinking and songs are codes
clean well factored well tested why do
we care about the language in use in our
code well as kind of agile teams we
value collaboration with our customers
if we're not collaborating effectively
with them then when it going to be
building the wrong things things that
aren't valuable so how do we communicate
collaborate effectively with our
customers we need to communicate
effectively and to communicate
effectively we need to be speaking the
same language on Star Trek there's a
team of a diverse team of people who
speak all different languages aliens not
all human and they travel around the
galaxy and they are able to perform
diplomatic missions make first contact
explore the galaxy and work together as
an effective team but there any able to
do that because they speak the same
language well they don't speak the same
language but they have a wonderful piece
of technology called a universal
translator which makes it as if they do
it translates in real time everything
each other saying so each other can
understand what they're saying and
arguably this is one of the most
important pieces of tech in Star Trek
otherwise it wouldn't be possible which
unfortunately we don't have one of these
and so sometimes we introduce people as
translators to lift some of you seem to
recognize this guy this is the guy doing
nonsense sign language translation
mandela's memorial but as soon as you
introduce people doing translation
things sometimes go wrong so in
development sometimes we introduce
business analysts to sit between
development teams and the business teams
to translate developer speak into
business week and vice versa now that's
obviously not the only way that business
analysts can work but is seems to be a
common anti-pattern and things get lost
in translation if it's kind of the
Chinese whispers effect if we're content
to be spoon-fed requirements things go
wrong this is one of my favorite
examples it's I vote sign from Wales in
the United Kingdom for those of you who
haven't been to Wales all of the road
signs have to be written in both English
and Welsh at the top of the sign you
could presumably bead at a bottom of the
Seine translated read something like I'm
currently out of the office could you
please send me any work for translation
say so the sign builder understood how
to build signs but he didn't understand
the language that he was encoding into
the sign so we ended up with something
that wasn't what anyone wanted at all
and that can so easily be us if we can
tend to be spoon-fed requirements about
what we're building but understanding
the language isn't enough either does
anyone recognize this no this is form a
star trek episode called Darmok and in
this episode Captain Picard and this
alien are trapped on a planet and
they're unable to understand each other
the universal translator I mentioned is
working perfectly they can understand
the words each other are saying but it
sounds like gibberish it's things like
the alien will say things like chaka
when the walls fell and so what does
that mean well long story short this
alien species communicates entirely
through metaphors and chaka is a person
in history and when the walls fell is
referring to an event that happened to
him and if you understood all that
history you'd understand that he's
trying to
convey the idea of disappointment and
eventually they were able to understand
what each other was saying it's kind of
the same idea is internet memes nowadays
they're kind of ish today if you
understand the meme and where it's fun
then you'll understand the idea someone
was trying to convey by it so what does
that mean for us I think it means that
we should not just be content with being
told definitions of things we should
spend time talking to domain experts
going to maybe industry conferences not
just tech conferences wedding industry
literature really understanding the
wider context of the domain in order to
understand what we're building but
understanding isn't enough either and we
I can barely remember the what I had for
breakfast this morning let alone any
intricacies of a domain discussion we
had six months ago so how do we make
knowledge persistent well this guy knew
this was a quote from a guy called Jobe
in the Bible a few thousand years ago
and and he knew that for knowledge to be
persistent it needs to be written down
and we kind of value working software
more than documentation so where do we
write down the knowledge well I would
argue that we persist the knowledge in
the code the code should be persistence
for the conversations that were having
with our customers with our stakeholders
so that we can come back and look at it
I remember the conversation look at it
and it tell us what the conversation and
result was and supplies tests our code
to and tests should also be written in
the domain language in maybe it's easy
for tests to be cluttered with
implementation detail things like
setting up stubs mux database
prerequisites for the test I but then
it's hard to read the test and
understand what it's doing so if that's
happening I prefer it may be a smell
that your model isn't you're not able to
test the model well enough and we have
the test to read in the domain model but
if that's not possible I'd like to hell
out
the dsl that there's the test read and
the main language and have it backed
onto the implementation details are we
often quite fortunate in that we are
implementing I we're automating existing
manual processes this is Google's
self-driving car there's already a loss
of the main language associated with
motoring we don't need to create a whole
new terms it already exists we're not
always so fortunate for example my team
has recently been working on building
something with a framework called
cascading which runs on top of Hadoop
and in cascading they used the metaphor
plumbing throughout the code which
really does make it easier to understand
we have taps which are sources of data
we have syncs to which data flows and we
have pipes that connect different things
that process data and I think in that
kind of very technical domain where and
by mean new domain it's that's West XP
extreme programming idea of system
metaphor really comes into its own
because we don't have a natural language
to use for describing what we're
building so we need to create one but
pretty much really all language is
filled with metaphors in our domain of
advertising the metaphors from an terms
from auctions an auction houses is used
we have options for showing ads we have
bids we have bid requests we have floor
vices so and in all of our language we
have things like Leah we use green to
mean good we use thing as being higher
up to be better than things being lower
down so all of our language is really a
mixture of metaphors and other terms
so that's how I think domaine drouhin
design an XP fit together they're both
about effective communication with our
customers and other people who are part
of the team at once a customer we must
do referring to internal customers
within our organization people for whom
our team is doing work and the way we
communicate effectively is by having a
shared language and in order for that to
work effectively we need to follow the
XP principles of continually it's racing
and improving our designs as I wonder
standing in foods so that's quite a lot
of fair but more theoretical stuff I
wanted to go through some examples of
places we've messed up along the way and
what we learnt from it and it design
ways these are not new thing as a few
when in red the domain driven design
literature then you'd probably avoid
making these traps but these are things
that we did and what we learnt along the
way it's the first what I want to talk
about is being blind to context so the
problem we had was in one of our
applications we ended up with a huge
model more than 100 classes per possibly
more than 200 it was getting very
confusing it was difficult to explain to
new people joining the team what all
this stuff meant and it was making
conversations with our team's customers
difficult we were getting lots of
confusion and one of the developers said
it's difficult to be using the same
terminology in our code because people
non-technical people use terms very
imprecisely and we have to make them
very precise in order to see encode them
but I think that's kind of missing the
point I think the reason I think people
use terms precisely but these them
differently in different contexts and I
think that's actually really important
it gives us a clue about the high level
structure of our code so we might use
package boundaries or operating system
boundaries or API boundaries to separate
different contexts and then within those
contexts
it's easy to you can use the same
context same term differently in
different context without there being a
clash and as we realize this then things
started to get better which will come
unto you probably the best example of
this in our domain is the verb to pay or
the idea of a payment to our ad
operations team making a payment is
something they pay a publisher in
response to some services rendered such
as some views of an advert to other
things and paying that publisher
involves increasing the amount that we
as a company over the publisher now to
our finance team on the other hand when
they make a payment they're actually
sending some money in the real world to
a publisher which actually involves
decreasing the amount that we as the
company either publishing their leaves
the same language in discussions of
paying the publisher but it actually has
literally the opposite effect on the
system as a whole or our company as a
whole so as we started to realize this
I'm which actively took us too long we
we went through the exercise of
refactoring the model big model into
smaller contexts initially just separate
by packages and then later set foot ed
processes Sanford deployable artifacts
and one interesting thing we noticed at
least I thought it was interesting is
that the context tended a map quite well
to the personas that we've been using on
our user stories so we had all along we
had in ad operations persona which we
stories that were features for the ad
operations team would be under and that
ended up mapping quite well to add
configuration context our finance team
obviously not quite well to our
financial model that we ended up with so
I thought that was quite interesting it
was kind of in our faces all the time
but we'd been ignoring it
another lesson was that the this started
happening when the team proved quite big
and I think this is a kind of an
implication of Conway's law that the
organizations tend to produce systems
that no other communication patterns
within that organization when the team
was getting big it's easy for terms to
get muddled for people to be using
language in different ways it's harder
to spot when that's happening as we
split out the teams as we agree it
became easier to notice this kind of
thing for example our analytics team has
a concept of a creative which to them is
kind of a collection of similar video
content for purposes of reporting they
can treated the same whereas for my team
I creative is a set of like video video
image text assets that form the template
for an ad and they're kind of completely
different things and because we're
separate teams that was easy to notice
and when we came to want to build a
reporting layer across both systems it
was clear that there's no way we could
coerce these into being the same thing
and we had to treat the reporting system
as another context okay the second
example I want to talk about is hearing
but not listening to what I use is the
same so as you might expect to an
advertising company we had a concept in
our model of an ad or an advert not
surprising what was surprising was that
at one point we had a fairly odd request
from our ad operations team to rename
this ad everywhere it appeared in copy
in the UI renaming it from ad to sub
campaign and by sub campaign they meant
a part of an ad campaign it was quite a
generic name this was a bit odd and
what we should have done at this point
we've talked to them and understand how
our understanding of the model had
diverged from their understanding of the
model and then we factor to bring the
two back into alignment unfortunately
that's not what we did but he kind of
buried our heads in the sand and we went
ahead and made the copy changes they
requested I wasn't long before we went
into problems with that we found that we
were getting confusing requirements the
people asking us to do things that adds
really shouldn't be able to do we found
were getting code smells when people did
what they were asked and added features
to the add that really didn't belong
there we ended up with kind of a god
object that did far too many things so
there are other things that could have a
letter dist for the problem but the
first symptom was really the fact that
our vocabulary had diverged but why did
we stick our head in the sand lightest
why did we not address the problem
earlier I think it had to do with the
state of our code base at the time there
was a lot of things that cause
resistance to refactoring so for example
we had a lot of unit tests that made
happiest mocks in such a way that each
test was asserting many pieces of
behavior about the model because they
were strict mocks and if you change the
night of a behavior and a model it would
often result in chat in breaking several
tests maybe even dozens of tests and so
that cause resistance to be factoring
because we knew that every change we
made we'd have to go through all these
tests work out why do I breaking and fix
them we also had resistance from
frameworks and this was before we
factoring tools were quite so good they
can now do a lot of refactoring with
some of these frameworks the frameworks
such as dependency injection our M's
templating frameworks we were using
several of these to interrogate the
model by reflection and when we made a
change that would we could rely on the
compiler to tell us all the places we'd
broken the Java code but there were
still loads of places to burn through
with
that could have been broken by I'm
frameworks that are interrogating of the
reflection and we have nothing to really
tell us whether that happened yes some
of our tests could sometimes alert us to
this but it didn't give us the same
safety net that the compiler gave us for
the a java code so to all these things
that are holding us back from
refactoring and improving things so what
we learn we learnt to listen when a
vocabulary is diverging from our users
and take notes talk to them understand
why and act accordingly why was I
refactoring hard here there were all
these technical reasons and but the real
underlying reason was that we weren't
doing enough we have kind of a motto if
it hurts do it more often and then it's
going to get less painful because we
forced to address the underlying cause
of the pain if we'd been doing more
refactoring and we would have been
forced to address all of these things
that were making refactoring hard and
indeed that it was the case as we
started to do more and started to
address some of these problems we had to
improve our tests we learnt to write
tests where each test asserted as close
to a single aspect of behavior as
possible we lent to be more wary of
values of frameworks what is it making
it hard to change in the future as well
as how easy does it make it to build
things now
so next example is consistency being
overrated no matter how agile you think
your development team is your marketing
team is probably more agile at least
that's true for us but able to change
the language use overnight and that has
quite a lot of implications for us oh
you may think it's just words what does
it matter what marketing cool things but
they change things because they want to
change the perception of something
whether it's outside the company or
inside the company and changing
perception also in our experience
changes the behavior people expect from
it so why is that a problem sure we
should just keep up with them well it's
very hard to keep up with marketing
partly because there were some things
that are just inherently hard to change
there are terms tend to leak into things
like URLs which shouldn't change ideally
should keep them working terms tend to
leak into large datasets that may take
hours even days to update in some cases
so we started off blocking kind of our V
factoring exercises until we could find
enough time to do all of these things at
once and that was a problem we kind of
imported the idea of inconsistency where
we'd have multiple languages and use for
the same thing so we wanted to update it
all at once but we basically found you
and getting around to it that's a
terrible pearl pun by the way that's
what we learnt was to focus on what
helps us communicate most effectively
which is the core domain model update
that as soon as we can after the
language starts changing because that's
what helps us communicate with our
customers
if if we waited until we get up to
everything we found we basically just
weren't doing it now in some cases that
means you need to introduce the
translation layer that translates
between kind of the language and using
your core model and old language in use
in other places but that works is kind
of another as kind of executable
documentation of that there was old
language in use for this and now there's
this new language it helps people
understand way it also documents changes
and differences in behavior as well so
keeping up was impossible so we learn to
focus last example I think of things
going on don't repeat yourself it can be
a trap so we started building a new
system maybe two or three years ago now
and we decided to build it as a
collection of smaller services this was
kind of before the micro servers hype
probably not as small as microservices
but quite small services because they
were all part of one application I
appeared that they were kind of using
the same model across all of these
services so developers not liking
duplication thought LA we'll have our
model as a library and share that across
these services and then we can reuse the
same code now we wanted these services
to be separately deployable because we
like to deploy things very rapidly and
to make that work people decided we use
versioning full version this library and
then we can have different versions in
use by different services it wasn't long
before this ran into problems you can
probably guess I what could go wrong
right I we had multiple versions of kind
of the same concepts but different
different behavior running in production
modifying kind of the same state as it
flowed through the system which resulted
in unexpected behavior in production we
had
different versions in production there
was no way we could test every single
permutation of all the different
versions of this that might be running
in production I mentioned earlier about
how fast we can add deploy to production
so you could end up with a large number
of versions in different services and we
did indeed run into problems one service
created an object graph that was just
incompatible with another service things
break in production so we refactoring
approach we took to this we decided that
any change we made that was a first step
any change we made we would add redeploy
all affected code to production each
time it's part of our kind of continuous
delivery approach and that way at least
we get rid of the betting problem so so
that helped and then we realized we need
to be more relaxed about duplicating
code because sometimes we need to be
able to play things separately for
various reasons and as we started to
perform at refactoring we noticed really
we just been being blinds to different
context again this was kind of an
analytic system but it became clear that
the same entities really would behave
differently in different contexts when
we're collecting data about them the
behavior was different to when we were
reporting on them or when we were using
them for calculations for other teams
within the business so really we just
fallen into the same trap all over again
so even though these services are much
smaller they still had separate contexts
see how we learn don't version artifacts
in production and again come back
tomorrow to find out more about that
redeploy all affected code production
each time and deploy often is something
we do anyway but that helps us to notice
where there's missing boundaries between
things because deploys gets low we want
them to be fast so we can work fast and
so where that gives us the pain I was
talking about earlier and when we're
causing ourselves pain by doing things
more often than we're forced to address
the underlying issues
if one more problem I so it's not just
development problems that we have for
failing to apply the main driven design
properly we also have performance
problems so domain driven design has a
concept of an aggregate which is kind of
a collection of strongly connected
domain objects for purposes of
transaction boundaries or persistence
and and retrieval of data so you don't
have to worry about these things across
aggregates and our groups are far too
big this seems to be a common problem
lots of people seem to have this bub
Twitter's fill of vista and but maybe
this is a common pattern that you've
seen so you got a web application web
request comes in to your application
then you go after the database slowed a
load of state of the database into an
in-memory model you poke the model a bit
to perform some operations which in turn
results and loading loads more stuff of
the database and then at the end persist
all that stuff back to the database and
your web response goes back out again
this kind of works fine for small models
but the trouble is the models grow in
ways you don't anticipate so we
initially assumed that each publisher
would only have a small number of web
properties and that was completely blown
out of the water by large blogging
platforms with millions and millions of
pages and so the unexpected performance
implications the problem really here in
this particular application was our use
of our m's it was hiding all the crazy
stuff that was happening but it's not
purely our mville it's very difficult in
Java to convey the performance
implication of calling a method at the
call site it looks just like a method
call regardless of whether it's just
invoking something ellen object or as a
result of that according out to an api
or a database was difficult to convey
that to the person using that method
I VRMs were hiding all the crazy stuff
so what we learn in this application we
kind of use our earns less now but in
this application we started not using
lazy loading so that we didn't we
weren't transparently loading other
aggregates of disk without realizing it
because before this stuff would only
show up when we profile the application
and work out what's going we try where
possible to make performance
implications of doing things explicit so
for example if you need to load our the
aggregate rather than lapping a method
call that transparently loads more of
your object graph instead that's that
gives you a a reference or when
identifier further and then you can use
that identifier to go and load small
data and like find it makes it explicit
that there were maybe transaction
concerns to these two things being
separate or maybe there are performance
concerns for loading that data so it's
not all bad things work well as well my
best example I think this being really
useful having a shared language that the
team's coming up with are they using and
helping them adapt we're working on a
tracking feature for our ad units I
think we were building a feature that
would allow us to see how many people
had gone on to make a purchase as a
result of being exposed to an ad
something that a lot of advertising
companies will do and we were
implementing and we're getting stuck on
part of the implementation we I think it
was related to what to do when a user
been exposed to more than one ad on our
platform and as usual when we don't know
what to do in this kind of snobby a we
convened a team huddle something like
this we get together and we discuss the
problem and try and come up with the
solution we've been sketched up some
sort of pseudo uml on the whiteboard but
we didn't really get anywhere
so at some point I went and pulled in
someone from that ad operations team
kind of a domain expert because he's
worked with this kind of feature before
with other people's platforms so we
brought him down to our area and started
explaining the problem to him but at
some point while we're explaining he
noticed our sketch on the whiteboard and
he said says something like here why
have you connected the tracking pixels
with the ads I send out the tracking
pixels before I've even created the ads
in the system and thus he'd kind of
solved a problem we were looking at the
implementation detail trying to coerce
it into working let's guy trying to look
at what's wrong with his engine I mean
while someone familiar with the domain
was able to use an artifact produced for
the dev team by the dev team had
intended for developers but because we
were using the same language in
everything we do he was able to
understand it and split the problem
which this guy is causing the lake for
us it was that our model was wrong and
this kind of thing happens quite a lot
so a few weeks ago we were working on
automating an algorithm for predicting
the popularity of videos in the future
based off data we've collected about
that video and other videos and we kind
of implemented the model but we weren't
very confident he was working we need
all our tests were passing but we
weren't really confident we written like
tests because we didn't fully understand
the underlying months behind it and we
hadn't yet plugged it into our the user
interface into reports and our data
pipeline to so that people could do a
more end-to-end test but we wanted to
increase our confidence before we did
that so we went and pulled in someone
from our data insights team to come and
have a look at what we've done we
actually sat down with him and walked
through the code this is not really a
very technical person he well he's
familiar with Excel he knows the
the what we were implementing because
he'd kind of come up with it but it went
there code but we were able to walk
through the code with him and he was
able to actually understand what it was
doing recognized it was the same as what
he'd be doing in Excel and more than
that we were able to work through the
tests and he was able to read the snow
yeas and work out that yes that is what
it should be doing in that scenario and
we actually helped him modify the inputs
and outputs as well and check that it
was behaving as he expected and this is
the kind of thing that's possible when
everything you're doing is using the
same sort of language our acceptance
tests as well which one is the same
language as our ad operations team so we
have kind of a domain model almost of
our ad young ad units which uses the
same language that the adopts team will
use to talk about our ad units when
they're talking about setting up
different features for different
customers that models only used in the
tests is backed onto a webdriver with
kind of the page object pattern but it
means that the tests read in the same
language that we'd use discussing
features with our adopts team and on one
occasion there was a dispute about how a
particular feature worked with our ads
and well this guy was in a different
office but when he came over to London
we took the opportunity to go through
the scenarios for the feature that we
were talking about and I able to
convince him it did in fact work as we
told him and it that we could be sure it
was working as we could show him these
tests show him the Mexica ting and
testing the future and so so we found
that really really valuable as well so
in summary I'm really we've grown really
fast it's introduced some problems some
words introduce disruption to
development practices we move really
fast which adds more disruption because
things may not be valid very long but I
think remainder of design really helps
if we use in the same language and we
keep the language up to date then it's
it should be easy to spot when I
language liebert and
edges and it is easy to spot really it's
just that sometimes we've ignored it
yeah but any and it's hard to make sure
that you do keep up to date with things
because there's as usual there's always
pressure to be delivering things and we
have to be really disciplined to be
updating our models all the time key
points I thought you might want to take
away if something hurts do it more often
do painful things more often and they
will become less painful because you
will have to deal with the pain what
causes the pain be wary of frameworks
consider what they're going to make hard
to change in a future not just how easy
to make a life right now and if
necessary isolate them behind
abstractions continually integrate
everything or doing to us continuous
integration means not just integrating
our changes with the rest of the team
but integrating our changes into
production so they're integrated with
our production environment with the data
in production with our users in
production which is quite from the
extreme interpretation but doing that
forces us to notice things that you
might not notice in isolation and
working on a particular feature in your
workstation and finally everything we're
doing is all about having effective
conversations conversations within the
team about what we're building how to
build it to conversations with our
customers about what they want
conversations with stakeholders about
how it's going to deliver value for the
business and it's those conversations
that enable us to build the right thing
and enable us to build that thing well
well thank you very much for listening
and I've any questions yep you have
something as in two different contexts
that you don't want to use the same
implementation each because it may have
different usages in those two different
contents what if it needs to be backed
by the same Gators
you wake up with over those artifacts
talking to Gators so the question was I
think if you have the same thing in two
different contexts or with different
behavior but it's backed by the same
data store what you do then do show it
well this was kind of the snowy we had
actually it was back they were back for
the same data store and as we started
splitting it out we also started moving
away from that folk and we moved more
towards services that communicate to
each other player and we're using flume
patchy flame so the bay they send each
other messages and we actually only have
one service that's storing that state
now I think it is hardware you have
actual shared state across different
contexts and we tried to move away from
that buzz and solving that problem I
don't need someone else might have some
insights into what to do in that snowy
any more questions yep
design time you some things that you
make very easy for your end users
understand but it's a way need to
implement it into runtime view because
it needs to be efficient possibly the
waitresses philosophy so this is the
same concept but these mythical
presentations how do you then
how do you deal with different views of
the same concept for reasons of
different users or different performance
requirements I think sometimes they'll
just be supper context and they will
have set foot representations you've got
to think about who is who's this for so
if it's I'm doing some very performance
intensive calculation may be that that
mean that's a result of the
implementation maybe that's not
something that the business is concerned
about and there they wouldn't be
interested in looking at us anyway and
this is it was only be the developers
who talked about this feature so you'd
use the language that they've used to
describe it and I might be different
even if it's under an underlying
implementation for a business concept
maybe that's different I don't know
these things tend to be very different
for each specific example I think
different answers more questions
now okay well I hang around afterwards
if anyone wants to chat but thank you
very much for listening and come back to
my</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>