<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Microservices for Mortals | Coder Coacher - Coaching Coders</title><meta content="Microservices for Mortals - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Microservices for Mortals</b></h2><h5 class="post__date">2016-09-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5ZSA99aq6UA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so waking up the evening or the morning
after all the party to Jeff one sure
made me feel mortal I don't know about
you but I'll try and be your
entertainment for the next hour so here
we go
welcome to micro services for mortals my
name is Edmond I'm from the Netherlands
where I work and live mostly and my work
is mostly concentrated around a number
of clients and also I have some internal
responsibilities I run a training
academy and also a conference so I had I
was a lucky one to be around Java
actually when it started so I like to
think of myself and I know a thing or
two about it and the good news is that I
really like to share those things as I
get to travel a lot and I speak at many
conferences so that's enough about me
let's talk about micro services so when
you start reading about micro services
you probably see things like this right
cheaper better faster stronger and we've
seen these things before right so the
question is do you still fall for it
right and and to answer that question
I'm gonna ask you a question first and
that question is do we have any fans of
the band Metallica in the room don't be
shy right show some appreciation for
real music all right okay okay good I
know it's still early so the reason I'm
asking this is that you may or may not
know this but Metallica is actually
known for their lyrics about
microservices and and I can prove it to
you right so this is an excerpt from one
of their songs called no leaf clover
might be not be their most popular song
but I mean it's in there and to me this
is exactly what this session is about
right so imagine yourself in this dark
winding tunnel right because you have to
deal with monoliths all day and then at
some point you see the lights right the
light at the end of the tunnel and for
some of you this may be the soothing
light at the end of the tunnel right
just like Metallica says but then for
others it might be a freight train
coming your way and so the thing with
this presentation is
I have seen many many presentations on
microservices already and most of them
really have this hallelujah vibe to it
so this is not gonna be an endtime
micro-services presentation but it sure
is an objective few or mostly not only
the prose but also the cons and the
pitfalls of what you are getting
yourselves into when you start doing
micro services right so a Metallica is a
really nice way of explaining to me at
least so okay I know it's still early
but I'd like to talk to you about food
right it's nowhere near lunchtime yet
although in my timezone it oh really way
past lunchtime right but for some reason
we like to compare our architectural
styles with Italian food right so
basically what it comes down to is that
everything before service-orientation we
now label it a spaghetti architecture
right because it's pretty much a big
mess it's tangled and if you pick up one
end you have no idea whether it's gonna
be short or long and what will end up at
the other end actually right but then
somewhere in the year 2000 something
right we realize that we started to eat
all the spaghetti and we went from
spaghetti to lasagna as when we entered
the service-oriented age right we
started organizing everything into
layers so if you think of a layered dish
oh you get to lasagna and now that we
are talking about micro services for a
while and we're actually on the brink of
the next architectural shift it is about
time that we put a Italian dish to watch
this style of architecture so I need
your help here right so I have two
choices for you on on the left hand side
there is macaroni so we have macaroni
architecture and on the right hand side
there's Ravi Olli so we have a Rafi Orie
architecture so all in favor of macaroni
architecture please raise your hand
a few right and then all in favor of
ravioli architecture okay all right so
now I have to solve alright so now I
have to solve this dispute and um so
while I was preparing for my talk I
thought well I mean let's turn to Google
all right let's do some Google research
so what when I was researching
microservices I stumbled upon this
picture
and you may or may not know but this is
actually a recent picture of Netflix's
architectural diagram right and as you
know Netflix is supposed to be the
poster child for micro-services so this
is what your architecture will end up
with right if you go Netflix style oh
that's that's a pretty side right so but
the thing is that we're still trying to
solve the Italian dish right so when I
was staring at my computer screen for a
bit right suddenly I started to see this
and now okay I give it to you this is
not strictly speaking this is not
macaroni right this is mac and cheese
right sorry that's the American version
of macaroni and well the recipe is
actually pretty easy so you take a
beautiful Italian dish
macaroni all right you know where this
is going right I think you dumped a
shitload of cheese on it yes and yeah
and it I mean it screams healthy right
you see all the vegetables and stuff
it's yeah it is amazing so from now on
right I like to think I'd like you to
think of micro-services as mac and
cheese architecture right so now that
you laughed about it you'll probably
never forget it all right so okay so
disputes solved so now let's get into
the more serious part of this talk so
let's ask ourselves you know where does
this architectural style actually come
from right and when I talk about
micro-services I really like to to label
it as an architectural style because
it's really important that there is no
single truth in microservices right
there's no single thing or book or
whatever that you can turn to where it
is stated exactly how and when and where
and what you should do in order to get a
microservices architecture so in my
opinion microservices is a style which
comprises of some technology some
practices some process and at some point
somebody labeled it microservices and
we've seen these things before right
we've seen with Ajax no sequel even it's
so on
they're all things which are a
combination of things that we do and at
some point somebody labelled it but it's
really hard to get a strict definition
for
each and every one of them right so if
you consider microservices an
architectural style then you can ask
well where did this did this style
originated from and like I told you
before a Netflix is supposed to be one
of the deposit deposit children for a
micro service together with Amazon and a
couple of other companies and they
really used it to address changes in
their software landscape right and these
changes were not originated from a
technological perspective but they were
they originated from a business
perspective so it is really important to
understand that the drive to watch micro
services come from a business
perspective right so it is a way to
address business agility and if you take
Netflix and they really needed to
overhaul their existing business model
into something completely different
right from DVD renting and DVD reselling
onto the biggest online entertainment
company right there's totally different
business so they need they needed to do
drastic changes to their business model
and in order to accommodate those
changes they needed a way to to address
that using technology right so it's
using technology to address business
changes or business process changes and
not the other way around now there is a
number of drivers which will eventually
Drive you into the hands of micro
services right but it is also important
to understand that micro service is not
or it's not like an architectural belt
system right like karate where you say
well I have a brown belt now and I
practice a bit and at some point I have
a black belt right so micro services are
not black belt of architecture right it
is an architectural style and for some
it will be a good fit and for others it
won't right so imagine you are a heavy
user of services and api's yourself and
your everyday work then there's a high
high likelihood that you will turn into
building services and api's yourself as
well right so this might eventually
drive you into the hands of micro
services same thing with DevOps you
might consider micro services as an
step of DevOps but then the other way
around you really need you to have your
DevOps in place you need to have solid
CI CD purchases in place before you can
even start thinking about doing micro
services and I will come back to this
point later on as well
you can also think about micro services
as a next way of doing agile because
most of us now probably know how to do
agile in a single project right but what
if you have you know a large software
landscape where you have multiple teams
changing parts of the architecture at
all times right and they don't
necessarily talk to each other at all
times so it might be a way to address
those ever-changing things in our
architecture using this style of
architecture if you think about it from
a completely different perspective let's
say your Netflix again right you see a
revolution in terms of how people
consume your content then this style of
architecture might also be a way to
address new developments in technology
in a new way of how people or things
start consuming your services in your
api's right so the first point here that
I want to get across is that micro
services are about business agility and
not so much about technology so just by
using docker you're not doing micro
services right all right so if you start
reading about micro services a bit more
you might run into quotes like this
micro services are like so on but then
only the good parts now this implies
that so I actually had good parts right
yeah and well it depends on the amount
of disappointment that you went through
whether you're able to see it yes or no
but to me I think this whole notion of
service orientation it's actually a
pretty nice thing right so I think it's
pretty nice to think about software in
terms of services so that's where this
compression is but so actually works and
to some degree but I have to be careful
here even the idea of having an ESB but
I mean the pattern right the
architectural pattern
is not such a bad thing although as soon
as vendors started to interfere and he
got ESB products that's where things
went sour right so that's actually the
next questions
what happened to so on that we need
another architectural style right
because so I promised us utopia over and
over again so why aren't we there yet so
I like to think of it as all gardeners
fault right and that might be easy to
say but I think but I really think it's
true and I'll I'll tell you why
so gardener they have these conferences
every now and then right a couple of
them per year and then you know all the
c-level executives they gather at these
conferences and they eat and drink and
they're merry right and they listen to
all the stories from the garden analysts
and at some point Gartner was really
hyped over so right so I really was the
way to go and so it was actually pretty
easy to convince all the c-level
executives right and so they demand that
we want to have a so on right all right
so that's where the vendor stepped in
and they said oh you want to have so ah
well we'll give you so on and they
turned all of the good ideas into
products right overpriced horrible
products to be exact right and they were
called WebSphere ESB and what-have-you
right and these products were sold at
huge amounts of money to these c-level
executives and then they got home and
they talked to us and they said well I
want you to build me as so on and here
is the thing that you are going to use
because I spend all our money on it
right and we all know what happens right
this was not a happy ending and the
thing I'm telling you is is that you
know history has a tendency of repeating
itself so you know with all the sessions
about micro services these vendors they
are lurking in the shadows right and
they are already thinking about their
next products in fact if you google
around a bit there's already a number of
them out there right now I think there's
nobody in the audience which is willing
to admit that he's working for a vendor
right now all right
but that's what they are really thinking
and well just to prove this point right
when I was you know googling for this
talk I found this and at first sight
this appears to be some sort of a
reference architecture from
micro-services and actually pretty nice
apart from one or two typos but then and
you point your eyes to the lower right
hand corner alright yes so so to put it
in the in the in a quote from one of my
favorite movies right this is actually
where it's going now actually the matrix
I take you all you all seen the matrix
right at the matrix well we shouldn't
tablet a movie right it's more like a
documentary yeah and and and you all
know probably that there is a really
important question in in that
documentary right and at some point the
question get asks which pill do you take
when it comes to micro-services right
well they don't put Microsoft to it but
that's what I do so you have two choices
here now if you have seen that
documentary you probably know which way
it will go but let's assume just for a
second here otherwise you're gonna mess
up my slides that we're gonna take blue
pill right so if you approach
micro-services from a blue pill
perspective right then you enter the
world of blissful ignorance right and
sometimes oh that's nice right because
if you look at your Twitter streams
right and you look what everybody is
doing on LinkedIn and you look at the
job descriptions then it appears that
everyone is using this cool technology
right and you are still stuck with all
the old crap right so it makes you itch
for a little bit so I want to do this
microservices thing and it sounds like a
great idea to introduce docker and what
have you into my organization so let's
do micro services now I can guarantee
you that if you take blue pill and you
go into micro services world you will
quickly turn from one pill to a whole
set of other pills right it's probably
gonna be vicodin or exacts or whatever
what have you but you'll need lots of
them so so let's let's not approach
micro services using a blue pill
perspective right so let's apologize to
mr. Morpheus here and say okay I wasn't
really paying attention right
I took the blue pill it got me the
Microsoft boner for a couple hours right
yeah that's the thing with the blue pill
but I mean yeah so so now I might be the
one so I take the red pill right and the
red pill well it takes us to the painful
truth of reality right and we really
need to learn how we can start defying
the laws of IT physics now this might
seem a little strange at first but let
me explain it so the first thing that
you have to realize about micro-services
that it's all about distributed
computing right that's an open door
right but it's it's good that you
realize every now and then and the thing
with distributed computing is not that
it's hard in terms of you don't have the
tools to do it I think right now we have
more than enough tools so then it's
really easy to do it but it is hard to
grasp right it's hard to graph your head
or to put your head around it and really
understand what is going on because
there are so many moving parts and the
same thing is the second thing to
realize that you will soon abandoned
familiar programming models so in our
current mainstream stack we're probably
pretty used to asynchronous programming
model but with micro-services you will
quickly turn towards asynchronous
programming models right and as they say
there's not so many things wrong with
asynchronous programming except for
programmers right because there's lots
and lots of programmers out there
probably not us
but there's lots of them out there who
are willing to admit that they have a
hard time really grasping asynchronous
programming model so the same thing goes
for distributed computing right so what
microservices does is it is raising the
complexity bar not by a bit but by a lot
right because we go to distribute
computing and then we go to a singleness
programming models right so it means we
raise the complexity bar a lot so if
there is a con raising the complexity
bar there need to be a lot of pros in
order to get rid of these cons right so
let's talk a bit about this defying the
laws of IT physics
so if you fancy any of the things which
are on this slide right cygnus
programming models a single Enterprise
domain model asset transactions or
distributed transactions or what have
you
relational integrity right then you will
be in for a treat when you go to red
pill world because in red pill world you
will quickly realize that there are no
such things so you should be ready to
abandon a lot of witches on this slide
and as they say in the documentary there
is no spoon so at first when you enter
micro-services will you see spoons all
over the place and you have to realize
with each and every spoon that you see
is it a real spoon or can I bend it
right and in terms of micro-services you
will need to bend your spoons a lot
right or there is no spoon at all so if
you're really tied to your enterprise
demand model or you can kiss it goodbye
if he gonna do micro-services you want
to do transactions in an acid way or if
you want to do them in a distributed way
you can kiss them goodbye so you need to
be ready to defy these laws of physics
and this is how we are trained right we
are trained to think in this kind of in
these kinds of things but if we really
want to do micro services we need to
forget all about them now if you are
ready to look past these things then I
can welcome you to red pill world and
red pill world looks something like this
because this is truly defying the laws
of IT physics
okay spoiler alert he's not gonna fall
off all right now microservice is for
mortals so who remembers Mortal Kombat
right yeah okay so let's do a round or
mortal combat with micro-services but
before we can start fighting we need to
take one step back and select our
fighter first so let's take a look at
the player selection screen oh there's a
bunch of interesting people over there
and I think I'll go for the one in the
lower left hand corner let's look and
who that is ah it's the monolith alright
so now I knew about this thing called
monolith or monolithic architecture as a
way to describe the architecture of the
60s and the 70s right but somehow over
the past couple years this word was
introduced it has a pretty negative
sense to it right and somehow everything
that we have been building for the past
4050 years is now dubbed a monolith and
it's supposed to be bad now just to
state the obvious here not all non
micro-service applications are bad
applications per se right I mean that's
a little bit of uplifting to this and I
get into these discussions a lot with
coworkers or with clients and I'd like
to ask them a question and I say well
what do you call an application that
everybody wants to interface with but
which was never designed to do so right
is it a monolith or is it actually a
successful application right so things
evolve over time and not everything that
we have built using older technology is
bad per se right and also if he shifted
towards the users perspective right the
user has a pretty clear opinion about
what he wants right so you can put it
into a user story and you say I just
want a thing to work alright so the user
doesn't care whether we are building
monoliths or microservices he does care
about getting the functionality fast
probably right and this is where micro
services come in so let's talk a bit
about when monoliths are truly bad
and probably we all recognize these
situations I mean systems can end up as
monoliths when you start to build up
massive technical depth right and this
can happen of because of all sorts of
reasons and over time it will become
harder to change anything without
breaking stuff right so um oh I have the
luxury to work with customers that will
pretend to do agile right so they do
two-week Sprint's and then after the
two-week sprint they do a two months QA
cycle right because they are afraid to
break anything so this is the kind of
mullets that we are talking about right
and these kinds of monoliths actually
are bad and if we can find a way to
change them for the better right because
probably the functionality which is in
them that's still still what we want
right but and we want to but we want to
better them in order for it to become
less hard to change right and well let's
think about the business agility
perspective we want to be business agile
so we want to be able to make changes in
our business model or to adopt to new
things happening in the markets and with
moments that is hard to do so a little
while ago
this thing was coins which said well
maybe you should do a monolith to
microservices approach if you have an
existing monolith you should maybe start
strangling off some of the services
which are locked up inside of the
monolith you strangle them and you
strangle them off and then slowly you
turn your big monolithic application
into a set of micro services now I like
to think of this as pretty theory right
but in practice this is all going this
is going to be hard to do because your
monolith right has internal building
blocks but they were designed with
different things in minds right so they
probably do very cheap in process calls
right then if you turn it into a bunch
of micro services you're gonna do
distributed calls over a network right
which will introduce all sorts of huge
failure modes right we have a thing
called latency to deal with and then the
interface of the building box probably
was also designed to be pretty you know
fine grains because calls
right so if you want to turn your
monolith upside down it's probably not
enough to just strangle off services but
you have to completely react attacked
and redesign the thing so it's probably
not that easy but there's a bunch of
things that you will run into when you
start thinking about micro series I call
them the micro services struggles and
these struggles all they are dead or if
you turn your micro your monolith into
micro services but they are definitely
there if you go for greenfield micro
services deployments right so in both
cases you will have to deal with the
same struggles and so in the remainder
of this presentation I will go into
these kind of struggles and what you can
do and to deal with them so the first
one is called initial investment and the
initial investment if I you know take
back the the Gardner architecture
diagram over there is also called outer
architecture of services right so it's
not the services themselves but it's the
cross-cutting concerns that these
services rely on and you can think of
discovery mechanisms monitoring and
metrics stuff like that right logging
those are all services that you need to
do have presence in your software
landscape in your systems a landscape
because all micro services will have to
deal with these cross-cutting concerns
and so they will be sharing these
infrastructural services now this is
probably the easiest part of going to a
micro services style of architecture
because for most of these things there
is either open source or commercial
alternatives out there right so you can
just download these things configure
them and then you have them up and
running in your in your infrastructure
right so this is probably the easiest
thing to do it will get a little bit
harder if you don't have your DevOps in
place so there is a very strict
requirement for doing DevOps for doing
micro services which is you've got to
have your DevOps in place so if you work
for a company where you don't have
DevOps in place right now forget about
doing micro services you really gotta
have your CI CD in place and if you have
to start doing that right now it will
take you months if not years
to get their hopes right and then you
can start doing micro-services if you
start doing it the other way around
you will get yourself into very big
troubles right then this whole thing of
having multiple services around also has
a very high impact on your testing
strategy right because right now if
you're testing a model it's you deploy a
version of your application and you can
start testing it right in its natural
habitat but then you have everything
present now with micro services each and
every service is completely independent
of each event of each and every other
service so what you cannot do is have
connected deployments in terms of where
you have to deploy like five or 10 micro
servers at the same time or to be able
to test one of them right so they have
to be testable by themselves so this is
turning your testing strategy upside
down and actually the only place where
he can do the real testing is in
production right and and now we've done
this before right but testing in
production is a really tricky strategy
alright so I think this deserves a
conference session of its own so I don't
really have a time to go into this right
now but really rethinking your testing
strategy with micro services that is
really important all right so much for
initial investment let's let's move on
into internet topic which is called data
strategy and when it comes to data
strategy and micro services it's
actually pretty easy because there's
only two ways to do it there's the right
way to do it
and and then there's another one which I
forgot but when it comes to micro
services it is really easy you cannot
have two services that perform updates
on the same database model you can try
but you really really don't want it and
the reason why you don't want to have it
is because if you have independent
services but you tie them together using
a database model you will leak details
of your domain model into these services
so they become interconnected right they
become intertwined and after a little
bit you are not able to change one
service without changing the other right
so it hurts the end of
of the services so ideally you don't
want this to happen now if you come from
an existing database model right since
we're cutting up the monolith and we
have this huge database model right
designed by a DBA and he tried his best
shot to really annoy us so he put it
into the thirty-fifth normal form right
so it's actually really hard to to deal
with it and then it can be hard to cut
up the database into smaller pieces so
what you can do then in order to slowly
migrate to what's a situation where each
and every service has its own catalog is
by at least separating read and write
access right so it's okay to some degree
to read from the same model but you
cannot have two services updating the
same model and well there's older
technical strategies that you can use so
you have CQRS or event sourcing which
you can use as a way to slowly migrate
away from having a single domain model
and a single database model into having
each and every service with its own data
model right but this raises a number of
questions so for example well how do I
deal with common data for example right
because we see it as a spoon right data
redundancy is a bad thing right that's
what we learned
but in micro services world data
redundancy is a spoon and it's meant to
be bent right so this this spoon is not
there so data redundancy in a
micro-services world is perfectly
acceptable because maybe it will just be
there for a short amount of time and the
other reason is you know and this is
probably also an eye-opener to some of
you but microservices unlike so our
services are not meant to be reused and
you really have to think about this so
it is okay to use a micro service but
they are not designed for reuse like so
our services are so and so on we design
one server that needs to be there for a
long long time that's why we version had
very strict versioning with with dolls
and X's and XS DS and what-have-you
right so we design it once and we try to
reuse it as much as possible but
microservices the goal is to deliver
software into product
and faster right and to adopt two new
business models or changing business
models so they're the speed of getting
things into production far outweighs the
element of reuse so it is okay to use
and maybe reuse a micro service but they
are not meant for reuse right that's why
it's also perfectly acceptable to have
redundancy in terms of data now there's
all sort of things you can do if you
have a spare a couple of milliseconds
lying around between calls you can also
create a third service that actually
shares this common data right that's
also another way to do it but then if
you have a lot of fan-out between
services it is probably not such a good
idea to have another call over the
network because you don't want data
redundancy right so another question
that you might have is coming from a
relational background so what's up with
referential integrity and micro services
right and well I think it's the same
thing I think you should regard it as a
spoon because referential integrity and
implies that you have a bigger domain
model which you probably share among
multiple services and now this is a
no-go in micro in the micro services
world so if you really want to have
referential integrity you just move it
up a little bit into the application
layer and that's where we have this
notion of bounded context right where we
where we cut our big domain model into
smaller parts and there might be some
services that well understand a little
bit about each other's interfacing about
each other's don't domain model because
they live in the same bounded context
but then service in another context they
have no clue what the domain model of
the other services is right so you
usually don't have referential integrity
between those services right so you have
the things about if to think of other
things of dealing with it now when it
comes to interacting with services we
have a question of synchronous versus
asynchronous and we touched upon this a
little bit when we talked about
programming models right and usually
with the model it's most communication
is probably synchronous right unless you
needed to do some asynchronous
and we usually usually be a little bit
of messaging for it and so when cutting
up a monolith into smaller pieces you
will probably be tempted to change that
synchronous interface into a more
asynchronous approach right so
rethinking your interaction patterns
between parts of the monolith and
between services is really important now
I'm not claiming here that you can't do
asynchronous model with micro services I
mean it's perfectly acceptable you can
do synchronous but probably when you
when your amount of services start to
grow I think there will be a separation
between some services which will have
synchronous interaction and maybe the
ones that are being called from a user
interface for example right or through
an API gateway or but the ones which are
mostly at the top of your architecture
and then the services further down in
your organization they and well they
need to deal with really fast fan-out
calls this day will probably have an
asynchronous interface right so you
probably end up with having both
synchronous and asynchronous
communication right so service
communication is a really interesting
topic so when you think about that then
you see that most people talk about well
we create rest services for everything
so when they talk about micro services
they talk about the rest services right
and there's not so much wrong with rest
right but the thing is it is built on
top of an HTTP stack right and if you
think about it HTTP has a lot of
overhand right so if you need to do a
lot of fan-out calls and the amount of
time is short right then
rest might be a little bit of a burden
because a lots of marshaling involved
and also the HTTP protocol is not really
really efficient it's so you will also
be tempted to switch from more rest
based services over time to different
kinds of communication protocols so
maybe you want to switch to binary
asynchronous protocol so the the the
sort of same thing here
further down in the architecture you
might be tempted to switch to binary
asynchronous protocols to messaging for
example right to zero latency messaging
and there's lots of interesting
protocols
which also come out of the IOT space
which can be used for this to have low
latency and messaging between services
and then services which reside more on
the top of your architectural landscape
which are probably the services which
will be called from a PID a tracer from
user interfaces right and there you
might still want to do rest because it
really integrates well with for example
front-end frameworks like angular and
other frameworks right alright so moving
on to the next subject here and it's
about avoiding reuse traps now reuse
just like some of the other stuff which
I have been showing is also a form of
coupling right and coming from a Java
background myself and I see that in the
Java world we have lots of people
suffering from abstraction disease right
so it doesn't take long in any projects
when someone comes up and say well I've
created this abstract template generator
thingy and it's really cool you should
use it right because well I need to type
this service thing twice now and I
thought it was time for an abstract
implementation
okay so with microservices reuse is
another spoon right and reuse is not
really acceptable because if you start
reusing stuff in services you are tying
them together so if you really really
have to then make it binary dependencies
right but don't have services reuse
source code of other services right so
couple them together in a version
control system right if you really have
to and you want to save yourself the
typing of the first 15 lines of code
when you start building a new service
right you just copy the code once and
then you never loop back
so there's other ways of sharing stuff
with micro services and one thing that a
lot of companies do is they start an
internal open source policy right so
they open source all of their micro
services internally so different teams
working on different services can learn
how other teams have
solve certain problems right so they
don't make a dependency by linking to
that exact codes but it is okay to copy
the codes and then make it your own in
your own service ID because we don't
want to mix the source code of multiple
services and base it off of one piece of
code right so if you really have to do
dependencies between services make them
binary dependencies version them and put
them somewhere in a repository where you
can use them binary and probably first
it as well so the thing here is that is
better to fav for some conventions over
abstractions right and the same thing
goes with technology because they say
about micro serve as well and then one
of the nice things about micro services
is that you can build each and every
service with a different technology
stack that's true well in the end if you
have a couple hundred services and
they're all built with different
technology stacks right you're in for a
nightmare because a few years from now
or maybe even a few months from now
you've still got to have all the
brainpower in the house to be able to
maintain them right and this might give
you a hard time so so some shops and I
think Netflix also is an excellent
example here is they said or they said
originally well we are a Java shop so
let's take the Java that's our
convention right let's start building
our micro services in Java first and
then when we really figure out that for
some services it's not fast enough right
or we need something else okay then we
switch to another implementation right
but that should be conventions instead
of you know giving everyone the freedom
to to carry whatever they want into the
organization and builds all kinds of
things
Trillian and into containers nobody sees
what you actually doing and then and
then throw it into deploy any into your
deployments right so be careful with
that all right so the next thing I want
to talk about is Conway's law now every
self-respecting presentation about micro
services has they got at least one
reference to Conway's law right so I put
it up over here and I say well melting
Conway he made the observation already
back in the 60s that organisations would
produce systems are constrained to
produce
designs which are copies of the
communication structures of these
organizations meaning that if we build
multiple systems in our landscape right
there needs to be parts in our
organization that corresponds in terms
of ownership for example to these
systems now if we no longer have systems
in our landscape but we cut everything
up into really small pieces we still
need those communicating structures so
if we have a service in our landscape we
need to have something in our in the
organizational part right that
corresponds that really owns the service
and is responsible for it all right and
this means adjusting the architecture
with the organization right and this is
actually one of the hardest things to do
in micro services because it means you
cannot just download the latest tools
and frameworks and start developing
micro services right but it also means
that it requires organizational change
of some sort and in a way you can
compare it with agile right so when we
first started doing agile we made a
mistake of just doing agile inside of
our development projects right and the
business was not involved there was no
product owner right so the business
couldn't take ownership of it they had
no clue what we were doing and those
projects failed I think there is a
parallel to draw here with micro
services where if we forget to include
the organization in the transformation
towards a micro services architecture
right it will fill because we have no
sense of ownership and we have no idea
how these services can communicate with
each other and how we can change them
and most importantly when we can start
throwing services away because putting
services into production is one thing
but it's better to throw them away right
removing service is actually part of the
lifecycle of a micro service because
some services will only be there for a
short amount of time so you really need
to take them out of production and as as
well right so this is probably one of
the hardest things in doing micro
services in getting Conway's law right
now back in the days when I was involved
in in service oriented projects I used
something like this this is a really old
picture that I I use with my clients
which is I like to call it a
service-oriented adoption model or a
maturity model and it has a number of
levels right so I'm a Java programmer so
I start counting at zero right level 0
and then 1 2 3 and so all the way that
they entered at the top there is so I
utopia which probably no one ever
reached right and then how do you start
with service-oriented things well you
start really grassroots right so there's
one or two applications that start
developing a single web service and then
at some point these services start
communicating with each other but that's
just level 0 you start small baby steps
and then after a while right you
transition into the next level of
service orientation all right so there
will be multiple services services are
really focused on reused so they have a
coarse-grained interface right and
eventually you go to the point where you
really need something like an ESB and
once again I mean the architectural
pattern and all the products right and
then eventually you progress to all of
these stages until you end up in so I
utopia right and you cannot cut corners
here so that's also why it went wrong
when people started building those ESB
products because they thought they could
cut corners and I could immediately
launch themselves into a level 2 or
maybe level 3 of so I utopia right which
they never reached so and I think there
is there's a similarity here with micro
services like you should really start
small right and then slowly progress and
then you should really think about all
your stakeholders which not only
includes technology right it's DevOps
it's the business it's the organization
that should all tag along right so maybe
it's time to craft another adoption
model but then from then from where and
micro services alright so now that we
passed all these things we actually
survived our first round of mortal
combat with micro services right but
then they're still round two and we need
to be careful because we are still in
red pill world right so there's lots of
things that can go wrong and I will
promise you there will be blood
yes and the reason for this is that in a
micro service of style architecture
failure will always happen right it will
always happen because there is so many
moving parts right we have a completely
distributed architecture there's many
many services who do calls to other
services who do cause the water services
and if one of those services starts to
fill right they have oh it could easily
get really out of hand and then it's
good start go into cascading failures
and you could take half or the entire
landscape down right so this is and
that's a really dangerous situation
so what we are after here is something
that they call resilience right so all
our services should be able to be
resilient and deal with unexpected
situations right and unexpected
situations should be dealt with as if
they never happened right so maybe it's
a little bit like Visual Basic right on
arrow or resume right you remember that
smell that's what Microsoft's are about
so much so Microsoft was way ahead of
his time with Visual Basic probably
right so in the best case but our user
should never notice when a downstream
surface is down or multiple downstream
services are down so there should be all
kinds of tricks within our services
landscape to be able to deal with this
situation right and what we're dealing
or what we're after worst case is that
we have some form of graceful
degradation right so maybe some part of
the functionality will not be there but
then the user is still able to to
interact with our application and maybe
he cannot use some of the functionality
maybe there's no recommendation of
products on our websites right but all
of the other basic functionality is
still there all right so graceful
degradation actually key here so what we
should do is we should have a plan a
which is our happy flow right and then
we should also code a plan B
maybe even a Plan C for if things start
to fill further down the line and we
should be able to sense and smell if
something is off and if something is off
we should immediately switch from plan a
to plan B because you don't have seconds
to spare and you do a lot of thin out
calls right if each and every call is
gonna have a time out of multiple
seconds right then the user will quickly
say well this application is completely
unresponsive right and as they say on
the internet the competition is only one
click away right so this is dangerous
stuff so what we should do is we should
design for failure right so fill you're
dealing with failure is a design goal
right and if there's one thing that you
should definitely not do its cry for
human intervention with each and every
exception in your in your code right so
the best thing is probably never to call
for human intervention and try to solve
each and every error case on your own so
services need to have backup plans so if
you're the service responsible for a
product guitar a catalog or something
and you cannot reach your database for
some reason then you shouldn't have a
cache or something else a predefined
list of products from somewhere that you
can return for other services to just
keep on responding and keep on working
right and failure will happen all the
time in fact if you have a micro service
of landscape where nothing feels right
that's probably something wrong right
yeah so another thing to do in able to
enable designing for failure is you
should be able to fill as soon as
possible right so you should really
smell if something as often as soon as
you think something is off
even if it's not you should immediately
return an error or an exception so other
services which are dependent of you can
you know go for their plan B or their
plan C or or on a worst case for
graceful degradation right so fill
rattles rhythm later there's all sorts
of things that can help you in designing
for failure sometimes there are really
easy measures so for example if you do
horizontal clustering of your service
right so you have one functional piece
and you just deploy it 10 times then if
one of the ten instances feels you still
have nine others now of course if it's a
structural or functional error right it
won't probably won't take long for the
other nine to fill as well but it will
buy you some time right so a horizontal
clustering might buy you some time might
solve some of these problems but surely
not all of them so we have also more
sophisticated means for this and we call
them resilience patterns and we have
things like bulkheads and circuit
breakers and but it's also easier
mechanisms like caching for example if
you think of Amazon they have caching
all over the place right so if something
fails you just take it from the cache
right or just to do a very human thing
right
just retry retry might also be a way to
deal with failure I mean that's exactly
what I do if I type something on my
keyboard and I press Enter doesn't work
I type it again I press ENTER a little
harder and sometimes it works sometimes
it was right yeah oh and then there's
sort of things like messaging for
example so by by having loose coupling
for example you're just less prone to
having services with the same uptime
right so you're decoupling right so
decoupling actually key here all right
so now this is actually pretty
complicated stuff you really have to
think about this and it's it is way more
than just downloading the latest version
of a framework in this case history for
example it is really famous for having
one of these resilience patterns it's
cool stuff but by just throwing hystrix
into your application you are not
resilient right you really have to think
about all of the cases where you are
using it for and then you have to
protect these cases right all right
so some takeaways from the talk I think
the essence of a microservices style of
architecture is about structuring your
systems in a different way right so that
they are more likely to be able to deal
with business agility and bottom line is
that you want to have modularity right
so modularity is key here now modularity
is a word which is used a lot these days
right because of jigsaw and Java 9 etc
but by just having jigsaw and Java 9 you
don't have modularity right
you have modularity by design so you
should really think about it when you
start designing your software the other
thing is services are about separation
of concerns right so you're separating
it out it has single responsibility
right these are all good things in a way
you could say these are higher order
pieces of your architecture right and
micro services is one way to deal with
them but there's also other ways to go
for modularity and modularity just
starts at a clean design right so make
sure you don't tangle them that that
model is by just having a clear design
now in the end what you're after is
business agility through the use of
technology and not the other way around
so by using the technology you don't get
a microservices architecture right you
get a lot of garbage in so all of these
things are not bad things per se but
there's also other ways besides micro
services that you can do in order to
reach these things now downside here is
obviously everything comes at a price
right and with micro services the price
is high because as we've seen we are
raising the complexity bar right there's
a few things which are easy for example
you know getting the cross-cutting
concerns the outer architecture in in
place that's easy to do right you can
just download things like console or
zookeeper or whatever right and but
applying the architecture to the
organization and the organization to the
architecture that is much harder because
it requires some form of organizational
change and this just is something which
needs to grow organically and it just
takes time right this is not a matter of
throwing in a couple frameworks
this is a matter of really thinking
things true so in the end I strongly
advise you to keep on educating yourself
because micro services are still very
young style of architecture right and
there's a couple cases that we know
really well so we all know about Netflix
about Amazon right but is is your is
your company is your project are your
projects like Amazon or like Netflix
right so um keep your eye out for more
war stories as they start to appear both
positive and negative ones and whatever
you do don't don't be convinced by just
one vendor story a version of the story
because what they try to do is just sell
you the next micro-services fabric for
whatever right they are thinking about
it now they're building these products
right now so don't let history repeat
itself as with Sowa right and whatever
you do and i know it's difficult for
developers right because you really want
to use all of these new tools but don't
let the tools right order or the tools
and write on the back of the
micro-services hype really trump your
thoughts about this right because it's
all about designing and taking the
organization along right so and then
probably the most important point of the
whole presentation that I didn't did I
want to make on a final slide is that we
are not all Netflix or Amazon right so
if you pretend you are you will have all
their problems for free right even if
you have just two micro services and why
was that's actually the same as that we
had with Twitter and Facebook when we
had the big data and web skill hypes
like a few years ago we all thought we
were Twitter right but then when we
realize we've got all their problems for
free right we just were back to what we
actually are right so with that I like
to thank you for your attention
open
all right so there's a rerun of this
presentation tomorrow so you have any
friends co-workers we'd like to see it
good thing is I have practiced now right
so tomorrow can only be better yeah all
right</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>