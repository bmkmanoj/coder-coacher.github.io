<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Code Generation in the Java Compiler: Annotation Processors Do the Hard Work | Coder Coacher - Coaching Coders</title><meta content="Code Generation in the Java Compiler: Annotation Processors Do the Hard Work - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Code Generation in the Java Compiler: Annotation Processors Do the Hard Work</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xswPPwYPAFM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello welcome everybody to our
conference session 2013 cogeneration in
the Java compiler impatient processors
to the hard work so these are all
rejected for today we are going back
we'll introduce annotations on impatient
processors just trying to set some kind
of common ground we are going to learn
how to create a run on impatient
processors and how we can use them to
actually generate source code then we
are going to connect annotation
processors with all the generation and
genes that are probably best suited for
the task okay and we will also discuss
about integration with IDs and build
tools I have slides but most of the
presentation is actual demos like coding
so I want you to look at how this works
in reality and how it is to get it
working my name is Jorge Davao I am a
senior technical technology architect
from Accenture based out of Malaga in
Spain and besides some internal work I
also have an external block you also
have there my tutor hundred so if you
just want to connect have any kind of
questions related with these techniques
after the session I will be happy to to
help you
so why cogeneration ok that's first
thing we need to us and ensure that
probably many managers have said that
before is because ourselves developers
we are lazy people
ok but we are lacing the root sense
because what we want really is to not
repeat the same things who wants one
over again we just got to concentrate on
the things that are important the
complex stuff the things that are really
delivering value I mean our human
intellect can't really do a difference
and we don't want to just write the same
boilerplate code once all over again
of course there are many other reasons
like reduce sorry to standardize on code
patterns ensure that the code that you
were writing its complying with all
those practices and conventions and you
can name your own reasons for that but a
they are all around three things one is
productivity or personal productivity we
want to do our job in as less time as
possible
the second is of course quality because
we want our work is fit for purpose
meets our standards convention and it's
really delivering the functionality that
is supposed to be unpredictability
because we our clients perceive that we
are doing our job rather than our job
well in a predictable manner our
estimates are rights our plans are good
and there is no risk okay so these code
generation for example is one of the
many tools that we have in our tool belt
to help to help us to do that before
going into the actual contents of the
session there are two question have for
you the audience okay just trying to get
how much of this you you know so first
question is please raise your hands if
you are familiar with annotations
annotation types or even know how to
write them okay so mostly everyone in
the interim and the second question how
many you know what is an annotation
processor could actually point one of
them are actually even know what they
how to write them okay just a few okay
so that's nice this is the end up
following closely the objectives I
mentioned before so let's start very
quickly about annotations okay so most
of us know what annotation are they were
introduced and they have a language
first time in Java file and they are
surely speaking is just made a data
capabilities for the language so with
annotation we were able to add VIN
information to add configuration
properties to add compiler behavior and
also more advanced features like
dependence injection persistent mapping
things that traditionally requires
lengthy and separate XML files or just
plain properties files now we could add
them directly into the Java source code
so a few things just to refresh about
annotations the notations always appear
before the piece of code that they are
decorating the actual elements from the
language that you can enhance
sanitation has been growing with time so
at the beginning you could annotate
packages types variables constructors
but now since have 8 you are also able
to annotate generic type parameters and
also any kind of type views ok no it's
annotating a type but the usage I am
doing for a type in a specific statement
annotations can be grouped can be
repeated can be nested so they are
really powerful you can express a lot of
things with them
so with great power it came great
responsibility so please don't abuse
about that because if you start to nest
group repeat annotations you can have
the same kind of problems that we have
with regular code its own gradable
unmaintainable so use them wisely and
this is just a one-liner
an example of how rotations can mix
richly add meaning to our code so ok
document store is a map before Java 5 we
have a map of what I don't know how I
mean that's in it I don't know I need to
to look at the code then we have a 5 we
could start to enrich the meaning and we
could have things like okay I'm indexing
by string the string is the key and it
contains a list of documents so my
document store is just a number of list
of documents that I'm just storing by
key but if I not annotations I can
provide even much more concerned
information to that expression I can say
that the strings are not do not know and
they can have actually the compiler at
compile time verify that I am NOT adding
any new key oh I can say the lists are
supposed to be non-empty all the lists
should contain anything and all these
document objects whatever they are are
read-only so again the compiler for me
can verify that I'm not modifying the
documents or that I am actually adding
only lists that contain information so
annotations in Jos were lying with very
few effort
gives a lot of information to whatever
it is read in the source code without
needing to go deep into the into the
into the source code or even reading
Java Docs or other implementation
comments in just a very few lines or a
very few words you get as much
information as possible so again I'm
patients are really repower for unuseful
okay so what this is are just a couple
of example of annotations so we can have
annotations that just have the name of
annotation like a market like a marker
we can have annotations that contain
values in pairs so we have a name of a
property and the value and you have a
lot of different features that you can
use at your benefit so for example you
can have annotation with just one
element and you can omit it or you can
provide default value so if someone is
just calling an annotation which are
some of this attribute it just gets the
default value creating an annotation
type is really simple because an
annotation is just a specialized type of
interface so you us use the data chapter
and interface and you are creating an
annotation type annotation types
contains a number of methods that in the
context of annotations are called
attributes okay so they are what should
be our properties that we don't have so
you don't need to write gutters you
don't need to write setters okay this is
done automatically by a compiler so you
just define these attributes and you can
also place here the default values if
you wish one important thing these are
not regular classes we cannot add
anything in there specifically we can
only add
primitives and new types other
annotation types strings classes just
the object class and a race of any of
them so specifically we cannot add
object any object which means that we
cannot add a rice of rice because an
array is an object okay but formal
situation this should be good I mean if
you need something more complex you
probably need another annotation to
press the extra information okay and try
not to make them so complex annotations
when you're creating a type you can also
have a notation themselves and they this
annotations are special they are
specified by the by the Java language
specification and they have been into
these annotation types specifically we
want to mention two one is retention
which specifies at which point the
annotations are removed from there from
the access of the of the user so if they
are behalf retention source they are
accessible while we are compiling but
they are not translated then into the
class file or you can use rotation
policy runtime which means that all this
information is carried over to the class
file and you can access them didn't draw
that okay and the target annotation can
be used to specify which elements which
purchase of the language we want this
annotation to apply in this case for
example to annotation types and types
only good so now let's go to annotation
processors so all these things are cool
but they will really need it I mean we
could add this kind of metadata thing
before Java 5 with Java Docs
ok so probably you've seen Java Docs
like that a lot of time out for version
deprecated and you could add your duck
legs so you could have more and more
information to Java Docs so this was
really needed the answer is yes because
this first annotations are really
first-class citizens of the Java
language they are formalized in the
general language specification and but
more importantly they an accessible or
they can be accessible during runtime
something that you can have with Java
Docs and you don't need to format parts
anything around the Java Docs because
it's they are very formal parts of the
specification so the compiler
already do all the work for you to
access the values of annotations at
runtime you can use methods like this in
the class class get annotations get a
notation by type or get the gate
if you just want to look at the things
that are actually in this class and not
in other classes in the hierarchy okay
so these two methods give you all the
rotations from the class and other
classes in the hierarchy like the
superclass interfaces etc while the
Clair annotations only gives you the
information about your source code and
and this is really the important truth
in around annotation processors and we
in what really makes a difference
between what we could do before there
are five is that you can trigger your
own custom actions at compile time using
the annotation processor
so in short an annotation processor is a
piece of code that is going to react
when an annotation is found okay when
the annotations annotation processor
were first introduced in jail five
really the API to access this
information and manipulate the the code
was not a standardized okay so there
were a comments and oatmeal or packages
so it was not good I mean kondo-san is
bad okay really not bad but you know
they are really internal implementation
classes they can't change any time so
this was procedure this was really not
good
so in the other six there was a Java a
specification request so it this API did
the way that you can interact with
annotations and do things were
standardized and now we have our Java X
dot lab dot language dot model packages
that contains the way to interact with
with source code and more importantly in
the other five to do something with
annotations you needed a separate two
apt sanitation processing too so you
have jealousy to compile the code and
then apt to do whatever rest it was
really not a good idea just to have two
separate steps when you are doing your
your build
it added complexity and if you forget to
do apt to probably our mission important
things so with Java 6 apt although it
was still available just for one word
compatibility all the process was
included into jealousy
so you just issue a jealousy common and
everything is that
and now since Java 8 apt to have swing
completely remove okay so it got
duplicative in Java 6 and now Jay Wright
is no longer into the JDK okay so yes
half your jealousy tool for whatever you
need okay so you want to write my own
annotation processor so it's really
simple okay
so too long didn't read yes extend Java
X dot annotation that processing dot
that's the processor class and implement
the process method that's the sure
recipe it's just a method that this is
going to be executed by the Java
compiler when the notation is found in
the source code so this is an example so
you might imagine this annotation side
is a complexity annotation it's
something that we want to put in our
code to flag how complex a class or a
type is just very simple stuff the
annotation processor there's very simple
relation processor needs to tell ok
compiler I'm going to handle this
annotation this annotation is this one
this type and I also tell the compiler
that I am incapable of handling source
code up to personate see it's always the
maximum level that you can handle and
this is important because new versions
of the language may have different
things different construct that you are
probably not aware of
lambda I can have a very nice piece of
annotation processor in Java 7 but it
does not know anything about lambdas so
potentially if I just take this piece of
code and execute it I'm doing wrong
things so I always need to specify the
Java compiler that I'm capable of
handling code up to this person ok in
this case up to version 8 is fine and I
just implement the process method okay
so this return true is important because
it tells the compiler that I actually
handle it the annotation
I do anything with it and you can see
well but why I need to do that
I already told
by now but you need to think that you
may have multiple annotation processors
actually doing something with the same
annotation it's any of you familiar with
jba there are persistent API and you
know that there's a lot of things or a
lot of different uh nations like column
like table like persistent initial you
have a lot of different annotations and
you can think that different portions of
code may need to react to different of
to some of them and probably this
different portion of the code we need to
react to the same one which means that
in any case I need to tell the compiler
I'm finished this annotation don't need
more processing and the actual will
react and the compiler will react
another very important thing to know
about processors when you are creating
them is that all this process happens in
rounds so you are compiling a lot of
source code and maybe most surely you
cannot compile every single class at the
same time you need to start with off
classes without dependencies then you
can process in a second round all those
classes that have dependencies in the
first one then the third one on the
second the first you know what I mean oh
so you start with all things that don't
have dependencies or that you can
compile the things that depend on them
so all this process happening rounds in
each around a subset of the source code
is compiled and after this is very very
important after it is compiled then the
annotation processors are executed ok
the processing will end when there are
no more sources pending to compile ok so
if you have one simple project with one
class it will just happen in one round
but you have more and more classes that
they depend one on the another do you
will start to have even 20 30 40 rounds
ok so the compiler work that way a
processor may also claim all annotations
with a real card so you can actually
here
place a vodka this is very powerful you
can have an annotation processors that
intercept pretty thing that is being
compiled and two things with it okay
very fine having some kind of
instrumentation code whatever you need
and the process method have two
parameters that we can assume we can use
in our own benefit so first one it's a
set of type elements that tell us which
annotations are being processing that
run which means a process some circle i
found out these annotations so i let you
know because probably you need to do
something if there are other notation
presence in this source code and the
second parameter just give us
information about the covering and the
previous round which classes has been
compiled etc okay another thing that we
can use in our benefit when you extend
the abstract processor class you have
access to our instance variable the
piece of tied processing element
precision environment give us access to
a different number of specialized tools
one of them is the messager which is a
login to but the kulfi industry of this
logger is that is specialized and you
can connect each message to the actual
element in the source code that you are
processing which means that you don't
not only have a number of locks in there
you also know in which pieces of the
source code they were trigger and we
will know after doing the demos how
useful it is and and this is really the
cool part of both of these we can or we
have also access to the filler utility
which is passive so for name just allows
us to create files in a compiled in a
compiler friendly manner if you use file
and in Java dot IO dot file
you need to specify where the files are
going to be placed and if you are
compiling source code you actually don't
have to know where the source code is so
filer knows so you just need to give a
fully qualified name of a class um the
finder would actually place that file in
the correct folder okay and if you know
a bit about Java C you know that you can
express if I in which study English
sorry which folder you can place the
compiled code or the new code so that's
very useful because you don't need to
mess around directories permissions etc
the final route ility do it for you even
better if you have a deep type hierarchy
the final utility will create all the
needed subdirectories and will place the
file in depth in the correct place so
you just forget about all that
complexity I want to create this class
file or this java source file and it
will do ok so this is very useful and
it's really the moment in which we can
connect the things that we've been
looking in the source code and in
annotations and actually do something
create code create new classes that were
not there before
ok so now we have an addition we have an
addition profit processor that tells the
compiler which typing is howling but how
I tell the compiler ok these are the
processors you have available
ok then different ways of doing that uh
probably the easiest and/or the message
straightforward is just to leverage a
standard services mechanism in Java
which is pack your annotation processors
in a jar file and include this file in
meta and folder services so folder which
is where all the services are indexing
create a file with this name which is
actually the name of the interface and
then you just place all your types one
by line ok so this is a really standard
services discovery mechanism this is
using for example for XML parsing for
the
security processing etc I mean there are
a lot of different services in the JDK
that you work with it within play sorry
with the interfaces and the actual
implementations are found during the
boot up of the Java Virtual Machine just
look into these files okay so now we
have the complete picture we know how we
can create the the annotation processor
and tell the compiler to do something
now we need to find out what to do with
it okay but we before going into the
actual demos and showing you how to do
this this stuff I just wanted to stop a
bit about how to run validation
processors because we've just briefly
mentioned about it been interactive in
jealousy but there are a few other
fields that I want to share with you
okay so with jealousy is really seed you
don't need to do anything just jealousy
and that and you're done but you can add
a few refinements if you need first is
that you can specify a different class
path for annotation processing than for
regular compilation I would say that
need 95 I mean 99% of times you don't
need to do that but there may be cases
in which your actual code depends on
let's say Commons collection wat zero
but your generation engine needs
collection tree and you cannot mix both
of them during the same process so you
can keep both class paths separate okay
I'm not saying it's not combination re
but you can do it if you need the same
that you can place or joka you can tell
the the desire compiler world to place
the generated class files you can also
ask it to place the generated sources
whatever they are in a different folder
and this is realized practice because
usually related sources you don't want
it to put it in version control so you
want to have them in a different folder
okay so they don't mess with version
control system etc okay and another two
things that you can do with Java with
jealousy is to add these two extra
parameters that are going to give you
more information in the console
what's happening it's very useful to
know about the rounds which classes are
being compiled etcetera this is actually
not specific to this one is not a
specific about annotation processors
because compilation also course in
rounds but it's very useful when you are
at a book in your your processor okay
next Apache maven brilli nothing that
you need to do because you are already
leveraging Java C and Java seduced to do
all the work for yourself you don't need
to have anything else in the past you
just you needed to have a specified
special goal to call apt but now it's
not needed so what do you need to do
well some a few plication so if you are
just compiling annotation types nothing
nothing special
they are just Java types if you are
completing the annotation processors
although in many cases will not happen
anything it's usually good practice to
add the proc known argument to the
compiler
so actually you tell the compiler I am
going to compile an annotation
processors don't do annotation
processing okay it could be awful so you
can you can do it but it could lead to
in predictable result sometimes so it's
better to just disconnect it and when
you are compiling the actual artifacts
that make use of these annotations of
course you need to add this add as
dependencies which is logical and you
can also add the extra parameters if you
wish okay that's really nothing of this
is required okay in many cases is will
happen just fine out of the box so if
this is perfectly integrated with Java C
and there is nothing really special I
need to do with maven what these are
some examples I will show you later so a
goes a as I was saying if this is really
well integrated with Java Sea and there
is nothing really special I need to do
with maven or with rather for example
you can they look that there is really
nothing that I need to do to make this
in a continuous integration engine
Jenkins Travis team city whatever it is
because you have your maven jobs and
you're relying on maven which actually
relation Java C to make the build so it
just work out of the box you don't need
to do anything extra
as mentioned before you can add some
parameters you can fine-tune things but
you don't need really know you are not
required to do anything else so if you
are creating a job in Jenkins you don't
need to add an extra step or whatever it
just happens which is very convenient
and the IDS do they react well to the
annotation procession yes please yes all
the three major IDs and all the
derivatives works perfectly fine with
annotation processors there are some
differences or some of them will allow
you to fine-tune the class path some
other will let you deactivate or
annotation processing or some specific
processor but really all the important
things are there in the question of the
tips you can enable annotation
processing or leave it disabled during
the full bill or you can just enable it
automatically while you are typing which
is very useful just step in save your
type and annotation process what happens
okay you can configure the options if
you need them you can configure
different target folders if you want to
override the defaults or you can even
configure the class path if you need to
add something especially for example if
you are importing million project you
will not need to do these things but you
can control everything
integration of NetBeans a and in the
case of non main projects because when
you import a maven project in in
NetBeans everything it's just using
maven so there is nothing especially in
the IDE no configuration that there is
no matter that metadata directory
created by NetBeans is just moving but
if it is not mailing you can also
control all these things like enable IP
sorry yes yes okay so again enable IP so
I can be simply fine in it
and configure a number of other things
one cool thing about a
that means if the is that it allows not
only to enable disable annotation
processing you can also enable
individual ones so it's cool if you are
just doing the beginning and you have a
large number of annotation processors
you can just enable those that you want
okay and in the case of IntelliJ IDEA
pretty much the same okay again if you
are just important and maybe module all
the configuration is discovered for you
and that you can fine tune if needed or
if you are just creating an animated
model you can just a configure there
okay so again class paths the name of
annotation processor if you can specify
some some of them etc okay so cool so
now we have a very powerful tool and
let's do something useful with it
yes yeah the question is if an
annotation processing enabled by default
the answer is yes okay if you just
execute jealousy automatically Gela the
Java compiler is going to find out all
the processors that are there in the
class path and use them okay if you want
to disable annotation processing you
just add a block known parameter to the
java c command line okay sorry yeah
absolutely I'm going to that part okay
okay so what we have here is a
meaningful annotation the you know what
are being enforced some of them some of
you know okay well in short I mean in
for class is a special type of Java
class that contains information about a
Java Bean what's that
imagine that you can use Java beans in
visual editors for example so it
contains properties it contains events
it contain properties and the visual
editor gives you more information about
the things that you are doing but you
cannot add them in in a regular Java
Bean so there is a separate class okay
that contains this metadata information
okay so this is something that comes
from the body always of of suing under
your foundation classes okay but it's
useful okay if you are using visual
editors so I don't want to create being
enforced it's really really a very long
road from task because you basically
have an interface as you need to create
to provide a lot of information in terms
of methods descriptors property
descriptors even the script owes and its
really really lengthy and it does not
give any value the value is this
property and explanation the description
of the property so it will be deal if
when this was born annotation world
there but it didn't happen that way okay
so at that moment engineers of Santa
they decided to provide this X they this
been in for a mechanism okay but ensured
I don't want really to mess with this
color
kind of classes I don't want to create
them so I'm going to create a tool to
handle them for me so I create in the
meaningful class
they've been in fermentation so Avenue
for us for attributes the description
that tells me something more about this
property or this method I need to know
more than just the name and 3 billions
one expert I am telling the visual
editor whether this is an expert or or
just regular property this is usually
done to put perfume - to put the VX /
properties at the bottom of the editor
because they are not for for you know
regular users many times they are just
given by default the second one hidden
is what it's obvious just hits the
property in a visual editor that the
property is there I mean it's a Java
Bean so you can get and set the value
but the visual editor will not show it
because it does not give you another one
you with a lot of information and the
fourth one is prefer whether it is a
prefer property or not typically the
preferred properties are highlighted
some some way they are put at the
beginning or whatever we will show okay
so this is a rotation so it's cool
because now when I create my article
beam I can just play some bidding for
rotations in it okay for the moment I'm
not going to give any extra information
just the meaning for notations I want to
know what I can do with it
so what I did next is to create my linen
for processor I tell the compiler that
this is going to handle the meaningful
annotation I've just created and then I
implement the the processor method I'm
going to come here okay so I started
with the process method I get
information about which sources are
going to be processed and for each of
them
want to know whether it is annotated
with been info class or not because if
this something that is being compiled
during this round but it's not annotated
I have nothing to do with it okay the
second thing I'm going to do is to check
if it is a class it could be a class it
could be a method because I'm annotating
methods properties so if it is a class I
need to extract something from some some
information I need to then generate
source code for example which is the
name of the class which is the package I
am going to place them in info in the
same package and I'm going to take the
class name and add a suffix been info so
it's much the specification of the
winning four so that's cool then I lock
something okay I'm just processing this
a type and next I use the filer
interface to create the source file
which is cool I just have my file
created and now I need to place
something in it and now it's when the
things come and you know because if I
yes even if I'm trying to keep my clean
code and with low complexity the fact is
that I'm starting to do things like this
and this is not a scalable this that's
not a scale even for the simplest of the
types that I want to generate just start
writing lines and lines and lines this
not works okay in this case this this
generator is actually working I mean it
gives me this automatically generated
been info class but look it's really
simple I'm not doing anything just and a
skeleton I'm not reading any information
and put it in the in the in the
generator of course but the generator is
already very complex because I need to
just keep printing lines printing lines
printers lives this is really not a very
good way of doing things so why we don't
take an existing generation 10 engine
and plug it in do you know which is a
patch of velocity some of your say yes
with ok and some hands the particular
cities yessir a template engine I define
a template with some
language in it which is very familiar
like if for if-else and you can control
the aspect of the things that you are
generating it's much much easier to know
what you are writing so I'm going to
show you a template going back here and
I'm going to show you an example of
Avenue template as you can see it's
pretty much just source code because I'm
generating a class of course and I'm
placing some special marks with dollar
where I am passing information into the
velocity engine so it could be a map it
could be at least it could be any Java
object I can put any Java object in
there and velocity will find the Gator
will find the names and will use this
information here but as I said before
I've been info has a lot of information
information about the class you can see
here or information about the properties
that this Bonifas
ok so I can use a four so even velocity
it's very simple to create much richer
code generators and you can scale it
more easier so if you need to create two
three four classes you just take an
existing class that you have hung around
right now and then it start to place the
different marks that you need to replace
with the actual contents of the code
usually really the complexity of this is
- no actually what to renovate to
generate not really the mechanism which
you see you can see it's really racing
ok so let's see this in in action
ok so if you are here my annotation my
processor and I have here an article
class ok this one which is actually here
this contains more information ok so I
have here a description for the property
description for this other property so
at this moment if I just force a
compilation of this source code ok I'm
not sure what's happening today but it's
not working here okay not a problem
just demo effect but I am going to show
you in a in mail any NetBeans ok say
have here they they they actual being
that I'm using two units of course so I
am making some change here for example
this is the updated property okay so I'm
not yes forcing the debil okay will
project and I can see here that the
console of what's happening okay so good
so good things to to note so we we we
have here the rounds of going to magnify
this okay so first the compiler is going
to compile the article class and it
founds a belief a notation in it so what
it does next is to execute the processor
meaningful processor okay it just found
that you have it in in the class path
okay and it's very interesting because
as I'm generating a new source code I
need to trigger another competition and
this is round two completing the
compilation of article beam info okay
it's another class so it needs to be
compiled okay um if there were more you
will have here more rounds or more
rounds happening okay but we have only
these two the result is that we have the
article meaningful created for us and
actor it contains to show this to the
right of it
have you seen I've just modify the
description of the property and now I
have here in the generated code okay
just directly I am not don't need to do
anything because it's already working
with a compiler but moreover if I came
here I'm going to the civil magnifier I
just take a J fry as a frame with shrink
and I'm going to use my article being to
do something with this issue interface
when I click here in the wind I shall
hear my three proper properties but
hello okay it is also showing the extra
information that I created so you can
see this is just an example with having
info read on the focus too much on the
example one focus only on the fact that
I just have code I just have an
annotation processor the source code
that I need is created and it just works
in this case is just a Java Bean and I
have it there okay
in the in in the same moment I want to
show you something cool because if I not
take any of these properties I modify it
so it is I prefer for example here okay
and we just build again okay any I need
to close this select the class path cost
code refreshed if I open again the frame
and I go to the property sorry select
the devine and click on the property you
can see that the preferred properties in
the NetBeans IDE etre are place at the
beginning which is cool I mean my
preferred properties at the beginning
but so again I just change the code and
everything's happen automatically
I don't need to to care about that okay
okay I'm going to show you another
example which is a bit more elaborate so
in this case it's about entities so what
this is about is that I have my typical
Java beans with all the letters and all
the setters and I'm really tired of
writing all the contents of getters and
setters okay and you can say okay but
you can create them with the ID yes but
I need to create them and if they if I
then add three more properties I need to
go back and generate the three more
irani and they probably don't have the
Java Docs I like or the format I like so
it's really something that the service I
don't want them to create
to be created what's really important in
a javabean I mean while we don't have in
Java in the concept of a property the
name of the property the type of the
property so what I need really to
express just the interface no so if I if
I had just an interface with the getters
and the setters and I somehow could
create yes everything else for me that
won't been effect because I just need an
interface
I don't need really to create an
implementation of a deriving every
single time so that's what I've done
with a generation processor in this case
I'm using the generate entity annotation
type and I yes annotate my type and I
can also use this to identify which
fields are part of the key so in this
case the ID field and I'm going another
step ahead and I also want to generate
my data access classes I don't want to
generate all the time they select insert
update delete methods I don't want their
we could say most of them they are the
same when one is different at that
access object when you have your own
queries so I just want to create an
interface with the queries I need and
everything else is generated for me okay
so that's what I do using a velocity
again as I said before really using
directly a hand-cranked imprint lining
all the contents of a file it's really
not a good way of doing this so this is
an example of method access a template
so you can create the insert methods
using JPA
I can create my update method what are
the things that are different the name
of the entities the name of the fields
for example the name of the columns this
kind of things or for example the entity
template okay so here there are a bit of
more intelligence here so for example
I'm just applying by default and upper
case to the entity name and I should
that as the table name so here that the
generator can be as complex as you wish
so if you want your inator to allow the
possibility to have a different that are
stable you can
another property and it's a default
property sorry it's a it's an optional
property in your annotation tag so you
can add the complexity as you go ok so
what's happening when I generate this so
I have my interface alligators and
setters and I have my data access that
only has the extra query that I need
well the results is that I have these
two generated generated types and you
can see they are a full entity they have
all the things I need okay so like the
the entity annotation the table
annotation they ID'd the column
annotation everything I need and of
course all the contents of their Gators
and setters I could I could add here to
string equals hash code whatever I need
okay
I've not done it to not to not add too
much complexity for the demo just to
show you ASCII things but you can have
it I mean you can have your generators
be as compressed as you need it and for
example there are taxes okay so I have
my Selleck by ID and as if you came to
think as I told the compiler watch which
feel is the ID he knows he can generate
the right the right field sorry the
right method with the right class etc
insert update delete okay
the only thing that I've not done is to
create the code for the custom query but
I have the custom query I mean it's
contained in the indiana tations okay
yeah and that's a very good question a
and in this case the ID is react
differently in the case of Eclipse if I
try to do something it was me okay this
is a generated file are you sure that
you want to modify it because I'm going
to overwrite it anyway you can do it and
this is very useful when you're creating
the code generators because I mean you
are creating a velocity template or any
other technology and you can make
mistakes and syntax or whatever so it's
very useful to come here and tell
eclipse okay I'm going to modify it
manually find out what's wrong and then
take the corrected file back into the
template it's a very nice mechanism to
add new functionality back into the
templates you can take actual CRO that I
could just hand crank and it's perfectly
it's well proven and take it back into
the templates okay but by default it
wants you in it's also placed in a
different folder it's not on the under
version control so in most case it
should be okay okay the other idea is in
this case NetBeans and IntelliJ that's
not to warn you in any money okay so you
should be more careful about what you
are doing okay
so I can show you here for example with
with IntelliJ I can check the the
modified file and start doing things
okay it does not watch me any money but
the fact is I it's going to be
overwriting the next time the
compilation triggers okay ah yeah now
it's there okay okay now cool
okay so the the question let me refresh
it so to see if I understand is you can
modify something that has already been
generated it's that what you
hmm
okay good question it's not going too
well right the source file because it's
already it's in different folder but you
are going to have just one class file
okay so the generated class file is
going to be right the generated the
first compiled file okay because the the
annotation processing always happen
after the compilation you can do it I
mean you can add into your annotation
processor before creating the Java file
object check if it is success or not
okay question other Java objects good
question a really yes but you cannot
control it because as compilation
happens in rounds you actually cannot
know what you're designing a processor
which classes are going to be there
because if you introduce some dependency
it's going to be done in a later round
so all in theory yes you can access and
the second element the the run
environment a parameter in the in the
process map of gives you information
about which other classes are being
compiled you cannot control which of
them are there in those cases they would
practice is okay I need to do something
cross class so I am going to pick
information here pick information here
pick information here any processor will
know what when I have all the
information I need I generate the code
so you can have some information from
round one some information from round
two some information for round three and
then I check okay now I am complete and
now I can generate self code okay but
you need to pay a bit more attention to
the to your processor logic to know that
you actually have all the information
you need so for example I put the
example of JP a so you may have
information about columns here but this
type has another type and you need to
know if this is one too many or not so
you need to wait for the other side to
be there to extract information okay so
in this case the processor is a bit more
complex because it needs to react to
something that happens
crowd question yeah yeah this is all
happening the same process so whichever
beans
whichever objects I'm just saving their
and that they are in memory so in the
second round I have also access so
typically the your generator may have
some static feel or whatever so you have
access to that okay it is not well
specified in in specification I think
it's a bit doubtful but it seems to work
like a single tone in that case I mean
that rotation process is just one
instance okay yes I mean processing the
question is whether you can actually
instant in classes that has been
compiled okay you cannot do it directly
because they do not exist in the
annotation processor class path but you
can use a reflection do you know which
classes are being compiled and they are
there do you have the back dot class
files so you can use reflection to
actually get them you can use reflection
to get the annotations in these other
classes and get the values back from it
so you can do a lot of things actually
and and this is something that I say for
just for this case of more advanced
questions even if you need it you can
take the dot class files and extract the
byte codes and do things I mean this is
really advanced it's not so simple just
as creating an empty file and put things
in it but you can do all this kind of
tricks and actually there are many
popular libraries that do that so
probably some of you know or probably
Lombok or allow data nucleus so you
cannot also only create new source files
you can also get something that already
exists and do things with it
for example instrumentation in in code
coverage tools that a nucleus is an HR
system a library that enhance your
classes which enhance means and adding
all the boilerplate that you don't need
to write or Lombok which is a library
that creates getters and setters for you
there are main methods they are
riah bands so you have not for afraid of
her so you need to really be a a system
developer for that but you don't do
really a lot of things I mean just
trying to show you the very basis of the
technique and how you can create the
files and you can do anything that you
can imagine how that no you sure about
the question you mean which is the order
of the of the oh yeah yeah the order is
always first compilation and then
processor which means that what you are
processing the annotations found in a
class the class is already compiled
which means that you cannot modify the
source file of course you cannot take an
existing thought you have a file a
modify it but you can take the existing
dot class file and do things with it if
you need it load the class file and
those things with a write code different
libraries take different approaches so
for example with ASM CG leaf you need to
know a lot about my codes in the case of
Lombok it uses the actual compiled
compiler API and you need to traverse
all the abstract syntax tree or your
class to do things like nodes method
node contains one or more parameter
nodes etc etc so it's it's really
complex or I would say it's it's lengthy
it's not immediate to do this kind of
operations but they will part is that if
you need it and you need these advances
use cases you can you can do them ok to
show you for example this one this is a
a piece of of the Gator generator in
Lombok just to generate a getter it's
quite complex because you need to put
all the byte codes etc so you have to
dare they the an example of this of this
source code ok it's not immediate but
you can do it but well it's true is that
is that generating new sources or for
example generating configuration files
it's real easy releasing and you can do
it right now you need just to create the
process
the main different engine is that
aspects happen at one time okay
while this is so happening in the
compiler one of the good things that
happens in the compiler is that you
don't need a specialized tools to handle
the aspects for you that may interfere
with other things because the classes
are there they are in a different folder
but I don't care the idea reacts to them
I mean I come to here they can't come
here any place for example article and I
could if I if I wish I could do this
yeah this is not a good place okay now
that it's not hearing there in the
classpath okay no no I don't find that I
don't have the example ready but you can
do it I mean there is a class that
exists you have seen the example with a
client frame I'm just painting a string
frame and I can use the beam
implementation is there I can I can use
it okay with aspects you need to rely on
within tools that may or may not work
for you or you need to wait at runtime
to see if this all really plugs together
okay so I think we are a over the time
we have two minutes for more questions
if you have
okay hmm
it is not I mean there is nothing that
it's added by default you can use you
can add it I mean it's something that
you can put in your templates on in your
generated code and have it there but the
good part is that you really don't need
it but because the eyelets reacts for
you you have a different folder and the
companies know that is today the
derivative I'll so they are not really
created by you just this a I all these
examples are I'm the wreck I will put it
in a in McDonald block and they are also
github okay so you want to take a lot of
day of the URL is de o RS dot workplace
comma there you can find the examples
and under other slides
well the slides are not already there
I'm going to put them up examples are
there and also in India top okay any
other questions sorry
no no no I am not familiar with it but I
think the question is because it's a
template engine something that you can
use to create templates okay yeah you
can plug it you can you can important
you don't plug it I mean I've shown here
an example with velocity but you kind of
finally for example if you prefer
assembly even in theory if you I've not
tried because it's difficult you can use
even the clips java emitter templates
but you need to have an OSD i run time
to run the generator so it easily takes
a lot more time so it's probably not
this idea for because it's pretty much
the same that velocity okay okay
so now we are added about the agua so
that's all for my site if you have any
further questions or comments or
whatever i'm open to discuss now or
later or just by twitter or whatever
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>