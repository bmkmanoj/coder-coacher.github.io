<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Transforming Code to Java 8 | Coder Coacher - Coaching Coders</title><meta content="Transforming Code to Java 8 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Transforming Code to Java 8</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CeSoW83N4Y0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to the session on transforming
code to Java 8 my name is Venkat
Subramanyam we're gonna talk about
taking some code examples that we are
used to writing in older versions of
Java and we're gonna refactor it move it
over to Java 8 along the way learning
about certain reasons to do it and
certain things we will learn about
features in Java 8 along the way best
time to ask a question or make a comment
is when you have it so please don't wait
till the end any time is a great time
for questions comments raise your hand
draw my attention ask your questions
share your thoughts I would be delighted
to hear your voice here and your
thoughts as well so let's get started
one of the biggest change in Java 8 is
going to be in the minds of the
programmers we have to rewire the way we
write code in Java 8 and we're gonna go
from imperative style of programming to
more of a functional and decorative
style of programming so we're going to
talk a little bit about this and then
we'll start looking at code examples
I've got six examples I'm gonna go
through here and look at various ways to
transform the code so what is functional
style of programming the very first
thing in functional style is it is
declarative way of writing code a
declaration style of programming is
where we tell what to do and we don't
really spend overtime telling how to do
it we let the underlying library figure
out the details of how to do it so as a
result we are more intelligent when
communicating with the language or using
the language we are not burdened by
giving instructions at a lower level it
becomes a lot more easier very
expressive and and and and a higher
level of abstraction
we're gonna program with higher order
functions higher order functions are
functions that can receive other
functions as parameters we are used to
passing objects to functions returning
objects and functions and creating
objects within functions now we can pass
functions to functions create functions
within functions and return functions as
well we will honor immutability as much
as we can mutating variables is really a
poor programming practice bugs creep in
the more Mugler do we
in code the more bugs we have in code
the more mutability we have in code the
harder it is to understand the code the
more immunity have in code the harder it
is to make the code concurrent so the
NIT Sun of using immutability is a huge
net negative every bit of that comes and
hurts us and makes it really hard we
have done it for a long time but we have
suffered through it more than anything
else we're gonna use pure functions pure
functions or functions with no side
effect they receive some data do some
work and return results and they do not
go around and modify other objects or
they don't depend on objects that are
changing while they are running so that
there is a good stability as many times
as you call the function with exactly
the same input you will keep getting
exactly the same output this makes
testing those functions lot more easier
it becomes easier to resend those
functions it also becomes easy to prove
that correctness as well so these are
all very a comes from very strong
mathematical underpinning so why should
we care about doing all of these for a
number of reasons well as you're gonna
see here I'm not gonna use any slides
I'm gonna be showing some code and
working with it
if you are interested in not downloading
the code examples they are available on
my website you don't have to rush to
write this down the same link I will
post again towards the very end at the
bottom as well so you can take your
times note it down no rush
so what's the reason for this to be a
better practice the reason is the code
is going to be concise is there anybody
in this room who goes to work saying I'm
gonna write a lot of code today no not
really right in fact this is one thing
I've learned over the years the
difference between a novice and expert
programmer is the novice things he can
solve every problem by writing code and
the experts knows that he gets every
problem by writing code right so the
point really is hands down the code we
don't write has the fewest bugs and and
with experience you find ways not to
write code right so we gonna be writing
a lot less code which is actually good
the code is going to become a lot more
expressive expressive as in it becomes
easy to communicate your intent
it becomes very
transparent and of course because we
gonna have less code and expressive and
transparent it is easier to understand
once we get through the syntax of lambda
expressions and things like that
it's easier to modify that code because
it is very modular in nature unlike
human structured code we end up having
fewer bugs for reasons I mentioned
earlier and it's almost effortless to
paralyze and make it efficient well
that's all my talking is done let's go
ahead and take a look at some code and
start refactoring some examples and play
with it
like I said I'm gonna take six examples
here and play with it over the next
about 15 minutes or so so let's start
with our very first example code and
take a look at it so the very first code
I'm gonna start here is this write this
code here let's take a look at what this
code is doing first of all I've got a
class called sample in the main I've
created an executor service for creating
a pool of threads and I have a loop and
within the loop this should be very
familiar to you right why are you saying
final int index equal to I because I is
a mutable variable and we know that we
cannot access mutable variables inside
of you know this block so as a result
you had to assign it to a stupid
temporary variable so that you can come
back and access it right and anytime you
did this there are two people right once
who know why they are doing this and the
others they do it because they've been
threatened by the compiler right it's
like oh the compiler wants me to do it
why do you do it because it won't work
otherwise right so it feels like you go
to work to work for the compiler rather
than the compiler working for you right
and and so these the kind of things we
end up doing well thankfully in job
eight we don't have to do it because
Java has what's called effectively final
at least we don't have to put the word
final but we'll see better ways to do it
then what did we do we call the submit
mail executor service sent it a new
runnable provided the run method and
within that we are running some tasks we
are displaying the result and then when
we are done
we say task started and then we print
our first rule of refactoring code
you never refresh the code that doesn't
work so let's run it well at least do
some definition of work it's running so
it's time for us to refactor this but
before you factor we're
we go what are the things we're gonna
change notice we got about 20 lines of
code but if you look at this code there
is quite a bit of noise in this code as
well my first question to you can
somebody tell me what is this in Java
you call it anonymous inner class in
English you call it missed opportunity
because this was back in Java 1.1 they
could have done this in a better way
right and we were given anonymous inner
classes or rather than being lambda
expressions right what a sad story well
thankfully we can fix that so if you
look at this code I've highlighted this
is called ceremony right this is very
smelly most likely a code like this away
from the code right it's that smelly
well that's because you're doing a lot
of stuff in this code just to make the
language and the compiler syntax happy
so I'm gonna highlight this part of the
code and remove this particular part
that is purely smelly and I'm gonna then
put a little arrow that's the parameter
list of just empty and then I have this
function body which is the essence and
I'm gonna get rid of everything else
around it and we can see the code is
still working that's a very first step I
did is I threw away the anonymous inner
class and put in the lambda expression
so rule number one when was the submit
method of executor service created the
job of 1.5 in fact I could have used
thread dot new write to the new thread
new runnable ad that's Java 1.0 so here
is the beauty for code created as old as
Java 1.0 to that code you can pass
lambda expressions in Java 8 I love that
backward compatible capability right so
you can take very old API and you can
call them with lambda expressions the
only requirement is that those methods
take what are called single abstract
method interfaces but in Java we don't
call them single abstract method
interfaces we call them functional
interfaces so what is the functional
interface every interface already in
Java that has a single abstract method
is automatic
nicholae a functional interface in Java
8 so any function that receives a
functional interface now can't receive a
lambda expression so as a result we can
remove a lot of ceremony in code even
when using older API you don't have to
go around and force older API to evolve
they already are evolved and ready for
lambda expressions right so that is a
very big benefit now the other thing to
look at in this code is if you notice
what are we trying to do we are trying
to do this ten times now what is this
for loop doing
it's simply looping through for I equal
to zero I less than 10 this is a
terrible way to loop isn't it this is
2014 we should not be forced to use
loops like this right I mean every time
somebody writes a loop like this dot
kills a cat right there is no reason to
be doing this this is such evil code and
yet we have been writing code like this
right so what can we do about this well
we could essentially say that we want to
work off a range of values so when you
write code in Java 8 you want to
communicate with a lot more effective
vocabulary rather than saying take a
left take a right take a now you know
stop for a second instead you say hey
you know do this particular operation
right so you're focusing on an
abstraction to communicate a rather than
the small different different turns you
take so notice what I'm gonna do to
achieve that particular goal here so
first of all I'm gonna go ahead an
import over here Java util stream dot in
stream so in the stream is a
specialization of the stream and it's of
course the name indicates it's geared
towards integers but what I'm gonna
really do here is I'm gonna say in the
stream dot range and I'm gonna go from a
zero to a ten the range function is a
non-inclusive function it goes from 0 1
and so on up to a 9 and doesn't cover
over 10 there is also a range inclusive
if you want to include the value also so
now that you have the range of value
what's the next thing to do I'm gonna
say for each of the
you in that range I'm gonna say here's
an index that I'm receiving and I want
to do something for each of the value in
that index now notice we got that index
on our hand without having to go to that
ceremony of the for-loop that becomes a
lot easier so now I'm gonna grab this
part right here which is the insular
service code and I'm gonna simply go
back here and I'm going to simply
replace this part with the executor
service as you can see and say that
that's what I want to go ahead and carry
out and run as part of this executor
service so you can see the code still
works but you can see that this code is
a lot less noisy compared to the code we
had a minute ago when you look at this
code it actually is Pleasant you want to
read it the other one you want to take
it a string break right so the point is
that should be easy to look at code its
pleasant it's nice and it flows through
and you can logically walk through
rather than spinning your eyes through
the loop back and forth it becomes a lot
easier to work with and and so this is
essentially going through a stream which
produces a range of values and then for
every value in that range we are doing
this particular action in this case
dispatching the job to this so we did
two refactoring in this particular
example we went from the anonymous inner
class to the functional interface but we
also use the stream API to get the range
of values sounds reasonable so far
questions comments better bet it's
improvement or not no it's better right
absolutely it makes you feel happy isn't
it right that's what comes who cares but
anything else right so it feels better
and and so it's better to write code
like this excellent so we saw one
example the next thing I want to talk
about here is stream oh did we run this
make sure it's still running yeah okay
so the next example I want to talk about
here is going to be about using yet
another feature that we're going to use
which is about iterations let's
understand the code first of all before
we try to refactor it I've got a
function called East Prime
everybody in this room knows how this
code is working right because what does
it do you first say is divisible Bulli
now what is this variable called
normally use the word called flag but
this also known as smell right because
anytime you use flags it's really poor
flags lower self esteem there's a
research that shows that right so so the
point really is you have to find the
flag and you feel terrible and you make
spelling mistakes like this while you do
it also right so you know divisible and
then you create a variable like this and
then what do you do you loop through I
mean this is like work it's worse than
working in a post office right it's like
next time please next time please right
that's what you're doing looping through
every one single variable and then if
the value is even then this divisible
equal to true then you break out of it
makes me cry looking at this and then
you say if the number is greater than 1
and not divisible then the number is
prime right so what is the problem with
this code the problem with this code is
this is called primitive obsession we
feel like we got to do everything all
ourselves because after all we cannot
cross the language to do stuff the
libraries to do stuff then in the main
it's even worse square root of first
hundred primes
so we first create an empty array list
right now this is where you really
create this and say why do I have to do
this but we still have to create an
empty list then we create an index I
because we don't know how many values
we're gonna have right because we want
the first hundred Prime's but how do you
know what the 500 frames are so you put
an index equal to one you do a while
loop while the size of this this is then
hundred then go ahead and get the first
prime value and then you pass to see is
it less than hundred or less than or
equal to hundred have you ever done that
before
that is called punishment right so we do
that all the time and then you say is it
prime and then if it is prime what do
you do you find the square root of that
number and then you add it to this right
and then you increment the variable how
do you feel doing this right really
terrible isn't it you are trying to find
out if there's you know people in prison
who can give this to you right you don't
want to do this anymore
so that's kind of that low-level code we
saw let's attack this what are we gonna
do to fix this the first thing is we
want to be communicated we want to be
expressive so let's put an English what
are we trying to say
we're saying a number is prime if the
number is greater than one hey that's a
good first step awesome then what then
if there are no divisors hey that's it
why can't we just write that in code so
in the stream one more time range and of
course we need the stream object for
that so we'll bring in the stream dart
into stream great now that we have a
stream what is the range of value of two
of course not including the number great
and then what do I do all that I'm gonna
say say is none match right nothing is
matching what are you matching against
given an index value then I want to make
sure the number Mart index is equal to
zero that condition is not true non
match and then you can remove this
garbage you saw here and notice how
expressive that code really is so if you
run that little code you can see that
that part is still producing the result
so that's one refactoring so what that
means is every time you sit down to look
at a piece of code we got a look at that
code and see is there an equivalent that
I should use now here's a good news if
you're using some really good IDE is
your IDE s when you open the code in
Java 8 you'll see a little light bulb on
the on the side and then you click on
the light bulb it'll swallow your old
code and you'll push a new Java 8 code
now the other day somebody was asking
hey what if my idea doesn't do that I
told him get a real IDE right the point
is that you can use ideas to do the jobs
like that and absolutely you can try to
you know use some of those facilities
but beyond that we also need to know
what kind of the factoring we got to do
well that's great we can do that the
east prime num is refactored it's
expressive concise lot less code than we
had before and it makes you proud
writing that code right because it feels
like you spoke to an adult rather than
sitting them babysitting in a no child
care center or as a childcare center now
that it's wrong to babysit child care
center but you do it when you love doing
it not when you have to do this is how
it feels like that right ok great now
coming back here to the main method what
are we doing here in this case of course
this while loop right it's really a very
imperative style of
code we definitely don't want to do this
so notice what I'm gonna do instead of
doing all of that I'm gonna take this
part what are we trying to do before I
get rid of that code we're trying to get
the first hundred prime numbers and then
we are trying to find the square root of
those prime numbers right well guess
what we're gonna do we're gonna simply
say stream dot ETA rate so iterate and
start with one given an element
give me element plus one stare at that
code for a minute this is extremely
powerful this is called an infinite
stream so you basically created an
infinite collection it starts with one
and it goes forever now you may say how
could you possibly create an infinite
stream wouldn't you run out of this
space right well it runs on cloud I
don't talk about it No
so the point really is like so the point
really is of course nobody can store an
infinite collection we don't have this
space for it but hinges on one very
smart decision right and the decision
has it says I dare you ask how much you
want if you have if you ask for infinity
you suffer through infinity right so it
is a lazy evaluation it postpones really
creating objects until you it's on
demand that's what it really is so
you're saying create one but don't
produce the next element until you have
as before it okay great
what's the next thing I'm gonna do well
now that you have given me one value at
a time I'm gonna filter what am i
filtering I am filtering only values
that are prime so when I go through the
filter he is one a prime know is two a
prime yes well yes a two goes through
he's three a prime yes
his for a prime no don't let him through
it is five a prime you see we see how
it's dropping down only prime numbers
come to line number fifteen non prime
numbers are blocked and making sense
okay great now you're on line 15 what
does that mean you only have prime
numbers what the next thing you're gonna
do map those values to what math square
root
that right so I want to do a square root
of these values so math dot square root
now on line 16 what you have you have
the square root of all the prime numbers
what prime numbers every prime number 2
through infinity right but then you say
I want to only take in this case limit
200 very cunning as you can see right it
says well now that you have infinity
things but I only 100 right so this only
gives you the first hundred values and
then what you do I want to collect them
back to a list of integer quietly so
look at the expressive power of this
code we're not sitting there and
spinning around and looping and mutating
and wild loop right and instead we
breathe easily right because we are
speaking in our own language right now
hey given the infinite stream of numbers
only give me prime numbers of the prime
numbers give me the square root of those
and of all of those I just get me the
first hundred please right so it is very
very expressive right and and of course
you got to know what these things mean
right so this is like having a really
really powerful tool you need to know
how to use the tool but it makes you
more efficient when you learn to use the
tool so it becomes very communicative as
you can see now of course for me to use
this I need a few things I need the
stream I also need the tool list method
so we're gonna go back over here we're
gonna bring in the stream at this point
so here is the stream and then I'm also
gonna bring in the to list method
well the to list method is available as
part of a little class called collectors
and then the to list method comes from
the collectors and so that is a
convenience method available in the to
list and assuming I wrote all of that
the result must be that particular list
that we have collected up here which
would bring in the value for us so I'll
let me go back and fix this error here
oh I forgot it equals right there there
we go
so you can see that the value is there
so do the same as before but what did we
do we do two refactoring here we use the
YZ Prime and we use the non match
which means we got to go through and
scan through the JDK and look for
higher-order functions that are
available and so you may be coding like
the way you do normally but then you say
oh look what I found this actually saves
me so much effort compared to what I
used to do this is like opening the door
and finding new sets of tools available
all of a sudden and you can do a better
job with what you have in you and in you
in your hands and then of course we
create an infinite stream and then only
cherry-pick prime numbers then transform
those Prime's to their square root but
only limited ourselves to first hundred
numbers and dump them into a list makes
sense so for good the progress awesome
excellent so that is our next thing we
did we used internal iterators rather
than using external iterators we used
very specialized functions filter map
limit all those specialized functions on
stream we did function composition what
does that mean do you notice how
beautifully these darts are aligned
right they aren't they cute right you
look at that and you feel like there is
order in life right it feels it feels
right don't you think so
right and that is that is function
composition right there when things are
lined up we used an infinite stream
right and then of course we did lazy
evaluation of course the word lazy in
Java eight is pronounced a little bit
too an accent you pronounce it as
efficient right so make sure you keep
that in mind because the lazy may have a
connotation but it's efficient that's
what you need to keep in mind okay so
time to want to the next exercise I call
this the tail don't ask exercise so
let's go ahead and try this out so the
next exercise I'm going to look at over
here I've got a little thing called a
time slot well time slot is just a
little class that represents a time slot
and I have a random number generator you
can schedule a time that's available and
you can ask if it is available and I
have a list of time slots available to
me and I want to schedule an available
time slot now so what do I do
this should be very familiar code you
for to say first available time slot
equals what is this called no if you
pronounce it smell right so so you
defined a smell and once you do that
what do you do you loop through the
values one at a time and then what you
do give in a time slot is the time slot
available if it is available then
schedule it once you schedule it assign
it to this variable and then make sure
to break out of it anyone has written
code like this yes you never admit that
in public right that's why you people
want to say yes yeah I feel your pain I
feel your pain well we have done this
right but here's the problem
notice one thing we totally forgot along
this path that we may not have a spline
time slot at all available and the few
testing we do guess what happens we get
a time slot which means we are so happy
until that poor tester comes along reads
and times are all full and what do we
get
nullpointerexception anybody here who
goes home happily after a null pointer
exception I mean there's a reason why
programmers curse right without you it's
like okay oh it anyway get really angry
that the point is well what if you can
avoid all of that in a very very nice
way let's try this again
so this violates one important principle
that principle is called tell don't ask
tell don't simply says tell an object to
do stuff rather than querying the object
making a decision and putting things
back in so notice what I'm gonna do I
want the first available time slot
that's all I'm interested in so let's
get rid of that code for a second I'm
gonna refactor this just a little bit of
course you could keep this API the way
it is but it's easier to refactor it
so public boolean schedule so schedule
if available and what do you do here in
this case I'm gonna say a boolean open
let's call it open equals is available
and then if Oh
when then schedule it and then once you
schedule return the open right so I just
wrote a schedule if available function
now what I'm gonna do here is I want the
slot whatever chouet is available so I'm
gonna say time slots dark stream and so
we got a nice stream of these data lists
to work with and then I'm gonna say
filter and what am i filtering on I'm
gonna say time slot schedule if
available well how many do I want find
first only the first one because it's a
lazy evaluation it will stop the minute
it finds the first one it will not
schedule everything right it's very
smart this is called lazy evaluation it
doesn't work through the entire
collection
it works with one element at a time and
continues only if it's not satisfied
still so it takes the first time slot
it's a schedule available it says I'm
not available
next one next one and the first time it
finds one that's available it's done it
doesn't even look at any more schedules
after that but when I run this code
notice what it's gonna tell us
it says optional time slot what is that
optional it readily tells you hey
nothing may be available so the result
may not be optional at that point the
result may be none meaning sorry I don't
have a time to give you right so it
doesn't lurk around imperative code is
opaque imperative code hides in a corner
to hurt you and you least expect the
transparency here is it reveals the
intent very clearly says I'm sorry this
may not be available I have to tell you
that it's optional so there's no
possibility of getting a
nullpointerexception because when you go
to the sky what is he gonna do he's
gonna say sorry it's not available right
so I can how do I get the time slot from
it I'm gonna use another function but I
gotta warn you this is probably the
scariest function I've ever seen in the
JDK it's called or else right you
threaten it right if you don't have it
well then you can do whatever you want
to do maybe create a new time slot or
given error playing sad music whatever
it is right so the point is you can say
are L saying unprepared it may not exist
I'll deal with it
and then you can give an alternative
time slot if it's not available or you
can do other actions as you may play
you'll feel fit so that gives us an idea
about how we can write the code but also
notice compared to the code we started
with there was that bulk of code we
started with a loop and all the flag and
smell and null but notice all that just
disappeared just about two lines of code
to go through it make sense so far so
once again we gotta rethink the way we
write code and be very highly expressive
and so what did we do in this example we
first said keep the focus on the whole
rather than the part we said here's this
list of timeslot just do the booking and
get me the first one rather than being
in the business of looping through each
one of them and then the code is very
transparent it gave you an optional
rather than hiding behind to surprise
you later
you averted the smell of null and then
you use the optional to get the result
out of it seems reasonable questions
comment so far
keep going all right well let's I
couldn't figure out a good name for it
so it isn't a call it you gotta be
kidding me
so let's talk about what this is well
imagine you are given a directory so I
have a directory on my hand print the
name of all the files in that directory
comma-separated that's my job right
let's try well first is I want to get
all the child directories how do I do
this so far I'm gonna first of all say
list a file we could call this as
children equals and then we could say
something like a directory dart list
files right so that uses a list of all
the files in the directories in the
current directory well okay that's even
better
he says that's actually a file array not
a list so let's go ahead and change it
to a file array great now that have a
file array how do I loop through and get
all the values for in I equal to
0i would you dare no of course not right
that is insane so what would you do you
would say well file child in children
and then what would we do well we want
to list of all the children so we could
say let's just drink
names equals and new ArrayList and then
we would create something like this
right and then we would patiently say
name start add child dot get name and
then we would add to the names
collection well good news we got the
collection we want we can print the
names right here so yeah that that's
wonderful isn't it you say wait a second
but what's its quiet racket doing oh
yeah I don't want the square bracket
well we can easily fix that right well
we could say for string right name in
names and then we could simply say
output the name that was very easy well
but they are in multiple lines they got
to be on the same line and sure we can
fix that easily they're on the same line
now well but I want separators on them
no worries we can provide separators too
but I want comma separation no worries
comma separation for you but now there's
a stupid comma in the very end
I've got a great idea to fix it anybody
has done this before
and you told and you'd sent that night
god this cannot be true because you have
to say I less than what what is what we
did we get name start size right and
then I plus plus and then you had to
only put that then you had to say output
and then you had to put a little comma
when you're done with it you got to put
a print line and then you have to say
well but not for everything still right
so what do you have to do you have to
say something like if I is not equal to
name start size minus 1 right man
unbelievable isn't it and yet we all
have done this well shouldn't like me a
lot better than that so let's try it
again
so what we going to do here is the
following let's say I want to print all
the values right so output let's try
this again a directory stream dot F
directory dot list files the off method
transforms an array into a stream so if
you have a logical array not a list
remember if you had a list you can call
stream on it but you don't have a list
you have an array so he's a stream dot
off and you got an array make sense so
far well now that we have an array I do
you have a file on your hand we do a
mapping and I say file get name because
I'm interested in getting the name of a
file we got the name of a file what's
the next thing
dark collect because now we have a name
of all the files I'm gonna say joining
and you go to join in with the comma
isn't that cool the day I learned about
joining I cried that night right
this is the way it should be right this
is the way programming should be so
essentially that's what you print out
you got the string on your hand and then
now that you got the string you just
print the value because that's your goal
is to just print it out well what are we
using here list files is a function so
let's put a parentheses right here
obviously so we're calling the function
on that Oh in fact how silly me well
actually it's a directory so I can't do
much with it but I had to call that and
then joining worth joining coming from
well joining is part of the collectors
so I'm going to say collectors start
whatever that method is it's a static
method in the collectors that's where
it's coming from that is from the stream
stream dot collectors right so now that
we brought the collectors together what
is the stream coming from obviously the
stream is coming from it's not a static
thing it's actually from the stream API
so I'm gonna say a dart stream to bring
in the stream itself so if we go back
and look at the code now hey first good
news there's no that stinking comma in
the end and you can also see how that
code is lot less also than we started
out so you stream of directories of
directory dot list files and then you
map to only get the file names and then
you collect them into a string voyage by
joining them with a comma seems
reasonable so that is an example of how
again we can be very highly expressive
and we don't have to endure the pain we
saw so all those daunting tasks that we
have done now we can raise to a very
high level of abstraction as you can see
here great now I want to talk about one
other thing which is another thing we
normally do in programming is we have to
compare things we got these sort things
we can't trace things and so on I
believe in good design principles and
one thing that makes me very angry is
when my design becomes intrusive I I get
very angry when somebody says modify a
class and I ask them is this an
intrinsic behavior of the class no it is
not an intrinsic behave the class then
why are you messing with this class
right so to me those design principles
are very important so let's look at one
example
here of how we could get really wild at
this I've got a class with list of poor
people
I've got Sarah 12 years old mark 43 barb
is 12 and Jill is 64 as you can see now
collection starts sort what does that do
it sorts the people in this collection
now if I go back to person dot Java
notice how inclusive this is I
implemented the comparable APA interface
because I want to compare there's a
problem if you implement this you get
exactly what you asked for right which
means I'm comparing them based on the
age well what if you don't want to
compare based on the age you got to
change it what if you want to compare
some based on something else again
you got to change it again what if I
want to compare games to different
things
tough luck right so it doesn't give you
that flexibility at all but we'll come
back and address this in a minute
then notice we sorted the people right
here but the problem is this when I
print out notice it is sorted but this
is called evil programming right why
because we took the initial collection
and we sorted it what makes us think
that the initial collection deserves
sorting right in a particularly use case
scenario we want to print a sorted list
but we have no business touching the
main collection unless that was a very
intrinsic operation on it right so this
sort method is an example of how we
should never write code because this
code takes objects given to it and
modifies it right that's a very terrible
practice you should never modify
parameters given to you or at least
rarely modify parameters are given to
you right I mean the only time you write
code that constantly modifies variables
given to you is we hate the programmers
you work with right then they're gonna
sit there and debug forever that that's
great but if you really love the people
don't do that right so the point really
is we modified the given thing that's
very very evil so what are we gonna do
notice what we're gonna do we the first
thing is we're gonna get rid of this
intrusiveness no more
implements comparable in here as a
result I'm going to get rid of that as
well now notice the person class is pure
it only focuses on its own self and it
doesn't deal with any of these
comparison you know nonsense now we go
back here to the code and what am I
gonna do
well I want to sort but what was a
sorting on I was sorting based on age in
the first place so notice what I'm going
to do now I'm gonna bring in first of
all a util dot function dot function so
function is a functional interface I'm
gonna bring in function and what I'm
gonna do now is I'm gonna say function
over here and this is gonna take a
person and return an integer and I'm
gonna call this by age and simply equals
to person get age so we simply wrote a
function called a by age function that's
all we did now once we write a by age
function now I can simply say that over
here let's actually write a separate
method to have fun pop like let's say
static void print sorted and the print
sorted takes a list of let's say people
will call it people but I'm going to
give it another parameter over here for
this okay
there we go okay so I'm gonna give
another parameter for this which is
comparator right and this is going to be
a comparator on the person so we
externalized is we call it as comparator
that's what we're gonna call it right
okay great so now that I have a
comparator where's that coming from
let's go ahead and bring in the
comparator but in addition to the
comparator I'm also gonna bring in one
more thing and this is going to be a
bunch of static methods that are now
available in the comparator this is
another thing in java 8 that interfaces
can't have static methods at the very
first sight you may look at this and say
that's crazy and then you use it for
about 15 minutes and you say that's
crazy cool right so the beauty is that
it becomes very reachable to you right
it's there and related to what you're
trying to do so in this case of course
you are saying by age and now I'm gonna
call this function we wrote what is this
called print sorted so what am I going
to do with them prints sorted I'm gonna
say in the print sorted a people first
of all dot stream so we got a stream
again and then I'm gonna say sorted
based on what based on the comparator so
we are giving to the stream assorted a
comparator but the sorter is a very
civilized sorting it doesn't change the
given input instead it gives you a new
collection which is sorted then I say
for each and I'm gonna print system dot
out and I'm gonna print out each one of
those element in that collection right
that's what we are doing so now if I go
back here I'm gonna call the prints
sorted and again that takes a stream
sorts them and prints them so in this
case prints sorted people and then what
am I gonna say I'm gonna say comparing
comparing based on word by age I want to
compare it based on the age value notice
how it is by age so Sarah is 12 then Bob
is 12 and Mark is four to three
and Jill is 64 so it was sorted on age
as you can see right there
but then what I'm going to do is but
benefit of externalizing it we get the
benefit of doing it very differently so
notice what I'm gonna do now I'm gonna
go ahead and create another function
which is going to return a string and I
called this by name and this time I say
get name over here and as a result now I
can simply say print sorted people and
then comparing by name and the worst
thing that's gonna happen is people will
actually read it and understand it right
because it begins to read like English
right you know print sort of people
comparing by name and they're like what
do I do I understand this code go home
right you don't have to be sitting there
and debugging the code it just makes
sense
well but then the come comes the cool
part now that we have this flexibility
you can say people comma comparing by
age and then comparing why not write by
a name so you can compare them using
multiple properties now and if you look
at the output this time in the very last
call you can see Bob comes before Sara
because they both are the same age but
once they are the same age we sort based
on the name so Bob took proceedings over
Sara so you can do a very powerful
combination without having to be
intrusive at that career pattern that
doesn't suck as you can see right so it
becomes really easy to work with in this
case so that is an example again of how
we can redefine the things we do and
it's very non intrusive as you can see
well the last example I'm going to show
you is one of my favorite which is the
execute around method pattern I'm gonna
explore a certain options here to work
with it well I have a class called
resource right here and the resource has
a constructor and op 1 op 2 method and I
got a finalize method sitting here now I
go back to the main I create a resource
I call up one and op 2 and I run the
code notice it constructed the object it
did op 1 and op 2 obviously this is due
and
worked on that but unfortunately notice
it did not call the cleaner my first
reaction as did I miss fel the finalize
method and apparently not
well it didn't call finalized why
because the garbage collector says I
don't have really reasons to run right
now
there's a lot of memory so if you really
want if this was an external resource
you are in trouble right because that
external resource is going to be held
for a long time and as a result this is
gonna become very problematic well I'm
gonna call this as close right here and
then I'm gonna come down to the code
right here and call resource start close
and if you run this now you can see that
it actually did perform the cleanup
operation but there is one problem in
this code or it does anybody see what
the problem is
that's correct I heard the whisper an
exception if this code was to throw a
bit throw an exception the close will
never happen so what do you do to fix
that problem
you say try and then you move this code
into the try block and then you say
finally and then you put the resource
over here in the finally block and then
make sure that it would call it makes
sense right what do you think of this
code it is called desperation right
because we're desperately trying to get
this to work to clean up the research in
a deterministic way what are the chances
you will forget to put try and finally
high or low very high for me it's very
high right and this is where bugs come
from and somebody eventually finds out
and what do you do you fix it and say
here sorry I forgot the finally block
right it feels really bad when that has
to happen right and so what do you do
and then people say well you should
really use a good IDE that tells you
about this next thing you know we're
basically next six months finding and
finding an IDE that'll fix these kinds
of problems right so that's one way to
solve the problem well thankfully Java 7
fixed it RIT really well we'll find out
so what did we do in Java 7 Java 7 has
this
interesting concept called a or M which
stands for automatic resource management
the idea behind automatic resource
management is we can all agree that this
code is smelly so to remove the pain a
little bit what they're dead is you
don't have to put the finally block what
a relief
so what you do is you write the resource
like this and then you simply put the
resource right inside of this well of
course for this to work you got to do
one more work you have to say implements
over here and the implements of
auto-close civil right so once you
implement auto closable that has a
public closed method now you no longer
have to put this at all
isn't that beautiful well that works for
about ten minutes then you realize when
kid comes along and you know what think
it has to have a habit of forgetting to
put the try block so rank it never put
the try block what is gonna happen will
air and tell me I'm wrong right now no
but don't act surprised you know this
already you never trust a feature with
the word management in its name right so
that didn't go really well at all right
so what do we do wouldn't it be nice to
really be deterministic about this right
so let's go back we'll make the
constructor private right we'll make the
close method private now what's going to
happen the poor programmer comes along
calls the method resource start close
and guess what the programmer gets an
error when the programmer tries to call
a closed method and he says what in the
world
it doesn't like me calling the close and
the programmer says no no worries I
don't have to call it right
well that one missiles has the problem
now the programmer cannot even call the
constructor
now we drew the attention of the
programmer and the programmer says
what's the magic how in the world do I
use a resource so now we're gonna use
the style in Java 8 we're gonna say
public static void use and the use
method is
static method so we're gonna come down
to the resource and we gonna call the
use method now of course the use is
going to do something very interesting
in terms of managing the resource it's
called execute around method pattern
it's a pattern very useful to really
perform a very deterministic behavior
around the piece of code the word
executes around means around a piece of
code you have written you can do pre-ops
and post-ops
so resource equals new resource we
create that we remember to put a try and
finally because we have the authors of
the class here we call resource start
close and notice we took care of what
the programmer should be doing correctly
right and you say programmer this is the
way to do it so guess what
don't worry about it we have done it for
you so you do the free up and the post
up and right between the pre and post-op
you eel the control to the programmer
and the way you ield control to the
programmer is to say blocked out except
and you pass the resource what in the
world is this block
well the block is going to be a function
over here dart consumer you can use a
consumer you can use a function a
predicate
whatever that may make sense and in this
case of course we're using a consumer
and then we pass it to this consumer so
we say consumer resource and that's
going to be our block so if you look at
the use method the use method receives a
block of code creates a resource hands
the resource to the block of code and
says go be happy do whatever you want to
do with it and when you are done come
back and return it to me and when it's
returned it from the clothes clean up
and it's done with it so back here in
the main we simply call the used method
we are given a resource on our hand and
with that resource now we perform our
transactional operation whatever we
choose to and you can see that the
cleanup happened automatically for us
and it take care to care of you know
clearing things out so as a result this
is one of my most favorite patterns it
comes from the small talk days and small
tough people
normally use these kinds of patterns
because there had lammed expression for
a long time but now that we have lambdas
available to us in Java 8 we can do this
as well and and be able to write code
like this so the idea behind this I was
on a project where we use this where we
have transactions constantly running and
we have to check the status of the
transaction if the transaction fais if
something was an error we want a log and
we want to rollback transactions if
everything went fine
we want to commit the transaction so we
said transactions or running transaction
give the transaction object to the to
the caller the caller does whatever they
want but when they return back to or
function we would check the health of
the transaction commit or rollback with
the logging and take care of those you
know pre and post-ops very nicely so
this gives us an ability for us to write
code in a way we can apply some nice
rules the idea really is this when you
develop enterprise applications what do
you do you have these kinds of rules to
enforce all the time and this gives you
a way for you not to threaten people to
say you better follow the rules instead
you'd structurally design your code they
will not be able to write code without
following your policies and rules and
your if you could write code like this
the future you will thank you today
right because you are saving so much
effort in writing the code and and so we
have to write better code for the sake
of our future ourselves and and that is
the reason to write code like this it
really saves us a lot of effort so
rather than rolling on features that can
be tricky and easier to forget we can
design code in a way there is nothing to
forget because it is designed in a
structurally in a certain way that it
only works that way so what did we do so
far what we did here is we started by
talking a little bit about the
functional programming concept we did a
quite a bit of refactoring along the way
we looked at how we can make use of
lambda expressions for all the single
abstract method interfaces then we
looked at these streaming API s and how
we can use lazy evaluations very
effectively then we looked at how we can
be more expressive and start using the
evaluation further in doing things like
fine first and using the tell don't ask
principal then we use the facility to do
joining and then we looked at the beauty
of comparators and the sorters and then
finally we looked at a pattern we could
use if you're interested in downloading
the code examples there on my website I
sincerely hope you found the session
useful thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>