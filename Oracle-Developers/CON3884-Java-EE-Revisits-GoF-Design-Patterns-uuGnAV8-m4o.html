<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON3884   Java EE Revisits GoF Design Patterns | Coder Coacher - Coaching Coders</title><meta content="CON3884   Java EE Revisits GoF Design Patterns - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON3884   Java EE Revisits GoF Design Patterns</b></h2><h5 class="post__date">2015-12-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uuGnAV8-m4o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so who we are you may not recognize
Razer because of his new hairstyle which
I couldn't when I first saw him this
year yes my name is Reza Ramon I'm a
Java evangelist at Oracle Corporation up
there is my twitter handle and even up
just not up there just for giggles you
know if you have any questions on any of
this or Java EE generally please feel
free to reach out to me and I am the
track lead for this track that you're on
at the moment so if you have any
comments or suggestions what whatsoever
on that track I'll be happy to take
those as well and this is Murat we work
at Intel as a mobile developer so the
talk which will have today has nothing
to do with my daily job but I've been
interested with Hawaii since from the
early days and I happen to write a book
with my culture Alex sir again I didn't
want to have him on stage because of his
hairstyle we need some long hair guys
I'm losing my hair so that's why I
wanted to reserve us right so any of you
have the book okay if you don't we have
a discount code and if you ask questions
you can win one so yeah so wouldn't an
incentive to ask questions in fact for
this particular session the way we'll
run it is to make it more discussion
oriented so don't hold up until the very
end to ask questions ask us questions in
the moment and if it's a really good
questions will you get to win a free
book and it's not a cheap book either
it's like 50 bucks or something is like
yeah what I don't know question Alex
brought them with him so you can just
ask him about the rest forty-seven or
something like that so what are design
patterns oh they just emerged so
actually when you go back in history you
just realized everything started with
object-oriented programming and when you
read about design patterns you just
kind of a feeling that extra might be
right
which I don't really agree then gang of
four appeared and they published a book
which introduced the list of design
patterns and after that in at Java Evo
in Java one 2000 there was a talk about
prototyping patterns for Java EE
platform which become a very successful
session and become a book which has been
standard for a long time and after the
introduction of Java EE 5 most of the
Gang of Four design patterns and
actually more have already been
implemented in Java EE so they have the
out of box implementations you don't
really need to do anything so if you
just just the base main summary of the
talk Hawaii has more almost all the
pattern so you can just go and have some
beer but if you still instead in the
instant of listening cos let's move
singleton ok so I just want to clarify
the previous point that that Murat was
was was talking about so especially Gang
of Four is a famous book and I think at
least some of you have at least heard of
Gang of Four Gang of Four has a bunch of
different patterns ok not all of which
are actually that common in into
enterprise applications however the ones
that are actually common database
applications those instead of having you
having to implement those patterns it's
actually baked in as part of the api's
of the of the platform itself ok not all
of them but certainly the ones that you
would use in the 80 to 90% use case okay
so singleton is a pretty good example so
let's let's start there essentially the
singleton a design pattern if you read
the Gang of Four books is
about having a single instance in the
jvm of of an object okay and why do you
need this well the Gang of Four
motivation was essentially heavyweight
objects objects that you wouldn't want
to create and because they were
expensive to have around and that's why
you would have this singleton pattern
forcibly sort of if you will force
object orientation into forgetting about
objects and really thinking about making
a one-to-one relationship between a
class and an object instance and if
you've read any further in the gang of
four patterns you know implementing the
singleton pattern is quite non-trivial
you know you have to start with some
pretty unnatural constructs you know
like private constructors and you know
thread thread synchronization and the
like okay so and of course and in the
end you still didn't get get get thread
safety you know whatever object that you
were producing in the end they were
singleton object still needed to think
about safety because after all it's just
a single instance being shared across
the JVM across multiple threads so what
we've done in Java EE is to simply
introduce this concept of a singleton
okay so if you want an object to be a
singleton well you don't have to go
through all of the mechanical details of
in all of those and ste
you're looking you know Gang of Four
recipe code to do all of that well what
you simply do is you stick this at
singleton annotation on on a class
definition and this effectively makes it
a singleton okay so no more crazy
private constructors or thread safety
concerns or anything like that at all
in fact this object by default is read
locked okay so all access to it is
serialize alright so you don't have to
worry about thread safety at all so
let's get to I guess the expensive
construction part that's that's remember
one of the principle motivators of why
you would want to have a singleton in
the first place it's expensive to create
yes absolutely
hmm please ask your question a bit
differently there's a bunch of
advantages to this so first of all this
look at the syntax it's far more natural
it's simply a Java plus you know like
any other Java class all you're doing
here is sticking a bit of declarative
information think of this as as the
application server is a JVM on steroids
and all you're telling the JVM is please
make sure this this thing is a singleton
right and you don't have any other other
besides that your your code artifact
looks very much like natural and natural
coding paradigm as opposed to doing
something quite artificial you know
mm-hmm so beyond that though there's
other benefits as well you know they are
the one being that this is entirely
thread safe okay out of the box you
don't have to worry about thread safety
concerns at all whatever access you have
to this bean is going to be
automatically thread safe for you okay
there's no way you can run into a a
threaten threading contention for a
singleton object okay all right so going
back to my point okay so original
motivation for the Gang of Four
singleton expensive objects that are
expensive to create okay so how do you
do that in this world well what you do
is you can do a couple of things you can
certainly create a classical constructor
there's no problem doing that okay and
just great a do whatever you need to do
in in terms of object setup initial
objects set up in your constructor
however there's an even more elegant way
to do that you know that hooks into the
instantiation of the object itself in in
the Java environment and thus this other
callback called post constructors they
simply have a method where you do your
object setup and you simply stick the
construct method on it and a nice
benefit of this especially as compared
to hand hand writing a singleton pattern
is that the the lazy initialization part
will actually be done for you okay this
will dispose construct method will be
invoked only on the first axis okay of
the singleton object similarly you can
actually force eager loading as well
okay so let's assume you have a case
where you do want this object to be
available right out of the box when the
application starts and you can very
easily do that by just adding the at
start up annotation okay and this will
make sure that it is eagerly initialized
as opposed to lazily initialized
something by the way that wouldn't be
possible okay to do in a classical
classical signature singleton pattern
yes sir
the scope is a technically speaking
cluster yes yeah you know Java ie
application it with it will recur in
classflow this is this would be Java EE
6 onward okay yes sir
not all so this is how it works so this
is how you get a reference to a
singleton in an Java environment you
actually simply say @inject singleton
bean okay and what you will be given
here is actually a reference to the
underlying instance okay so this is in
fact a proxy under the hood so whatever
you whenever you whoever is accessing
this at any point in time is actually
accessing that single instance in
available in the JVM somewhere and that
access is granted only on you know on a
thread safe basis so if you have two
threads accessing the same instance at
the same time they will be forced into a
suit in to serialize daxus even calling
methods in nature's most certainly
calling methods and main strands yes
that would be the whole point okay all
right so what are the benefits of some
of this of course expensive objects the
the the thing that we talked about the
original Gang of Four motivation that's
still valid the other nice thing that
the nice access that nice uses of this
singleton pattern meets in a Java
environment is things like caching and
shared data so if you have any any thing
that you want access you want accessible
throughout the JVM this is a nice place
to stick stick that piece of that bit of
information what are the what are the
beds we'll overuse like just like
anything else if you overuse it it'll be
a problem you don't want to have too
many Singleton's and too many
heavyweight Singleton's it'll eat up
your memory and it will never be
released essentially because it's a
single instance and similarly you have
to be careful about when you want this
data to be loaded right so if you--if
you eager load if you lazy load
everything that means that you know
you'll pay a cost on first access okay
the the person that accesses it X is it
first will pay a cost and and the
opposite problem if you you know if you
if you eager load everything you'll pay
here cost in terms of memory so it's a
question of what do you trade off CPU
versus memory okay at runtime the ugly
these days it is considered in an
anti-pattern
in most job ie applications you
generally will not use single terms
except for some in each cases okay there
are some other frameworks out there that
will remain nameless that you use single
tones quite heavily the big problems
with these are you know issues like
thread safety concerns and the like okay
so in Java EE we do recognize as a
recognize it as an anti-pattern you
should really only be using it when you
need it
by default the smartest thing to
actually do is use something called
stateless session bean through either
than single tone session means okay
moving on and murad takes over for
abstract Factory
so factories listed in Django for their
creational patterns which are used to
encapsulate the creation of the objects
so the main motivation is not to create
objects with new instead just ask the
factory and a factory just creates the
objects for you and gives you the
instance you want and it's usually very
good because it will encapsulate all the
parts which are subject to change so you
don't need to change all your code and
clauses when part of the creation system
has changed so moving to Hawaii if we
just change an ordinary bean into a
factory we just add the producer's
annotation which which turns this method
into a string factory
so whenever string objects is injected
to a resource this method will just get
in action and produces the string and
the string produced by this method will
be injected into the target so a quick
note here you can actually assign a
scope to the object being produced
well so by default this is something
called the dependent scoped which is
essentially the default scope it's
equivalent to new which means this
producer will be invoked every time you
do an injection however you can you can
assign any scope to this so you just add
the scope type right after the producers
annotation so if you wanted for example
something that is application scope you
would simply say produces the
application scoped okay and that would
mean that is instantiated only once okay
per the entire application and I don't
know why this empty slides are showing
up but so what about ambiguity if we
have two different instances of the same
type of objects then we end up with
ambiguity of the type system so in that
case we use the qualifiers to solve the
ambiguity as you see here we can just
use the name connotation and I just give
some names to the factories so each
client will just need to annotate which
Factory it's really targeting and
listening so it's a very easy way to
solve the ambiguity so the good part
it's very very easy to implement you
just add produces annotation and just
creates the magic know boilerplate code
and everything just works magically the
bad part nape annotation is not type
safe so same type of objects can be
wrapped or annotated with qualifiers and
the ugly part is it may introduce some
level of understanding if someone is new
to your project because the execution
flow just works magically some part of
your code is producing
objects and they're magically injected
into some other parts which is not
really the way you just follow the code
and read everything but again it's not a
huge deal when you just check the pros I
guess and you can also the IDS can also
help you out for example NetBeans has a
nice little wizard to say okay for this
produced you know object that's being
injected please find the corresponding
producer and there's no problem with
debugging debugging also works magically
okay facade this is an interesting one
in some sense because it's debatable
whether a actually deserves a separate
name or not so what is facade in fact
about the simple definition if you read
it read it it's on the slide it says
hides the complex logic and provides an
interface to the clients well sounds
awfully familiar right this is nothing
much more than the core part of
essentially abstraction right or one of
the core principles of object
orientation so what is special about
this and why precisely does it deserve
does it deserve it and its own name and
a sort of its own its own place in the
cat in a catalog of design patterns well
it's not merely about creating
abstractions it is about creating a
specific type of abstraction in an
enterprise system what you'll find is
when you're designing the system you
will wind up with a layer called the
application layer it's a layer that sort
of describes at a high level what is it
that that particular part of your
application or subsystem does okay think
about think of this as high level these
cases the types of use cases that a
business analyst may describe right do
this do do the other thing and so on so
perhaps order perform an order or you
know get a list of products and match
this particular search criteria these
are your high level API is describing
your middle tier of your application
okay that is really what you are doing
using as a facade and the facade is
simply an abstraction to describe those
high level use cases to
any users above that layer okay so talk
about whether it's the GUI layer or
perhaps a remote service invocation
there they're talking to you in very
simplistic terms and telling you please
do this and you figure out how you do it
okay so the underlying code for that
would be non-trivial and fairly complex
how do you do this in a classical Gang
of Four fashion really not again not
very difficult at all generally these
are assumed to be stateless objects and
you simply write a thing that looks like
something service you would typically
name them that way or something facade
and then you simply create essentially
atomic methods okay they methods that do
a single thing that's less generally how
it's implemented in Gang of Four so
question is what does what what
precisely does Java II give you in this
case well Java EE has a specialized
annotation and the annotation that I
talked about before when I was talking
about Singleton's and that is the
stateless annotation okay so it is
essentially a marker to denote the fact
that this is a facade okay it is
essentially it intended to be stateless
it's intended to describe the atomic
operations at the service level but
beyond that this the stateless
annotation actually will do some other
useful things that pertain to the
purpose or the real purpose of a facade
as well so one of the biggest ones is
this facade also is entirely thread safe
okay so however you access this object
it will be thread safe but it is not a
singleton okay so it is made thread safe
despite the despite despite not being a
singleton okay it's beyond the scope of
this talk as to how that have occurred
but again it's a bit of container magic
but essentially you can assume this is a
stateless and a thread safe object you
can never run into third safety problems
in business logic access it is also by
default transactional which is useful
for for that tier of your application
generally you would want to
one those high level yeast cases to be
transactional also it's a it includes
things like monitoring management as
well as pooling more importantly of
defining upper threshold pool sizes for
these services and again very very
useful in creating sort of high-level
scalable applications high level
scalable API layers in your enterprise
applications okay how do you access it
again the answer is pretty much always
the same okay you stick an end @inject
annotation and you know wherever you
want this thing injected and it will the
container will do the rest of the work
for you
you don't have to do really anything at
all okay yes sir mm-hmm
okay so this has to do with the fact
that it is stateless in terms of what
the what the API expectations are
however the state under the hood the
implementation may be using things that
are in fact stateful for example you can
have an entity manager instance okay
that connects up to a database so the
purpose of the threat safety is to
shield the implementation from any
threat safety concerns okay so it's as
stateless in this particular sense is
just a marker to tell the client that
this is this can be accessed in a
stateful manner this object is not
expected to whole state however you
could be holding straight anyway okay
because it's useful to do so in India
implementation why does it need to be
pulled well very simply you know when
this object is this is this is
essentially a backbone of your
application okay let's assume that you
have a let's say a create order method
in there and let's assume that you
suddenly you get a sudden burst of
orders and suddenly have 10,000 orders
to process concurrently okay so because
of the fact that this object had this
the stateless object has an implicit
upper bound really what will happen is
you won't run into a thread starvation
situation
we'll only be processed in with the
upper bound of that of the threat poll
which is typically something like 10 or
15 or a hundred and hundred threads okay
somebody else had a question yes sir
actually that's a good question so you
know let's wait maybe you are a
candidate for winning the book okay but
yeah that ups the stakes for the rest of
you by the way okay not much at all I
would say in the order of milliseconds
yes sir
you most certainly can so you know yes
so the answer is yes stateless and
statefulness generally is the domain of
each Ivy's as to with regards to your
serviced here but there's other ways of
managing declaratively managing stateful
stateful situations in java years well
so these days there is a whole bunch of
CDI annotations requests scoped and
application scoped and sessions scoped
and the like so these those would be
again would be implicit straight
handling as well state hunting
situations yes sir I can barely hear you
I'm sorry you're gonna have to
somebody's gonna have to either relay
that question or you're gonna have to
speak up can somebody relay that
question place somebody in the middle
you could yeah you can you can't have an
interface you're not required to have an
interface so you state lessons stateful
session means do not require an
interface anymore you can opt to use an
interface if you so wish me personally I
I tend to take a a kiss approach okay
keep it simple stupid if it's unlikely
that I need that high level of
decoupling through an interface I
generally tend not to use one in
circumstances where it is clear that
having an interface is helpful I'll
promise cases all I had an interface
later okay
but either way ajb doesn't care you can
have an interface again you can skip the
interface whichever way either way it
works okay any other questions break it
okay
moving moving forward okay again very
simple a very robust you know it gives
you a whole bunch of services you can
add more services on top of it because
it's an EJB you can add scheduling you
can add remoting you can add
asynchronous processing you can make it
we can publish it out as a soap web
service a WebSocket endpoint or a rest
endpoint
okay so incredibly powerful sort of
compact compact thing to do
at your backbone application-layer the
bed overuse may introduce unnecessary
layers yes this is true okay so you if
you don't need a facade don't you
introduce one okay if all you're doing
is getting a database record out don't
create a facade for it just access your
dao directly okay and get access to your
entity and those are two words that we
haven't explained yet hopefully we'll
get to explain explaining that okay in
other words if you don't need an
abstraction don't create one okay fairly
obvious stuff the ugly well there isn't
much of one it's really just name of the
pattern it takes a little bit of
thinking as to what it actually means
and where you would apply it you don't
like to see with the tail
next the decorator
okay so decorators add behavior to
objects in runtime so instead of
inheritance they have the ability to add
functionality on the runtime to objects
which are subject to be decorated so
they introduce huge amount of
flexibility and actually we had war
stories in our book with Alex and I
really enjoy actually the whole war
story idea was because of the decorator
pattern because in my previous
experience I didn't messed up a project
and couldn't really solve a simple
problem which could be easily solve with
a decorator
so yeah decorators are can be really
powerful but you need to create some
boilerplate code and have the interface
and everything to just implement the
classic implementation however in Java
EE it's again pretty straightforward you
just add the decorator annotation
you add the delicate object with
annotation so this world decorates the
product actually the accessory object
and will executor get price method when
it's cold the way to enable the
decorators is the XML tech declaration
so far that's the first exam I'll call
tree just short and needed and actually
the XML is also needed for to decide on
the order of the execution so it's
basically declares the order of the
decoration so you can have multiple
decorators and you can just add as much
as functionality at the runtime without
really changing the real implementation
the good unlike inheritance it's very
very easy to change the behavior and you
don't really change the original code
you just introduce a new decorator and
just the configuration and it just works
magically the bad part you may need to
have some XML declaration mostly for the
order of the decorators and ugly well
I'm not sure if it's really the ugly
part but yeah overuse will introduce an
execution flow again very hard to
understand well II yeah might be
depending on the status of the project
but generally they introduce quite
powerful and flexible structures
okay and the next one actually will
finish off the Gang of Four part so good
we actually have some bonus material for
you there's a basic material that we're
going to cover and the stock looks like
we'll be able to get to that bonus
material so let's talk through observers
observers again a little bit difficult
to understand why it's needed in the
first place this again goes down to a
basic fundamental requirement in
object-oriented systems namely passing a
message okay from one object to the
other telling one object to do something
as a result of a say a state change on
on another object okay but the big
difference here versus just simply
invoking a an object on a dependent
method is that you care about decoupling
in one way or the other perhaps you have
a an event for which you want to trickle
trigger multiple observers ok multiple
endpoints that react to that particular
event or you simply want a bit of loose
coupling because you want to change
which observer actually gets triggered
at runtime ok so that is the real reason
why you would the original reason why
you would need essentially the observer
pattern now the way you implement the
observer pattern is sort of antithetic
all to the original goals of the
observer because the way you do this in
gang of four is literally you have a you
implement an interface you have a bunch
of objects that implement this interface
and then on the listener you actually
have to register concrete
implementations of each of those
instances ok so it's sort of bit self
self-defeating if the goal is to create
essentially loosely a couple of systems
so how does job ie solve this well it's
solved this in a much more loosely
coupled fashion so let's say we have
this this object here that is an
observer so it reacts to something else
happening some somewhere else in the
system so the way you express this is
simply you know create the method and
you know give it its expected
what am I expecting what am i acting
upon and simply add the add observable
annotation and what this says is observe
an event okay of that of that matches
the payload of my method parameters in
this case it's the string message and I
will act upon it okay
and unlike and the way this is actually
invoked is not directly by initiating a
or other injecting an instance of hello
world observer and invoking the trace
hello world method after all that
defeats the purpose of two things you
know it's not very loosely coupled and
you couldn't have for example
one-to-many relationships very easily so
the way this is actually triggered is by
triggering an event okay that
corresponds to the to the observer that
you're listening on so in this case you
know you would inject a type event
string and then when when you want that
event to be triggered when you want the
observers to be triggered you simply say
event dot fire and you give it the
payload that you want okay so in this
case again you're getting loose coupling
and you can also have multiple observers
listening on a particular part
particular on a single event okay so
what are okay so this is just going a
bit more into that so you can observe
not just primitives but your own custom
objects and that's how you would trigger
them the pros and cons again same thing
with the rest of it it's you know this
is not instead of having to write code
to implement the observer pattern and do
observer registration and deregistration
invocation none of that actually happens
for you in Java EE it's just all managed
by the container you have a very simple
API just one annotation and you know an
injection of an event object with the
payload and then you call fire very very
simple by comparison the bad yes it can
introduce once again please you can it
can introduce difficulty in following
the execution order it's hard to
determine okay
if this this event is fired what is
going to get triggered again the IDE
will help you do that it's a you know
NetBeans as a wizard to say okay when
I'm firing this event please tell me
what observers would be triggered you
know in the corresponding not much
that's actually about this you know it's
it's a when you need it this is a
elegant solution to the problem yes sir
actually here is just an first
can somebody please relay that question
okay
no the by default they are synchronous
today in CDI 2.0 there they're
introducing asynchronous observers okay
but that's in CDI to point or not today
yes sir
yes pearl means you can so there's a
couple of ways of doing that number one
is that you can specify as many
qualifiers that you would like so in
this we don't have an example of a
qualifier here oops
clicking a bit too fast one second
please
so you can most certainly have
qualifiers okay the same just like
pretty much anything else that you've
saw you can qualify this at observable
okay you can say you know observe a
string message with with the qualifier
such and such okay you could use the ad
named and a built-in qualifier or you
could create your own custom qualifier
and then what you would do is when you
are firing this you are you have two
options you can statically statically
provide the qualifiers right at the
injection events injection point or you
can also specify them when you say when
dot fire you can attach qualifiers there
so yes there's there's yes sir it does
not
yeah execution continues but you will
get a nasty stack trace that you can
later figure out what happened there yes
sir
okay so a bunch of things so number one
is this is look at the amount of code to
do this it's very very trivial asset as
compared to Janis in in when you're
doing a JMS or invocation there's a lot
of moving pieces going on there so you
have transactions persistence all of
those things you'll needing to deal with
right in this case that's none of that
occurs it's just a simply a lightweight
event it's just an in-memory invocation
in in memory indirect indication as to
the what the use cases are there's lots
of these cases right so really anywhere
where you would need an event this was
helpful in particular imagine that you
have a significant set of events in your
application that you need multiple
multiple endpoints to react on and these
are not important enough to warrant you
know putting it putting it in message
oriented middleware let's say perhaps a
system warning right or and anything of
that nature you know this is this is a
very very helpful facility to do so okay
yes sir CDI interceptor is not an
observer pattern CDI interceptor is an
example of AOP of aspects so that is not
a gang of four pattern in fact it's not
a pattern at all you could say that I
guess okay all right yes sir
events do not have much to do with
transactions whatsoever the only place
that the intersect is that you can have
a observer that listens on the
transaction so you can get callbacks to
say my transaction got committed got
rolled back so on other than that
there's no if you need something
transactional yes that's another use
case for using JMS because in fact in
JMS message will be transactional this
wouldn't be this is just simply
lightweight in memory in in memory
invocation there's no there's no
transaction coordinator here okay
anything else moving on
excellent okay so let's take stock of
how much time we have left I believe by
my count we have 20 more minutes yes
somebody confirm or deny that about 15
15 more minutes 20 more minutes I think
that's it we're in good shape so let's
let's continue with the rest of the
presentation I think yep so we're
actually out of the realm of gang of
four now okay so what we are now talking
about is design patterns that you oughta
know about that for one reason or the
other isn't in the Gang of Four book
okay but these are design patterns that
you should know in enterprise
applications and in many cases again
these design patterns are also built
into the Java EE platform in one way or
the other
yep so let's move to model will contact
controller which is actually is not a
pattern but a collection of patterns so
M EC is used widely in almost all UI
frameworks so believe it or not if you
did any kind of UI programming at some
point you use that so the main
motivation is to keep the data the logic
and the UI code separate so it will be
easy to change one part without really
breaking or introducing huge change to
another part so more importantly
modularity yeah and
luckily JSF is a very clean and easy to
write implementation of M EC which is a
part of Java EE so what's the model the
model is the part which represents the
data and related business logic usually
the model in Java is the CD i-beam next
it's the view view is the visualization
part of the data which filters some
fields and just visualize the data to
the user it also enables the user to
interact with the data and also trigger
the business logic and the controller is
the part which links the view with the
model so it directs the application flow
and basically orchestrates of everything
in the MVC so if you look at the Emmys
in Java EE the model is annotated
modules which are notated with named and
requested scope the view is the face
lips which are written in XHTML and of
course with CSS and the best part is the
controller is something you don't need
to care about it's the face of servlet
and you don't really need to write
anything for the controller part in fact
that is the original intent of the NBC
ABC design pattern the way it was
implemented in small talk small talk
basically was the controller you
wouldn't never write a controller
yourself the exact same concept
translated exactly in exactly the same
way in in JSF next we move to the data
part mm-hmm okay
entity this perhaps is the most
important artifact that you'll have in
your application what is it
it's a representation of the nouns in
your system the important nouns so these
are what is it that you are attempting
to model so and in for example in a in a
ecommerce application this would be
catalog product customer and so on okay
think of it as essentially a rough way
to think of it is the database tables
that are stored in your relational
database
these are your models the entity object
essentially is a naming of that concept
okay so an entity has again goes to the
very core object-oriented programming
it's a particular it's a specialization
of object orientation so in object
orientation you know an object has data
and behavior and in the end it's
supposed to emulate something that
you're trying to model in software and
that's precisely the definition of an
entity okay so it's a it's a thing that
you're trying to emulate in the real
world it will have data roughly
corresponding again to columns in your
database tables but it will also have
business logic in it how do you do this
in Java EE well it's quite simple
because there is a very very intuitive
and notation called at entity in the JPA
package that is its exact intent is to
describe an entity object of course in
JPA it really will allow you to map to
map to a relational database or an on
relational database these days actually
you can do so you can use JK entities to
map map turn on relational databases and
yet again this makes perfect sense
because you know it would be highly
unlikely that you would have an entity
that is simply goes away when you do a
when you do an application restart its
you know what would be the point of
having it so it's quite natural to think
of entities as something that is
persisted and persisted in into into the
database so a good place to put
essentially the end identity annotation
no I must say I haven't seen that too
often okay
all right all right so so here's here's
how how an entity looks like okay so
here's a simple entity contact it has
two attributes first name and last name
it may also have behavior there is no
example of a behavior obviously we're in
sort of in an artificial mode of trying
to fit in some logical bits of code on a
slide deck and in this case it also has
an ID that maps to maps to the database
this is essentially something that goes
into the database via JTA okay the next
related bit artifact or design pattern
that is related to entities is called
daos or data access objects what is the
purpose of this the purpose of this is
that data access code is often very
atypical okay from they're different
from the rest of your rest of your
application okay so you have your
presentation here you have your business
logic and then you have your data access
code the presentation to your code is
naturally segmented in its own part
because you're following the MVC pattern
the business logic again is naturally
segmented in its own part because
hopefully you're you're creating facades
to encapsulate your business logic
however you know there's no real good
place to stick data access code if you
did if you didn't have a layer to deal
with this you're essentially pollute
your business logic within your facade
by not just writing business logic but
also doing data manipulation and data
access concerns so the purpose of the
DAO is to give you that bit of ass
abstraction okay to be able to decouple
the business logic from you know the
sort of the manual tasks of data access
okay usually a Diu is going to be a
singleton or more specifically an
application scoped object right you know
it is for the most part
as you'll find out you actually don't
need actual real DTD AOS
anymore in Java EE application so the
reason for this is because of JP a JP a
has a has an has an API called the
entity manager and if you really look at
the entity manager is really nothing
much more than a Dao right it allows you
crowd Crudup perform crud operations on
on an entity and it does it in such a
high-level way that it makes the data
access code virtually vanish okay
there's not much data access code to
speak of anymore however in still there
may be complex cases were entity manager
is simply not sufficient right there is
maybe you're doing something a bit more
complex than what and then simple entity
manager crud operations in which case
yes you would actually create an object
that you say is something Dao let's say
customer Dao and then you would stick
some code in there so let's figure take
a look at a brief example this is a case
where we're doing something very simple
we don't need a whole bunch of
abstractions we don't need an actual
implementation of a Dao all we're really
doing is treating the entity manager API
as as the Dao
so we're injecting the entity manager if
we need to find an object we simply find
it by ID you know if you need to process
something it's e/m dot persist
um dot merge as you can see pure
operation just a one-liner you can't
really abstract much more than that and
it's not necessary in this case your
entity manager is you're effectively
your Dao okay details are a bit of an
interesting case again in modern Java EE
applications you don't actually need ADT
or per se so before we get to that let's
get to what ADT o is a dt o stands for a
data transfer object
okay so quite naturally where this comes
into play is when you are crossing
system boundaries okay so a classical
example would be a restful web service
okay so you're invoking restaurant web
service from one one
application to another application well
what are we gonna do with 15 minutes
song-and-dance
okay so okay so we have let's say we
have a remote restful web service okay
invoking your service from one point one
endpoint to the other and then what you
have on each of these endpoints is Java
bindings so you have the wire format
whatever that may be usually these days
it would be JSON but at the end of the
day if you're talking about
a Java client and a Java server both of
those would have corresponding Java
objects okay that you ultimately
transfer on the wire to some other
format that artifact is a data transfer
object okay that is that is its its
purpose okay that is its purpose in life
and hence it deserves its its own
pattern name now again in very
simplistic or rather in well-written ok
Java EE applications you actually don't
need to necessarily create a separate
artifact called something DT or like a
customer detail because in many cases it
you can simply perhaps treaty or entity
as your Dao okay you can simply transfer
the entity as is over the wire without
any problems didi use your entity as as
Aditi oh yes great right so but that
that won't always work okay so in many
cases you may want we want you may want
an actual abstraction layer okay so this
would be a good example of this would be
if you have a very complex domain object
okay and you're only for a given web
service you're only publishing a small
subset of that of your entire domain
object that's when you would actually
create a specific DT object generally
speaking the intersection between D tos
and Java EE is that you see Allah is
Java EE allows you to declaratively do
the serialization of ADT oh so it
recognizes the purpose of the DTO object
and it allows for some annotations that
you can
there to make that civilization okay
remember that's the whole point of
creating and Ito in the first place
happen so here's a brief example so
let's revisit our entity class and
assume that you know we're lucky enough
so that we don't need to actually create
a a separate DTO object we can simply
use the entity as a DTO
but still though we don't want to
publish out some of these objects some
of these values for example a client
probably doesn't care you know what what
the idea what the internal database ID
of this implementation detail on my side
is okay they probably just care about
first name and last name and you know
they were when they send me the last
first name and last name or you know
it's my job to figure out how that maps
to an entity so the way you make this
happen is simply you know let's take Jax
Jax B as an example let's assume we're
creating an XML serialization of this
DTO so what this happens is you simply
say XML root element and that makes it
makes Jax be recognize this object as a
DTO essentially you're in this case the
default access is method okay we're
changing that to be field fair enough so
basically we're going to read through
all of our fields and not look into the
access service mutate so we get a
getters and setters and simply you know
push out whatever properties that I may
have in this case well in this case I
definitely do want the first name and
last name to be to go out and that's
what's going to happen by default I
don't remember I don't want the ID to be
published serialized so you can simply
say XML transient and that will stop
that the ID field from being serialized
out you know as a DTL okay finally
domain-driven design roth you want to
cover this one okay
mmm Tomas with you know right I don't
see that happening I mean I've been
developing java ee now since Java EE 5 I
have seen very little case very little
reason to use anything else other than
JPA so JPA is all you're using why
introduce this other abstraction that
you need to maintain from then on so I'm
not saying that what yours what you're
saying doesn't occur okay all I'm saying
is don't assume that it'll look her okay
sure all right anything else and
actually if your few more questions
entities and details you can also use
the transient annotation so some parts
just are translated to XML but isn't
written into the database and voiceover
sir other question you cannot know Jax
we just don't recognize that yeah
transient it has nothing to do with this
yeah that has to do with objects for
serialization in the Java native
civilization okay
in fact by default yes he would yeah
because that minimizes code duplication
in the end yeah so why creating
unnecessary obstructions if you're never
going to use them it's just wasteful yes
yeah precisely yeah you can do so yeah
in this yeah exactly what's going on
here we're using this as probably for
multiple purposes you know we're using
it in the view layer of JSF we're using
it for persistence persistence the data
and we may be using it as additive as
well yeah imagine the wasteful I mean
this is called cargo cult programming
have you heard the term there's an
interesting little graphic but basically
using something without understanding
its actual purpose leading to sort of
nonsensical usage you know in this case
probably unnecessary artifacts that you
don't need in your application right
exactly yet more yet more code
duplication yet more bag as you sort of
had to carry forward with your
application yes sir yes that was the
point yeah that was the point I I know
we haven't done a great job of the
flushing out the entire remember this is
bonus material but again yes yeah that
was that is really what we're trying to
describe here yes yeah the simple way of
doing so in Jax be yes sir
I didn't quite follow the question yes
so look into a Eclipse link no sequel or
hibernate OGM okay all right
so let's you know sure let's cover
domain-driven design I was doing
facetious because the reality is you you
can't cover domain driven design in five
minutes okay it's it's its own talk in
fact it's a talk that I gave last year
in this very same room ironically but
sits on one right now right anyway okay
so here's our best shot at explaining
domain driven design here's the
explanation look it up that was supposed
to get you anyway alright okay so
besides all of the things that we talked
about some of the things that we're
talking about is actually somewhat
old-fashioned okay so principally we're
talking about Gang of Four patterns and
and j2e core patterns okay that's what
the patterns that we described by and
large that's what that's where they're
coming from there's actually a whole
different world called domain driven
design that takes all of these ideas
puts them together and puts them in
newer more modern cohesive fashion okay
so these are some other design patterns
that you should look into there I've
accidentally slipped and actually
mentioned those patterns in my facade
when I was describing facade and those
would be things like application
services okay entities are entities in
in either world repositories are nothing
much more than more fine-tuned more
sensible daos
slight differences between daos and
repositories don't let anyone tell you
that if you just rename DAO depository
you're done you're not and there's also
something called value objects okay in
addition to entities it's an extension
of sort of the entity concept there are
again Factory is another recognized
design pattern and in domain driven
design and if there's a few others that
I won't talk about principally we want
to put this here
so you should look it up so there's some
interesting patterns there and again
they mapped it very they map quite
nicely to Java EE because Java EE has
those same concepts in them including
things like value object and small
certainly Factory and the like so that
part was more like a homered so you
should go home and study here okay
you can't that's that would be a
legitimate reason to create two separate
details okay yes sir my opinion on that
is you should use what works best for
you okay for me and domain-driven design
works best for me I like to have the
business logic very close to the data
itself okay so I want the data and the
business logic that operates on it in
the same place it's I find it more real
more maintainable in a more logical
place to look at those objects and it
makes it easier for me to communicate
with my developers when I'm talking
about the domain model I don't have to
say oh customer entity and look in this
other little service that has this
business logic in it okay
I can simply say we'll look up look it
up in the in the customer and it's
entity it's in there if you don't like
that way for some reason you know one
reason would be that this way is harder
okay you have to do a lot more analysis
upfront and continual analysis to make
this happen - really because at the end
of the day this is what object
orientation is about right and it's not
easy you know object orientation doesn't
come for free it implies analysis and
thought if you don't want to do that
simple way is my entity is just to
represent dumb representation of a row
in my database table my I'll just stick
all of my business logic in the
application layer I don't have to do any
analysis who cares about all that stuff
that's yet another way of thinking about
it all right okay
you know yes so you need to be aware of
those problems but they don't impede you
from using entities in them in the
presentation tier so you need you need
to be more aware of you know using
things like producers in a proper way
using scoping in a more clever way and
and you can get around those problems
those are not showstopping problems they
are hiccups but you know there's no
unfortunately no elegant solution just
resolving those lifecycle issues you
know you just have to be aware what's
going on and you know simply add a
producer to be honest with you yeah okay
yes sir that I think is carrying the use
a bit too far I do see value in MVC and
it's separating what you would wind up
doing there is essentially mixing the
presentation tier with the transaction
tier I'm all for getting rid getting rid
of unnecessary cargo track art or
artifacts but I I think that that just
goes a bit too far okay any other
questions so what do you think would be
in a book I think that gentleman over
there right yeah okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>