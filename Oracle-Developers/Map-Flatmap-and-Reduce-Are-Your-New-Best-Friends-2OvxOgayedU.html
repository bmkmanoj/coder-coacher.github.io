<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Map, Flatmap, and Reduce Are Your New Best Friends | Coder Coacher - Coaching Coders</title><meta content="Map, Flatmap, and Reduce Are Your New Best Friends - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Map, Flatmap, and Reduce Are Your New Best Friends</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2OvxOgayedU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it's great to see that so many of you
have survived the week survived the
Oracle party and the shown up for the
last session of the day to learn about
functional programming which I kind of
would imagine you've heard quite a lot
about this week given the lambdas and
streams which are inherently functional
or a big part of Java eight just kind of
been the big new thing at Java one so
this is sort of my take on functional
programming and my goal is to show you
how in various different diverse aspects
of programming functional programming
can make your life a whole lot easier
make your code a lot simpler now I'm
really going to do that through the lens
of three sort of functions map flatmap
and reduce which kind of are at the core
of functional programming and you're
going to see how they're actually
remarkably versatile you can use them in
all kinds of different use cases so but
before I talk about that a little bit
about me so Graham Chris Richardson I
got my start programming long long time
ago in the 80s building Lisp systems
compilers runtimes garbage collectors
Ige's and so on
Lisp of course being one of those really
early functional languages and then it
also became object-oriented as well and
then eventually I ended up in the Java
world and back in 2006 I wrote the book
pojos in action which is all about how
to build applications with spring and
hibernate which you know played a major
role in transforming how we do
enterprise Java development today and
then I back in 2007 I started tinkering
with its obscure little service called
Amazon's elastic compute cloud and of
course cloud computing has sort of
exploded these days and I created a
startup Cloud Foundry which was a Java
passon on Amazon ec2 and that got
acquired by SpringSource shortly before
spring sauce was acquired by VMware it's
that charming picture of the fish the
Cloud Foundry was much more of a
plankton than a than a
sort of fish otherwise I'd be fabulously
wealthy now so you know I was at VMware
for a number of years and these days I'm
kind of doing two things doing some
consulting around sort of new
technologies no sequel micro services
and so on also working on a stealthy
kind of sort of cell stealthy startup as
well there's you know highly buzzword
compliant so here's the agenda so first
off going to talk about why functional
programming why should we care about it
what are the benefits and then I'm going
to look at four different very diverse
areas and show how functional
programming can really simplify the code
that you write so first going to look at
collection processing because you know
to me in many ways to me collection
processing is sort of the gateway drug
into functional programming then what's
going to look at how functional
programming can eliminate null pointers
from your code look at how functional
programming can make your concurrent
code incredibly simple and then then I'm
going to finish up by talking about how
functional programming applies to Big
Data which of course is you know one of
those big top big hot topics today okay
so why functional programming you know
what is it what why should we care so
you know first off functional
programming is a paradigm the big idea
is that with object-oriented programming
we build our code out of objects or
strictly speaking classes while in
functional programming you build your
program out of functions those are the
building blocks and you can actually
write any functional style in any
language of course it's a much easier if
you use a language that's designed to
support functional programming but I
think because in a language like that
functions are actually first-class
citizens you can assign them to
variables you can store them in field
they're just values functions are just
values just like in source strings or
any
or object references that you create and
then interestingly you can pass
functions to other functions or methods
so you can actually pass in a little bit
of behavior that the function you're
calling can then invoke whereas it sees
where it sees fit and also you can
return a function from another
functional method and the whole passing
returning thing that kind of is the
concept of higher-order functions and
those are really a key way of
structuring your functional programs in
fact map flatmap and reduce are all
examples of higher-order functions and
that will become concrete in just a
minute and then another big idea in
functional programming is that it avoids
mutable state so you have immutable data
structures basically all of your fields
are final you have final variables as
well and in fact some functional
programming languages don't actually
support side-effects so there's the
class of pure functional languages like
Haskell where you simply cannot have any
side-effects which leads to all kind
very interesting programming style and
you can build real up with real world
applications using it but you have to
jump through a few hoops so that's kind
of the essence of functional programming
functions are the building blocks of
your code your code is mostly working on
immutable data so why is that important
I want to go back to this guy so this is
Tony Hoare who's the very famous
computer scientist he's actually he's
one of the inventors of I think
quicksort he also invented Algol 60 back
back obviously in 1960 which was a very
influential programming language that's
sort of like one of the ancestors of
Java and C and so on and he said that
you know to him the highest goal of
programming language design is to enable
the elegant expression of good ideas and
that's kind of the essence of functional
programming it actually enables you to
express solutions to programming
problems in a very elegant
functional codes more expressive tends
to be more concise tends to be more
intuitive in the sense that the solution
actually much more closely matches the
problem and then also functional code
tends to be composable which means we
could take two modules written
independently and combine them together
in a program and it should just work
whereas that's not always the case in
other programming languages where you
might have like global variables and
other or even worse things like monkey
patching and dynamic languages like Ruby
that really just get in the way makes
you really get in the way of writing
composable code and then also a mutable
code immutable state tends to be lesser
error-prone tends to be much more easy
to parallelize which I got a great
example of that later so there's sort of
a whole bunch of reasons why functional
programming is has some benefits it
turns out that it's actually a very old
idea you know it's kind of it actually
one of the most ancient ideas ever so
the lambda calculus the mathematical
foundation for functional programming
was invented back in 1930s before
computers Lisp which is a which was I
guess might have been the first
functional programming language was
actually invented in 1958 can you
believe that you know had functions had
recursion and things like that
Lloyd garbage collection things that you
know took mainstream languages a very
very long time to to get and in fact my
final year project to college which was
way back in 1985 was implementing a
language called a functional language
called SAS all fascinating little
language like here's how you can
calculate primes and it starts by
pulling the function sieve with a list
of all integers starting from two so
you've got an infinite list and that it
recursively removes multiples of the
head of the list from the tail of the
list
so we're sort of dealing with an
infinite data structure here but it's a
lazy language so the list does never
ever gets instantiated fully into wood
until you actually start asking for
elements anyway so I implemented that
that language that language is may
finally a project in in Lisp
so it's sort of two functional languages
there and then but you know for the most
of sort of computing history functional
languages have sort of been off in this
ivory tower they've been very academic
and so there's languages like Miranda ml
and Haskell which in academia have sort
of seen very a widespread adoption over
the years but they've been very pure you
know there's a school of thinking that
if you have side effects in your code
that will kill kittens and puppies and
that that's sort of that that kind of
purist thinking is somewhat kind of got
in the way of of adoption so much so
that there was this joke back in 2010
that the haskell community was excited
that an industrial programmer actually
cared about their language it's not
exactly as a slight exaggeration but the
you know it's sort of just kind of off
there in this sort of ivory tower land
but what's fascinating today is that now
functional programming is mainstream
right so there's closure which is a
dialect of lisp that runs on the JVM the
Scala which is you know quite a popular
hybrid functional object-oriented
language that's seeing a lot of adoption
often net LAN there's F sharp which is
another functional oo language and then
of course Java eight which is you know
the thing for this conference has lambda
expressions so you can write functional
programming in an incredibly widely used
mainstream language and that that's
really cool so you know if you have a
quick look at what about what are these
lambda expressions in Java so they're
basically sort of function literals
they're concise ways of expressing a
function you know and
they're not too dissimilar from
anonymous in anonymous inner classes but
they're incredibly concise so hopefully
you can read that so on the screen is a
function that takes one argument and
returns the square you know here's
another lambda that takes two arguments
and returns the sum of the squares and
then here's a more elaborate lambda that
actually determines whether it's argue
argument is a prime number or not
so you've got little we've got a very
concise way of writing functions which
we can then pass into methods we can
even store them anywhere where a
functional interfaces that is expected
an interface that's got one at one
abstract method you can pass in a
corresponding lambda expression and so
we've got this ability to write
functional code in Java eight which is
really exciting now what we need to do
is convince management that we can
upgrade from Java five to Java eight
right and WIPP we will be all set so
let's look at one use case just to sort
of illustrate why we should care about
functional programming so you know you
think about the code that you write on a
daily basis an awful lot of it has to do
with collection processing collection
you can think of a string even as a
collection of characters what a jdbc
resultset is a collection of rows you
know in addition to lists and arrays and
so on so you know most of programming is
manipulating collections of things in
some way and to me there's sort of three
fundamental operations that we kind of
want to do with collections so one is
mapping where we want to transform apply
some function to each element of a
collection to build up a new collection
another key operation is filtering where
we want to select a subset of the
members of a collection and then the
third case is reducing where we want to
sort of take a collection and then
combine elements pairwise to yield some
kind of scalar value such as summing
if you've got a collection of integers
summing summing them or computing the
average those are all examples of a
reduction operation and to sort of
illustrate this kinda go I'm going to
show the old way of doing it the old
iterative way with four loops and then
it's then show the nice functional way
I'm going to use a social network
example so you have a social network
that's a collection of people and then a
person has some fear attributes agender
a name a hometown a birthday and of
course they have some friends they have
a set of friend which hopefully is not
empty and a friend really is just a
reference to a person plus the date that
relationship was was established all the
time they became friends within the
social network so if we look at you know
an example of mapping so here's an
example where we want to get the
hometowns
of a person's friend so you know pretty
this is a typical collection of a
typical example of collection processing
code where we define a result variable a
result so we've got this empty cut we've
instantiate an empty set in this case
and then we have to iterate and then we
add some we add we modify the result in
some way we add an element so we're
adding the friends hometown and then we
return the result you know it's pretty
standard pattern so that's an example of
mapping where we're going from from a
person's friends to the friends hometown
to us to a collection of their hometowns
you know here's an example of filtering
so we wanted we got a social network and
we want to find all the lonely people
and so we once again we build it we
specify a you know result collection we
iterate through the input collection and
then for all of the members that satisfy
some predicate in this case are their
friends empty we add that person to the
result and which we return and that
patterns kind of is very similar to the
previous pattern except there's a little
bit of conditional logic in that
and then the final example is reduction
so we want to find given a person
we want to find the average number of
friends that each person has so here
once again we declare you know we
declare a result variable except in this
case it's a scalar value it's not
another collection we've got the same
old iteration and then we're modifying
the results in this case we're just
adding up adding to the result the size
of each person's friend collection and
then we divide it by the length another
number of people to get that get the
average so we've sort of seen you know
there's a standard pattern define a
result iterate modify the result return
the result and that's pretty typical
iterative code and we just write that
kind of thing over and over again right
probably this is that you know there's
an awful lot of a boast boilerplate for
doing basic stuff you know at least five
lines of code just to map over a
collection or to filter the elements so
there's a lot of bloat here also this
sort of style of programming doesn't
really it's very iterative it says what
we tells the computer how to do it
rather than sort of abstractly saying
what we want
also we're mutating variables or
mutating data structures which in these
simple little examples is not a problem
but when your code scales up that that
can be a problem and also this code is
difficult to parallelize if we were to
try and paralyze any of those algorithms
to work on large data structures the
code that we would write actually would
look very different than that sort of
simple for loop so what can we do about
it so this is you know kind of a big
motivation for the streams concept that
that's now been added to Java 8 so
basically a stream is a sequence of
elements so it's you know collections
all about storing elements and giving
you access to the elements streams or
more JustGive processing one element of
the stream at a time you can create a
stream from a collection so you can you
know just cool dot stream on a
collection you
get back a stream of its elements and
streams are actually lazy they can
actually represent an infinite number of
infinite stream of values if when
necessary so which means you can write
code and some interesting ways but
what's really important is that streams
give you this sort of functional lambda
based interface for manipulating the
elements of the collection basically for
transforming or in other words mapping
collection elements filtering collection
elements and then also aggregating them
doing the reduction so in and it lets
you write code that's a lot simpler a
lot more declarative so if you look at
the you know the forensics are poor
revisited so in know for loops anymore
so instead what we do is we get the
friends we get the stream from that
friends collection and then use this map
method to transform each element so map
is a method that takes a function as a
parameter and creates a new stream by
applying that function to each element
of the input stream so in this case
we're just getting the hometown we're
going through the stream mapping over
the elements getting the hometown of
each friend and then there's this dot
this collect method which is in java 8
how you turn a stream back into a
collection so we're using the built-in
collectors to set method to do that so
you go from a stream we try we go from a
collection to a stream we transform the
stream and then we turn the stream back
into a collection and later on you
actually see where you cannot perform
multiple operations on the stream before
turning it back into a collection
unlike in Scala where you can just map
over a collection directly and you get a
collection there's an output Java eights
a little more verbose but it's a big
step forward so if we look at that
visually you can see see we've got an
input stream we map over and then an
output stream and each element of the
output stream is f applied has
F is f applied to the corresponding
inputstream element so that's quite nice
mapping you know codes got a little
simpler just more declarative so then
filtering is the other example right
where we want to find the lonely people
so we take the collection of people turn
it up turn them into a stream and then
we then we use the filter method and
that takes the input stream builds up an
output stream containing those elements
of the input stream that satisfy this
predicate so in this case the the lambda
we're passing in is returns true if a
person is does not have any friend
so it is cool is empty so once again
that's quite nice later on you can see
how we can map and filter go stream map
filter and then collect and in one go so
the codes simpler and then I want
another interesting example is how can
we get the friends of friends so here's
the first attempt at doing that so take
the friends turn them into a stream map
over each friend and get the friends of
friends and then turn that back into a
set so that's not bad except that it
gives it gives you a set of a set of
friends so we've got this unnecessary
two layers of nesting of sets which is
kind of unfortunate and what we actually
need to do is flatten but what's nice is
that there's a version of map called
flat map that actually does the
transformation and then flattens by
concatenating the elements together so
here's the example of that so instead of
map we're doing a flat map and so that's
actually getting the friends so that's
we're passing into that method a
function that returns the friend stream
of the friends of friends or fret
friends of that friend rather and unlike
map what flat map does is basically
splice those those elements into the
output stream so there's this sort of
flattening going on at that point so we
end up with a stream of friends and we
turn each then we map over it to turn
each friend into a person then use
filter to eliminate this this this
person because they'll you know if
you're a friend of a friend of a friend
it is kind of like you end up back at
yourself and then we turn it back into a
set and so there it kind of a good
example of using flat map but then also
chaining map and filter to accomplish
the task and visually this is what flat
map looks like so it basically takes
each element of the input stream applies
F to it which returns multiple elements
and then concatenates all of those
together to form the output stream so
it's very powerful and then here's an
example of reducing so combining the
elements of a stream to guild some
scalar value so in this case we're
taking the people out of a social
network mapping over it to get the size
of the number of each person's friends
so that gives us a collection of
integers or stream of integers I should
say and then this code uses the reduced
function to kind of add them all up and
the reduced function works by taking an
initial value and a binary function and
applying the binary function to the
initial value and the first element so
it's zero plus the first first element
of the input stream and then that yields
the new result and then it takes that
result and the next element of the
stream and invokes that function and so
it kind of runs down the stream just
kind of a good cook applying that
function to all of the values so
visually it looks like this so you can
just see we're just a you know we apply
F to the initial value in the first
element then we apply F to the outcome
of that in the second element and so on
and so forth and that you know is a very
generic way of expressing operations
like some for example
so that's quite nice so with just these
few basic mobile functions or methods
map flatmap filter reduce we've got some
great ways of manipulating collections
and kind of wanted to just illustrate
this really quickly so if you've ever
looked into how to calculate a square
root it's actually in an iterative
algorithm where you kind of guess the
value you guess what the square root is
and then there's a there's a function
you apply to actually calculate a better
approximation to the square root and
that you keep iterating until the
difference between the old the last
value and the new value is is sort of
less than some target precision so you
can imagine expressing that as a for
loop we're just iterating until till the
until it actually converges but you can
actually express that in a functional
style so this is actually in Scala that
the Java eight one is not too different
where there's an iterate function that
takes an initial value and then a
function to apply and then gives you a
stream of values out that's sort of the
initial value then the function applied
once to that initial value then the
function apply twice to that initial
value and so on so you get progressively
better and better approximations to a
square root and it's an infinite stream
but then the trick is well when do I
stop right how do I figure out when I
can stop and Scarlets got this really
cool function called sliding where we
can actually grouped together pairwise
elements of adjacent elements of the
stream so we can actually then compare
them to see whether the delta between
the one element and the next element is
within some kind of precision value so
we kind of end up just finding using
fine to search down this infinite stream
of values to find two values that have
converged and you know once you get used
to this style it sort of ends up kind of
being a pretty clean an X
recive way of writing code and what's
nice with in java 8 is that you canyou
you can start doing this immediately the
biggest barrier is actually switching to
Java 8 right you know in some
organizations that's a challenge but
once you've done that you can just you
got your existing application whenever
you touch part of it you can just store
add new functionality you can write that
code in a functional style in the old
way and the new way just happily coexist
then apparently eclipse can actually
refactor your code for you so oh yes
so should probably save all questions
until the end but I will just address
that so on the previous slide I used the
sliding feature and unfortunately that's
in Scala and not not in Java 8 the Scala
streams and collections have actually a
much richer interface and do the same
thing in Java you'd actually have to
keep have a variable that would play
keep track of the last value you looked
at unfortunately but anyway so adopting
this is sort of pretty straightforward
right or if you wanted to you could
adopt scholar and write some service
write modules of your application in
Scala and actually still run on much
older JVM so there's a couple of
different ways we can go about adopting
this technology all righty so you know
switching gears want to talk about
something completely different
eliminating null pointer exceptions so
going to go back to this guy Tony Hoare
and he cool he's actually responsible
for null null pointer exceptions in our
code because when he was designing Algol
W back in 1965 which was one of the
first languages to introduce the concept
of a reference he thought well let's
just let these references be null
right and our programs have been
crashing ever since that day you know
segmentation faults or no pointer
exceptions or so on you know it's very
common to write code like this so here's
some code it finds the longest it's a
method that returns the
longest friendship of a over person and
so we just kind of iterate and of course
if there are no friends it will actually
return null right it's common to return
null if we don't have a value this thing
was not found right which is you know
okay if we remember to always check that
that return value is no but of course
more often the note we don't and then we
got our code blows up with a
nullpointerexception
so Java eight has a great way of
addressing this it's got this optional
type and in Scala it's option in a
Haskell it's maybe and it's really a
wrapper around things that are null or
things that are not there and it's
actually so no an option value has two
states is either empty which means
there's sort of nothing or it's non
empty which means in this in Java skates
it contains a non null reference and so
the idea is that you should change the
code that you write instead of returning
a nullable value you return an option
type as well which tells everyone this
this method is returned might return no
value and so it's just and then there
are various methods for manipulating
optionals that are a look at in a minute
and then conversely if you have a
parameter that can be know to say it's
sort of you don't have to supply it make
it an optional so that so anyone can
actually see oh yes this really is
optional so what we're doing here is
really using the type system to express
the null ability of our values so big
step forward with sort of making
everything much more explicit so here's
how we might use it with with longest
friendships so what we're doing here is
returning an option with a friend and
that the return statement you can see it
is doing optional of nullable which is
actually returns an empty option if it's
null otherwise it returns a non-empty
option if it's not null and then when we
cool
when we use this method we know that we
get back an optional so we know that we
have to do some checking I mean we could
just get the value out of it but that's
sort of been turned
you know a nullpointerexception into a
no such element exception I mean we have
to deliberately write bad code rather
than just forget but really you know so
it's it's a little bit better and if we
want we could test so if the person if
the optional is non-empty then get the
value else not so it's sort of you know
it's not it this is not bad but it turns
out we can do a whole lot better than
just that like we should avoid calling
is present and get almost entirely
because there's a whole bunch of
interesting methods on optional such as
or else so common case is we get an
optional if it has a value we want to
use that value otherwise we want to use
some default value so in this case you
know someone want someone needs to make
you know call for help so they call
their oldest friend and if they don't
have a friend then they call their
mother right you know it's a variant of
that called or else get that actually
takes a lambda that and then that lambda
is cooled to go get the value it's that
sort of a late lazy way of get computing
a value or you can actually cool or else
throw so if the if the lat if the
optional is non-empty you get the value
out of it otherwise it will just throw
an exception so it sort of got a cleaner
way of dealing with at the empty case
then it gets better than that we can
actually map over them so here's an
example where we want to calculate the
LTH difference between the person and
their oldest friend right and of course
the oldest friend is could be empty
ordinarily we'd sort of have to write a
bit of conditional logic to handle that
but we can actually use map whoops we
can actually use map I don't have it
highlighted where so we get back an
optional we can then map
for it and if and the mapping over an
empty optional doesn't invoke the
function it just returns an empty
optional otherwise it invokes that
lambda width with the contents of the
optional so in that case then we can
means we've got a got a friend and we
can calculate the age difference so
that's kind of nice let's just sort of
transform without having to write all
the tedious conditional logic to check
whether there's a value and then there's
a way of chaining as well using flat map
so flat map takes a function that's
cooled with the value out of the
optional if there is one but then
instead of just returning another value
to put into the output optional it
actually returned this function returns
another optional so if in this example
we're finding the longest french the
longest friendship of the longest friend
which actually is not a sort of
symmetric relationship and in both you
know so the first one could return an
empty optional in which case we don't
map over it but then if it does we cool
the friends longest friendship method
which itself returns an optional but
with and then the overall result is
optional frame so it's kind of a nice
way of chaining together functions that
return optionals without writing a lot
of conditional logic you know that if
you were to do this the old way we'd
have lots of it if that else is in our
code so things are definitely got a bit
better alright so that's that's we
looked at collections we've looked at
optionals kind of want to quickly look
at concurrency yeah which is in yet
another area which is very different
than the first to the map and flatmap
applied apply to so
kind of first thing to note of course is
that streams give us a Jerry cheap
concurrency mechanism so imagine we want
to perform CPU intensive operation on
the elements of a stream what's really
cool about lambdas is that we can write
instead of writing this we can write
that turn it into a parallel stream
which in some cases might actually be
many times faster than than the doing it
serially you know we leverage multiple
cores
what's tricky is determining whether the
overhead of doing all the parallelism
out ways that the performance speed-up
so I just wanted to throw that out there
so that's sort of cheap you know another
benefit of functional programming is
cheap parallelism in some situations all
right but let's get back to you know map
and flatmap and so on so let's imagine
that you're writing code and you want to
display the products and a user's
wishlist right and the you're writing
some web web front-end code that needs
to make some web service calls so it
first needs to cool the user profile
service to get the list to get the wish
list that has the product IDs and then
for each one of those products we need
to go get the product info so this sort
of like cool one web service and then
make end cools to some other web service
and you know in the second step we could
get the information for product one when
we get when that returns get the
information for product to do it
sequentially but that's likely to take a
really really long time so we kind of
want to get all of the product infos for
all of the products in just one go right
so we need to do things sort of in a
concurrent way so you know get the wish
list and then get all of the products it
concurrently and this is a very common
problem where we sort of got some you
know composing all this concurrent code
some things we need to do sequentially
some things we need to do concurrently
and it turns out that features are a
great abstraction for that features of
course you know they've been in Java for
quite a long time I think they were
first invented back in 1973
and sort of the way they work of course
is you've got some client that initiates
some asynchronous operations right so it
does this in this example it initiates
two asynchronous operations one and then
in both cases futures get created and
the future acts as a little box that the
outcome of the asynchronous operation
will eventually appear in so when the
asynchronous operation completes either
successfully or unsuccessfully an
outcome a value or an exception appears
in the future so you know they can
appear in different futures at different
times but then the client can get the
values out of both of them so it's sort
of a way of kind of you know initiating
some asynchronous operations and then
communicating with those asynchronous
operations to get the result and it's
very good for sorting for implementing
scatter gather logic but the problem you
sort of get into is that kind of writing
that logic at least with futures how
they exist in Java seven really was
quite unpleasant because number one the
futures basically have a blocking API
the only thing you can do is call get
with a timeout with not possible timeout
and that blocks the client the client
threads that really kind of impacts
scalability and it really doesn't scale
to sort of more complex ways of
composing futures together so there are
some libraries on top of Java 7 that
give you futures with callbacks so
instead of you having to ask the future
do you have a value yet the future will
actually evoke a callback that you
specify to say here's the value and on
the one hand that's good that means we
can write some nice asynchronous
blocking code non blocking code the
downside is the cool box you know if
you've done a lot of JavaScript you know
how sort of tangled and unpleasant that
code can get but what's really nice with
our Netflix they have an article about
this you can you know slides will be
online so you can look there what's
really nice is that there's a different
kind of future functional futures
which into in spin and scholar and now
they're in a form of them are in Java
eight the RET they you do this in quite
in a quite a different way so this is
some scholar examples and later on I
have a quick example of Java Java 8 but
Scala futures have a map operation and
basically map take you know see you call
future map passing in a function and
that actually gives you back a new
future containing the result of applying
that function to the value that
eventually appears in the input future
so it's a way of just sort of
transforming futures and this is
happening asynchronously and then
there's also flat map which kind of
follows the pattern of map in this orb
we've seen before where it takes a
function as an argument but that
function doesn't return a value in this
case it returns another future so this
lets you whereas with option we saw how
it let you chained together functions
that return options this is letting you
chain together
operations that return futures so we're
just cool async plus to add together
five and eight to give you 13 and then
when that completes it will actually
cool async squared that will eventually
compute them this 169 so map lets you
transform flat map lets you change chain
and all of this is happening
asynchronously so when you use map for
example it returns immediately in our
new future but then it ranges so that
when if input future is completes the
function will be invoked on the outcome
one the success value to compute a new
value which will then appear in f2 so
it's all happening completely
asynchronously
so that that's pretty cool so if we go
back to the list service because either
both work with math and flat map it lets
you kind of chain together and do some
very interesting
in composition with your futures so
hopefully you can read that so here's
the wishlist service so first thing
we're going to do is a synchronously get
the user profile so that's going to
return back a future containing a user
profile and then we're going to map over
it to turn the user profile into just
the wishlist because we don't care about
anything else so that gives us back a
future containing a list of Long's and
then we're going to map flatmap over
that so we're going to take the product
IDs and then we have to make all of
these asynchronous calls in to get the
product info so we map over the list of
product IDs that gives us a list of
futures a product infos so you've got
lots of bit of nesting going on here and
then there's a really cool thing we can
call future dot sequence that turns a
list of futures into a future containing
a list so it waits for all of the input
futures to complete and then takes the
values out of all of those input few
chisholm and makes a list out of it so
we've kind of caught off you know made
all these course the product info
service and then we're actually wait
then we build up a new future that's
going to contain the list of all of the
results and we're doing this in a nice
functional way and then we can just map
over it and we've got we built a
wishlist object out of the list of
product IDs so you know once again once
you get used to this style of coding
it's very clean it's very concise and
you know doing this in it and some cool
back based approach would just be like
you know spaghetti code Java 8
interestingly has has has futures that
behave like this except that the methods
are not called map and flatmap
unfortunately for some reason they have
totally different names all right and
also Java 8 is missing future dot
sequence unfortunately so this code down
here is actually kind of doing the
equivalent so it's a little more complex
okay so futures you know they're very
old very powerful
or when their functional way of doing
concurrency they hide all the threading
all of the asynchronous nature of your
code but there's actually a new new
mecha new kind of approach called
reactive extensions and while ago Eric
Meyer who invented reactive extensions
at Microsoft wrote this great article
whether what was great was the title
your mouse is your database and what
that does is that it captures the idea
behind reactive extension so they were a
dotnet project and what it did was
represent event streams as could be
coming from your mouse right as this
abstraction called an observable and
then they took them the operators from
Microsoft Lync which is their data
access technology that's sort of this
functional way of accessing database and
use those to manipulate event streams
hence your mouse is your database so
they've kind of merged asynchronous
event handling with function with sort
of functional data program percept
programming to yield this concept of
reactive extensions and that's what the
words on that slide say now of course
that was off in dotnet land right and
you know I'm a Java developer don't
really pay attention to that but what's
really cool is that a few years ago
Netflix
started implementing rx Java so that's
an implementation of reactive extensions
for the JVM and there's adapters for
scala closure and groovy so that's cool
and then it's actually been embraced by
more of the community and there's this
whole reactive streams project that's
sort of a kind of abstraction of
reactive streams so it's very exciting
and the big idea whether idea behind
them is really simple you really got two
main abstractions you've got observables
that represent a list of items and then
you can subscribe to the with two two
and observable and you supply an
observer and that observer has three
methods
next that's cooled when there's a new
item uncompleted that's cooled when that
stream comes to an end because you in
some scenarios you might have a finite
stream of events and then also on arrow
that gets invoked if if some kind of
exception happens and that's kind of the
core of it
so in observable representing an
asynchronous stream of events which
might be coming from your message broker
it could actually be coming from a mouse
even in UI programming whatever wherever
it makes sense to have event and then
you can just observe it so that that's
kind of the essence of it and you can
kind of think that observable so that
they're sort of like the observer
pattern hence the name except that the
observer pattern only really has on next
the observable adds on complete and on
arrow they're kind of like iterators
except that you're being except that
this is push rather than pull because
you was with iterators you have to ask
for the next value right whereas this is
pushing this is notifying you there's
somewhat like futures and that's
actually why Mike why Netflix originally
implemented rx observables they wanted
an implementation of futures that were
better than Java 7 futures and they
didn't want to go the scholar route
because of their particular needs so
they looked at rx observables and
thought well these are like futures on
steroids let's implement those but the
difference is is that as future contains
at most one value whereas an observable
contains a potential infinite sequence
of values and they're kind of like
collections and streams except that
they're asynchronous and you know
they're actually similar because they
are you're going to see they have map
and fly map but that they're actually
asynchronous that there's a difference
so ok so that's the big idea so what we
do with them well here's a really true
real observable that's an observable of
the value minus one contains just one
element you know okay so no big deal
thinking you can make an observable from
a
collection so if you subscribe to that
you would just get on next will be
cooled with minus one and then on
complete would be cool not so
interesting what's a little more
interesting here's an observable that
emits a value every 10 seconds so after
10 seconds at it emits 0 after 20
seconds it emits 1 and so on but we can
combine them together and now we have an
observable and whether then if we
subscribe to it we're actually what
we're see is first minus 1 immediately
10 seconds later 0 10 seconds after that
one and so on and so forth
so we've got this observable that's sort
of doing this time-based thing and under
the course under the covers of course
it's using some kind of timer mechanism
so and that that and then you're
actually going to see that they actually
have sort of collection methods you can
map over them flat map over them fill to
them and that's instead of operating on
a static collection of data things like
filter are acting on a dynamic
asynchronous stream of events which is
really really cool
so this is an example of how I've been
using it so it gosh this codes really
small it's probably unreadable so the
big idea here is that so I've been right
doing some code that uses Amazon's
DynamoDB I've been from specifically
writing code that creates and deletes
tables and what's interesting about that
is that those operations are
asynchronous you create it you tell AWS
to create a table and eventually it will
create one takes can take many seconds
do you actually have to keep polling you
know are you done yet are you done yet
and so the way I kind of abstracted that
is I wrote this method get' table status
that returns an observable that will
eventually contain one value the status
of the table and the way I create the
observable is this is sort of the wrong
way of doing it you to the constructor
you supply a function that gets invoked
with the subscriber and what this code
is doing is eight is calling the
asynchronous AWS SDK to say
describe the table and then I'm
supplying a cool back and if that
operation succeeds so I cool it and if
it succeeds I get the status of the
table I passed that too on next to
supply the value into the observable and
then I say uncomplete because I've got
the value and I'm done and then if I
fail I actually inspect the kind of
exception I've got neither I push into
the observable and not yesterday a not
found exception a status message or I
pass in the exception so when I cool
that I get an observable that will
eventually contain what the status of
the table is and then as I mentioned in
order to find out what the true status
of the table is I actually want to find
out when the table has been created or
been deleted I have to keep polling and
the way I can do that is simply by
taking the ticker stream that's this
every 10 seconds I get a value and flat
mapping over it with this new piece of
code that contains the work and the
returns and observable containing the
table status so you know in the same way
we sort of a pattern here
you know the function that gets passed
to flat map takes an element of the
input collection which I actually
throwing away in this case because I
don't care and then returns another
thing another object that looks like the
thing I'm flat mapping over it so here
I'm flat mapping over and observable and
this functions giving me back an
observable of one element and then all
those elements are can Kadett fective ly
concatenated together and with this I've
just got it I've implemented some simple
polling code that every 10 seconds gives
me the status of my AWS table which is
quite nice and then there's more mundane
things that they mentioned map and
flatmap and so on and you can do some
other really cool stuff like I don't
have time to talk about this but this is
computing the rolling average of stock
trades you know kind of a
common sort of scenario so you sort of
have traits I have an observable of
trades going into the system and each
trade has a price and a quantity and
then what I want coming out is the sort
of a rolling average of the stock prices
of the of the prices of the trades and I
need to do things like group the trades
by symbol because I want to average IBM
separately from Apple right and then
look at sort of this rolling window of
30 second or yeah piece of pieces of the
trade and he can do that in like what's
sort of one slide of code using
observable so I'm doing things like a
group by two separate Apple from IBM for
example and then sort of various sort of
there's a windowing operation that sort
of creates this notion of a rolling
window so every ten seconds it will
start a new window that of trades that
lasts for M seconds and then there's
sort of a fold operation that's doing a
reduction which is like calculating the
average and then I have to flatten
things out because I end up with
observables of observables of
observables in this code example but
just you know once again I mean it's
sort of not not you know I meant to get
the details but it just sort of
illustrates the power of Ray of reactive
extensions when you can write code
that's accomplishing something that's
quite elaborate you know and it kind of
fits on a slide so that's pretty cool
all right so five minutes remaining I
want to write quickly turn to yet
another domain for functional
programming namely Big Data and it turns
out the Big Data is sort of you know
goes sort of hand-in-hand with
functional programming you know for
perhaps for no other reason other than
the fact that big data means scaling out
and functional code is very easily
packed well parallelizable to run on on
many machines or many threads or many
processes or many machine
concurrently so they fit together really
well all right so let's imagine you want
to count word frequencies you know
sometimes it's like this is kind of the
stat word counts like the standard
Hadoop exon pool in a way so here's how
you might do it in scarlet just a small
scale alright so we take a file where we
get the lines in the file which actually
in this case gives you an iterator and
then we can just flat map over it so
we're basically splitting each line into
words because we're flat mapping that's
all guest concatenated together we
actually need to turn it into a list
because an iterator right if I remember
correctly doesn't support group by and
then we're doing a group by so that's
basically applying the identity function
to each element to give you the key and
then turning to and then basically
giving you a hash map where the key of
the hash map is the key which in this
case is the word and then the value is
all of the other words so we get a you
know if a word appears five times you'll
get a the word few appears five times
you will get foo as the key and then of
a list of five foods is the
corresponding value and then we can just
map we can then map over the values of
the list of site map over the values of
the hash map at that point by using the
map values method that basically just
takes the length of each value of each
entry in the hash map so now we just end
up with a map of a word and the number
of occurrences and we're done so it sort
of got a kind of a flat map and a
reduced type operation here and then if
we look you know the Gettysburg Address
the word that here's 11 times liberty
appears once so kind of a real simple
way of just expressing you know how to
kind of doing word counts but how do we
scale this up to a cluster of machines
maybe we've got you know gigabytes of
data and you know we can't do it on just
one machine
and of course the standard way of doing
that today is with with Hadoop you know
which is a open source ecosystem for
scalable distributed computing and the
two main parts of that or the original
parts with a Hadoop file system and this
MapReduce algorithm the way sort of
MapReduce works is that it treats the
input as a series of key value pairs
which could just be the third for text
it's just the offset of the line in the
file and the value is the line and then
those will get fed into mappers that in
each mapper refer every input key value
pair emits zero or one more wrappers and
then we're basically doing the group by
keys so we accumulate all of we group
together all of the key value pairs that
share the same key and we get so we have
a key and a list of values and then we
have a reduced phase that gets applied
to each key and the corresponding list
of values to form to output the output
values and so we end up writing so it's
kind of very functional right we're
mapping with grouping and then we're
reducing except we write code that looks
like this so here's the mapper and you
know it kind of did its doing mapping
and then there's the shuffling and then
we write code that looks like this
that's doing the reducing and it you
know but the thing is the wild MapReduce
is actually incredibly powerful you can
do a lot machine learning algorithms and
so on I mean the code that we're writing
is like really really verbose unit
testing is tricky and also flat map is
basically map a batch disk processing so
it's pretty slow one way of improving
that is to use technology like Scala a
scolding that's a scarlet DSL for and
that lets you write things in a very
functional style like the difference
between you know my original in memory
word count and this is pretty small and
all of this gets turned into MapReduce
jobs so it says concise it's unit
testable but it's kind of slow
so then it's this new technology called
Apache spark where you have what are
called resilient distributed datasets
and these are these things that look
like collections except that they're
partitioned across memory of ultimate of
machines in the cluster and that what's
really good they can also be cached and
they can be replicated for availability
and what's really cool is that you end
up being able to write functional code
that's basically identical to what you
would write for a single machine except
that it gets executed while you can
actually execute and run this on your
laptop unit test it on your laptop but
then you could run it on a cluster of
ten machines and it would just scale out
and process massive amounts of data and
it's kind of the exciting new way of
doing big data and if you can see it's
very very functional in style
okay so I've ran out of time which is
good because I have ran out of torque so
sort of in summary you know functional
programming sort of really does enable
the elegant expression of good ideas you
know flat map map or map flat map and
reduce really are these versatile sort
of functions that let you accomplish a
lot and it's really good that Java eight
has sort of taken the first good step
towards supporting functional
programming so I'd encourage everybody
to go upgrade to Java eight or switch to
scarlet and to go write some functional
code so that's my talk you know you can
find my contact details here hopefully I
have ten new friends on Twitter by the
end by now or please shoot me an email
or you can look at my blog so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>