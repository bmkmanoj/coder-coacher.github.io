<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Functional Programming the Groovy Way | Coder Coacher - Coaching Coders</title><meta content="Functional Programming the Groovy Way - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Functional Programming the Groovy Way</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/AX2v4UTM2Vg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello good morning thank you for coming
this is getting funky with the baby well
actually if you saw the schedule then
official name is functional groovy but
we think we think that this name is much
much better because again this is groovy
right of Connors
I mean Charisse I'm Andrew Solomon right
a little bit about us
okay we're from Mexico that's why you're
hearing our accent but we live in
Switzerland we're the land of chocolate
and cheese and delicious chocolate and
cheese we both work of kill you this is
a smart company
well smallish but we are very interested
in groovy and Java many other things
open-source projects yeah and one of the
things that we do thanks to canoe is be
here in front of you guys speaking of
the stuff that is as part of our passion
so the stuff that you can see right
there on that slide okay so functional
groovy Andres I guess that we should
begin by boiling the audience how many
people here already used groovy yes
that's my kind of people did you know
this already okay hey how many of you
guys actually use functional programming
in other way but it doesn't matter if
it's groovy or not own a few okay okay
all right so hopefully we'll have some
interesting points for you in this talk
and please feel free but we will leave
some time at the end for Q&amp;amp;A but if you
have a burning question in your mind
just bring it forward and we'll try our
best to answer it as soon as possible or
increase the doubt so you know we always
go with making things cleaner okay so
when we talk about functional and
we usually have Scala Clojure anybody
here uses a Scala there's a few hands
pleasure expected a few more but usually
functional programming the JVM these are
the two languages we will say oh let's
use them but still and Java Honduras
yeah well we have dedicated release
finally we have lambdas expressions
since February us in March actually a
little bit late but who is who is lucky
enough to use JDK 8 in production today
ok no you see the problem now yeah
nobody has raised the hand and this is
why we believe that using groovy in a
functional way well I loved you to be
more productive to have more fun if I
can do an overload on the phone aspect
and because well groovy is as available
since 2003 has closure since the
beginning and Ronson's runs in JDK 6 I
think is the lowest maybe even dedicate
5 you're still stuck with Westview but
it's much easier to migrate to than just
tell me your manager let's go everybody
to Jetta gate 8 I will certainly prefer
if everybody will move to JDK 8 as soon
as possible but we know for some people
that is not what can be done in in the
next few weeks so functional Ruby is not
a joke
so for those people that know groovy
groovy say dynamic language okay Lisp is
also a dynamic language
Clojure is a derivative of Lisp it's
also a dynamic language okay that's not
a problem but the problem with closures
in groovy is that they are not
side-effect free one of the tenets of
functional programming is that your
functions will take arguments do their
job do not produce any side-effects and
give you a some output and when you call
the same function with the same
arguments you get always the same result
there again no side effects the design
of groovy closures was not thought in
such a way that they will be side-effect
free there are times when you want to
have these side effects and there are
other times when you must avoid it so
when we say you can write functional
programming in Ruby is you have to be
aware some guidelines once you know
these rules within this playground then
it gets much much easier but again if
we're talking about functional provie is
not Haskell yeah don't expect Haskell
this guy he looks like a rock star he's
actually a rock star his rustle window
from the UK he's a core member of the
group a dominant team he is much into
functional programming he is also part
of his member of a wonderful project
that we'll see later in the talk called
jeepers and he knows his way around
functional programming he actually knows
what he's doing I certainly don't
Michelle does but if you're looking for
the purity of a language like Haskell
the other thing that you can look at
inside the JVM is frag if this guy it so
happens that after this talk at 10:30
there is another talk on frag a by Derek
Koenig you might recognize the name he
is the author of groove in action he's
also a Caligula's at canoe he also knows
very much about Haskell and he's
promoting for you now and after three
o'clock we have a No
talk called the emerging languages
scribble where we compare languages such
a free game
Kathleen Ceylon and Mira which also can
apply some functional programming
aspects I encourage you to guys to to
visit that talk if you haven't heard
about these other languages yeah so I
think we can start with a little bit of
closure so for those of you guys that do
not know what groovy is basically the
closures in groovy are functionally
equivalent the two functions so you just
supply arguments they do the job that
gives you some output the syntax is very
similar to land expressed Angelica at
some point it looks like the lambda
expression signal was inspired by the
groovy syntax just because curry was
pretty much it's already pretty much
everywhere you can invoke functions or
pressure well in this talk I'm going to
use functions and closures even though
you know for function is one thing
enclosure is another thing so you can
invoke this function into way either
you just invoke the method called well
the function were just like that
surprised on arguments or you use the
long way which is used a called method
every closure the every plantation of a
closure in groovy has this method and
this method name is a special it will
come back later in the slides and we
will see how we can make use of this
method call in different kind of objects
another thing I want to mention about
this is why is that well we are using
assert in case of GUI we have the power
search if you haven't seen that please
it's awesome yeah again for those people
that don't know groovy the assert
keyword was added to the language really
great for and you have to specify a flag
in order to enable a search well groovy
it says there's no need to enable that
flag we will enable a search for you
since the beginning and what it shall
say the power search we don't have a
working example when we want this
assertion break
well I have a working example I'm really
busy
oh there we go so some code yeah hi Cody
so these are served when it breaks then
you can see that different values so
it's easier to know now why this
assertion fail and as expressions
continue to grow and grow you will see
every single piece every element of that
expression you will see that value so
you will be able to trace back when this
thing or what who in that expression
made the the whole assertion fail
alright just to mention okay so next one
here's an example when we were saying
about side effects we have a variable
that is defined at outside and function
we invoke the function twice and inside
the body of the function we modified our
variable from the outside said sometimes
you want to do this sometimes you don't
if you are really into the purity of
functional programming you want to avoid
doing this kind of stuff okay yes okay
next one because guru B's function is a
dynamic language you can omit arguments
if you wanted at the type of the
arguments if you don't care about a type
then don't use it if there's no need we
believe that if you're thinking about
outside is better if you put it in code
because the first level of documentation
that you have in the code is the code
itself if a teen may doesn't know what
type of this argument is a base or
factor he might think something
different of what you were doing with
this particular function durkani has a
nice sentence about this if I see at
type I type it so it's better to
communicate with types as long as you
need them but the invocation of this
function whether it has type definitions
or not is exactly the same
that doesn't change all right
the American think it's about parameters
is that we may have default values
there's an example of this this feature
can be found in other languages such I
think it's better no no no
PHP any play HP developers in the house
I used to be one yeah it's not that bad
yeah I still have the mental scars
that's what I have a dynamic language
it's also JavaScript yeah I'm coming
like a crazy guy but you can do this
kind of stuff you can define default
arguments for default bodies for an
argument which means that now that
function call either takes two arguments
like we see like before or we can invoke
it with just one argument what will
happen with the body of the second
argument well it's already defined it's
kind of fix what's going to happen in
the other the covers are the compiler
generates actually two methods one that
takes one argument and internally it
calls their body in calls the other
functional text two arguments is is not
really that magical it's just a
convenience for you but there's a catch
default arguments have to be defined
from left to right you try to define a
different argument somewhere in the
middle bad things may happen why if you
leave out the argument types and if you
have much different bodies yes I'm sorry
it's just I'm in the other way so from
from right to left from there today
sorry always it confused thank you so
don't try to put it there so it's from
here today
later we're coming from the other side
of the Atlantic or so so that is right
so this is on the west and West is on
the east is crazy anyway if you do not
define a name for an argument you still
have access to a single argument the
name of this argument is it something
this is nice because these two functions
now are equivalent in behavior one where
we define the name of the argument but
we don't define the type it could be
anything and in this one we just call
the to uppercase method on it looked at
it both invocations produce the same
result if you need to define a function
that takes no arguments at all then this
is the syntax you define nothing there
and put the arrow if you do not put the
arrow then this function still accepts
the eight argument all right it is
important to define this because you may
have nested closures if you do not
define an argument with in a nested
closure then you have a neat argument on
the top closure and a neat argument on
the inner closure and you make a
reference to the eighth argument in the
inner closure who's gonna be is going to
be the effort from the outside or they
want from the inside there is a problem
here with with the scope so when you had
this kind of stuff please be sure to
define at least the name of the argument
if you don't care about the type psycho
mom is taking Ruby but now that we know
what closures of functions in Ruby are
then we can look at all the constructs
that we can take advantages for example
iterators and streams there's a string
API in Cherokee eight partial regulation
or coring composition of functions is
just how we can invoke one function
after the other in certain order
memoization
is remembering outputs given certain
inputs and tail call optimization
okay so iterators they are found pretty
much everywhere in the
api's for those also new to groovy there
is one feature that I really love you
probably know it too metaprogramming
so with compile-time well you have two
types of Como metaprogramming but what
basically what you do we need the
programming is add new methods or add
new properties to existing classes and
these additions can also be applied to
JDK classes so what you see in right
there this is native syntax for
collections in groovy this is just a
plain Java util array list and in this
arrival list were invoking new methods
inject some final grab all these methods
and somehow magically the groovy runtime
is able to locate these methods this is
why groove is a dynamic a language so
this iterator goes through all elements
in the list and applies a function in
case is a plus operator and appends a
value into an accumulator so for those
of you that know functional programming
this is reduce or this is false fault
applying the the some operator we can
just simply do some so another thing
that we can do in groovy
it is operator overloading if it makes
sense for the types in this list to
apply this plus operator then just use
this one
this is shorter or we can find an
element for which this condition is true
or do the same thing with grab I think
these two methods are functionally
equivalent you can find the first one or
you can find every element see if every
element did that collection fulfills
that condition or if there's any element
in that collection that fulfills that
call that condition finally we can also
generate a string concatenating the
tostring representation of this each one
of these elements with that particular
separator and you can use any string
here
okay yeah okay more examples or
iterators these are closer to the
functional style you can take as many
elements from the head and I'll give you
that
subs list in this case we're taking the
first two or we can drop the first n
elements from the head and this will
return you the tail so we take out the
first three and then grab the rest of
the collection we can also do something
like drop wah so we can drop elements
from the head until that condition is
met or we can just simply grab the first
element head or grab the rest tail and
or we can do a collect this is
functionally equivalent to the map
function that you see in standard
functional programming so we iterate
over all elements apply this function
and the result will be added back into
this collection if you haven't seen this
before this is a range another data type
Arabic Ruby so we are pretty much
creating a sub list of these five
elements right there and iterate over
those so we get 3 m 4 3 &amp;amp; 4 multiplied
by 2 and that's the result and there are
many other methods that we can see based
on iterator this is a really nice one
clade that generates a list of lists
based on an initial collection it's very
useful there's also permutations and
combinations are so many other things
you can have a lot of fun what all the
things that we can provide
so far so good any questions okay you
guys let us know so I you I was saying
something about collect and map and fold
reduce the creators a groovy for some
reason decide to use their all names for
these functions in the standard
functional nomenclature you'll find that
we have to use filter map and fourth and
most recently reduced is the same thing
in groovy you had these names so if you
see an algorithm algorithm in a book or
somewhere else where did they apply
these standard names
just remember to rename these methods to
the others and it will continue to work
exactly in the same way alright we're
going to talk about beers I don't know
why we chose that there is kind of like
an affinity with in conferences and
drinking beer and in the end at the end
of our very long day so imagine yourself
ourselves after a one long day Espanyol
job one and we got one of these great
partners so we just got to a pub and
have some drinks and we have so much fun
that the list of beers has to grow and
grow and grow and the end we had to pay
very handsome amount of money and
because we work for a company that is
friendly to us we had to expanse this
list of that great awesome we don't have
to pay it out of our pocket but then we
start sleep mmm why did we wanted to
know all the names are the beers that we
consume what was the most expensive beer
what was the cheapest beer and what was
the total number even though the would
you get a result out there what is the
total amount that you paid you sure that
is exactly what you should have paid so
we we ask outs of these questions and we
came up with different ways to calculate
these things alright so basically
remember our scenario right now is a
list of beers beers have prices name
Amer there are properties just plain
produce
so the first one is how do we you find
that she was beer so there are a lot of
ways to do it there are many ways this
is one thing that we like about groovy
is that it doesn't force you to go in
one way so any Python developers here
now
well Python says their philosophy of
Python says there should be one way to
the things and it should be the right
way it should be the intuitive way
that's fine whereas our peril says team
tau D there is more than one way to do
it some people believe this is crazy I
believe in choice so we have these
different choices we could for example
say given the list of beers a map the
price of all beers so now at the end of
this collection here we have a list of
all prices so we map from beer objects
into prices so far so good then we sort
and we grab the first element because we
start using the natural sorting of
numbers so we should get the smallest
one at the top or we can sort them again
I use first or we can simply ask the
minimum of this one which is pretty much
the same as just grabbing the first or
even better we can provide a closer to
the mean function and just grab the
price because at this point we still
have a beer object we didn't do any
mapping so we just grab the price
property out of it what about the other
question this is the most the cheapest
one what about the most expensive one do
you have before we switch that do you
have any ideas how we can do this
we can grab the last right we could use
the max function okay so here we are you
can again we map all the prices we sort
them and grab the last okay or we sort
them so we get again the cheapest at the
top and the most expensive at the bottom
we reverse the list and grab the first
item or we can give it a comparator for
the sword and we reverse the comparator
and grab the first item or apply the
mass function or apply the condition to
the max function and just grab the price
which ever way you want it will still
work one of them is definitely much more
expressive than the others very sub to
you to decide how much idiomatic you
want to be in your algorithm what is the
most efficient one the last one because
this
actually creates iterates the list twice
three times the iterators in groovy the
default ones are not lazily related like
in the streams API dedicate 80 which
means this collection goes iterated once
once we map a list of all the prices
then we sort that we reverse street
types if you apply streams API then
we'll be much better but this is
definitely the most these two are the
boers performant and perhaps this one is
the most idea Matic another question
okay so we're good to go for the next
one yeah suspense how do we want the
most expensive beer name the name of the
most expensive beer I guess the first
piece of code is what we will naturally
would do if we're still thinking in an
imperative way we're using a side of an
onside effective function because we
iterate over all the beers trying to
find out what who which beer is the more
expensive and we save that value and
once we have that beer we just get the
name from it right this is what we will
do with a for loop in Java this is okay
if we're still thinking an imperative
way but if we're thinking in a
functional way is just as easy as
grabbing the max from it we already got
the beer object just grab the name
property out of it so what we believe is
better from functional programming
versus imperative programming is well
it's better if you ask for what you want
and you don't worry about how it's going
to be done because at the end of the day
we can change how it's done but not what
we want to do in this case we just want
to grab the name of the most expensive
beer I don't we don't know how big this
list is if the max implementation uses a
for join or streams or parallel strings
well that's easy
imagine that we do it in a very
interactive way and then we
said okay maybe we can use concurrency
and then it's not that simple
but with your using the functional way
it doesn't matter at the end we can
change how this code will be executed
but if we choose to go with the
interactive way it's not that simple to
say let's do it concurrently it's any
party where you also to say how I want
to do it and what I wanted to so there
was a question here in front the
advantage of this instead of the stream
API is that you can do right now enjoy
any k-6
and if you still do it with the stream
API you still have to write a bit more
characters than just this because this
would if you do it with a stream API you
have to graph the recommended way will
be to grab the name of the beer using a
method reference which will be like the
class name column column gets name and
we just even simply say name because of
property accessing groovy the well the
definition of a closure here could also
be is this smaller in groovy than the
one in inland expressions so you are
still saving characters is more readable
but in terms of behavior and in terms of
performance is almost the same almost
the same the same speed so you don't get
much advantage of this code is read more
often than executed so if it's better
for you and your team to read the code
in this way I would recommend it to do
do it that way we can talk about when
groovy in production or if we suggested
to move it to testing we can discuss
that later
I mean it's an amazing talking about
groovy if there's a question in the back
so we are pushing part of the problem to
the implementers of the iterator method
because you as a developer of this thing
you don't care so much how you're going
to iterate the elements the promise of
the max method integral the iterator
method is that you will go through all
the elements whether is this go from
left to right or right right to left in
parallel way is not really that
important that what is important is that
you go through all of them and the
condition is supplied on did you find a
satisfactory result whereas in the first
example here you're doing both things
you're in charge of the iteration and
the filtering yeah
who implements the max method in the
case of glue B is the groovy development
team this is a standard method coming in
for all collections there are many other
classes many other methods that can be
applied to set map and list and I
believe that vector has been retrofitted
to implement the list interface so if
you still using vectors which I
encourage you not to then you still can
use these additions
all right so use case number three
number four get all the pure names many
different ways and he will see a few
other groovy isms the first one will be
okay let's map again the map will return
a collection the these objects okay so
we are mapping from beers to strings
we're just grabbing the names perfect we
got that collection but we can do it in
a much better way which is functionally
equivalent and in performance wise is
also the same it's just that it breeds
in a different way we can do a spread
dot on a collection when groovy sees a
spread dot operator it will invoke that
method on each element of the collection
or
because we are using we know that we
have inside pojos first worth which we
can call properties like get name and
set name are just simply dot name we can
call a spread dot and the name property
this will be the same thing iterates
over all Emmons grabs the property name
and put it in each slot and finally this
is one nice thing that we have in groovy
the last element is called G path if you
have done XML in the past you probably
want to find elements inside the XML
tree and probably have used XPath so
think about G pad as expert but for
object graphs so what we see here is a
simple expression where we say
collection dot some property this
collection which is a Java util arrived
list does not have a name property so
the groovy rotten nose Oh what you
actually want to do is get the name
property of each one of
the elements inside the collection so
I'm going to do that so these three
things are definitely completely
equivalent whether you want to go with a
spread dot or just simply that it's up
to you okay the final example getting
the total price so first we're giving
away the the simplest one which is apply
the sum if we apply some on a beer
object then we have to know is the plus
operator overridden for the beer class
probably not because when you say beer
plus beer whether you get an plus plus
be repealed you probably get a hangover
you don't get the total price right so
in this case we're mapping the price of
the beer and now we are definitely
summing we are applying the plus
operator on numbers so we get a
numerical result as we expect or we can
go to go the long way which will be to
use inject remember this is the same as
fault or reduce we start at zero if we
do not start at zero then the first
element will be a starting accumulator
value and then simply go through it oh
just like that apply the function and
that's it I yeah it's just as easy as
that okay
so I'd like to mention some of the shots
of using it and some of the real nice
benefits so remember at first we
mentioned that when we think about
functional programming the JVM Scala
Clojure come to mind the Scala can do
the same things like you see here a
slightly different but they basically
require you to use a different
collection library and they had to map
within their collection library to the
Java collections library when you need
to have interoperability with Java in
the case of groovy the pros is that we
are using the same Java collation APR
there is nothing different all the
editions are on top of the same API we
have closures this is a really nice
addition it plays very nicely with other
functional frameworks there are fewer
functional frames that came before JDK 8
of course and we'll see a few examples
there and metaprogramming I definitely
cannot stress enough how important is
meta programming when you have this
capability on the console yeah on the
con side is that as a fine gentleman
asked what about performance
well the evaluation of putting different
iterators one after the other is not
lazy so that's a bad thing well kind of
bad depending how big your data set is
streams are not included in groovy core
so you run in JDK 7 your ek6 you are out
of luck we'll see if there's a fix for
lag 1 but you run JDK 8 well you have
the access to the API and the names we
don't use filter MapReduce we use all
the names so you have to be aware of
that when mapping an algorithm
yeah
so the question is so he's mentioned in
a project called groovy strains by team
Yates another core member of the group
development team at some point this
extension was supposed to be added to
groovy core we have a slide about that
so no no that's okay I like these kind
of questions because you're already
looking forward so remember what I said
about meta programming are what is
important if you still care about these
names filter Map Reduce or fold you can
get them back how using meta programming
so basically what we're doing here at
runtime is we're in the indicating to
the list type that it has a new method
called map and whatever argument it
receives probably should be across sure
it will actually call the collect method
and we do the same thing with filter
that actually calls final so once we
have this we have monkey patch the list
class we can invoke our algorithm using
the standard namings filtered Map Reduce
whatever right yeah did you miss it that
much I guess it makes it easier to just
put a functional algorithm that you find
in a book or in some publication
directly into your code because perhaps
one of the resurgence of that we're
seeing right now in the past few years
with the functional programming is that
there are many problems out there in in
the real world that can be solved in a
functional way we didn't do it in the
past
first because Java was not really very
functional and second functional
languages were slow now functional
languages are much faster and we have
functional capabilities at the table so
it's easier now to solve these problems
if we look back into functional programs
that really makes sense to use a
functional way to solve them so don't
discard those algorithms and use the
best words okay so and here's the answer
to the grooviest stream so team Yeats
created a groovy stream API as the
groovy 2 was launched it and what this
thing it does it has its own string
class this was released before JDK 8 so
the API is very groovy like so you can
do stuff like this create a stream of
infinite numbers that each element is
just one and when we do here when we
take five elements we are mapping from
an unbound a list of numbers into a
finite list of numbers so we are just
getting five number ones and then we can
collect over all of them so this result
is actually what we expect we can also
say I want to create a stream using this
kind of generator so our range so will
contain just ten elements but it could
also be an unbound number and we filter
one of them I'm just getting the even
numbers out of the air stream
unfortunately this addition is not in
court but the advantage is that this
class actually the fingers have a most
recent number for that you just put this
jar in your class pad or you use this
annotation and graph which will
automatically download from the network
and put it into the class but so it's
very easy there's there's really no need
to put it in court if you know that this
thing exists and how you can find the
job
you want to use Java libraries groovy
it's really easy here's an example of
one of these functional frameworks that
we were telling you about before
functional Java they use their own
constructs so what we do here again you
see meta programming we use that trick
to grab the the jar and put in the class
but automatically so there's no need for
maven or Gradle in this case or any
other build tool just a simple screw
this will work we map those special
methods right there to the string class
the string class comes from functional
Java why are we doing this thing because
this filter method from the real class a
save some type that is not type closure
so we're doing here it will casting
Requena proxy alpha closure as if it
where functional Java type okay so now
functional Java will except our closure
very happily and we can invoke whoa we
can invoke now this functional Java
class using their own API but sending in
groovy closures of course after there's
one guy in Australia called Mac Perry he
has created another extension for
functional Java very similar to the one
that team gates created so it's just a
jar you put in your class path and then
off you go is very easy and he has
continued to blog about functional
aspects and groovy here's the home page
for his blog this is the first thing the
one the last one I remember but there
are a few others boards are in that
place of course you can use a JDK 8
stream API this can you tell if this is
groovy or Java code who says is Java
who says it's groovy and you will be
right this the only thing that I believe
we don't support yet is methyl
expressions like this method references
but everything else is valid groovy code
and this is the kind of the code that
you will be able to write somebody has
in your team has written jeddak a8 land
expressions you will want to paste it
into your groovy code without any
changes by the way in groovy we have the
same idea of method references just that
the operator is not a double column or
just an ampersand ampersand dot okay so
further down into partial evaluation in
groovy we call this Corinne what do we
do recurring is simply a function that
passes through a transformer and creates
a function with less arguments what
we're doing in the transforming is
fixing values of arguments the standard
way of current is from right to left so
in this case this function takes two
arguments will bakit with two values
when we call r.e.m now we get a new
function whose first argument is fixed
to five so this number one is actually
mapped to the wide argument if you try
to invoke the second function with two
arguments you get a runtime failure
because this function only takes one yes
I was expecting that that that question
because every time we say Korean okay I
came calling from right to left can I do
it from left to right can I carry an
arbitrary argument at any point the
answer is yes you can because this is
grouping we give you options the
standard name is query if you want to do
it in one direction or you do our curry
when you do it from right to left or you
use egg curry when you have to give the
index of the argument you want to fix so
what we're doing here is create three
functions as a direct derivate of this
one and we are fixing you can see the
element that we're fixing right there
and this this feature plays nicely with
default arguments to yeah you can do a
crazy with these things but that's why
we love groovy gives you options yeah
remember they a special Cole method that
we were talking about in the beginning
with closures here it comes back if any
object any class defines a Cole method
then we can use instances of those
classes up if there were functions while
we're seeing in this example this is a
simple poacher that has some state and
we define a Cole method when we create
an instance of this object we can use a
variable that references the instance as
if it were a function like that we can
call even tack Surkov which will be the
whole the most explicit way but with the
implicit way will be this and what's
nice about this is that because this
object has a state we can have access to
it
change the value and then invoke the
function again again this is not a side
effect free function but it gives you
something that looks like stateful
functions if that makes sense all right
we can have composition which means
calling a function after another one
it's just as easy as saying give a
function as an argument to another
function which is what we're doing here
we add we send the result of invoking
this function first to the second one
but because we groovy and we have
operator overloading when we can use the
right shift operator this is actually
the same thing we're just saying
first apply this function and then apply
the function to result or the first one
if you want to do it in the other way
well guess what there is a left shift
operator so whether you like using
operators or method calls is up to you
okay our good friend Berkut Subramanian
which is actually here at the conference
he talks about about groovy and
functional programming if you haven't
had the chance to attend one of his
talks we certainly encourage you to see
one is it would blow your mind away but
he posted a few months ago about this
feature that we like about groovy which
is called memorize the classical example
is right here Fibonacci when you cook
when you calculate Fibonacci one number
you know that the number is equal to the
Fibonacci of the same number minus one
plus the Fibonacci of the same number
minus two but it so happens that the
minus one will require a calculation
under the minus 2 plus minus three so
you already have calculated twice the
same value from the same arguments as
you continue down the pyramid you will
calculate more and more the same numbers
given the same arguments and because
this function is side-effect free then
you should get the same answer
why are you calculating the same things
with your team in the same arguments so
what memorize does is it will remember
the arguments apply to that function and
once it is called it will store the
result the next time the same arguments
and set to the same function it will
give you the results immediately you can
tweak how many items you want to
remember
and for how long do you want to remember
them in this case we're using the
default which is up until the memory
breaks down
so without memorize calling Fibonacci
for these two numbers it takes some time
but doing Fibonacci with me memorize
notice that Fibonacci 420 is pretty much
already done okay
take call optimization some people had
wanted this thing to be in the JVM the
java language do not support it we need
to change the JVM to support tail call
optimization which is basically reused
the last stack frame as long as the
function that you call in at the end of
your body is the same function you are
on if it's something else then you
cannot reduce the same stack phrase a
stack frame what happens is you do not
have tail call optimization when we call
when we attend to calculate Fibonacci
for a very long number or a factorial
for a very long number you get the stack
for a stack flow overflow which means
you create a function and then
recursively get another one and another
one another OOP you do run out or stacks
but we tail call optimization you're
calling the same function at the end you
kill one and it's in the same place and
it remembers what is going so once
everything is calculated just go back so
you never grow so so big with trampled
line which is what we're doing here you
can calculate a huge number and actually
doesn't take that long if we take out of
the trample of this algorithm you will
get a start all over for there's another
way called tail recursive this
annotation began life in outside of
groovy and since groovy to 3 it is
included in core this annotation can be
applied to any method and because
methods can be treated as functions then
now this function is also a star can do
tail recursion alright
method approach do I remember that
remember that says something about
method expressions in JDK 8 is how we do
it engine in groovy dot a person whether
these are not type or whether it is
owned in instance the same operator we
are grabbing a reference to a method put
it as a closure now there is a closure
you send it everywhere where a closure
is accepted so part of it right well
immutability one of the things that we
have to take care of when doing
functional programming again is
side-effect free and the other thing
that we have to take care is what about
our data is our data mutable or isn't it
mutable if it's immutable it makes
reasoning of our algorithm much much
easier because this is not then we have
to take care of its if it's a state can
be changed or not what a judge block has
defined a few guidelines so how you can
create well code several guidelines how
you can create an immutable class in his
effective Java Bobby do you remember
those guidelines what will be the first
one the class has to be final what about
the constructor it has to have a
constructor initializes all the estate
it optionally the estate can be visible
so you expose it using Gators all the
fields have to be final the types of
that fields have to be immutable as well
so all these rules have to be applied
recursively to all the arguments to the
constructor and the type so you see it's
not that easy and also you have to
specify an incorrect implementation of
the hash code and the equals method
right this goes out but it groovy is
just as easy as having a one line of
code we have something called AST
transformations that allows you to
modify by code at compile time the
compiler will now be aware of these
conventions and will do the right thing
for you so this class
if you know implants person if we
inspect the bike cut it will be fine
all these properties in that types are
immutable then there will be no
compilation errors and you will see a
getter no setters there right number
constructions the right implementation
for equals and hashcode so now it would
automatic with you if you create an
immutable person using the standard code
structure or the turbocharged purchase
as i like to call them
groovy version you now can call equals
of those things because those things are
immutable they have the same values if I
want to modify one of those properties
then I get a read-only property
reception you should not be able to
modify something that's immutable now we
get into jeepers
there are reverse says something about
Russell Russell is a member of this
project initiated by this guy pasla
from the Czech Republic for quite a
while a skull had been seen saying
actors are the solution to your
concurrency problem you should use
actors everywhere actors are not a
silver bullet but if you need to use
them so happens that jeepers provides
you with actor capabilities so if you
know how to use actors then you can use
it with Ruby but jeepers gives you much
more things it gives you sober
transsexual memory from closure it gives
you a much better abstraction over the
40 own framework coming from JDK it
gives you also CSP and data flow and you
can apply clothes shoes everywhere with
this framework here's a simple example
also you have agents here's an example
using at Red Bull and again within the
confine of this closure we are doing
something that looks like this dream API
we got a list of images make it parallel
so now we don't care how this how many
threads are spawn we don't care how
these things are managed we're just
simply saying I want to run this thing
in parallel and after that we're going
to fill out we're going to filter all
those things and then map them and then
obtain that particle value
so this reads a lot like the streams API
but grew bian here's another example
coming up monads
does anyone here get what monads are
certainly done it is said that if you
gain the capability to understand mana
then you no longer can explain monads so
I'll try my best to explain one as we
can simply don't get monads I think sad
joke it was something we do with side
effects and Manas be in side effect free
but anyway if if if the algorithm that
you have to use somehow reliance on
monads then there is another project
called mana gg that can be also be
applied using ad grab is just one jar
and you put in your class path and then
you can do crisis to stop with Mona's
and groovy and they will happily take
crushers this actually looks like well
nested plushies right all right what
time is five more minutes okay so we are
definitely on time we have here a list
of resources for you on where you can
find more information about the
different things that we were looking at
let's see
memory this is the the block from
banquette need for and banquette and
scott davis have a series of groovy and
functional programming at IBM
developerworks are certain we certainly
recommend you to have a look at it it's
really good
third because it not including core a
big ruby stream project by Tim Yates
here's where bass lab the author of
jeepers usually blogs about the homepage
for jeepers which so happens to be
included in the standard distribution of
groovy since groovy too
so if you have downloaded groovy then
you already got jeepers and we also were
inspired by other presentations we pass
by through a regular arrow and another
conference called rich at least a really
groovy conference out there but anyway
just to make sure that you have all the
resources here you
want to know more about these things so
for that I think now that we open the
floor for more questions you guys have
questions yes yes
it is so so the question is why we were
casting a functional Java type which
will be found here why are we doing this
casting if this type is a function on
interface then groovy should have how to
convert the closure into this function
interface the answer is yes if you use
groovy two three if you use a previous
version of groovy then you have to use
this notation because those version
agreed to not do the outer casting for
you
so using lazy evaluation here so for
example it would be what you thinking is
that maybe this this create an
intermediate collection at this point
and then we do the map and then we do
the mean so we are iterating over three
different collections my most insert
answer will be I don't know at this
point in the past there used to be three
iterations but it could be the case that
even most recent developments is now
lazy will or later I will have to check
if that is the case
any other more questions if not then
thank you very much for for being here
continuing to enjoy one</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>