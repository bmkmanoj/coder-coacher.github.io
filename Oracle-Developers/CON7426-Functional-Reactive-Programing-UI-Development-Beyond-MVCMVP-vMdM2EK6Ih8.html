<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON7426   Functional Reactive Programing  UI Development Beyond MVC:MVP | Coder Coacher - Coaching Coders</title><meta content="CON7426   Functional Reactive Programing  UI Development Beyond MVC:MVP - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON7426   Functional Reactive Programing  UI Development Beyond MVC:MVP</b></h2><h5 class="post__date">2015-12-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vMdM2EK6Ih8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">what makes you I development so hard in
my opinion they're mostly two reasons
why UI development is so hard the first
one is when we develop user interface we
have to deal with events and that makes
the control flow very difficult we have
the user who's working with the system
doing his changes and all of that
triggers event to which we have to react
so we don't really know what the control
flow is that makes UI development in
this regard a lot harder than for
example writing a server where you get a
request you do some calculation you send
a response in UI development you
actually never know what's happened next
because it depends on the user and this
becomes harder and harder because more
and more application or the user expects
that the applications nowadays give
collaborative experience so a user does
something in the application and another
user wants to be get notified about that
so we have these server push events
being sent to the different clients all
the time so their events coming from
their data is being updated in the
background and we want to show that on
the screen so we have a new event source
which becomes more and more important
and certainly we get more and more
center event exert and will get more and
more different events like that in the
future so we have all of these different
events coming from different sources at
the same time and we have to deal with
that that makes you very difficult to to
write an application
and the other main point is state
remember when we learned about state and
state machines in the university our
examples look something like this but
that's certainly not how state looks
like in a real application in the user
interface there are often dozens if not
hundreds of elements all of them have
different states different properties so
if you would draw that as a as a
finished state machine it would be huge
but still we have to make sure that this
state is that this state is in a
consistent state at all times despite
the fact that we have events coming in
from everywhere and we have so such a
huge complex state we need to make sure
that is always consistent and give is
fast and gives the user good experience
and that's my opinion what the
underlying clock costs it why user
development is so hard
my name is Michael I work at the canoe
engineering AG in Switzerland
so we were the guys who did the voting
machine for example and we focused on
user interface development it's pretty
much technology agnostic so we do lots
of Joe effects but also web development
angularjs lately we do a lot with
polymer and web components so everything
that's related to user interfaces we do
and we're specialized on either block
where sometimes block on and you can
follow me in Twitter now let me go back
first
now in the past we used MVC and MVP in
it and it helped pretty good and I mean
it helped pretty well it's it's a good
pattern and you can use it for a lot of
applications but we can also see that we
are hitting hitting boundaries or it
doesn't really help when you work with
large complex applications which have
the different event sources coming in or
the different events coming in and we
need to find something new unfortunately
at least in my opinion the innovation in
the Java development space when it comes
to user interfaces is pretty much stuck
I mean we got show effects a couple of
years ago that was good which was a huge
improvement but since then not much is
actually happening
but in the web development world there's
there's it's it's just an unbelievable
how much innovation is happening there I
mean you probably went to the keynote we
heard it there's a new web framework
coming out every month right now it
feels like what is a pain on the one
side if you have to maintain a project
and you have to decide what kind of
framework you want to use that's
certainly a bad thing but on the other
hand it shows how much energy and how
much innovation is happening there so I
did a look at some of these new trends
that are
being there and try to think how we can
apply that to the Joe effects world we
can apply that to the Java world - yeah
to keep up with the current trends and
to be able to write these new
applications with with a different event
sources and an unbelievable complex date
using these new technologies and one of
the trends that's pretty big right now
is functional reactive programming now
there are several approaches how we can
how you can introduce this topic and how
you can deal with it the one I chose
which work best for me is using events
streams and marble diagrams so what's
that an event stream is can imagine is
something like like the standard Java
streams but it's a stream of events
exactly so you have a time line time
passes by which is in the marble
diagrams show and ask this error so time
passes and then certain events happen
and this is shown on the marble diagram
like this we use different shapes which
show different events so these events
happen there's not just regular events
there's also an errors can happen this
is also shown with this cross and an a
stream can end or can become complete or
it can complete
regularly and that's symbolized with
this with this line each event stream
can have zero too many events it has at
most one error event or one on complete
event so as soon as one of these two the
the error here or the complete event
occur on event stream it's done and you
can throw it away there's there's
nothing that should come after that so
what does it looking like in code if you
want to use event streams with Java
effects there are mostly two libraries
that you can use right now there's react
FX and rx Java reactor fax is probably
the simpler approach because it is
optimized for Joe effects it works very
well with Joe effects you can easily
create event event strings from Joe
effects events and and it's also taking
care of the threading which which you
have to otherwise have to take care of
because as you know in Java vex you have
to do everything on the UI if I threat
react have access taking care of that
it's optimized for a single threaded
environment like Joe effects
our ex Java on the other hand is not
optimized for Java effects you can use
it in any context and it's actually one
part of a family of libraries there is
an aurochs library for pretty much any
programming language that exists out
there
there is for example one for JavaScript
for Scala for c-sharp you name it
there's an aurochs implementation for
that so ya ipi is always the same but
it's implanted for different languages
so let's say we want to create a stream
of mousemove events enjoy effects with
react FX it's quite simple we have this
event streams class which has a lot of
factoring methods we pass in a note
rectangle for example and then the event
type and that's it that creates an event
stream of mouse moved events we can
subscribe to that event and for example
and print print out the event when it
comes rx Java on the event it's a little
more cumbersome because it is not
optimized for Java FX you have to write
more glue code in between but it's still
it's still ok I would say so you have
this behavior subject this you can use
if you want to create an event stream
programmatically and then you trigger
new events by calling the or next method
which you can see down here or
let's see down here so every time you
call this on next method this generates
a new event on that event stream what
would you here we could is we create
this behavior subject and then on each
onmousemove
event we call this method with the with
the event as a parameter and as for the
other library we can subscribe to that
event and for example print out the
result so these are the two approaches
as you can see the one is a lot easier
to use with the JavaFX the one the other
one is more generic but also works with
Java effects so in the upcoming samples
I'm always using using this approach
down here because this is actually the
more sophisticated library it is it has
more functionality it requires me work
on the developers part but it also
offers more functionality ok so far it's
not really obvious why this should be an
improvement compared to for example just
hooking a listener to the most moved
event it's actually more code it would
be much simpler to just hook this
system.out.print line to the mouse moved
if events or creating an event handler
that would do the system.out.print line
but the difference is that he can
actually use the event stream and do
operations on them so for example you
can filter on an event stream so you
have this event stream with all the
different events coming these are
regular events the different symbols we
have a filter on it which filters out
all the circles and this generates a
second event stream that has the
different that has just the circles as
events
in code it looks very similar to when
you use the Java the standard Java
streams you have the shape stream for
example and then you define a filter
with a predicate that sorts out all the
filters that match or the shapes that
are circles and again you can subscribe
this generates new event stream you can
subscribe to that and do what you want
with this so for example printing it and
we can also combine different event
streams so for the simplest
functionality that you have here is a
merge so here we have two event streams
we do the merge operation and the result
is an event stream that has are the
events from the other streams in the
order that they appeared on the other
streams as soon as one of the events up
here has an error or closes the merge
stream closes there are other operations
or you can ignore this error for example
and continue with the other event and
stream but this is probably the simplest
one
in coat it looks like this so observable
that's kind of bad about the rx library
the observable the event streams are
actually called observables you can call
you emerge on that you pass in these two
streams and then you get the new stream
with a merge result and you can
subscribe to that now let's take a look
at a more more real application I mean a
more more real or more realistic use
case and that is a text field where the
user is supposed to enter some data and
you want to do a query and show the
results in the ListView and you want to
do that while the users typing so it's a
very typical requirement that you have
now the thing is the query goes to the
server that which means you don't want
to fire a new query whenever the user
types in the event if you do that with a
standard event listener it's pretty
cumbersome right you have to you have to
try to start a timer when the user types
another key you want you need to stop
with the timer start a new timer and
then you wait until the time is over and
then when the time is over then you do
the query so it's actually for for such
an obvious and often happening
functionality some a lot of code
with event streams it's quite simple
because there's actually even a method
for that debounce which does exactly
that so you can see there's an event
coming then it waits for the period of
time that you specify and then fires the
event and here in the second exam when
the second event comes it waits there's
a third event coming before the second
event fires so it drops the second event
and justifies the third event and so on
so it's actually when you look at the
codes it's it's just one line of code
and then you have this quite complex
functionality if you use regular event
handlers it's a lot simpler because it's
just line of one line of code called the
D bound the debounce methods with a half
a second interval that you want to use
so what makes or event handler or events
during shyness when you need to when you
need to deal with time a regular event
handler is not able or it doesn't know
about time it doesn't know if anything
happened before or after if if you don't
store it yourself but an event stream is
aware of time and so there are functions
which take care of which allow you to
deal with this quite easily
here's another example so I just have
the the diagram here because it's
actually quite boring each of these
steps is just one line of code you can
easily see how you can assemble a more
complex workflow or data flow with these
streams so let's say you have a click
stream so the mouse user clicks a button
on the on the user interface you map
that to a URL string so whenever the
user clicks on a button it generates a
click event which is then mapped to a
new event which contains the URL you
pass that in to a function that you
write yourself that does a query and
sense this request to this URL waits for
the response and gives the result back
in another event stream so you can
modify it or you can add new
functionality to these event streams
yourself so you get this response stream
and then you can map it again on a note
stream and with that you have the note
that you can add to the JavaFX
application for example showing the
results in a list view and as you can
see you have the whole process that is
happening very tightly bundle together
in just one piece of code and each of
these steps is just one line of code
oh there's one more just realize there's
one more advantage of event handlers
when you have event landless as I
mentioned you can combine them so he can
actually easily create functionality
where you have to deal with several
event handlers or several types of
events that provide your functionality
so for example if you want to draw a
line on the screen usually I have to
deal with the mouse down event when you
want to start the line the mousemove
event when you want to take care of the
new coordinates and the most up event
when you actually want to draw that line
when you do that when you do this just
using event handlers it's again very
cumbersome and uncomplicated because you
have these three event handlers but they
actually need to no need to share state
which you then have to store outside of
these event handlers and all of that
becomes pretty messy but when you have
event streams you can just merge them
and you have everything together easily
and you have also the under state that
they need to share together in one look
localize a in one place
so another trend that's pretty big in
web development is the virtual Dom
what's the virtual Dom so in the past
when we had to deal with the DOM and
modify the Dom we usually use two
libraries like jQuery and called an
action like or call something like image
attribute to change the attribute of a
node and then we pass in the name of
that attribute and the new value with
the virtual Dom there's actually a copy
of that Dom in memory which is which
just consists of JavaScript objects so
you can work with this like you would
with any other JavaScript object and the
advantage is that since it stands diced
you actually don't need a library like
jQuery which would which took care of
all the different implementations you
had in a Dom with this virtual Dom you
can directly interact with this because
it is a defined library so you modify
you do all your changes in this virtual
Dom in this copy of the Dom and at some
point the virtual Dom takes the old
virtual Dom compares there to the
current virtual Dom calculates the div
the Delta between those two Dom's and
then sends an update to the real Dom now
it sounds kind of weird to do this
there's a lot of overhead Pro probably
involved when you calculate the Delta
between those two Dom's but actually
turns out that this is even faster than
the traditional approach because when
you manipulate the Dom directly there's
a lot of stuff happening there's the
layout needs may have to be recalculated
the CSS may have to be reapplied and
that happens whenever you do any change
but with the virtual Dom all of these
changes are batched and sent together
so this recalculation has to be just
done just once which makes the whole
process a lot faster and it's it's a big
improvement and it's actually used in
pretty much any any new framework that's
being built right now so the question is
can we actually use this this idea enjoy
effects and what would it bring us while
I was trying to implement something like
that or thinking about how you would
implement that but the more I thought
about it the more realized actually we
do have a virtual Dom in Java effects
already because when you deal with when
you deal with the scene graph you are
actually naturally modifying the data
structure that's used for rendering but
you're dealing with the data structure
which is kept in memory and then in
every frame there's internal scene graph
which checks if there were any changes
in the scene graph you modified copies
the changes over and then uses this
internal scene graph to do the actual
rendering this was mostly done to free
the scene graph from from being stuck
while you do the rendering because with
this approach while you do the rendering
this one is luck but you can use this
one and this is the only thing that the
user can see so we had to lock this see
graph just very briefly while we do
think we did the copying and then you
could unlock the scene graph again the
user could use it and all the rendering
the expensive
and the expensive functionality took
place while the scene graph was was
unlocked
the big difference between these two
things is between the the virtual DOM
and the scene graph we have in Java
faxes that this works bi-directional so
whenever the user does some changes here
it's copied into the scene graph and
that's how we see how we can see that if
the user changes anything type something
into the text field we can see that in
the scene graph while the virtual Dom
doesn't do this there's another way how
how these how the user interaction goes
back into the virtual Dom but it's not
part of this copying step and that
becomes very important later when I want
to explain some of the new architectures
that are being designed right now
so what one could do is I mean just to
experiment with that you don't really
need to do much you just need to make
sure that you don't actually use this
feature if you want experiment with that
so for you you shouldn't copy the state
from the scene graph into your model so
you if you want to experiment with that
you cannot use bi-directional bindings
for example and you cannot hook in to
listeners or create listeners on the
scene graph that react to changes done
by the user but otherwise you can
actually play with this already without
doing any changes for for real
application you probably want to create
a custom scene graph which does exactly
simulate this copying once in a while
just to make sure that this that you
never accidentally touch the state here
another thing that you can do if once
you have this this custom scene graph
you can make sure that this copying
happies happens in the run later method
which frees you of dealing with with the
UI thread so you can implement this
custom scene graph in a thread safe way
the copying is done in the run later
thread and then you can modify this
scene graph at any time on any point at
any time on an any threat it's an
interesting experiment I started with
this and it makes really a lot of
applications simpler because you really
don't deal with this all the time when
you deal just with the business logic
and he update the data but you don't
have to worry about threats anymore am i
just implemented a part of this custom
seeing ref just for a couple of notes to
see how it works and it's actually you
know it's it makes it very convenient
another thing that you can do what we
kind of use quite often it to can do
actually without even noticing edit the
the custom scene graph over here can
actually be on a higher abstraction than
the real scene graph so for example we
have an application that shows a form
but instead of describing all the data
on the same level as you would in a sink
raff we have some high abstraction for
example input fields which have a name
they have a mandatory flag they have a
visible flag and all this kind of
information and then we render it the
real scene graph or create the scene
graph from the real scene graph from
that for example an input field would
become a label and a text field which is
also layout it correctly and works just
like that which also I'm simplifies
development if you take this approach
having this data define it in your
application and then generate the scene
graph from that instead of dealing with
the scene graph all the time
so these two topics were actually just
the start or just the foundation that
you need when you think about to
understand the architectures the new
architectures that are designed right
now are implemented right now in the web
development world the most famous
architecture is probably the flux
architecture here's a picture of it the
base idea of it is that instead of what
we usually do in UI frameworks we have
the view which where you change things
then you have a bi-directional binding
to the model which updates which gets
updated from that and then you have
listeners on that and you have other to
them to bar bi-directional bindings
which again modify some state and if the
application grows large enough this
becomes really complex so what what
Facebook tries to do instead is they
have this unidirectional data flow so
the data is just flowing from the
dispatcher to the store from there to
the view and then the information is
going back as an action to the
dispatcher over here and according to
Facebook it makes the application a lot
easier to understand it becomes much
simpler to reason about it because you
don't have these inter dependencies all
the time which update and you never
really know when the application is in a
consistent State here you can quite
easily see or look at a certain part and
you know when it's in a consistent State
and if everything is okay with that so
here's a more more detailed view of of
that
so well let's maybe just give a brief
overview of the different elements so
any kind of change comes in as an action
it goes to the dispatcher which is the
central hub for everything and it
distributes all the actions to all the
stores the store now is a collection of
objects which define a certain domain so
it's not just a single type of object
it's not another single collection but
it's different objects which are closely
coupled together so for example if you
have a chat application you could have a
store for the users of your chat
application and a different store for
all the rooms and all the objects that
belong to the rooms um so these stores
maintain the state and then there are
views which are listening for listening
for changes from the store and when
whenever there is a change in the store
the view updates automatically and shows
the new state when the user interacts
with the application the view generates
actions which are passed back to the
dispatcher and the circle starts from
the beginning when there are survey
events or sensor events they also create
actions which are sent to the dispatcher
so here's the more more complex view of
that so one thing that Facebook figured
out is that just creating actions
everywhere is it becomes kind of messy
so they created these action creators
these are classes with factory methods
to generate different kind of actions
these actions are sent to the dispatcher
and the stores listen or register
callbacks at the dispatcher they can
also define dependencies they can say
that a different store needs to be needs
to finish his work before I had called
which is needed in a lot of scenarios
and then down here the store sends a
change event to all the views which are
registered with the store and then the
views sent queries to get the data that
they need and update themselves to show
the new views and whenever the user
interacts it creates new actions by the
action creators if there are other
things happening there's a Web API and
then these actions are also created
using the action creator
now conceptually I think this is a very
good approach but when you look into the
application it's not so clean anymore in
my opinion it's really kind of
unfortunate I think the main issue is or
what I think what the main issue is that
the the guys at Facebook had this really
good idea how we can do things but they
actually didn't trust themselves enough
to really follow through so that you
have always these little loopholes and
workarounds we can actually do very
messy things and do or leave the
reactive pattern and to just regular
traditional implementations because it's
it's just there for example the stores
have setters and getters which is kind
of bad if you use that because actually
it all of that should be reactive right
everything should just be based on
callbacks and everything should be go or
should go through the dispatcher but
there are loopholes you can you can
avoid that actions are actually
functions that's also something that I
think is pretty weird so you create a
function here you pass it through here
and then is it gets executed in the
context of a store which is not in my
opinion at least not a very clean
solution
and they actually don't the whole
architecture is not really based on
events dreams but they just work with
events which is cumbersome because
events dreams are actually better
there's another interesting architecture
which is called psycho Jas and the here
the guys really try to stick to the
reactive pattern and do it as cleanly as
possible
and what they say they have a model view
intent pattern so the model works as we
know it there's there it's just a model
of data the views get updates using
event streams so this is an event stream
of data which gets sent to the view the
view uses the the the functionality
that's provided to modify invent streams
and generate the view from that and then
the view is passed to the intents which
then take the Dom and map the user
interaction with this view to the yet to
the world of the model so for example
here you may have a button which is
passed to the intent the intent then
hooks a listener to this button and
generates or creates an event stream for
the clicked events and then these click
events have a transformation to actually
define what you happen in the model and
then the model listens to that stream
and gets the information for example I
don't know update a certain field
and that way you again have this
unidirectional flow but this time it's
really just using reactive streams and
there is no way how you can actually
jump out of that to work around this
pattern which forces you to think I'm a
lot harder and make the whole
architecture much cleaner than you would
with the with a flux layout yeah and I
started to implement this stuff and
experiment with this unfortunately it's
not really something one can publish yet
but it's it's definitely definitely an
interesting approach to I can encourage
you I encourage you to look at cycle GS
to look at the JavaScript implementation
because that's really an interesting
pattern so let me just jump to the code
to show you an example because it's
really hard to understand this
just from the diagram so here we have
the model we create two streams for the
weight and the height and then we
calculate the BMI from that so that's
the data model very simple data model
that we have here so that way we have a
stream of these I say so we get we get
these two values into the stream and we
map it to these three our values which
go out of the stream and this gets
passed to the view down here so here we
get those three values height weight or
and BMI and then we generate the the
dump from that directly which is also
rendered from the
which is then also rendered and passed
to the intent and up here you can see
the intent that takes the dom and then
it gets a specific element and it then
hooks to the input events and and every
time such an event happens it maps to
the new value and then sends that back
to the model so this may make sure that
when something changes the new values
are then sent to the model up here so
it's really a very pure approach you
have event streams
in all three aspects and there's no way
you can escape from this pattern
oops
okay so to summarize this what I hope
would I was able to show is that there
are a lot of interesting things
happening in the web development space
and I encourage you to listen or to look
closely at it and just to learn and see
what's happening there and try to think
how you can apply that knowledge and the
the experiments that are happening there
how that you can use that to challenge
what you actually know to understand UI
development in the Java space better
thank you very much are there any
questions yes
your API
well the Java streams mostly deal with
collection type of strings
I think well these the event streams
also consider the time which gives you
just more possibilities for example this
kind of debounce
that doesn't make any sense in the
regular java streams that you can just
delay certain events while they're
happening you need to do this for this
kind of events when you have input
events you sometimes need to delay stuff
like that but you never need to do that
when you when you want to work with the
collection right I mean you work with
the connection you just want to get it
done as soon as possible but with with
the event streams you have to recognize
time so that's a huge difference I think
and why using or X makes more sense in
that space yeah
there is an Ardex JavaFX library it's
under you can find it on github if it's
not supported but it works just fine you
can take the
actual Java code
right yeah there is right there's our
this Oryx Oryx JavaFX but as you said
it's not maintained anymore the build is
failing I mean I downloaded it recently
and try to build it it it broke it
didn't work for the reason okay so yeah
then there is a binding which makes the
whole thing a lot easier yes good good
for Java effect yeah exactly it's good
that it works because it didn't work for
me yeah okay cool yeah so so try that
out
definitely it's it's very important
because otherwise it becomes really
cumbersome when you deal with the
threading the event streams happen on
pretty much any threat you have no
control and then you need to make sure
if you actually modify the the scene
graph that you're going back to this to
the jaw effects right and and that's
this wrapper or this bridging code takes
care of that it makes it simpler
good yes please
sorry
playing a using genefex from the browser
well I think it used to be possible
using applets but I guess nobody really
wanted to do that
I didn't experiment almost a year ago
trying to portray effects on the browser
using or rendering it on WebGL and that
actually works quite well it just it's a
lot of work and it got boring over time
so I stopped that effort but it is
definitely possible but somebody has to
do it
okay any other question
so thanks a lot I wish you a safe trip
home</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>