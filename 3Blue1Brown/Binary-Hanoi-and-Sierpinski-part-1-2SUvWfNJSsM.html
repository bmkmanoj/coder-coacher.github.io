<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Binary, Hanoi and Sierpinski, part 1 | Coder Coacher - Coaching Coders</title><meta content="Binary, Hanoi and Sierpinski, part 1 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/3Blue1Brown/">3Blue1Brown</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Binary, Hanoi and Sierpinski, part 1</b></h2><h5 class="post__date">2016-11-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2SUvWfNJSsM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today I want to share with you a neat
way to solve the towers of Hanoi puzzle
just by counting in a different number
system and surprisingly this stuff
relates to finding a curve that fills
your Pinsky's triangle I learned about
this from a former CS lecturer of mine
his name's Keith Schwartz and I've got
to say this man is one of the best
educators that I've ever met I actually
recorded a bit of the conversation where
he showed me this stuff so you guys can
hear some of what he described directly
it's weird I'm not normally the sort of
person who likes little puzzles and
games but I just love looking at the
analysis of puzzles and games and I love
just looking at mathematical patterns
that come from in case you're unfamiliar
let's just lay down what the towers of
Hanoi puzzle actually is so you have a
collection of three pegs and you have
these disks of descending size you think
of these disks as having a hole in the
middle so that you can fit them onto a
peg the setup pictured here has five
disks which I'll label zero one two
three four but in principle you could
have as many disks as you want so they
all start up stacked up from biggest to
smallest on one spindle and the goal is
to move the entire tower from one
spindle to another the rule is you can
only move one disk at a time and you
can't move a bigger disk on top of a
smaller disk
for example your first move must involve
moving disks zero since any other disk
has stuff on top of it that needs to get
out of the way before it can move after
that you can move disk one but it has to
go on whatever peg doesn't currently
have disk zero since otherwise you'd be
putting a bigger disk on a smaller one
which isn't allowed if you've never seen
this before I highly encourage you to
pause and pull out some books of varying
sizes and try it out for yourself just
kind of get a feel for what the puzzle
is if it's hard why it's hard if it's
not why it's not that kind of stuff
now Keith showed me something truly
surprising about this puzzle which is
that you can solve it just by Counting
up in binary and associating the rhythm
of that counting with a certain rhythm
of disk movements for anyone unfamiliar
with binary I'm going to take a moment
to do a quick overview here first
actually even if you are familiar with
binary I want to explain it with a focus
on the rhythm of counting which you may
or may not have thought about before any
description of binary typically starts
off with an introspection about our
usual way to represent numbers what we
call base 10 since we use 10 separate
digits 0 1 2 3 4 5 6 7 8 9 the rhythm of
counting begins by walking through all
ten of these digits
then having run out of new digits you
express the next number 10 with two
digits one zero you say that one is in
the tens place since it's meant to
encapsulate the group of ten that you've
already counted up to so far while
freeing the ones place to reset to zero
the rhythm of counting repeats like this
counting up nine rolling over to the
tens place counting up nine more rolling
over to the tens place etc until after
repeating that process nine times you
roll over to a hundreds place
a digit that keeps track of how many
groups of 100 you've hit freeing up the
other two digits to reset to zero
in this way the rhythm of counting is
kind of self-similar even if you zoom
out to a larger scale the process looks
like doing something rolling over doing
that same thing rolling over and
repeating nine times before an even
larger roll over
in binary also known as base to you
limit yourself to two digits 0 &amp;amp; 1
commonly called bits which is short for
binary digits the result is that when
you're counting you have to roll over
all the time after counting 0 1 you've
already run out of bits so you need to
roll over to a twos place writing 1 0 &amp;amp;
resisting every urge in your base 10
trained brain to read this as 10 and
instead understand it to mean one group
of two plus zero then increment up to 1
1 which represents 3 and already you
have to roll over again and since
there's a 1 in that twos place that has
to roll over as well giving you 1 0 0
which represents one group of 4 plus 0
groups of 2 plus 0 in the same way that
digits in base 10 represent powers of 10
bits in base 2 represent different
powers of 2 so instead of talking about
a tens place a hundreds place a
thousands place things like that you
talk about a twos place a fours place
and an eighth place the rhythm of
counting is now a lot faster but that
almost makes it more noticeable flip the
last roll over once flip the last roll
over twice flip the last roll over once
flip the last roll over three times
again there's a certain self similarity
to this pattern at every scale the
process is to do something roll over
then do that same thing again
at the small scale say counting up to 3
which is 1 1 in binary
this means flip the last bit roll over
to the twos then flip the last bit
at a larger scale like counting up to 15
which is 1 1 1 1 in binary the process
is to let the last 3 count up to 7 roll
over to the eighth place then let the
last 3 bits count up again counting up
to 255 which is eight successive ones
this looks like letting the last 7 bits
count up till they're full rolling over
to the hundred twenty eighths place then
letting the last 7 bits count up again
alright so with that mini introduction
the surprising fact that Keith showed me
is that we can use this rhythm to solve
the towers of Hanoi you start by
counting from zero whenever you're only
flipping that last bit from a zero to a
one
move disks zero one peg to the right
if it was already on the rightmost peg
you just loop it back to the first peg
you
if in your binary counting you roll over
once to the twos place meaning you flip
the last two bits you move disk number
one where do you move it you might ask
well you have no choice you can't put it
on top of disk zero and there's only one
other peg so you move it where you're
forced to move it so after this counting
up to one one that involves just
flipping the last bit so you move disk
zero again
then when your binary counting rolls
over twice to the fours place move disk
number two and the pattern continues
like this flip the last move disk zero
flip the last to move disk one flip the
last move disk zero and here we're going
to have to roll over three times to the
eights place and that corresponds to
moving disk number three there's
something magical about it like when I
first saw this like this can't work
like I don't know how this works I don't
know why this works now I know but it's
just magical when you see it and I
remember put any other animation for
this for when I was teaching this and
just like you know I know how this works
I know all the things in it it's still
fun to just sit and just like you know
what should play out oh yeah I mean it's
not even clear at first that this is
always going to give legal moves for
example how do you know that every time
you're rolling over to the eighth place
the disk three is necessarily going to
be freed up to move at the same time the
solution just immediately raised these
questions like where does this come from
why does this work and is there a better
way of doing this then having to do 2 to
the N minus 1 steps it turns out not
only does this solve towers of Hanoi but
it does it in the most efficient way
possible understanding why this works
and how it works and what the heck is
going on comes down to a certain
perspective on the puzzle what's es folk
might call a recursive perspective dis 3
is thinking ok two-one-zero like you
have to get you have to get off of him
like I can't I can't really function
under this much weighted pressure
um and so just from just three
perspective if you want to figure out
how is dis 3 gonna get over here somehow
I don't care how this two one and zero
have to get to spin goal B that's the
only way they can move any of these
distraught tapa three it can't move that
any of them are in spindle C it can't
move there so somehow we have to get to
zero having done that then we can move
disc three over there and the district
says I'm set you never need to move me
again
everyone else does figure out how to get
here and in a sense you now have a
smaller version of the same problem now
you've got two zero one and two sitting
on spindle B you got to get them to C so
the idea is that if I just focus on one
disc and I think about what am I going
to have to do to get this disc to work I
can turn my bigger problem into
something slightly smaller and then how
I solve that well it's exactly the same
thing disc 2 is going to say disc 1 to 0
you need to you know it's not you it's
me I just need some space get off they
need to move somewhere then just two can
move to where it needs to go than just
one and zero can do this but the
interesting point is that every single
disc pretty much has the exact same
strategy they all say everybody let me
get off then I'm going to move okay
everyone come back on when you know that
insight you can code up something that
will solve towers of knowing like five
or six lines of code which probably has
the highest ratio of like intellectual
investment to like lines of code ever
and if you think about it for a bit it
becomes clear that this has to be the
most efficient solution at every step
you're only doing what's forced upon you
you have to get disk 0 through 2 off
before you can move disk 3 and you have
to move disk 3 and then you have to move
disk 0 through 2 back onto it there's
just not any room for inefficiency from
this perspective so why does counting in
binary capture this algorithm well
what's going on here is that this
pattern of solving a sub-problem moving
a big disk then solving a subproblem
again is perfectly paralleled by the
pattern of binary counting count up some
amount roll over count up to that same
amount again and this towers of Hanoi
algorithm and binary counting are both
self similar processes in the sense that
if you zoom out and count up to a larger
power of 2 or solve towers of Hanoi with
more disks they both still have that
same structure subproblem do a thing
subproblem
for example at a pretty small scale
solving towers of Hanoi for to disks
move disks zero move discs one move
discs zero is reflected by counting up
to three in binary flip the last bit
roll over once flip the last bit at a
slightly larger scale solving towers of
Hanoi for three disks looks like doing
whatever it takes to solve two disks
move disc number two then do whatever it
takes to solve two disks again
analogously counting up to one one one
in binary involves counting up to three
rolling over all three bits then
counting up three more at all scales
both processes have this same breakdown
so in a sense the reason that this
binary solution works or at least an
explanation if you like you know there's
no one explanation but I think the most
natural one is that the pattern you
would use to generate these binary
numbers has exactly the same structure
as the pattern you would use for towers
of Hanoi which is why if you look at the
bits flipping you're effectively
reversing this process you're saying
what process generated these like if I
were trying to understand how these bits
were flipped to give me this thing
you're effectively reverse engineering
the recursive algorithm for towers of
Hanoi which is why it works out
that's pretty cool right but it actually
gets cooler I haven't even gotten to how
this relates to sierpinski's triangle
and that's exactly what I'm going to do
in the follow-on video part two
many thanks to everybody who's
supporting these videos on patreon I
just finished the first chapter of
essence of calculus and I'm working on
the second one right now and patreon
supporters are getting early access to
these videos before I publish the full
series in a few months this video and
the next one are also supported in part
by desmos and before the next video I
just want to take a moment and share
with you guys a little about who they
are and the fact that they're hiring so
desmos is actually really cool they make
a lot of these interactive math
activities for classrooms and tools for
teachers the real meat of their offering
is in their classroom activities for my
part I'm super impressed by just how
well thought-out these activities are
from a pedagogical standpoint the team
clearly knows their stuff and they know
where they stand to make a difference in
students and teachers lives and like I
said they're hiring they are always
looking to bring in more good talent
whether that's engineering talent
designers teachers or whatever other
skill sets line up with what they want
to do if any of you out there are
interested in joining them you know
helping them make some of these great
tools for teachers and students you can
check out the careers page that I've
linked in the description personally I
think they're doing some really
meaningful stuff I think their
activities are building genuinely good
math intuitions for students and the
world could use a few more talented
people pointing their efforts towards
education the way that they do
all right so with that I'll see you guys
next video and I think you're really
going to like where this is going
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>