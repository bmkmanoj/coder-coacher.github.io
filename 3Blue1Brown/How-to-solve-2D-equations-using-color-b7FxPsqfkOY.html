<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How to solve 2D equations using color | Coder Coacher - Coaching Coders</title><meta content="How to solve 2D equations using color - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/3Blue1Brown/">3Blue1Brown</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How to solve 2D equations using color</b></h2><h5 class="post__date">2018-03-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/b7FxPsqfkOY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">there's two things here the main topic
and the meta topic so the main topic is
going to be this really neat algorithm
for solving two dimensional equations
things that have two unknown real
numbers or also those involving a single
unknown which is a complex number so for
example if you wanted to find the
complex roots of a polynomial or maybe
some of those million-dollar zeros of
the Riemann zeta-function this algorithm
would do it for you and this method is
super pretty since a lot of colors are
involved and more importantly the core
underlying idea applies to all sorts of
math well beyond this algorithm for
solving equations including a bit of
topology which I'll talk about
afterwards but what really makes this
worth twenty minutes or so of your time
is that it illustrate Sal Essen much
more generally useful throughout math
which is try to define constructs that
compose nicely with each other they'll
see what I mean by that as the story
progresses to motivate the case with
functions that have 2d inputs and 2d
outputs let's start off simpler with
functions that just take in a real
number and spit out a real number if you
want to know when a function f of X
equals some other function G of X you
might think of this as searching for
windy graphs of those functions
intersect right I mean that gives you an
input where both functions have the same
output to take a very simple example
imagine f of X is x squared and G of X
is the constant function two in other
words you want to find the square root
of two even if you know almost nothing
about finding square roots you can
probably see that one squared is less
than two and two squared is bigger than
two so you realize ah there's going to
be some solution in between those two
values and then if you wanted to narrow
it down further maybe you try squaring
the halfway point one point five and
this comes out to be two point two five
a little bit too high so you would focus
on the region between one and one point
five and so on you can probably see how
this would keep going
you keep computing at the midpoint and
then chopping your search space in half
now another way to think about this
which is going to make it easier for us
once we get up to higher dimensions is
to instead focus on the equivalent
question for when the difference between
these two functions is zero in those
terms
we found a region of inputs where that
difference was negative on one end and
it was positive on another end and then
we split it into two and the half that
we narrowed our attention to was the one
where the outermost points had varying
signs and like this we were able to keep
going forever taking each region with
varying signs on the border finding a
smaller such region among its halves
knowing that ultimately we have to be
narrowing in on a point which is going
to be exactly zero so in short solving
equations can always be framed as
finding when a certain function is equal
to zero and to do that we have this
heuristic if f is positive at one point
and negative at another point you can
find someplace in between where it's
zero at least if everything changes
smoothly with no sudden jumps now the
amazing thing that I want to show you is
that you can extend this kind of
thinking into two-dimensional equations
equations between functions whose inputs
and outputs are both two-dimensional for
example complex numbers are 2d and this
tool that we're developing is perfect
for finding solutions to complex
equations now since we're going to be
talking about these 2d functions so much
let's take a brief sidestep and consider
how do we Ellis trait these I mean
graphing a function with a 2d input and
a 2d output would require four
dimensions and that's not really going
to work so well in our 3d world on our
2d screens but we still have a couple
good options one is to just look at both
the input space in the output space
side-by-side each point in the input
space moves to a particular point in the
output space and I can show how moving
around that input point corresponds to
certain movements in the output space
all of the functions we consider will be
continuous in the sense that small
little changes to the input only
correspond to small little changes in
the output there's no sudden jumps now
another option we have is to imagine the
arrow from the origin of the output
space to that output point and to attach
amen
version of that arrow to the input point
this can give us a sense at a glance for
where a given input point goes or where
many different input points go by
drawing the full vector field and
unfortunately when you do this at a lot
of points it can get pretty cluttered so
here let me make all of the arrows the
same size and what this means is we can
get a sense just of the direction of
each output point but perhaps the
prettiest way to illustrate
two-dimensional functions and the one
we'll be using most this video is to
associate each point in that output
space with a color here we've used hues
that is where the color falls along a
rainbow or a color wheel to correspond
to the direction away from the origin
and we're using darkness or brightness
to correspond to the distance from the
origin for example focusing just on this
ray of outputs all of these points are
red but the ones closer to the origin
are little darker the ones farther away
or a little brighter and focusing just
on this ray of outputs all of the points
are green and again closer to the origin
means darker farther away means lighter
and so on all we're doing here is
assigning a specific color to each
direction all changing continuously you
might notice the darkness and brightness
differences here are pretty subtle but
for this video all we care about is the
direction of outputs not the magnitudes
the hues not the brightness the one
important thing about brightness for you
to notice is that near the origin which
has no particular direction all of the
colors fade to black
so for thinking about functions now that
we've decided on a color for each output
we can visualize 2d functions by
coloring each point in the input space
based on the color of the point where it
lands in the output space I like to
imagine many different points from that
input space hopping over to their
corresponding outputs pin the output
space then getting painted based on the
color of the point where they land and
then hopping back to where they came
from in the input space doing this for
every point in the input space you can
get a sense just by looking at that
input space for roughly where the
function takes each point for example
this stripe of pink points on the Left
tells us that all of those points get
mapped somewhere in the pink direction
that lower left of the
space also those three points which are
black with lots of colors around them
are the ones that go to zero all right
so just like the 1d case solving
equations of two dimensional functions
can always be reframed by asking when a
certain function is equal to zero so
that's our challenge right now create an
algorithm that finds which input points
of a given 2d function go to zero now
you might point out that if you're
looking at a color map like this by
seeing those black dots you already know
where the zeros of the function are so
does that count well keep in mind that
to create a diagram like this we've had
the computer compute the function at all
of the pixels on the plane but our goal
is to find a more efficient algorithm
that only requires computing the
function at as few points as possible
only having a limited view of the colors
so to speak and also from a more
theoretical standpoint it would be nice
to have a general construct that tells
us the conditions for whether or not a
zero exists inside a given region now
remember in one dimension the main
insight was that if a continuous
function is positive at one point and
negative at another then somewhere in
between it must be zero so how do we
extend that into two dimensions we need
some sort of analogue of talking about
signs well one way to think about what
signs even are is directions
positive means you're pointing to the
right along the number line a negative
means you're pointing to the left two
dimensional quantities also have
direction but for them the options are
much wider they can point anywhere along
a whole circle of possibilities so the
same way that in one dimension we were
asking whether a given function is
positive or negative on the boundary of
a range which is just two points for 2d
functions we're going to be looking at
the boundary of a region which is a loop
and ask about the direction of the
functions output along that boundary
for example we see that along this loop
around this zero the output goes through
every possible direction all of the
colors of the rainbow red yellow green
blue and back to red and everything in
between along the way but along this
loop over here with no zeros inside of
it the output doesn't go through every
color it goes through some of the
orangish ones but never say green or
blue and this is promising it looks a
lot like how things worked in one
dimension maybe in the same way that if
a 1d function takes both possible signs
on the boundary of a 1d region there was
a zero somewhere inside we might
hypothesize that if a 2d function hits
outputs of all possible directions all
possible colors along the boundary of a
2d region then somewhere inside that
region it must go to zero so that's our
guess and take a moment to think about
if this should be true and if so why if
we start thinking about a tiny loop
around some input point we know that
since everything is continuous our
function takes it to some tiny loop near
the corresponding output but look for
most tiny loops the output barely varies
in color if you pick any output point
other than zero and draw a sufficiently
tight loop near it the loops colors are
all going to be about the same color as
that point a tight loop over here is all
blueish a tight loop over here is gonna
be all yellowish you certainly aren't
gonna get every color of the rainbow the
only point where you can tighten loops
around it while still getting all of the
colors is the colorless origin zero
itself so it is indeed the case that if
you have loops going through every color
of the rainbow tightening and tightening
narrowing in on a point then that point
must in fact be a zero and so let's set
up a 2d equation solver just like our
one-dimensional equation solver when we
find a large region whose border goes
through every color split it into two
and then look at the colors on the
boundary of each half in the example
shown here the border on the left half
doesn't actually go through all colors
there are no points that map to the
oranges yellowish directions for example
so I'll gray out this area as a way of
saying we don't want to search it any
further
now the right-half does go through all
of the colors spends a lot of time in
the green direction then passes through
yellow orange red as well as blue violet
pink now remember what that means is
that points of this boundary get mapped
to outputs of all possible directions so
we'll explore it further subdividing
again and checking the boundary for each
region on the boundary of the top is all
green so we'll stop searching there but
the bottom is colorful enough to deserve
a subdivision and just continue like
this check which sub region has a
boundary covering all possible colors
meaning points of that boundary get
mapped to all possible directions and
keep chopping those regions in half like
we did for the one-dimensional case
eventually leading us to a zero of the
funk hang on a second what happened here
neither of those last subdivisions on
the bottom right passed through all the
colors so our algorithm stopped because
it didn't want to search through either
of those but it also didn't find a 0 ok
clearly something's wrong here and
that's ok being wrong is a regular part
of doing math if we look back we had
this hypothesis and it led us to this
proposed algorithm so we were mistaken
somewhere and being good at math is not
about being right the first time it's
about having the resilience to carefully
look back and understand the mistakes
and understand how to fix them now the
problem here is that we had a region
whose border went through every color
but when we split it in the middle
neither sub regions border went through
every color we had no options for where
to keep searching next and that broke
the zero finder now in one dimension
this sort of thing never happened any
time you had an interval whose endpoints
have different signs if you split it up
you know that you're guaranteed to get
some sub interval whose endpoints also
have different signs or put another way
anytime you have two intervals whose
endpoints don't change signs if you
combine them you'll get a bigger
interval whose endpoints also don't
change sign but in two dimensions it's
possible to find two regions whose
borders don't go through every color but
whose boundaries combine to give a
region whose border does go through
every color and in just this way our
proposed zero finding algorithm broke
in fact if you think about it you can
find a big loop whose border goes
through every possible color without
there being a zero inside of it now
that's not to say that we were wrong in
our claims about tiny loops when we said
that a forever narrowing loop going
through every color has to be narrowing
in on a zero but what made a mess of
things for us is that this does my
border go through every color or not
property doesn't combine in a nice
predictable way when you combine regions
but don't worry it turns out we can
modify this slightly to a more
sophisticated property that does combine
to give us what we want the idea is that
instead of simply asking whether we can
find a color at some point along the
loop let's keep more careful track of
how these colors change as we walk
around that loop let me show you what I
mean with an example I'll keep a little
color wheel up here in the corner to
help us keep track when the colors along
a path of inputs move through the
rainbow in a specific direction from red
to yellow yellow to green green to blue
or blue to red the output is swinging
clockwise but on the other hand if the
colors move the other way through the
rainbow from blue to green green to
yellow yellow to red or red to blue the
output is swinging counterclockwise so
walking along this short path here the
colors wind a fifth of the way clockwise
through the color wheel and walking
along this path here the colors wind
another fifth of the way clockwise
through the color wheel and of course
that means that if you go through both
paths one after the other the colors
wind a total of 2/5 of a full turn
clockwise the total amount of winding
just adds up and this is going to be key
this is the kind of straightforward
combining that will be useful to us
now when I say total amount of winding I
want you to imagine an old-fashioned
odometer that takes forward as the arrow
spins clockwise but backwards as the
arrow spins counterclockwise so
counterclockwise winding counts as
negative clockwise winding the outputs
may turn a lot but if some of that
turning is in the opposite direction it
can
as out for example if you move forward
along this path and then move backwards
along that same path the total amount of
winding ends up just being zero the
backwards movement literally rewinds
through the previously seen colors
reversing all the previous winding and
returning the odometer back to where it
started for our purposes we'll care most
about looking at the winding along loops
for example let's say we walk around
this entire loop clockwise the outputs
that we come across wind around a total
of three full clockwise turns the colors
swung through the rainbow rosy BIV in
order from red to red again and then
again and again in the jargon
mathematicians use we say that along
this loop the total winding number is
three now for other loops it could be
any other whole number maybe a larger
one if the output swings around many
times as the input walks around a single
loop or it could be a smaller number if
the output only swings around once or
twice or that winding number could even
be a negative integer if the output was
swinging counterclockwise as we walk
clockwise around the loop but along any
loop this total amount of winding has to
be a whole number I mean by the time you
get back to where you started
you'll have the same output that you
started with incidentally if a path
actually contains a point where the
output is precisely zero then
technically you can't define a winding
number along that since the output has
no particular direction now this isn't
going to be a problem for us because our
whole goal is to find zeros so if this
ever comes up we just lucked out early
alright so the main thing to notice
about these winding numbers is that they
add up nicely when you combine paths
into bigger paths
but what we really want is for the
winding numbers along the borders of
regions to add up nicely
when we combine regions to make bigger
regions so do we have that property well
take a look the winding number as we go
clockwise around this region on the left
is the sum of the winding numbers from
these four paths and the winding as we
go clockwise around this region on the
right is the sum of the winding numbers
from these four paths and when we
combine those two regions into a bigger
one
most of those paths become part of the
clockwise border of the bigger region
and as for those two paths that don't
well they cancel out perfectly one of
them is just the reverse the rewinding
of the other one like we saw before so
the winding numbers along borders of
regions add up in just the way that we
want them to also side note this
reasoning about oriented borders adding
up nicely like this comes up a lot in
mathematics and it often goes under the
name Stokes theorem those of you who've
studied multi variable calculus might
recognize it from that context so now
finally with winding numbers in hand we
can get back to our equation solving
goals the problem with the region we saw
earlier is that even though it's border
passed through all possible colors the
winding number was actually zero the
outputs wound around half way through
yellow to red and then started going
counterclockwise back the other
direction then continued going through
blue and hitting red from the other way
all in such a way that the total winding
netted out to be zero but if you find a
loop which not only hits every color but
it has the stronger condition of a
nonzero winding number then if you were
to split it in half you're guaranteed
that at least one of those halves has a
nonzero winding number as well since
things add up nicely in the way we want
them to so in this way you can keep
going narrowing in further and further
on to one point and as you narrow in on
to a point you'll be doing so with tiny
loops that have nonzero winding numbers
which implies they go through all
possible colors and therefore like I
said before the point then narrowing in
on must be a zero
and that's it we have now created a two
dimensional equation solver and this
time I promise there are no bugs winding
numbers are precisely the tool we need
to make this work we can now solve
equations that look like where does f of
X equal G of X in two dimensions just by
considering how the difference between F
and G winds around whenever we have a
loop whose winding number isn't zero we
can run this algorithm on it and we're
guaranteed to find a solution somewhere
within it
and what's more just like in one
dimension this algorithm is incredibly
efficient we keep narrowing in on half
the size of our region each round thus
quickly narrowing in on the zeros and
all the while we only have to check the
value of the function along points of
these loops rather than checking it on
the many many points of the interior so
in some sense the overall work done is
proportional only to the search spaces
perimeter not the full area which is
amazing now once you understand what's
going on it is weirdly mesmerizing to
just watch this in action giving it some
function and letting it search for zeros
like I said before complex numbers
they're two dimensional so let's apply
it to some equation with complex numbers
for example here's the algorithm finding
the zeros of the function X to the fifth
minus X minus one over the complex plane
it started by considering a very large
region around the origin which ended up
having a winding number of five each
time you find a loop with a nonzero
winding number we split it in half and
figure out the winding number of the two
smaller loops either one or both of them
is guaranteed to have a nonzero winding
number and when you see this you know
that there's a zero somewhere inside
that smaller loop so you keep going in
the same way searching the smaller space
we also stopped exploring a region if
the path that we're computing along
happens to stumble across a zero which
actually happened once for this example
on the right half here those rare
occurrences interfere with our ability
to compute winding numbers but hey we
got a zero and as for loops whose
winding number is zero you just don't
explore those further maybe they have a
solution inside maybe they don't we have
no guarantees and letting our equation
solver continue in the same way
it eventually converges to lots of zeros
for this polynomial by the way it is no
coincidence that the total winding
number in this example happened to be
five with complex numbers the operation
X to the N directly corresponds to
walking around the outputs origin and
times as you walk around the inputs
origin once so with the polynomial for
large enough inputs every term other
than the leading term becomes
insignificant in comparison so any
complex polynomial whose leading term is
X to the N has a winding number of n
around a large enough loop and in that
way our winding number technology
actually guarantees that every complex
polynomial has a 0 this is such an
important fact that mathematicians call
it the fundamental theorem of algebra
having an algorithm for finding
numerical solutions to equations like
this is extremely practical but the
fundamental theorem of algebra is a good
example of how these winding numbers are
also quite useful on a theoretical level
guaranteeing the existence of a solution
to a broad class of equations for
suitable conditions which is much more
the kind of thing mathematicians like
thinking about I'll show you a couple
more amazing applications of this in the
context of topology in a follow-up video
which includes correcting a mistake from
an old three blue on Brown video which
one well watch all of the videos
everything on this channel and see if
you can spot the error first the primary
author of this video is one of the
newest three blue one Brown team members
three there Ramesh and with the last
video on the Basma problem you've
already seen the work of the other new
addition then hum bricked some of you
might be curious so I did a little Q&amp;amp;A
session with both of them which you can
find over on the patreon page and where
you can have fun laughing at just how
bad we are with live-action filming and
in particular lighting now sweeter and
bin are both incredibly smart and
talented and additions like these are
going to be crucial for covering all of
the topics that I'd like to with this
channel because the fact is a lot of
time goes into each one of these videos
at the top of it there's looking at the
infinite list of possible topics and
taking the time to choose which one has
the best chance of deepening someone's
relationship with math
and then even once you have that any of
you who write know just how many
iterations it can take to put together a
clear and engaging storyline that you
really think does that topic justice
without going too crazy long and then
obviously I think visuals are super
important for clarifying ideas and math
and that takes serious time I mean quite
often as in this video it involves
writing the more general code for a
fundamentally different type of visual
now what's neat is that unlike similar
products like movies or college courses
were able to offer you these stories and
these lessons for free and what makes
that possible is that a little less than
half a percent of those subscribe to
this channel have decided that it's
content worth paying for in the form of
patriotic ledges which is amazing so
thank you and if you're not in a
position to support just don't worry
about it that is exactly why the content
is free if that's you all I want you to
do is sit back and enjoy and if you
really wanted to help out share it with
others
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>