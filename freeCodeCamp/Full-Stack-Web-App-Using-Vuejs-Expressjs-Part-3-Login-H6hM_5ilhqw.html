<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Full Stack Web App Using Vue.js &amp; Express.js: Part 3 - Login | Coder Coacher - Coaching Coders</title><meta content="Full Stack Web App Using Vue.js &amp; Express.js: Part 3 - Login - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/freeCodeCamp/">freeCodeCamp</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Full Stack Web App Using Vue.js &amp; Express.js: Part 3 - Login</b></h2><h5 class="post__date">2017-09-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/H6hM_5ilhqw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey everyone and welcome to part three
of building a full stack web application
using view j s and express j s so if you
remember in the last part 2 we kind of
pulled in sequel eyes to connect to the
database and when I user registers we
create a user model and save that and we
did a little bit of validation as stuff
to return different error messages and
then finally near the end we started to
style this register page the kind of
having more like material looking design
to it so I guess we'll start off going
from there and the first thing I want to
do is I want to kind of fix these input
labels so let me go to the view to Phi
website again and we can try to find
some other components that we could
possibly bring in so if I go to the left
go to components maybe I do
I think text fields yeah there's a text
fields component that we could
potentially use so here are some
examples of the text fields or labels
whatever you can use and again just to
show you like how I kind of do this I
just click on View source
I look through their code really quick
and I say okay well they have this as an
example so I'll just go ahead and copy
that so instead of using inputs let's
just use a text field here and I believe
that's all you need to do and now
instead of doing I could just put the
v-model on that I don't even know if you
really need any of these let's see let
me go back to this really quick so I
guess there's different styles depend on
which one you want if we just want the
normal one we could just start off with
a normal one for now so if I were to
search for normal with hint text label
so I'll actually copy that one I kind of
copy the wrong one and then inside here
I can say v-model is equal to email
let's see
label text I'll say email ID I don't
think we even need an ID or a name so
I'm gonna get rid of that stuff
save this and see what it looks like on
our page over here see there it's
already filled out with my username cool
so we got a we brought in the beautify
text field component by just doing view
text field or whatever and just kind of
follow the approach that they're using
and we want to do the same thing for the
password down here so let's go ahead and
just copy this make this password change
this to password get rid of that input
save this boom we have email and we have
password here I'm not sure if they wrap
this in anything it's just enough flex
okay so I'm not sure why these don't
have a blackboard at the bottom like if
you go over here I would rather have a
have a border bottom here just so you
can tell that it's like an actual input
box so what I'm going to do is just find
out that class that I need to style so
input group text field I can just go
down to my scoped CSS and I'm just gonna
go ahead and say border bottom one pixel
solid black
in fact I think this is more of a global
setting I want it to be on all the input
boxes so I'm gonna go over here to what
this app dot view and notice that the
style for this is not scoped so this is
globally so anything here would be
global in the whole app so if I save
this now we have a border underline on
these two input boxes and again I don't
know why I need to do this because there
example says that you know there's
already a underline so maybe there's
something I did wrong in the setup maybe
there's something in version 5.2 that
broke that underlined who knows but
anyway it looks okay now so let's move
on to potentially adding some new
features so again I like the text I want
the text in this top bar to be white and
not to be dark and I think before if I
go back to the register dot view page I
thought if I added dark here it's
supposed to add I change the colors
anybody they add too dark to that No
yeah anyway it's just another thing I
could probably style globally just to
make it look a little bit nicer so I'm
gonna go ahead and figure out what class
this uses toolbar title right so I
should be able to go to toolbar title
just say give it a color of white so
cool we got a color white there and so
that should be affected for everything
and then we also have a button content
I'm pretty sure for the buttons if I
were to go and add a dark attribute to
that I guess it doesn't change I don't
know something must have changed or I
have something set up where it's not
styling like it was before but anyway
I'm just go ahead and add that so
globally our buttons will have a white
color text and then our headers will
have a white colored text for that
alright so at this point I think it'd be
nice to add a fixed header at the top
and have like you know the name of the
app maybe like a hamburger menu so I can
open up a side nav and I'll log in and
log out register button so what I'm
gonna do is you could go to beautify I
think they have a toolbar so toolbar is
one of those components that they have
and again they have like examples
whatnot you could view the code to see
how exactly do a toolbar again they have
like a ton of different examples so this
is a really good documentation so what
we're gonna do is inside our components
let's just go ahead and make something
new called header deal and that's going
to represent our view header so inside
here of course let me just go ahead and
copy an existing one and gut it out so
go here gut out that code in that code
care of all that boom so we have a blank
I have a blank view J s file I'm sorry a
blank view file and what we want to do
is we're just going to say our header is
going to be composed of a toolbar which
is fixed and that's one of the special
attributes that you can find in their
documentation go down here the bottom
their API says they have a fixed boolean
that you can do it sets the position of
the toolbar to be fixed and that means
that's basically going to stay attached
to the top of the screen like if you
notice this blue bar up here it's fixed
so if you just add fixed here it should
just become fixed go ahead and give it a
class of sign as well go ahead close
that off so we have a toolbar let's go
ahead and add a title to it so V toolbar
title class of margin right for we're
gonna call this tab tracker save this
and now at this point we should be able
to start using this so if we go to our
app top view page what we want to do is
we want to bring that in so first of all
we can say components we want to bring
in our header and of course we need to
import that so I could say import page
header from component slash header view
I think header might be a reserved
keyword in view so I had the name of
this thick page header so once we
include line 9 which basically brings in
that head of you file that we've
declared or component that we declared
we can pass it in to this components to
allow our app to actually use it in what
we mean by that is we can go over here
and actually say page header and put it
inside the template here and now when we
save this make sure there's no lessee
trailing spaces is not allowed on the
header maybe that was the issue
yeah so now if we go back to our clients
nice we have a fixed header at the top
sooo so you saw how easy that was to add
something you basically just read
through the docs look at their examples
you know copy and paste it into your
code and then change it as needed then
I'm also just kind of taking this from
some notes to have it look a specific
way for me so first thing you'll notice
is this panel right here is a little
messed up and I think we need to do a
little bit more work on adding all the
beautify components so I think if I go
back to the beautify thing thinks
somewhere they have it and they say you
must have your app that looks like this
pretty sure there's they say this so if
I were to copy this and put that here
that's probably why I like my dark
styles aren't working so basically they
say you must have a be app and inside
here you must have a main which has a be
container and then inside the V
container we can go ahead and put our
router if we want okay put the router in
we don't need this image anymore
I'm gonna go ahead and put the main page
header on side view app there oops I
thought I'd delete of that so go ahead
and delete that go ahead and add a fluid
attribute which basically allows it to
be a fluid layout go ahead and save this
and hopefully that works boom so we have
a nice spacing already added for us
because that's what beautified does for
us let me just try something I don't
really quick I wasn't sure I wanted to
add dark here and see what happens
without having to actually like hard
code
get rid of this stuff
yes okay so that whole stuff I added
before the colors we don't actually need
because once we've set up our app to use
this particular V app we can then start
using dark on two things that we want to
change the text to white so like in this
case we can add dark to this save it I
believe this will become white awesome
and then same with the button if we go
to that register and B button add dark
to it our text will become white
so that's built in to beautify so we
don't really need that CSS hack that I
did before so sorry for about wasting
time on that but at least it was fun to
figure out how to do globally styled
stuff inside that view style tag down
here at the bottom in the same with this
I don't even need that border bottom
anymore because I assume that that's
working now cool so it goes a show make
sure you read the docs before you start
using because it says right here you
must wrap everything in view app and I
wasn't doing that so shame on me huh I
so Cole we have a fixed top header here
in what we want to do is over on the
right let's go ahead and add like a
login or a logout button depending on if
you're logged in and then also like a
signup button so let's go back to our
header so here I go to header table view
and then inside here we can inside the V
toolbar which again is that cyan color
toolbar we can add another component
which is built in to beautify called B
toolbar items and this IB toolbar items
we can add let's say a button
and that's gonna say browse and we can
just make that a flat button and a dark
button see what that does
oops my brows instead so this is a
browse button when you click it it's
gonna take you to all the songs but we
can implement this later on let's go
into the very far right we knew the
first add a V spacer and again these are
in the beautified docks but a B spacer
is gonna pretty much alike to put things
all the way over here fixed to the right
and then at this point we can say V
another V toolbar items and then inside
the V toolbar items let's just go ahead
and make another button let's make it
flat and dark V button and what we want
to do is name this a sign-up button and
just too so we have to worry about this
stuff now let's just comment out that
Browse button because we're not really
even worrying about that functionality
so we can come back later and you know
see I had a nice little to do there so
we know to come back and fix it up so
now we have a sign-up button over here
if you saw that pop up and what we want
to do is we want this to actually
navigate us to our register URL so if I
were to go to the base URL here and
click signup it doesn't do anything
because we haven't actually linked it to
our view router so one thing that if you
go to the view router documentation one
way they tell you you should do this is
by using a or the docs should be like
the first link when you go to look at
hub not sure why they have it like
hidden okay so
a writer link all right so this is kind
of one way you can kind of make links
work basically you can use a router link
which will wrap whatever you do inside
an a tag and then you can do special
special stuff like Rider link to
whatever so I'm just going to go ahead
and copy this let's just go ahead and
put it right in our application sign up
I'll say go to the register page and
then we have to verify that we actually
have a register page so if I were to go
back to my router we do have a name
called register and what this does is
basically what you whatever you put in
this to so 2 equals register it's gonna
look through this route or routes array
and find anything that matches that
exact name and then if you were to click
on it it's gonna go ahead and point you
or navigate you to that
so you see here it's now a link with
sign up if I were to click it it does
nothing and that's because I think maybe
I need to just wrap this on the outside
yeah I don't know I guess the button was
catching and preventing the propagation
down to that sign of event so one thing
I'll point out is this is again one way
to do your whole router logic and it
kind of wraps your HTML elements with a
an a tag you see here and it completely
jacks up your style I don't know if
there's a better way to do it and
beautify so please leave me some
feedback if there's a better way to do
this but my approach to a solution is
instead of wrapping it with that router
link directive or component instead what
we can do is just say if a user were to
click on this let's just go ahead and go
to a register page manually so what we
can do is manually you know set up a
methods here so on click we can save
methods and that's gonna have a nav
navigate to method and then we'll say
route here and then when you use view
dot router basically you have the router
object that's put on to every components
local object so you can access the
router by doing this dot money sign
route and then I can push a new route by
just doing like this
so money signer out push and then push
the route in fact I'll change that to an
object like this let's have a name of a
set of to put name so kind of a
workaround not sure if that's necessary
but it keeps the button completely
styled how it should be and when I click
it it goes to the register page oh maybe
not I'm getting an error error and the
event handler for click this dot route
push is not a function
Oh should be router my bad so I change
that the router and now it's working so
if you saw here I clicked on sign up and
it goes to the register page another
thing I want to do is I want to be able
to click on this logo here and go back
to the home page so again if I were to
go back to the app and go to the header
view we could simply just I don't know
show maybe we should make that a button
too I don't know but I'll just make it
for now a span we can come back and
change this later it's not that big of a
deal so make it a span for now so if you
anyone were to click on that span it
will navigate them to the route I don't
think I have a route installed so if I
go back here to path and name this route
now if we click on this it takes us back
to the root of our application and again
we could do some styling here right now
like there's no hover effect so cursor
let me just do that really quick it's
not that hard to do so in here we could
say class equals logo I'll just say home
so now that style that span has a class
of home onto it if we go down to the
scoped styles we can say pointer is our
cursor is equal to the pointer save that
now we have a cursor when we hover over
it in fact let's just go ahead and do
like home hover color is
pick some random color cool and we could
choose that color later on but again
recap we added a fixed view toolbar
header by doing let's say a V toolbar
fixed gave it a class of sign and dark
so that the text is white or dark makes
the text white cyan changes the color so
we can go over here we can just like
green see how it changes the green or
blue and there's a bunch of colors
already defined on beautify so if I go
to the style drop-down and go to colors
we could basically use any of these
colors so they have like that ones call
us to use orange darken to so if we go
over here change that to Orange darken
to and go back to our app awesome but in
this case let's just keep it as cyan
save that and start moving on to
something new such as the login page so
for the login page we we already have a
way the register right but we don't
really have a way to keep track of the
state if the users already registered or
logged in so let's go ahead and work on
adding a login component which we can
you know have a link up here called
login so let's just go ahead and go to
that header we can go down here and say
let's just go again go ahead and add a
new button called login so I'm going to
go ahead and say login and when we click
it it's gonna go to a login state so we
have logged in here click it goes to
login state but login state does not
exist yet so if you remember you need to
go to your route router we need to go
ahead and add a login state which means
we need a login component which we
haven't created yet so let's go ahead
and copy a login component so go to
register and I'm just gonna copy and
paste a register component because it's
gonna be very similar right
so now if I were to just go through here
and anywhere it says registered let's
just go ahead and rename to login and
then for this logic we are probably not
gonna use it actually we might so right
now we're kind of assuming there's a
login method on this service but there's
not so let's just go ahead save and see
if this this works all right so now
we're at a login page we had this login
panel email and password we have a login
button if we were to click login
this should just throw an error mainly
because logging is not defined yet so
you saw how easy it was to add a new
link at a new view at a new component
called the login component and we
basically just copy and paste register
and we could just change it as needed so
now at this point what we want to do is
actually invoke a login endpoint with
this email and password so if you
remember if we go to authentication
service so I go over here to services
authentication service we don't have a
login method so let's go ahead and
create one so if I were to copy and
paste this change this to login we want
to do a post request to a login endpoint
with these credentials again I think
this is fine just you know prevent
present an error if there's a login
error
call log in from authentication service
with the email password and I think
honestly we're good to go with that got
a little syntax error thank you webpack
so now this point if I were the type in
test at gmail.com password 1 2 3 4 5 6
we hit login you can go to the network
tab we see that it does make a request
to slash login using a post request its
pasting the payload email and password
here and it's returning a 404 not found
and why is that well it's because we
haven't actually implemented a login
end point all right so let's move on to
the back end and try to implement that
login end point so if I open up the
server package and first go to routes we
can just go ahead and copy these routes
and what I'm gonna do is just indent
that and go to the login and basically
we actually don't need a policy for this
one at the moment or let's not even
focus on a policy so let's just focus on
adding a new login method to the
authentication controller so save that
file and I go over to authentication
controller let's go ahead and add a new
async login method and inside this
method we're gonna do I'm just copy and
paste this code what we need to do is
first find a user which matches the
email that's passed in right so the
first thing we need to do is grab that
email and password that the user has
passed in in their body so we could do
that on line 16 and then instead of
creating a user here we need to find one
so find one user where the email is
equal to the email that the user is
passed in and we can do that like so so
instead of using create we do find one
this should return a user object and if
it doesn't return a user object it could
be undefined or null what we need to do
is say if that user object does not
defined let's go ahead and send back a
403 which is the authentication error
status and then just say error if the
login information was incorrect
typically a good idea to return to New
York messages back to the user when
you're dealing with authentication or
logging in just so that a hacker doesn't
you know find a way to figure out all
the different users that are in their
system so again we grab the email and
password from the body we find one user
in the database that matches the email
we check that we actually found
something and if not we're going to
return a 403 status make sure you have
returned there
and then finally what we need to do is
say is password valid we need to verify
that the password the user passed in
matches the password that's attached to
the user model so I could do this is
password valid equals password equals
user not password and the see if the
password is not valid again we're going
to do the same logic to just return to
403 and just say the login information
was incorrect and then at this point if
everything was good to go
we're just going to return that user so
I'll say user JSON is equal to user dot
to Jason and we can send that back here
and again if there's any type of error
whatsoever we can just again return like
the valid login information I shall say
in air has occurred trying to the login
and in this case I think that might be
like a 500 error because if for some
reason you failed to make that sequel
eyes call and it's pretty sure there's
something wrong with the server so I
return to 500 status to the users so
they understand that it wasn't their
fault so at this point we can go ahead
and tried to test that end point so if I
were to go and make sure that we have a
count registered we do that we go here
and try to log in because the login
information was incorrect
and so let's try to figure out why
that's happening you may not even be
finding that user in the database so
it's finding a user you see how I
printed out user here so it should not
be getting to that let's print out but
what's happening here
it's printing out false that saying
password is not equal to user a password
so let's go ahead and just do a little
bit more debugging try to figure out why
this is having issues and the password
that user has is one two three four five
six and the password expects is seven
eight so for whatever reason I am not
sure why that user has a password length
of six so what I'm going to do is I'm
going to go to the app dot J is pretty
much gonna clear out the database so if
you in in sequel eyes if you do dot sync
and then pass this force flag it
basically drops all of your tables so
this is very dangerous in a production
environment but when testing locally if
you want to clean database you can just
go ahead and add that and then run it so
now that is ran we should not have a
single user in our database so I'm gonna
go back to register register with
testing and then log in with this and
and let us login this time cool so we
want to do JWT or Java or JSON web
tokens for kind of our authentication
method so the first thing we need to do
is install a package called JSON web
token so I'll say an install save Jason
web token and while that's installing
basically we can come up here and say
Const jaded to JW t is equal to require
JSON web token
and we also want to go ahead and just
include that config file that we had
created earlier and I'll write a helper
function called JW sign user which
basically is a function which is going
to sign a user object using the GWT
library to give us back a GWT token so
I'm gonna say first of all I'm going to
clear this variable called one week
which is basically 60 seconds times 60
minutes times 24 hours in the day times
seven days in a week and I'm gonna
return JW sign give it the user I'm
gonna give it a second argument is some
like options so I'll say yeah
then education dot jaded to be JWT
secret and then the third one is some
more options where you can actually pass
in the expires in so in here and config
let's go ahead and define an
authentication key and we say JW secret
is equal to process env GWT secret or
secret and basically what this is going
to be used for is signing the JWT token
you typically need to pass it a secret
string and that secret is only known by
the server and basically it's used to
determine if the JWT token is valid or
not because technically anyone can go to
you know JDBC IO and create their own
token and try to send it to my server
but if they don't know what this secret
is then my server is gonna be like yo
that's a bad token and just reject it
and we'll see this used later on when we
bring in password and start validating
using passport but for now our goal is
to just send back a GWT token when the
user signs in so again we have this
helper method and what we need to do is
down here we could just send back token
JWT sign user and pass it the user JSON
here so now when I save this file and go
back and hit my login endpoint
we get back our user information and we
also give back our token all right so
now as you might have seen when we
register a user it's storing the
password in plain text and that's again
another security concern you shouldn't
be doing that so let's go ahead and try
to fix that issue by just using bcrypt
and encrypting the password so yet again
we're gonna install another package and
this was gonna be called bcrypt nodejs
and basically as a package you can use
for encrypting and salting and hashing
passwords or whatnot so maybe I should
rephrase that I'm not gonna encrypt the
password I'm just going to add a hash
with a salt hash so we can easily check
to see if the password that's sent in by
the user matches what we expect in the
database so now that bcrypt
is done installing if we were to go back
to the user model I'm gonna go ahead and
include that bcrypt package and I'm
going to promise Phi all of that bcrypt
package
I like to use a bluebird as the promised
library I don't remember if we already
brought that in so let me just go over
here NPM install Bluebird and basically
promise file is going to take any
typical function which has like a
callback structure and it's going to
wrap it to allow us to use the promised
format and again I don't know how much
that really matters since we're
typically going to be using async and
await where possible so this might not
even be used let me just try to write
this out and see if we need it so I'm
going to change this up a little bit I'm
first going to say change this to that
because I need the actual reference to
the user object I need to return the
user object here so that's just like a
little refactoring just so I have access
to user here and what I want to do is I
want to on the prototype attach a method
called compare password and that's so
that the user model is kind of the one
that's doing the the password compare
instead of the controller and that's
useful if we need to do like Patrick
comparisons anywhere else so starting
off instead of doing that compare
password where I do password is equal to
user password we expect the password to
now be encrypted so what we need to do
is return bcrypt
compare a sync candidate password shell
changes the Kin Kin did it show us keep
that as password why not so compare the
password to the model's password in fact
to change that's the function because we
don't want to use the fat arrow
so assuming that the password is stored
using bcrypt we can just compare the
password that the user sends in against
the model's password so again any user
object now is gonna have that method so
instead of having to do this logic up
here we could just say user dot compare
password like a passive password and I
could say oh wait since that's going to
return a promise I believe and now
that's going to call this method which
is going to use bcrypt to compare that
password against the model's password
and the second thing we want to do is
before we store the user we instead want
to hash the password so if I were to go
here and say hooks I can add a couple of
callback functions so I'll say before
the object is created we want to hash
the password we want to say before the
object is updated hash the password in
before we save this object also hash the
password and then up here we can go
ahead and just declare function hash
password that takes a user object and
options and so the method for hashing
the password we first need a salt factor
which is just used and by decrypt not
sure what happens really behind the seam
that they look into that but a second
step is we need to check if the password
has changed at all so if the password
hasn't changed we can just go ahead and
return out of this hash password
function out do anything otherwise we
need to call bcrypt
we need to tell it to gin generate which
is gin salt a sink
using the salt factor we need to then
take that salt and then decrypt using
the user's password so basically we just
take the plaintext password and we salt
it which will give us a hash which we
can then update that user's password
value with that hash so at this point
let's just go ahead and do force true
again to clear out the database of all
those bad passwords and I can go back to
here go to the register endpoint go
ahead and register that user saying the
account is already in use I probably
have some type of like exception that's
been thrown
so let's first make sure that we're
getting into this hash password function
okay so I guess it didn't cleared the
password last time so now you see that
we've registered him we got a user back
with a strange-looking hash of a
password at this point what we can do is
if we were to try the login it's going
to check that 1 2 3 4 5 6 7 8 string
password against the hash to verify if
it works or not
so I can go back to here and just remove
that ok so let me just recap again
really quick what all changed
so inside routes we added a login
endpoint which calls the authentication
controller login method and then we went
to authentication controller we added
this login method which basically grabs
a username and password from the body we
find the user and using the email we
check if there wasn't an email or user
returned we just returned an error if
for whatever reason the password they
passing does not match the user's
password returning error otherwise we
are going to go ahead and return a.j dbt
token with that user information and
that's about it for that and then the
register in point we didn't change we
did add this JDBC sign user helper
method which is used for dinner in that
JWT token and then inside the user model
we added some hooks which basically run
whenever or before we create the method
create the object update the object or
save the object what college that calls
the hash password method up here which
basically takes that user password and
hashes it and then saves it again and
then finally we added a prototype method
called compare passwords so that any
user model we can call compare password
as needed in fact just to make things a
little bit easier let's just go ahead
and do the exact same thing for register
like we can return a GT
b:g token wild after they register
otherwise I think the user would have to
call login after registering to get that
GWT token which I don't know I don't
know what the better approach is for
this but that's basically how we're
gonna go forward with that so at this
point let's go ahead and go back to the
UI remember we had that login in point
that we created and let's verify that it
actually works so if I go I think the
account was testing or test yeah oops
testing at gmail.com password is 1 2 3 4
5 6 7 8 if we were to hit that log in
endpoint does it work yes a return does
the token and the user and again we did
change the register method so let's go
back here and try registering with
something regression tests manually so
yes it allowed us to register we got
back a token and we also got back a user
if I were to try to login with that user
we got back those things one thing I'm
amazing is it's allowing us to type in a
plain text into the password instead of
having stars so that's no good
so let's go back to the client and go
back to register in point I think we can
just say type is equal to password here
and do the same thing for the login
controller
okay that's working and I think one more
thing I'm kind of annoyed how on the
register page it's auto-filling it's
fine for logging to autofill but I don't
think that's good for the register page
so there is a autocomplete new password
attribute you can pass in two input
boxes and that should prevent it from
auto filling and I think it's also a
good practice to like wrap everything in
a form I think like Internet Explorer
might need the form thing and then
chrome uses this other thing it's just
kind of a pain but whatever so hopefully
now it doesn't autofill the register
page good it doesn't because it doesn't
make sense to me to autofill the
register page but login that's cool for
it autofills I don't really care about
that all right so what we want to do now
is that we have the ability to log in
and register and we get back that JWT
token at this point let's bring in the
view X library for the front-end which
is if I go to view X in PM or maybe I
should go to github not really sure
probably get up that's better
documentation
basically view X's the equivalent to
Redux which is the flux implementation
you can go through these Docs if you
want to but basically when your
application gets larger and you have
components kind of interacting with
other components the original approach
was to use like message passing so like
your parent component would use props to
pass down to your children and your
children and we use events to propagate
up to the parent and that's fine or you
could use like a message bus to kind of
communicate between all your components
and I think it's fine for small
applications but everyone always says
that it gets out of hand when an
application gets larger I'm not really
sure if that's the case because they
don't really have that in England or one
and I didn't see an issue with message
passing become any issue in angular 1
maybe my application wasn't big enough
but anyway they say you should be using
view X for something like that if you
need to keep track of a state that's
used to route your application and in
fact that token that we're passing back
and the user ID those are two things
that we want to keep track of throughout
the entire application so it makes sense
to use view X here so I'm going to go
ahead and again do an NPM install but
this time on the client I'll go ahead
and install view X
and then I'm also going to install
something called view X router sync and
it's a good way to kind of sink your
router to your Buicks view X store so
while those two are installing let's go
back to our front-end close all these
tabs to make this all manageable go back
to source so we can go back to main in
here let's go ahead and import the sink
from pukes view X router sink and we can
go ahead and say sink
store to router we need to import a
store which we're gonna have to define
ourselves so import store from store
such store which means we need to create
a store folder inside the store let's go
ahead and make a store dot Jas
so basically inside your store let's go
ahead and import view let's import to
view X let's tell view to use view X
that basically allows you to access your
store and all of your view components
and then we can go ahead and create the
store I think I could just do that
export default new view store I'm gonna
say strict is true which means that you
can never modify the state unless it's
through an action or a mutation for
State I'm gonna go ahead and just put
token in all and then user null and also
say is user logged in mostly false so
these are kind of the global states of
our application that we want to keep
track of and they can be used for like
adding stuff to the headers or changing
and changing what's displayed in the
header or side now depending if you're
logged in or not and I'll go ahead and
add a couple of mutations actually I
think I might make more sense if I just
keep it you know start with one and then
add on later so how view X works is you
have your actions your mutations in your
state basically you should always invoke
your actions from your leg view
components so your actions are like
basically just like event name so I
guess a set token which is going to take
in a commit as a first argument and a
token as a second and then inside your
actions you typically want to call your
commit or to your async calls basically
this is where you do any type of async
logic and then inside your mutations
you'd have a method with the same name
as that but in this case we're going to
take a state and then whatever the pin
that the second parameter we passed sent
which is a token so here basically
saying call the mutation called set
token
and pass it that token object and then
inside here we can say say token is
equal to token so it's kind of a lot of
extra legwork just to freakin change the
value of a token but I guess it's
supposed to allow your application to be
easier to follow because you know that
in order for this to change you must be
invoking either you must invoke a
mutation and/or to invoke a mutation
typically you want to invoke an action
but okay so how does this help us right
so when we login if we go back to that
logging dot view component at this point
we keep track of the response that was
returned which will have the username
and the password our username in the
token we can use that and call that
action using dispatch we can say set
token response that token and basically
that's going to call our stores set
token method which is going to call our
mutation set token which is going to
update our state to token and then we
could do the same thing with a set user
mm-hmm so response I think actually your
stupid response data user and response
data token so same idea with register go
ahead and just copy and paste that code
same idea set token and set user based
on whatever we got registered or
whatever's you turn from that register
endpoint and then I'll go ahead and save
that
all right so let's go ahead and just
force refresh the page just in case and
for view X you can install a chrome
plug-in called like that I think it's
called view I don't know what it's
called but if you search the chrome
store it's called view dev tools so if
you install that you basically can keep
track of the events that are firing off
and how they're affecting your
application so like in this case if I
were to change this to testing at
gmail.com change the password to that
and hit login we are getting an error
back okay so I was kind of looking
through the code and I found that I
needed to add s it was mutation and I
need that s and then also I'm trying to
call I'm trying I'm like jumping the gun
right here I'm trying to call set user
and we haven't even defined set user so
that's an oopsie on my parts again so
let's just go ahead and allow us to also
set a user state so set user user is
null and hopefully this will work this
time
it's kind of hard refresh you just in
case there's like any type of caching
issue please work
is it because I use a lowercase u
they're probably well when our truths
oh my page refresh dupes all right sorry
this is getting kind of annoying but you
know debugging is part of programming so
you got to get used to spending 20
minutes debugging something where you've
left off a character or something all
right I'm gonna pause this video and
I'll come back when it's fixed because
I'm wasting too much time alright so I
realized that in the main done JS file I
completely forgot to add state R sorry
dad store
so before view had no idea how to even
access the store but now it should be
able to access the store now so let me
just refresh this page and try that one
last time cool it worked so now in this
view dev tools you can actually see
every time that we commit an action in
the state changes we can kind of check
how the state is changing over time if
we want to we can actually revert in
time travel back to like the state of
the application before I set those
tokens and then time travel forward and
we'll see this how this can be useful
later on when I'm trying to hide these
login and sign up tokens up here so
let's actually try to use those right so
if we were to go to the header now and
we only want to show these if the user
is not logged in so what I could do is
just add another state say is user
logged in set that to false and I could
say if token is defined go ahead and say
state that is user
logged-in is equal to true otherwise set
it to false
and then I could use this is user logged
in if I were to go to the header
component here in fact let me just
delete this hello component just like I
said we even using that still yeah I
guess we were I'll keep that so anyway
the header component if I wanted to hide
those two items I can simply do V if and
then I could say store dot state dot is
usually logged in so this will only
display if that is true in fact I added
that to the wrong thing so let me add it
to the button same thing here I'll add
it to the button so only display if the
user is not logged in so I'll go ahead
and negate that save that file and
hopefully these are hidden now I think I
need to read login one more time all
right so after we logged in you saw that
those two links actually disappeared
from the header and I can go back in
time travel to like different states so
in this state user until curtain and is
logged in as false in this state token
is defined is user logged in is true
user is not for some reason I think
that's because we totally forgot to
uncomment that code here so I will do
that
change that to response data token make
sure registers all look good
let me just hard to refresh this in
retest that one more time
so I keep getting all these like teeny
little bugs and that's because I'm I'm
moving too fast so just a little piece
of ice you know so lit down and relax
you don't have to like be a speed coder
because the faster you go the more
chances you're gonna make stupid
mistakes so hopefully I'll slow it down
in these future videos all right so now
the users defined here we can go back in
time travel and we can see those links
appearing and just disappearing as we
change our state all right so like
always let's do a quick little recap so
we brought in the view X module inside
the main jeaious we went ahead and
included viewer outer sync and we
included the store
we told view router sync to sync the
store to the router and then we also
make sure you include line 29 setup view
to use that store and then inside this
project the client project would create
a store folder we created a store j/s
export which basically says or pretty
much tells you to use view X we create a
view X store we tell it to you
strictmode we created these three
different state variables that we're
going to be using throughout our entire
application and then we created the
actions and mutations that are needed to
kind of change those as needed and then
lastly in the login and register
endpoints we are keeping track of the
response that's returned from the server
and we are setting token and setting
user based on those two responses and
we're gonna use these two later on right
now we're kind of only focused on is use
your logged in but these will be useful
later on and then lastly in the header
we wanted to hide certain navigation
based on that state so we're saying hide
the login button and hide the sign up
button if the user is logged in
all right so that pretty much wraps up
part 3 I think we did a lot of extra
work getting everything set up with the
registration and login and then brought
in a couple of new modules so I think
it's good to have a little break here
maybe make part four in a little bit
after this is all sunk in thanks for
watching again I'm Cody Seibert and feel
free to follow my Twitter to get updates
as to when I release part 4 alright
thanks for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>