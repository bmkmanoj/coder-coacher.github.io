<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Graphs: breadth-first search - Beau teaches JavaScript | Coder Coacher - Coaching Coders</title><meta content="Graphs: breadth-first search - Beau teaches JavaScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/freeCodeCamp/">freeCodeCamp</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Graphs: breadth-first search - Beau teaches JavaScript</b></h2><h5 class="post__date">2017-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wu0ckYkltus" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I gave an introduction about graphs in a
previous video in this video I'm going
to talk about how to find the distances
between two nodes in a graph this is one
of the main uses of graphs and is called
graph traversal traversal algorithms are
algorithms used to traverse or visit
nodes in a graph the main types of
traversal algorithms are breadth-first
search and depth-first search in this
video I will be showing how to implement
breadth-first search in JavaScript as
you can see the algorithm starts at one
node first visits all its neighbors that
are one edge away then goes on to
visiting each of their neighbors the
point is to determine how close node are
to a root node there are different ways
to implement breadth-first search in
this version you pass in an adjacency
matrix graph and the index of the root
node remember an adjacency matrix each
nested array in the matrix shows which
nodes in the graph are connected to the
node at that index for example this
array is at index 0 so it shows which
nodes that node 0 is connected to if it
is connected to a node there is a 1 at
the index but if it is not connected
there is a 0 at that index before I go
through the code let's see it in action
so here is a graphical representation of
this adjacency graph check out my
previous graph video to see how this
adjacency graph goes into this graph so
we ran the breadth-first search function
we passed in this graph up here and then
we pass then the number 1 so that means
we're trying to find out how far away
every node is from the first node so you
can see this graphical representation of
the exact same graph and if you see the
first node right here that's the node we
passed in to the the breadth-first
search function we're going to see how
far away each node is so you can see
right here it shows how far away is so
node 0 is 2 nodes away see because of
the direct
of the graph we can't just go straight
across a zero first from one we go to
two then we go to zero that's two nodes
away one the the note itself is always
zero nodes away and then the second node
is one node away just one third node is
three nodes away see you first year to
start at one then you go to 2 then 0
then three so that's three hops and four
is infinity because when you're from the
first node it's impossible to get to the
fourth node because the fourth node only
points back to the first node this
function will output an object of key
value pairs where a key is the node and
the value is its distance from the root
this object will be used to store the
distances to the root node we will start
all the distances at infinity which in
this version of breadth-first search
indicates that a node is not reachable
from the start node here the distance
the root node from the root node is set
to zero instead of infinity we are going
to create a simple queue to keep track
of nodes to visit and the purpose of
this variable is to keep track of the
current node that we are traversing now
we will start a while loop to keep
traversing nodes until there are no more
nodes in the queue to traverse we'll
start the loop by popping off a node
from the queue to traverse which at the
beginning is the root node here we get
all the nodes connected to the current
node remember each index of the graft is
an array that shows what nodes are
connected to the root node associated
with that index so in this example we
are first looking at node 1 at node 1
the array show is that it is connected
to nodes 0 &amp;amp; 2 now we set the neighbor
index variable to an empty array this
will keep track of a list of nodes that
are connected
to the current node this line gets the
first node connected to the current node
when it says index of one this finds the
first connected node because the number
one in our array means that the node is
connected to another node at that index
if there is no node with an index of one
the index variable will be set to
negative one so while index does not
equal negative one
push the index onto our list of
neighbors this line searches for the
next connected node we look for the next
one in the array starting after the
previous one we found that's what this
plus one means now that we know all the
nodes connected to the current node we
loop through these connecting nodes and
get the distance if the value in the
nodes Lin array at the index of the
neighbor from the neighbor index array
equals infinity that means we haven't
set the distance of that node yet so we
will set it now we are going to set it
to the value of the the nodes length
array for the current node plus one then
we'll push that neighbor to the queue so
the next time we go through the while
loop we'll check the neighbors of that
node to this for loop is the most
complicated part of this and you may
have to read through a couple times to
completely understand it at the end we
return the nodes length array and that's
breadth-first search of a graph thanks
for watching my name is beau Carnes
don't forget to subscribe and remember
use your code for good</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>