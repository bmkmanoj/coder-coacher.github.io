<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Trie Data Structure - Beau teaches JavaScript | Coder Coacher - Coaching Coders</title><meta content="Trie Data Structure - Beau teaches JavaScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/freeCodeCamp/">freeCodeCamp</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Trie Data Structure - Beau teaches JavaScript</b></h2><h5 class="post__date">2017-05-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7XmS8McW_1U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">a try that's how this is pronounced
right here a try sometimes called a
prefix tree it's a special type of tree
used to store associative data
structures a try stores data in steps
each step is a node in the tribe this is
often used to store words since there
are a finite number of letters that can
be put together to make a string a
possible use case would be to validate
that a word is in a dictionary each step
or node would represent one letter of a
word so if you can see over here this is
an example of a try this word right here
o BB a ll ball the steps begin to branch
off when the order of the letters
diverged from the other words in the try
or when a word ends so if you get the
word be a ll but you also have be a T
bat so the first two letters BA are part
of the word ball and part of the word
bat and then down here you have doll do
dork and dorm if you look at the red
stars that just means it's at the end of
the word so the word do you can see it's
the end of a word even though there are
still letters in other words after the O
so let's look at the information in each
node from the code here each node is
going to have a keys which is just a new
map and this is the es6 map structure
it's kind of like an object it has just
key value pairs and in the in these keys
the key value pairs are kind of like the
name of a folder in a folder in a
directory structure so if you can
imagine these all folders in the root
node there is the keys map that's going
to have B D and s and each of the key
value pairs are the B the name of this
folder is the key in the map and the
value of that key is the folder be the
actual contents of the folder B and so
the D is the key
in the map and the value the key value
pair the value is going to be the actual
contents of the folder each note is
going to have a list of keys which is
just a list of all the other letters
that are inside that folder or in that
inside that note and then we're going to
have an end data that just means is this
the end letter in a word so in this
picture all of the node with a star have
end set to true and all the nodes
without a star have end set to false now
we just have a setter function set end
and is equals true is end so it's just
going to return true or false if it's
the end of the word so now that we've
looked at each node in the Tri let's
look at how the code to the actual try
setup so we're going to only going to
have three functions we're going to add
two add a word to a try we're going to
have is word to see if a word is a word
in the try and then print this is more
of kind of like a helper function just
to print all the words are in the try so
before I go through the code let me show
you how it be used what we're going to
create a new try and then we'll get you
can add the words like this and then
after you add all these words and these
are the same words are in this picture
over here you can check if it is a word
is what dollar word well doll is going
to be word is daughter word see we have
the word do R in the picture but there's
no star on R because door is not a an
actual word even though those letters
are in the try and then Dorf well check
the Oh R and then there's no F so that's
not a word and you can just print the
whole thing like that so if I run that
you're going to see in the console down
here
true false false and then you can see
the whole list here so let's go back up
to here first of all we're going to
create the root node a new node and then
let's look at the add function so this
add function is a recursive function so
when you call it for the first time
you're going to put the entire word you
want to add to the try and that becomes
the input and here says node equals this
dot root that means
if you pass in a node it will use that
node but if you don't pass in a node it
will just use this dot root as the
default node so if input that length
equals equals zero that means if we're
at the end of the word that we pass then
we're just going to do no dot set end
and then return and we're done with the
add function else if that means if
there's more than zero letters that
we've passed into this add function
we're not at the end of the word so
first we're going to check if there's
already a node with that letter that
we're looking at so this is if not no
dot keys that has so let's say we're in
the root node no duck keys is a list of
all the letters of that root node points
to so if it does not has if it does not
have a letter input zero would just mean
the first character of the string we
passed n so if we pass in ball it would
this is just saying if there is not a
node with the letter B here then we are
going to create a node with the letter B
note that keys that sect set is how
we're going to create a new key value
pair in the keys map we're going to set
it with the key to be the letter input 0
so input was you don't bracket just
means the first letter of the input we
pass in so if we pass in ball the first
letter to me B and so remember each key
value pair is then a is kind of like the
name of a folder and the contents of the
folder the name of the folder is B the
contents of the folder are a new node so
then this is where it becomes recursive
we're going to call this ad and we're
going to pass in input dot sub struck
one which takes the input and takes
every letter after the first letter and
passes it in to the add function again
so if the word was ball every letter
after the first letter is a ll so we're
going to just pass in the letters all
and we're also going to pass
than a node before remember we start
there with the root node now we're going
to pass in this node which is also the
node we just created here so we're going
to set a node with the letter B that
will be the input 0 so now we're going
to get the node with the input 0 that's
the first character so now we're going
to run the add function but instead of
after being at the root node we're going
to be at the node B and then the else is
just if there is already a letter by
that name so remember here we added a
node with the letter B but if there
already is a letter B like for instance
let's say we already have the word dal
and we're going to add the word Dork if
we're at the D and the word dal is
already in the Tri and we want to add
Dork well o is already going to be in
the Tri so if I was already in the tribe
we're not going to create the own ode
we're just going to add the the new
substring which in this case would be
oor K we're going to add that to the
nodes that know that keys that get input
0 which would be the O node so I'm going
to keep running through that until we've
added the word to the Tri and then down
here we're going to check if the word is
in the Tri so this is where the Tri
really performs you can check if a word
is in a dictionary
much quicker in the Tri than other data
structures because we don't have to
check through every word we're just
checking one letter at a time
so we're passing in the word we're
setting the node to the root node at
first and then this is the loop that
we're going to keep running through
until we find the word so while we're
dot length is more than 1 while there's
more characters to search in the the
word that we passed in so if not no
duckies that has word this is saying
we're going to check the first character
in the word so let's say we're on the
root node so if there is no key with the
first character in the word like let's
say we passed the word tree well there's
no T there's no key with the letter T
here so we can return false we quickly
the turn
that word tree is not in this try
because there's no word that starts with
T else that just means there must be a
word that starts with that letter so
let's say we're looking for the word
it's end well if it does have the letter
S then we're going to do these two
things we're going to set the node
remember which we used to be the root
note but now we're going to set the node
to the the node s because if we're going
to look for the word send we're setting
the node to the S node and we're going
to change the word into the word - the
first character so now we're just going
to be looking for the word end instead
of sindh so I'm gonna go back up here
now we're going to keep running through
this now we're on the S node but we're
looking for the word end and yeah we'll
find the e we'll find the end and we'll
find the D and now we go to this very
last line if node that key that has word
which would just be a single letter
because remember we keep taking the
letters off and so if it has the last
letter of the word that we passed in and
it is the end so is end then we're going
to return true that word is in the Tri
else we're going to return false
yeah so this last one was just the print
function this because it's kind of a
helper function and so we're going to
create an array of every word but right
now it's just going to be empty then
when a search we're going to pass in or
a search if we don't pass anything here
it's going to set this is a root node
actually but we don't even need this let
me just run that just to see if it does
the same thing in the console yep we
don't even need to set the node to the
root node because when we first call the
search command down here we already pass
in this dot root so we're just going to
pass in a node and we're going to pass
in a string here if no deck keys that
size does not equal zero that means
there's still still more letters to look
through so for each letters and the keys
here let's say we're on the root node so
the letters in the key would be BD and s
so for each of those letters we're going
to run the search command again and then
we're going to pay
note that keys that get letter that
means we're going to pass in the the
node at that letter so we would pass in
the B node and then we're going to add
that letter to the string at the
beginning the string would be empty
so do string that can concatenate or
going to add the letter B and basically
since this is recursive it's going to
keep going and keep adding each letter
so we keep Concannon each letter to the
string until it's formed the whole word
and then see if node that is end if
we've got to the last node in the word
it's going to do word dot push string so
that's our words arrayed if we've gone
to the last letter in the word we're
going to push the word onto the words
array no else that's else to this if
statement if the node keys that size
does equal zero then we're at the last
letter of a branch if string that length
is is more than zero we're just going to
push that word on to the words array or
else returned undefined and here's where
we call that search function for the
first time so here's the search function
and then we call for the first time and
this is going to go over and over until
it gets every word in the try if words
that length is more than zero it's gonna
return that were the words the words
array or it's gonna return off there's
no words in the array so that's a try
thanks for watching my name is beau
Carnes don't forget to subscribe and
remember use your code for good</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>