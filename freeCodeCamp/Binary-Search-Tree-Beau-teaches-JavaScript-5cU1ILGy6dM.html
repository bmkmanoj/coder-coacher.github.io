<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Binary Search Tree - Beau teaches JavaScript | Coder Coacher - Coaching Coders</title><meta content="Binary Search Tree - Beau teaches JavaScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/freeCodeCamp/">freeCodeCamp</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Binary Search Tree - Beau teaches JavaScript</b></h2><h5 class="post__date">2017-03-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5cU1ILGy6dM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">a tree data structure is a way to hold
data that when visualized looks like a
tree you would see in nature now this is
actually what we visualized a tree data
structure to look like all data points
in the tree are called nodes the top of
the tree is called the root node and
from here it branches out into
additional nodes each of which may have
more child nodes and so on nodes with
branches leading to other nodes are
referred to as the parent of the node of
the branches that leads to the child
leaf nodes are nodes at the end of the
tree that have no children also any
children of a node are parents of their
own sub tree in this video we will be
covering a specific type of tree called
a binary search tree while the tree data
structure can have any number of
branches at a single node friends
instead of see here there's FG h it has
three branches at a single node a binary
tree however can only have two branches
for every node so look down here here's
a binary tree each node only has two
branches also binary search trees are
ordered each subtree is less than or
equal to the painter node and each right
subtree is greater than or equal to the
parent node because they use the
principle of binary search on average
operations are able to skip about half
of the tree so that each lookup
insertion or deletion takes time
proportional to the logarithm of the
number of items stored in the tree this
is much better than the linear time
required to find items by key in an
unsorted array but slower than the
corresponding operations on a hash table
so let's see how this works in
JavaScript here we're going to use
classes to create the binary search tree
basically we're gonna create two classes
the no class in the BST or binary search
tree class the no class represents each
node in the tree and there's give me
three data properties we have the data
which is what we're actually trying to
store and we have this that left and
this that right which are going to point
to the left node and the right node so
in the binary search tree we're going to
have the constructor which just creates
the the root node but which is the top
of the tree which it starts as null and
then we're gonna have the add function
so this is how we
going to add something to the tree so
we're gonna add the data we're going to
get a reference to the root node but if
this is the first node node will be null
in that case we're just gonna set the
root node to the new note the new data
we just put in so new node data so we're
just gonna create a node based on that
data if it's not the first node we're
gonna have to figure out where to put
this node in the tree to figure out
where to place the new node we are going
to use a recursive function so I'm going
to create this function which is search
tree we're gonna pass in the node which
starts off as a root node if the data we
pass in is less than no dot data that
means we're going to put the note on the
left side of the tree so if the node dot
left side of the tree is null we're just
going to assign no dot left to the new
node and then we'll return but if no
doubt left is not null we're going to
return search tree no doubt left that
just means we're going to continue
searching this is where the recursive
nature comes in it's going to run the
search tree function again and continue
working down the tree to find where to
put the node and you can see here else
if if the data is more than no data that
means we're gonna put the note on the
right side so if no debt right equals
equals equals null then we just assign
no dot right to the new node and we can
return else if if the node outright does
not equal null we're gonna have to keep
searching so we're gonna return search
tree no dot right so else that means
data is not less than no dot data data
is not more than no data so they must be
equal if they're equal we're not going
to add the data to the tree we're just
gonna return null so this is the search
tree function and this is how we
initially call the search tree function
return search tree node which starts out
as a root node but then it can be called
with different nodes adds it's going
recursively through the tree let's say
you have 15 your tree and you have 17 in
your tree and you want to add 23
first it's going to see that the note is
not null because you have things in your
tree and then it's going to run the
search tree function putting in the root
node which is 50 then we'll see if data
is less than no dot data which it is
because 23 is less than 50 we're gonna
go to the the node dot left if no doubt
left is null we would put it here but
it's not because there's a 17 here
remember we're just adding the number 23
so else if if left no doubt left does
not equal null which is true we are
going to return the search tree no dot
left so we we are now gonna run this
search tree function but pass in the 17
so now we're gonna see does is data less
than no data
well now date is 23 but no data is 17 so
this is false now we're gonna go down to
this is data more than no data yeah 23
is more than 17 well is no dot writeln
all in this example we're saying that 23
isn't there so no dot right would be
null and then we can just set no dot
right to be the new node the next
functions we're going to talk about our
find min and fine max so we're just
gonna be finding the minimum of the
array and finding the maximum of the
array if you look at this binary search
tree right here you can see the minimum
is all the way on the left side 9 the
math is all the way on the right side 76
so just using that knowledge makes it
easy to find min and find max so I'm
going to set the current node to the
root node and so the minutes can get all
the way on the Left so while this dot
left does not equal null the current
node is going to be current dot left and
then at the very end it's going to
return current data so we're gonna check
this if the left side is not null we're
gonna go to the next one if it's not
learn all we're gonna go to this one if
it's not null when we go to this one now
the next is null because there's nothing
to the left of 9 so we're gonna return
current data we're gonna return the 9
cuz that's the data on the very left
side fine max is just the same way but
the opposite we're gonna start at
current which is gonna be this dot route
which is insert the top while current
dot right does not equal null well this
does not equal null cat 72 then we're
gonna go to the next loop current equals
current that right we're
next one but now current that right
isn't all because there's nothing to the
right of 76 so we can just return
current data now we have the fine
function now is present is very similar
but instead of returning the node we're
just gonna return true or false whether
the data is in the tree so we're
starting at the top the root node while
current that means while there is a
current node while current is not null
we're going to do the following if data
equals equals equals current that data
return true that means we've found it if
we haven't found it we're going to see
is data less than current that data now
current equals current that left so
we're gonna start searching on the left
side else
well data must be more than current data
so we're gonna start searching on the
right side and we're going to keep
searching and if we never find it if we
never find that data equals equals
current that data and return true that
means is not in the tree and we can
return false
okay the remove function is a little
more complicated than the other
functions we've covered just like in the
add function and the remove function
there's gonna be a recursive function so
we're gonna create this function here at
contra move node equals function where
we're gonna pass in the node and we're
gonna pass in the data which is the data
what we're trying to remove so we have
this whole function here and then here's
where we're gonna call the function at
the end this that root equals remove
node and we're gonna pass in this that
root and data we're assigning this that
route to whatever is returned to this
function here we're gonna pass in the
root node because you always start with
the root node and then the data that
we're searching for so let's see how
that works
first of all we have to check if we have
an empty tree if the node equals null
then we have an empty tree and we can
return null now I'm gonna save does data
equal no data so we're trying to see if
we can find that data in the tree so if
we've found the node with the data this
is what we're gonna do there's actually
three different options either no one
has no children that would be just like
the 76 if there's no children we just
completely delete that node so if no dot
left equals null and no dot right equals
there's no children just return know
when we're returning null were setting
the node that had that data to null now
we're gonna check if the node just has
one child if node has no left child if
no dot left equals null that'll be just
like this 54 here there's a node on the
right but there's no node on the left
if node outlet left equals null then
we're just gonna return no dot right
that means we're gonna replace this node
with whatever is on the right which is
67 so instead of 72 point to 54 that
will be replaced with 54 ZnO dot right
which is 67 and if there's no note on
the right we're gonna do the same thing
we're gonna just return the node that's
on the left to be the the new node
that's being pointed to it gets more
complicated when the node has two
children like such as v 17 if you want
to replace node 17 you can't just put in
12 here because then what will happen to
23 you can't just put in 23 here it's
and what will happen to 12
so let's look down here this picture
down here is kind of small
let's say we're trying to remove this 3
here that has the red X in here the way
to remove this node right here would be
to replace it with this node down here
so if we remove 3 we can place we can
replace it with 4 and then everything
will be right with the binary search
tree so if you look at what it would
become over here we just replaced a 4
down here with the 3 up there but how
are we gonna get down to that 4 well
first we have to go to the right sub
node and then we have to go all the way
down to the most left sub node after
we've gone to the right sub node so
let's see that we're gonna create in
node which was going to be no dot right
so in this case the temp if we're trying
to delete the 3 the temp node would be
no debt right which would be the 6 here
well no tip node that left does not
equal null tip node equals no dot left
that means we're gonna keep first we're
gonna go to the right of the node we're
gonna delete and then we're gonna keep
me gonna keep going to the left until we
get to the last one on the left side and
this one just happens before there's no
more to go down because you don't have
to go down one but if there was more to
go down to just keep hopping down
until it got to the most left node now
we're going to set no dot data to tip no
data so the node is the three up here so
instead of the data of this node being
three the data the node is now four
because no data is four now I'm gonna
set node dot right to equal and now here
we're gonna call the remove node
function again this is where it starts
becoming recursive and we're gonna pass
in the node up the node on the right and
the tip no data and this will keep
running through the function and set up
the right side of the tree correctly we
see here we were saying if data equals
no data else if data is less than no dot
data that just means we have to go to
the left side of the tree because it's
less and here we're gonna call we're
gonna say that no doubt left equals
remove node and we're gonna call this
recursive function again and pass a node
up left and the data and then we're
going to return the node else that means
data is more than no data when you know
dot right and then call this recursive
function again and no dot right data and
we're gonna return the num the node so
you can see that the leaf is the most
complicated one that we've covered
especially when one node has two Leafs
so let's look at how you use a binary
search tree at least this one that I've
created so far so let's open up the
console here I'm gonna do Const BST
equals new BST I've created my binary
search tree we're gonna add four at two
six one three five seven
and then I'm gonna remove four and then
we're going to file we're gonna console
that log the min and the max two times
and then want to check to see if or it's
present another thing we're gonna do is
we're I'm gonna add in and you remove
seven and we'll run that again you can
see it first it's the minimum is one
it's gonna console that log max which is
seven but then we remove seven and now
the max is going to be six and we're
gonna see is this present is for present
false note 4 is not present because
we've removed in this video covered all
the key methods common to a binary
search tree however in a future video
I'll be going over a few other things
you can do such as finding the tree
height and Trevor
seeing the tree through in order
preorder and postorder traversal if you
want to play around with this code you
can check the link to the code in the
description thanks for watching my name
is beau Carnes don't forget to subscribe
and remember use your code for good</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>