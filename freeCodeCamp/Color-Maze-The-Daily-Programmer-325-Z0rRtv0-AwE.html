<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Color Maze - The Daily Programmer #325 | Coder Coacher - Coaching Coders</title><meta content="Color Maze - The Daily Programmer #325 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/freeCodeCamp/">freeCodeCamp</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Color Maze - The Daily Programmer #325</b></h2><h5 class="post__date">2017-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Z0rRtv0-AwE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">a frico camp welcome to another the
daily program a webseries video the
problem today we're going to talk about
was called color range which is number
three to five on the daily program or
subreddit page alright so here is a
problem statement posted on the
subreddit I'm not going to read through
the whole description but I'll go ahead
and give you an overview basically he
attaches an image or two images the
first image is your 2d array which has
your color matrix and then your goal is
to find a path from the bottom row to
the top row which matches a sequence so
in this case he gives us a sequence of
orange green so our sequences orange
green so at the bottom row if you can
find an orange node and then traverse to
a green node and then again tourists
turn orange to a green orange green
orange we've found a path which matches
that sequence inside the provided 2d
array so that's the goal again given a
grid find the path from bottom the top
which has the exact sequence we're
looking for and then inside here there's
a couple of criteria it says you can
move horizontally and vertically but you
cannot move diagonally and you're also
allowed to move too it is also allowed
to move on the same node more than one
so if for some reason you have to like
go up the grid and then cut through
somewhere you've already been that's
allowed and then for the input the first
line is a color sequence so again o
space G would be our color sequence and
then followed by that is our grid that
we're trying to solve and then he says
that you can output the path that solves
the matrix or you can just go ahead and
print out the matrix with that path
print it out inside of it with empty
streams and all the other locations so
for our case let's just go ahead and try
to solve it to print out this um actual
grid so we can visualize it and then
we're not going to worry about trying to
parse this input we're just going to you
know write a function which takes in a
sequence array and then also takes in a
2d array of our grid yeah so that's
basically the problem let's go ahead and
work it out on the whiteboard with a
really simple solution all right so
let's start off with a really
example here so again we have the
sequence of Ong and we have this grid
it's dumb which is 3 by 2 so 4 rows by 3
columns and remember the goal is to
start at this bottom row and find a path
which happens to be this path that I'm
motioning out with my hand from the
bottom left corner at the top-right
corner where you can only move
vertically and horizontally to match the
next color in the sequence so let's work
this out by hand
so the algorithm starting off is you
pick the first index of your sequence so
for this algorithm we're going to do
something like a breadth-first search
where we pick the first index of our
sequence so in this case we have the
color oh and we need to find the bottom
elements so all the elements on the
bottom row which match the current
sequence that rat so in this case we
only have this bottom left corner which
is equal to O so one more time we
initialize and start with the first
element of our sequence we go to the
bottom row and find all the elements
that match that sequence and then we can
go ahead and push that location which is
3 0 to some type of list or queue so
I'll go ahead and put a 3 comma 0 here
for our cells or path and that's
iteration 1 so iteration 2 we go ahead
and increment the color that we're
looking at in the sequence we check the
vertical and horizontal locations that
we can move to from our current location
so a current location would be we pop
off the first element of our current
cells list so in this case we have 3 0
and then at 3 0 we just check can we
move to 2 0 can we move to 3 1 do they
match the color that we're currently at
in this case the only match that we find
is to 0 so we can go ahead and push 2
comma 0 to our RA
and then go ahead and move to that
location on our next iteration so
iteration three we again we increment
our sequence so we go back to the oh
here we pop off the first look for some
element of this list so 2-0 which puts
us right here we then add on every
vertical in horizontal location that we
move to which matches this color of the
sequence oh and then one caveat is we
can kind of ignore the one that we've
already been to since that last previous
location was this Oh there's really no
reason to go back and check so in this
case the only location that's a kind of
a new location is 2 comma 1 so we can
push to 1 here and then go ahead and
move on to iterations number 4 so again
iteration four we pop off the first
element so we're put at 2 1 we increment
our sequence
and then using the same logic we can
just and on every location which is
vertically or horizontally adjacent to
this location which matches the sequence
of color G in that case it only be one
one so we can just go ahead and add a
1-1 here and then repeat our steps so
iteration five we're pointing at oh now
we pop off one one which puts us at one
one and then we check every location
where the previous isn't equal to so in
this case we can check this that in
there and this happens to match oh so we
go ahead and push one two iteration six
we remove one two which puts us at one
to increment the sequence and then we
check and the happens to be that zero
two is the only location we can go to
and then for a final iteration seven we
remove the slot and throughout the only
iterations you basically check if we're
ever at two row zero we've kind of
solved this problem so in this case
we're popping off the first element we
get zero comma two we check okay zero is
equal to row 0 so therefore we found a
solution so this algorithm kind of shows
you that yes there is a solution where
you can get from the bottom row to the
top row but then you might say okay well
how do you keep track of the path that
we took to get from there to there so
basically all you can do is just instead
of having this array you can make it an
object which has the I and J location
you're about to move to and it also has
the previous location as an attribute
which points to another object so if you
imagine we could have each one of these
is kind of like a node which points to
the previous so in this case
this one its previous pointed to that
this one's previous point to that this
one's previous points of that previous
points to that end points of that
so ultimately if you instead of using
arrays to build up your paths what you
can do is use objects that point to
other objects it kind of Traverse
backwards to the path that you found so
in this case we'd have 0 2 points to 1 2
points to 1 1 which points to 2 1 which
points to 2 0 which points to 3 0 and
then we can just print that out here and
that is basically the algorithm for how
do you use breadth-first search to
traverse this grid to find a path which
matches the sequence and this will make
a little bit more sense as we implement
in JavaScript because like the hole
keeping track of the path thing might be
a little bit confusing but I think I'll
make more sense when we see it in code
and then also there's little caveats for
two um like let's say there's multiple
start locations this algorithm will
still work it will just take longer
because we have to pop off extra
locations and move each one individually
and I'm not going to work through a
larger case because obviously this took
a lot of time but try for yourself
hopefully it makes sense let's go ahead
and implement this in JavaScript I
suggest a heads up this implementation
is probably going to be a lot harder
than any of the other ones that we saw
in previous Divi programmer challenges
but hopefully it can make sense in D as
we go through all of it but basically
again let's just get started we have a
sequence which has an array of the
sequence we need to iterate through and
then we also have a maze constant which
is the actual 2d grid that we need to
find a solution throughout and then down
here I have 112 which is just calling a
solve method passing a sequence in the
maze and then we're printing out the
path so let's go ahead and create a
solve function here which takes a
sequence in a maze and then inside this
function what I'm first going to do is
just declare couple of helper variables
so I'm gonna say Const Rose is equal to
some ACE dot length so that's just a
constant which tells us
number of roads we have in the array and
then I'll say Const calls is equal the
maze of zero dot links now tell us how
many columns are in the matrix those are
again just kind of helper functions that
we'll use or helper variables we can use
okay so another thing I'm going to do is
go ahead and declare a generator so if
you don't know anything about es6
generators you might want to read up on
that but basically when a generator so
every time we call it it'll give us the
color and then I'm going to reach the
end of the sequence array we just go
back to the beginning and it just keeps
on returning us to color sequence so I'm
going to say Const colors is equal to
I'll say this is going to be a
self-executing function which takes a
parameter of I which is equal to zero by
default and again if you don't know what
a self-executing function is is
basically you create a function and call
it right then and there so they return
something so in this case we want to
create a self-executing function which
returns a yield or which does it yield
and that's a pretty much do it using
generators in es6 alright so again this
is a generator function which is going
to keep on looping over each sequence in
the list and then once I goes out of
bounds we go ahead and modify the link
so it goes back to zero so this will
give us oh gee oh gee oh gee oh gee it
could keep on calling it again right so
we have a rows constant we have a
columns constant we have a color
generator constant which we can use to
kind of implement our algorithm so the
first thing I'm going to do is again the
algorithm says we start at the bottom
realm right so we need to grab every
cell that's in the bottom row so I'll go
ahead and say let pass equal two paths
our maze of the last row so amazed of
row - Rose minus 1 will give us that
very last row and I'm going to go ahead
and filter out our sorry I'm going to go
ahead and map that to an object so in
this case every index we want to keep
track of so we could say rows and minus
1 J of J and then previous like we
mentioned in the white board is just
pointing to another object which is how
we Traverse back so in this case let me
just reiterate we grab the last row for
each element in that row we're going to
return an array which has an eye a J in
a previous attribute inside an object so
here if I were to just say let's just
print out paths so we can see what's
going on here we see that paths is an
array of 5 elements where we have AI is
equal to 4 which is the last row and
then we have J of 0 1 2 3 &amp;amp; 4 all right
so that's kind of what we're going to
start off with and then we can go ahead
and filter it out to only match the
colors of our current sequence later on
ok so now we have our initial caps we
can go ahead and loop through our colors
so this is how you can loop through an
iterator or a generator in es6 if you
want to basically just a normal for of
loop so if I were to print out color
here it should print out oh and if I
were to print out in the next iteration
should print on G and if I didn't have
this break here just infinite loop
forever so I'm going to keep the break
in there for now starting off we want to
like we sit on the white board we want
to grab in filter out anything that is
out of bounds so first of all because if
halves equal tabs and we're going to use
like functional programming to just keep
on modifying the pads array so we can
first filter out every path that is out
of bounds right so we could say if path
of I and less than rows
path of I is greater than equal zero
if passage a is less than columns and
path of J grooving equals zero so
basically this will give us or this will
filter to only give us the cells which
are valid or inside of the grid because
later on we're going to push values that
might be potentially outside kind of a
little bit different from the white
board algorithm but just going to do a
little bit bit different on this
implementation the next step is we need
to filter out every path that doesn't
match the current color that we're at so
if I were to just do filter pads base of
AI path of J is equal to color again
this will give us only the paths which
match the current color that red so in
this case color o if we were to print
elf what passes here it should make
sense that it only gives us the fourth
row of the last row and then that column
one right because if you look over here
that's the only thing that matches
though so again we take every element in
the bottom row we filter anything that's
out of bounds and we also filter to only
match the color that we're at which will
give us this one location of O and then
finally what we want to do is for each
remember we pop off the first element
and we add it to the end and we keep
doing that so what we can do is is do a
reduce function where we have kind of
we're going to build up a new array and
just keep on returning a new array with
all the elements pushed to the end so if
I were to say reduce where we keep track
of the accumulator go ahead and pass an
empty array to reduce and what we want
to do here is just go ahead and say
accumulator concatenated with and then
I'm going to do the four location so
horizontal and vertical
so I could say di of one DJ of zero and
then di of negative one so this should
be the direction going up Direction
going down actually I think that swapped
the direction going down Direction going
up direction going to the left direction
going to the right so for each of those
directions we are going to we are going
to simply map those
to an object and that object is going to
be our current application added to the
direction so if I do I is equal to
pacify plus dur of D of I and then same
thing with the J you can say J is equal
to passage a add it on to Durga
alright so again taking a step back we
started off with that one element right
and then we're going to reduce over that
array which is going to be one element
and for each element what we do is we
add every potential location you can go
to and put that to the end of the list
so in this case we're going to check
we're going to add the element that's
above which is what we're doing with
this whole make an array and then map it
and then for each mapping callback
function we just take the current
location of the path and add it to the
direction so you can see here we have
after this runs once we have a new array
so path is equal to array of four where
each location is the top to bottom left
and right location you can see some of
these are out of bounds which is why we
have this filter up here so that we
filter on the ones that are in bounds
and the some of these locations may
point to places in the grid which are
not equal to the current color sequence
so that's why we have the filter here
and then that keeps on happening where
we just take a spot add the four to the
end take a spot add the four to the end
and we keep on looping that until we
find our very in case which again if we
just say if we reach the top row we can
just going to return or in so I'll say
cons first row paths is equal to paths
off filter and we want the paths which
match the very top rail so I'll say
filter out the ones and give you the one
set or at the top rail and I can see if
first rope have that length that means
we found one we just go ahead and return
first row paths like so
go ahead and remove the break statement
and down here this is working as
intended so it's putting out the path
here right so we have the first location
of 0 3 which is 0 1 2 3 which is here
second location is 1 &amp;amp; 3 which is here
the second location set is 2 &amp;amp; 3 which
is here and then previous again is going
to be an empty object so I'll go ahead
and stringify this so we can actually
visualize what's going on all right so
our algorithm are a function right now
is currently returning this huge nested
list where every previous is the
previous node so again I'll just go
ahead and walk you through this we start
off with 0 3 which is here and then we
go to 1 3 and then we go to 2 3 and then
we go to 2 2 and then we go to 3 1 and
then we go to 4 1 and then we are done
so again that's pretty cool but we want
to actually visualize it inside the
matrix here so let's write a new
function which takes a maze takes a path
in what it does is it returns a new
array which has only that path
highlighted so I can say print path in
maze is our function now it's going to
take a maze that's going to take a path
or path
and what we could do is just go ahead
and create a new 2x2 grid so I'll just
say blank is equal to arrays I made that
link fill it with underscores and then
map that to another array of mazey links
fill that with underscores this needs to
be made 0 so this will give us an M by M
matrix here and we want to do is loop
through all of our nodes of go through
our paths so I need to write some type
of helper recurse or function recursion
function which is going to just
overwrite the locations of all the paths
inside the blank array with the original
color string of our matrix that we pass
in
okay so one more time what this function
is doing is we're recursively
recursively diving down all the paths
and then replacing the values or indices
inside of our blank array with the
corresponding values of our original
mages that we pass in so down here I can
say constant M is equal to print path in
maze like a pass at that maze like a
passive path and then I could say in
let's see what that gives us and we see
down here it prints out the maze with
the path highlighted cool so I hope this
solution wasn't too confusing now that
I'm explaining it I think this was
pretty confusing but again this was a
harder algorithm to implement and I also
use kind of like a functional approach
to using like as many filters Maps
reduce as I could again if you have a
different solution or you think you have
a better solution that's more
straightforward feel free to paste it in
the comments and also if you liked this
video be sure to subscribe to feed Co
camp and like the video below and I look
forward to more videos in the future
hi thanks for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>