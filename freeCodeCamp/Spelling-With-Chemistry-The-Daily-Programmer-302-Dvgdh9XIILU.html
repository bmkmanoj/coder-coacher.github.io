<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spelling With Chemistry - The Daily Programmer #302 | Coder Coacher - Coaching Coders</title><meta content="Spelling With Chemistry - The Daily Programmer #302 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/freeCodeCamp/">freeCodeCamp</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spelling With Chemistry - The Daily Programmer #302</b></h2><h5 class="post__date">2017-07-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Dvgdh9XIILU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">a frito camper welcome to enough of the
daily program or web series video the
problem we're gonna talk about today is
called spelling with chemistry which is
number 302 on the daily program or
subreddit and before we break it on the
whiteboard I just want to say there's a
survey link in the description below if
you want to take it she's taking me like
a minute or two just so I can get
feedback on the videos I'm making in try
to improve them in a future all right so
let's break it down all right so for
this problem we're given a single input
for instance the string bacon and our
goal is to decompose that input using
the periodic table of elements over here
so for every symbol in this table can we
build up this string so they're kind of
walk you through an example the first
example we can build it up with B for
boron AC fracked inium Oh for oxygen in
for nitrogen right and then we also just
want to keep track of the weights here
if we were to sum all these atomic
weights together for this first example
we get a 267 and the purpose of the
weights is we need to return the maximum
way to build up the string all right so
that kind of overviews the problem let's
go ahead and look at two other examples
we can use da which is barium plus
carbon plus oxygen plus nitrogen and
when the atomic weights are summed up we
get 179 and then lastly this last way to
decompose this string using the elements
is we can use barium cobalt and nitrogen
which ends up summing to 209 using the
sum of the atomic weights and so again
the goal is given a string break it down
or decompose it using the element
symbols and then return the best
optioned with the most part with the
maximal atomic weights when summed up so
in this case this is our best answer and
we need to return that so that was a
good overview of what we need to do to
solve this problem let's go ahead and
work out how exactly we generate these
potential solutions and they pick the
best answer so we take a step back and
just think all the symbols in the
periodic table of elements is either one
or two characters right there's nothing
that
three characters at least the table that
they provide us an example so what we
can do is just try each possible one
character or two character combination
so they kind of walk you through this
I'm going to building a chart or a graph
which kind of represents the recursion
of the algorithm so starting off you
have a word for instance bacon and we
have two options we can go ahead and
pick off the first letter which leaves
us with a con yeah a con and then of
course keep track of whatever number
that was so I'll say that's the atomic
weight of ten point eight and then the
other option is we can take off a barium
which is BA and then the atomic weight
of barium is 137 and then leftover we
just have Co n over here so once you
reach this depth of the recursion or the
program we can then remove AC for
actinium but we can't remove a because
there's no element with just one symbol
so I'll just go ahead and say we remove
AC actinium is two two seven and then
again I'll just go ahead and pop off
those two so we're left with O and in
and then over here we can take one
character which is carbon so I'll go
ahead and say C and we're left with Oh N
or we can take C over kobold which we're
left with Co
are sorry we're only going to be left
with the end for the nitrogen and then
again carbon the atomic weight is 12 and
coal bolts 158 point nine and then
moving on to this level or this depth we
can again remove the O which is oxygen
which gives us fifteen point nine and
then we're left with n and then we're
left with the empty string here if we
were to remove nitrogen which atomic
weight is fourteen and there's no
particular way to remove O&amp;amp;N because
there's no
element called on so we have the same
thing over here we can remove the end
are sorry we can remove the oh and then
we can remove the end here and then
lastly we could just remove the end here
Tomic way to 14 and we're left with the
empty string so looking at this graph we
can tell that there's three possible
solutions right and the solution ends
when we reach the industry meaning that
we are able to take off one or two
characters all the way up until we reach
the empty string meaning that we've
built it up using valid elements and if
you notice here we kind of check before
we go down this path to make sure that
the element actually exists like there
is an element called a if there's not we
don't go down that path otherwise we go
down the other path so there's an
element called AC we can go down this
path so then looking at this graph it
should be pretty obvious how do you find
the maxima late to build up or decompose
this string using the elements atomic
weight so we can go through here and
just add them up down the path and I'll
kind of just do this off I'm not going
to do this a exact so I'll say ten plus
two to seven plus 16 plus 14 this path
we have 137 plus 12 plus 16 plus 14 and
in this file path we have 137 plus 59
plus 14 so this one is summed up we get
roughly 267 around there for this one
where you take barium we take oxygen our
sorry if you take barium carbon oxygen
and nitrogen we are left with we're left
with 179 roughly and then lastly we have
barium cobalt and nitrogen which leaves
us with 2 ohm
nine roughly so obviously this is the
best path that we need to take right
here because this is the maximum 267
over 179 and 209 all right so that kind
of is how you solve the algorithm by
hand right just you could just simply
draw out this little graph and then go
through and sum up your best path and
then return that as your option
pretty straightforward on paper right so
how would you kind of do this in code
and before we go to JavaScript let's
kind of break it down so basically again
just pop off the left or pop off one
character check the element exists pop
off two characters check if the element
exists if they do exist you can then go
down that path recursively
and try it again and then of course keep
track of the the element that you chose
and then keep track of the atomic weight
as you sum them up and then keep doing
that algorithm remove one character or
two characters check the element exists
for two characters if it does go down
that path etc etc until you reach the
empty string down here and then if you
reach this ending statement where you
have an empty string you should have a
running sum that's already up to 267 at
that point and what we can do is just
let's go ahead and add that to some type
of collection or an array where we keep
track of the symbols so let's say
symbols and then we keep track of the
sum so say 267 and basically we just
have this array that keeps building up
so this array will end up becoming RAF 3
where has objects where we have the
symbols we used in this case would be B
AC o N and then in this case would be BA
o in so I could say be a Co n and in the
final case we have be a co in lower case
and then the sums would be you know
whatever this is so 179 209 and I know
you probably can't really read this but
just know that you have an array at the
end that
has all of these symbols concatenated
and the sums added to it and finally we
could just sort this in descending order
and pick element zero so in this case
we'll just say pick the first element
after sorting descending and that's
going to be our answer all right so
hopefully that was a pretty good
breakdown of what we need to solve a
breakdown of how we solve it and let's
go ahead and move the JavaScript and try
to solve it in our editor so starting
off from showing you the problem as is
posted on the daily program subreddit
and you can see here they provide you
with a table of all the different
elements and their weights and their
symbol name so I did a little bit of
pre-processing which you're going to see
in the code that I'm just going to start
with a variable called elements which is
going to have all of its already defined
as objects and then again if you wanted
to look through this or see example
answers down below you can do so and
just hover over these gray text you can
see them so now that we have you know
information as to where that's coming
from let's go back to the code and you
see that I started out with a Const
called elements I'll actually going to
make this all caps so it's understood
that it's a global and then in each
property of this object we have the
symbol name which maps to an object that
has a name of ailment and the weight of
that element and then down at the bottom
I'm just going to go ahead and call
spell with chemistry which will be our
functioning we're trying to implement
and I'm passing bacon to it so we can
actually start testing out with the
bacon so to start off let's go ahead and
write a function called spell with
chemistry which takes an original word
and then what we need to do is again i
gorg backwards I'm going to declare a
constant called results and set it equal
to an empty array and then like we said
on the whiteboard I need to return the
first element of results after or right
after we sorted right so again we're
going to resort this somehow in this
case let's just say that we have a and B
are the elements in the array and then a
should just be an object that has the
weight value so I can say B dot weight -
ate out weight
so that should sort it in descending
order so the zero index has the largest
weight so now that we've had like this
whole like boiler plate what do we do
after we find the different solutions
that we push in the results how do we
actually implement this whole you know
traversing the tree recursively so
inside our cell with chemistry function
I like to make a function called helper
which is going to take a couple of
arguments so that we can keep track of
the state as we Traverse down the stack
so the first argument is going to be
word which is the current state of the
word so bacon remove the B should be
athan or Co n or ONR in and that will
change the opinion where we go down the
tree we have another parameter argument
called symbols which is just going to be
the list of symbols concatenated
together which allows us to easily print
it out down the road and you can I think
that's optional you could just change it
as you want to the third parameter is
going we called Elms which is the
elements in fact I was called elements
which is going to be the list in order
of elements that we put into the results
in order to build it up and then finally
we have a running sum weight so as we
pick elements we just keep track of the
weights and push that into our recursive
function and then of course since we
have this helper function we need to
call it with an integer or the original
word which is going to be bacon in our
case an empty string for symbols I'll
say an interior a for elements and then
0 for the weight so again just take a
step back what does help we're supposed
to do it's a function that supposed to
traverse that graph and then when it
gets to eat in being a terminal node or
an empty string we push the result into
a result array so again I'll repeat that
if we reach a terminal node so how do we
determine a terminal node well the
length of word will be equal to 0 right
if it is that we know that we've reached
a node which actually can be spelt out
the symbols list or the periodic table
elements
so again we start with if word length is
equal to zero we can just go ahead and
return results that push and we can push
in the the list of elements we use so in
this case I'll just say output which is
just going to be a string output we can
use where we output the symbols and then
followed by a space we're going to
output the elements that join like so so
basically this is going to print out a
string which has the actual string built
up with symbols and then followed by is
going to have all the elements we used
in order written out with their actual
element names and then lastly we can
just print out they're running some
weight or or put that inside the object
so that we can later sort it down here
on line 122 so now we have the base case
of our recursive function typed out we
can now start working on the else
statement and I'm actually going to try
to use more like es6 functional
paradigms so what we can do is remember
we have two options we can try to get or
pop off one character or we can try to
pop off two characters and then we need
to check to see if those characters
first of all put it out of bounds so I'm
going to go ahead and do a filter on
this array and I want to filter out any
of the choices which put us out of
bounds so I could say were links - none
cares greater than equal to zero so I
only want the numbers which keep us in
bounds so for instance if we write the
very end and so bacon we get down to the
character in so if word was in for this
example we don't want to filter on - or
we don't want to to pass our filter
because if we try to take two characters
off of that word is going to crash right
so that's why we have this filter on
1:19 so now that we know which none
characters we can actually try we need
to go ahead and map those num characters
to their actual symbols and map them
back to this element so right at the top
so to do that I'm just gonna pretend
like we have a function that's called
get symbol which we can pass in our
current word and pass in the number of
characters we want to remove from the
front of that word so I'll go ahead and
call it get symbol here but since I was
undefined we're getting an error so I'll
go ahead and define it up here and pass
it word and num characters as parameters
and what we want to do is when passing a
word we want to take the first two
characters of that word or whatever
characters num characters is so we could
take the first character or we could
take the first two characters then we
need to take the first character in it
make it to uppercase so we can actually
find it in our symbols array and then
we're going to concatenate that with
another substring of num cares so again
take either the first or the two
characters and then just concatenate
that capital first character with the
rest of the string here so again if we
were to call get symbol here with let's
say bacon and then pass the two
characters I don't think this is going
to run right now because oh it does run
so again look it prints out to be a if I
were to change this to one it just
prints out B capital B all right so
that's what gets symbol is doing its
just returns the first two possible
symbols that you can build with a string
so then again so again we have one and
two we filter out the ones that don't
put us out of bounds we map into their
respective symbols and then we want to
filter again to make sure that the
symbol that we've trying to generate
actually exists in our array so we just
say elements dot symbol so only give us
the symbols which are real elements in
our periodic table of elements and then
finally we can just loop over each
good symbol and recolor for a recursive
helper function right so I in here I
could say for each symbol call our
helper function one more time and then
in this case we're going to remove those
first one or two characters so I could
say or dot substring of symbol dot
length so that could return remove one
character or that might remove two
characters from word we want to
concatenate that symbol string with the
symbol we chose we want to concatenate
the elements that we have previously
chosen with the element that we just
chose so I'll say concatenate elements
typing cat with elements of the symbol
name and then lastly we want to keep
track of that running some await so if
you say wait plus elements of symbol dot
wait
so everything seems to be working fine
and now if I scroll down to the bottom
we so we see here in the output below it
printed out bacon with boron actinium
oxygen and nitrogen and gave us a weight
of 267 and then again just to show that
we got multiple results I can just go
ahead and point out the results here and
we see that we get an array of three
different elements where the first
option is this type of dispelling a
bacon the second option is this smelling
a bacon which gave us a way up to nine
and then third is this bacon with 239 so
that wraps up our solution or
implementation for the spelling with the
chemistry problem this problem was a
little bit more challenging than any of
the other problems I think I've done in
the past
mainly because we're dealing with
recursion in this one it's a little bit
more complicated to build up and
traverse that graph but if you did have
issues understanding this be sure to you
know watch tutorials about recursion try
to solve easier recursion problems such
as like Fibonacci just so you understand
our def first search breadth first
search or whatnot and then hopefully
after learning those you can come back
and get a better understanding of how
you solve this yourself also as a
reminder there's a survey below which
should take you about two minutes to
fill out just so I can get feedback as
to you know how difficult these problems
are are these helping or these not
really helping is there a way I can
change these videos to make it so you
can comprehend when I'm teaching better
again feel free to leave me any type of
feedback and be sure to subscribe to
free cook camp below and like the video
if you thought was good all right again
I'm Cody and thanks for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>