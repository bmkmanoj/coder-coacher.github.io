<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Heap Data Structure (max and min)- Beau teaches JavaScript | Coder Coacher - Coaching Coders</title><meta content="Heap Data Structure (max and min)- Beau teaches JavaScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/freeCodeCamp/">freeCodeCamp</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Heap Data Structure (max and min)- Beau teaches JavaScript</b></h2><h5 class="post__date">2017-05-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dM_JHpfFITs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">a binary heap is a partially ordered
binary tree which satisfies the heap
property it has some similarities to a
binary search tree except the order is a
little different each node has at most
two child nodes the heap property
indicates a specific relationship
between the parent and child nodes you
may have a max heap in which all parent
nodes are equal than or greater to than
the child nodes so you can see the the
biggest numbers on top and the smallest
numbers are on bottom or you may have a
min heap in which all child nodes are
greater than or equal to the parent
nodes so the child nodes are the biggest
ones and the parent nodes are the
smallest ones the Oder between child
nodes on the same level does not matter
so you have 10 6 and 12 here here we
have 5 6 and 1 you can see that it goes
from a small number to a big number to a
small number the order doesn't matter if
they're on the same level binary heaps
are also complete binary trees this
means that all levels of the tree are
fully filled and if the last level is
partially filled it is filled from left
to right so if you see the example down
here so here's level one then we have
level two here level three level three
is all the way filled level four is only
partially filled because there's nothing
over on the right side here but you can
see it's filled from left to right
binary heaps may be implemented as tree
structures with nodes that contain left
and right references like what I showed
in my binary search tree video however
heaps are more often implemented as
arrays this is possible because of the
partial ordering according to the heap
property we can just compute the
parent-child relationship of the
elements now this will make a lot more
sense with this diagram here so if you
see this array right here this is the
array representation of this tree right
up here the number 1 is 20 and that's
the root you can see that right up here
and then 2 and 3 are the child knows 19
and 17 right here and now I want to pull
your attention over to these equations
up here so that the left child is going
to be I times 2 the right child can be I
times 2 plus 1 let me show you what that
means so if you look at
here which is at index one in the array
also I should point out that there is no
index zero so when you're representing a
heap you're just going to leave index
zero as null to make the math work out a
little better so if we go back to index
one well the equation for the left shell
is I times 2 so 1 times 2 would be 2 so
yeah 19 is the left child and the right
child is I times 2 plus 1 so 1 times 2
plus 1 is 3 17 that's the right child
now let's say we go to number 13 here
that's index 4 well if we go to the
equation I times 2 4 times 2 is 8 so if
your index 4 and you go to index 8 11
yep that's the left child now we start
index 4 and we do the right child
equation I times 2 plus 1 that's 9 so if
we go to index 9 yep that's the right
child here so that's how you can use
these equations to find the left and
right child from an array representation
you can also figure out the parent so
the equation for a parent is I divided
by 2 if we are on 11
that's index 8 8 divided by 2 is 4 index
4 and this really should be floor I
divided by 2 because you divide the
index by 2 and then round down to the
nearest whole number
for instance 5 divided by 2 is 2.5 but
if you round out it's 2 and then 2 would
be the the index 19 here also you can
see in this diagram that the last index
is also the size of the heap size 10
this diagram is a max-heap I'm going to
show you the code for a min heap but in
the same file down here we I also have
the code for the max heap down here so
you can check the link in the
description so you can review this
actual code yourself and you can review
the max upon your own but like I said
we're just going to review the the men
heap right now but before I show you the
actual code I want to show you a visual
representation of how it works when
you're inserting and you're removing
items from the heap those are the main
two commands insert and remove and then
there's one more I'll show you at the
end but let me show you this
representation here so you can see this
is the array representation and I'm
going to insert some numbers and you'll
see them show up as a tree
representation so let's see 4 you can
see 4 goes at the top that's the the
root node now I'm going to put in 6 6
just goes down to the bottom there 8 so
as it builds the node one thing to keep
in mind is that it's going to build one
level of the tree at a time I'm going to
put in 10 it's going to be on the very
left side now so far I've been putting
them in order but now I'm going to put
in the number 5 here and when I insert
the number 5 you're going to see this
it's going to first go to the end of the
array here you'll see their array which
is going to first appear right down here
and then it's going to move up to the
correct position so let's see that so
then as you see it checks what position
to move it up to so I'm going to put in
a few other numbers here see 16 3 okay
so you see it always puts in at the end
of the array or the end of the tree and
then it moves it up to the correct
position now I'm going to show one more
where I put in one where it's going to
put it put it down here and it's going
to move it all the way up to the top and
it's a check one at a time to see if it
has to move it up also another thing
would just be removing what when you
remove you always just remove the
smallest it's going to remove what's in
index one which is always going to be
the smallest and then it's going to pop
the last node to the first node and then
it's going to sort them so let's see how
that works
so did you see that so it moved the last
node to the first node and then they
have to keep checking and keep moving it
down until it gets to the right position
so let's move remove three okay so now
let's go to the code and you can see how
that works
in the code so before we insert anything
you can see that we've created a heap
with an array that just has one item and
it's the item null at index zero so when
we insert something we pass in a number
and we're going to push that number on
to the end of the heap so if you pass in
the number three there's going to be
index zero is null index one would be
three
now if the length of the heap is more
than two that means there's more than
one item in the heap if it's less than
two there's one or zero items in the
heap and that makes things really easy
but let's say it's it's more than two so
we're going to let the index equal keep
that length minus one so that means
we're finding the last index and the
heap while heap at that at the last
index is less than heap and then see
this equation right here that is the the
parent equation so now we're saying if
the last item in the array which is the
item we just inserted right here if the
last item in the array is less than its
parent well if it's less than its parent
we're going to have to move it up
because the smallest numbers have to be
at the top in the men heap so if the
index is more than or equal to one that
means if we haven't reached the root
node then we're going to do this now
this is es6 destructuring syntax which
just means we are going to switch the
node we just inserted with the parent
node we're going to we're going to
switch them so here is the parent node
here is a node we just inserted and now
we're going to switch them so the node
we just inserted is going to be first
and then the painter node is going to be
next so it's just a way to swap them for
more information about the es6
destructuring
you can check out my video about that
topic so if math math dot floor index
divided by two is more than one this
just means if the parent node is not the
root node because remember this is the
equation for the parent node
is the index of the root node so if the
parent node is more than the root node
then we're going to set the index to map
that floor in X divided by two that's
the parent node which if you remember up
here we just put the number we pass in
into the parent node so now the index is
still going to refer to the number we
just passed in because that number has
went into the parent node and so now
we're going to set the index to that
node and since this is a while loop when
I keep going through this and we're
going to keep switching the the node to
its parent node as long as it is smaller
than the parent node else break so once
it's not smaller than the parent know we
just get out of this while loop and
that's the insert so let's go down to
remove it's a little more code and but
it's some similar concepts so we are
always going to remove the top node the
smallest node so we're going to let this
smallest equal heap one so that just
means that the first node in the array
is the smallest node so that's the easy
part the hard part is rearranging the
array after you've removed that node
so if heap that length is more than two
that just means we have more than one
node in in the tree we're going to set
the first node in the tree which
remember was the smallest node but we're
going to set this to the last node the
last node in the array now gets moved to
the first node in the array now we're
going to heat that splice keep that
length minus one this just shortens the
array by one so we just remove the whole
the last index of the array completely
since we've already moved that to the
first index if heap dot length equals
three that means there's only two
numbers in the tree and that makes
things really easy just if one is bigger
than the other then we just switch them
this is the destructuring syntax again
so if the first one is bigger than the
second one then we switch it so the
second one is bigger than the first one
and then we just return the smallest if
there are more than two nodes in the
array that's where it gets slightly more
complicated so we're just going to set
the index equal one
we're going to set the left equal two
times I and the right equals two times I
plus one remember that was just that the
equations from up above the equations
right here we're just putting them into
our formula down here now technically
you would not need to put this equation
here since we know that I equals one you
could just put three here you just put
four here but this is just so you know
we're using the equations from above so
we remember one is the root notes or
starting with the runo so while the root
note is more than or equal to its left
child or the root note is more than or
equal to its right child we're going to
do everything in here that means we're
going to have to basically move it down
and keep moving it down until we get to
the appropriate spot so if the the left
node is more than the right node then
we're going to switch the root node with
the left node this is the destructuring
syntax again so we're going to just swap
the nodes so for instance we would be
swapping if we're on this node and this
so we just swap those two nodes and then
we're going to set the index to the left
node so we're going to set the index to
be the node that was at the top node but
has now been swapped else that means the
right node is less than the left node
we're going to switch the node with the
right node so we're just going to swap
with the right node and then we just set
the index to be the right node so the
node just moved down a little bit and
then we set the index to point to the
node that we just pushed down a little
bit and then we have to set the new left
and right node so we would set the left
and right node to be the left and right
of the the one we just passed down and
then if the the left child or the right
child equals undefined that means we're
at the very bottom of the tree so we can
just break out of this while loop and if
it's not undefined we just keep going
through until we find the place where
the node that we're moving down the tree
is not more than equal to the left node
and is not more than or equal to the
right node else if it's only equals two
that means there should be only one
element in the array so we just cut off
the last element else we return null
that means there were zero elements and
they
Raye to begin with and then widgets been
returned the smallest element which is
just the element we just set up here the
last thing I'm going to talk about is
this now a common use case for the heap
data structure is for heap and sort this
is one of the most efficient sorting
algorithms with average and worst-case
performance of o of n log n heap sort
works by taking an unsorted array adding
each item in the array into a min heap
and then extracting every item out of
the main heap into a new array the min
heap structure ensures that the new
array will contain the original items in
least to greatest order so this is the
function that you would use to do that
heap sort
the hard part is creating the all the
code we just already went over and this
is just going to use that code so let
result equals new array while heap that
length is more than one we're going to
add if that remove so we're going to
remove the element on top of the tree
and we're going to push onto the result
and we're going to keep doing that until
we've moved removed all of the smallest
elements and push it on to the result
and it's going to put the elements in
order well that's all I'm going to talk
about for heaps feel free to check out
this code and create your own heap and
and add some items and remove some items
just to see how it works thanks for
watching my name is beau Carnes don't
forget to subscribe and remember use
your code for good</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>