<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Binary Search Tree: Traversal &amp; Height - Beau teaches JavaScript | Coder Coacher - Coaching Coders</title><meta content="Binary Search Tree: Traversal &amp; Height - Beau teaches JavaScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/freeCodeCamp/">freeCodeCamp</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Binary Search Tree: Traversal &amp; Height - Beau teaches JavaScript</b></h2><h5 class="post__date">2017-04-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Aagf3RyK3Lw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in my previous video on binary search
trees I covered all the basic concepts
so definitely check that one out if you
haven't seen it yet
in this video I'm going to talk about
finding the tree height and tree
traversal height in a tree represents
the distance from the root node to any
given leaf node so if you look at this
example over here the root node is nine
that's height zero but if you see four
and seventeen here
that's height one three six and twenty
two height two five seven and twenty our
height three so it's the distance from
the root node to the leaf nodes they're
kind of like layers of a cake and that's
how you're gonna count them different
paths in a highly branched tree
structure may have different heights but
for a given tree there will be a minimum
height and a maximum height and if the
tree is balanced these values will
differ at most by one so before I show
you the code to implement those things
I'm going to show you the use of the
code we're going to go all the way down
to the bottom where we create a new
binary search tree and then we add all
these values with the those values they
are the same values as in the picture
over here we're gonna find the men
height we're gonna find the Mac site and
we're gonna check if it's balanced let's
just comment out these now so it's
showing the min height is one in a
console the map that is three and it's
not balanced the min height is the
distance from the root node to the first
leaf node without two children so if you
look on here 17 is a root node without
two children it has a right child but
doesn't have a left child so the minimum
height you started at the root node
which is zero and then you count to the
next level which is one so the min
height is one now the max height is just
the distance from the root node to
whatever the the most bottom node is so
five seven and 20 are all at the max
height so zero one two three so the Mac
side is three now this tree is not
balanced
because remember if a tree is balanced
the values between the min height and
the max height will be different most by
one you can see that there's a missing
number here the reason why this tree is
not balanced is because there's no
number here to the left of 17 but if I
uncomment out this code here we're gonna
add 10 now 10 you see when it's being
added it's going to add to the left of
17 because it's more than 9 but it's
less than 17 so the tin will fill this
spot right here and then we're gonna
find the min height the max height and
then check if it's balanced again okay
so now the min height is 2 and the max
height is 3 the min height is going to
be either this 3 or the 10 that we just
add that it's not showing up in the
picture but just imagine there's a 10
right here so we have 0 1 and then the
min height is this level right here
because this is the first level that
there are node without two children if
you imagine there's a 10 right here so
that's 2 and then 3 is down here right
now is balanced is true the difference
between the min height and max height is
at most 1 so it's going to have to be
either 0 or 1 to be balanced when a tree
is balanced then searching through it is
much more efficient we're not going to
cover this in this video but there are
ways that you can make a tree
automatically balance itself when you
add new items and when you delete items
this creates greater efficiency when
searching the tree ok now we're going to
look at these last lines I have to have
commented out here these are ways to
traverse the tree tree traversal methods
can be used to explore tree data
structures and basically find all the
values in the tree in depth-first search
a given sub trees explored as deeply as
possible before the search continues on
another sub tree when I show you an
example it will that will make more
sense but there's basically three ways
that this can be done there's inorder
traversal preorder traversal post order
traversal and this last one I'm going to
talk about later this level order
traversal so
let me run this and then I'm going to
explain it so here you look at the
bottom of the console and you can see
what we've logged here for in order
traversal you're going to begin the
search at the left most node and end at
the rightmost node so you can see this
this just has all the numbers in order 3
4 5 6 7 9 10 17 20 22 so there's all
these numbers in order you're going to
begin at the leftmost note and you're
gonna add all the numbers in order now
preorder traversal you can explore the
root nodes before the leaves so let's
look at this I'm gonna read off these
numbers down here and I'm going to show
up on the picture where they are in the
picture so we're looking at the root
nodes first in the list 9 is first
that's a root node then 4 that's a root
node then 3 and the next new troop is
gonna be six and then five and then
seven then 17 and then 10 which we don't
have on this picture then 22 and 20 this
is a pre-order focuses on the root nodes
first and then adds that there knows
below that the post order explores the
leaf nodes before the roots so look at
this one the first node on the list is 3
because it's the leaf all the way down
and then we have 5 because that's a leaf
node and then we have 7 and then we're
gonna go to 6 we're not gonna hop over
to 20 over here because that's on a
completely different branch of the tree
you have to finish all the leaf nodes on
one branch before you go to the next
branch so after 6 is 4 now is where we
jump over the leaf nodes on the next
branch and we use 10 which again is not
on the picture then 20 then 22 then 17
and 9 this level order is called a
breadth-first search this explores all
the nodes in a given level within a tree
before continuing on to the next level
first it's going to do level 0 which is
9 if you see these numbers on here and
the next time is next is gonna show 4
and 17 then 3 6 22 then 5 7 20 so let's
go over the code so first we're gonna go
over the code for the main height and
the find math side and it is balanced
so that is balance is pretty simple
because you just call these functions
that I haven't talked about yet but you
na'kal find min height and see if that's
less than or equal to by max height
minus one so this is going since this is
a conditional statement it's going to
return true or false so as an example if
you remember before we added the ten we
had the min height of one and the Mac
side of three if this Mac site is three
three minus one is two so is one less
than or equal to two
no false so we know that the tree is not
balanced we have false right here but
then we run it again down here and the
max height is three and the min height
is two if we do three minus one that's
going to be two so now we have is two
less than or equal to two
yes so we're gonna return true so that's
how we're gonna find out if it's
balanced now let's look at fine min
height this is going to be a recursive
function you can pass in a node but if
you don't pass in a node it's going to
set the node to the root node here and
then it's going to check if the node is
null and return negative one if you
haven't added anything to the binary
search tree it's gonna return negative
one for the height we're gonna set the
left and right to calling the Fineman
high on node left and Fineman height
node dot right so this is where the
function becomes recursive eventually
one of these two is going to be negative
one because the left or right node is
going to be null so here we are going to
add one to the left if left is less than
right and we're going to add one to the
right else so if right is less than left
and for five find max heights it's it's
the opposite so instead of having the
less than here we have the more than
here so here we're going to return left
plus one as if left is more than right
else return right plus one feel free to
check the code in the description to
play around with this yourself
the inorder preorder and postorder
there's a lot of similarities to the
code so let's look at the inorder
traversal first
the only thing that's going to be
different and each of these in order
preorder and postorder are these three
lines and the only thing that's going to
be different in those three lines is the
order of the lines so for all of them
we're going to check if the root is null
and return null that's just to check if
there's even a binary search tree that
exists or if there's any values in it so
if we find out that there is a binary
search tree we're going to do these
things I'm going to create a new array
of the result and we're going to add
each value in the list and the tree onto
the result so we're going to create this
function traverse in order function and
you can see down here we're going to
call that function and pass in the root
node and then after the function has
been run you're going to return the
result so inside this function it's
going to be recursive and remember these
three lines are the only thing different
between inorder preorder and postorder
it's going to change the order that we
check things so in order we are going to
first do this line so this right here is
short-circuit evaluation
whenever JavaScript evaluates the and
operator like this if the first thing is
true it will also run the second command
if the first thing is not true it will
not run the second command check my
video on short-circuit evaluation to
find out more about that so if no dot
left is true that means if no doubt left
exists then we are going to run the
tread Traverse in order function on no
dot left and that just calls the same
function again and passes n note that
left then we're going to push no data so
I'm going to push the value in that node
onto the result array and then we are
going to check if no dot right exists if
it does we are going to call the
Traverse in order function on no dot
right and if we look down here remember
I said they're just these three lines
are different so in pre-order it's going
to push first and then it's going to
call the function on
left and then it's gonna call the
function I know dot right in post order
it's going to call the function on no
dot left then call the function on no
dot right and then push the data so just
to order that we call these commands is
going to change the order of how we get
the result when traversing the tree
again you can check that code and play
around with it until you can figure out
exactly how it works I'm going to go
down to the level order function in this
method we start by adding the root node
to a queue then we begin a loop where we
DQ the first item in the queue add it to
a new array and then inspect both its
child subtrees if it's children are not
null they are each in queued this
process continues until the queue is
empty we are treating a result array
that we are eventually going to return
now here's just that the queue array
this is just a temporary array that
we're using that we're eventually going
to put things off that ray onto our
result
if this that root is not null if there
actually is a binary search tree we're
going to push the root node on to queue
and this is a while loop so it's going
to continue going through this until
we've actually added all the all the
elements from the tree so while Q is the
queue length is more than zero we're
going to keep doing these things so
first we're going to let note equals Q
dot shift now shift just takes off the
first element in the array and returns
that element so we're going to put the
root node into node because it started
out as the root node and now Q is not
going to have that root node on it
anymore and we're going to push no data
on to that result so we've just pushed
nine onto the result and if you remember
nine is the first thing in the the level
order result now if note that left does
not equals null we are going to push
note left on to the queue and if no
doubt right is not equal now we're gonna
push note that right on to the queue and
then then we're going to go back through
the while loop we're gonna take off the
first node and put into node which
remember is going to be no doubt left so
we push on here and we are going to push
that value
to the results I'm going to put forward
to the result and now we're going to
push no doubt left and we're gonna push
no dot right so in the queue we're not
gonna have three and six but when we go
back through the while loop and we shift
off an element even though we added
three and six in the last iteration of
the loop then know that we're shifting
off is going to be 17
because shift is going to take the first
item of the array off and three and six
are at the end of the array so then it's
going to get that value and so on it's
gonna keep going through this until it's
got every value from the tree okay this
concludes my video about height and
traversing trees thanks for watching my
name is Bo Carnes don't forget to
subscribe and remember use your code for
good</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>