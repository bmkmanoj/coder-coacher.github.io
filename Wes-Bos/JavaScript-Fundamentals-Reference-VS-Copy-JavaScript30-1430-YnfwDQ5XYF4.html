<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JavaScript Fundamentals: Reference VS Copy #JavaScript30 14/30 | Coder Coacher - Coaching Coders</title><meta content="JavaScript Fundamentals: Reference VS Copy #JavaScript30 14/30 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Wes-Bos/">Wes Bos</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JavaScript Fundamentals: Reference VS Copy #JavaScript30 14/30</b></h2><h5 class="post__date">2017-09-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YnfwDQ5XYF4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today we're going to talk all about
JavaScript reference versus copy and I
found this to be a sticking point and
while it's not necessarily going to be
something you're gonna build that's
gonna be sweet and your clients gonna
see it but this is something that is
fundamental to understanding how
JavaScript works and more often than not
this is the source of a lot of bugs
because people don't understand what the
difference between a reference and a
copy is especially when you get into
nested data so let's take a look at some
strings numbers and boolean's right here
if I have a variable or let's use let
here and age is set to a hundred and
then I make another variable called h2
and set that to age if I console.log age
and age to what are we gonna get 100 and
100 right but what happens if age is
equal to 200 and then I also console.log
Asian h2 what are we gonna get are we
gonna get two hundred two hundred or two
hundred 100 okay good now we get 200 100
why because the value of age goes into
the variable at the same time that works
the same way with strings if I do Const
name or let I'm going to reassigning
these so I need to use let Wes and let
name to is equal to cool Oh No let name
to is equal to name
console long name and name too you
probably will see Wes Wes but if name is
equal to Wesley and we also console.log
that what are we gonna get
Wesley Wes okay good so the values of
strings numbers and billions go into it
and if you change the original one it's
okay it's not going to update the other
one make sense now let's actually work
with an array let's say we've got some
data here and we want to make a copy of
the array so we say Conn steam equals
players and that should make sense
console log players and team just to
make sure we got both of them here okay
that's the same array here so you might
think that we could do something like
this where we changed team
is equal to lakhs now if I look at team
you'll see Lux is the last one but if I
look at the original one which was
players
what should the last one be should it be
poppy as it was or is it gonna be
updated to lux
ah it's Lux again so what happened there
because we updated team but team is not
the array team is just a reference to
the original array which is players so
when you edit that original array or
when you update any of the arrays it's
always going to go back to the reference
where it was which is not the same as
what we did here with numbers strings in
boolean x' so that's interesting if you
update an array it will always reference
back and that's what I find people do is
they oh I just want to make a copy of
the array and update it so what we then
need to do is make a copy rather than a
actual reference and there's a couple of
ways that you can make a copy of a array
because I can't steam to equals and you
can take the players and just call slice
against it and if you call slice players
don't slice that is just going to return
the entire array because generally what
slice does is you ask for two and three
and that will give you one of them
whereas the original array is untouched
right but what slice will do if you pass
it nothing is it will take a copy of the
actual array here let me just comment
out this changing of the earth so let's
take a look we got players and we have
team two and if I were to change team
two to Lux team two has Lux in it but
players still has papi because we made a
copy of it with all right another way
you can see people do it is if we make a
team three you take a blank array and
you concatenate in the existing array
and that will just concatenate all of
the items from that players array into
the empty array here that will work the
exact same way and then finally we can
use the es6 spread way which looks like
this
Kant's team three or four equals you
create a new array and you spread into
that array with the players and what a
spread will do is it will take every
item out of your iterable and put it
into the containing in this case it's
the containing array although we have
also used spread to spread into a
function as well so that will take a
copy of it just as well the team for the
last one it's going to be equal to he
huh and console.log team form you see
the last one but if I go back to my
players array it's untouched then
finally we could say constant team 5 is
equal to array dot from and then you
pass it your players array and if we
were to look at team five that's our
array and we were to change one of them
then players array untouched
whereas team five has been updated so a
whole bunch of different ways a readout
from in the spread is probably my
favorite way but any of these ways will
work just fine now the same thing
happens for objects as well if I have a
person object here and I want to make a
copy of it you cannot do this Const
captain equals person because if you
change the captain's number two ninety
nine so person is now ninety nine even
though person should be eighty and we
just update the number two ninety nine
we just made a copy or sorry we made a
reference to the original one so how do
you take a copy instead that is with
something called object dot assigns
object assign the way that it works is
you start with a blank object you pass
it the object you wish to copy all the
properties from which is person and then
you sort of fold in your
new properties that you wish to
overwrite which is number it's going to
be 99 and then you stick that entire
thing in your own Const cap to equals
stick it into its own variable now when
it console.log cap to you'll see we have
I gotta come with these ones out here 99
however if I go back to person the
number has not been added to that one at
all
so we just added them in saying goes if
I wanted to have a number of 99 in age
of 12
the captain is now 12 but the person is
80 so what happened there is we take a
blank object we overwrite or we sort of
fold in all of the properties and values
from our object and then we use the
third argument to fold in our own ones
we are going to be getting or hopefully
it's it's not confirmed yet but we will
be getting a cap 3 which is called an
object spread and you may be uses if
you've ever done any react before and
it's not a thought person and that works
exactly the same way as we spread into
an array but you can spread into an
object now one thing that we do need to
know is this is very shallow meaning
that it will only ever go one level deep
so if we create a new object here so
Const Wes equals name is Wes age is 100
and maybe we'll say social and Twitter
is equal to at Wes boss and Facebook is
equal to less boss thought developer
okay good then I've got this this object
here Wes let's pop a quick console dot
clear above it so it clear out
whatever's in here Oh
obviously this is not going to work that
that thought why because object spread
is not in JavaScript yet so we have to
comment that out there we go so we've
got this object here that's the person
you open up social and we have the
object there now if I want to make a
copy of Wes we would say Const dev
equals object
a sign we take a blank object and you
pass in Wes as we have here good so I
have dev that's good
dev name equals Wesley now Wes is still
Wes and dev is Wesley so you see how we
took a copy of that object and when we
update it it's not going to update the
original one so it's not a reference how
ever what if we do this dev dot social
dot Twitter is equal to at cool man
now dev dot social the twitter is there
but what if I look at Wes that's social
now oh shit look what happened because
when you use object out of sign it only
does one level deep if you need to go do
a clone you have to get out a function
and go online and find it where it's
called clone deep and that will clone
every level as deep as you want although
before you do that you should ask
yourself do I really actually need to do
this maybe I could be doing it in a
better spot because very rarely do you
actually need to clone an object that
deep so we have that and then another
sort of cheating way the poor man's deep
clone and I'm not recommending this but
you could say constant EV 2 equals Jason
dot parse Jason dot stringify
and you pass it your person now we have
dev 2 and then we say dev 2 dot social
dot Twitter equals at Google man and now
if we look at Wes that social has not
been touched why because what you can do
is you can take json stringify
and pass it an object and that will
return to a string that's no longer an
object and then you immediately jason
dot parse it to turn it back into an
object and then you get a full copy of
it rather than and you shake all the
references have no idea about
performance with that you won't want to
look it up before you
it but it's often referred to as the
poor man's deep clone other than that
hopefully you learned a thing or two
about object references and array
references versus actually copying them
see you tomorrow
[Laughter]</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>