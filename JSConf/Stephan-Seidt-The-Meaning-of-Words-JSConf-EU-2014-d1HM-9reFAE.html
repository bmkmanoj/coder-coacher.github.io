<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Stephan Seidt: The Meaning of Words | JSConf EU 2014 | Coder Coacher - Coaching Coders</title><meta content="Stephan Seidt: The Meaning of Words | JSConf EU 2014 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Stephan Seidt: The Meaning of Words | JSConf EU 2014</b></h2><h5 class="post__date">2014-11-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/d1HM-9reFAE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Thank you (Applause) thank you.
Da‑da.
Good evening, we oar almost done with day
one.
If you don't know me in my free time I submit
presummually JSConf 2014 talks and sometimes
I write funny tweets such as a JavaScript
funk returning this shall henceforth be known
as a Selfie (Laughing) before the talk (Trumpets)
before the talk, I worked for Contentful if
Berlin, they paid for my flight.
They're hiring script developers.
Okay.
The meaning of words.
I want to start by reminding you of a ‑‑
of someone's guiding principle.
Creators need an immediate connection to what
they're creating.
This is Brett victor's guiding principle I'll
show you some of his ideas following this
principle to give you an idea of what he's
talking about.
On the right side we have an editor, on the
left we're showing a picture the code generates.
The editor allows direct manipulation of values,
changing a value on the right gets an immediate
result on the left.
There is no compilation or any other sort
of waiting, every change is instant.
So, Brett thinking this immediate connection
is very important.
You can't do certain things if the computer
makes you wait all the time.
And I very much agree.
 ‑‑ Brett is very inspiring go watch
all his videos if you haven't.
I think his ideas should be part of every
creative environment.
However, I thought I'd play his principles
to something different.
So, the ideas I'll show attempt to remove
everything that stands between your idea and
running or sharing it as a program.
So, do we have an immediate connection to
what we're creating in JavaScript? Nein.
I think this preference million is often violated.
Are many things which are actually disconnecting
us from our creative process.
Setting up development environments is a pain
in the ass.
Here's a tweet.
If you set up your development environment
yourself, and if you can't tear it down and
recreate it in one command you are coding
in prototype.
I think Jessica makes an important point here.
Jo hulledn't have to copy paste or overflow
answers with the highest vote rating or whatever,
or Blog posts.
All of this stuff really must be automated.
But, even if you're using something like Vagrant,
it's going to take time until your environment
is set up.
Alas, we're not done with waiting for things.
Another thing we wait for is long running
tests or MPM install or deployments to servers.
Like for example when a test run takes more
than a few minutes, I can't do anything during
that time that changes it's outcome.
I'm forced to work on something else and when
I get back to the test result, when it's done,
my mind will have lost all context.
Another disconnect is managing package deopinion
den say and releasing packages.
We depend on packages also on NPM and GitHub
and other places, where it gets really fun
is when you're publishing your own packages
there, coordinating between these different
services is difficult and you will make mistakes
unless you're very careful.
For example it's possible you mixed up version
numbers between NPM and GitHub.
There's even more to fix like randomly occurring
CIRs, test timeouts or third party failures,.
Here's a tweet that sums it up nicely, I think.
Programming is the act officiousing one error
so you may proceed to the next error, by Michael
Fogus.
It's Ironic and probably true.
This is wanders above the sea of flog by Fredirich.
Pictures have different interpretations just
like JavaScript syntax rules.
John Gaddis an American historian felt that
the character of a wanderer is contradictory,
suggesting mastery over landscape at the same
time the insignificance of the individual
within it.
Computers are insanely powerful, but, still
we can realize the full potential of our ideas.
Maybe we are the wanderer above the sea of
computation.
We like to look at terminal windows or at
least we think we do.
It is certainly part of our identity.
The text displayed to us offer abstract descriptions
of what's going on.
It alerts us of problems and eventually will
always ask us what we want to do next.
So while the terminal is a great interface,
I think we're too often doing things that
the computer is better at.
We suck at playing computer.
So, ‑‑ Ooops.
Sorry.
Befehlsze Ilenbeklemmung, having forgotteden
what you want to enter into the command prompt.
The terminal interfaces we use are well designed.
That's because most of them are four years
old.
But that's not the problem, what ‑‑ because
we can imitate great examples from the past.
What matters is that I want to work with people
who aren't programmers.
I also want to teach people and seriously
get them started with programming.
I don't want to tell them what they're supposed
enter into their terminal when stuff goes
wrong.
And the same is true in my job where people
are using my tool automation.
If your process is sufficiently complex you
need to automate it.
Browserliebe, browser love sharing, sharing
an internet address lovingly for browser consumption.
Browsers are powerful,both as instruments
of media consumption like looking at cat pictures
and it's instruments of creation, you're also
read so the demo I'm going to show you later
is browser‑based, I wanted to build something
that I can share immediately.
There is no read me with a pattern of commands
or please download this and install that instructions.
It just works.
Hopefully.
Because it's a live coding demo.
So, let's look at a couple of problem areas,
I'll focus on dependency management and building
in today.
So, what does depend mean? It means that code
that we write depends on a stack of things
working properly, which is the hardware, and
the operating system no J S or browsers or
dependencies we use.
So as an example let's assume we have a Mac
with node installed and let's build a package.
So, I don't know about you but I had a fantastic
breakfast this morning, let's write a module
for making pancakes.
So, usually I search for modules that I can
use, so let's to search.com and look for things
that we can use ‑‑ NPM search.com.
There's NPM.org search.
I usually get this.
I don't even understand it.
Well, I do, but ...
so, then we found our packages and I need
to itch stall these packages, so I switch
to ‑‑ and we need to install these packages,
so I as much to terminal and install the commands
for the packages I found.
Next, well, what next ‑‑ wait for a few
seconds or minutes depending on what it's
going to download, and after that I open my
file from the terminal.
And finally we're in the code.
In my editor like ten minutes later, I begin
by requiring the modules I installed just
before.
And then I can write my function making use
of the modules I found.
We'll do this in a demo.
At last I explore my bacon pancake factory
function, we need to be a proper module citizen,
then I go back to step one and two to find
and intell a suit suitable testing framework.
I go back to ‑‑ create a file that puts
the tests, sorry, create a file to put the
test for our module N the test we're going
to require a test framework and our own module
and finally write our test Phew! So, I don't
know about you, but, this is really complicated,
this really sucks when you're maintaining
many small modules you have to do all most
all of this by hand and many, many times.
And it's incredibly easy to make mistakes.
Of it also gets very repetitive for files
within the same package, for example, when
you're building a react up with nicely separated
components in their own modules you'll have
to require react in every single file.
As programmers, seeing the same block of code
usually makes us forthing with rage! That's
not Dry! But in case we accept our reality.
Weird isn't it.
Of so what if we went back to here and we
remove everything that isn't our code? If
of we're left with function declaration.
It's calling pancakes and bacon and it's passing
an array of results into fry.
What if we just tried to run this now? We
better reports that some words are not defined ‑‑
well, of course, you might think, but think
for a moment, these are words that have meaning
for us.
We know that they exist, somewhere, and we
know what they're supposed to do, we have
expectations if we understand them, why can't
the computer? So, to help the computer to
understand, let's look at how the computer
sees code.
This large blob of text is the abtract industry
and you don't need to read it.
So, we search the DAC for words or in terms
of ‑‑ identifier nodes.
And each time we find an identifier we check
to see if it's been defind anywhere in our
file.
And since they're not defined in this case,
we get a list of these three identifiers.
Which is what we saw before.
So, we have our unknown identifiers, and we
match these against our known words.
What are known words? They're things we remember.
They're modules we've written ourselves.
They're modules like ‑‑ there are modules
on NPM like redact or load ash, or there are
modules like note build like HTTP or FS.
Well, it turns out that a simple functional
transformation of your code and a prediction
of words that you're referred to yield the
expended code that you can run, and pass into
note ‑‑ and it works, prepending the
appropriate required calls and exporting your
main module, we'll see that in a bit.
So, and that means that a series of manual
commands that you have to enter into terminal
and editor can be expressed by just mentioning
a word.
I think that's a pretty powerful idea.
So before we go to the demo ...
I want to talk about building stuff.
So, what does build mean in our context? It
means taking our source and our dependencies
and creating something that can be executed
by node or a web browser.
Docker is an amazing tool, we're going to
use it as a very efficient build system and
&quot;runtime&quot; you can post a ‑‑ archive of
your code and dependency to a docker DBHM
point and it will extract the archive and
build our package running any commands we
tell it to.
And in the end, it will spit out a nice little
contain their can be run on any other docker
host.
That means we can run this container on our
local development environment, but also on
a core OS cluster of thousands of nodes.
At the end of the word look up face we end
up with a dependency tree.
Sort of like an MPM shrink up file that includes
everything required to install something.
Okay.
Demo time.
So, FN, F 1 ‑‑ thank you Jan that didn't
work (FN + F 1).
&amp;gt;&amp;gt; Try it now.
&amp;gt;&amp;gt; Command ...
yes! Are you seeing what I'm seeing? I think
so.
So, this is my prototype editor.
So we go in here and we have a name and we
have a description ‑‑ hold on.
6 (Making pang cakes that's what it's going
to make, pancake pancake (Singing).
&amp;gt;&amp;gt; Can someone come up here and dance please.
So, this is probably something went wrong
here because this function is returning a
German sausage specialality.
So, let's just, you know, turn this into something
which we want so making bacon pancakes means
frying bacon and pancakes.
And let's remove this comment.
So we have used these words and our editor
knows that these are not defined yet, so we
go in here in to bacon andism me meant this
function and we go back and it's defined.
Magic.
And liquid kind of magic and we go to pancakes
and we return pancakes.
Go back again, another function defined and
there's one more left, which is frying, so
frying means making a set of items hot, so
we take the items, we want to cook, and we
join them in a string.
Okay.
So ...
we go back once more and we have a program
which the computer is, fully able to understand
and knows everything we're using in our program.
But, we're not calling this function yet.
Let's create a command line interface for
this.
Okay, so ...
we're going to build the JS Con of breakfast
modeling interface.
So, it's a new module.
And we are going to just ‑‑ log ‑‑
so we call our make bacon pancakes function
and we also call the function we just defined
in our program.
Makes sense? Okay.
So, here comes the docker part.
When I click &quot;engage&quot; this dependency tree,
which has been generated is going to be turned
into a jarble archive and posted to the docker
Daem no which will turn it into a nice image
we can execute.
This is the name of the image, let's go to
my terminal and rune run it.
Works (Applause) so, let's go into the docker
container and run bash.
Free docker tutorial.
So here we have index such as, which is ‑‑
which has a required statement, we have to
recall it typed into our editor and exporting
this thing as a module.
And we also have ‑‑ sorry, we also have
node modules with the function we referenced
and there's another index of JS in here, which
is our making bacon pancake function, it is
also requiring stuff this is probably very
obvious by now but, there's even more modules,
right.
And it's like bacon for example also as an
J S file and it's returning a string bacon
and exporting itself.
So, we turned this very simple to understand,
I would say, representation of a module hierarchy
into something very obvious.
So, the next step is kind of, you know, let's
go out of this container again, and just run
it again, and I think this is a very sorry
amount of bacon pancakes for JSConf 2014,
so let's go back and, you know, we could just
do this.
(Laughing) run it multiple times and engage,
again.
Write and run it, but it's not very exciting,
so I know a function on NPM which does this
much Bert than I could do, so, not only does
our editor know words from our own creations,
it also knows all the words which exit on
NPM so I can just reference load Ash and tell
it to run 20 times, if works as expected,
click on this, it will open loadash on NPM
that's what I was referencing, so we build
this again (Lodash) and I run it again and
it works.
(Applause) so, let's descend into the madness
of the container once more.
This time my node modules had Lodash, it does
exactly what you would do if you wanted to
install Lodash, it installs it.
(Chuckles from the audience) so ...
I would say one more thing, but it's not really
that special any way.
One more thing, we created a CLI from our
make bacon pancakes, this is saw some, let's
make them pancakes with maple syrup.
Ummmm fantastic.
Let's go back and recompile whatever our CLI.
And run it again.
Sorry.
And we have maple syrup, it's really, I want
to change something off this program, I just
do it, run it again and it works, I don't
have to bump dependencies or Synlink or whatever.
 ‑‑ Symlink ‑‑ or whatever.
We could also turn this function into an API,
right, let's say we have the breakfast server,
API, ‑‑ sorry.
Bacon pancake API, and, in here, we oar just
going to do the hello world example so we
create a server and the computer is smart
because it knows suddenly what you already
knew that HTTP is of course the built‑in
HTTP module node J S, so we're going to answer
this request with a response and of course,
we're going to make bacon pancakes.
And it works, so we call this function and
we listen to a port and for convenience reasons
we're also going to add a log line.
 ‑‑ what's the magic.P address, I don't
know, let's copy paste it.
Okay this is the IP address of the docker
Daemon.
Right, so we built this and there's some amazing
docker output.
And we run this ...
what was the name? Bacon pancake A PI, it's
great if all you have to do is remember names
of things.
Okay, and it works.
(Applause) so, such timing, very on time.
Ooops, you're not supposed to see this, this
is my reality, let's switch back to your reality.
Yes.
So ...
this is happening.
There are smart people who are already doing
stuff like this.
For example hoodies semantic release completely
automates process for publically releasing
new software bundles.
Basically all you do is the local part.
You say I want a new origin and I want it
to be a patch, and it even knows that you
can say I want a new version, it's going to
figure out your comments and figure out the
kind of release you want to do.
Have a look.
And, as anything that will ever be done in
the next fifty year in software development
most of it will already have been done by
mad scientist on this IRC channel ...
it's true.
Look into the log files.
So ...
I want to thank you and I want to thank great
friends who gave ‑‑ who give me great
ideas and people who support you.
I'm working on this stuff right now I would
like to ship it to you and I for one am looking
forward to the party now.
Thank you (Applause).</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>