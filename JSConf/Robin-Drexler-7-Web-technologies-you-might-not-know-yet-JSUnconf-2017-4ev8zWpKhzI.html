<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Robin Drexler: 7 Web technologies you might not know yet | JSUnconf 2017 | Coder Coacher - Coaching Coders</title><meta content="Robin Drexler: 7 Web technologies you might not know yet | JSUnconf 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Robin Drexler: 7 Web technologies you might not know yet | JSUnconf 2017</b></h2><h5 class="post__date">2017-06-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4ev8zWpKhzI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">provides JavaScript and the thing is I
think that asset server security is
often a little bit underestimated so as
soon as an attacker has the ability to
alter your JavaScript your JavaScript
content they can basically do anything
there for example stage login pages
under your domain and then wait for the
user to enter the password or they can
also do all the editing cuts that you
can do and then send the information to
their server or yeah stuff like that
and I really hope we'll never see the
day where somebody gets access to the
Google Analytics JavaScript servers or
the Facebook like buttons JavaScript
shows because this stuff ones basically
everywhere on the world from one hundred
and millions of websites there's also a
way to mitigate that at least for stuff
that you feel yourself or for libraries
that don't change to us this is instead
of just embedding scripts on stacks you
also add an integrity attribute which
includes a Content hash of your your
JavaScript file and this way which helps
the browser to okay download download
the JavaScript and if the the content of
the delicate doesn't match this hash or
the hashed content of the Joseph doesn't
national attention please do not execute
it and then you're safe the site will be
broken but at least nobody will get hurt
and the cool thing about this is that
it's 100% backwards compatible so for
browsers that do not support the exactly
integrity attribute they will just
download and execute JavaScript as it
used to be so now that we've made pages
a little bit more secure let's make them
a little bit faster too and this is how
to really really really really catch a
cache effort so you might think that
once you have a Mac a cache control
max-age header which is maybe for a year
that the browser will always serve that
file out of the cache until the cache
expires and I just important that this
is not true by default and what will
also show a way how to actually achieve
this and I want to do this by an example
our little web page with a bunch of the
middle let's pretend it's 40 maybe 50
and those are your measures and you are
pretty sure that they will never change
on the LEDs not in a year and if they
change you can just change ul and then
basketball castle which is more safe
anyway and I would like to to go through
what actually happens if the browser we
pressed in one of those images for the
first time and then for the second time
and then explain the problem so what
happens is the browser requests the
image and your server will basically
answer will to run it okay because the
image is found and fine
then there's the image content of course
but there are headers in between and the
for example cache control header with
the next page those this is one year and
second and an e-check which is the
content hash of the image and then the
browser will will cache this image in
the cache stored in the cache and then
whenever you navigate through the page
will will liberate from a cache but when
you do a reload which actually happens
more often than you might think
then it won't serve it directly from the
cache but will initiate a request in
your server although you specify before
that the image will be fine for you it's
a so called conditional request and the
browser will adder is non-match tag
header in this case with the with the
hash key tag you have provided before
and will basically ask your back-end
server is the image it's still still
matches this hash and this is the case
because you are sure that this will be
the case for the next year and therefore
the browser answers with a we owe for
not modified response omitting the
header omitting the body so there the
body has not to be transferred again but
you still have to make the request with
a lot of agency and if you have 40
images this is done for 40 images and if
you are talking about a scale like
Facebook then this will result into
millions and millions of unnecessary
and Mozilla pioneered something that is
going to fix this which is called
cache-control immutable and with
cache-control immutable which is a HTTP
header you can tell the browser to like
I am really really sure that this image
will not change in the year and this is
how the request then looks like for the
first request to the image again we get
requests and you will receive the image
content again but this time the cache
control in addition to the max H also
has an immutable flag and when the
browser or user refreshes the page the
next time then
the browser will simply observe it from
its cache and not ask you move ever
again at least for this year and I guess
this is pretty cool the issue is now if
you if you if you go to Chrome and want
to try this then you won't have you will
have a bad time because they were asked
to implement this as well and then they
just almost switches the entire
condition to accept and you don't need
be headed there it just works out of the
box map which is cool as well so now we
improve caching a bit but no matter how
good your caching might be there's
always the first unfished
request to be made to a website and this
is why I would like to talk about
results in and especially the preload
resources my example is a such totally
awesome website which is a blog post
about dancing pedestrians and with a
with a large viewer image which which
icons which I would consider pretty
important for this page so yeah this is
how it looks like this is maybe how we
had stuff like so there's a stylesheet
precisely this and a bunch of JavaScript
files nothing too uncommon I'd say this
is Caesar so there's only background
image for yes the dancing finish you
intimate the issue is what when the
users on a slow Network this is how it
probably will look like when they open
the page so going to wait for image it's
going to take a while until it appears
on this tax in this case because the
image is super super important
and you can also see them in this
waterfall graphic options and yes that
the image is the last item and it is
only downloaded after all these scripts
and and the see is that and this is
because in if you specify a background
image and CSS it won't be it will only
be downloaded different selector
measures and the browser can only know
if these selector matches if it has
downloaded and parsed the disease that's
entirely and also there's rip
synchronous quits let's follow it so
this is why the image download starts at
the very very end what you can do is you
can add a link tag to your have in the
state the bucket a sheet with relation
cetera preload and the atria is your
background image and this tells the
browser that you want this this asset to
be downloaded as fast as possibly as
fast as it can and so you don't need to
wait until it finds it into InDesign and
the resulting water shot what a full
chart looks like this so the background
image is now downloaded in parallel with
all the other assets and we will get
much much earlier and before and you can
use it for for other things as well for
JavaScript that you will load as
inclusive or use for I think this keys
as no name - so but if they're still
under they are not enough and you really
want those you there's actually a way to
tell the browser even earlier about
resources that you might need
enter early hint so this one is a
request for comment that isn't
implemented in any browser yet I guess
but I think it's so cool I wanted to
mention it anyway but before I will dive
into that there's one thing I'd like to
emphasize that is that an HTTP one
request doesn't necessarily result in
only one response and the spec states a
client must be Pichette prepare to
accept one or more status responses
prior to a regular response also I'd
like to give an example of something
that has been in place for years already
to give a better understanding
which is the status code 100 continue
and so imagine you you are youtuber and
you want to upload a large 8 gigabyte
video to YouTube but you're not sure if
you're allowed to so if you're still
logged in what you could do is simply
send the 8 gigabyte of video along with
your request and then get injected and
have congested the network but what you
can also do is spend your your your
cookie information and the content
length or that the video will have a but
not sent the body right away and then
also the expect 100 continue header
which basically tells the server that
you will not send the video right away
but expect its response so and if then
the solar check if you'll still log in
and allows you a video and if that's the
case will enter with 100 and only then
you will go on uploading the video which
will then result in an HTTP code of 200
or 201 depending on the implementation
or something 400 if it fails this and
this same mechanism is used in the 103
early hand
so when you make the request to the
server then the backend server can
generate your HTML by talking to API or
make it or contacting the database for
information but while the server is
added the web server can already give
you the response with the resources that
you will need once the pages done
generated a window that you will need
when the page is generated so and once
this when once this happens the image of
the image will already have started
downloading and will even will be there
even even further faster with a really
cool and we are yeah the last thing I'd
like to talk about is addeventlistener
or better yet the third parameter of
activated nerve so who of you has seen
that before
quite a few so what it basically changes
the propagation model or how the hell
did all events you know so if you set it
to false or don't set it at all then
event flow basically like this look at
my offer
we'll be gone when you click on the
target then we click target event
handlers will will be called first and
then the event will basically bubble up
or flow up all through all the interface
and the event handlers there will be
cost blended the default nowadays
then there's the it should set it to
true then it changes to to something
called capturing and this basically
reverses the way events flow so the
ancestors will get the events first and
the inner target the click target itself
will receive the event laughs so that
even allows outer containers to cancel
the event before it even arrives at the
click target and you might now ask
yourself why is why are two in place I
guess is just for circling there were
two teams that came up with different
solutions for the same problem and now
we are we have both vividly but we are
pedal for bubbling as we thought ah so
that this parameter actually has changed
in the last year say so it's not doing
it anymore it is now become an object
which allows us to configure even more
event handler option so the first one
which is still in place of course
capturing because it was most there
before you'll need to be supported but
there though there are also two new ones
which I would like to talk about briefly
the first one being one so if you set
one to two then when your event handler
is being called then it will be removed
automatically for you so it will only be
called once the parameter orbiter and
that saves us from writing a lot of
rollerplate
for all using jquery ladies for that
matter and then the another one it's a
little bit more interesting i say which
is passive and so there's one problem
with mobile phones so have you ever
tried scrolling web page this is awesome
pretty janky and this is because when
you when you scroll and use for example
then you are as a developer
able to prevent this touchmove from from
happening which is good only one time
because it allows to be to be flexible
but is also bad because browsers need to
wait until all touchmove event vendors
are done with their work before they can
actually paint a scroll because you
could cancel it and then they brother
where wouldn't be allowed to scroll and
with passive if you can cast pepper true
and you are promising the browser that
you that you will never ever call
prevent default in your codec in your
event handler and that allows the
browser to adjust painter scrolling and
you still can complement before but it
won't do anything because you promise
that you won't arm one last thing is if
you want to use the new version also the
object version instead of the full
version
now you need to feature detected first
because imagine you are using something
like this in an unsupported browser then
so you're giving the option the option
object will capture false but what
you're what you're actually getting is
kept a true because this is an object in
a JavaScript object so truthfully and
therefore if you capture is true and
then you're in for a surprise
and the the last thing I'd like to show
us how to feature the check so basically
a quick and dirty way how to do it and I
want to show it because it involves
something I've mentioned earlier which
is Gator Gator something so what you
what you can do is just add an event
listener to any event it doesn't ever
have to be called at all and then you
use capture but use the getter Center or
capture and if the browser supports the
object version it will ask you will ask
the object that captures will force you
to read it and use it and if that's the
case then you know it got caught and
know that it's supported or not I hope
that makes sense now that's basically it
already so thank you very much if you
still have some that you have questions
then don't hesitate these are still
eight minutes or so
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>