<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tim Doherty: Framework Fatigue - JSConf US | Coder Coacher - Coaching Coders</title><meta content="Tim Doherty: Framework Fatigue - JSConf US - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tim Doherty: Framework Fatigue - JSConf US</b></h2><h5 class="post__date">2015-12-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Fk_WbNrZmgA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">check one two check one two you hear me
out there yeah testing testing testing
all right everybody smile you guys all
signed the photo waiver right you get to
use your photo in perpetuity all right
so maybe m daugherty I'm an architect at
a jealous asst working on our guest
platform and product my twitter handle
find me on linkedin my very seldomly
updated blog a little bit of background
about me I've been doing software
engineering in one form another since
1996 the back my early background was in
desktop and server technologies went
through the whole classic asp asp.net
PHP server side interpolated templates
things like that I saw he started using
javascript in 1995 when it was dropped
in netscape navigator to i was a college
student at the time i used it casually
for the next 15 years like that and i
thought i knew a reasonable amount about
the language and turns out i knew very
little about it beyond Serpas syntax
around 1997 i started using libraries
like prototype script oculus jquery
things like that that kind of jquery in
particular being an abstraction on top
of the various browser inconsistencies
got me interested enough in javascript
to actually take a deeper look and then
ice moved into frameworks like backbone
knockout number things like that i'm an
organizer for my local javascript meetup
I'm based in sin Santa Barbara
California and I got promoted to
architect in january of this year which
means i do less coding then i would like
I spend probably less than fifty percent
of my time coding now and it's not all
JavaScript you know I have an emphasis
on the front end but I do lots of stuff
with docker an ansible java and mongodb
and things like that so like i said i
took a deep dive in around 2010 in the
JavaScript I found it really fun to use
and expressive and share a little bit
about framework fatigue so there's a
handful of popular frameworks if you
don't see your favorite framework
up here let me know so that I can
include it in future iterations of this
talk but it's daunting I there's a lot
of them it's hard to figure out what's
what and it seems like a new one drops
every day it seems almost like these
frameworks are going under faster than
the startups that use them so what do
you do this one looks pretty cool right
vanilla j/s everybody's using it
Microsoft Google Yahoo the sad reality
is that there's probably a lot of people
coming to this for the first time that
look at something like this and think
it's legit right and it is vanilla
JavaScript is a legit thing but it's not
a framework well you may suffer from
framework fatigue talk about some
symptoms of framework fatigue confusion
so here's a bunch of concepts that are
in popular frameworks one way reactive
data flow right this is probably the
most important contribution that react
is brought to the table everyone talks
about the virtual Dom and the speed but
the real contribution i think is
popularizing this idea to a data binding
which is popular and a lot of different
frameworks not necessarily good it's
hard to reason about when you're states
being manipulated all over an
application but it's got a great deal is
factored upfront micro frameworks
virtual Dom extensible HTML decoupled
event-driven architecture and the
various flavors of client-side NBC it
turns out these all actually mean
something these are all important
paradigms if these frameworks and Braes
but it gets confusing gets really hard
to keep up with these things and to
differentiate them and especially for
newcomers ambivalence
another framework really I mean do we
really have to go through this again but
mine's the right framework who cares
about your framework my framework does
the job well there's a bunch of
frameworks from 1990s Java that still do
the job but do we still need the people
and do I even need a framework and this
actually becomes a valid question
especially now in the context of xmas
crypt 2015 there's some language level
enhancements that start to eat into some
of the utilities and things like that
that we have historically dependent on
frameworks and libraries for skepticism
so here's some claims that I just kind
of scraped off the front page of some
popular frameworks some of which may or
may not be true but it's important to
have some healthy skepticism going into
it it's important to understand that
just because your friend is developing
with the right framework tells you that
it's super spectacular magic you know
auto magical thing doesn't mean it's the
case right and it is important to
approach these things with a healthy
degree of skepticism right let yourself
absorb some knowledge let yourself try
these things out and see if these claims
are actually true reduce capacity for
hype and marketing lingo I'm cured make
it stop so here again these are great
right off the front page of a bunch of
popular libraries and frameworks they
sound amazing you know I want to use
half of these I've used a couple of them
but are they true is any of this true we
see what the symptoms look like to talk
about treatment first treatment I have
is to go native what I mean by that is
that all things being equal all other
considerations taken into account you
should favor the built-ins the standard
library that JavaScript provides over
their equivalents and frameworks and
libraries some of these are array
methods array for each there's you know
there's a raging debate and I have it
with some of my developers on my teams
who just automatically reach for a low
dash or underscore when they want to do
revelation particularly for each and you
know the arguments are one of two
flavors usually the first flavor is well
it's faster wood ash and underscore
implementations are faster than native
array dot for each and that's true
generally the jazz performance is a
little slower but my argument is that
unless you're dealing with a really
large data set or performance is a
critical path in your application you're
prematurely optimizing if you're just
grabbing this instantly and saying it's
faster I don't think it's a valid
argument if you know ahead of time that
performance is critical then yeah you
can justify that but in my next slide
I'll talk about why that might not be
the case either and the other argument
for things like the for each method on
lodash or underscore is that it can
handle both arrays and objects it's kind
of neat you have to worry about it itals
no checking to write it'll just ignore
it if it's no but I argue that with
JavaScript being a weakly typed and
dynamically typed language there's a lot
of them certainly inherent right you can
object can be of any type that gets
passed around and if you can remove that
uncertainty and be explicit about the
intent to recode you're expecting an
array using a ray method if you're
expecting an object iterate over its
keys it makes the code easier to reason
about and understand for the developers
which i think is more important you know
a lot of times strong developers come to
the table with a golden framework hammer
or golden library hammer everything
starts looking like a nail right and
before you know what they've run rampant
and they've got code that's no longer
portable you know the cost of it the
cost of switching between frameworks
especially opinionated frameworks that
are very prescriptive becomes expensive
so there's one guy that works on my team
super strong senior developer he comes
from a background of server-side
technologies and he jumped out on the
front end a couple years ago as an
angular dev and he's a very strong
angular developer but he didn't take the
time ahead of time to sort of you know
get a solid foundation in JavaScript and
we had a really interesting you know
kind of learning experience for both of
us so one of the patterns that I use as
you can sort of emulate proxies from es6
using meth
that dropped in es5 so you write a
factory factory takes an object and some
interceptors essentially like the traps
that you get in proxies and you
basically just do an object get owned
property names iterate over them right
use an object define property and use
getters and setters and then you can
intercept those calls and do whatever
you want with him so I already had some
of this in the code base this guy came
on board I submitted a pull request and
you know we had this great learning
moment this at home moment for him I
think where he looked at that said I
didn't know you could do that JavaScript
and and it was a great it was a great
opportunity for me to teach and for him
to learn and for us to learn from one
another and you know ever since that
time I've always tried to steer him to
you know this is not a question of
should you use frameworks or not it's
not a question of you know belittling
their importance you know and that's a
raging debate some say that frameworks
are not worth the cost that they impose
I'm not sure I agree with that I think
there's it use cases but this is more
learning the fundamentals getting a
solid foundation and understanding when
is the appropriate time to use a
framework method or a framework utility
versus a native method or utility so an
object defined property has been around
since es5 there's run into a lot of
developers j/s debs that still aren't
aware of some of these features that
dropped in es5 the s5 was an incremental
update to the language I'm assuming
you're all in a JavaScript conference
everyone knows what he s 5 is right and
he will not know what he is 5 it so you
know it took a while for some of these
features to get out in the wild people
were using polyfills because the
browser's didn't support them but six
years later there's still a lot of
people that aren't aware that some of
these features exists and there's some
really good reflective meta programming
tools in there around the object you
know function bind when it dropped you
know a lot of people obviously didn't
want to use polyfills and they were
already using underscore lodash i think
at this point in time it's almost always
better to use the native function
prototype bind there's some new string
methods that dropped in es6 versus using
underscored out string for these things
you know we get starts with includes end
with and then that last one I have
asterisks tag template literals template
is sex are not enough by themselves to
create a templating engine but when you
combine them with tag functions all of a
sudden it opens up a lot of
possibilities now I think probably some
of the popular templating engines will
start using tag template literals to
implement their engines and so that
might be a moot point still worth
learning still worth using if you want
to you do like your own micro templating
framework something like that so I
mentioned performance so those are one
of the classic arguments for underscore
lodash is going to rights faster right
and my argument is that performance
really matters go native anyway this is
probably as close as you to get to the
most performant array iteration now this
assumes that order doesn't matter it's
going to go backwards through the array
but it's still ought to be about the
fastest implementation and it's just
plain JavaScript my next treatment is to
go deep a function within a function
within a function you're going to need a
powerful sedative for that so I
recommend that you learn in depth
everything that's already in es5 the s5
is all still valid JavaScript it doesn't
go away because we have a new
specification and in fact everything in
es2015 or es6 is a superset of es5 which
means all that code is still valid you
still need to understand it it won't
suffice particularly if you're new to
java script just to learn es6 you know
there's the one versioning philosophy
which means the minute you add es6 to an
es5 codebase it's all es6 so you do need
to learn es5 you know like i said es5
dropped in 2009 and still a lot of jas
devs today don't understand what's there
or don't utilize what's there and then a
lot of a new syntax that's dropped in
es6 things like the structuring and the
rest and spread operators things like
that a lot of them are actually just
terse concise syntax for things you can
already do any s5 so it really is
important to understand what it is you
can do with the language before you add
these syntax sugars on top of it other
things that are really important to
learn and the existing s5 codebase
prototypal inheritance this is the one
that trips most
people are coming into JavaScript
because it's so different from
mainstream classical object orientation
but what about classes javascript has
classes now right well your classes are
probably the most controversial drop in
es6 I'm still sort of on the fence
leaning towards negativity you know on
the positive side you have this kind of
friendly or syntax for classical Oh
depths and it makes people that
otherwise wouldn't look at the language
possibly give it a first look you know
also a lot of frameworks and libraries
have been sort of trying to glom on this
Oh classical syntax into JavaScript for
years now and if the community is doing
in any way and it's fractured
standardizing it is a win right it makes
tooling automated tooling easier on the
flip side of that the syntax the
syntactic sugar on top of prototypal
inheritance and prototype genes is so
different from the underlying semantics
that it's kind of dangerous to those
same Oh devs that come in saying this
looks like I know classes right and then
they start using it and they go this is
not classes object.create is another
feature that dropped in es5 I think most
people are familiar with it but not a
lot of people not as many people as I
would like to see actually use it I
think it's you know in many ways it's
more superior than constructor based
prototype James because you don't tie
initiation instantiation of your objects
together you can still use constructor
functions with object.create it's just a
more flexible way of doing things you
should understand the difference between
differential and concatenate of
inheritance differential being prototype
chains where an object differs from it's
the members up its prototype chain and
concatenate of inheritance which is
essentially mixing where you can have
multiple inheritance now javaScript
being a multi-paradigm language the dual
paradigm language has classical
prototype or sorry prototype 00 and
functional programming there's a lot of
tenants to functional programming that
aren't necessarily specific to
JavaScript but it supports quite a few
of them the most important is going to
be first class in higher order functions
you should certainly understand even if
you don't even if you're not aware that
it's functional programming you use
lambdas all
anyone that's use callbacks anonymous
functions uses lambdas right we connect
we have functors like mapreduce things
like that pure functions are simply
functions that have no side effects
there javascript supports this and these
two paradigms are critically important
to understanding what you can do with
the language in JavaScript you can
program entirely in a functional style
you can also program entirely in a
procedural style you can also function
entire program entirely in a prototype
below style but more than likely you're
going to be programming in a hybrid of
these you should understand closures and
variants of them like immediate
immediate Lee book function expressions
the module pattern type coercion whether
or not you leverage it Kyle Simpson has
a great a great lecture on using type
coercion to your advantage and he's a
big proponent of it most people's fear
clear of it but you should understand
how it works type conversion if you
understand it you won't get caught up in
the pitfalls she'd understand like
sickle scope and hoisting so in es6 we
get block scoping finally in javascript
but until then all we've had is global
or function level scope lexical scope
you should understand equality and
strict equality and in es6 we get super
strict equality with object that is
object that is is one of those odd
little things with base there's like two
use cases for it it's kind of weird how
it made it through this back like that
you know if you're if you're programming
in JavaScript aside from the
multi-threaded JavaScript project and
it's the name is escaping me right now
you're going to be running in a single
event lib right in a single thread so
you need to understand at the
synchronous environment and that you're
working and you should understand
callbacks promises are a nice pattern on
top of callbacks that abstract that our
way for us a little bit in es6 where
they synchronous generators you can do
even more abstraction and the seven with
the weight and async keywords we get
even one more level of abstraction that
starts to make a synchronous code look
like synchronous code makes it a lot
easier to reason about but you should
understand what's happening another hood
just like if you're using classes you
should understand that the syntax is
different from the semantics you should
understand how a sink rate
works in a basic level how the event
works how event handlers work then
you're going to learn an abstraction on
top of that that makes it easier perhaps
to reason about and read about your code
but you'll have that firm understanding
underneath of how things are working you
should absolutely understand function
call and function dot apply bind as well
call and apply are the really important
ones right because of context
idiosyncrasy we get to borrow behaviors
from other objects using called bind and
then you could understand what in the
hell this is you know I saw I saw a guy
on Twitter and I miss miss remember i'm
going to miss attribute this quote i saw
a guy saying you know every time I
program in java script i just want to
throw my hands up in the air and say
what the is this but i can
never remember what this is so once
you've got a good basis in es5 you
should learn ESX and beyond yeah six is
now the specification so it should be
safe to go ahead and start using it
assuming that browsers will catch up you
know we we've entered a new world now
where we don't really need to wait for
browsers with these transpiler engines
we've had polyfills for a long time and
even with trans filers for some features
you need to use polyfills but you should
get a good grasp of es6 now yes 2016 has
some great stuff coming as well and they
kind of falls into three major
categories we get new syntax introduced
into the language things like let const
the rest and spread operators d
structuring and arrow functions and
pretty much without exception these new
syntax are as i mentioned earlier just
new ways of expressing existing
functionality they don't really add
anything functionally to the language
they just give you the ability to write
less boilerplate to achieve the same
ends we get an enhanced standard library
we get some really important
enhancements to object and especially
array string and reg ex are also useful
most of the additions to math and number
are aimed at transpile de jan systems
like ants Krypton there's a lot of stuff
that's kind of geared specifically for C
C++ type development and then we get
some entirely new features in es6 and
this is where it gets interesting right
i mean i think that generators are
probably one of the most important
additions to the language that the
possibilities with generators real
kind of open up some pretty amazing
things they start to bring the language
on par with some of the other serious
languages out there your JavaScript gets
a bad rap some of it is justified some
of it comes from the rapid nature in
which it was developed some of it is odd
design choices but it's also been
incredibly anemic in terms of its
standard library in the feature set that
it provides now that's both a blessing
and a curse on the one hand it's super
lightweight right in some ways
JavaScript has fulfilled that promise of
write once run anywhere that Java failed
to deliver on but at the same time we've
had to rely on this ecosystem of
libraries frameworks and things like
that to provide us with some of the
basic functionality that we would get
out of the box other languages and so
these things that are being dropped in
ESX it's the first really major overhaul
of the language since 1999 we got es5 in
2009 that it was a compromise over a
failed es for maybe it was originally
codenamed es harmony was es6 right
enemies because these factions that
split over what es for should be you
know they finally came to the table and
said ok we'll compromise will do a
utility release and that was es5 that it
wasn't really a major update the last
major drop was es 3 and so es6 is a
major leap forward for the language and
it represents kind of a sea change I
think and what we can do with it there's
my shameless plug it's a three-part
series i did for the santa barbara
javascript meetup please go check them
out there github reveal jas
presentations my last treatment here
second last treatment is to use the
source surprisingly a lot of popular
JavaScript frameworks are written in
JavaScript right there there are
increasingly those that aren't right
elements the popular new language out
there I haven't had a chance to play
with it myself but one of the guys at
the meetup did a presentation on it I
planted digging deep into it there's
various other trans Paula J as languages
but a lot of it most of the popular ones
are actually written in jas so you know
if you're struggling to understand how
these things are implemented or
particularly if you're new to something
read the source right because you're
going to see exactly especially and
start with the things that you're
actually using right don't just try and
read the source from top to bottom
that's like going to the spec for xmas
crypt and reading it
to bottom it doesn't make a very good
novel to go to bed by right but there's
useful information in there and if you
going you look for the things that
you're trying to find it's spelled out
black and white and the same thing is
true for the source code and a lot of
these frameworks and libraries that you
use start with methods that you use on a
regular basis like for each right and
see how they've implemented it and it
turns out that it's usually not that
hard to understand zoom very well this
is from Ember this is there for each and
basically what you can see about
two-thirds of the way down it's just a
for loop right it's it's pretty simple
procedural easy to understand stuff
there's some angular same thing they do
some checking to see what it is that
again this is one of the arguments for
using a framework or library method is
that you can pass it an object or an
array and it will iterate through either
you know ordinals in the array or
properties on the object but when it
comes down to it once it's done with the
checking it's just a simple for loop
right it's basic JavaScript and then
here's low down here's load ashes
implementation of a rage well that's
just splits it into two separate
functions it checks if it's an array and
it's an array does a rage it's an object
it does object each but this looks kind
of similar to my little native wilder
than I add earlier right so it can be
extremely valuable as you're learning
these things to look at the silica what
other people have done and see how it's
implemented some good resources there
these are a little older but I still
think they're really valuable John Resig
recently just published the original
jquery source annotated Jeremy ashkenaz
posted underscore and backbone they're
among the few developers that have taken
the time to go out there and walk you
through in a narrative style how the
code was written so nothing can you see
the actual source code you can see the
developers thought process you can get
an idea why they did things the way they
did that can help inform your
understanding of it and then that last
one is a video by Paul Irish from 2010
where he talks about it from our side as
a dev going through and reading to the
source code and the important lessons
that you learned from it the last
treatment i have is to learn what is and
what isn't javascript this picture is
often used to belittle javascript mean
the good parts versus the definitive
guide
but what this picture doesn't tell you
is that the definitive guide includes a
whole bunch of stuff that isn't
JavaScript right it's written for mostly
from the perspective though it's been
updated recently mostly from the
perspective of a browser JavaScript
developer and so it includes all the
tools that you need to get up to speed
writing javascript in the browser it
covers the Dom it covers cascading style
sheets covers the xmlhttprequest object
and a variety of other in ciliary
technologies that are provided by the
host environment they're not JavaScript
right so even though Doug Brock Berg's
book might be even more narrowly focused
it's still you know you could cut out at
least two-thirds of that other book to
cover just JavaScript so it's important
to understand the difference between the
language and the environment that it's
running it right and that environment
now isn't just browsers it's on the
server it's in a variety of popular
database engines it's now a first class
citizen for operating system automation
it was the first language to be allowed
for iOS development after objective-c
and so each of those environments
provides some host-specific api's right
some of those api's are not necessarily
host-specific like in the browser you
have the xml httprequest object it's not
browser specific it's a specification
but nevertheless that's an API that's
provided to you in a JavaScript
consumable format but it is not
JavaScript there's also complementary
technologies like cascading style sheets
and my recommendation is get a solid
foundation go deep into the language
first understand what javascript is what
it can do what its limitations are and
then do the same with the supporting
technologies go look at Dom take a deep
dive into the Dom API see how the
different browser is implemented what
its shortcomings are and there are
plenty limitations etc get familiar with
all of that and then start to coalesce
that knowledge into a hole right and
lastly this is not JavaScript specific
but this is kind of more an approach to
how not to get swamped by this constant
barrage of frameworks out there and
that's to learn how to learn change is
the only constant you know even the
right framework the days are numbered
and that means react to react is amazing
but even its days are numbered right
these frameworks will continue to drop
and evolve end or you know one of the
emerging trends is micro frameworks
right and micro libraries are putting
together your own framework which comes
with its own advantages and
disadvantages on the one hand you can
curate your own set of a specific
functionality that each of these micro
frameworks or libraries provide on the
flip side you're then in the wilds
wondering how do you orchestrate all
these things together right kind of
framework depending on how prescriptive
it is will opinion eight that for you
you cannot know everything about
everything no matter how smart you think
you are I also argue you cannot know
everything about anything right if you
try to be an expert these days and one
particular technology unless you are
unless it's your own open source project
or your employer's funding it you will
not be able to be an expert before it
changes things just change too quickly
write my recommendation is to learn
enough to be productive learn enough to
get by and then improve by immersion if
you end up using it you will absorb more
knowledge right work with other users or
the developers on your team and you will
gain the knowledge and need to improve
your understanding of that particular
domain and then this is 1 i'm struggling
would which is developing a strategy for
focused knowledge gathering i tend to be
a hoarder i save links i say podcasts i
save videos and they all just go into
this bin and i never actually get around
to watching them or reading them or
listening to them and and then I go back
to try and find them a year later or six
months later and I wade through all
these bookmarks in my browser or this
huge file folder full of videos and I'm
trying to develop strategies for being
smarter about it being more selective
about what I save and using tools i
started using pocket recently which
helps me to search for things that i've
saved and things like that but it's
important that you don't a hoard
knowledge and be that you actually use
things right you see something great on
a topic you're working on it's important
to get that information in a way that's
digestible so some side effects once
you've gotten the treatments out of the
way you may acquire language level
skills you may have increased confidence
about your ability to use javascript and
better problem-solving ability in your
next javascript project and most
importantly you may end up knowing what
this is now lastly occasionally
javascript users have reported a desire
to write their own frameworks or
abandoned frameworks all together
although this is rare and that's all I
got thanks guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>