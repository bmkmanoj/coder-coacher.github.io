<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Forrest L Norvell: Learning ES6 as a Community [JSConf2014] | Coder Coacher - Coaching Coders</title><meta content="Forrest L Norvell: Learning ES6 as a Community [JSConf2014] - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Forrest L Norvell: Learning ES6 as a Community [JSConf2014]</b></h2><h5 class="post__date">2014-07-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MjrP-P6Pv4I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Forrest Norville and I'm a
developer at MPM incorporated and I'm
here to talk to you about the next
version or two of JavaScript I'm truly
sorry that I'm what stands between you
and lunch but this is a talk I've wanted
to give for a long time and I hope you
find it valuable
I also compared you all the cows at
least once in here so that's a thing so
equi script the standard that defines
the next version of the JavaScript
language is probably going to be
ratified towards the end of this year it
describes the most sweeping set of
changes to the language and at least a
decade and it's the endpoint of a lot of
work and at least one giant fiasco as a
node developer who's been writing fairly
involved javascript full-time for the
last three years and been using
javascript is a full-stack developer for
at least a decade before that I have a
lot of friends who are also node
developers as es6 gets closer to
standardization a lot of friends are
skeptical or concerned about what they
see is needless complication and
wrongheaded design decisions I can see
why you might feel that wave there's a
lot that's going to change as the new
features roll out and it's not clear how
all this new stuff is going to combine
but every risk can also be viewed as an
opportunity I feel comfortable saying
that everything that's in es6 as of now
has a good reason to be there in this
talk I'm going to spend a little time
talking about the trauma which shaped
the development process of es6 and then
talk about what we can do as a community
to figure out how to use es6 effectively
ultimately the point of this talk is
this it's up to us as developers to make
es6 is a success and we can do that if
we work together and spread what we
learn as widely and quickly as we can
so es6 wasn't developed in a vacuum
there are a lot of parties involved and
I think it's helpful to map out who
everybody is and how they relate or
don't to each other I grouped the
contributors into three categories
standards committees stakeholders or
implementers and the developer community
first the committee's in particular and
in particular tc39 it's impossible to
discuss the development of JavaScript
without mentioning tc39 or to give it
its full name ACMA International
Technical Committee 39 tc39 is the
steward responsible for es 262 the Ekman
scripts standard the two most important
figures on tc39 are its chairman brendan
eich who really doesn't need any further
description and the editor of es 262
alan wharfs brock without them and the
other members of tc39 the web platform
as we know it would not exist the
membership of tc39 is largely self
selecting a point as Rick Waldron
forcefully reminded me the other night
worth keeping in mind when you look at
its makeup the various member companies
of acumen nominate delegates to join
tc39 and subsets of the delegates attend
the individual face-to-face meetings
where the bulk of the standardization
work gets done trying to stakeholders a
language specification on its own isn't
very interesting unless you're some kind
of programming language nerd you need
implementations to actually do anything
and that's where stakeholders into the
picture you can also think of these
teams as implementers but I call them
stakeholders because I want to be clear
that the owners of the specs and the
owners of the implementations are
interdependent
neither can get a new version of the
language standardized without buy-in
from the others the important
stakeholders have names that should be
familiar to you
Mozilla Google Microsoft Apple Adobe but
there's an interesting trend which is
the increasing importance of library
developers in the standardization
process jQuery ember angular and the AMD
in required GS communities have all
contributed substantially to es6 and
several of the most active members of
tc39 come from that world this is a new
and very important development because
it brings the standard closer to us as
developers I think I forgot something
oh yeah you'll note that I didn't
mention node and that's because with
certain significant exceptions node just
uses an implementation of JavaScript it
doesn't implement JavaScript itself
despite what a lot of node users think
it has very little control over its own
language runtime this is something that
only seems weirder the longer you use
node but strictly restricting itself to
being a consumer of v8 has been key to
its rapid development all of us work and
wrangling is pointless without us the
JavaScript community all tc39 online can
do is let us loose with the standard and
see what we do with it you can think of
us as a herd of cows let loose and high
pasture over time we'll figure out the
best ways to get around and the easiest
way to do things and end up laying down
trails
if tc39 is doing its job it will be
watching what paths we've made and come
in behind us and tend and pave them for
our convenience and safety this paints a
picture of a tiny little ecosystem with
its own feedback loops and checks and
balances and with some allowances made
for the inescapable politics and
wrangling that comes from any activity
involving a lot of people with
conflicting goals that's pretty much
what's actually happening with that out
of the way let's talk about what
happened six years ago the last time a
lot of JavaScript was going through a
lot of changes what was the es for
fiasco put another way what made some of
you out there a little skeptical about
JavaScript odds of successfully being
updated
well standards bodies are strange beasts
with minds of their own but they do have
principles and goals stated or unstated
and sometimes those goals fall into
conflict
Edwyn script for was a very ambitious
stakeholder led project spread out over
many years the stakeholders had many
goals among them being to add proper
classes to Java scripts prototype object
system to unify JavaScript with Flash's
action strip and to generally take what
had more or less accidentally turned out
to be a cornerstone of the web and put
it on a more solid footing at the same
time tc39 was working on Ekman script
3.1 an incremental refinement of ekam
script 3 the problem that most of you
have probably encountered with branchy
development is that multiple groups
working on multiple versions of a single
thing at the same time end up generating
a lot of overhead and Comm
when it comes time to figure out how to
reconcile everything into a final end
product
ultimately what sunk es for along with
the extremely ambitious nature of the
changes was the fact that the team
working on es 4 had essentially created
an entirely new thing and called the
JavaScript they completely lost the plot
and the blame storming was fast and
furious for a very long time
it's hard to overstate how traumatic
this was years of spec work stakeholder
discussions and implementation effort
had gone into es 4 and what was probably
a relief to not have to argue about it
anymore the literal cost of all that
wasted effort was staggering so the
stakeholders sat down and hammered out a
set of principles to keep this from
happening again
which resulted in what's been called
Xmas script harmony originally harmony
was more or less a version code name for
es6
but over time it's come to refer to the
version of Ekman script under
development regardless of the version
number and ultimately the set of
principles governing the development of
the standard so broadly put harmony
takes this as its goals
don't break the web new features can't
come at the cost of breaking existing
code hole search engines exist just to
support this goal and even a very small
number of breaking sites is considered
enough to sink new features I would
actually prefer that the second thing
with new language features for acquiring
concrete implementations I would
actually prefer the JavaScript follow
the IETF lead here and require to
complete implementations of a feature
before calling it a standard but that's
really hard to do with a language spec
because it's really hard to synchronize
people working on strawman
implementations with the effort needed
to get the language into the spec itself
I talked about ways to do that a little
bit later on and that's also something
that james long's talked yesterday about
sweet J's for address really well I
thought so if you didn't see that talk
you should go back and watch it when it
hits online so keeping the language
Pleasant for casual developers if you
look at all the things we've done
together over the past few days it
should be clear why keeping the language
simple and easy enough for newcomers to
get up and running quickly is so
valuable this may make working with the
language tedious for power users but
whatever you can write Haskell on your
own time improving interoperation
observing the
existing standards explicit in the fact
that whenever possible is another thing
that is a really good common sense
software engineering principle this is
just another way of saying pave the cow
paths which is I believe trademark rich
what Rick Walter finally and this is in
many ways the most important principle
on this slide preserve harmony if no
consensus can be found around a feature
among the implementers on tc39
and to an extent the broader stakeholder
community it doesn't go in it's
important to note that while all this
sounds pretty common sensical it's not
something that is universal or even
typical for language standards anyone
who's watched the evolution of c++ or
java knows what i mean it's easy to get
wrapped up in the needs of implementers
in standards committee juan curi and to
lose sight of any languages primary
constituency which is the people who
need to use it to get things done that's
all of us so part of the motivation for
es force development was the hard-won
emergence of the web platform a lot of
you probably remember the bad old days
of the browser Wars when the majority of
our time as web developers was spent
trying to coax our code to do the same
thing in multiple browsers without
crashing one of the ways we got past
this was by collectively deciding what
sane conventional JavaScript should look
like two things really helped firm up
JavaScript as a language for serious
software development on the one hand
jQuery is important because it took the
pretty much ridiculous world of Dom
programming and turn it into something
that was actually accessible as well as
pretty much defining its own abstracted
web club platform just that they just
sat above the Dom and job browser
JavaScript on the other hand Douglas
Crockford wrote javascript the good
parts which is in a lot of ways some of
them kind of uncomfortable the ten
commandments of javascript programming
why were they important because they
signaled the arrival of a widely shared
consensus about what was good and bad in
JavaScript and indirectly defined a set
of conventions that experts could point
to and call good javascript it's worth
pointing out that this isn't to say that
either of these was the absolute
objective best at what they did mootools
continues to have its partisans and I
personally find Dave Herman's effective
JavaScript to be a less idiosyncratic
and more Dogma free presentation of what
makes for high-quality JavaScript it's
just to say that again we see the
language community blazing trails for
their own use conventions are basically
de facto standards so it shouldn't be
too surprising that it's several points
developers have just gone ahead and made
their own standards these standards have
helped and in some cases hindered the
work of tc39 so it's worth taking a look
at a few of them
first off browserify es6 introduces a
module system which is interesting
mostly because it highlights that
javascript didn't have a module system
before then a package system and
namespaces were proposed for ES 4 and
we're in fact one of the most
contentious parts of the language that
doesn't mean that people didn't want one
though common jeaious was a community
effort that is one of the first tangible
contributions of the server-side
JavaScript community and came out of the
Rhino community anybody remember right
now few hands
if the floorings not just a module
system but a set of common modules node
pretty much throughout the standard
library part but it grabbed the idea of
the module system and this has been key
to node success it has even come back to
the browser in a twisted way through sub
stacks browserify which allows you to
write your browser code out of the same
kind of small single purpose modules
that are practically the node paradigm
and then bundle them for use in the
browser this end-to-end integration is a
powerful signal the common jeaious
modules are an important tool for the
community but browserify isn't the only
attempt by developers to bring modular
code to JavaScript and he started in the
browser and grappled with the problem of
asynchronous module resolution head-on
it's also become a full-stack tool
although I think it hasn't caught on the
node as much because node modules
already existed and because it's much
more finicky to work with in practice
AMD and common j/s are very different
well there are frameworks like UMD that
bridge the gap they're not precise
mappings and so they're not very widely
used this highlights an important point
any standard module system is going to
have to make choices and any attempts to
offer everything implemented by these
competing standards will either have to
drop features or introduce complexity
this is something that you see over and
over again in standardization efforts
and helps explain why standards turned
out to be super sets of what language
communities are using standards end up
being bloated for
reason the last best example of
community standards I want to discuss is
promises a plus you thought you were
going to skate this conference without a
big talk about promises didn't you no
such luck for a language that is
predominantly used asynchronously
even before no JavaScript doesn't have a
hell of a lot of support for asynchrony
this is a pain point for everybody
pretty much regardless of how long
they've been writing JavaScript and an
industry has grown up the proposed
debate and vilify the competing styles
of asynchronous control flow promises
love them or hate them are widely
popular and as a result promises a plus
is probably the most significant
standard to be defined purely by the
community
it's simple clear and narrowly scoped
and it's done a great job of driving
adoption to the point where in the
JavaScript speaking world promises
nearly synonymous of promises a-plus
this is probably the only reason
promises successfully made it into es6
given how late they were introduced to
the standardization process this
movement from browser Wars through
conventions into community standards
pretty much as is the visible aspect of
the maturation of javascript is a
language and it seems like a pretty
important reason why Java scripts
popularity has continued to grow for so
long all right I want to drop a little
aside here I have it always been the
JavaScript developer in fact I spent
about 15 years writing Java for a living
and I studied computer science in school
I was and remain a big fan of
programming language theory but probably
my favorite class in school was actually
my software engineering class that's
mostly because I loved watching train
racks which is largely what studying the
history of software engineering turns
out to be anyway a few of you may
remember that Java was the first
programming language that was going to
revolutionize the browser
remember applets only to find its real
success on the server side and as soon
as I started writing server-side Java it
was a nearly perfect tool for software
engineering why because it was just dumb
enough Java 1.0 and 1.1 were about as
straightforward an imperative
object-oriented get through clever with
their code and write the kind of write
only gibberish the perl developers were
so fond of golfing out in the nine
however this changed over time
developers demanded and then got stacks
and stacks of new features in the
language each of those features
introduce complexity and in some cases
compounded existing technical debt in
the languages design and around the time
that generics annotations got added to
the language I decided that the
complexity had gotten burdensome enough
that I was no longer really interested
in dealing with it
this is a way of saying that the most
important piece of tooling in your
language of choice is the language
itself its syntax and features are its
user experience and like all user
experiences you want to make sure you
don't clutter that user experience with
unnecessary contradictory or confusing
features however as far as I can tell
the primary purpose of language
standardization is to include everything
all the time forever each of these
columns is a single thread I may of
cherry-picked a little for effect but
these are all discussions about es6
features that went on for days people
were arguing about promises for months
this is one of the chief reasons harmony
is so important doing this stuff out in
the open and discussing things fully and
bought beyond there's a pretty good job
of getting all the issues out where
everyone can see them discussion gets
kind of aggro at times but the spirit of
harmony is mostly held true and acts
again acts as a guard against the most
pathological forms of standards
committee necrosis so let's talk about
the public mechanics of Ekman scripts
development the most important piece is
the draft itself which is most easily
consumed via JSON or endorsed HTML
conversion Allen is cranking out new
drafts as quickly as he can as finishing
the language is the language of the
specification is the most substantial
obstacle to finishing the standard and
Jason is pretty much completely
automated the process of producing the
HTML draft standards language is not
always super user friendly and Alan's
style takes a little getting used to but
this is the ground truth of es6 so it's
worth your time if you're interested
Rick's notes on the face to face
meetings are at least as important as
his work on johnny-five in my opinion it
takes me more or less an entire day to
go through each set
notes so I can only imagine how grueling
it is taking them and they're published
shortly after each face-to-face meeting
but aside from the spec itself this is
the most valuable resource for
understanding what's happening to
JavaScript I think you either need to be
working on ACMA script standardization
for your day job or be sort of a glutton
for punishment to actually subscribe the
es discuss there is an incredible amount
of detail sometimes but also endless and
sometimes tedious bike shedding and a
lot of discussions that don't go
anywhere interesting fortunately you
don't need to subscribe to the list
because forbes lindsay has put a
fabulous and simple UI around the list
on es disgust org so you can dip in and
dip out when you need to and actually
this time right now most of the time
search results will actually take you to
es discuss organ stead of the mailing
list archives which is a big plus if you
find issues in the specs or when reading
the meeting notes you can't or you find
issues while you're reading them in
enemy notes you can and should file them
on the Ekman script bug tracker this is
basically your API and to the specs
editorial process you should use it and
finally and most interestingly I got to
talk about tests 262 tests are no
substitute for a formal language
standard but test 262 is a great
resource for people who want to get
involved in validating the spec and
contributing to the evolution of the
language without actual code exercising
these features it's really hard to say
whether a given chunk of the design is
any good or not it's also critical to
have some way of evaluating how much of
the spec a given runtime is implemented
test 262 is only recently put up on
github and just this week completely
open source so it's ready to take your
poll requests many put many people put a
lot of work into convincing ACMA to do
something that's never done before by
opening this process up to the public so
please do take advantage of it so
believe it or not yes six is basically
done the work that remains is mostly on
the specification itself and refining
the standard his feedback comes back
from stakeholders about how easy or hard
it is to implement all the new features
in the language the draft is slated to
be read it ratified and promoted to
version 6.0 of ACMA script by the end of
this year tc39 itself has
largely moved on es7 with some features
being pushed from 6:00 to 7:00 and the
other standards bodies are rapidly
incorporating es6 features into their
own specs the big open question is when
will the first complete standards
compliant implementation of es6 be
available I'm hopeful it will take less
than a year especially because the due
date for es 7 is sometime in 2016 but if
any of you want to place bets on how
long it will actually take I'll be happy
to lay you odds so looking beyond es6
one of the great products of harmony is
increased attention to improving the
specification process itself going
forward new features will be developed
the strom and proposals with a champion
responsible for gathering consensus on
how features should work and with an
example implementation and maybe even
tests before the feature even gets
brought back to TC 39 this is an
excellent place for developers who are
passionate about features to get
involved and contribute directly to the
development of JavaScript so how's it
going as far as implementing es6 wow
these are ureas odd sets compatibility
charts for es6 don't try to read them
this is just to give you a feel of how
much work remains before es6 is done in
various browsers the picture is actually
slightly worse than it appears here
because these just say that the features
are there not that they actually work
it's probably not visible but
SpiderMonkey is doing the best of any of
the browser runtimes
this is scrolled further down on that
chart and to continue even in cases
where features are available today there
are cases where the standard is still in
flux as is the case with some edge cases
around generators or the implementation
is just straight-up buggy as is the case
and promises in Chrome Canary and
development versions of nodejs given an
implementation is spotty how do you get
a feel for how this works today as I
mentioned Firefox is in the best shape
of any of the major browsers when it
comes to es6 readiness although it does
still have a way to go and when I say
Firefox I mean the dev channel not not
the release channel if you want to try
polyfills and shims you can lash
together a more-or-less working
environment with es6 shim for built-in
constructors and objects tracer for
syntax and es6 module
spyler or es6 module loader four modules
and module odors but even all about us
incomplete and lags behind the standards
so there really isn't an out-of-the-box
playground for es6 right now one really
interesting strategy which James long
talked about on Wednesday is to use a
tool like sweet jazz to test individual
new features and to see how well they
work and what backwards compatibility
risks they have Macker can't do
everything anything that depends on
runtime functionality that isn't exposed
by the language like weak maps and their
special garbage collection semantics is
going to be difficult or impossible to
do if macros but they can do a lot less
invasively than a complete transpiler
would so they're a really good way to
pilot these things out so I'm going to
choose an example of a feature at es6
that's gone through a lot of the
different processes that I've seen
affecting the standard so let's talk a
little bit more in detail about how this
works I'm going to use promises as an
example because they clearly illustrate
a lot of factors at work and also
because maybe we'll all finally be able
to stop talking about them all the time
when he s6 is done then we can move on
arguing about private symbols and
object.observe instead that'll be fun so
tc39 isn't the only player and web
platform standards the w3c and what WG
play with substantial roles as well and
as there is still only one standard
language in the web platform sometimes
though these other committees end up
creating their own standards that
require support from JavaScript
historically this has led to some
weirdness like oh the Dom with basic
bits of platform functionality just
dropped into the runtime as Global's now
at least stakeholders try to get their
features integrated into the language
here's a pretty straightforward example
for a bunch of new API is the what WG
team needed a standard way to do
asynchronous computations so they came
up with something called Dom futures
that were pretty much an extraction of a
pre-existing pattern as I've already
discussed the JavaScript community had
pretty much solved this problem with
promises a-plus and so the discussion
eventually turned to how to reconcile
what what WG wanted with the existing
spec a clear-cut example of looking at
the existing cow path and figuring out
how to pay fit pretty hot on the heels a
promise is making it into es6
too hot in fact the chrome team
announced their intent to ship promises
in v8 I think it's interesting that one
of the biggest implementation drivers is
actually other standards chrome needed
promises and week maps for new Dom API
so they move promises from blink to v8
and move them both from behind a feature
flag so that they are actually in the
browser there are risks to the strategy
in this case the promises implementation
that v8 is using has several bugs which
are clearly called out documented in
promises a-plus for what it's worth and
for unrelated reason this version of v8
got dropped into a development build of
nodejs in such a way that it's entirely
possible that the next major version of
nodes
0:12 will include these buggy promises
if people start building significant
code bases on top of buggy promises
it could cause real pain later when note
includes a build of v8 that fixes them
it's not a good idea to put draft
language features into runtimes that are
intended to be used in production but
that's web development for you so of all
the arguments around promises on es
discussed the longest and arguably most
tedious debate was over whether es6
should support flattening promises
monadic promises or both in addition the
w3c had built the standard for Dom
futures and promises A+ have pretty much
taken over within the JavaScript
developer community promises are really
a pretty simple construct and they
threaten to turn to something really
cumbersome in es6 all the parties in
these debates have at least a little
history and computer science on their
sides and none of them had a complete
understanding of the entire argument
another example of this has generated a
lot of heat is the new module system
people have very strong opinions about
AMD and nodes module system I work up
one of the places where there are a lot
of those opinions they're very deeply
ingrained patterns around both and in
the case of node and ecosystem of nearly
unprecedented scale this is led to
skepticism a lot of very blunt talk
about the new module system which will
have to tread carefully if anyone wants
to see it widely used and one or both of
the browser of node the module system
was one of the last pieces to be
finished and work on model loader still
isn't entirely done in large part
because Dave Herman has had Tobin hast
at had to work so hard to accommodate
all these competing constituencies that
can really own be only one of these
kinds of features in the standard
if it's going to deserve the name node
deserve the name no it isn't Scala for
which I'm very thankful and a lot of
what fueled the arguments was the desire
of all the people in the debate to see
their preferred strategy win beyond a
certain point it became pure politics
who cares whether or not this is a good
thing this is how the process works and
having an understanding of that makes
you better equipped to participate in
the process and to figure out how to
effectively champion the pieces that you
care about at various points in the
development of es6 I got concerned about
how much of the discussion of new
features was framed in terms of how
those features worked in other languages
yes six is a mag past net Magpies nest
of a language with shiny bits and pieces
picked from many languages and not as
much consideration as I'd like as to how
these pieces will fit we're all going to
have to figure that out together and we
need to be careful or we're going to end
up being stuck with some really gross
stuff for a while we need to be free to
look at these features in terms of how
they relate to JavaScript and cleaning
some other languages model really isn't
helpful part of the reason I'm here in
front of you today is that I spent much
of the last two years banging my head
against Java scripts limitations in
order to help node users figure out how
to make their applications faster I had
to learn pretty much all of the
JavaScript just to do my job
server-side javascript is just different
from browser code there's more code it's
running for much longer and whatsup PDX
node it runs closer to the metal there
are a lot of features in es5 that don't
run in that fast and v8 node in fact you
can recognize people who've spent a lot
of time analyzing performance of no
doubts because their JavaScript looks
more or less like C some of this is
because v8 is still optimized for chrome
some of this as a result of a carefully
collected body of lore about how v8 JIT
will optimize things but some of it is
because features like function dot bind
are just doing way too much stuff they
were designed by people who wave the way
concerns about whether all of this could
be optimized filing spec bugs and adding
useful performance tests that aren't
part of meaningless benchmarking games
is our best hope for trying to get these
performance issues addressed that's
right I added this slide just for Trevor
if he's around to pull this together
there are a lot of basic powerful
abstractions at es6 some of which can be
taken further instead
the conversions of the language we need
to put them all together and see how it
feels to compose and combine them it's
time to find the new cow paths we need
to think really hard about what's good
and to separate it from what's cool
being clever is gratifying in the short
term but building an ecosystem with
solid foundations will be much more
rewarding later on we don't need to use
with all the new features at once and if
we do we run the risk of creating
conventions we're going to find
incredibly toxic to work with some of us
love shiny things and gadgets and
hopping from crevice to grab crevice
like mountain goats the rest of us look
at that mountainside and see not only no
trail but certain and terrible death as
trailblazers it's our responsibility to
remember the needs of the people who
will come after us remember keep the
language pleasant for casual developers
something you learn when you study a
foreign language is that when you are
fluent in a language you think in that
language instead of mentally translating
as you go along you stop noticing which
words are loanwords and which words
sound funny and struggling to juggle
conjugations and genders in your head
and think instead of getting across
concepts and feelings I want us to get
to a point where it is possible to be
fluent in idiomatic JavaScript and that
we as a community spanning the browser
and the backend can all code in a way
that is intelligible and consistent to
each other javascript is a very
expressive language and es6 adds a lot
more expressiveness into the mix all
know that es6 is a success when people
talk about JavaScript primarily in terms
of JavaScript and not in terms of how it
compares to other languages even with
the new features that originally came
from somewhere else to get there is
going to require critical thinking and
judicious editing if some of the feed
new features turn out to be obviously
bad deprecated them quickly and loudly
and move on with is still in JavaScript
but nobody's forcing you to use it it
took over 10 years between the
introduction of JavaScript and the
publishing of the good parts it doesn't
have to take that long again work with
the goal in mind of converging on a new
style of effective JavaScript using a
new set of good parts but treat it all
as a process rather than a product
good parts the book is best when it
talks concretely about what has and
hasn't worked and less effective when it
tries to establish a new dogma we should
strive to be descriptive as much as we
can and to save the opinion based
flaming for Twitter and you know
wherever IRC ultimately we're all on
this together
some of us may sound a little surprising
to those of you who know me I'm an
opinionated smartass and fond of saying
things like your favorite programming
language sucks at the end of the day
javascript is just another imperfect
tool made by imperfect beings this is a
polite way of saying that javascript is
kind of terrible but it gets things done
as this conference shows I think my
message to you is hopeful es6 is almost
done and that means that it is now our
responsibility as a community to figure
out how to use it most effectively and
to make it a success there is a lot of
stuff in there and I have strong
opinions about which bits of it are
absolutely terrible but I and more
importantly all of you have the power to
sort through everything and figure out
which bits are useful in which bits are
nasty
together we are JavaScript and its
future is under our control I urge you
to take advantage of that control and to
help each other out along the way thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>