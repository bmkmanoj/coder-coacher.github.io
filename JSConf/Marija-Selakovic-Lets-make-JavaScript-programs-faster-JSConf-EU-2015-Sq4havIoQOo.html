<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Marija Selakovic: Let’s make JavaScript programs faster | JSConf EU 2015 | Coder Coacher - Coaching Coders</title><meta content="Marija Selakovic: Let’s make JavaScript programs faster | JSConf EU 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Marija Selakovic: Let’s make JavaScript programs faster | JSConf EU 2015</b></h2><h5 class="post__date">2015-10-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Sq4havIoQOo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Hello everybody.
Thank you for
introduction.
This will be very interesting talk
because I'm going to show you how to make
your
JavaScript programmes faster.
But let me first
introduce myself.
I am coming from academia, I'm
a student at a university in Germany, and
they work in
research group which main goal is to build
techniques to
make it more secure, reliable and efficient,
and we're
now focusing on JavaScript, but if you ask
me where do
you use JavaScript, and why do you use JavaScript,
I will tell you we build JavaScript tools,
and we found
JavaScript really interesting language, challenging,
but
also very unusual.
So don't take this literally, but
there are still many things in JavaScript
coded, you
have to be improved.
This is my first time at the JSconf and I'm
happy to
be here because I personally believe that
whatever we do
on the research side should be also very beneficial
for
the community.
And now let's start.
Who have
a experienced JavaScripts programmes that
are like this?
Can you raise your hand?
In this talk I'm going to tell
you how to make JavaScript programmes like
this, and
believe me, it is not very difficult.
But let's first
agree on importance of JavaScript performance.
And
I would remind you that 90 per cent of almost
all
websites nowadays are powered with some amount
of
JavaScript, and having efficient and highly
optimised
JavaScript is very important to keep your
web
applications responsive.
But when we talk about mobile
world, we also can see that many mobile applications
nowadays are written partially or entirely
in
JavaScript, and we don't want mobile applications
that
drain our battery.
So highly performing JavaScript is
also crucial for energy efficiency.
I hope that I convince you why JavaScript
performance is important.
But probably some of you
would ask me why would we care about optimisation
of
JavaScript, especially in the presence of
highly
optimised JIT compilers and almost every browser
or
platform that has JavaScript nowadays has
some sort of
JIT compiler -- even Internet Explorer, yes.
For
example, Chrome, Opera, now Js, they employ
V8, Firefox
has SpiderMonkey, Internet Explorer has chakra
and JIT
compilers are known to be very powerful.
And that's
true.
But I would remind you that optimisations
are
limited.
When I say limited, I don't mean number of
optimisations are limited, but I mean the
situations in
which certain compiler optimisation can take
place
because compilers, JIT compilers, optimise
JavaScript
code in runtime, and they make certain assumptions
of
JavaScript code, if they're not met in the
runtime,
simply compilers refuse to optimise JavaScript
code, or
they optimise previously optimised JavaScript
code.
So,
because JavaScript performance is obviously
very
important, and optimisations are limited,
developers
still manually optimise their code.
And to understand
what type of optimisations developers apply
and what do
they consider, as important optimisations,
we did
analysis of performance issue reports from
popular
JavaScript projects, and here I would mention
only three
of them so we started backtracking system
of angular
project, amber react to JQuery_ and many more.
Because
for those projects we understood that performance
is
significant concern.
And we analyse in total and
reproduce successfully 98 performance issues.
Now I am going to give you some examples of
the real
world JavaScript performance issues and how
developers
fix them.
So let's first start from the most prevalent
ones I don't know, would you guess this, but
please
don't be surprised if I show you that most
-- the
significant amount of performance issues we
analysed are
related to this, and this not surprising because
compilers in many cases are not successfully
optimise
this statement.
And this particular piece of code
iterates over properties of some object, and
checks
whether the properties are new numeriable,
so they
solved this problem and traditional, and to
convince the
developer to apply certain optimisations,
people -- what
they usually do, they create micro-benchmarks
and they
run that on JSperf.
I hope you're familiar with that?
Can you raise your hand?
Okay, almost all of you are
familiar, but this online benchmark to compare
performance of different code snippets written
in
JavaScript.
As you know, it represents how many
operations per second one code can execute
and the
higher value is better one.
So for some input you can save almost 60 per
cent of
the execution time by using object keys built
in Forlin.
This is another example of performance issue
in
JavaScript, and yeah, it is not really performance
wise
to create regular expression every time when
split
method is called, and for this particular
project the
split method was called many times during
the execution.
So it is much more efficient to start a computation
of
regular expression creation and to reuse this
computation later in your code.
And by running these two codes on JS Perf,
we
managed to save for some input 15 per cent
of execution
time in Firefox.
Another example shows how you can copy elements
from
binary to another, so what you can do is just
iterate
over elements, and append new array with every
original
element of the array, but it is much more
efficient and
smarter to call built-in prototype slice method.
For
this particular example, we saved almost 200
per cent
execution time in both browsers, Chrome and
Firefox.
In
the last example, it is about how JavaScript
developers
use sometimes, not always, JavaScript API
in inefficient
way.
So a couple of years ago it was really popular
to
use split and join calls for doing search
and replace in
JavaScript, and nowadays, since replace method
is very
well optimised by many browsers, it is much
more
efficient to use, the built-in method, and
please keep
in mind this example I will come to this later
on.
And
on JSperf we could save 44 per cent of execution
time in
Chrome for this particular optimisation.
So what I would like to discuss now is, well,
it's
common belief that having optimised code would
sacrifice
maintainability of your code, which is for
some
optimisations true, but if you could remind
yourself of
the previous example you could see that many
optimisations were pretty simple and they
didn't change
complexity of the source code, almost at all.
So, is
this really the case for real world optimisations
in
JavaScript?
Well, I would not say that.
And to prove
this, we measured for every optimisations
how many
statements the optimisation change in the
source code
and what is the difference between original
and
optimised version of the program?
And if you could see
most of the optimisations, almost are not
changed
complexity at all.
So, here in this, I would say that yeah,
optimisation are relatively simple, that by
relatively
simple changes you can optimise your JavaScript
codes
significantly, and we also observe that many
optimisations are instances of recurring partners
which
means that one type of optimisation we found
in multiple
projects.
Imagine the following situations you use your
split
and join pattern all over your codebase and
you use it
many places.
Optimising this particular pattern would
require a lot of manual effort and maybe some
of you
would give up of this optimisation.
But we wanted to
answer, is it possible to outmain the process
of
optimising JavaScript programme?
I don't have general
answer to this question, but I can say for
many
optimisations we succeeded to do this in almost
fully
automatic way.
So what we did, we built a tool for
semi-automatic refactorings, and general idea
of this is
to provide as you input something that we
already have,
and this the program we want to optimise and
some set of
tests, they can be functional tests on which
you will
check the reference of your code.
To use it as input
and output, you have optimised program.
It sounds
really promising.
So let's take a closer look into the tools
-- into
the structure of the tool and what tool actually
does.
So, as I mentioned, you use your program,
set-up test,
and you describe the pattern you want to optimise,
you
want to refactor, and our tool is based on
estimating
and rewriting, and I hope most of you are
familiar with
the AST term, and simply speaking it is a
true
representation of your JavaScript code, and
in addition
to this, we wanted to report only those optimisations
that actually provide some performance benefit,
and
that's why we do performance measurement for
every
optimisation that our tool applies, and of
course, as
output you have optimised program.
So what is pattern specification?
We wanted to keep
it simple, so we said our pattern will be
two fragments
of JavaScript code, how the original will
look like and
how the optimised code should look like, but
we also
wanted somehow to make this pattern up struck,
which
means you don't have to write pattern for
every project
so you can make your pattern specification
once in
a general way, and we use it for many projects
later on.
And we also wanted to make the pattern enough
so you can
cover as many cases as possible.
So to do this, we
introduced placeholder for some constructs
in
JavaScript, I don't see this list of placeholders
you
can see now is exhaustive.
It is not.
We are working
on adding more placeholders in our tool, but
for now,
our tool supports placeholders for expressions,
identifiers and literals.
And if you remember, the
example of split and join, we can say okay,
the split
can be called on any expression JavaScript,
which means
not only on identifier or some stream, it
can also be on
some property access can be called on that,
some result
of the function call, and so on, and as I
input to
the -- as the permitter of the split, we can
have any
identifier later, all the same with join.
So you can
see how the optimised code should look like.
Based on the pattern specification, our tool
generates the ASTs for each code fragments,
and for
generating ASTs we use existing parser, but
yeah, the
idea about the transformation is not specific
to the
outlook, and can be applied to any other parser.
So
having two ASTs, our tool actually generates
the
programs ASTs and tries to find a match between
AST of
the first fragment of our pattern specification
and
subsub in program AST and once the match is
found, it
rewrites the AST of the original program as
our AST of
optimised code.
Looks like this, sorry.
Okay.
I would
illustrate the first step of our tool on the
examples.
So given the first fragment of our pattern
specification
we generate the AST, it usually looks like
something
like this.
And for some program we try to find match
between the first AST and some subtree of
it, and we say
the two ASTs match if the number of nodes
position and
the types also match, but we have special
rules for the
placeholders, for example, this expression
one
placeholder can match to any tree structure,
that
represents some expression, and also all in
this
identifier can match to any identifier in
JavaScript,
and the same with the $y.
So now we all have the
subtrees or program AST that match the pattern
specification.
The next step is to rewrite all those
subtrees.
What we first use?
We first generate the AST
of the second fragment or optimised code of
our pattern
specification, and as you can see here, there
are some
nodes that should be resolved.
I mean, all nodes that
represent the placeholders.
We just use what you found,
replace placeholders with the real nodes,
insert this
AST instead of the found AST and generate
a new code.
Yeah, that's how the optimisation takes place.
But is
it worked?
Does it bring some performance benefit?
Well it depends on the tests that are given
as input, so
we use those tests to run the original and
modified
optimised version of the program.
And we show to the
developer only optimisations that really bring
some
performance benefits.
So we run every test, repeatedly,
until some meaningful measurable execution
time is
reached and we compare the execution times
of the
original and optimised program.
It's nice.
We have
a tool, is it useful?
Well, we didn't always find it
useful, really, but we decided to run this
tool on some
real world JavaScript projects and on some
patterns we
found, so we made a specification for six
patterns that
change at most one statement in JavaScript,
and we run
this tool against 10 JS libraries, which we
extracted
from NPM repository.
And yes, we found the
optimisations, we found 35 potential optimisations
and
24 of them actually show some speed up.
Now I am going
to give you example of one optimisation we
perform by
our tool.
So in this particular function, the type of
the input is checked, by using class comparison,
class
comparison in JavaScript is done by calling
to string
method on object.
So the developers first use class comparison
to
check the type of the input, and if it is
not true, they
use instanceof operator.
It does the same thing.
But
it seems to be more efficient.
So it is more efficient
to use first instanceof than class comparison.
And we
found ten potential optimisations of this
pattern, six
of them showed actual speed-up.
And we reported this
optimisation as a pull request to JS library,
and they
accepted this pull request to merge and optimise
their
code as we proposed.
So I would conclude this talk by saying that
yeah,
you can reach really nice performance benefit
by using
very simple optimisations and semi-automatic
refactorings can help you to achieve these
goals, so in
stead of a slow turtle we can have a rocket
turtle.
Thank you.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>