<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Jeremy Ashkenas: A Cup of CoffeeScript | Coder Coacher - Coaching Coders</title><meta content="Jeremy Ashkenas: A Cup of CoffeeScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Jeremy Ashkenas: A Cup of CoffeeScript</b></h2><h5 class="post__date">2013-01-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/A5Sg04IEkvk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm gonna talk about CoffeeScript which
is a little language that is written in
itself and compiles to JavaScript so I
was pretty interested in a lot of what
Crockford was just saying couple minutes
ago over in the other in track' about
all of the sort of deficiencies and
things that people aren't satisfied with
in JavaScript and things that could have
been done better bad parts that should
be left out and you know it should be
kind of like a human right but for but
for coders that you should have a coders
right to have javascript be the language
that you want it to be and and because
javascript has such a nice clean
functional object-oriented lexically
scoped core you can build a lot of
interesting languages on top of it
without having to get too far away from
what the core idea of javascript is so
could I get a quick show of hands of how
many of you have played with
CoffeeScript before all right so that's
a that's a pretty good mix so I'm gonna
go quickly through some of the language
features what it does differently than
JavaScript and then also how its
implemented if you want to write
something like this for your own
language that would be however however
you sell fit so let's see here
this talk is gonna be pretty rapid-fire
it's also just gonna be all codes so we
can if you have any questions feel free
to raise your hand in the middle and we
can change things and recompile it and
see see how it works so so there's kind
of three main aspects to the idea of
doing this you know there's a lot of
languages I mean I guess the other one
of the other really big ones is
objective J which puts Objective C into
JavaScript but to do that you have to
have kind of an entire runtime but the
idea here is not so much to support an
existing language like Python or Ruby
into JavaScript directly but instead to
take the core of JavaScript and to clean
out all the syntax that you know looks
like Java but you don't really need and
to also clean up some of the semantics
so things like var how you know you have
to use var the first time you declare
the variable never again thereafter and
you almost always need to use it the
first time because you don't want it to
be global so things like that go away
things like like statements go away
everything is an expression in
CoffeeScript so you can pass the
result of an if statement directly back
to you can assign it to a variable you
can pass it back to a callback that sort
of thing so that's the second aspect we
have that we have the cleaned up syntax
we have we have cleaned up semantics and
there's also extra goodies so language
features like slices splats that's the
very attic arguments that the Crockford
is talking about before you have
comprehensions instead of low-level
loops and all all kinds of extra goodies
that we can there's some things that you
can't do like Brian was just talking
about like with method missing you can't
do that without actually either having
an interpreter or having you know or
intercepting every single object call
that you ever do so those kinds if
there's some things that are just
impossible but the things that we can do
we try to so the gold so that that
brings us to the golden rule is that
it's just JavaScript it's not it's not
it's not a runtime it's not an
interpreter there's no special functions
really allowed and that's a rule we
break slightly but but we're not going
to be injecting a whole bunch of
CoffeeScript specific library functions
into your code in general it just
translates into the equivalent
JavaScript so it leaves a lot of things
out it is a smaller language then then
JavaScript is you don't have with you
don't have semicolons or semicolon
insertion to deal with and you're
parsing you don't have to worry about
trailing commas there's no difference
between the colon inside of the object
to assign a property versus variable
assignment outside syntax wise no
implicit global variables because that's
taken care of for you you don't even
have to worry about low-level for loops
because instead you have comprehensions
and if you really really need the
low-level loop you can use awhile so
that's the one that we do expose and
that can be that's the general have to
be transformed into into anything else
and no difference between turn areas and
if else's right so in JavaScript you
have an F else that's a statement you
can't return that value but a ternary is
an expression and you can and there's no
real reason that they need to be two
separate things so let's start with the
basic basically a function so here you
have a JavaScript function it's it's
assigned to a variable named square it's
also named so that if you need to debug
it you'll actually have a name in what
you say anonymous and you're gonna
return you're taking a number X you
return X times X and that's that's you
know JavaScript 101 so if we were going
to transform this into CoffeeScript what
would that look like
well first off you don't need a
semicolon because
why bother second you don't need to
declare your your VAR you can just
assign it we can we can use and this is
kind of up to your style the preferred
CoffeeScript styles to use colons to
assign all over the place instead of
equals but they are interchangeable so
you can use equal signs instead of
objects inside of objects as well so
we'll switch this over to a colon
returns are implicit inside of a
function the last thing that you last
expression you evaluate will always be
returned so you don't need to return it
yourself so we'll take that out and also
the semicolon in there it uses Python
style block whitespace syntax so you
don't need to use Curly's to the limit
your your blocks so we'll take off the
Curly's and just use the indentation
there and finally instead of the
function keyword well I guess before we
get to that we have square repeated
twice and which always looks very
redundant so let's take off one of those
squares and finally instead of the
function keyword what a function looks
like is just an arrow pointing from the
arguments to the result so we have
square as a function of X and it goes to
x times X and now that's highlighted as
a function and you can also write that
on one line like this so you can see how
that got transformed square as a
function that takes in action it returns
x times X so that's a good example and
actually let's give this a try so this
textmate is hooked up and there's a
there's a text made bundle there's a
there's an Emacs bundle there's a vim
bundle there's bundles for all your
needs
this one's hooked up so we can compile
this and see what it turns into
so here we have it back looking more or
less like it did the the declaration got
pushed up to the top but you have back
your JavaScript function and if we run
that let's say puts the square of 100
and we get oops I have to do the whole
thing let's do this we get back 10,000
all right so um it the sort of the mo is
to not change anything about JavaScript
that's already you know very clear and
very common it's not just changing it
for changes sake so so arrays look the
same object literals look the same
there's a book very nicely done you can
see how we're using the same assignment
syntax element
is an object literal that has hydrogen
silicon and uranium properties with if
you because it has because we are
whitespace sensitive if you do your
assignments on multiple lines you don't
have to worry about comments you can
leave them off you can put them in you
can have trailing commas it's all going
to compile to the same thing so actually
let's do that we compile this to
JavaScript and we'll get our commas and
you can see even if you have them and
it's trailing it's not going to be
trailing when you compile it to
JavaScript so you won't kill you on that
and and property accessing is the same
it's dot property so we can say it puts
elements dot
silicon and we're gonna get back 14 all
right
on to the next one so this is the
whitespace for blocks and tax that I
showed you before it of course looks
more more Python II when it gets more
nested so here's an if here's a block if
statement if answer is yes and attempts
is less than three then we have a
try-catch try try again catch error
report error and if you look at what
this compiles to in JavaScript just to
get a sense of how the whitespace is
working it's gonna look like this so you
can see how your try catch block got
translated and all the curly has got
inserted and this also shows some
aliases that that you have so all of the
JavaScript operators greater than less
than triple equals stuff is available
but you also have aliases so yes yes yes
no on off our aliases for true false
like they are in the ml so you can write
things out a little bit more naturally
if you're depending on what your wording
is for your boolean and then also is in
isn't for triple equals and not not
triple equals which is nice too so a lot
of things that are available in block
syntax form like this are also available
in postfix prefix or postfix so here we
have if ignition is on block launch
rocket or you could say launch rocket if
ignition is on and if we compile this
snippet right here we can see that I
guess in one case it became the ternary
and the other one it's a it's the actual
block if but they're doing the same
thing
if ignition is true then you wash the
rocket otherwise you don't and then the
same thing for the same thing is true
for basically for anything where you
have a where you have an indented block
you can also do a prefix if it's just a
single line expression so here we're
doing a comprehension so for every song
in repertoire we're gonna sing it and
then this is the same form but but
written as a block all right
so getting getting past the sort of the
syntax subtractions the you know all the
semicolons and punctuation noise towards
the expression stuff which i think so
I think that everything is an expression
is probably the single most important
feature of all of this it definitely
changes the most in how your code is
structured so here we have a
comprehension you're going to print out
I for I in that array in one two three
and so this is this is an example of
running a function call you know n times
or I times for that entire statement so
if we run that we're gonna get one two
three I just ran the entire file sorry
we're gonna get one two three but you
can also so if you wrap if you wrap the
comprehension and parentheses or if you
call the comprehension or you return it
or you assign it to a variable it's
going to be converted into an expression
for you and so what that means is is
that as we're generating the code we we
look at the comprehension and we say is
it being used is it being returned is it
being assigned to and if it is then it
gets converted into the result of the
computation every single time through
the comprehension so this just to be
familiar to you if you've used Python
before or but it's basically the
equivalent of doing on each or a select
or a filter so you are taking your
you're applying the you're applying the
block of code for every time through the
loop and then you're taking the array of
results and you're turning that array so
here we're gonna print out one two three
as an array I guess P will make that
more clear because P will inspect that
so now we'll see one two three as an
array as the result of this and so
internally what it's doing is its it's
pushing the result of every time through
onto an array and then returning that
when it's done so but this works exactly
identically for
for anything else so here we're gonna
put a try/catch block directly into puts
and so if we run that we're gonna try to
call a property on a missing object this
object is not defined that doesn't exist
and then catch the error and then print
that out so we have the error is
reference error missing is not defined
and so internally what happens is
basically every every single node in the
grammar knows how to return itself so
you can ask it to basically if you're an
if and it and you're being asked to
return it'll return all it'll return
from any of the branches that it goes
into if you're a for loop I mean if
you're if you're a comprehension you ask
to be returned you're gonna return the
results of going through the array if
you're a try-catch you're gonna return
the either the try or the catch
depending on what gets fired and so
based on that anytime you need to
convert an expression a javascript
expression into a I mean start a
JavaScript statement into an expression
you can wrap it in a closure so if you
wrap it in a closure and then you return
the result now you have something that
used to be a statement but instead it
can be used an expression so that's
what's going on internally there the
other thing that I didn't mention that
this demonstrates is this isn't being
syntax highlighted in this but we have
string interpolation as is proposed in
Ekman script harmony I'm one really fun
place to mine for language ideas is
there's an echo script harmony wiki that
has a whole bunch of things that they're
thinking about putting into the next
version of JavaScript and this is one of
the proposals this is just a quick
little demo of how the var works so you
might have noticed that we're not
declaring var at all but what ends up
happening is that you're you're when you
when you first use a variable when you
first assign to a variable its var
declaration is going to get pushed up to
the top of the nearest lexical scope so
in this case a is going to have you know
the equivalent of var a out here because
it was first even though it's being
referenced in the same exact way inside
the function it was first reference
outside and then B will have a VAR b
inside the function won't be visible
from the outside scope so that's how
that's handled for you what it means is
that you can't you can't shadow
variables inside of a function
the same name you're always going to be
referring to the outside variable and
that's similar to languages like Ruby
inside of blocks if you refer to a
variable the same name it's always going
to be the outside one so you have to
pick it if your name if you actually
mean a different variable because there
isn't devar for you and I think that's
that's a worthwhile trade-off the other
way isn't workable at all if everything
shadows then you can't get anything done
here's another example of a clean up it
we fix Java scripts which statement so
so I guess we have chef a long example
of what it looks like these are the same
sort of implicit blocks you can say when
Moe then do an action or you can indent
it like this is equivalent but switches
internally compile into if-else chains
using object identity to match instead
of a JavaScript switch case statement
because Java scripts which cases are
implemented using labels you can only do
string comparisons you can't compare
anything that's not a string and if you
do it'll course it and then also you
have to stick and break after every
after every case we don't want to fall
through so so instead of doing that this
becomes an if-else so we can put this
back the way it was and give it a try so
if we run this actually nothing will
happen so then let's call so which
stooge which dude is a function that
switches on stood when it's Moe then it
says it's Moe when it's curly and this
is using actual objects not strings so
let's say puts which is huge curly and
let's run this file and we'll have it's
curly oh I'm sorry I was already put
saying we can just say which ducha curly
we can do the same thing for moe
and let's look at what it compiles into
so we have our we have our two objects
and you can see how we have our function
it's a named function if Stooges moe
then we return that value you can see
how the returns are getting pushed into
each into each statement so because the
switch that's a good example because the
switch was the last thing that happened
inside the function you're always going
to return a value no matter what you do
let's see is 10 22 all right here's that
string interpolation so we have dollar
sign and and so this this is exactly the
same as the proposed harmony syntax
dollar sign literal
or you can do literally just gets
interpolate it directly and then you can
with dollar sign with brackets you can
do arbitrary expressions inside of your
interpolation so let's say Jeremy name
is Jeremy there you go and one thing
that we add is a pythons chain
comparisons so if you have more than one
greater than less than comparison in a
row it's going to do the correct order
of operations to make that value work so
healthy is if your cholesterol is less
than 200 and more than 60 so healthy 133
is going to be true and healthy 40 is
going to be false and what's going on
under the scenes behind the scenes here
is this gets converted into 200 is
greater and cholesterol is greater than
60 and so this is one of those cases
where if you're doing some like this in
your own language you have to be careful
if you ever have to reference a variable
multiple times two to compute a result
you have to be careful that you don't
call if it for example if if what's
going on here's a function call that you
don't call the function twice because
then that could have side effects and
could do something you don't want it to
do so the way we get around that is if
cholesterol is actually a function call
here and you compiled that what's gonna
happen is you're gonna get a temporary
variable assigned to cholesterol and
then referenced in the later one so you
don't have to so it doesn't get called
twice
and that that's the case in general for
for something we need to have multiple
references to an expression but you
don't want to evaluate more than once is
we'll do a temporary variable in the
output JavaScript so really quickly
besides we saw the array comprehensions
before where you're saying I in a list
of numbers but you can also do it for
objects so it's for its for sorry so for
a number in a list of numbers or for key
comma value of an object so in this case
we're gonna look at all the keys and
this is so this is all being powered by
nodejs on the back end so we're looking
at all the keys in the process object
which is the one of the global objects
that you have and you're going to get
back your big list of of node signals
and such and so that's an object
comprehension and of course you can have
a block inside
doing however much code you need to do
and then there's also range
comprehensions so instead of having to
write out if you if you're if you're if
you're a for-loop was just gonna be
numbers and you're going to start at
zero and go up to a certain amount
instead of that you can use a range
literal this is the same as Ruby's range
literal more or less so two dots is is
inclusive of the final value and three
dots is exclusive and so this is this is
going to be the comprehension of I in
zero to twenty let me take off this by
two for a minute and then we're going to
join it so there you have from 0 up to
20 you can you can do steps so we can
say by two and that'll give you the even
numbers and you can also do filters so
this is where this is where that select
filter kind of thing comes in so for any
comprehension you can say when and then
you have an arbitrary condition to to
satisfy so in this case let's say when I
mod two is one and we'll get all the odd
numbers or a but this when I'm on two
isn't 0 isn't 0 and now we get all the
odd numbers between 0 and 20 inclusive
all right I'm gonna try to get through
this on time so here's a JavaScript a
statement again you can tell because of
the semicolon so this is something
you've probably done a lot where you
have a default value you want to assign
to a property inside at the beginning of
a function so one of the simplest of
plus equals and minus equals and divided
by equals in JavaScript and in languages
like Ruby you would have instead of
writing this you would write or equals
to say that the options or equals the
default value so one thing that we do to
get rid of those you can still use those
if you want to they're present it's it's
all sort of backwards compatible with
JavaScript you can sort of slip into it
easily but the cleaner way to say that
is just assign it to the half expression
so options that value gets or the
default value or you could do gets and
or you could do gets plus and this would
be like doing a plus equals assigning it
to plus the default value so let's talk
about splats
splats are a nice feature where you know
if you if you have a splat in your
argument list will compile that into the
correct look
up inside of the arguments array to get
back what you need so here we've got
Best Actor the first arguments going to
be the winner and then every every next
arguments gonna be a runners-up and
we're just going to print out who the
winner is and then pass in three three
actors and you'll get the expected
result and if we look at what that
compiles into you're gonna see that
we're gonna be so this is one example
where we do have a reference to a
special function just to keep the code
shorter the actual outputting bytes so
we make a cash reference to a rate
prototype slice and we're gonna slice
the runners-up to get that this is kind
of a fun one the the existential
operator if so so or the the logical or
there's a lot of falsey values and
JavaScript things that like zero the
empty string that that you might be they
might be confusing to you so if you're
trying to set a default speed for
example and you use or if the speed
happens to be zero which is a perfectly
valid speed to have it's gonna still get
the default which isn't what you want so
what you really want is you want to say
if it's not undefined and it's not null
you know those are that being that not
exist values then then use it so the
existential operator which is the
question mark gives you a way to sort of
to say if it's undefined or if it's null
then you know do one thing or else do
the other thing so in this case if we
leave this the way that it is using or
and run that you're gonna get back 140
let's see I wouldn't go around your step
part right you can get back 140 but if
we use the existential operator you're
gonna get back to the correct value
which is it's gonna stay zero because
there is a valid speed and so you can
use the existential operator with in
property chain if you're walking down a
property chain this is similar to a soak
in groovy where if that value is
undefined that property is undefined and
it's going to stop and you're gonna get
back undefined as the result so in this
case we can say put suit name let's get
rid of this and it's gonna say sue sue
name that length does exist
to name dot length dot other does not
and we'll get back let's see let's keep
going other dot dot 1.2.3 it's spelled
wrong you get back an error but if you
want to soak it up and you want to
assign this often happens and you want
to assign if it doesn't exist then just
give me back undefined and I don't need
to to continue then we can say oh let's
soak up the result of that chain after
other and you're going to get back
undefined instead of the instead of the
big exception so yeah dude is a
judicious judicious use of soaks can
help clean up your accessing and I'm
gonna try to wrap things up there's
class literals which this this is
basically a lightweight wrapper around
so it's this isn't this isn't like a
full-blown class system with runtime
objects and stuff all this is is setting
up is basically you have an object
literal and you set properties on an
object right you have a class little
you're setting objects on the prototype
you're setting properties on the
prototype so that when you make a new
object everything will be set up for you
correctly and so the two extra things
that this lets you do that aren't so
easy in JavaScript is it helps you
correctly extend the prototype chain
there's a lot of ways to incorrectly
except extend the prototype chain where
you're breaking your inheritance and you
can only get one level deep but this
will this this uses something similar to
Google haratz from the closure library
if you guys have ever checked that out
to to basically you can have arbitrarily
long inheritance chains with with
everything working correctly including
super so you can call super and it'll
reference the function of the same name
on the immediate ancestor and you can of
course pass variables to that and do the
super things that are usually tricky to
do without a class library in JavaScript
so here let's say so here we've got a
sea chantey our Mariners we can make a
new Mariner and have him sing make a new
sailor and we can see how sing is
overridden this is all you know OOP 101
and then the pirate calls super and then
says are so loud the pirates sing and
that's all as expected and let's see I
think that's that's getting close to the
end I'm going to wrap things up so in
terms of implement
this CoffeeScript was first written in
Ruby it was a ruby gem because of course
when you start working on a new language
you have to start with something and but
now it's written entirely in
CoffeeScript so there was a point where
we we had a working ruby version and
then wrote a CoffeeScript version that
was more or less parallel had the ruby
version compiled that and then had the
CoffeeScript Version compiled itself and
then now that's where we are so it's
like I guess is that there's that
Wittgenstein staying about pulling up
the ladder after you you know we can't
go back now if if the CoffeeScript
interpreter disappears then there's no
way to compile it at this point because
that's that's all that does it so um so
it was using Ruby and rack and rack is a
it's a it's a yak style lalr parser
generator that's that's done in Ruby and
C but so now that we're in JavaScript it
uses Jason which a Zack is gonna give a
talk about shortly I think it's not the
next one but the one after this which is
a nice flexible JavaScript parser
generator so so that's that's the
current mix it's got a handwritten lexer
done in CoffeeScript it's got a rewriter
so the token stream gets rewritten
before it actually gets sent to the
parser which is something that lets us
get go beyond the sort of basic lalr
grammar we're doing stuff with with the
with the implicit calls where you can
see how we're saying you know we have we
have calls that don't need parentheses
and then they get matched all the way
down to the end of the of the block
doing things like that with uh with the
significant whitespace and also the rest
of language features gets a little bit
tricky if you're trying to fit that into
you know this would seem like it'll be a
very large large language try to fit
into a grammar but if you rewrite the
token stream in advance to remove
ambiguities and things that would be
ambiguous if you decide in advance oh
this is the way that implicit calls work
before the parts before the parser ever
sees it then you can have a much smaller
parser so including including the
grammar including the rewriter including
the lecture it's 1,800 1,800 lines of
CoffeeScript so it's not it's not very
big and then and then that and then the
result of the parsing stages the ast and
then to generate the JavaScript you just
call compile at the top level of the ast
and all walks down and every node you
know passing information around compiles
the resulting JavaScript output so all
of this is available on CoffeeScript org
it is
it is sort of a fun project it's not
it's not supposed to you know I'm not
trying to sell you one using it for your
next big web app I think it's fun to
play around in and the language still
might change until we go to 1.0 if
things have settled down a lot recently
it used to be much more unstable the
first version didn't have significant
whitespace and then people were you know
talking about it and we we decided to
add it but uh so the language might
still change and that's the caveat but
besides that it is being used some
people are using in production to do
different things here's a fun example of
someone who's using it to generate art
on their website so this is using
CoffeeScript in Raphael to
combinatorially combine a whole bunch of
little sketches that he has going on and
and then I've got a fun example of this
of my own which is right here so this
shows that you don't really lose you're
not gonna really lose any speed from
from what JavaScript would be doing if
you do something in CoffeeScript because
it's gonna be a one-to-one translation
so this is v8 powering a strange
attractor that we can let's see we can
reseed and draw in different ways and
the and the processing speed of v8 here
is is very good it's comparable actually
to the to the Java processing versions
of this same of the same sketch so again
it's all on CoffeeScript org there is an
interactive compiler you can try it'll
it'll compile as you type right here
it's running in the browser there's also
the entire annotated source right next
to that so if you want to read what the
grammar looks like you can pop over to
that and you can check out what all the
rules are so here's statements
expressions all this kind of stuff and
come talk to me about it after if you
have any more questions and thanks a lot
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>