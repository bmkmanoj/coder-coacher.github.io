<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Dave Herman: Modules for JS.next | Coder Coacher - Coaching Coders</title><meta content="Dave Herman: Modules for JS.next - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Dave Herman: Modules for JS.next</b></h2><h5 class="post__date">2013-01-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qM9u-5fjNvs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yes so as Brendan said I work on Jess
next so today I want to talk about
modules that we work on a lot of stuff
for Jaya snacks and I'm happy to talk
with people about any of it but uh but
for today I want to I want to talk about
modules because I think it's really
important so so modules are all about
great libraries and languages is really
nothing without its libraries it's the
lifeblood of a language and a javascript
is doing well for libraries we've got
we've got an impressive field and it's
growing all the time it's exciting to
see I think it's only getting better but
if we're really honest with ourselves we
have to admit that we're kind of getting
pummeled by our older siblings so this
guy over here as of this morning they're
up to 20 2529 packages on Sipan this guy
over here closing in on 14,500 packages
for python and of course he wasn't in
the original picture but this guy is
actually the the big heavyweight here as
of this morning Ruby gems are up to 20
3501 those are those are impressive
numbers but I don't see any reason why
we shouldn't be able to to reach those
numbers ourselves with JavaScript I mean
we got the whole web behind us so it's
not like we're talking about a small
playing field so I want to argue that
the language is actually not quite
giving us the tools that we need to to
support it now on the server side we're
catching up so we're sort of we're still
the little brother but but NPM is
catching up fast i think we're closing
in on about 2,000 packages for npm so
that's that's getting better but
especially when you're talking about
writing a library for the browser or
even worse if you're trying to write a
library that works in in any environment
that's the significant its host
environment the language isn't really
helping you right now so JavaScript kind
hands you this this little ball of clay
and it's a very malleable ball of clay
we've actually figured out how to do a
lot with this ball of clay but every
time you start your new application or
your new library you've got that same
little lump of clay and and it's kind of
all up to you so so let's see what you
know what what you have to do if you
want to write your own module so the
first approach that that we've kind of
all learned is the module pattern and
this this lets this makes life nice for
the client it means the client can
really do something as simple as a
script source equals and just add your
library to their program and everything
works fine for them for the most part
but for you as the library writer
there's a whole lot of bookkeeping you
have to do this is kind of like the bare
minimum of what you need to write a
library for the browser so to start with
my highlighting isn't going to show up
very well that's all right so to start
with you you wrap everything in the
immediately invoked function expression
down here we pass in the global object
this won't even work if you're trying to
create something that's that's multi
environment so you have to play even
more trickery to get at the window I
were to get at the global object if it's
not called window may be up here you uh
so yeah down here you actually put all
your exports in an object up here at the
top you might save a local copy of your
library in case you need to refer to it
during the body and then the most
miserable part is this uninstallation
process that you need to do to be a good
citizen so just in case the global name
that you chose is the same global name
that somebody else chose or maybe you
just have a user that doesn't want to
trash the global namespace and they'd
like to be able to get at your library
without it trashing the namespace you
have to sort of create this little do
this little dance to restore the global
object to whatever state it was in
before your library got installed and
right here in the middle
these three lines that's sort of like
the core of the library that's the
actual contents here the rest of this is
just boilerplate this is a huge amount
of overhead that you have to pay every
time you want to create a library that's
just too expensive and just the fact
that it's a pattern language geeks like
me when we when we whenever we hear
people say design pattern it sort of
sends off a red alarm in our head I like
this quote from Paul Graham he says I
wonder if these patterns are not
sometimes evidence of the human compiler
at work I don't want to be a compiler I
don't think anyone should be a compiler
I think your compiler should be a
compiler so if you don't want to go
through all of that pain another choice
another option that you have is to take
some existing framework and just write
your your library as a plug-in for that
framework so if you are willing to make
the assumption that your users will use
jQuery for example or that they'll have
to use jQuery to use your library you
can just extend jQuery through their
their plug-in mechanism that's lower
overhead on your part for creating a
library but it's a crappy deal that that
you just had to make which was basically
i'm willing to restrict myself to only
those users who are using this
particular framework so that's no fun
now on the on the server side common j/s
has really drastically improved the
state of things so common Jas is is very
much a big deal when you when you write
your note j/s app it's really as simple
as sticking it in a separate file making
sure it's in the right directory and you
can just say require and common GS is is
starting to pick up steam in the browser
but this is what it looks like when you
want to use a common j/s library in the
browser environment and the reason for
this of course is because of the
non-blocking i/o and javascript so we
all know the the pain of the nested call
back issue in javascript and james burke
has done a good job and required j/s of
making it a little less painful because
you can sort of you can give an array of
modules that you want to to require so
there's only one nested call back but
this idea that you have to slap this
boilerplate boilerplate around your
program and nest your program into the
middle there is is really just too high
of an overhead especially because now
we're talking about overhead on the part
of the clients so now you're saying if
you want to use my library you every
single one of you users of my library
you're going to have to pay this cost to
buy into it so I think we we need to be
able to do better than that and on top
of that there are just certain things
about the semantics of JavaScript that
are that are not ideal that common J's
can't really do anything about because
common Jas didn't didn't have the luxury
of changing the language so when you
create your separate module and you put
it in a separate file there's still
nothing common j/s can do to stop you
from making a mistake and assigning to a
global variable so if i accidentally
assign to I in inside of my common J's
library I'm going to create a global
variable and have all the the trouble
that global variables cause so this is
sort of all prelude to why I think
modules for Jas next are important and
why on TC 39 the the ACMA script
committee we've been working on this so
in our design creating a module is
really as simple as this you just use
the new module keyword you give it a
name you put a couple of braces and then
you put whatever you want inside the
body and by default when you put a
variable declaration that variable
declaration is local to the module it's
not exported so if you want to export
something with the rest of the world you
say export so this immediately gets you
away from the iffy the immediately
invoked function expression but it's
still creating that that one global
variable and I think the common JSO
approach is a good one where you might
also like to just put the contents of
your module in another file and now you
don't even have to name the module now
you can let your client just import it
however they were require your module
however they want to so this is sort of
the equivalent of the previous slide
it's just being done in a separate file
so the client now just gets to say
something like this I should say that
like none of the none of the syntax is
absolutely set in stone and people like
to argue about the syntax and and you
know we may continue discussing the
syntax but this hopefully gives you a
flavor of what it is we're trying to do
so again we have this new module keyword
and the client can say i'm going to call
their lip my lib and i'm going to
require it from the separate file so
notice now you get to do external module
loading from within javascript no more
script tag necessary this also means
that it's one solution for the language
that works whether it's a nodejs or in
the browser in a mobile app whatever the
next school thing is that you can put as
many of these module declarations in a
row as you want without having to do any
of those nested callbacks so we're doing
io here so what's the trick how did I do
this without avoiding blocking the whole
browser the answer is that there's
really two stages involved in running a
JavaScript program and this is true in
all modern JavaScript engines even
though it's you know we think of it as
an interpreted language every JavaScript
engine actually has a really
sophisticated compiler in it so when
javascript code comes into the engine
the engine actually compiles it first
turns it into some sort of intermediate
representation or maybe into assembly
and then every time you call that code
it's actually going to run the compiled
code so we want to exploit that fact
that there's compilation involved so we
actually shove the i/o portion into the
compilation phase so all of these
requires are happening before any of the
code starts running and that's the trick
when you shove that into for example the
browser the browser can do the i/o in a
separate thread it doesn't have to block
the main UI thread so we have this
compilation phase that does all of the
loading in whatever order it wants on
whatever threads background threads at
once and then we have the separate
execution phase and that's where we once
again will enforce the sequential order
of execution like 0 is in JavaScript so
by introducing news
tax into the language and and extending
the existing compilers we actually will
allow you to write your requires just
the way you want to write them without
blocking the UI thread some more
features of the module system we can
nest module so here's a module
declaration inside of another file that
itself is defining a module and you can
refer to modules by name just like any
other binding in the language so so here
we're just sort of treating this module
like an object and its export map is
like a property of that object so we can
just refer to it as utila but we can
also get compile time checking again
we're extending the compiler here so we
know what these modules are at compile
time the compiler can actually tell us
exactly what the exports of that module
are so here we're saying import utilizzo
variable binding but if we misspelled
map the compiler will tell us right away
before it starts running the program you
got a you got a variable name wrong so
one of the most annoying bugs I find
when I'm writing JavaScript code is
whenever I fat finger a variable name I
don't find out till somewhere in testing
or if I forgot to test that particular
path I don't find out till the codes
already out there and running in in
harmony and jace next we're actually
designing it so that all unbound
variables will give you an early error
or compile time error and that includes
a bogus imports the other thing we can
do again exploiting this compile time
information we can say import util dot
star which you know some people think
that's bad style but for scripting
that's often just really useful if
you've got some module that has 200
exports and you want to use 120 of them
and you don't want to name them all by
name you can just say import that module
dot star and this doesn't have all the
problems that with has so with is you
know the problems of width come from the
fact that it's doing dynamic variable
binding what we're doing here is
completely compile-time variable binding
so the compiler knows what all of those
variables are
another thing that we are inheriting
from common Jas here is the notion that
models that you require our Singleton's
so if you require the same the same
module multiple times in the same
program you'll get one single instance
of that module which is just it's just
what you want so those were all sort of
static patterns but of course for you
know real serious JavaScript apps you
often need to be able to do dynamic or
lazy or conditional loading of modules
so the static modules that I was showing
you were sort of the simple easy way to
do the common cases but if you want to
do dynamic loading we also have an API
included in the design that lets you do
make dynamic decisions about requiring
and that's where you actually do have to
use the callbacks so for example if you
have some easter egg on your site and
you don't expect it to be clicked very
often and you don't want everyone to pay
the cost of loading the easter egg
module you can do you know on click for
the the easter egg element you'll then
make the dynamic decision to call this
require method on a module loader object
which I'll talk about in a minute give
it the URL and the callback that takes
the dynamically loaded module okay so
the design accommodates both static uses
of modules and dynamic uses of modules
okay that's sort of the basic highlights
this might get a little Trippier now I
hope that's okay I hope it's fun there's
there's something kind of lurking
underneath here that gets at the heart
of one of the really mind twisting
aspects of javascript javascript
actually gives you this crazy ability to
eval inside of your eval I'll spare you
the the yo dog jokes but so we can do
things like eval of eval of eval of eval
in JavaScript and this this might seem
like a crazy parlor trick
um and in fact you know there's there's
lots of people who have learned that
that we should never touch eval eval is
evil all of those things we've all heard
it and I'm so inspired by Andrew DuPont
who who's telling us all relax
everything is ok you just got to know
what you're doing so I personally don't
want to see eval go away I think eval is
an incredibly powerful tool that's not
always the right tool so you know we all
know we've all seen these examples of
ridiculous programs that use eval where
they had no business doing so you know
when you can use bracket notation
there's absolutely no reason to be using
eval but that said there's plenty of
examples where I can't think of anything
other than eval that will do the trick
so if i want to write a little
command-line interface for javascript a
little JavaScript shell how am I going
to do that without evil am I going to
write my own JavaScript interpreter just
to implement that that seems absurd
that's exactly what eval was built for
and this I mean this site you know is
maybe not the most you know full scale
web app in the world but there are real
web apps that need to evaluate
JavaScript code for real serious
purposes we've seen some some awesome
demos yesterday of the ACE editor of
course there's code mirror and when you
have an IDE that somebody's editing
their JavaScript code and they want to
run that JavaScript code well that's
that's evil right the the cloud-based
editors are written in JavaScript
they're taking JavaScript code and
running that JavaScript code so that's
an eval inside of an eval there's sort
of a hidden inception inside of every
one of these web apps but there is kind
of a nuisance of that eval which is the
fact that every one of them is sort of
sharing this one single global namespace
so if I'm writing my own cloud-based ide
and I'm taking some arbitrary strangers
JavaScript code and I'm running it I'd
really rather run it inside of some sort
of a sandbox so that i can make sure
that their codes not accidentally going
to trip up on the javascript code that
implemented the ide itself
and if they're going to do things like
hack the the prototypes of the standard
built-ins I don't want that to mess up
the operation of the IDE itself so I'd
really like to be able to kind of create
these nested evals and somewhat of a
more protected setting so I showed you
that module loader dot require before
module loaders are actually the the way
that we can do nested evaluation in a
more protected sandbox a module loader
is itself a sandbox so it's module
loaders all the way down and we can take
an existing loader say parent loader and
create a new one and we get a lot of
bells and whistles where we can control
exactly what that sandbox does and
doesn't allow what it shares with its
parent and what it doesn't and we can
and we can eval inside of that loader or
we can require external modules with
that loader so some of the things that
these sandboxes let you do you can
control the instance caching that that
makes the singleton behavior work you
can create custom loading behavior so
you could decide that you want to
redirect load requests to some CDN or to
some local storage where you've been
cashing it you can you can put whatever
custom behavior you want there you can
create a separate global object so that
it's completely isolated from the parent
loader you can create fresh built-ins so
that prototype hacking doesn't interfere
with each other and you can even do
compiler hooks so you can actually add
your own compile time checking like a
lint tool or you could even add your own
arbitrary compilation where you can say
hey I want a module loader that
understands CoffeeScript instead of
JavaScript so uh where we are right now
we've prototyped this in a meta circular
evaluator for java script called
narcissus I've built the the core module
system and parts of the the module
letters as well and for the sake of demo
we also have an add-on for a Firefox
called Zaphod that takes narcissus and
drops it in as a replacement for spider
monkey
so I'd like to do a demo just showing
you a little bit of some of the kinds of
cool things you can do alright so here
I've heard people saying they don't like
live coding I hope this isn't unpleasant
okay so here we've got a little tiny web
page let's call this one harmony okay so
here's a little div called harmony and
just to show you that we're working with
narcissus type equals script narcissist
this is what Zaphod does is it lets you
use this sorry application narcissus
right so of our element equals document
okay so that code was actually not
running through spider monkey but
running through narcissus so so this is
actually the extended that the language
extended with the module system so one
thing that I've done is well here let me
show you know it's still like this
script type equals application or cissus
source equals coffee so I've implemented
a little module loader for coffee script
and it's not the full coffeescript it's
just enough to demo so I could do just
to show you that it really is there
alert coffeescript okay so there's a
module loader called coffee script that
I brought into scope so I don't know if
this exactly will be something we could
do for HTML but I would really love it
if we could if we could just take an
existing module loader that's already
been defined and say that's the loader I
want to use for this script tag so then
I could do element equals document Oh
should create that element
okay so there's some coffee script code
just embedded in my web page and there
it is okay and just to show you that I'm
really weird I've got 14 scheme as well
okay so here's some scheme code to find
element
oh yeah
Thanks pair programming document dot get
element by ID scheme set bang element
that entry channel oh man the dot should
work let's look at my backup file and
see what I did wrong scheme dash loader
is it's always good to have a cheat
sheet there we go alright
okay so as I say I don't know if the
HTML extensions here are going to fly I
have not yet pitched that to anybody but
that's kind of my goal here is that I'd
like to be able to let you write your
own language extensions and then plug
them directly declaratively into the
into your HTML so that you can put
whatever languages you want or whatever
extensions to javascript you want this
of course is going to have a performance
cost so it may not always be viable in
production but what it does mean is that
when you're when you're in development
you don't have to run your own
preprocessor on the code before you
before you can actually keep reloading
it means that you can do that the more
dynamic shift reload style that that
will know and love for the development
process okay so that was the demo all
right so I actually don't have too much
more might run a little under but I want
to address head on something that you
know I always hear a fair amount of
angst about you know I I'm not trying to
taunt you with things that that you
can't have tomorrow but at the same time
I can't promise you that these things
are going to happen overnight so the the
life cycle of the standards process is
long and and it means that that these
things take some time but but here's my
plan this is this is my answer to that
question I've got to work hard and the
rest of tc39 s gotta work hard and we
are working hard on specking prototyping
building in real browsers and then
deploying so we've moved at Mozilla to a
faster release cycle that's more in line
with the the speed of the chrome
lifecycle and so we're not waiting for
the full standard to come out to start
deploying these features so we're hoping
to try to ship modules somewhere around
Firefox seven or so that is not a
promise but
firefox 7 is actually scheduled to be
later this year so it's our hope to get
this in the hands of developers as soon
as as humanly possible now that'll be
sort of the initial release out of you
know maybe be unstable as the standards
process continues we'll have to keep
refining you may not be able to build
production code that depends on it
immediately but it does mean that you'll
be able to try it out soon but there's
also you know just just because it's
it's released in 2011 or 2012 in modern
web browsers doesn't mean that every web
app will be able to depend on it because
you're going to have to wait for non
modern web browsers to catch up but
there is a polyfill answer even for
language extensions and this is
something that Brendan mentioned just
briefly yesterday but but i really want
to hammer on it just sort of like I was
showing with with module odors that we
could you know you could use it for
development as a quick reloading process
a quick debugging process but you could
still do an offline compiler we can do
offline compilers just like coffee
script for Jace next and we can even do
tricks like we did with Zaphod to let
you do that in a really convenient way
in development but then you could run
the preprocessor offline for for
deployment so my hope is that shims will
help that that people will be able to
start using the new features knowing
that ultimately the web browsers will
actually have built-in support for it
but until they do they can precompile I
think that's going to help but the last
point I hope advocacy is not a dirty
word but the developer community has a
really strong voice and what what
developers clamor for browser vendors
have to build so if you demand it that
will help bring the better future faster
so that's a taste of the module system
I'm happy to to dive deeper with people
offline and I'm happy to take any
questions about Jace next at all thanks
very much what's going on with proxies
proxies are in so proxies are
a fairly stable design at this point
they're they're widely lights on the
committee they're very very powerful and
we can do a lot of cool things with them
and Firefox 4 is shipping with them as I
said there may be some some API changes
so it's not completely stable yet but
but you can you can use them today and
it's my understanding that there are
chrome developers who are interested in
building it soon v8 developers who are
interested in building it soon but I
don't want to speak for them but yeah
they are they are harmonious they are
agreed upon by the whole committee so
the question is is an import that star
dangerous because names you didn't
expect can get injected so import that
star is not something that's happening
at runtime it's happening at compile
time so it's not like running code can
suddenly inject new things into into the
namespace but there is you know there is
somewhat of a hazard that you might get
it you might get in scope a name that
you didn't expect however part of the
design and modules is that if you have a
name collision where you imported the
same name from multiple places it's
going to give you an early error instead
of just sort of silently picking one so
somebody's not going to be able to
secretly override the name via import
star that said I fully expect that there
will be people building lint tools that
say you shouldn't use import star just
like they say you shouldn't use minus
minus and I think we're all grown-ups
and we can we can make those decisions
for ourselves I think imports star
import that star is just too useful for
scripting for rapid development and for
cases where you know what you're doing
but I certainly can understand that a
development shop might decide that you
know their coding practices say don't
use it I know what the question is
though is what's what's the deal with
require being a keyword requires a
contextual keyword here not a keyword so
the module for my should have said this
the module forum is a special form and
what's on the right-hand side of the
equals is not a arbitrary JavaScript
expression it's a module expression and
so
it's a limited sub grammar and require
is only special in that context so
there's no backwards compatibility
issues with the syntax of require there
are potentially some compatibility
issues with this syntax of module first
of all I should point out that this is
an opt-in new language so so j/s next is
going to be something that's not going
to just get turned on by default in the
browser it's going to be something that
you have to choose via a new script type
so we are allowing some level of
backwards and compatibility to try to
fix things that that you know that we
really want to fix that people really
want fixed but we'd also like to keep
the migration costs low so we don't want
too many you know really unnecessary
gratuitous incompatibilities so we'll
look at possible ways of finessing the
module keyword to make it a little bit
less incompatible but the require
keyword there's there's no problem I did
can you talk about how the require
system plays with with packaging systems
that people are using today where you
may have many modules in a single file
it's a good question I think I think to
some degree what we're trying to do is
not solve the packaging system problem
and let people continue to create their
own packaging systems as far as oh did
you mean like like like bundles like
that or maybe in a jar file or a zip
file or something like that so as if
it's in source form you can have many
modules either required by one rapper
module or even just nested inside of it
but if it's in some other form like zip
or jar or something like that I don't
have any plans for anything built in but
module letters do let you write your own
custom loading semantics so that was one
of those like circling the sandbox there
were all these different knobs that you
could customize one of them is the
loading semantics you can write your own
code that maybe uses some of the new
binary data and IO facilities to read
whatever source format you
recognized so that's why I say we're
sort of leaving that to continue to be
explored by the community rather than
trying to solve it here and now but it
is a very very extensible system so
hopefully people should be able to write
their own loaders for that some of that
is already possible with jar your eyes
using the bank syntax okay loan member
so you could try to factor it out of any
languages module system and into the URI
and the browser's URI handling but yeah
there's still some pieces we need to
work out of the the exact behavior of
the of the standard web module loader
and maybe some of that stuff we can
actually just have work out of the box
and we definitely welcome feedback hi
just wondering if you could expand a
little bit more on you know commonjs and
AMD in a month the migration strategy
because the module loader a.p I looked a
lot like the AMD one and and also we
have plugins on AMD to allow people to
do that either server side or client
side you know cross-compilation as well
there's CoffeeScript plugins as well so
20 have had any other comments about the
migration strategy itself you guys
thought about that yeah I mean I think I
can only speak broadly because I have a
lot more to learn and we have a lot more
conversations left to be had but I do
see a place for tools for migration
tools in this I think so much of the
semantics of what we're doing and the
semantics of modules of comm jas modules
and Andy are very compatible with each
other that hopefully people should be
able to continue writing with the tools
that they have today and we should be
able to build migration tools to help
them move to that tomorrow oh and I
think Wes garland has actually even
started working on some of those tools
but as I say there's more there's more
conversations left to have
I don't know where we are on time but
yeah I think we're just at out of time
so yeah I'm happy to talk more offline
thank you thank you very much happy
trails to you until we meet again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>