<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Felipe Ribeiro: JavaScript @ Spotify - JSConf Iceland 2016 | Coder Coacher - Coaching Coders</title><meta content="Felipe Ribeiro: JavaScript @ Spotify - JSConf Iceland 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Felipe Ribeiro: JavaScript @ Spotify - JSConf Iceland 2016</b></h2><h5 class="post__date">2016-09-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9UsnX5X_DF0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi I'm Felipe I'm a lead developer at
Spotify I'm based in Stockholm Sweden
and I work in the team responsible for
the infrastructure of our desktop
application and today I'm going to talk
about how we've been using javascript in
our client and I'll be sharing some of
our architectural details and a bit of
the of the stories of the thing that we
tried and worked for us things that we
tried and didn't work for us
and what we learned from them so I've
been chatting with some people here at
the conference and I realize a lot of
people don't know that Spotify for
desktop is based on that technologies
but it is and right now we do have a lot
of native code but the whole UI is
web-based so the the goal of this talks
to present the story of how I got there
and everything we learn in this process
but before getting into where we are
today I'd like to go back to the
beginning of the Spotify history and
describe the journey until now like the
devolution of the dis oft where how it
started and how it is right now so it
all started like 10 years ago this is
the first sketch of the idea in 2006 two
guys in Sweden had this idea that we
needed to change the music market
because piracy was taking over we needed
something that would allow people to
consume music that would be just
convenient that they could use all the
music they could listen to all the music
in the world and there to just look like
they were using their own library and it
should be an alternative to piracy it
should be convenient safe to use and
free and fair to the artists so they get
paid by by their music and however that
idea came in 2006 but what if I was just
really released to user 2008 and the
reason for that was not just the
technological challenges but mostly the
business challenges around that because
what was disrupt in a market and it's a
really traditional and big market where
they have really conservative ideas of
how things should work so it was a long
journey of negotiations and contracts
with record labels and trying to get the
idea that this model should work and
then this was 2008 more or less and
around 2011 but if I had already grew a
lot it it was mostly in Europe had just
opened in the US and then there was a
need both from Spotify and from other
developers to build the community so
Spotify really is a platform where
third-party developers could write their
apps and run them inside fortify so you
could have things such as last.fm for
example you could use their
recommendations inside this part if a
client I think like that this platform
is no longer available but it is very
important to the story I'm gonna wanna
tell today we change the approach to
have third-party developers that for
another model that works better for them
and for us that's exposing SDKs that
they can use in their absence of having
their code running sorry all right and
in order to make that that platform work
and has something that other developers
could work with we started having web
build inside the client and for that we
use Seth Seth stands for chromium
embedded framework and it's not a
spoiler as electron or node WebKit but
it's older than Windows and what it does
is basically the same but it requires a
bit more of C++ code to integrate and
then it allows us to embed some web
build inside the client and it is an
open source project that is used mostly
by Spotify but also for steam they gave
me a platform and there's some projects
made by Adobe and of course some smaller
projects as well so at the time we had
this describe that was mostly C++ but we
had this web bills that were just a
regular web pages and in those web pages
everything was sent both so from the
developer perspective they day on the
whole document
don was belong to to their app they had
the global scope for JavaScript and they
could use a JavaScript API to talk to
this modify functionality such as
playback control or fetching the user
playlist anything like that there was an
API that they could use for that and
then we started dogfooding this platform
internally and changing over our
internal reveals in the client to use
this apps platform and that's how I'm
gonna call those deals from now on their
apps so for example they are this video
in the clients now in a have just like a
third-party app that is what HTML
Javascript and CSS and use the same API
two years later 2011 2013 it's what if I
went to it for its first big UI change
Spotify went black it was great and
black and then replacing all the C++ UI
components was painful mostly because we
use some custom C++ libraries built
in-house and that's usually not fun and
also at this time the first laptops with
high DPI screens or the retina screens
as they're called starting popping up in
the market and you could start seeing
differences when you open the client in
a retina screen that there were bills
had support for that out of the box but
our our C++ UI components didn't so it
could see some blurry text 2012 C++ view
and a really nice that rendered tax it
was a web view so it was a bit
complicated and what we kept this this
hybrid approach at this time and then
one year later there was another
iteration of the client well we still
had a very similar UI but we had a
really big difference in terms of of the
stack we went full web so all the UI
code that was before in C++ was removed
and replaced by by HTML and JavaScript
and things that were done as regular C++
method calls became api's exposed to the
JavaScript layer that could be called
from there so now we have this client
that's fully fully web-based
and for us developers there was a big
advantage of that because it's of course
much faster and easier to develop on it
and we gained some things for free by by
using this deck such as the the retina
support as I said before but also it's
better for accessibility because you can
integrate better screen readers for
users with visual impairment and other
accessibility issues but then to get
them into a big dilemma that I think
most developers in this room and outside
this room have been through so you have
this big codebase that works and it
attends your needs but it's really hard
to work with should we actually rewrite
that code it's usually an anti-pattern
you were replacing something that work
works and in risks too it can introduce
new bugs and all of that and then also
in this case we had gonna replace this
new this big chunk of code but there is
no really any visible visual any visible
gain for the users at least short term
so it's kind of questionable if it's
actually worth it and then like the old
code we had the C++ code that had been
around for several years it said has
been tested a lot we knew that it worked
well if we just replace it before a new
code base could be introducing a lot of
new bugs and it was of course the
opportunity cost so it will be right not
cold and then you were missing the
opportunity to build new new features
and you can also block the development
of new features because we're rewriting
a toad code so there are several
arguments not to rewrite code that works
so and when when you discuss in the team
about rewrites
those discussions can be really
emotionally charged because people got
can get attached to their the code they
wrote and some people can also have a
can kind of hate
code that they didn't work because they
don't understand because writing code is
easy but reading code is hard and then
sometimes when you got someone else's
code you can just throw it away and
build it yourself but you have to be
pragmatic when I think about these
things and then we try to apply a bit of
Janene thinking on that and I when I say
engineer thinking I mean that engineers
should analyze trade-offs they should
look for optimizations and it should
look for improving the efficiency of the
product and processes they're working on
so how how could it do that in a way
that we would be pragmatic about the
trade-offs and try to optimize the cost
and benefits gonna take all of it so we
thought that we would be if you take
this path and rewrite this C++ code in
JavaScript we will be adding value by
allowing us to iterate faster in the
future and experiment with things in the
UI that because you have a much more
easier code to work with and then as a
as a data driven company it's really
important for us to do a/b testing and
then it's nice if you have a code base
that allows you to do that easily
because you can iterate much faster and
on the downside you had a really high
implementation cost because I have to
rewrite this whole code base but we we
thought that it pay off over time
because the maintenance cost will be
much slower much much lower so we went
ahead and thought that yeah let's do
this and what I'm going to talk about is
a bit of the architecture how we
structured our our layers and our
architecture in order to achieve this
this go so I'm gonna describe it
architecture but I'm not starting from
the lowest layer so under everything
there is what we call the client core
and clients core is a hybrid that's
habit Spotify that's the c++ library
lets shared among all the main platforms
so it's the same code base for Android
iOS and that's top and what this library
does is basically them the lower level
things like it's just much before the
streaming the code in playback audio
drivers talk to the back and offline
syncing and all those things that are
common between those platforms in a more
integrated in a lower level and above
that so and then also like this client
core is as it's used by several
platforms the ownership is also shared
by those teams so the infrastructure
teams of those those platforms work
together in this library
above that had the client desktop layer
what that what that is is basically the
integration with operating systems with
Windows and Mac and Linux limited Linux
is kind of not officially supported and
what it does also is to glue together
the core and expose things to the web
layer that's safe there is above it so
that's what the client desktop does and
if you were yesterday in that really
nice talk about electron she talked
about two processes the main process and
the rendering process here is pretty
much the same the two layers the bottom
are the main process so we don't have
any JavaScript running the main process
but the render process are the rest
so we have like the chromium embedded
framework that basically just renders
the our web views and the client desktop
exposed some API through chromium added
framework so we can talk to the core and
then we have two two layers of
JavaScript where JS container is more
like a logic layer where we manage like
navigation and playback state and things
like that for more the container of the
UI of the of the of the UI and the
little boxes in the top are the actual
videos the actual what we call the apps
that are owned by different teams so for
example have the Browse view or the the
search playlist the artists they're all
like their own little boxes that belong
to different teams so if you want a more
visual understand that of these
JavaScript layers more or less like this
our visualize and then we kept the same
architecture for the apps as we did for
the third-party developers a few years
back
and so the container is the main Chrome
and the application it manages out that
the apps inside it and that's our
sandbox as I said before so they they
only document they own the global scope
and the way to do that was to use
iframes
and then some people might be a bit
surprised like come on it's 2016 you're
still using iframes and of course it's
not idea what life is a trade-off
right and then here's iframes was a
really pragmatic decision at the time
because iframes are relative abstraction
for sandboxing on the web so we could
guarantee for some level of guarantee
that things are running there before
their own environment that really leak
things to other to other things and it's
not our negative because imagine that it
Spotify is not really like most web
applications that people run on the
browser and they close once in a while
or like after a few hours or something
something that people can leave the
client open in the background for weeks
and then newer leaks can be a big a big
thing there in the client side and with
iframes
we can even though the iframe itself has
a higher memory footprint we can just
kill iframes and then release that
memory much much more easier so the the
feature developer got to work inside
that iframe they don't need to care too
much about that the video that they
should care but not too much because the
container can kind of manage okay this
iframe has been idle yes let's just kill
it to release the memory anything like
that
and keeping iframes when we did this
rewrite reduce the risk of the rewrite
because the rewrites didn't affect the
apps themselves so it like the people
who are working in the artist view
weren't affect at all by the process
that we meant by replacing
infrastructure because they still kept
their sandbox environment so it's
something that we used to reduce reduce
risk and it's migration period and you
can iterate on it afterwards so based on
what I said so far of the having these
two layers of JavaScript a lot of custom
custom libraries and tools how do we
actually organize our code and then this
is something that we did and seems
really standard so we had the autos app
so had one repository per app
plane his browser I think their own
repository had one repository per
library so we had some libraries
internally
such as our UI library that has CSS and
how buttons look
I can templates and things like that
have another library that does the
Parsee no Spotify internal you are
either things like that and we had we
had an instance of an internal in game
registry to distribute this libraries so
it seems pretty standard but no didn't
work for us
which is also can be surprising for some
people and why didn't it work it's like
everything had their their little things
they're organized
everything seems really encapsulated but
why didn't it work it was really hard to
coordinate horizontal changes and when I
mean horizontal changes like a change
that affects affect many views so
suppose you were working in the generic
UI library for Spotify and then you want
to change the shade of green
that that's a display or the behavior of
the play button that is everywhere in
the client so you had to make the change
in a library and make sure all the apps
have new builds that fetch on your
change and so it involved a lot of
communication and syncing between teams
and especially stressful before releases
it's a bit hard to coordinate and that
could also cause some cascade effect on
library updates so imagine you are
changing a really basic library that
there is another library depends on it
and another library and an app that
depends on it to make sure that all the
versions were bumped and dependencies
are not I think they're active so the
the communication overhead was really
really high with this model it also
complicated continuous integration
that's the billeting standardization it
complicated continues integration
because the builds need the bit
pipelines needs to be changed somehow
so we wanted to make sure that if I
change something and after it builds I
want to also build the things that
depend on it because I have to keep
consistency my product even though some
semver is is a good idea it might might
have something that we need to to force
glaber's to be updated so we need to
trigger new builds of things that depend
on my library so we if you actually need
it to work I will need to create a
really complex graph of dependencies in
the bill wipe lines
it's not something that you wanna do
and for Standardization it's also hard
because evacuating silos so different
teams will build things in different
ways and use different tools and that's
a bit it goes a bit with autonomy that
autonomy is usually good but you need
some alignment and then it these
architecture it makes a language more
difficult so little how it looked like
so suppose like you have like the
playlist step the radio app they depend
on the same libraries but they depend on
separate versions because they are in
repositories their separate modules so
you have those things and then average
every every app had their own build
pipeline so when you build you generate
the artifacts and you could for example
have playlists with a different style
for the tracklist then in radio for
example or a different sheet of green in
the same release and that's not
something we want to have so we started
investigating into it how could we avoid
this kind of problem so we checked out
how other other companies were have been
doing how to merge repositories and
things like that so how could you
mitigate those problems so basically
what I did is we jumped into the mono
repo we had a most of our repositories
in a single one and it automatically
addressed a lot of the issues that we
had before it simplified a lot the
continuous integration because we just
have one build pipeline you change the
repository you build everything and it's
fine it's always like it always works as
it should be and it's easier to test the
impact of your changes so if you're
making changes in the library you can
just grab and see what it's been used
and just fix it there and because of
that you don't need to care about
backwards compatibility which makes the
code much simpler
you don't need to keep old code there
just make a change change whatever it's
being used it's fine and you can do that
in an atomic way so it can make a change
in a library and the code that depends
on it in a thing
commit which makes it much easier to to
go back and forth and roll back and
everything so it is much easier for
refactoring the code and it promotes
some consistency in its narration across
the board because the articles in a
single place
so now we had like this single posit Ori
the single build pipeline and we could
have consistency that dependencies
because they're all searching the same
dependencies so yeah now things are much
simpler than before I'll have the other
code in the same place they are
affecting the same dependencies but
there is still a lot of entropy and the
reason for that is we had many teams
working in this layer of repositories
they're kind of siloed in their own
world so in order to escape our
development and our teams we gave them
an autonomy to to pick their tools to
pick their technologies and then we
start putting things together with so
many things are different so some teams
used to write unit testing framework a
the another teams framework B and we're
cite like putting everything together in
the same field pipeline come on we need
to we need to fix this we need to find a
way to standardize our practices so we
came up with the idea of the Golden Path
and the Golden Path what it is is a set
of recommendation recommended practices
tools and libraries that are fully
supporting it that recommended things
that people should use it doesn't mean
that they are forced to use but if they
do they get all the support from the
infrastructure team all the tooling they
just they can just focus on building
their feature did not need to focus on
spending time in tooling tooling is
there just use it and build your feature
of course you can still go crazy and
doing other things but it's not
something that would really like so the
way we came up the way we started
working in a Golden Path I was to put
together put together a standardization
work group and the way we did this we
got like one representative from each
team and the this world would get
together and analyze different things
that
so let's check all the testing libraries
that we are using so to make we're using
for example look at the unit testing
like and some some apps are you can
expect some I apply using assert some
apps are using whatever and then so how
can we turn it back on something so you
can go into our test and understand how
they work and things like that so this
what this workgroup goal was to actually
do this kind of analysis and come up
with solutions and proposals for that
and when I started analyzing and
building this golden path documentation
we start seeing some de facto standards
that were easy to standardize on because
that's what most people are already
using so we just went ahead okay 80% of
our code base already does it this way
so let's just do it for the rest and so
if that would be taking the path of
least resistance and so it would be
easier to to make every one line in the
same thing and we try to make those
decisions based on actual data so we
don't really want to go for wishful
thinking we actually want so much more
experimentation around some some
technique or some - and then see okay
that works for that team maybe we should
actually adopt in other teams as well so
there were some lessons we learned in
this process so I'm going to just recap
I think that III said before and think
that we learn when we go to this stage
that's that stage where right now you're
aligning teams in in same practices so
we can move forward they maybe rethink
the iframes thing because once the code
is more standard it's easier to remove
those kind of sandboxing at the inner
gates so what the first thing that that
is very important is to what in your
projects always always try to evolve
things incrementally and what that means
is that don't try to solve all the
problems at once try to fail fast and
validate your hypothesis and don't ya
try to release as fast as possible so
you can see that the impact that they
were creating and also like many
companies have done an infra ting
marketing my work
and in some companies in for teams are
usually kind of dictators that okay we
built this thing everyone should use it
this way and for us having more empathy
as we saw yesterday and more connections
with the other developers make things
work much better have a much better
relationship with feature teams and we
can get things with much higher quality
so having an infra team let's pour in
touch with other developers and
listening to them and having other
developers participating and the
decisions have really improved us I
proved the our flow to get things
working and when we merge repositories
we noticed that the way we structure our
repositories shouldn't dictate your your
architecture so that's why for us
merging them was a good idea because it
gave us a lot of flexibility on how we
want things to change in the future
and last but not least like consistency
is really important in a codebase
specially in a big project it's more
important to have one single way of
doing things then and then doing like
the coolest thing ever
because when you have a consistent way
of doing things people are more
productive people can understand better
the code you can navigate through the
code and see okay this is how you do it
and there's how it's been done but if
you're just focusing on trying like this
new thing and make it the coolest
possible and then everything is
different different parts of the code
base it really makes it hard for people
to understand their code and to first if
I know got a new hire in a company's
growing you need to have oh okay this is
how you do things and then this person
is gonna be able to spin much faster
than you have like such a heterogeneous
code base and yeah I couldn't miss the
opportunity with so many good people
here say that we are high so with me to
a lot of challenges have a lot of
challenges ahead so I recommend this
take a look at our jobs page and the the
job ads there are usually a pretty vague
and open but if you need more detail you
can just grab me and I can can give you
more more details and that's it for me
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>