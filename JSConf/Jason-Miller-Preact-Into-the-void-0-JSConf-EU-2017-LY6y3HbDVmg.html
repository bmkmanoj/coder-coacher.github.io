<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Jason Miller: Preact: Into the void 0 | JSConf EU 2017 | Coder Coacher - Coaching Coders</title><meta content="Jason Miller: Preact: Into the void 0 | JSConf EU 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Jason Miller: Preact: Into the void 0 | JSConf EU 2017</b></h2><h5 class="post__date">2017-05-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LY6y3HbDVmg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right
hi everybody I'm Jason as was advertised
before when the slides come up hey there
okay cool yeah I'm Jason develop it on
Twitter underscore develop it on Twitter
develop it on github I'm a cereal
library author as some of you may know
that's self-diagnosed i like donuts and
poutine and axes which means that I am
Canadian I also like constraints I've
been developing for the mobile web since
before the mobile web was something that
anyone would willfully use which is
around the time of Windows Mobile five
I've written a bunch of UI frameworks
it's actually a serious problem I'll
developed that I'm trying to work around
and the reason why is because I find
constraints to be interesting challenges
I have something called ADHD you are
probably familiar with that basically it
means that in order to do something
effectively it's best if I can hyper
focus on it and these interesting
constraint challenges provide me a
situation where that's true so I wrote
pre-act
this presentations help react into the
void zero and that's just cuz I thought
that was clever and that's the only
semicolon I think you'll see in these
slides when I did do that for
Christopher okay so you might wondering
what is pre act this is pre act in its
entirety I did remove the source snap
comment and today we're going to touch
on that and that mostly the second one
we can't even talk about them until we
talk about this stuff that's up here and
then this is a pre a presentation so
naturally we need something in purple so
whatever that is is going to be the last
thing we touch on but before we can get
to any of this we need to talk about JSX
if you're not familiar with JSX I don't
know what rock you've been living under
but secondly don't worry it's really
really easy to understand JSX is simple
at its core by the end of my talk you're
going to be already starting to rewrite
your entire web pack configuration in
JSX which makes it longer and more
complex and that's a good thing
so if you don't believe me go and look
at the web pack two dots that is in them
and I have some part in that so what is
JSX JSX is an XML like expression that
is compiled to a function call we write
the thing that you see on the left we
write these HTML looking angle bracket
you know syntaxes and on the right is
what we get out of the transpiler like
babble or Buble or whoever you know just
10 transpilers now and the whole point
of JSX or at least the whole point to me
is that I would be totally happy writing
the thing on the right and this is
verified by the fact that I'm constantly
tweeted at by people who much prefer the
thing on the right I think that's
telling I like JSX because I like the
parity with the Dom but the thing on the
right is if something people are
perfectly happy to write so it's
important that this is kind of a
transparent thing sitting in front of an
understandable thing so there is one
little complexity on top of this from
JSX and it's the fact you can get back
into JavaScript from these angle
brackets and taxes so you can see in the
thing on the left one and the variable
world are both persisted into the code
generated on the right and then the
other complexity is just if you use a
capital letter as the first letter of a
tag name it's a variable reference in
the resulting generated code so the
essence of JSX is this factory function
we saw it's really simple it just has a
signature that accepts the things that
you typed into your text editor so you
have node name you might see just refer
to this tag name they're the same thing
which can be a string or a function
really could be anything that's going to
be one of these two you have attributes
which is optional could be an object and
then the rest of the arguments are
children and this is how we do
composition you might be thinking to
yourself aren't you just writing hyper
script right isn't that really what this
is under the hood and you wouldn't be
wrong a hyper script is very similar in
some cases it is the same it is a slight
superset of JSX
because of
this this so hyper script supports this
additional tag syntax where you can use
essentially CSS selectors to predefined
attributes on the element and JSX does
not have that
so what JSX does have is the ability to
use these these sort of extended tag
names so it's important that we have a
solid understanding of JSX
because the concept is simple and direct
but it's the interface through which we
access all these virtual Dom libraries
also please remember that JSX is not Dom
JSX is not even related to Dom it's just
a syntax it doesn't know anything about
your code or how its intended to work
you can use this to write your web pack
configuration please don't you could use
this to write xml so if you want to
write a sope client and you don't want
to deal with parsing and serialization
you could use JSX for that and i would
actually recommend that as an
interesting solution to a problem so
that's JSX out of the way next stop on
our adventure is going to be virtual Dom
virtual Dom is just objects that
represent a Dom tree structure that's it
there's nothing else going on I like to
think of it as configuration you are
passing to a theoretical Dom builder of
some kind and we're actually going to
walk through making that Dom builder not
so theoretical in a second but the first
thing we need to understand is how do we
get from JSX to V DOM and the way that
we do that is by invoking that h
function that we just defined the
arguments for it's fairly
straightforward we know that we wrote
our JSX we got our H function calls what
we need to do is have an H defined such
that it produces these objects this is
virtual Dom sometimes it gets trumped up
a little bit beyond this but at its
essence this is what virtual Dom looks
like it's just nested objects this is
surprisingly easy to do this is how you
do it it is a one line function you can
do some more stuff here if you want you
could normalize children you could
remove empty values you know coalesce
adjacent string nodes lots of stuff but
at its core you could totally write a
virtual Dom renderer using
is function so let's do that let's write
a virtual Dom renderer the first thing
we're going to pass ourselves a V node
this is that object that we saw before
up on the right there with a scrollbar
so the first thing is we need to create
a Dom element that matches the type of
the video element we passed ourselves so
we can do that using Create element
pretty straightforward then we're going
to loop over the attributes in this case
there's just one ID equals foo and set
them as attributes on the Dom element
and then we got to set up recursion so
we're going to loop over children pass
them back to render and then take the
resulting Dom element and appended to
our current Dom element there's one
slight complexity here that you may have
noticed one of the children is a string
you know one of these things is not like
the other so we need to deal with that
hello text and the way we do that is in
render if the V node is actually a
string we just bail out with a text node
so that's that's our virtual Dom
renderer there's one slight complexity
here in attributes you notice I've
called them attributes and if any of you
have used Reax you're probably getting a
little hot under the collar about that
that's okay
they're not attribute don't ever let
anyone tell you that except me I don't
know why I've chosen that I can get away
with it but you know for the duration of
this talk I can so they're actually
props and there's a reason why we don't
use the name properties for that either
they're kind of an abstraction between
these two things
so most HTML elements can accept data as
attributes and they can also accept
similar often typed data as properties
for something called Dom property
reflection but both of these are
technically wrong because there are
things we can do with attributes that we
can't do with properties and there are
things we can do with properties that we
can't do with attributes so what we need
is a way to have both and thinking about
pre acts sitting at three kilobytes you
can't use whitelists in pre active Useem
libraries that define like yours you
know self closing tag names or whatever
that's not a thing that that pre-act
could ever do there's not enough room so
what we do instead is we have a
reference to a Dom node and we actually
ask the Dom node do you have support for
a property
and if it does we use the property if it
doesn't we fall back to setting the
attribute this actually works really
well for things like custom elements
because custom elements tend to define
getter setter pairs for properties so we
just kind of use those and move forward
so the question that you may be asking
yourself is does it work sorry I'm
really bad Sean Connery impression I
promised somebody I wouldn't do that and
then I had to do it in order to break
that promise so here's the virtual Dom
that we wrote we're going to pass it
through the render function that we
wrote which gives us back a Dom node and
we're just going to check that I did
document dot body on the right here
tethered through my phone it worked
yay is the output in jsfiddle so it
works deploy to production just be
thankful you don't work with me so we
just built a simple virtual Dom renderer
it is a terrible virtual Dom renderer
and I'm sure you were probably all aware
of that as we were writing it you know
it's a version zero but it's terrible
because it doesn't get it doesn't look
at the current state of the DOM and
update the Dom to reflect anything it
just blows away to hold on and replaces
it with something diff algorithms in
virtual Dom are kind of a subject of a
little bit of debate and mystery the
debate is warranted because there are
you know trade-offs here that you can't
treat as black and white things but the
mystery is unwarranted and I'd like to
attempt to demystify that for you guys
today so dissing is basically this idea
of instead of rendering top-down and
creating it anew as we render top-down
we're going to pass ourselves a
reference to what the Dom looks like now
and then mutate it to look like what
this JSX
derives Dom looks like our virtual Dom
just apply the differences so on the
left you can see what virtual Dom looks
like this is the object we've been
staring at for 15 minutes now on the
right you can see what the actual Dom
looks like and you can see that the
names are the same or similar there is
actually a Dom children property it just
doesn't include text nodes so we don't
use that but you can see how you could
probably run through this and perform a
comparison left to right and apply to
changes on the right so it's basically a
three step process to run through the
diff first step is pipe before we can do
anything we need to create an element
with the correct node name so I mean
this is pretty straightforward but
that's kind of step one here the second
step is we're going to loop over the
children perform a bi-directional
comparison and figure out whether we
need to add remove children rearrange
them etc and then the last step is just
update the attributes / props with with
the new values from our virtual Dom tree
so when we set up recursion by looping
over the children so let's start off
with type we enter into our diff and the
first thing we need to figure out is is
this node owned by a component if it's
not owned by a component things are
really easy we just look at the node
type in this case node name if it's the
same we're just going to update it in
place and be done with it looks a lot
like the virtual Dom renderer we just
wrote and then scrapped if it's
different we're going to throw out the
node and create a new one and then
continue dipping down the tree setting
attributes and children and so on if the
node was owned by a component as things
are a little bit more complex basically
we just need to create a backing
instance created if it doesn't exist
updated if it does exist at its props
but then things get really easy we call
render on that backing instance which
returns a new virtual Dom tree which we
just passed back into the same
dysfunction so I don't think this is
actually even that complex there's some
intricacies here with life cycle but as
far as it you know further a chart on a
slide goes it's pretty simple so
children is even easier than that it's
basically three steps the first step is
we loop over all the existing children
in the DOM and put them in divisions
there's a nun keyed list which is
ordered there's a keyed list which is
named second step is we move over the
new virtual children which are just the
lightweight objects and or strings and
we find the first match in our list of
unkeyed or our map of keyed and we we
find that or null we have either an
element or nothing indicating we're
going to need to create it anew and then
we dip that against our virtual Dom
child object at the end we're going to
have an
that matches this sort of specification
object we've we've got for it and we
just insert that at the current index
that we're at in the virtual loop and
then the last step is the easiest if
there's any kid left we just delete them
because they're obviously not used in
the in the updated definition of what
the dog should look like you might be
wondering about the keyed versus
unhealed list this is probably the worst
understood part of virtual Dom so I
really wanted to touch on it today I
tried to explain this on Stack Overflow
and it's like the only thing I've ever
done on Stack Overflow and I kind of
butchered it so let's get it done within
slides so keys are an act review
meaningful order to virtual Dom elements
when they have uniform type so we can
see in this example we have three list
items one two and three in the second
render here we only have to list items
and it's clear to you and I as humans
that that we've deleted item to write
the text to is gone so we know logically
it's probably that we deleted the second
item and the third one has just moved up
but a virtual Dom renderer does not know
that there's nothing saying that item
two is item 2 in the second render it
just receives a new tree each time
there's no way to for it to correlate
these things so what it's going to do is
actually going to go look at one one is
unchanged that's easy nothing happens
it's going to look at two and it says oh
no actually they change the text content
of two to three so that's fine so I'll
just update that and then it's going to
get to three and it's gone in the second
render so it's just going to kill that
node and the thing to understand here is
by default for a list of uniform
elements in virtual DOM it will always
push and pop off of the end it has no
concept of removing and adding to the
middle of the of the child list contrast
this with a keyed approach in a keyed
approach we give each element a unique
key they do have to be unique so you can
see in the first render we've got one
two and three and the second render
we've got one and three it's very
obvious that the elements with key to
has been removed now we've told the
virtual Dom render exactly what to do so
it knows when it loops over the list
when it gets to item two the key is
wrong it will delete it and move to
three which will just move up in its
place so it's actually makes things
really really simple for the renderer it
is kind of cheating you're essentially
telling the diff how to do its own job
but in the case where you'd like to
control the diff it's nice to have this
escape hatch it's the last step for this
diff process now that we've got our
children in our type gift is attributes
this is really easy we give ourselves
the old properties and the new
properties we move over the old ones
find the ones that are not in the new
property bag and then set them to
undefined the DOM and then we do the
exact opposite for each new attribute we
check if it differs from the old value
so this would include if the attribute
is now defined and it was previously
undefined it's going from undefined to
some value and then we set its value in
the Dom to the corresponding property so
we solve all of life's problems
and now our app is as fast as it could
possibly be except this is completely
not the case all we've done is we've
moved our problems into a library we
move their problems into pre act or
react or inferno or by Dom or the list
goes on but so I want to tell you guys a
little bit about the performance journey
I've been on in writing pre act and
trying to benchmark it and take it
further than it than it currently is
this is something that you will often
see people say especially if you hang
out on Twitter for various reasons so we
often hear complaints the DOM is slow
right the Dom is the source of slowness
and it's true that the Dom is not as
fast as an immediate mode drawing API
it's not designed to be there are
different things but the Dom has all
these advantages that if we compare
compared with an immediate mode drawing
API we're kind of not really taking into
account the first one is the dumb offers
accessibility essentially built in you
can annotate the Dom with titles and
Aria attributes and you're going to get
screen reader support for basically free
other platforms have ways of doing this
but the Dom's way of doing this is
incredibly easy you almost don't even
need to understand how it works it's
your writing semantic markup the Dom is
also extensible people like to forget
this but if I'm using Twitter on Windows
and I want to add emoji support to
Twitter I install a browser extension
that hooks into every text input on
Twitter and I can now type emoji into
the text
without using Twitter's input fields
Twitter doesn't know about this they
don't have to know about this they don't
care about this that is one of the
values of the Dom is it's this substrate
that underpins all of our applications
that is extensible without our knowledge
and that's the same kind of thing with
saying the DOM is framework agnostic you
can write two widgets in two different
frameworks and as long as they are
rendering elements you can depend those
elements to a common parent and they
don't have to know or care about each
other so pre-act
at its core is essentially a Dom
renderer it's a virtual Dom renderer but
it's just sort of a Dom library right
this is the next step after after the
whole sequence of libraries carrying on
from jQuery so I'm going to share a
couple lessons that I've learned while
writing a Dom library the first is use
text nodes for text this sounds stupid
I'm aware of that
but it's surprising how often you will
see this either misconstrued or
misinterpreted so the Dom has an API for
working with text that we often ignore
it's create text node like we saw before
you concede an initial value you can
insert these you can move them around
with like any other elements they're
just they don't inherit from element
they inherit from node and then you can
set it to text so I've got created
inserted flip it and reverse it I think
that's a Missy Elliott joke but I would
don't remember I actually had to Google
Larry cut to make sure I was on point so
this is a benchmark showing that that is
the case we've got text content and then
text that node value just for an atomic
update no value is clearly faster here
if you were writing a library or a
framework that does text updates you
would be crazy to choose the first one I
will say text content does a lot more
work it's not unjustified in its
slowness it's removing elements that
don't belong there it's collapsing
strings into into a single text note it
does a lot of work but in a lot of cases
we're using text content in a situation
where we don't need any of that work so
the next dom lesson
I think that's an Aerosmith joke I don't
know the next time lesson is avoid
getters just entirely don't use them
don't rely on them or when you are using
them be incredibly cognizant of the fact
that you are and if you're confused
about what this means here is
a snippet from chrome dev tools showing
if we look at the node type property of
a text node write text nodes that no
type should be the integer 3 which is
the corresponding type it's actually
undefined on the text prototype which is
a little bit counterintuitive it's
defined on the node prototype which is
what text inherits from and if it get ur
and this is a huge red flag that I have
highlighted as a red flag
the idea is everything that's going to
have this inheritance from nodes it just
implemented in one place I'm sure
there's some better reason for this but
this is a red flag for anybody who's
writing a dom library so this means that
when we write code that relies on node
type by default this is not going to run
as fast as it could instead we can use
duck typing to improve the performance
of this so text nodes happen to have
this this function called split text
split text is much faster because it's
not a getter all we're doing is checking
if a property exists and I know Benedict
would tell you this if I didn't you can
also check to see explicitly the
property exists the problem with the
second check is actually that it's going
to check if it both is existing and
trophy which is to operations where the
second one we don't care about so here's
a performance test showing that that's
true you can see here we've got instance
of and a couple of different variants
there instance of it's not great because
if you have a text node from a different
document it's a different parent class
so it's kind of useless the getters are
all relatively slow but those property
accesses are surprisingly fast so this
is help reactive text text nodes
the last one is live node lists please
try not to use these they were they were
good intentions thing but they they end
up hurting performance so here's an
example of trying to clear children out
of a parent element first one you've
probably seen this before you just do a
backwards loop over what appears to be
an array you do a backwards loop because
the indexes are going to be all screwy
if you loop forwards because it is a
live node list they change as you mutate
but we're removing the children as we go
through the list eventually were going
to get back to none and then we're good
second one is much faster though because
we're just accessing one property at
each point in the loop we never have to
go back and ask for chow
again and recompute child knows we'd
never have to access an offset in
essentially an array we're just using
references so here's a performance
benchmark one thing to remember this
benchmark is a lot of this is actually
set up overhead as actually create the
elements before I can delete them and
benchmark that delete but in either case
last child is always faster so talking a
little bit about measurement I've been
doing a fourth optimization for quite a
while and back in the day benchmarks
were like you know run a loop five
million times check the date before and
after and cross your fingers and we
still surprisingly often the way that
stuff works but chrome dev tools has
kind of advanced this and it's made
things really visual so dev tools is
like having a little tiny copy of Sam
ciccone in your browser and you can ask
him on demand to run performance tests
it's all so far in a way the best tab in
chrome dev tools to use in a slide so
one metric I rely on a lot is what you
can see here it's the total time taken
to render a tree of components and the
value here is you can see it visually I
can see that it is 3.81 milliseconds to
re-render this DV Mon I think it is
benchmark but I can also see that it's
consistently around that same value and
those values being able to visualize
that and track it over time the next
tool is IR Hydra by mr. Eila I believe
he has a v8 engineer and this actually
touches on what Lynne was talking about
in her talk with D ops and optimizing
compilers so I get to thankfully skip
over this slide and not go over time
which is great but really this is going
to show you visually when your code is
going to do and it does this using the
type feedback from your code having run
you run this with flags and if you want
to know the flags and figure out how to
run chrome with these flags because the
tracing output go to that gate I owe you
RL that only works on OS on Mac OS for
now I don't know how to wear some
Windows yet and then the last tool is
when I wrote this is unsurprisingly the
first app that was built with pre-act
and like September of 2015 and hasn't
been updated since then so I'm sorry
there's like a whole bunch at UX laws
but the goal with es bench is
essentially to give you a very
user interface on top of Babel and
benchmark is so it runs your code
through Babel and then it passes it over
to benchmark Jes and you can do
comparisons of various different
implementations of a given function and
literally just figure out which of these
runs fastest and if you do it in a bunch
of different browsers or you could check
it as new chrome releases come out you
can see that
turbofans started in lining push so now
all of a sudden the benchmarks have
inverted which is useful it's useful to
know that way we're not doing
performance optimizations and then a
year down the line accidentally
suffering because of them so a couple
lessons from these things the first is
be explicit so I covered this a little
bit earlier don't accidentally cast
something to a boolean if you have no
reason to do that so in this case we're
checking we're checking what looks like
the existence of props on an object but
really what we're doing is we're
checking that it exists and that it
isn't zero an empty string null false
etc the second one is much more explicit
we are literally checking to see if
props is defined reading this as a
programmer it makes a lot more sense and
it also is a lot faster for VA to be
able to run the next lesson is in-line
helpers so functions can be way too
generic and as JavaScript developers
because this is kind of a language that
will let you do anything you want this
is really really common so this is a
hook function that was in pre-act
it does way too much stuff it gets be
opted immediately and the solution here
is to rewrite it to just be an inline
function call and the last one is just
short-circuiting here's a quote by me
that's a quote by me but basically the
idea is if you can avoid making a
function call avoid it there's sometimes
there's just no reason to do certain
things in the case of praefectus would
be like if you're dipping a virtual Dom
tree and a parent element has one
textual child and the Dom also has one
textual child it's actually going to
entirely skip the rest of the disk
update that text child in place and then
bail and it is a huge performance
improvements probably the most
significant performance improvement that
has ever gone into pre-act is that
particular early return so the point of
all this is to say please make decisions
based on actual data find a way to get
data
whether it's a benchmarking tool or a
dev tools or any of these solutions
collect better data through benchmarks
and performance tests and then act on
that by setting better goals and if I
can leave you with a message it's
remember that we all have a shared goal
of making the web faster and more
accessible that's how we provide better
experiences to frustrated users of the
mobile web it's how we're going to make
the mobile web the platform of choice
you know in the next three and a half
years I just picked that number but and
then finally it's how we get the next
billion people online so they can
benefit from the access to the same
resources that we've had opportunities
from so that's my
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>