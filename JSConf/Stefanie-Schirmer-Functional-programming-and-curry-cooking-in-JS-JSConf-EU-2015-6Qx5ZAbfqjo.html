<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Stefanie Schirmer: Functional programming and curry cooking in JS | JSConf EU 2015 | Coder Coacher - Coaching Coders</title><meta content="Stefanie Schirmer: Functional programming and curry cooking in JS | JSConf EU 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Stefanie Schirmer: Functional programming and curry cooking in JS | JSConf EU 2015</b></h2><h5 class="post__date">2015-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6Qx5ZAbfqjo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Hi, everyone, I'm a software engineer at Etsy,
in my master I did a lot of functional programming
in Haskell. I wrote a type checker for a Compiler
for a domain specific language, dynamic programming
problem. That's quite different, Haskell was
also my first programming language, I might
be a bit unconventional. I still find functional
programming amazing and all the power that
it has, and that's why I want to talk about
it today, but the tool we'll be working with
is JavaScript. So together with my friends
I started to think about how to make functional
programming more accessible because it's so
powerful. And for this is great to start with
a language that's familiar so we can focus
just on the concepts. Since new concepts can
be difficult, we will use cooking analogies
to make things more understandable and learn
about curery cooking along the way: It's a
very good example, because very algorithmic
and everybody has to eat. So cooking with
curry frying spices in a pan. But, wait, let's
talk about programming deliciouses programming,
programming is awesome, I love programming,
but also it's sometimes hard. It's hard when
the code is too complex. So, in reality it
looks a bit more like this. We could say each
problem brings it's own complexity, it's our
job as programmers to build a program to solve
it. When we start we're creating some kind
over mental work space. But over time, things
can get messy so we add unnecessary complexity
to the problem, we add things asster Rick
reasons not because there's a problem. That's
not ideal. So let's create work space for
curry recipe, it could look like this. We
need some spices. A base for the source, curry
originally come from the word sauce, and we
need a main ingredient, which could be some
of this. That's a lot of ingredients, wow!
Let's say we pick five spices one base for
the sauce and one main infreed cent for our
recipe, that's already way more combinations
than I can easily oversee, I don't know about
you. So, in functional programming and in
cooking we like to decompose our problems
into smaller sub problems, so that we can
leverage the power of combination of solutions
instead of drowning in combination of problems,
oh my God. (Laughing) so here you can see
I have a function shuffle, which shuffles
an array of stuff. I didn't write it out,
it's too long, but you can imagine, and then
I have this function pick, which picks from
a shuffleeled array. Then I have the function
print item that prints a thing with an asterisk
in front of it. I can pick five spices and
map the print item function over them, which
looks pretty readable. For our composed recipe
function, I would saw it's really human readable.
We pick from each infrequent group and print
the resulting recipe with a bit of words around
it (Ingredient) what did we just do? We used
two really good ideas to keep our work space
clean. First of all, having a good set of
bah sick functions that we can compose and
combine to achieve something more complex.
Also, it should be clear whether the order
of steps is important or not. Fit's not important,
it should be up to us, so we would have them
as independent functions. And then the second
thing was capturing all side effects in our
recipe to avoid sure praises, when I put the
right ingredients into a recipe, I should
always be rewarded with the correct result,
or the same delicious dish. So no secret side
effects? No, if temperature over ingredients
isn't specified it shouldn't affect the result
if I change it. Secret side effects forbidden,
no leaving of the recipe. So every program
in this way, we can often grasp what a function
does by looking at it's input and output,
these all we need to know. Okay, let's really
get started, let's talk about abstraction.
Some famous person in computer science once
said the art of programming is the art of
organizing complexity of mastering multitude
and avoiding it's bastard Chaos. I really
like that quote. And then he also said, we
all know that the only mental tool by means
of which a very finite piece of reasoning
can cover a myriad of cases is called abstraction
isn't that great in code we make decisions
all the time to solve our problems, and they're
combinations of all these decisions, we're
creating a huge space of possible paths through
the program Andorra the state of our work
space. And we're supposed to keep all these
state in our head. And if we forget about
one we create unexpected behavior, ranging
from a small bug to a gapping security hole.
Our only tool for keeping this combinatorial
complexity at bay and without unnecessary
complexity is abstraction. So, how can we
use it? The good news is we already use it.
Functional programming heavily builds on abstractions
we know already, let's go through them real
quick. So the basis of programming is often
so simple that we forget about it, but we
all know it, it's abstracting from a value.
So it would lack like this, by assigning it
to a variable I can give it a name, and I
can use it later by just calling that name,
I don't have to write all the vennelbles there.
And in the functional programming world, I
don't make a big difference between a value
and function when I name them. We can also
assign a function to a variable. We say functions
are first class citizens, you've heard that
before. But, wait, we didn't talk about functions
yet. So, building on this what's the next
more abstract building block of the program,statements
and blocks of statements, to abstract from
a Blog and give it a flame, we would create
a function. And ‑‑ we would create a
name and create a function. It's under valued
as the main means of code organization. It's
at the core of functional programming, that's
why it's called like that, right. We could
say we build toolboxes of functions, assign
them to variables, we pass them to other functions
and we combine them. Wait, I just said we
pass functions to other functions? So functions
that receive other functions as arguments
are called higher order functions. And they
are the next level of abstraction, abstracting
from function abstractions. So, I'm passing
another function into mySort function here.
Sorting my spices and bypassing a function
as an argument I can supply a part of the
behavior. We could say we are configuring
the behavior of the higher order function.
This technique is not possible in our programming
languages, but in JavaScript higher order
functions are more common such as map and
reduce, which we know in arrays, and all these
functions that accept call backs for asynchronous
JavaScript. On the top level of our hierarchy
we have sets of functions, the functions are
the tool in our toolbox, they are really important,
so abstraction gives us levels of detail to
structure our programs, and on each level
we get contained building blocks. We didn't
talk about data yet, but that's okay, bah
we're learning to think in terms of functions
first. Okay. Functions, functions, functions.
Wait, with all these levels of abstraction
don't I just have a tree‑like composition
for our program like in any imperative programming?
How is it different? Don't I have something
like program and then ‑‑ or ammonal yule
and then functions, blocks, statements down
to variable declarations? Yeah, that's right.
And that's why it was possible for me to move
around between functional and imperative work
in my masters thesis. That's why I could take
a program that was expressed in reoccurance,
that means recurrent of function that are
evaluated like in mathematics and I could
Translate it into programs that fill tables
in an efficient way and in a smart order using
loops. Most paradigms focus on very different
areas though. Let's have a look. So, every
time I write a loop statement, I would need
a variable to evaluate whether it's time to
leaf the lap. If we had no state we would
have to juice a recursive function instead.
So, ‑‑ we would have to use a recursive
function instead, we would focus more on functions
than on statements, a function is a complete
literal package that captures a behavior.
We can always swap it out with another one
to get a different behavior. A lot of magic
is the stuff we can do with functions and
combine them and leverage their power. With
special higher order functions, that's why
I made the higher order functions big. Okay,
let's be honest, isn't this slow? I would
say, once you're in a loop or performance
which you always should considering this we're
optimizing for some other time than computation
time, we're optimizing for developer time.
By keeping the code elegant we can keep it
maintainable because we can find stuff faster
and we can reuse it and recombine functionality.
It's more fun to cook with a well kept food
pantry stocked with our functions. So, why
do I talk about curry all the time? Wouldn't
it be great if we could start computing even
before we have all our stuff ready? Let's
talk about curerying and partial application.
I still have to eat more from the knowledge
tree. This is a curry tree. On our lucky day
we might find it's leave in a curry spice
mixture, usually it's not in there. And this
is Haskell curry, he ate so much from the
knowledge tree of combinatorial left‑hand
lane Eck that he has his own function, the
curry function and he has programming languages
named after his first and last name the literature,
curry is the transformation of the function
of arguments with one argument each so let's
have a look, here we see a function with three
arguments, ABC. It just prints them. The curryied
version consists of a function returning a
function returning a function. And each one
of these has just one argument and returns
a function that expects the remaining arguments.
The difference is visible in the call of the
normal and the curried version, you already
see it here, but let's look in detail. So
the function look like this. I can provide
the parameters ABC, one, by one, Haskell curry.
I could also prefill my arguments up to a
specific death so I could just supply the
Haskell and then I would have a function which
names everybody Haskell. (Laughs) so I could
specialize a more general function, if that
makes sense. That's also re ‑‑ let's
revisit higher order functions, they can help
us do repeated work on data structure, map
reduce and filter are some of the most prominent.
In JavaScript we know them from arrays. So
map applies supplied unary function with one
argument to each array Element. How does that
work? We already used it. We said pick three
spices and then map the print item function
over them. So on the left we have our array
of the three spices and then on the right
side we have the result, how does this work?
It works like this: Just for each array Element
the print item function is executed and we
get this result. It's like a transformation
of the array. And reduce, combines an array
of Elements into a single result via a repeated
application of a supplied buy flair function,
the binary function input produces one output
so we're reducing something. Let's look at
an example. Here we want to sum up all our
items in our food pantry, so the individual
counts you can see here, remember we had ten
spices, three soup bases and five main ingredients.
And plus as a pienary function I just rewrote
it here because the operator works a bit differently.
And we applied repeatedly when we make a sound,
clearly a pattern for reduce and would lack
like this. I do ten plus three get thirteen
plus five and I get my overall result of 18
so it's reduced to one number. And filter,
filters the Elements of an array based on
a predicate. Hao would that work, let's say
we have an array of veggies and we want to
filter that's in stock so we can start cooking.
(Vegetables) you can see there ‑‑ so
how does it work, I have 25 okra so it is
in stock and in the resulting array, the car
wrotes get filtered out because I have zero
in stock. So we saw closure, currying, partial
application and higher order functions help
us to build complex specialized functions
from more simple and more ‑‑ from simple
and more general functions. Let's build some
pipeline, function composition. A function
transforms input into output as we said in
the beginning in the most straightforward
way to build functions from other functions
is to just connect them into a pipeline. It
would look like this, function composition.
We can write ourselves a higher order function
for function composition. And it looks like
the definition from a math book, so you see
the G of F of X in there. And with these tools
we're now ready to build us some functions,
let's try it out. So here I count the pieces
of okra and chop them in half, remember we
had 25 pieces of okra and I'm just chopping
them in half so I get double the amount of
okra. (Laughs) so, I can compose the two,
and then I get 50 okra. And so we can see
from this combination we were building something
new, and this style of programming can bring
our programs closer to the declarative side
where we tell the computer what to do but
not how to compute it step‑by‑step. Programs
in the declarative side are easier to read
because we don't have to keep the space of
the work space in our head all the time. So
I have to make a confession, I'm coming from
Haskell and some things are a bit different
there. I'm just going to tell you for context.
In Haskell we have referential transparency,
a function can be replaced with it's value,
it means the same thing. And this is mind
boggling coming from JavaScript because there's
no such thing as call or return in Haskell.
We have to think about functions in a sense
of mathematics where I can F of X equals Y
I can replace the left‑hand side F of X
with the right‑hand side Y and vice versa
without worrying if the function was called
and if the result is ready yet. This simplifies
reasoning about the program for both the programmer
and the computer. Haskell is laity only computes
values when needed and automatic currying
so it's normal to partially supply function
arguments there. And Haskell is also purely
functional, that means we cannot have side
effects that modify our environment in a Haskell
program, even if we wanted to, we would have
to use an explicit mechanism to perform side
effects. So that's a bit different. Wow! We
already tricked ourself deep into functional
programming. We could say, if you understand
the importance of functions and what we can
do with them, you understand functional programming.
What we can do with them was pass them to
other functions, currying composition, but
what else is there? Is there more? A question
that comes with statelessness when we try
to avoid side effects is the question of how
to control our program flow. Usually we need
a counter for our iterations and then we need
a variable to check if it's time to leave
loop? So it's a side effect we want to avoid
it, it's bad. And few functional programming
we would have to change our way of thinking
exactly for this reason. Instead of iterating,
we would favor recursion, and that means we
use a function that calls itself for a smaller
part of the problem. That sounds uncomfortable.
What's so bad about the loop? In fact nothing's
bad about the lap, it's just a different way
of thinking about the problem. Iteration is
usually bottom up, whereas recursion is top
down. And I'm very grateful that I had to
move back and forth between these two words
in my masters thesis because it's a really
good brain exercise. Restrictions are just
function made people construct really cool
stuff like the Y‑combinator show that recursion
is possible with just functions and parameters
you don't even need declarations I think that's
one of the coolest things in computer science.
So if we restrict ourselves to the purely
functional style, everything is express in
the the input and output of functions even
the program flow. It's a recursion over the
input or out put of the data. Ooops (Laughs)
when we have to gale with the internet, asynchronous
code can dramatically reduce the latency in
a distributed system, but it can be hard to
write, we all know this because there's no
way vanilla JavaScript to say wait for the
return of a function, we supply a call back
function and tell the function where to continue
after it's done. If we have a cascade of call
back functions and we need to doer report
handling things can get hairy. So this is ‑‑
there's my favorite web site call back hell.com.
You've all seen this code which looks like
a pyramid and it's horrible. So functional
programming technique for explicit error handling
would be using Monads. Imagine we would be
in the purely functional world where functions
behave look mathematical functions. So the
order in which we write our functions doesn't
matter in this world. But in JavaScript we
can execute expressions and sequence by writing
one after the other with a semicolon in between,
so it's different. How does that work? How
about making our own semicolon? Let's observe
what it does for us. So what does the semicolon
do in this function? So ... here first the
given string is printed and then the length
of the string is returned. The right of function
behaves like the semicolon here, can we do
that? So we wrap the expressions, the two
expressions that we had, that we want to change,
we wrap them into anonymous functions so we
can call them like we want to later on when
they come into our semicolon function later
as arguments. We also need an extra return
here so that the last value gets out of this
extra function that we wrapped around it again.
So that's like a technical step, and then,
to abstract from the two statements we can
now pass in the first and second expression
as arguments into our semicolon function.
Now it's also clear why we had to wrap them
into anonymous function because of the different
return area which we have here. The expressions
depend on each other, but the first result
gets thrown away. We can now chain the first
and second expression in the same way a semi
colon can, so it's producing the same output.
In fact we can chain as many expressions as
we like. So I can chain here this works. Like
a semicolon and then bang, which adds an explanation
mark and then I get my result of 16. This
sounds really boring because we already have
a semicolon in JavaScript, but if you think
about this for a while we just constructed
a chaining function from purely functional
parts. So this is a big deal. We went from
a world in which the order of functions or
statements doesn't make a difference to a
world in which we can change statements into
a sequence, to establish their order. The
semicolon function works like a function known
as monadic bind. What's that? So mow daddic
bind or mbind resemble composition throws
away immediate results and statements can
be executed just for their side effects. I
just replaced the name here mbind. So, we
said Monads chain things into sequences, what
kind of things? Let's imagine a container
a cooking pot. We start with pot one, so that's
my pot one, it has some contents, here is
pot one and when we have the result from pot
one, we can execute pot two, so it would look
like this and go on like this. So I'm doing
some steps here this is a different view under
semi colon function from above, steps can
be chained with mbind after we work through
the entire sequence of steps we get some kind
of result in the pot, the contents. Let's
express this work flow in steps to reveal
the pattern. If you would just write town
the values of ‑‑ write down the values
of the pewation it would like like this. The
difference we between the two versions is
the first one puts everything in the pot and
the second one works on a naked values. Let's
now imagine we have a really good reason to
put everything into a pot. So for example
we could hide some additional logic in there.
The pot could keep track of the sum of all
numbers that are stored in it or it could
keep a list of ingredients sorted in a pot.
The question is now can we deduce a generic
monad pattern from this? So we want a function
that applies a function to the contents inside
the pot and gives us a new pot. Containing
the result of that function. We can define
this function which is mbind for the pot monad
on the pot prototype, let's do that. We see
a very clear pattern now. We also see that
we need an extra step to get the contents
out of the pot in the end, So, I'm doing the
C contents here to get it out. And step one
of the computation is A equals new pot of
one as an object oriented programmer I say,
ait's a con instructor, a new type of pot.
But in the monad jargon we call it unit or
return, return is already taken in JavaScript,
so I want to be careful. It takes a value
and transforms the value into a nomadic value.
The next steps all have a similar pattern.
We've seen it before, we know it uses the
function mbind and mbind takes a monadic value
and function which works on the contents we
sometimes say the play non‑monadic type
and returns a new monadic value containing
the result, just as we intended. And that's
all! Why got so many people talking about
monads what continue we say patterns that
wraps and changes computation. First of all
it's not a very good name, and also it was
described by mathematician from the field
of Cat theory first. The monad pattern, this
is completely unimportant we don't need to
know about it, but what's really cool about
the monad pattern in JavaScript is we can
hide stuff in it. We get an extra layer of
abstraction to hide the bookkeeping and all
this error handling and let the beauty of
the algorithm shine. So now that we've con
cored the monads do we get desert? I'd rather
have you take something home because it's
late. I hope you enjoyed some of the techniques
I hope I could make them digestible if you
ever find yourself in a mess, maybe some of
these techniques will help you out of it.
And if you never get yourself into one, at
least it's fun to reason about them (Laughs)
so don't forget to take home some of the purely
functional goodness, abstraction it's more
important than we think. Very localized understanding
of code and very small functions that you
can reuse. Explicit said effects that we know
about error handling, and reusability resulting
from this. And as some of you might have seen
all of this and more can be found in the book
called gas cure rebuke, I'm not sure how ‑‑
Das Crrurry ‑ Buch. The book is in German
the code examples are in English so you can
ease into a known language again W have seen
it's fun and totally possible to explore deeper
functional concepts in JavaScript, it's all
there, even though I still like Haskell, I'm
amazed how much elegance this programming
style reveal from the core of JavaScript,
I think it's just awesome refactorring in
a functional style is really fun, thank you
for listening.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>