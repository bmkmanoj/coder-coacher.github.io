<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>David Herman: r/evolution | JSConf.au 2014 | Coder Coacher - Coaching Coders</title><meta content="David Herman: r/evolution | JSConf.au 2014 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>David Herman: r/evolution | JSConf.au 2014</b></h2><h5 class="post__date">2015-01-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hMXkLgXZzS4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Oh
okay I want to talk about how we change
the web that's my job at Mozilla is to
change the web and forgive me if this
talk it's a little philosophical
hopefully things will get more juicy and
technical as the day goes on in fact I'm
probably the most awake person here my
body thinks it's like four or five in
the afternoon so you can all sleep
through this if you don't like
philosophy alright so whenever people
talk about changing technology you can
you see them start to divide into two
different camps there's the revolution
style and the evolution style and that's
what I'm going to talk about today and
I'm not going to try to convince you
that one is right or wrong but i do want
to convince you that evolution works
remarkably well and sometimes when you
think it's time for a revolution maybe
you should stop and think would
evolution work better so again i'm not
i'm not a anti revolution here in fact
the organization that I work for Mozilla
was actually founded on a kind of
revolution and I think at this it's in
2014 it's been long enough that a lot of
people don't actually know the sort of
creation story of Mozilla I was pretty
young when this happened I think I was
in my early 20s I'm betting a lot of you
were even younger than that so it's a
really fascinating story back then
Netscape and Microsoft were the two
dominant browser you know the two
companies with the dominant browsers
netscape communicator i think it was
called at the time and internet explorer
and netscape was doomed internet
explorer had undercut their business
model and they suddenly found themselves
a company with no source of revenue and
they knew this this was not they weren't
fooling themselves into thinking that
they had some some way to survive so
they could see that Microsoft was really
poised to basically take over the web
and in this kind of desperate situation
they actually pulled a pretty amazing
move particularly for that time when
open source was not as
as popular common a thing on the
thirty-first of march in 1998 they
decided to open the source to netscape
and create mozilla org which was going
to be this worldwide organization of
open-source collaborators now this was
really sort of it there was a kind of
two parts to this to what makes us a
revolution one was this was maybe
possibly going to rescue netscape from
almost certain death and we know how
that story ends but more importantly I
think this move saved the web I think if
they hadn't done this there would have
been very little that anybody could do
to stop Microsoft from from taking over
the web as it turns out this revolution
was actually televised so I have a
little clip here I want to show you from
a documentary called code rush which was
actually they followed Netscape people
around during this period and they
actually filmed the moment when Jamie's
a winski who was a well-known developer
at Netscape pushed the code out to the
web and for me this is a pretty heady
moment in the history of the web this
was this was a moment of revolution and
what led up to this was a whole bunch of
pressure they were behind schedule they
were finding out at the last minute that
they had potentially patent encumbered
code that they were going to have to
replace and there were people pulling
all nighters to replace patent and come
pre code with open source code so it was
really down to the wire and the
documentary kind of plays that up so
here they are on March 31st that's
American style sorry one way to learn to
run a marathon is put a person now 26
miles into the desert and say you know
that there's this bomb on your back
that's going to go off in a certain
length of time if you don't get into the
town well that'll motivate you to get in
but there's a certain chance that you'll
be blown up
bye i'm 55 well i'm so going to be late
hurry up welcome everybody to the
conference call thanks for joining us
this morning today a Netscape announced
that the first developer release of its
communicator 50 source code is available
for download from the mozilla org
website and you know where tarus go
second floor it's the first floor like
way on the other side and then today on
the end of March as we announced we are
pushing the code out to the web as they
say and we're delighted to be part of it
and we're very excited to see what
happens the good news is the marathoner
is now coming into town with that bomb
on his back and it looks like he's going
to make it this is the moment of truth
they don't have a theoretical framework
to write software they're just writing
it hi just like hitting the baseball if
their code gets a home run nobody's
asking questions well this doesn't make
sense or why do you do that why does it
work nobody cares why it works wait
what's good um well it's not connected
to the machine that controls the ftp
push it's like not answering is it Lotus
its blast that flash oh yeah maybe Reba
to uh hmm oh yeah right yay Super Max
there Phoenix is there and just there
we're done
jamie is here i'm told that means that
we have now pushed the source out on the
note that's correct i decided not to a
stupid idea that's a story interesting
to go
for a moment everyone at Netscape takes
a breather
he said I think it's going to work out
there at the end I think my favorite
part of that is the little Duran Duran
playing in the background alright this
was a this was a seriously revolutionary
move and they knew what they were doing
this wasn't just about saving Netscape
they understood that they were also
creating a parachute to rescue a
competition on the web to be able to
have another another option after the
end of Netscape so Jamie Zielinski was
replying a year later after AOL had
acquired Netscape and people were kind
of facepalming and giving up and he was
saying don't don't forget what we did
because we opened the the source code
because legally nobody can close that
source code back up he's saying nobody
can undo what has been done the Mozilla
code is out there and nobody can ever
take that away from you ever so that you
know it took a couple of years for that
source code to really land on its feet
and for Firefox to become a big thing
but this was a big a big bold move in
the history of of the web so revolution
is really exciting and it lets you raise
guns over your head and and red flags
and it's it's pretty hard to get excited
about things like evolution because
evolution tends to not be quite as
pretty not maybe not quite as exciting
it produces some interesting effects but
i'm going to try anyway to convince you
that there's there's there's times for
revolution but there's also times when
maybe revolution isn't what's called for
and maybe evolution would actually work
better so you know when they saw where
we're at death's door here the web is
almost over okay that's time for
revolution but often you hear people say
you know you read on like hacker news oh
this you know JavaScript such an ugly
language oh it has with we should just
start over again but look every
technology has words and maybe having
warts isn't actually enough cause for
revolution so one of the one of the
topics where you see people asking for
revolution all the time is this you know
why don't you have a byte code language
on the
and for a long time was ill argued
against trying to standardize a bytecode
vm but it was hard to really it's hard
to just say no you really want to offer
an alternative and so when we look at
the the calls for a byte code language
it's actually better to take a step back
and say what are the problems that
people are actually trying to solve the
problems that that they're identifying
these are real actual problems are
things like JavaScript lacks the
features that you need for other
languages to compile to the web so if
you want the web to be a compiled target
for some other language if you want to
be able to port some other code to the
web there are some features missing in
JavaScript that make that difficult
another one is is performance you know
JavaScript historically has been slow or
maybe it's not always slow sometimes
it's fast but it's very hard to predict
when it's going to be fast because jits
are extremely dynamic heuristic systems
it's very hard to get repeatedly
repeatable reliable performance it's
hard to get reliable performance across
multiple browsers and for people who
really wanted to squeeze out maximum
performance particularly the games
industry jit compilation can also
provide produce performance problems of
its own just the act of compiling code
can itself introduce jank in your in
your code so these were all real issues
but instead of just saying well let's
start from scratch and lets you know
create a new standards body and try to
get all the companies together and and
come up with something out of whole
cloth we decided to take a different
approach at Mozilla so the first step
was well we know that we can compile to
JavaScript there's lots of languages
that compiled to JavaScript let's try
compiling high-performance programs to
JavaScript and see how well we can do so
my colleague alone zack i created the
Emscripten compiler this was sort of the
first step of our process it was just to
say okay it's probably impossible to
commit this is actually what he told me
he said he was sure that this was
impossible to compile C++ to JavaScript
but he might as well give it a try and
see where it falls down and he along
with everyone else was shocked to see
that it worked better than he expected
and he was able to leverage a lot of the
hard work of the l a-- vm toolchain so
he didn't have to write a lot
back end code but even so it was a
pretty amazing feat to take a low-level
language and compiler to JavaScript the
next step was to figure out well how can
we get better performance out of this so
he's built this compiler that produces
JavaScript now we look need to look at
our JavaScript engine and figure out
well what kinds of performance
bottlenecks are we hitting there how can
we optimize our JavaScript engine it
turns out that he wasn't the only one
doing this there were other compilers
being used on the web and so multiple
engines were actually starting to
multiple JavaScript engines were
starting to improve the performance for
this sort of strange style of code that
was being generated by compilers and so
over time we were closing those
performance gaps and then the final step
was when we got together alone Zac i
Luke Wagner another colleague of mine
and I got together and said can we
actually formalize what this dialect of
javascript is that we're generating from
the inscription compiler in a way that
we could actually recognize that code
ahead of time in our JavaScript engine
validate it and actually prove that we
can get a higher degree of optimizations
that are guaranteed to be correct so
basically it was can we lock in that
last level of performance and this
worked really well and it also turned a
lot of stomachs so you know I showed you
those pictures of evolution evolution
doesn't always provide the the prettiest
results so one of the one of the things
that bothers people about as MJS is that
it's this very bizarre style of code so
you know I could I could defend myself
and say well you know any machine
generated code is ugly you know you can
look at any bytecode language and it's
going to look just as ugly but that's
really not the point the point here is
that this is an evolutionary strategy
where a bytecode language has to get
over this initial hump that's very
difficult which is that no content
authors nobody who's actually building
web apps could start to use a new byte
code language until enough browsers had
actually implemented that byte code
language and it had reached enough end
users and this creates a kind of chicken
and egg problem where developers aren't
creating demand because they're
building it so browser vendors aren't
don't have the incentive to build it and
so browser vendors aren't building it
which means that developers aren't using
it it's very hard to get off the ground
whereas with as MJ s what we did was we
said well this is just JavaScript this
actually works in any JavaScript engine
as long as it has typed arrays support
and typed arrays are you know had long
been standardized so from the get-go as
andreas worked in multiple browsers once
ie10 added typed array support it
started working in IE as well so you can
write as MJ s code that works in IE
safari opera chrome firefox so this was
a technology that could work from the
start and it was one that web developers
could start using and that meant that we
could bootstrap this evolutionary
process and actually get things moving
faster so just to prove that this is
real and because I love to show off my
colleagues work I'm going to do just one
as MJ s demo so what this demo is is the
the Triple A game company epic they do
some of the sort of Hollywood
blockbuster style games their latest
engine is called Unreal Engine 4 and
this is a port see oh this isn't fitting
on the screen here we go so this is a
port of a demo of Unreal Engine 4
running with no plugins in a nightly
build of Firefox I don't know how many
lines of C++ code it is but I think it's
at least a million lines it's about a 68
megabyte payload
you can see there's some pretty nice
lighting effects this is actually not
even finished so unreal 4 is not I think
it hasn't even been released or maybe
it's just in the process of being
released so when we first met with
unreal or with epic to help them port
unreal 3 a year ago they got it working
in less than a week so we're proving
that it's actually possible to compile
high-performance JavaScript code or hype
upon its native code to the web mostly
push button and that's getting better
and better but at this point now they're
taking products they haven't even
released yet so let's see if we can go
to some fun
I like this demo because i'm not a big
gamer and I like the atmosphere of it
it's not as violent so we have other
partners to the other really big name is
the city the other really big name in
game engines is unity and we just
announced with them at the game
developers conference that the unity
engine has also been ported to as MJS
somewhere there's like a big thing that
takes me wise me away I don't know like
I say I'm not much of a game game player
but anyway so there's a taste of native
code running in the browser with no
plugins alright so the next thing I want
to talk about is a sort of mini movement
that we started calling one javascript
or one j/s my nanny tells me that my
infant daughter really loves one
direction so i don't think i could name
their songs if I heard them so when I
first got involved with tc39 the
standards committee they were in the
process of doing addition for of ECMO
scripts and let me kind of get you into
the heads of people who do standards
people who do standards have to cope
every day with the mistakes that were
made in the past in a technology and
they desperately wish that they could
fix them and the web is enormous and you
can't take anything back and so when
you're looking at you know billions of
applications that are all using these
broken features and you really wish you
could get rid of the features but you
can't do it without breaking them
there's this enormous temptation to say
let's let's create a clean slate by
having a some sort of opt-in where you
can choose a new version of the language
and there we can actually throw away
some features that we never liked or
that get in the way or cause problems
for other features that we want so when
I first joined that was the plan of
action that was the plan of record for
addition for we were going to have this
new mime type application / JavaScript
semicolon version equals 4 and that was
going to be this grand new utopia that
everyone was going to program in I say I
have to get you in the mind of a
standards person because any developer
looks at this and thinks that they're
out of their minds but when you really
really wish that you could change the
technology it's very natural to want to
do that so the kinds of things that we
were talking about doing back then were
we wanted to introduce these generator
functions and at the time the the
problem we were running into was they
needed this new yield keyword but yield
wasn't a reserved word and there's
actual code out there on the web that
uses yield as an identifier so this was
just an incompatibility how could we do
this and the easy answer was well we'll
just force them to opt into the new
language and then with the new language
we can reserve new keywords so edition 4
got cancelled for all sorts of various
reasons if if you want to hear the story
you're going to have to get me a beer
but even though that got canceled then
when we moved on to addition 5 did a few
things but then when we moved on to
addition 6 we kind of went back to the
same plan again we were we're going to
have this version opt-in and we were
going to be able to break things and so
we were going to be able to have
generator functions that that had this
reserved keyword yield that was the plan
for a long time and it was allowing us
to think big thoughts about really
breaking compatibility and changing
things and doing things in new ways and
one day my colleague Sam Tobin Hawk said
who's a professor at Indiana University
back in the states he and I were I am I
and he said you know I just had this
nagging feeling in the back of my head
that maybe we were so close to
compatibility with the existing versions
of Java Script maybe we actually don't
need the opt-in and that was like this
big you know being slapped by a
two-by-four over the head it had just
never occurred to me before that that we
should reconsider that so we worked
through it and we realize we can do
everything we're trying to do without
actually needing an opt-in so for
generators for example by giving a
special distinct syntax for what a
generator function looks like that
allows us to contextually reserved the
keyword yield basically there are sort
of feature by feature you could call
them hacks or you
you call them finesses so this allows us
to add new features to javascript in
such a way that you don't have to decide
I'm going all-in for the new language
version if I just want this one feature
and that's really critical for the
evolution story for people to be able to
piece by piece adopt new technology they
need to not have to worry about if I
pull in this one piece am I going to
pull in all these other pieces as well
is that going to break other parts of my
code that already exists can I just you
know can I just adopt one piece at a
time and the easier you make it for
people to adopt one piece at a time the
faster you get to turn that evolutionary
crank so I sent an email to the mailing
list called es6 doesn't need opt-in and
I and I coined the slogan just one
JavaScript and that has become a sort of
a guiding principle for us all along is
let's not fork the language let's keep
within one language and add new features
piece by piece rather than trying to
create whole new versions of JavaScript
this is important for several reasons it
helps focus our work it prevents us from
going off in directions that are just
kind of pointless anyway it enforces
consistency the more we fork the
language the more we have the more
developers have to deal with well what
happens if I have es5 code in es6 code
and they need to interact with each
other and like i said it helps adoption
because it allows people to pick up
features one at a time and of course
when you're talking about language
features they can't just use them like
libraries and use standard polyfills
like they can with api's then they need
to use things like compilers but that's
a real thing now compilers aren't just a
theoretical possibility there's a
standard tool these days for JavaScript
development so in between es for in es6
there was actually another little mode
that gets snuck in there and that was
strict mode and i'm not going to get
into the vagaries of you know what's
good and what's bad about strict mode
except just to say that it's once again
another opt-in mode and it is another
kind of forking of the language and
again it was one of those things where
it was very tempting for people on a
Standards Committee to use
has there are all these pain points so
one of the main ones is function
declarations inside of a block have just
completely incompatible semantics across
different browsers they were actually
never part of the ACMA script standard
and so each browser added it in a
non-standard way and they have some
parts that have overlapping semantics in
some parts that are incompatible and so
it was just hopeless every time we tried
to figure out how can we actually
standardized what the behavior should be
it was impossible to find something that
worked on all browsers and that wouldn't
break existing content so strict mode
gave us an in for doing that we could
say oh well for new code that ops into
strict mode we can fix the semantics we
can make it clean we can make it what we
want it to be but the problem is again
you're forcing people to opt into this
new mode strict mode had some some
issues of its own as far as like you
know how to mash together non strict
code and strict code so in equus crypt 6
what we're doing is instead of an opt-in
mode or tying strict mode two modules
now modules aren't tied to a whole bunch
of different things this is the one
piece that's tied together but I think
it's really important so for one I think
node has proved to us that people want
to write their code in modules that's
the style that people want to write
programs in so I think that once modules
start landing in all of the browsers or
even once the compilers that people are
building today start becoming prevalent
enough people are really going to want
to use equi script six modules for
writing their code and just by using a
module you'll automatically be put into
strict mode and that means some of those
cleanups that we got to introduce into
the language for strict mode will now
just be applied everywhere and some of
the worst mistakes of Java scripts past
will sort of be automatically fixed for
the vast majority of code that you write
as long as as long as you want to be
using models which I think again is
going to be popular so this is a
one-time fixed we don't get to do this
all the time but modules were an
opportunity and they were up an
opportunity to do this in a way that
didn't force people to use that that
language for king so the basic theme
here is that features are better than
Forks introducing fixes to the language
on a case-by-case basis works much
better than forcing programmers to deal
with sort of a combinatorial explosion
of different versions of ECMO
and modules are just a better tool to
use for opting into strict mode than
modes and it's my hope that in the
future people aren't going to really
think about strict mode anymore it's
just going to be well there's some old
code that's kind of sloppy in this what
we call sloppy mood but but the vast
majority of code will be in modules in
their odd they'll automatically be
strict okay so the last thing I want to
talk about is hermeneutics this is no
relation to my name it's named after the
Greek god Hermes so hermeneutics is the
philosophy of interpretation it's
particularly was invented for
understanding for talking about how do
we understand texts and in the early
days it was all about religious texts
and in particular there's this idea that
was introduced I think in the 20th
century by Heidegger and then some some
later philosophers like gadamer and Max
Weber built on the idea called the
hermeneutic circle so the idea of the
hermeneutic circle you know again this
stuff started out with textual
interpretation but over time it started
to be applied to how do we understand
things in general and the idea was that
if you're reading a book to understand
the book you have to read the individual
parts but then once you've read all of
those individual parts you kind of get
an understanding of the whole and you
can start to interpret the whole book
but once you've got this better
interpretation of the book that would
actually color how you read the part so
you could go back and reread the book
again and refine your understanding of
the book and you can kind of go around
and around in the circle and iteratively
deepen your understanding of the text so
this idea i think is very intuitive for
us because we're used to iterate
oppresses in software and in particular
when it comes to designing web
technology there's kind of an analog of
that big picture small small picture
that micro and macro the macro is that
good design has to be motivated by
end-to-end use cases and workflows we
have to think about what does the the
whole system look like what does the
development model look like does this
language feel good to program in
what does a normal program look like but
in order to actually build that
programming model you have to design the
individual pieces and anyone who spent
time working in design learns that just
like software you want to build things
in small modular pieces little
orthogonal composable pieces that you
can fit together so if you take feature
a and feature be and you put them
together you don't get something
unexpected they just work as the sort of
expected combination of a and B so in
the design process we can really go
through that same harman dudek circle
you design at the individual pieces for
a while and then you have to evaluate
the big picture and you have to go
around the block multiple times I think
this is just a feature of any learning
process is that you're going to get it
wrong in the beginning you're going to
have to learn to throw some parts away
and we understand this in software
completely we talk about you know plan
to throw one away we talk about move
fast and break things we're all used to
the idea of of changing our minds as we
deepen our understanding of things so
when you're developing a product we kind
of have a pretty good handle on this you
sort of have this iterative process
where we develop the product for a while
we ship it we get some user feedback we
evaluate it and invariably it's not
perfect and we go back around the block
again and we refine our product but what
happens when you try to do this with a
standard there's a major problem you
develop the standard for a while you
ship it you evaluate it you get some
developer feedback but now it's out
there on the web and you'll break User
Content if you change it and you can't
break the web and you're stuck you go
one time around the block and you can
never change it again this is just a
broken way for us to evolve the web
because none of us is going to get it
right the first time we're just not good
enough so this is where this movement
called the extensible web came from so
if you go to if you google for
extensible web manifesto you'll find
this website and I'm one of the
undersigned and the basic idea of the
extensible web manifesto was we want to
change the priorities of web standards
and in particular we want to change them
so that we can tighten that feedback
loop
between the editors of the web standards
the ones who are actually creating these
standards and the web developers who are
the ones who are the best equipped to
evaluate to evaluate the work and really
should actually be directly involved in
that work so this is this is where you
come in this is the part where I want to
encourage web developers to take an
active role in evolving the web
historically if you look at the
conversations in standards it's
completely dominated by people who work
for browser vendors people like me and
there's a few hardy developers who are
willing to weather the storm of shouting
matches on mailing lists and well why
didn't you read the last three years of
back messages on this topic before you
came in and and ask that silly question
that I've answered so many times before
or you just don't understand what goes
on in building a web browser or you
missed a security constraint it's
actually incredibly difficult to get up
to speed on all of those things so we
want to get to a world where there's
more of a balance between browser
vendors and web developers who are
thinking about the web platform who are
designing the web platform and evolving
the web platform and I don't have
answers for all of this I do see some
culprits for what's not working in
particular after eight years in this
business I believe that mailing lists
are a failed model of communication I
don't think that they work I also think
that arguing on twitter is a new failed
model of communication I think that
doesn't work either I think Twitter does
have its place I've had a lot of good
conversations where people just want a
quick point of clarification it's an
easier way to get sort of a targeted
answer to something but as soon as
people start disagreeing about something
it is a horrible place to continue a
conversation so I don't have all the
answers I do think an important piece of
this puzzle is github I think that well
we're certainly seeing the w3c and to
some degree tc39 there's more coming
moving more and more of their work to
get hub and I think that's important I
think for ones are socially it's
important it's the world where web
developers
and that's where you know you need to
come to the turf of the people that you
want to engage with but there's also
some tools that I think work better it
allows you to focus conversations a
little bit better by having individual
github issues instead of endless mailing
list threads it helps you focus a little
bit I certainly don't think github
issues are a panacea I don't think
they're perfect but I'm very much
interested in improving the model of
collaboration between web web browser
vendors and web developers so I'd very
much encourage anybody who's interested
to talk to me and and just have some
conversations about ways that we can do
this better but i will say that there's
something very concrete that I think all
of you have the opportunity to do and I
think really does change the
conversation this is a phenomenon I've
seen in the last couple of years and
that is to actually take part in
building polyfills and the variation of
polyfills is prolly phils which is
really probably the most relevant thing
here for those of you who aren't
familiar with the idea polyfill is
simply a shim it's a library that
implements a feature in case it's not
there yet so it's filling a gap in
what's currently deployed by a
particular version of a browser a prolly
Phil is the same idea except it's
applied to a proposed library that
hasn't yet been standardized so if you
want to demonstrate what a feature might
look like a feature that you're
proposing you can build a sort of
candidate polyfill and that's what
people call prolly fills but the other
half is building compilers so if you're
interested in new language features you
can build you can either take one of the
existing compilers such as Google's
tracer or there's a handful of
individual features for es6 that are
being built as individual compilers and
over time people are starting to figure
out ways that they can put those
together so if you actually look at
participating in those you actually are
becoming a kind of browser vendor of
your own you're basically becoming an
implementer of a feature and you will
have a level of depth of insight that
actually many of the browser vendors who
haven't gone through the exercise of
building the future don't and you will
find that you're able to have very high
value conversations
with other people involved in standards
so I just want to give a couple of shout
outs to people who have done a fantastic
job of this so far because I think
they're models that we want to follow so
one of those is ben newman who has built
a tool called regenerator which is an
es6 generator compiler another group of
people I think three of the leaders of
the project are are Brian Donovan
Jhoulys and Thomas Boyd but there's
actually 16 contributors listed on the
github repo this is for the es6 module
transpiler so these are people who are
actually engaging with the standards as
they're going they're there they're
working with us together as
collaborators and they're finding that
in this process they're actually getting
brought into the conversation because
they have as much or more valuable
feedback to give as the people who are
building the browsers so the TLDR of the
extensible web is if they're missing
primitives in the platform we've got a
priority to prioritize those first
because those primitives are what you
use to build these polyfills prolly
fills and compilers on top of them and
then from there we enable evolution to
happen out in user land we enable
evolution to happen in JavaScript
implementations of language features or
sorry of library features or pre
compilers that compile language features
and then we can work together both
browser vendors and web developers to
actually together design the web that we
want to see and that's all I have to say
thanks very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>