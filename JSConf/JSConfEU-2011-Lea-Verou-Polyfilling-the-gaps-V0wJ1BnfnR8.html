<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>[JSConfEU 2011] Lea Verou: Polyfilling the gaps | Coder Coacher - Coaching Coders</title><meta content="[JSConfEU 2011] Lea Verou: Polyfilling the gaps - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>[JSConfEU 2011] Lea Verou: Polyfilling the gaps</b></h2><h5 class="post__date">2013-06-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/V0wJ1BnfnR8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone thanks for being here
today at this truck so before diving in
the wondrous world of polyfills I'd like
the times to take some time to introduce
myself I'm Leah vero as you can see
there are three times it's a Greek name
I live in Greece I'm a front-end
developer I love CSS and JavaScript but
don't worry I'm not going to start
singing now and these are the places you
can find me on the web so many people
know me from for my CSS research and
they were asking me yesterday if it's
going to be a talk about CSS and I was
like dude it's a JavaScript conference
it's I'm not going to speak about CSS so
no it's not about CSS polyfills purple
and Polly fields are to CSS about what
4k is the sushi you can use it to eat
sushi but it's not really a very good
idea and it's not meant for that purpose
so what our polyfills boy feels is a
term coined by Remy sharp last year but
it caught up really quickly and it
actually comes from this product on the
cover that's a UK product and it's used
in the UK to cover up holes and gaps in
cracks in walls and he thought that it's
a proper term for describing what Polly
filles du in a browser because that's
essentially what they do they cover up
holes and gaps in browser support his
official definition for that was that a
polyfill is a piece of code or plugin
for example chrome frame could be
considered a kind of polyfill that
provides the technology the cue the
developer expect the browser to provide
natively or as Paul Irish poet it's
assume that mimics a future API by
providing for buck functionality to all
browsers so if that sounds a bit unclear
I'm pretty sure almost all of you have
done this thing at some point this is
three lines of code or five depending on
how you count them but they essentially
have all the elements of a good polyfill
they have featured a firstly detect if
the feature is present is stream
available in strengths and if it's not
they go ahead and implement the feature
and just this is a very simple feature
some one line is enough and then after
that body feels included the end
developer can use it as if it was
provided natively and they can do that
thing without being aware that the
polyfill actually exists and that's one
of the best advantages of polyfills you
don't have to learn a new API for
example jquery is a script that helps us
do some tasks that in which support is a
bit flaky for example some I all that
uses a touch event modern browsers you
even listening jquery covers up this
inconsistency but you before using it
you have to learn in your api it has a
whole documentation which you have to
learn before you're able to take
advantage of it Polly fields are not
that jQuery is not a polyfill to an API
wrapper with Polly fills you don't need
to learn anything you just the spec and
then after polyfill is included you can
move on user spec as if the
functionality was provided natively and
after some years pass you can just
remove the polyfill and your code still
works there's no dependency on the
polyfill it's just there to bridge the
gap between today and the specs because
sometimes we have amazing innovative
specs that just aren't supported yet and
we want to use them
that's what police those are for so how
can you make your own polyfill there's
like ways with so in that very simple
example of trim there are three basic
steps the first step is feature
detection is this feature already
present because if it is we don't need
to do anything we just use the native
implementation if the native
implementation is buggy and we need to
fix it somehow that's not really a
polyfill if it's not present we go to
the second step which is implementation
this is the most clever part most tricky
part where you actually have to think of
a way to emulate the functionality
that's missing in some cases it simple
like in the new xmas script methods for
strings and raise that these are the
simplest body fills in some cases it's
very tricky like for example in CSS boy
feels these are the hardest of all and
after you've done you're done with your
code and you've implemented the feature
the third part is distribution you have
your amazing code you're proud of it but
other people need to be able to find it
and use it and you you need to publish
it somewhere and in format that's easy
for them to use and you need to actually
let people know by including it in the
different lists of polyfills that are
available so let's talk a bit about the
first part that's feature detection I
think this is one of the most important
parts of polyfills because if you do
that right you save on lots of
performance if if you the feature is
already present and you move ahead and
implement it again that's a waste you
don't need that waste you need to
actually rely on the feature if it is
there so the two main strategies we use
when featured the texting are a check if
something exists this is the simplest
feature detection method you just
if an API is there for properties their
function is there and if it is you
assume that the feature is present this
is much better for performance because
you just check existence of a property
and it's much much simpler code usually
it's just one line but sometimes it
doesn't work sometimes there are false
positives or sometimes it's just not
possible to detect a feature by
detecting if something exists which
brings us to the second core idea trying
something and then trying to check if it
worked that's much more reliable because
you actually check the functionality you
don't assume that just because it's
there it works but it's also much more
verbose code it's much bigger and it's
much slower than just checking if
something is there but sometimes it's
the only way and the third method is a
combination of the previous two you
first try something and then you check
did it actually work was something
created so let's try and see how we can
detect a few common CSS HTML and
JavaScript features that we commonly
need the first way which uses the which
uses the first core idea taking if
something exists is checking about
JavaScript API support like for example
is local storage on window is geo
location in the navigator object or is
query selector and document as you can
see that's really easy really small we
just use one line of code for every API
checking if CSS properties are supported
is about as straight forward we just
create a dummy element and we check if
the property is in the style object in
actual cases you shouldn't create a new
element every time I'm just creating in
your element here just to make it
simpler but in
actually use cases you should cash it
because it's not really a good idea to
just create one every time its
properties function is called or maybe
you should also catch the results
because if it's supported it will always
be supported another method of checking
whether CSS properties are supported is
by using the second core idea which is
especially useful if you want to check
multiple versions of that property like
multiple prefixes so you can still
follow the previous method but you will
need to come up case your property and
you will need to create two camelcase
versions of your property because for
example border-radius that's without a
prefix is camel case to board the radius
without and the first B is this lower
case most border radius is camel cast
with a capital m and then the bees also
uppercase so in this method we I trade
over all the prefixes we get the prefix
version of the property and then we set
the CSS text of the dummy element to a
declaration that uses that property and
because inherit is supported by every
CSS property it should get accepted if
the property is supported it should
accept inherit so then we try to get the
value of that property and if there's a
value we returned that version of the
property because we know that property
is supported if none of these prefix
properties are supported then in this
case we return undefined in if the
function was more correct it should
return node checking CSS values requires
a bit of a test there's nothing we can
check existence for so we actually need
to apply the property we just choose any
rgba value it would work and actually
that method is not just for our GBA it
applies for any kind of CSS property for
calc for hsla for mozilla before L
for the element function anything so you
just choose one value that uses this
feature and then you check was there an
error is there did the property keep its
value because browsers just ditch
anything in CSS that doesn't work if you
provide an invalid property it gets
dropped if you provide an invalid value
it gets dropped so if it actually kept
that value it means it's supported CSS
selectors are also a bit tricky you need
to create a new style element you just
create a simple row by using that
selector it's an empty roll it doesn't
need to create it doesn't need to
contain any declarations just the just
as long as it uses the selector and we
append it to the document because
otherwise if it's just in the dome
hyperspace it won't it won't get applied
so then we check it was an errand
created in this case I actually attract
if there's a first CSS role you could
just check the length of CSS rules it
it's the same thing and we clean up
after all cells but by removing the
element we don't need we don't want to
leave it in the document and mess up
with the end-users code and we return
the result if it was there or not
detecting HTML elements is really hard
to do in a generic way this could be a
very optimistic thought because if you
read the dome specification it says that
every element that's not supported
should inherit from the HTML unknown
element interface however browsers arms
aren't expected to expose these
interfaces there it's not required as
long as they use them internally and
also some browsers don't even follow the
spec and they don't use that at all for
in some browsers it in here unknown
elements inherit from the HTML element
interface it's really inconsistent so we
can't do that it's it's nice but it
won't work so what we have to do instead
his check for known properties or known
methods are they present in a new
instance of the element so it's a bit
lucky because we don't know if they
actually work but it gets it gets the
job done it works it does what we do in
most cases so for example if we want to
check canvas support which i give the
get context method is thereafter we want
to check if video is supported which I
could play method if if we want it to be
a bit more accurate we could actually
check if it's a function and not just
the property HTML attributes are usually
pretty straightforward of course there
are caveats to that which will see
afterwards but in the general case you
just assign you just check if the the
Gator is present because browsers assign
a getter through every attribute that
they support if they support placeholder
attribute on inputs they also make a
placeholder gather and setter or if they
support multiple file inputs they create
a multiple accessor so we can just check
it if that's present it won't have a
value so checking if input dot multiple
has it through the volume won't work but
it will be present it will be defined
and attribute values are about the same
as CSS values you just say you just set
appropriate value and you check if the
browser actually kept it for example in
this case type is a supported attribute
on inputs every browser supports it but
some values aren't Lee is supported for
example the number type which is used to
create a spinner some browsers don't
support that yet like Firefox or ie so
which we set the type to a number and
then we check if the browser actually
kept that because if it doesn't it
usually reverts back to the text value
which is the default for events we can
do something similar at least for events
that have a
an accessor like on something for
example own mouth center we can set them
to a very simple function like return
nothing at which does nothing and then
check was there a function actually
created on that element if a function
was created it means it's supported if
nothing was if nothing is there it means
it's not unfortunately there's no method
there's no way to detect events like Dom
content loaded or mutation events we
don't have a way for that we have to
detect something else that we know that
if its present these events are also
present for mutation events we can
actually change the dolmen see if they
got if they got fired but it's a bit
it's much more messy than that and of
course even the examples I showed aren't
always that simple there are browser
bugs and everything so for example we
checked if local storage is supported by
checking if its present on the window
object but in firefox 3.6 accessing
local storage throws an error so you
also need to account for that or for
example opera doesn't support pointer
events on HTML elements but it still has
them in the style object because it
supports them in SVG so in a wish before
actually deciding on a feature detection
code we should really test in lots and
lots of browsers to see if it actually
works or maybe check the moderniser
source to see how they did it because
they need to test in many many browsers
to develop their framework and of course
there are some features that nobody can
detect so far the the undetectable some
features just you can't do anything
about them even modernizer can't detect
pointer events an opera used to be one
of them because it kind of falls
positive but now some clever guy whose
name I forget actually came up with the
detection method he's setting the
property and then she's checking the
computed style to see if it got applied
so now we can't detect pointer events
and the cord isn't that big but there
are many other properties that features
that can't be detected currently maybe
you can think of a way we need that kind
of thought we need people to come up
with new ways to detect features just
because there they are on that list
doesn't mean they can't be detected it
just means we're not clever enough yet
maybe you are softer we've done with
feature detection we're going to the
interesting part with this
implementation actually making the stuff
work the first rule I think every
polyfill should follow is following the
spec not that kind of follow actually
being faithful to the spec and doing and
fit fulfilling the expectations that
people have is there's no use if you're
making a bully feel that behaves in a
way that you think is better but it's
not what's expected it will be
inconsistent with native implementations
it will be inconsistent with what people
have learned it won't really be a
polyfill it will be an API wrapper
masquerading as a polyfill but however
as much as it's important to follow the
spec you should also know when to stop
because you don't want to put your
polyfill to end up like this fine lady
you don't want your polyfill to be
cluttered for example I fell into that
this trap when i created a polyfill for
the html5 progress element I wanted it
to be as correct as possible I wanted it
to respond to property changes and
attribute changes and I wanted
CSS to be super flexible I wanted to
make the best progress polyfill and I
ended up with some code that's 200 lines
just to support progress bars who who
want to use 200 lines just to be able to
use the html5 progress bars your
polyfills need to be small so that
people will want to include them without
introducing an overhead because even
when they're not executed because the
browser already supports the feature
usually they get downloaded and we don't
need we don't want to add that much
bandwidth of course there are script
loaders that only conditionally load
polyfills but in the general case
they're just included along with any
other script a case that's quite
tempting to go overboard is a polyfill
for document head how many of you
actually have used document head it's
the same thing as document body but it
refers to the head element it's an html5
thing and it seems that it's really easy
to create a pulley feel for it you just
check if document head has a value and
if it doesn't you just assign the first
head element to it but however there's a
big problem in that and I'm pretty sure
some of you have already started seeing
it if your document only has one frame
that's fine it will work but if you have
multiple frames and you try to actually
use that in the other frame I want you
will get a type error it yes it breaks
expectations but what's the alternative
what would you do not to avoid this the
only solution
Shin is to hijack every frame in the
document monitor when frames get added
and also fixed the document head for
them as well and sometimes windows get
opened with window open so we should
replace the window open method and and
fix that too I mean it gets really messy
we don't want that that's fine the two
line polyfill is what most people want
they don't want a huge script that's
super intrusive and and easy to break
just for document head after all instead
of doing that I'll just assign the head
and the middle to have arrival and get
it over with the second rule I think
most polyfill should follow is not being
intrusive like I said polyfill stood
follow expectations and the expectations
aren't that you hijack your host
document with a relevant crap try not to
replace the target element with another
for example even if you're super careful
and you copy old properties and all
attributes and everything at the very
least you'll wipe out all event
listeners and it's really hard for the
end user to work with that also try not
to manipulate unrelated elements like
the body it might be tempting to add a
class to the body to use it in your CSS
if you're prolly fuel comes with the CSS
like HTML polyfills for example it might
be tempting to add a class to the body
to which corresponds to whether that
feature is supported or not but you
should try to find another way to do it
because the the horse document might
actually depend on how many classes the
body has the right they might have a
selector in use in their CSS about the
body not having a class or if the body
having only one class or something like
that
that will break and they'll be wondering
why did it break they'll find out it's
your bully film they won't like it much
adding extra elements sometimes is
inevitable but you should try to be as
conservative as possible for example if
you're making an HTML polyfill try to
take advantage of the pseudo elements
instead of adding new elements to the
dome that break existing selectors that
are already in the horse document for
example especially now with css3
selectors we have many CSS rules that
depend on the play on the place an
element has in the document on its index
among its siblings on how many elements
something has so you're breaking this if
you are the extra elements try to avoid
it also manipulating existing attributes
is sometimes the only way but try to
avoid that too like for example going
through the elements you care about and
changing their IDs or adding ideas or
stuff like that so you have to do it
sometimes but it breaks expectations for
the horse document so try to avoid it I
guess I don't need to tell you that that
you should try not to pollute the global
namespace probably already know it but I
had to to add it and also that's quite
obvious too but sometimes it breaks try
not one leaky CSS like for example you
should namespace your CSS to only apply
to what you add to what you target don't
add CSS like for example an element
selector that would leak in other
elements and not just your the target of
your polyfill and of course all these
it's just guidelines rules of thumb in
most cases you will need to break at
least one of them in most of oil fields
at least in most HTML polyfills but just
try to only do them if you really really
have to
also remember when we said at the
beginning that one of the biggest
advantages of polyfills is that they you
will be able to remove them after a
certain point maybe after some months
maybe after some years when support gets
better and you don't need that anymore
because the browsers that don't support
that feature a really old and nobody
uses them anymore so you don't want the
overhead so you're you should be able to
remove that polyfill and you're that
your code still works without the poly
filled in in browsers that support these
feature so you shouldn't require from
the end user of your polyfill to do
stuff like this feature detection
belongs in your polyfill gathering on
the elements and fixing them also
depends on your polyfill belongs to your
poi fill it might sound obvious but it's
it's really surprising how many people
don't follow that they make a function
that implements some functionality and
then they're like yeah use that function
on any element you want to fix and they
don't actually do that you know they
don't actually do anything except
defining that function so to use their
polyfill you have to actually add
JavaScript code get all these elements
yourself and apply that function to them
so afterwards when the time comes to
remove the polyfill your code will break
for example in this case it calls the
net method over details object when the
polyfill gets removed this will throw an
error there's no details element defined
so that's that's not how polyfill should
work also your polyfill will be applied
in many cases in many different cases in
many many times the assumptions you make
will be wrong many times we tend to make
assumptions to make our job easier but
those assumptions don't really don't
apply to every dog any document and
sometimes we know that and we just
choose to make these assumptions and
some other times we just didn't think of
that and if you actually have to make an
assumption for your polyfill to work
because maybe otherwise your code will
be 10 times as big that's fine but you
should at least know that you're making
this assumption it should be a known
unknown so attributes and properties
will change there will be other scripts
on that page it won't be just yours and
those scripts will actually change might
actually change attributes and
properties also new elements might get
at it maybe by via Ajax or maybe they'll
get created by some other script but the
thing is if you make an example for
example for the html5 details element
nothing guarantees that there will be as
many details element when the document
is closed as the ones that were there
when it was created CSS can be very
different from the one you tried you
might have making sinuses you might have
been making some assumptions and certain
kind of hot CSS will break them and
there might not even be a dome that
might sound weird and you might be
thinking about thick cases like no
genius for example but even in
client-side JavaScript there's not
always a dumb for example in web workers
your code might need to run in in a web
worker if it's actually a polyfill that
applies to something like that so you
shouldn't depend in a dome being present
and it might you might be thinking now
why would I depend on a dome if my
polyfill has nothing to do with the dome
and I can it can even run in a web
worker for example if your polyfill
needs to resolve URLs and get the
separate parts one waste partially URL
yourself and return the and split it in
two parts like the horse named the pass
the pestering and everything but another
way it would be to create a dummy
element and set its href to that URL and
then get the properties from there which
will might sound quite clever at the
time but it will break when there's no
don't present even though URLs aren't
breaking your elders in two parts isn't
something that needs to depend on a dome
and also you shouldn't even depend on
HTML it might not be HTML your polyfill
might need to run in an SVG document or
in an XML document and it should still
not break of course some of these are
edge cases and some of these are edge
cases and maybe you want to make the
decision not to support them because it
will make your code base huge and you
will fall into the trap I feel with the
progress element with the progress
polyfill but you should know that you're
making these assumptions and preferably
you should state them in the description
of your polyfill some people know them
and they won't spend time debugging
something that isn't supposed to work in
their case so the first thing responding
to attribute changes this only applies
to HTML polyfills how can we actually do
stuff what attributes change we have two
tools for this first is mutation events
which which are events that get fired
when the dome three changes when an
attribute gets removed when an attribute
changes when a new element gets added
the problem with those are they are
deprecated now and there's no
alternative in the standard this they're
preparing something but it's not even in
the spec there's not even a speck yet
and of course no browser supports it so
for the time being
even though they're deprecated they're
the only thing we can use and in all die
there's also this horrible proprietary
property change event which is kind of
horrible like all Microsoft proprietary
things but sometimes it's the only way
and in polyphenols it's the goal that
counts actually filling in the gap
because eventually it will get removed
polyfills by nature are temporary so
need do what you got to do for example
Paul Backhouse created an amazing
polyfill for CSS transforms and ie and
he used that and that's actually how I
learned about the property change event
she's using that to convert CSS
transitions to the matrix filter than
added ie uses and that allows us to make
CSS poly fills in IE that they can even
respond to changes which is amazing we
can't do that in other browsers CSS poly
fills our pain in the ass but in IE we
can with that thing so about mutation
events an example of a mutation event is
Dom attribute modified and that's one of
the two you are going to use more
frequently it gets fired when an
attribute changes and it we can get the
the old value from it the new value and
the attribute name also mutation events
bubble so we can just register an event
handler in the document and then monitor
all deauxma tribute modified events and
if they're of the
they're of the kind that interests us we
do stuff if not we don't do anything for
example in this case assume this is a
part of a placeholder polyfill it tests
if the node where the attribute got
changed is an input node and then if the
attribute that got changed is a
placeholder attribute because then we
need to update the placeholder or if
it's a value because for example if we
didn't have a valuable now we do we need
to run it we need to make the pole of
the placeholder vanish so if that's the
case we call our function in our
polyfill and we update the node we don't
even need to pass the new and the old
value is in this case because the only
thing we need is the node in this case
the second thing that our polyfill
should try to be responsive is
properties things are a bit better in
this one because we have accessors like
you might have heard the mascaras and
sellers and these are pretty standard we
also have on property change for old IE
since i since all die he treats
properties as attributes that event
works in both and if your polyfill is
only to fill in firefox specific
functionality then you also have this
amazing a method that supported only in
mosul it's its proprietary but it's so
amazing I think I think it should be
added to the spec and everybody every
browser should implement it instead of
accessors make you replace the property
with an accessor get a getter in the
cellar just one of the two object watch
doesn't replace the property it just
watches it and it fires a call back when
it actually changes which is exactly
what we want in polyfills we don't
really want to replace the property it's
a hack but it's the only thing we have
we actually just want to monitor changes
watch changes and have something that's
the equivalent of an event when the
property when the property gets changed
and that's the object watch is exactly
what we want but it's only five for
Firefox so
focus a bit on accessors the standard
syntax is the one presented here we use
the Defiant property method in the
object echoed in the object constructor
as you probably know all the newegg
mcrypt five functions and objects are
just added on the object constructor
instead of specific instances even
though it would be more convenient so
that they don't break backwards
compatibility with when we make pony
fills for them so we have the fine
property it except get in the set
property end up in the parameter and we
make some callbacks for them which get
fired when somebody attempts to set that
property so this property is essentially
functions like a property but actually
it's more like a function for example in
this case we define a getter and setter
for a placeholder so when somebody tries
to to get the placeholder value through
together we actually invoke this
function and return the attribute value
because it's the same in this case in
some other cases you might want to do
some math because the Gator should
return a number and they attribute
always return strings but in this case
it's the same and when it said we invoke
a function of our polyfill that updates
the the placeholder and also to match
the native implementation of placeholder
we make this accessor numerable and
configurable which essentially means
that a numeral is that when people use
this object on foreign loops it will be
present unlike some other properties
that don't get enumerated and
configurable means that we should be
able to replace it with something else
if we don't want these accessories
anymore we I kind of disagree with it
being configurable but that's how the
native implementation works and like we
said
should follow the spec you shouldn't
break expectations so this standard
syntax of accesses is supported by I ate
Firefox for pros safari 45 and opera 12
and of course browses after those so
what can we do with all the browsers
some of them are really up for 12 isn't
even released yet and some of them are
quite recent like safari five is still
kind of recent there is an older syntax
for getters and setters which works in
many more browsers in many older
browsers this was before akma script
five was published it was the first
syntax we had and I'm so glad we didn't
actually do that and the ACMA script
five ways so much better this actually
only allows us to set a getter and
setter we can't set we can't control
whether its innumerable or whether it's
configurable or anything but in this
case it does what we want and it's a
good fallback if you don't want to have
to deal with conditionals about whether
it is defined property supported is
defined get are supported there's this
nice polyfill by Ellie gray which
combines them so you can actually use
object defined property and it will work
even in those that don't support it and
only support that kind of getters so you
actually can use a poly fill in your
polyfill that's so meta a problem with
ie8 is that even though it supports
believe either the support successors it
only supports them on Dom elements so if
you're if you need to do something else
that's not related with Dom elements
you're kind of screwed and also if that
wasn't enough old ie thinks that
properties and attributes are the same
so essentially let's remember the the
case I showed before when the
placeholder property gets when when you
try somebody tries to read the
placeholder property we call get
attribute and wear it and the attribute
but what if the placehold what if the
placeholder attribute is essentially the
same as a placeholder property like what
all the ethics we try to read the
placeholder property so we try to read
the place from the property because
attributes and properties are the same
for all day so what does this gives us
give us it gives us infinite recursion
it so it's not horrible it will act we
will actually make a script that's
really slow and it will return in a
stack overflow also ie8 has this other
problem with define property if you try
to use a numerable true it will throw an
error which you can catch with this
weird code and just the solution to that
is just to try to apply the accessor
again without the innumerable true just
set innumerable to false and try again
also the third thing we said is that new
elements might get added for example
through ajax through some script so it's
best if our polyfill doesn't break with
them and it's kind of simple to account
for them if we're modifying elements
that are already supported we can just
add the message to the corresponding
prototype it you might you probably have
heard that modifying host objects is
evil but in this case you're not adding
property you're not adding functions
that were there you
running functions that should be there
and everyone if no matter how passionate
they are about not modifying host
objects everyone agrees that this is a
legit case of doing that so you can even
add a method to the element prototype
which is for every element or two
specific prototypes for example HTML
input element so in that case it will be
automatically in every new instance but
if you can't do that for example if
you're making a polyfill for a new html5
element that doesn't have an interface
in browsers that don't support it you
can you should use the the Dom node
inserted mutation event so that you do
stuff when an element gets added that of
the type we're interested in of course
that bubbles too so we can follow the
same approach as we did for DOMA tribute
modified we just register a general
hunger and we check if we're actually
interested in that in that particular
element that was added also another
thing you should keep in mind is
minimizing dependencies for example
libraries like jQuery might do your job
quite easy they might make your code a
bit smaller but when you're making a
polyfill that requires jQuery you're
actually requiring that everyone who
uses your polyfill also includes a
library that's like so many kilobytes of
code especially if it's not getting it
so just to add a small feature some
people will have to include a whole
library if they're not using it already
and especially in polyfills people want
to use these latest these these new
features so that they break free from
libraries so you should you should try
to avoid it as much as possible unless
it really makes your job easier unless
your code your polyfill becomes ten
lines instead of 50 lights but if it's
like a difference like for example
well it fills it use jQuery that were
like 40 lines with jquery and there were
like fifty five without jquery is that
really worth it also when you're making
a polyfill you might be tempted to
support every possible browser to
support IE 697 and because you want
people to use it and even in big
projects that require a compatibility
with my very old browsers but sometimes
this makes your code huge and it's not
really needed to be that huge for and
sometimes you should you can use the
internal methods that a browser can have
and take advantage of them and do what
you want for example how many of you
have cared about much media and what it
does what much media is a function it's
a global function and it tests whether a
document much as a certain media query
so some browsers already supported
supported and we decided to make a
polyfill for those that don't so how
would you go with that polyfill most
people would probably try to parse the
media query expression and then check
every condition separately to see if it
actually matches but we don't need to do
that it could be much smaller but just
taking advantage of what the browser
does with media queries because the
browser already has this functionality
built in so let's see how Paul Irish
tackled this problem he creates a new
element a new dev set some types and
styles and an ID that's unlikely to
collide with another ID and then it adds
a style element with a media query and
that div style elements can be anywhere
so they don't have to be in the head
they can be anywhere in the document so
that's pretty valid and it works and
then it depends that element to the to
the body so let's think a bit about that
that's that has a media query and it
gives that L that Dave it went for 42
pixels what does that mean that if the
media query matches the document that
Dave will have a width of 42 pixels if
it doesn't it will have another width so
now to check if luck media query applies
to this document we only need to check
if the opposite width of the tip of the
dev is 42 so we actually took advantage
of the of the built-in browser
capabilities for checking media queries
and we didn't need to pass anything so
after we get that value we clean up
after ourselves remove that deer from
the body and we return the result and
because the spec is kind of weird and it
requires us to return an object even
though it might seem stupid and
personally I don't agree with that much
we have to follow the spec and return an
object Leroy like it's required with the
result and the media query passed
another example of taking advantage of
the browser capabilities is trying to
implement outer HTML other HTML used to
be a Microsoft proprietary thing but
it's now in the html5 spec and
eventually all browsers will implement
it if they all don't already so some
people might actually try to parse the
the outer HTML do something with that or
extract the innerhtml portion and then
parse parse the the the talent portion
something like that but it's actually
much easier you first check if it's an
XML document by tracking the xml version
property of the document yeah that
should be document not doc and if it's
an XML document we can't use inner HTML
or anything like that so we invoke the
xmlserializer and we're turn we see
realize that node if it's not an HTML
and XML document which is the most
common case we create a new element that
we won't actually need but it will help
us in this case and we append we close
this the node we care about getting its
outer HTML we pass the false parameters
so that we don't clone the contents as
well because think about it we don't
need to pass through to to get the outer
HTML codes we just we can just get
enraged mo from that node from the
original notes so the only thing we care
about is getting the HTML for the outer
tag so we just apply it to that dummy
element then we replace we get the inner
HTML of the new element we replace those
that thing at in the middle and we had
enriched EML then the inner HTML of the
new element is what we want it's the
outer HTML that we wanted we didn't need
to do any parsing we just used the
browser capabilities also this is
sometimes an afterthought but it
shouldn't be if you're making an HTML
polyfill you shouldn't you should keep
accessibility in mind because native
elements have built-in area roles or
they can be focusable sometimes when the
spec says they should be focused ball or
they support some certain keyboard
shortcuts like
simplest as la- slider supports being
adjusted by the arrow keys but so if
you're actually implementing a slider
yourself you should try to fake these
things to you should make it focusable
by tabindex0 you should add some area
rolls yourself and some area attributes
and you should support these keyboard
shortcuts I've seen so many sliders that
can't be adjusted with the keyboard it's
so annoying it's not even for people
with disabilities everyone uses the
keyboard also like I said before CSS
poly fields are big pain in the ass if
if you're planning to start writing
polyfills don't start from CSS
everything is hard with them parsing is
hard because we need to parse the whole
thing because if you try to go through
the CSS object model the browser will
drop stuff it doesn't understand so
there's no point in doing that you
actually have to parse the whole CSS
style sheet also implementation is hard
at least implementations done
unobtrusively we all almost always have
to add extra elements and extra stuff
and it's always so intrusive and
reacting to changes is practically
impossible I mean I has this property
change event but other browsers don't so
we can't do anything about it they're
really hard and that's why we don't have
almost any CSS polyfills most of them
are just API rappers like i said before
like functions that you call to do
something but that's not really a
polyfill so after you've done you're
done with the creative part there comes
the distribution part because you might
be satisfied with your clever code but
you actually have to let other people
know and use it and help lacombe you
like like it helps you so the first part
is making a min ified version of your
script because people will actually end
up using that but you also have to
include the original version so that
people can study it and see what you did
how you didn't learn from you but you
should also include a mini fide version
to be used for production then upload it
to get them it's like the commonplace
these days for open source code and the
last step but one of the most important
is to add it to the polyfills list I
think this is the most official poly
fields list we currently have it's not
perfect it's just the list in the github
wiki and we should definitely do better
we need the poly fuels database of some
sort but currently this is the most
complete thing we have so you can just
edit this it's a wiki you owe everyone
can edit it and add your polyfill there
so now that this talk is nearing to its
end let's talk a bit about the people
that have helped a lot in this field
first of all Remy Sharpe is the guy who
actually thought of the word polyfill
and he's written many good polyfills
that are the people actually used today
also purple irises were written loads of
polyfills and he also maintains this
list of polyfills that i showed before
and i really admire le gray too he is
very young but he's really talented he's
written so many polyfills and his
polyfills are always amazing they
they're the least buggy poly fields i've
ever seen and he knows all these things
about the inner workings of browsers
that's like crazy but it's not just
these guys there are so many people that
have helped by creating a polyfill are
improving an existing polyfill this list
is by no means exhaustive there are so
many more people and these people have
spent their time
and energy just to help all of you just
to help the community I think they
deserve a loud club for that
and you can be you can also do that you
can also help the community like legatus
calc you while developing something you
can write something you can write a
polyfill or help in by writing a feature
detection test for something that's
considered undetectable you can really
make a difference and that won't really
help yours it will really help yourself
and your day to day development and will
make your code more future proof but it
will also help everyone so go ahead and
point fill these gaps thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>