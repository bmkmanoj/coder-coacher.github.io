<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Axel Rauschmayer: JavaScript inheritance: beyond the basics | Coder Coacher - Coaching Coders</title><meta content="Axel Rauschmayer: JavaScript inheritance: beyond the basics - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Axel Rauschmayer: JavaScript inheritance: beyond the basics</b></h2><h5 class="post__date">2012-11-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NyClWddeO_A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is accelerometer and Yuki down
here you can see the URL of the slides
so you can download those if you want to
and the URL is not just here it's at the
bottom of every slide down here so you
can't miss it
what will you learn if you make it
through to the end of this talk first
let's look at the snippet and I'm
guessing that most of you have written
similar code and it's ugly can we do
better yes we can and in this talk I'm
gonna look at a library for echo script
5 that is going to be purely object
based there not going to be any
functions and that will make things very
pretty
and we're also gonna look at echo script
6 that brings a lot of very cool goodies
with it so we have classes and you have
even more let's first take a very quick
look at the JavaScript inheritance
basics and you should already know those
basics but it never harms to take
another look in class-based languages
you have two relationships you have the
instance of relationship between classes
and instances and you have the subclass
of relationship between classes and
JavaScript makes do with only one
relationship and with only objects so
you only have the house prototype
relationship and that relationship is
always between two objects so this is
what it looks like if you use a
constructor to create an instance you
get this kind of this structure that's
depicted here you have a person and a
person has been created by the
constructor person the constructor
points
- its prototype and the prototype by
default points back to its constructor
and then you have the Haas prototype
relationship between the instance and
the prototype things get more tricky as
soon as you use subtyping then you have
a lot more wiring you have a relatively
feeble relationship between a
constructor between the constructor and
the super constructor but you especially
have a Haas prototype relationship
between the prototypes which is
interesting and obviously again you have
the instance and thanks to this house
prototype relationship employee
prototype gets all the methods from
person to prototype and thus you have
the the typical subtyping thing next
object exam + that's the library I
alluded to at the beginning javascript
has several kinds of object factories
two examples are you can produce an
instance via a function and those
functions are there's other
possibilities those functions are
usually the Constructors other than that
you have objects and you can use those
and object create to produce an instance
- but then the question arises how do we
call all of that what's the the common
word for what's going on what's what's a
good word for object Factory and Alan
where sprach one of the tc39 people he
suggested the term exemplar and if you
use that term then you can call
constructors function exemplars and
whatever is going on here you can call
that object exemplars so let's look at
two examples this is the almost
canonical example of a person
you have the constructor function and
you have the prototype and to create an
instance let's call the instance Joe and
this is kind of wrong name so should be
called Joe but doesn't matter
inconsistent data if you create an
instance then you use the new operator
and that's like the standard way of
doing it but you can also create the
exact same instance by just using an
object if you use object.create you
create a fresh object whose prototype is
person dot prototype then you have Joe
who sometimes crossdressers and then to
instance to instantiate to to fill that
with data you invoke the constructor but
you do so as a method and then what you
end up with you have like the instance
show you end up with is exactly the same
as if you had created it by a new new
person and then let's further examine
function exemplars and there you have
two main entities you have the
constructor and you have its prototype
what do those entities do the
constructor is there for instantiation
and the prototype is there for
everything else so here are a few
examples if you make an instance of
check internally what you actually do is
if you if we want to see is X and
instance of see what you actually do is
you check whether C dot prototype is in
the prototype chain of X so there it's
just the prototype that matters here
again if you if you subtype if you
create a sub constructor if you extend
an existing constructor also what you
mostly connect is the sub prototype with
the
super prototype if you do a super call
obviously you need to refer to the super
method via the prototype so it's again
the prototype and if you use generic
methods it's the same principle so what
you have is prototype is used all the
time the constructor only once but then
you have to ask the question what do we
need to construct us for why wouldn't
things be neater if we only worked with
the the prototypes and then we'd always
have in we wouldn't have this relatively
complicated wiring
we'd only have a single very nice
prototype chain and this is what such an
approach would look if you created a
noun and here everything is proper here
you have Jane whose name is Jane and who
has a title and that instance is an
instance of its prototype of the
employee and that prototype is a sub
prototype of person and that object is
again a prototype ee of the library
object that contains kind of the it's
kind of the metal object protocol up
there so this is the library
functionality and it is in and the neat
thing is that that is inherited these
are extend and new methods that you
should be able to invoke on a type on an
object exemplar extend says if I have an
existing object exemplar such as person
I want to extend it and new says I have
an object exemplar such as say employee
and I want to create an instance from it
or of it so this kind of inheritance is
neat because the whole library sits up
here
so this is what it looks like in code
you see that person is created by
extending proto and it it's basically it
is the prototype and then you it has a
constructor that sets up the instance it
has a method and then you create the
employee by extending person again
prototype there's some weird stuff down
here that we're gonna look at later and
so that's it and I think that looks a
lot nicer than the snippet we've seen at
the beginning and it's easier to picture
in your head - it's easier to visualize
so this is how you use it and when it
comes to creating an instance we're a
bit tiny bit different we just call
employee dot new we're whereas with
function exemplars you would use the new
operator and if we want to check whether
Jane is an instance of employee what we
do is we just check is employee in the
prototype chain of Jane so really nice
and and if you if you visualized this
kind of the chain then just to find out
is the object exemplar in the processor
time chain that works very nicely I
think afterwards after you've created
the instance everything is the same you
have a the same old instance of you can
invoke methods on it so there nothing
much changes how many lines of code do
you think that is like raise your hands
above 50 more than 50 lines of code less
raise your hands less so it's
the thing is that's everything so
slightly cheated down here because if
used proto here which we're gonna look
at later but it's it's basically already
there you don't need a lot of code and
this whole idea of prototype chains
that's very that's like an incredibly
elegant core of JavaScript so let's look
at Eggman script six next echo script
six we'll have classes but those are
classes by name only and I really like
the the Brendan Eich video explaining
the design of it the so what they're
actually are is syntactic sugar for a
constructor syntactic sugar for a
function so in echo script six you're
going to write class and some stuff
behind it after it but what you get back
is a function so it's only syntactic
sugar but the benefits are quite
impressive because you get ease of use
especially when it comes to subtyping
you get increased compatibility between
frameworks and at the moment the kind of
it's kind of a trend or or a rule that
if you have a framework it usually comes
with its own inheritance API and that's
a bit sad but sometimes unavoidable and
thanks to the increased compatibility
tool support will be easier currently
you have to little do a lot of tricks to
get that and classes will be the
foundation for future extensions and
mix-ins are one example so this is what
it looks like and curiously it looks
almost like object exemplars very nice
very clean syntax and what tremendously
helps us is that we have the super
keyword down here so this lengthy thing
that we needed to call the soup
method that is gone and all we have is
super down here so that's very nice so
let's look at that no not yet hmm let's
look at how classes are translated the
first this should be fairly
straightforward
you have a class person and that is
translated to a constructor function and
a prototype so far not that impressive
but it gets better
because here you exchange ugliness for
beauty and everything is fairly compact
and this is the scary snippet at the
beginning and it's things are really a
lot easier to understand all you do here
you clearly see that employee extends
person you have super and it's just a
lot neater so now we look at super
references how those work internally and
you will have four ways of referencing
super properties in eco script six to
our two reference properties fairly
obvious then you can call super methods
but you can also omit the name of the
method and then what's going to be
filled in is the name of the current
method so that allows you to it's a more
concise way of calling the super method
so this is how you currently do it if
you wanna make a super call so super dot
method becomes this whole lengthy thing
here if you look at it more closely
there are actually three steps that are
performed step one is super constructed
of prototype this is where the search
for the property starts next is method
that's the property we are looking for
and we look for it in this object and in
all of its prototypes
lastly we invoke the method but we keep
the current this and that's a bit
counterintuitive initially maybe we'll
see why it makes sense on the next slide
so one thing we would like to do we
would like to avoid avoid hard coding in
step one the super constructed up
prototype we don't want a hard code
somewhere inside of the code what the
super type is and to do that we
introduce a special variable that's very
similar to this and this special
variable home object points to the home
of the methods it points to the object
where the current method is located in
and if you use home object you start
your search obviously in the prototype
of the home object not in the home
object itself you look for method just
as before and you invoke it so what you
have here this is internally this is the
semantics of a super call and then you
have here's an illustration just to look
at it again what goes on you if
described makes a super call you start
your search in the prototype of the home
object you look for the method described
and when you call it that this that this
method gets has to be the same place
because this overridden method that gets
called it has to have it has to have
access to the instance properties so
that is why this has to stay the same
you don't want to lose that object down
here you want to keep that that's where
the instance data is and if a function
up here accesses name or title you want
to make sure that the method up here
finds it and it has to find it via this
so these two values are crucial
then there's one remaining question
where does the home object come form
from if I say that it's a local variable
how do we fill in that local variable
and in order to enable that there will
be two new internal properties that
methods have one will be home object and
the other one will be method name which
allows you to do to omit the name of the
method and to do this unqualified super
call in echo script six super is allowed
only in classes but in principle nothing
would prevent the scheme from working in
any kind of a prototype chain and it
would work just perfectly with object
exemplars how are we timewise okay
excellent next another new goodie that
echo script six brings us is proto and
if you look at how to written the first
you have to solve the problem of how am
I gonna pronounce that you don't want to
say underscore underscore proto
underscore underscore so the the the
Python world has a lot of these double
underscore variables and they call it
thunder proto so that comes from the
double underscore so that's a good way
of pronouncing it and Brendan Eich seems
to like it so it'll be it's become
popular for JavaScript dunder proto what
this special property allows you to do
is you get you can get and set the
prototype of an object in echo script
five its non-standard and it's actually
and ironically been discouraged for a
while but it will become part of a comma
script six and well as that'd be a nice
feature to have it first appeared in
Firefox quite a while ago and it became
so popular that there was pressure to
add it elsewhere we currently have
support in Firefox and in v8 that means
you can use it in no chance which is
cool
and it's also available in Safari so
what are the use cases for dunder proto
without proto you have to use this ECMO
script v function object get prototype
of to access the prototype of an object
with proto it's a little bit nicer but
it's not that much of an improvement
where you do get quite a lot of an
improvement is if you want to create a
new object that has a given prototype so
here we use object.create create an
empty object whose prototype is my proto
and then and then fill it via assignment
and obviously the alternative you have
is to use object descriptors in the
second argument who've used used object
descriptors already it's it's scary so
you're better off not knowing about them
no I'm kidding but it's still it's not
pretty it's a lot of noise so it's it's
really sometimes you need property
descriptors but with Donda proto you'll
have a very nice alternative that works
for the most use cases with proto you
get to use object literals which is
always good and everything becomes more
compact then there's one more use case
if you want built-ins in JavaScript are
notoriously difficult to subtype so the
problem with array for example is that
array instances are special so if you
want to subtype array then you can't or
at least no you can't you can't create
those special instances so what you do
is and what you can do things to proto
is you just initially you create an
array and then you swap the prototype of
this instance with your own prototype
and that's how you create how you turn
the initial array the the special
instance into an instance of your own
prototype and then you return it that's
a tiny hack that's I think is used by
Bizet 2:04 so this is the interaction
and you notice that if you add an
element length is automatically
increased that is not something that you
can do by hand you can check whether
dhanda proto is support it and you do
that by creating an object that uses
down the proto and then check has the
prototype I've actually been changed and
if not you know that Thunder proto is
not support it there's one caveat with
underscore with down the proto you have
to be even more careful when it comes to
what keys you allow so if you allow
arbitrary keys then you have to be
careful because you can really wreak
havoc if you if you use Donda proto here
and there has been a bug in in Google
Docs for a while and a while ago where
if you if the first word in a Google Doc
if if that word if you type that word
and if it was done the proto then Google
Docs would crash so they can invent your
own reason why that happened internally
but they probably stored something in an
object so typing down the proto crashed
Google Docs for a while until they fix
it
Thunder proto will be an echo script 6
you will be able to use it as a getter
you will be able to use it as a nicer
object create you might be able to use
it as a setter but it might be enough to
just make subtyping built-in it's easier
that's another possibility because other
than that there's not a lot of use cases
for making Donda proto immutable you
will be able to switch it off at the
very least for some objects
possibly for all objects that's not yet
been decided conclusion there are a few
takeaways the core of JavaScript
inheritance is simple and elegant it's
just
objects and the has prototype
relationship I think object exemplars
underline that simplicity and that
elegance so they are instructive they
teach you something about Chavez about
how JavaScript inheritance works but
they're not really for the mainstream
because you want to be compatible with
other code but you still can have nicer
ways for implementing types because or
in the future because in ACMA script six
you get classes you get super and you
get done two protos so those will help
thank you
awesome Wow lots of questions let's do
it
what is the reason for keeping Thunder
Pro to separate from the normal
prototype I mean the idea is close to to
reuse the existing prototype property
instead of dangle Pro to wiesen why is
it important to keep it aside those are
different things I mean once you have
the prototype object that lets inside
that points to the prototypical object
for for the instances and if you have
with Thunder proto you have the link
between objects in in prototype chains
so those are completely different
there's an unfortunate overload of names
in JavaScript you have the the prototype
relationship between two objects on one
hand and then you have the prototype
property of a constructor function and
that is something completely different
even though that object eventually
becomes the prototype of the instances
but that naming overloading is just it's
terrible and but those are completely
different things all right sorry I
really liked the years six classes and
having a constructor Kay that's the
equivalent of the old constructor
function is there a shim for is five and
where can I get it is there a can you
repeat that shim something little by
thought that run in an as5 and the
problem with syntax is new synthesis you
can't really back port it there are a
few lightweight libraries out there that
look almost the same so and they're
really just syntactic sugar for so you
don't get really a new feature it's just
nicer syntax I was just having some
future I forgot and there are a few have
you heard of traceur it's it's a Google
project that on the fly it compiles what
you have so you can use X
six syntax and it compiles it on the fly
to ACMA script three I think and
obviously you have typescript that is
largely based on the echo script six
especially when it comes to two classes
and then has additionally has type
annotations great thank you so there are
a few solutions out there else okay cool
thank you very much thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>