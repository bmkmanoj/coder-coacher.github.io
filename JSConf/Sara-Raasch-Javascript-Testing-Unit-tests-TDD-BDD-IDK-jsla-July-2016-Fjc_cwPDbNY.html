<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Sara Raasch: Javascript Testing - Unit tests, TDD, BDD, IDK. | js.la July 2016 | Coder Coacher - Coaching Coders</title><meta content="Sara Raasch: Javascript Testing - Unit tests, TDD, BDD, IDK. | js.la July 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Sara Raasch: Javascript Testing - Unit tests, TDD, BDD, IDK. | js.la July 2016</b></h2><h5 class="post__date">2016-09-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Fjc_cwPDbNY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey everybody everyone hear me okay can
you see my slides awesome so I'm gonna
talk to you tonight about something near
and dear to my heart
testing in JavaScript we're gonna cover
a little about unit tests TDD BDD and I
don't know what the hell I'm doing so
hopefully you'll learn something quick
about me my name is Sara Raasch I am
Sara Raasch on Twitter and Sara forward
and backwards on github I am senior
front-end developer at purebred breeders
and if you are looking for an adorable
purebred puppy we can help you find one
I'm also really into knitting and comic
books a little backstory I worked at an
ad agency for six years it was my first
job out of school I launched somewhere
around a hundred websites in that time
frame across 20 different advertising
campaigns and I thought testing meant
making sure a site worked in Internet
Explorer
or Alec so I left the ad agency and I
really loved to learn testing and there
are three apps that I worked on that
really brought me around to to why
testing is great and why we should all
be doing it so got a new job hooray
I was working on a product no longer
working for clients which meant I got to
work on one thing repeatedly day after
day but the thing I started working on
was a legacy app it had zero tests it
also had zero infrastructure to run
tests
it was jQuery tightly coupled to the Dom
so if you tried to run the script
standalone they sort of all exploded
there were no front-end build tools it
was a dotnet MVC project behind the
scenes so I started working on this the
devs who had initially worked on the
project at all left the company there
was no one there to tell me how to work
on anything so spoiler alert
I broke production it was bad I cried so
I decided to fix this and within the
first six months at that company one of
the key things I really wanted to do was
add modern build tools and get testing
involved in this app so I added in grunt
which was really easy to integrate and
see the legacy framework I installed a
grunt plug-in called a contribute unit
which runs cue unit unit testing I added
in phantom Jas headless browser
integrations so that I could run all my
tests through the command line and then
I was able to write some unit tests and
it was very exciting so here's my super
simple demo
I've got a really basic grunt file and a
really basic package.json
to run these NPM packages it's just
using connect to run a local server and
a queue unit to run the actual queued
unit tests we've got a really simple
HTML file that basically just has a div
that runs the Q unit tests and some
slides in this particular demo I'm
testing revealed J s which I wrote my
slides in because it couldn't think of
anything else to write tested and then
my test file is really simple it's just
checking that when it loads it's on the
Flair slide and not on the last slide so
if I run my Q unit tests in my browser
you can see it's very exciting maybe
ah where did you go
sorry it kind of build my demos at a bar
last night so this is uh a little
unexpected yeah
all right so I'm not on the first flight
I'm on the first line I'm not on the
last slide my code works I can ship it
to production and it won't break maybe
so
woohoo I've got unit tests they're
testing individual units of code is that
what I want oh I guess having some tests
are better than having no tests right
maybe I won't break production this week
but then it turns out the actual tests
the actual site I was working on made a
bunch of authenticated API calls on load
which all required API tokens which
expired so it couldn't hard code them
into my test file and making a call to
get the API token before running the
test wasn't a unit test
that's an integration test how do I do
that well I can't actually do anything
to fix that code without refactoring the
whole app and that takes a lot of time
how can I work around that and make my
test run now there's a really great
library for that called sign in' and
sign in' gives you spies stubs and a
fake HTTP server so you can set it up
that if I hit any API endpoint I want it
returns the data I want so I can have it
pretend to hit my API and give me back
the data I'm expecting at which point my
tests all work again assuming the API
doesn't go down I'm not gonna break
production and everything's happy so the
second app new shiny app should really
stop hitting my tyre touchpad uh-huh the
new shiny app is built in Ember it's got
some tests it's maybe got 50% test
coverage better than no tests and we
start working on it and we decide well
what can we do to make this app better
now that we've got unit tests well let's
start doing test-driven
development okay sometimes we'll do
test-driven development all code
required reviews and you couldn't pass a
review without tests but generally we
wrote the test after we wrote the code
because well we're all kind of lazy
sometimes TDD says you should have three
rules of how to do your tests you can't
write any production code until you
first written a failing test then you
can't write more of a unit test than is
sufficient to fail and not compiling is
failing and finally you can't write more
production code than is sufficient to
pass the currently failing unit tests or
in my paraphrased write failing test
write code to pass fail a test and no
more repeat I don't have a demo for TDD
there was a really good talk here back
in 2014 I believe that went nitty-gritty
into how to do TDD and you should all go
watch it alright so now I've got a new
app it's got good ish test coverage
wrote a bunch of unit tests things feel
stable but what happens when I run into
things I can't read a unit test for and
that happens a lot
that's where integration testing comes
in so integration testing is built into
ember and react and angular and most
large frameworks and libraries but if
not if you're rolling your own framework
or you're in a framework that doesn't
support it karma in turn and Nightwatch
or three really popular libraries that
will do integration testing and
integration testing is going to test how
your units or modules work together so
example of a more advanced sort of
acceptance integration test would be
like visit a page enter some data click
a button and see that the data is
correct and I have a demo for this guy
sorry all my demos are an ember because
that's what I write
um so this is still using Q unit and Q
units assertion library so it's
basically just importing the module I
want to test and testing that it renders
and testing that the text on the page
renders correctly and that it hides if I
click a button so
here's my really great app you can see
my great fancy tax component it makes
text look fancy
and I have a button that is not part of
that component that toggles that text
it's uh pretty much the best website
I've built this week and I'm really
proud of it so the test
I wrote basically makes sure that that
guy renders and that if you pass in the
class that makes it hide it hides
correctly so embers test setup which is
great
automatically runs jacent on all my
stuff so I don't write badly coded code
and I can filter it by the integration
test for my component and you can see it
renders and it hides and it's very
exciting all right so my third app is
the app I'm actually working on right
now which I'd love to show you but I
can't and this app is totally Greenfield
it is an internal tool so I can support
which browsers I want which means new
Chrome and nothing else I get to do so
much TDD because I have a much better
time frame and I can settle my own rules
I've got a hundred percent test coverage
of all three of my JavaScript files
right now it's beautiful and I get to
use the latest everything and pick all
the tools so I wrote in an ember because
it makes me happy so I've got this great
new app it's wonderful how can I make my
tests even better
enter behavioral driven development so
the assertions in the Q unit testing
library are very much does this
equalness that's how the assertions are
written
which as a programmer is easy to
understand but not necessarily a great
way to transfer your requirements into
what you're testing so with BDD I can
describe what I want my app to do in
more readable language and it's easier
to translate acceptance criteria and
requirements into tests so
got another demo app you'll once again
notice my awesome fancy text component
which is still super fancy I can still
toggle my text but instead of the
standard q' unit library and assertions
i replaced it with mocha so mocha is a
BDD testing framework that lets you
choose your assertion library so I am
using chai as my assertion library so
instead of in the Q unit traditional
unit test a sort of syntax where my
certs were assert equal this equals
something else instead my assertions now
look like this I expect this is spans
CSS display to equal none so when I get
requirements from my product people who
say when I click a button something
should hide I go okay I expect the
object to be hidden making it much
easier to have my whole test suite
aligned with the rest of the
requirements for the project it also
looks cooler
um so here is my fancy new mocha and
chai acceptance tests that are failing
so that's great so what's next now that
I've got all these fancy tests I tidy s
hint into my test tasks so that if it
doesn't lint my tests automatically fail
I tied my testing task into a get hook
using an NPM task so that if I try to
commit with failing test my commits
don't go through
I added blanket J s to show my test
coverage so that's how I know that my
three files have a hundred-percent test
coverage right now and I tied all of
this into a continuous integration
environment so failing test break the
build and hopefully no bad code ever
gets out to production and I live in a
happy world where I don't break
production every week and everything is
sunshine and puppy dogs
no question there we go
it not only made it more fun it made it
less terrifying because there was no one
else at the company who knew what was
going on with this code so I'd be like
oh you want me to add this feature okay
I hope this isn't gonna be the time that
I take down all the five web servers cuz
that would be really bad it also makes
it a lot easier to refactor your code so
once you have a good test coverage if I
want to take that Levitt gissy code and
scrap it as long as it still pasts all
the passes all the tests I know that my
code still works like it's supposed to
um I cannot and I'm not on the Wi-Fi
it's on an app that's not live yet so I
can't show anything
yeah sometimes even necessary like for
instance if a client our designers in
able to see premium projects they'll see
difficult formation in a test this one
we did rather nested because you'll have
the main test for me this page right the
dashboard page right and then you'll
have a okay well if you're in the
context of a designer premium designer
or a non designer do you tend to go
heavily Nessun or do you tend to fall in
a singular context
looks like describes of you and then
context when I'm a designer who is
premium enabled or you put them in
I don't nest the nesting is really hard
to maintain and I want not only my
production app code to be clean I want
my test code to be clean
and so I in general try to avoid nesting
if at all possible so if I can separate
those out and use some sort of scheme to
make it load the context of the user
separately that would be the way I would
approach that I outside of my app holder
I have an app holder and then I have a
test folder so that I can publish my app
to production without publishing my
tests going from an environment where I
had zero test coverage to minimal test
coverage to really good test coverage it
has become vital to my development
workflow to have that test coverage not
only for me personally making sure I
don't production break production but I
work in a team and I often work in teams
with junior developers and I want them
to have that confidence to make changes
and not worry that they're gonna break
things
what we got before this was a talk in
the practical about making sure your
stuff works and I'm gonna talk about
making things weird and you want to know
your stuff works when you make things
weird so right test please so the talk
is titled use use people in the modern
working about but the secret title is
future tool ok so just follow me a
little bit as I talk to you about what I
think is like one of the best tools to
come out for modern software development
in a long time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>