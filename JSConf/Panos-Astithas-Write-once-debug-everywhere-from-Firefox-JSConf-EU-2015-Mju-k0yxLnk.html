<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Panos Astithas: Write once, debug everywhere, from Firefox | JSConf EU 2015 | Coder Coacher - Coaching Coders</title><meta content="Panos Astithas: Write once, debug everywhere, from Firefox | JSConf EU 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Panos Astithas: Write once, debug everywhere, from Firefox | JSConf EU 2015</b></h2><h5 class="post__date">2015-10-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Mju-k0yxLnk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Panos is from Mozilla, which I also
want to mention upstairs, the mozilla lounge
is going to
be doing a workshop right after this talk,
it could be
in Firefox, OS, either way, go and check it
out.
It
could be a lot of fun.
He is going to be talking to us
today about testing various browsers from
firefox, so
he'll take it from here.
Another round of applause.
Thank you, everyone.
[applause].
Thank you.
Good morning.
I am Panos Astithas and
the title of my talk this morning is write
once, debug
everywhere, from Firefox, and the title came
from my
previous experiences as a Java developer back
in the day
when the motto used to be write once, write
everywhere,
and we used to be so excited about it and
jump around,
and later we discovered that the actual state
of things
was write once, debug everywhere.
Which wasn't so good.
Then as we grew up and moved on to web development,
what
I discovered was that the reality here is
more like
write once, debug everywhere, each time with
different
tools, which is even worse.
So in a way my talk today
is about how we could make the tools we use
talk each
other, because tools, as well as people, get
better when
they communicate.
So just a few words about me.
I work on Firefox for
the past 4 years, recently as a tech lead
for Valence,
the project I'm going to be talking about
today.
Previously, I worked on the network panel,
lots of
stuff, and even before that, I did things
like service
site development, mobile development, and
I really felt
the pain of having to use different development
environments for a single project.
So this is something
that I would like to see fixed.
Today we'll talk about
the problem, and I'll speak about Valence,
the solution
we think fits the domain.
I'll talk more about how it
works, what you can do with it, what kind
of debug
targets you can use it towards, why we chose
to ship it
as an add-on instead of bundling it inside
Firefox, how
do you install it, and as an engineer, I consider
it my
moral obligation to have at least one slide
in my talks
with actual code, so we'll get to do that
near the end.
So the problem.
I'm not sure if you have recently
seen the desks of web developers who are really
passionate about their work, and have to test
their code
in many different environments from other
browsers, from
other device form factors, but the ones that
I've seen
usually look a little bit like this.
Which is kind of
insane.
You know the left one tests Firefox and the
other one tests Chrome, and in the middle
it is IE, or
iPad simulator, or whatever.
But what I really want to
do and really want to work with is something
more like
that.
Like the serenity of a single laptop, empty
desk
that has space for notebook, even with espresso
on the
side.
This is the dream, right?
So let's break the
test down.
I am your average developer, I have this web
app, this excuse of a web app, which is my
website, but
bear with me, and I want to make sure it works
correctly
across all browsers, all form factors.
How do I start?
I'm a Firefox fan, I'm most comfortable with
the Firefox
tools, so I make sure it works on Firefox
first.
You
have to start somewhere, so I use the tools,
and
I inspect my code, I debug it, I test the
performance, I
fine tune it around here, so in the end, it's
okay, I'm
happy.
I'm done.
And I want to make sure that it works
in Chrome.
So what I do, I fire up Chrome, I fire up
Chrome developer tools, and I'm presented
with
a slightly different environment.
It is not that this
is completely different, like an entirely
outlandish
piece, but more like the layout is slightly
weird to
what I'm expecting, and maybe the labels are
different
or are the same, but do something different.
I'm an
experienced developer, I can manage, put some
effort
into it, fix the quirks that manifest only
in this
particular browser, and when I'm done in move
on to the
next thing, Safari.
I start Safari, open the web tools
which are again different, and I don't see
many labels
here, I see more icons, lot of purple, maybe,
and
perhaps the motivation I have for doing this
kind of
work starts to diminish, because I get less
productive
because the tools are not working as I expected
them to
be.
And I'm not even done yet, because next I
have to
move to IE and use another set of tools which
looks
entirely different, and to be fair this is
not a failure
of the tools themselves.
They are finely crafted for
their particular audiences and do their job
well.
The
problem is that each developer has their own
preference,
and what they would like to do is use the
tool they're
most familiar with to debug a web application,
a standard web application running on all
platforms, all
browsers.
So let me remind you that we haven't even
talked
about mobile yet.
So things should probably get better.
The question I want to pose to you today is:
is this as
good as it gets, or can we do any better than
that?
And
by better, I mean something like this.
The tools that
I'm comfortable with, at the Firefox developer
tools,
being able to debug a web app running in Chrome
without
me having to switch to a different tool set
and learn
a different paradigm.
And I'm sure you won't be
surprised to know that Valence provides exactly
that,
and we'll get to how this works in a minute.
So Valence
is an add-on that we developed that let's
you debug web
apps running in other browsers, but before
I get to the
details of how it works, it will be useful,
I think, to
give you a quick idea of how the developer
tools in
Firefox are architected, the main one is a
tool piece
that has the tool user interface, the thing
you interact
with by pressing buttons, typing in ink forms
as the
client for it, and that line communicates
with the
server through the Firefox debugging protocol,
which has
its own specification which is open, and everything
of
course is open source, but even the spec is
documented.
And the debug server is mostly a container
for various
actors which are entities that control the
individual
features of a low-level platform.
Things like objects
in the JavaScript virtual machine, stylesheets,
individual styles, nodes in the mark-up, et
cetera.
Of course, in the bottom you'll have the browser
range in which contains the virtual machine,
the
rendering edging and stuff like that.
So in this
architecture, when you introduce Valence,
what it does
is extends the debugger server with an adaptor
that
contains new actors that know how to speak
to protocols
to communicate with external browsers.
So Valence
provides you with the ability to target a
remote browser
and handle those individual platform features
over the
protocol.
So Valence, what it does is it extends the
debugger
server, provides an adaptor for external browser
back
ends, it knows how to speak the WebKit and
blink
protocols, and in the future we hope even
more.
And it
does that by being asynchronous to a whole
new level,
and I'll show you a little bit about that,
and the way
we manage to accomplish that is by making
heavy use of
ES6 or ES2015, as we heard before, promises
and
generator functions.
It also includes a third-party
open source library called IOS WebKit debug
proxy,
Google sponsored the Openkit project that
provides
a thin layer of transport to IOS devices like
iPhones,
iPads, even the IOS simulator, and we also
bundle
a windows clone of that project in our windows
platform.
With Firefox, what you can do is debug your
web app in
any Firefox project like desktop, Firefox
on android,
and IOS devices, phones, DVDs, etc, and with
the
addition of Valence you can now communicate
running on
debug on android and Safari, and IOS and I
hope in the
future will provide the ability to debug web
apps
running in Explorer and node.
One of the questions I get a lot is: why ship
it as
an add-on?
Why not bundle it inside Firefox?
And there
are a number of reasons for that.
One is that Valence,
as a project, has some external dependencies
that
Firefox doesn't have.
It depends on the release cadence
of other browsers like Chrome or Safari, it
depends on
changes to the published mode debug protocol
of those
browsers, and things they might become obsolete
or
modified or broken, and what we really need
to do is be
able to iterate rapidly once these things
happen, and
the release cadence over the Firefox browser,
even with
the rapid release schedule is not suitable
for that
purpose.
In addition, we found that moving in the code
to an
add-on makes it easy to host it in a separate
github
project, so external contributors can find
it easier to
contribute, fix bugs, provide new features.
And it also
helps us minimise the development tools footprint
inside
Firefox for the users who are not interested
in
developing in debugging their web apps in
other
browsers.
So be mindful of that as well.
How do we solve this thing?
Well, we're all
engineers, right?
We know how it goes.
You go to your
terminal, you clone your stuff, you compile,
you make,
install, you run.
That's usually how it happens, but
not in Firefox, because because Firefox is
about
automating the nitty-gritty details for you.
So you go
to the hamburger menu, click on the developer
button and
then select web ID. Web ID is our entrance
to remote
debugging Firefox.
And in the runtime list, which
you'll see then is the Chrome in Safari runtimes,
because what has happened is that the first
time you try
to launch web ID it will go behind the scenes,
reach the
Mozilla servers, download the add-on, install
it,
initialise it, so you get your extra runtimes
there and
if you have an android device connected to
the computer
via USB, you will even see that in the list
of USB
devices or the Firefox USB devices or what
have you.
So pretty simple: you don't have to do anything.
You already have it, essentially, when you
need it.
Now, let's get a little bit more technical.
Let's talk
about how actors are implemented.
Firefox actors are
pretty standard JavaScript objects, and they
contain
methods that receive requests from the client
side to
perform various operations, and these requests
are
formatted in the standard way that the remote
debugging
protocol specifies.
And a simple one looks like this.
This is the function that gets called once
you type
something in the web console and hit &quot;enter&quot;.
It is on
the evaluate JavaScript function, which is
-- you can
see here it is not just entirely removed the
error
handling and some initialisation stuff, but
it is pretty
much the code that runs in your Firefox today.
So what
it does is it takes the request, it extracts
the text
property that contains the string you tie
in the
console, it uses a low level debugging PI
in
SpiderMonkey to make the evaluation of that
expression,
grabs the return value, makes a few checks
about error
conditions, et cetera, and extracts the return
value and
sends it back to the client.
It is pretty
straightforward.
Your standard JavaScript method,
I suppose.
So the difference in the implementation of
the
Valence actor, he has to do mostly with asynchronicity.
So this is the same function that is executed
every time
you type something in the Firefox web console,
hit
enter, and that expression gets evaluated
in Chrome.
If you ignore the async method helper to reduce
some
of the bugger in our product handling, is
that you see
that we generator function, star function
that receives
the expression the user sent, and then the
first thing
it has to do is go across the Chrome debugging
protocol,
make request for the evaluation, and yield
the execution
back to the main thread.
Once the result is back, it
needs to take the response and make that previewable
and
it does that by making a new request to load
preview,
and the reason is to get a more useful representation
of
the result, so that we can display it in the
web console
in a colourful, easy to expand way.
This one, another
pause until the protocol request returns,
and after
that, we will then ready to check for errors,
we have
the result, and return.
I would say that the second
method is not more verbose than the first
one, I would
say they're equally concise.
I've removed around ten or
20 lines from each that had to do with error
handling
and details like that.
But it is just that the nature
of the programming is slightly different,
and I think
for people who are not used to program with
generator
functions and promises, this will look a whole
lot
better.
How does it feel to work with Valence compared
to
what we have today?
Let's take a look.
This is me
debugging my web application on Firefox desktop,
as
before.
But the same tools I used here I can use to
debug my web application running on Chrome
without
switching tools or browsers or anything.
I can make
sure, as you can see here, I have highlighted
the image
and that's the margins and paddings were highlighted
by
Chrome's inspector underneath, but what controls
the
Chrome inspector is Firefox through Valence.
And if
I want to make sure it runs well on my iPhone,
I could
run it through Valence on the IOS simulator,
as in this
screenshot, or in an actual device connected
to my
computer, and what would happen is that the
Safari
inspector would highlight the page, but be
in direct
control of Valence that I handled through
my toolbox.
And what is also obvious here is that I really
need to
fix the formatting on my page on iPhone.
Another thing I want to stress is this is
not a need
that we discovered people must have.
People have tried
similar approaches in the past, there's a
list of
similar projects here, like in the same general
direction, so I think that this is an actual
need that
our users have today, and I think all browser
vendors
should step up and help the users be more
productive by
providing something similar.
To Valence, and of course
Valence is open source, anyone who is -- we
are happy
for everyone to take the code and reuse it
and extend
it, and to the great open source thing we
do.
And as a parting thought, I would stress that,
as an
engineer, our duty is to programme to web
standards, but
we musn't forget that we need to make sure
that our web
applications run well on the platforms our
users use.
And making sure that your program runs on
a single
platform is not cool.
It is us going back into the IE6,
days that we all are happy that are past us.
So I would
like to make sure that you can see the slides
here,
there's links to documentation for you.
I am happy to
take questions and feedback over Twitter,
my team's
Twitter handle is there as well.
There are a few links
to Valence and web ID, for main platform feature
that we
use to communicate with remote processes,
and everyone
is welcome to get involved with the code.
This is fully
open source code, we're happy to get any help
we can.
And last but not least, note that there's
the Firefox
IOS workshop today at 11, and they're giving
away bags
like this, it is in the mozilla lounge on
the second
floor, and it starts in a few minutes.
And I'll be
happy to see you there.
That's all from me.
Thank you.
applause].</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>