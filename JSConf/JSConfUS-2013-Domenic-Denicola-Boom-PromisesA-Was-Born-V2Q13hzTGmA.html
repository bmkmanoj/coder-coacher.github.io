<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>[JSConfUS 2013] Domenic Denicola: Boom, Promises/A+ Was Born | Coder Coacher - Coaching Coders</title><meta content="[JSConfUS 2013] Domenic Denicola: Boom, Promises/A+ Was Born - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>[JSConfUS 2013] Domenic Denicola: Boom, Promises/A+ Was Born</b></h2><h5 class="post__date">2013-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/V2Q13hzTGmA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">everybody here to talk about promises a
plus and a story behind that so i'm
dominic and thanks for having me happy
to be here i want to start out by
talking about what I think the
JavaScript community is greatest
strength is and I think it's that what
we do a lot is we we turn tiny
primitives into into powerful patterns
and I think one of the most amazing
examples of this in recent times is the
the es5 module systems that we've seen
crop up things like commonjs modules or
AMD modules where we've taken these
these hacks really built on top of
function factory functions and objects
and turn them into a language feature
that was missing from our language and
allowed us to create you know package
managers and an amazing ecosystem on top
of that but we see this over and over
this is a general pattern that we do
something like just modules but also we
have classes built on this prototype
hack and we have callbacks that that are
building on we pass functions to other
functions and we have streams and we
have events event emitter is not part of
the language there's no like actor
pattern built-in but we're able to do
this I mean something as small as J
queries chainable API is an example of
this that's not a language feature
that's something we've built and
essentially we just use these function
and object primitives to cobble together
amazing applications and it propagate
like the wisdom of our patterns
throughout the community and I mean it's
a bunch of hacks but it's a bunch of
practical hacks and that really fits
with the spirit of JavaScript itself you
know as as its genesis in 1995 and
Brendan Ike's like hey let's put this
lisps semantics in some java syntax and
cool let's go I mean that's that's how
JavaScript works but I think this is
also our greatest weakness I think we
become prideful in our ability to shape
worlds out of the primordial Stardust of
function we get stuck in patterns we say
that because a certain thing is easiest
to express in terms of function it's
therefore the best pattern to use in
JavaScript and more generally I think
that we assume that the best ideas are
those that can be expressed most e
Lee in terms of JavaScript and most
naturally in JavaScript and we often
refuse to learn from other languages and
the lessons that have come from other
spaces so the promise is a plus story
that i want to tell you today is a story
where we actually as a community
overcame this weakness and i want to
kind of talk about how that went and why
it's important for the future of lily
the web and the language in general so
of course we first have to have a
minimal introduction or talk about a
sink programming but you know i want to
take a step back and be more general
about this than the usual just a sink
and JavaScript da callbacks whatever
right the async programming revolution
is something that's been going on for a
long time and a lot of programming
languages JavaScript may have made it
popular but it's not the first place
these easy ideas have been you know it's
it's popular because javascript is
popular but but that's not that's not
the foundation of these ideas and and
actually javascript is actually one of
the worst languages for a sink
programming and I think the reason for
this is largely historical you know Java
scripts initial asynchronous api's came
from this this wonderful set of API is
called the DOM and we all know how
pleasant Dom API czar to work with but
that's that's where they came from so
you know essentially all JavaScript
asynchronous API is end up being in this
thing called continuation passing style
I mean here's an oj s example because
nodejs kind of tried to clean up the
doms legacy but they really they just
latched on to that train where you want
to do something asynchronous you pass a
function to another function and you
stuff all the rest of your code in there
we call this continuation passing style
you pass a continuation of your program
to somewhere else I mean no decided on
the common signature for its callbacks
kind of getting away from the doms mess
of you know sometimes we use events
sometimes we use callbacks sometimes
we'll just do whatever and and but in
and then you know most of the time it's
consistent but it never took a step back
and said what's the landscape of design
patterns for asynchronous programming
how could we kind of look at what other
languages are doing or what other
frameworks are doing or what's possible
when you want to do asynchronous program
it just stuck with what the Dom was
doing which is just continuation passing
style and I think this is generally part
of the trap that we often fall into the
the more functions trap I like to call
it you spell it MOA are and where you do
literally the the simplest thing
possible so continuation passing style
in my opinion is easy right everyone can
do it callbacks are easy but it is not
simple so easy in this sense i mean it's
like the nearest thing you reach for
it's it's a very familiar tool you reach
out and functions are there and you pass
function to other functions and you need
to do an async operation you just stuff
the rest your code in a function
everyone can do this like if you can't
do this you're kind of a JavaScript new
band and like people will make fun of
you but they kind of should because this
is a very javascript thing to do like
I'm not kidding but the thing about
continuation passing style is it is not
simple okay it is not what what do I
mean by that exactly like what what's
the difference here that I'm trying to
get at well I think the way that I've
kind of come to think about this over
the the years is that continuation
passing style traps you in something
called the Turing tar pit and this is
one of my favorite conceptual entities
it's the idea that you know because you
have a turing-complete language you can
just cobble together whatever program
you want you rebuild whatever you need
and this is often seen in the Dom or in
you know in the browser where you're
like oh I have JavaScript i'm just going
to redo all of the browser's primitives
in terms of javascript like that's
you're getting trapped in the trying
carpet but it's the same thing you're in
you're in asynchronous programming in
JavaScript land you're like oh well I
have JavaScript I have a turing-complete
language let me just cobble together an
asynchronous abstraction like using the
basic JavaScript stuff and the problem
is that as with altering carpet things
you end up reinventing basic features of
the language something like returning a
value or throwing an error or a call
stack you lose those and you try and
reinvent them by cobbling together these
crazy Combinator functions that just tie
together other functions to try and
express your basic ideas and and of
course it's not hard right everyone can
do this this is easy stuff but it's not
simple
at all and this kind of complexity that
comes out really has the kind of
maintenance and cognitive burdens that
you would expect from a complex system
you know you're always making asking
questions or you know second-guessing
yourself you're saying did somebody
accidentally call my call back twice or
you know did they call it with both an
error and a value or what's the value of
that thing I use to do things in
parallel it's like a counter sometimes
with some of this is a map but I don't
know like what did I remember to pass
with the heirs to my collar like the
answer to all these questions should
always be I don't know and I don't want
to know I don't care i just want to do
an asynchronous function call and i
don't care how like that would be
something that was simple but
continuation passing style and callbacks
in general are not simple so the way
that other languages have solved this
asynchronous function call paradigm if
you want to look to them for four
lessons is by a concept called promises
and it comes from some very old
languages jewel and e are kind of the
originator of these and these are
somewhat academic languages that that
haven't seen that much practical
application but they're really
interesting and they have some first
class to support for this kind of
asynchronous function call idea but it's
made its way into a lot more mainstream
languages as you can see you know it's
in Java it's in Python it's an f-sharp
and VF charter got into the net in
general it's in C++ now it's of course
it's in dark because dark have
everything it's and it's it's in
javascript in the form of promises a
plus and so I think it's interesting
seeing this list because generally when
you see a list like this where all these
languages have adopted this feature it
generally means either one of two things
it means that the idea is so good that
everyone had to copy it or it means that
there's some convergent evolution on a
solution that everyone agreed was a
really good one and promises I think are
a bit of both so you know to convince
you this I I don't really want to show
you how to use promises in JavaScript I
think there's there's a lot of good blog
posts on that it's it's fun it's I'd
love to you know do a little tutorial
but I think I want to kind of blow you
out of the water here and say why you
should use promises of JavaScript with
some really compelling examples so the
essential point of promises that i want
to show with these examples is to give
you bat is that you're going to get back
asynchronous versions
of return and throw so instead of
thrashing wildly in this Turing carpet
only to sink further into this callback
molasses we're going to turn our
attention to an abstraction that can
bring us back into the semantics of
JavaScript the language the one that
we're used to we're going to create an
asynchronous call stack with these
promises regaining all the semantics of
the language as just like with
synchronous return and throw an we're
going to integrate well with synchronous
return well throw and so I think for
this reason promises are fundamentally a
simple thing they allow us to compose
our stuff in the same way that a normal
language constructs would and you can
compose a string or dysfunction calls
with promises without having to entangle
your concern of calling the asynchronous
function with the functions concern of
calling your call back and so I think
the first really drastic demonstration
of this is available to you actually if
you go to Chrome Canary and turn on some
experimental JavaScript flags so let me
show you about something called
generators so this is this is actually
not promises related at the moment but
so so the idea here is you declare the
special type of function called
generator function which gets a little
star next to its name not a typo and in
the middle of these you can put
statements like yield so in this example
this function yields up a few numbers
and in between the yielding it logs some
console statements ABCD and so I when
you call the function it doesn't
actually execute any code right away but
instead it gives you this iterator
object and then when you call next on
that iterator object it'll execute the
code it'll log a and yield you this one
and what that translates to is this
object value one done false because
there's no still more code to run but
the rest of the code doesn't run yet so
this is starting to look really
interesting this is something we have
don't have in JavaScript the ability a
pause execution of a function I mean
it's still completely single threaded
and there's no like blocking thread
stuff going on here but we've paused
execution and said well let's just not
execute the rest of the code and so you
know you keep calling next do you keep
executing more pieces of the code all
the way down until you get to the end
when after you've yielded three and got
value three done false you call next
again and you get D value undefined done
true
so this is pretty magic and I think
what's really fun is that if you go to
this J's bin link and turn on your
Chrome Canary flags you can actually see
this in action you can write this code
and it works and so that's that's pretty
amazing and I'm really excited about
next version of javascript in general
but I think this is really powerful
because this idea where we pause
function execution go off and do
something else and then come back is
exactly what we need to implement
something like a synchronous code that
integrates well with our language and
with promises because they're an
abstraction for asynchronous functions
that integrate well with our language we
can do exactly that so using the cue
library and this is also code that works
today in this jas bin you can do
something where you do an asynchronous
function call to this get repo events
function I wrote which is also written
with promises and generators and you
call this you use the yield keyword to
suspend execution until it's ready to
come back and then it goes then updates
the UI and so on and i'm also using
yield down there to delay for 500 5000
milliseconds and what's amazing here and
what you don't see in a lot of these
solutions is we integrate well with the
surrounding language constructs and in
this case i'm using try-catch finally
this is not something you can see you no
longer have to do these crazy like
Combinator's to say oh well sometimes
there's an error let me handle that well
but in both cases I want to execute the
finally function but if addicts and
could throws an error that i do want to
propagate that and so on you get all
that for free because promises as a
solution integrate well with the
language and they they can be directly
dropped into a generator solution for
the when the language evolves that and
so yeah it's pretty awesome all right so
the other major thing about promises
that I think is really cool and kind of
gives you an idea of their power is it
as a bonus to just this fitting well
with the language abstraction we get
time travel as i like to call it because
promises are objects that represent
another object that will eventually be
available it's an object from another
time and so you can get a really fun
like example of this with this this unit
testing assertion I've put down at the
bottom and I have a library that does
exactly this it's called chai as
promised where you can say like I
eventually expect this object
too deep equal these things so if you've
ever done asynchronous unit testing its
mean it's easy but it's not simple as
you as I emphasized like it's just it's
a pain it's not as simple as it should
be um but you know let's let's actually
step back a second and let Justin
Timberlake tell us what school because
time travel isn't cool really I mean I
don't know what well I kind of disagree
with him but but he thinks that space
travels much cooler so so let's look at
this example so this goes a bit beyond
basic promise stuff which is usually
just then but the idea is you have is
something like a promise for a user and
you call its get method and to get a
property called repose and that actually
gives you a promise for the property
called repose and you keep chaining off
of that you say oh we're going to get
the promise for the property 0 of the
repos get a promise for the property
commit history of the zeroth repo and
then I'm going to invoke this function
so I'm going to promise for the results
of the invocation of the to HTML
function on that chemistry history and
then I'm going to display it in the UI
and then I'm going to get done and you
want to point out that in ECMO script
six with the proxies feature this is
going to look really pretty just like
all our backbone code where we do get
set blah blah blah blah well or ember
code and so on is going to look a lot
prettier but it's not just like okay
here's some nice and tactic sugar for
some common promised operations like
getting properties and invoking methods
what if i told you that the user promise
was actually a promise for a remote
object an object on another computer
right so everything here takes on a new
meaning right what's happening is not
just that we're saying oq up these
actions to be taken in the future we're
saying cue up these actions to happen on
another computer and then the computer
will say oh well he called then let me
send back what I've currently computed
the the HTML rendered on the server so
if your Twitter and you don't believe in
rendering things on this client this
might be a good way to go so I think
this is really neat because we've we've
got an abstraction that was originally
meant for kind of asynchronous
programming but essentially it can be
used for distributed programming so we
really know we're onto something kind of
fundamental here all right and you can
actually do this
today we're using a library by Chris
Cole who's sitting right there called Q
connection and in this case the remote
sources can be a web socket a web worker
or a message port which is a way of
communicating among iframes usually and
so you can get a promise using today's
like using libraries today for a remote
user object and then you can queue
messages to send across these boundaries
to remote computers or remote iframes or
whatever and so this is I think really
neat demonstration of promises that goes
beyond the normal stuff so that's kind
of the end of the promises are really
cool part of the talk and now I want to
talk about something that I think is
really impactful for kind of how how
JavaScript as a community and a language
evolves the prop the story I promised
you earlier where we overcame our
greatest weakness of the desire to build
everything and reach for the easiest
thing and and so on and so the story of
promise is a plus it it all started with
this thing called common J's promises a
and actually if you look at this message
it's it's by a guy on the the common J's
mailing list proposing to base it off of
dojos so it actually all started with
dojo which as we learned two days ago it
started everything but but the idea of
promises a and dojo promises before them
just captured the core idea of promises
from all those other languages we saw
the idea of an asynchronous computation
in an object but it had some problems as
a community created spec it was under
specified it was it was missing some key
features that all implementations
actually ended up in planting I'm it was
written in some paragraphs of prose that
were really easy to misinterpret and one
of the unfortunate consequences of this
easy to misinterpret nature of the spec
was as i like to call it moneybags
deferred so moneybags dot deferred you
know this is a this is a screenshot of a
issue tracker while I'm arguing with its
maintainer kind of saying hey it would
be really cool if you guys adopted the
promises a standard instead of this
misinterpretation of it you have and the
response is like sorry it was too
I am when I was reading that spec and I
got it wrong and now we're stuck with it
so so do too late and so they had a
really bad reading comprehension issue
they're like they missed the whole a
sink sink parallel and so these these
deferred like whatever like they they
don't match promises conceptually at all
they don't integrate all of the language
they don't do the async return throw
thing at all so they failed reading
comprehension and I think the only
realistic response to that is a Godzilla
facepalm so whatever I'll do my own
thing I recently been added to this Q
library by Chris Cole on but ice or a
solemn vow on the the grave of the Dead
callbacks that I buried that I'm not
going to let this happen again so when
you know some sometime later this this
library you may have heard of called
ember got a pull request that said adam
berg deferred mix in which implements
the promises i spec i took a look at the
code and i found out that actually those
are horrible horrible lies then and you
know we'd seen like like this this
misinterpretation of promises a had gone
on again you know and then it's really a
systemic problem and so you know the the
first appropriate response to that is of
course a double bunny face bomber but
after i was done done with that i got
really angry and i wrote wrote this this
rant called you're missing the point of
promises and this this kind of had
surprisingly large circulation which was
cool so people were listening to what i
wrote and people really seem to
understand it like the idea that oh wow
these libraries are missing the point of
promises they're just using it for like
callback aggregation they're not trying
to integrate well below the language and
provide a sane asynchronous primitive
for a value that represents like a
synchronous computation and at the
bottom of the guests i wanted to end on
a positive productive note not just like
i'm ranting on the internet i said i
would produce a test suite and once you
put something on the internet with a
promise you really have to do it
otherwise people hate you forever so i
did I produced a promises a test suite
which people started using which I
thought was really cool and at this
point actually you who to cats one of
the main people behind number J us
with me and he said yes we totally want
promises a compliant promises an ember
we don't want to make that jQuery
mistake and he created this library
called RSVP jas which is one of the more
popular promised libraries today and I
think this this was really kind of the
start of something great so here's a
screenshot of that test suite that I
created and I mean it's if I'm very
happy with with how many people started
conforming to that but then the real
magic happened so so what happened next
is this guy called Brian cavalier it
should be in the audience but I haven't
seen him there is yeah he he created
this jist or guest a gift to something
we're called promises a plus which you
know is a brilliant name I wish I
thought of it where you know we're going
to take promises a and we're going to
clarify it we're going to say how let's
put this in in like real language not a
few paragraphs let's put this in likes
peckish ty bullet points and kind of say
what exactly are the requirements that
have emerged over the last few years of
promise to implementation in JavaScript
what do we need to create an
interoperable set of promise
implementations a man and from that that
little gist we ended up with this
beautiful github pages website you can
tell that I'm a designer and it a bit in
oh really it's like it's it's a pretty
nice you know spec that we created and
it's got its own domain name now
promises a plus calm and this time we
actually made a test suite unlike the
poor promises a guys if if only they'd
known how important that was and then
jQuery well okay but so what so we
created this this spec and we put it up
on the internet and has its own domain
name Lou but it turns out that when you
write a clear and thoughtful
specification for something that people
like to do like prawns people have been
doing for a while like promises and you
create a nice test suite for it that's
very thorough then people get really
excited about implementing that so you
end up with we've ended up with over 30
implementations of promises a plus spec
and we've actually ended up ones with
actionscript Python and Objective C
which i think is pretty amazing and
what's great about this is is not that
like yes we've forced everyone to
conform because we really made
do only specify the core piece of the
promised implementation that's important
the then method and every implementation
now has a good then method which means
you can build libraries that work with
any implementation if you don't have to
choose one and say oh everybody has to
use my promises a plus implementation if
they want a benefit from my library so
this is pretty awesome and actually
there's there's another implementation
of these that ended up in the Dom spec
under the wonderful name Dom futures not
sure what that's about but Dom futures
are kind of like Dom promises and the
notes but seriously we have promises in
the Dom now and there's been major work
throughout the the what WG and the w3c
to encourage the use of these these Dom
promises these Dom futures in upcoming
api's I mean it's actually gotten kind
of ridiculous the amount of times the
mailing this post's get responded to
with oh you should use futures like
there's if you don't have an API that's
using futures you might as well just
sets them up just in case this is from
an amazing site called w3c memes com so
that's that but even more cool than that
I think even more cool than getting our
promises a plus spec into the DOM is for
es7 this is a presentation that was
recently given at a tc39 meaning there's
a slide saying we're going to try and
get these kind of cool concurrency
things in there and as part of that
we're going to try and create a promise
implementation standardize it in ECMO
script 7 in the language based on
promises a plus so so what just happened
somehow promise is a plus this little
thing we put up on github became the
starting point for any conversation
about promises in JavaScript how did we
end up like so planting promises a so
dramatically and and why am I getting
weekly queries about whether jQuery will
fix their broken promises like that blog
jquery they have so many users but
people want them to conform to my spec
like you know how did we go from some
nerd rage over a pull request to ember
22 to something that's influencing the
dom and even ECMO script 7 like how did
how do a bunch of implementers
congregating on github and doing our own
thing suddenly end up influencing the
what would in the w3c and tc39 like this
is amazing so to end my talk I want to
kind of point to some principles of this
thing
following open specification development
so so it's it's the answer the question
what made this promise is a plus effort
works so well and be so influential I
think it boils down to a few principles
of this this idea so going through them
in term like our cause of bringing sane
asynchronous programming to javascript
is this is the stuff we talked about
earlier like this is important you know
this is this is you know if something
people can get behind you can't build a
specification like this around things
nobody cares about you need to solve
real problems and you just solve them
with coherent solutions you need to have
something that people really can get
behind it have been using and need to
solve in the real world the next thing
the people right we have a really strong
and cooperative community working on
promises a plus it's led by Brian who
really did a great job you know hurting
all of us sheep into the into the github
repo to talk to each other on a good
round and we all care deeply about these
issues and we all were willing to make
sacrifices and and change our own
implementations to conform to something
that would be a core set of behaviors we
could all agree on the code so so this
is a probably the biggest reason and
this is all about what I was saying at
the beginning how we harness the
JavaScript developers you know desire to
create everything from function and
object you know we'd already done this
we had implementations like when and Q
and RSVP was starting to get some buzz
where we implemented promises in
JavaScript itself and we did this before
we manded together so so the idea that
we have these existing of limitations
that are already explored the problem
space and decided oh well this is kind
of where we're converging it all ends up
looking kind of like this let's just get
all the edge cases narrowed down and
create something we can agree on and in
short like this is code before pros
right get your code made going to get a
prolly fill as they call it like a this
is what the web api of the future
probably should look like out there
before you write down a spec it's a
everybody should follow this the
contract right so the contract of
promises a plus is a very small thing we
only spare specify the core then method
because that's enough that's enough to
get interoperable promises that everyone
can use we
been fighting over who's API to
standardize now I want the queue API and
I want the when API we didn't even
specify how do you create a promise we
just specified once you have one how
does it have to behave and this is why I
like to say that the Dom future is a
promise is a plus promise implementation
even though it is Excel for spec because
just like Q or when it's building on
this core interoperable then method that
can work with other than methods and
other libraries to create a larger
surface area that its consumers can use
and as consumers are in this case
browsers finally and this can't be
underestimated the setting of github
plays a large part in in our success
right github is where we as a community
work and play you know it encourages
like easy forking pull requests reviews
it has marked down which you know
markdown diffs are really easy to read
so if you come into a repo and you want
to see it's see what's been going on
with the specification you can actually
tell what's going on if you look at some
of the history for the w3c api's it's
this massive HTML and you have no idea
what's going on but everybody like just
that's part of like everybody knows how
to interface with github in this
community we all know how to look
through old issues how to send a pull
request how to look at diffs like this
is where we congregate and this is how
weary how we should be working and even
the w3c and the what load are starting
to get in on this they're starting to
see this they put some of their specs on
github but they haven't really made the
transition because they still cling to
these archaic old mailing lists where
with these archives that are impossible
to navigate and it's you can't really
jump into the middle of conversation
very easily and it's very frustrating
trying to get involved in the standards
process when you have to subscribe to
these things that bombard your inbox in
this like you know 1990s way so I think
github is a is a big part of why we were
able to collaborate so well so to close
I want to take a look at our our slogan
for that our tagline for promises a plus
you know we spent a lot of time getting
this right actually I mean it's it's a
bit bit silly and sometimes but in the
end I think it's perfect we end up
meaning every word the promise is a plus
organization and the standard we're open
do everything on github it's out in the
open were sound that's our cause we want
say in asynchronous e in JavaScript
we're interoperable that's the the core
contract we're providing for everyone
and we're by implementers and for
implementers reflecting our commitment
to build on existing code and to
leverage the strengths of the community
we already had so if you have all these
open specification development
ingredients in place then I think you're
in a place to extend the web forward and
this is referring to a concept that
started becoming popular recently it's a
specific philosophy champion by the
newly reformed w3c technical
architecture group and in particular by
yehuda katz brian ross or alex russell
and brian cardell who and the essential
idea is that when we build things on the
web platform it shouldn't be magic
browser ap is that go into c++ and do
crazy things and we don't have any idea
how to interface with it should be core
primitives in JavaScript that then build
on each other and allow us to create the
next version and so then we have this
virtuous cycle just like in promises a
plus where the community says oh I have
these tools I'm going to build a new API
on top of them and then the community
can compete between themselves and
refine and converge around something and
eventually a common primitive is gets
established and we can take that back
into the web platform itself all right
thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>