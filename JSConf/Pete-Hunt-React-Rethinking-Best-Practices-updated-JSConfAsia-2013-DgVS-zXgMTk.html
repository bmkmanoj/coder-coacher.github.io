<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Pete Hunt: React - Rethinking Best Practices (updated) - JSConf.Asia 2013 | Coder Coacher - Coaching Coders</title><meta content="Pete Hunt: React - Rethinking Best Practices (updated) - JSConf.Asia 2013 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Pete Hunt: React - Rethinking Best Practices (updated) - JSConf.Asia 2013</b></h2><h5 class="post__date">2014-01-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DgVS-zXgMTk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so today I'm going to talk about react
which is a JavaScript library that I
work on and we announced the open
sourcing at Jas conf us in May and we
got some sarcastic reactions to it that
this tweet was was not a compliment
so we basically challenged some kind of
conventional wisdom with react so as we
talked about it I'd appreciate it if you
gave it five minutes we've used this for
a lot of big applications on big teams
and it's worked really well for us so
I'm going to focus not on kind of
teaching you how to use react and build
applications with it because you can go
online and look at our tutorials in our
videos I'm going to instead focus on the
design decisions behind what we did why
we did that and you know even if you
don't use react maybe you can can take
those decisions and apply them to your
own projects so react we call it a
library for creating user interfaces to
get more specific that means that we
render your UI and we respond to two
events in the browser you can think of
it as the V and MVC you might want to
think of it as the controller as well
depending on your definition of MVC
but there's a big focus on playing
nicely with your stack whatever it is so
a lot of the early react success stories
were existing projects that dropped it
in on a small part of their app and they
started using it for more and more of
their application as time went on so
we're going to talk about a couple
things today the first is that I'm going
to focus on some prerequisites so we
like to combine the dom generation and
display logic rather than using a
templating system and a lot of people
don't agree with that and i wanted to
explain why we think that that's a great
idea then i'm going to go into reacts
design so what makes building
applications with react really really
fun and easy and the core idea there is
we basically rerender the app every time
the data changes and finally what a lot
of people are really interested in is
our
unique implementation so we've built
this javascript library from the ground
up using a lot of different ideas than
other libraries so I'd like to talk
about that too
so let's dive into the first thing which
is building components and not templates
so I'm sure everyone here is built a UI
with JavaScript before right everyone
has anybody used a client-side
templating library like handlebars is a
really high-quality one a lot of people
use them on the server as well so
cynically we like to think of components
as mixing markup and display logic but
we do like separation of concerns right
let's kind of the number one reason for
using a template so a templating
language basically takes in a data
structure and combines it with an HTML
document marked up with some special
directives and spits out some static
markup but separation of concerns really
isn't a specific term right like what
are concerns there it's very ill-defined
so I'd like to kind of zoom in on this
definition and talk about coupling and
cohesion so these are terms from
software engineering and we're talking
about reducing coupling and increasing
cohesion so coupling is the degree to
which each module in a program relies on
the other modules in a program so think
about the really annoying bugs or
features that you had to build in your
day-to-day like work usually the ones
that are constrained to a single
function are pretty easy to deal with
right you go in you isolate where the
problem is you fix that function or that
class and you move on you with your life
maybe add a unit test to to make sure
that it doesn't happen again the really
painful bugs and features are the ones
that you have to make changes to
multiple modules so we like to call
these cascading changes and they're a
symptom of tight coupling so kind of the
way I think of coupling is that if I
want to make a change to some piece of
functionality do I have to make a change
to this module and does it affect all
the other modules requiring me to make
changes to them and that's what makes
software really hard to maintain
another term that we like to think about
is cohesion so cohesion is the degree to
which elements of a module belong
together so you can have the most
decoupled architecture ever but if those
modules don't really make sense in terms
of the functionality that they contain
it's also not going to be maintainable
because it's going to be hard for you to
figure out you know where to make the
change because those concerns are kind
of spread all over your program whoops
so I think that templates encourage a
really poor separation of concerns and
it's not just templates it's anything
that really tries to markup an HTML
document and you know make it alive and
really make it interactive
so angularjs style directives also fall
into this category and why would I say
that because obviously when you create a
template and you have your display logic
in one file and your markup in another
file that seems like a reasonable
separation of concerns right when I want
to change the way that the application
behaves I go to the JavaScript file with
the display logic and when I want to
change the way that it looks I go into
the template and change the template
right it's actually kind of a
misunderstanding because there is an
implicit coupling between that display
logic in the template so the template is
always going to need to read some data
from JavaScript write JavaScript fetches
from the server tells the template what
to do and then the template renders it
however imagine that I wanted to
implement a zebra-striped
table so it's a data table with
alternating row colors with a template a
lot of times you have to pass along that
row color in your view model which is
the piece of data that your your
controller or your display logic passes
to your template now if you want to
change the way that that template
renders you can't actually only change
the template anymore because you have to
make sure that the data in your view
model is synced between the template and
the display logic so we actually like to
think of display logic and markup as
inevitably tightly coupled because you
basically need to update the Dom somehow
and you need to somehow couple the state
of the Dom with your display logic but
the good news is is that they're
actually highly cohesive because they're
doing the same thing right so think
about what your template does your
template generates HTML the browser
parses the HTML into dom nodes then your
display logic just manipulates dom nodes
so they're doing basically the same
thing they're both rendering the UI to
dom data structures so what we're
actually doing when we're using
templates and display logic and
separating those out we're set
technology's not concerns and the
problem with this is that the
technologies that we're separating are
deliberately underpowered so I'm going
to pick on handlebars for a second which
is an extremely popular open-source
JavaScript templating solution and it's
a great one it's really fast it solves a
lot of people's use cases but it falls
into the common trap of templates which
is you rely on primitive abstractions so
for example if you want to reuse a
template the kind of standard way to do
it in handlebars is to use something
called a partial and a partial is a mini
template that you can include in other
templates so think of if you wanted a
profile pic component on a social
network and you reuse it all over the
place you would use a partial to
implement that now the problem is you're
basically copying and pasting in this
partial into a template and it gets all
of the variables that the parent has in
the in the current scope this is a whole
bunch of implicit dependencies now so
because the the child template or the
partial may be reading from any one of
these variables you have to go track
down every single call site that the
partial is being used in order to make
sure that it's you know being updated
correctly when you want to make a change
to the partial and another symptom is
relying on kind of flow control
abstractions like each so each basically
iterates through each item of a sequence
and emits some markup in a traditional
templating language what if you want to
kind of change the way that you iterate
over the list or what if you want to
insert two pieces of markup where the
templating language only thought you
would want to do one per list item it's
it's just difficult to deal with because
you don't have the power of a full
programming language you have the power
of a template language which is
deliberately underpowered so there are
some other symptoms of this I talked
about marking up an HTML document with
directives to bring it to life now in
order to do that you're basically trying
to
a new way to express program semantics
in a document so you're kind of like
creating a new programming language now
the problem with this is that the way
that that people are building these
abstractions on the web today
they don't accept that they're building
a new programming language so you have
to invent a lot of new concepts that are
slightly incompatible with you know a
real programming language that we have
today JavaScript so angular is hugely
popular these days so I obviously have
to pick on them and I've pulled this out
of the angular directive stocks which is
the way that you mark up a HTML document
and you know connect it with the
JavaScript part of angular and I've
highlighted all of the new concepts that
they had to create that are already in
JavaScript and that you have to learn so
there's a lot there and the point of all
this is that a lot of the ways that we
build applications today the the
frameworks and libraries we use um try
to tell you how to separate your
concerns for you but we don't think that
the framework can do that like your
application you don't think of your
application in terms of models views and
controllers you think of your
application in terms of user profiles
and navigation bars and you know posts
on a timeline or something like that so
we think that the framework of the
library you're using should just give
you tools for you to express your
program in the language of your problem
domain rather than the language of the
framework itself so the tool that we
came up with was a react component and
it's a highly cohesive building block
for building UIs and that is loosely
coupled with other components and so
with react even though we're combining
the Dom generation part of your UI and
the display logic that drives it we can
actually separate our concerns in a way
that matches your application better by
using components with the full power of
JavaScript rather than relying on a
crippled templating language to do it
for you so here's a very very quick
example of some react code like I said
this isn't a tutorial I not going to
dive in too deep
but I just want to point out some things
with react when you want to reuse some
code and you know or handle an event or
something like that we don't create a
new type of abstraction for you you
don't have to create a partial or
something you create a JavaScript
function and you call the function and
the best part about that is that you can
then link the function or you can unit
test the function and you can take
advantage of all of the great tooling
that javascript has today another thing
that's really important to note is
composition so one of the things that we
identified building large apps early on
is that composition is pretty much the
most important thing when building
applications so being able to reuse
components and build components out of
other components and finally I've
highlighted expressivity so you can
actually use regular JavaScript
expressions inside of your display layer
because sometimes you actually need the
full power of JavaScript to do it you
shouldn't have to jump through hoops to
add 1 to 0 index you know list item or
something so anyway the important
takeaways are that components are
reusable and they're composable and
they're unit testable because they're
isolated units
so if you're used to building templates
and if you have a lot of experience on
legacy code or legacy PHP code bases
like I do
you're probably concerned about
spaghetti code so we're not advocating
going back to the world where we call
like my sequel fetch row in the middle
of your data table rendering code that's
a terrible idea so my answer to kind of
ask you about spaghetti code when we
combine Dom generation and display logic
is just don't write spaghetti code keep
your components small and only put
display logic and components we're all
you know engineers here working on the
web and with great power comes great
responsibility no matter what framework
library toolkit or language you're using
you can write spaghetti code in it just
take action to use good design
principles and avoid it another thing
you might be concerned about is security
specifically cross-site scripting
vulnerabilities so one of the main
advantages of templates early on was
that you weren't generating markup and
strings and generating markup and
strings is pretty dangerous because you
might accidentally concatenate a
user-provided variable and that might
contain you know a script tag that then
steals someone else's cookies and then
can post on their behalf it's pretty
dangerous so we're not building you know
strings of markup with react we have a
small library called react Dom that
generates a representation of the Dom
for you so if I wanted to create a link
for example I call react Dom A which
stands for an a tag for link the first
argument is equivalent to the HTML
arguments or attributes and you just
pass it in as a regular JavaScript
object so right here it's a link to my
Instagram account and then the second
parameter is you know an array or
another react component or a string that
represents what should be contained
within this tag and that library
automatically escapes everything for you
so if you put you know HTML in there
it'll be escaped so we want to generate
this Dom representation with a bunch of
functions that look like this
right if you work with designers and
I've worked with designers they really
don't want to do this they're really
good at Photoshop and and you know
working on HTML mock-ups but they don't
really want to maintain all of this code
at the same time I don't want to spend
four hours tweaking the box-shadow
of my my components I just want to get
like 90% of the way there then let the
designer like pixel push so working with
designers is really important so we
built an optional syntax extension
called JSX let's use an HTML like syntax
with react so one thing that's important
to note is that this is completely
optional and you don't need to use this
to use react and the same is true the
other way around
so JSX can be used outside of react if
you want to so what JSX will do is it'll
take an expression like this embed it in
a regular javascript file and it will
translate it for you to this the exact
same code that I showed on the previous
slide and with JSX we found that it's
very easy for designers and people of
all backgrounds to contribute code to
react based projects so we like to think
of it like this the accessibility of
templates and the power of JavaScript
you can go in and the code looks
familiar but you can use all the
powerful JavaScript abstractions that
you're used to do all the functional
programming you want all right so I've
talked about have I convinced you guys
the templates are a bad idea
I hope so we're going to move on so the
next I'm going to talk about is what
makes react really cool and really
interesting and really fun to use and
that's rerender entire application on
every update so we've built a lot of
applications and we identified that
state is what makes building UIs
particularly hard so if you've worked on
anything in the backend before a lot of
times you can kind of unit test your
code and it feels really solid and you
ship it and then the unit tests break
and that's a real failure but with UI is
there's a lot of variables and a lot of
state and a lot of relying on like does
this UI feel right or does it look right
and this is you know there's a lot of
stuff going on here there's lots of UI
elements
the fact that we are pushing to you know
heterogeneous environments is is also
hard having a big mutable Dom that you
have to keep track of is also very
difficult and there's user input that
you might not expect that kind of thing
in particular data changing over time is
the root of all evil that's what we've
identified anyway we're not the first
people to come up with this though some
famous computer scientists agree Dykstra
says our intellectual powers are rather
geared to master static relations and
our power to visualize processes
evolving in time are relatively poorly
developed so what he's saying here is
that we can understand how a single
function works right we can look at the
inputs and we can look at the outputs
and we can figure it out but when we
call this function over time and we set
variables that might change in ways that
you don't expect it's very hard for us
to keep that program in our head so for
that reason we should do our utmost to
shorten the conceptual gap between the
static program and the dynamic process
to make the correspondence between the
program and the process as trivial as
possible
what Dijkstra's saying here is make
programs that execute over time make
them look like item potent functions
that execute at a single point in time
he's making an argument for functional
reactive programming so if we like turn
it back to 1999 when we were writing
that PHP spaghetti code that executed on
the server
everything was actually easier right if
I wanted to submit you know a new to-do
item to my to-do list I didn't have to
keep track of every place where I put
the the number of to-do items in the
list in my DOM and update each of those
when it changed
I simply submitted to the server the
server wrote it into the database then
selected all the information out of the
database again and re-render the whole
page conceptually it's really simple to
manage data changing over time since you
just rerender the entire page and it's
very easy to visualize that because that
process is a single point in time rather
than evolving over a point in time
so react borrows that so when your data
changes we rerender the entire component
we throw out your old
representation we call all your render
methods again and we have your new
representation set another way react
components are just item potent
functions that describe your UI at any
point in time just like a server
rendered app and because of this they're
actually you get this nice side effect
of being really easy to unit test you
don't have to write code that you know
clicks on this then clicks on that and
then updates this and then asserting on
the Dom because react just takes some
inputs and provide some outputs and the
the system handles the rest so let me
show you what I mean here here's another
little code sample this is a clicker
component where basically all you do is
when you click this link it increments a
count and displays the count so the
first thing that you you want to keep in
mind is that nowhere do we search for
this Dom node and rewrite the count
we declaratively say hey this render
method says what this component should
look like and it doesn't say here's the
initial state and here's how to update
that state it's just render is called
whenever the data changes and we said
that that mutable state is is the root
of all evil or data changing over time
is the root of all evil but we do need
mutable state in our applications
what react does is it isolates it as
much as possible so you can see right
here the only piece of mutable state we
have is this thing called count and the
initial value is zero very simple to
read and we've we kind of highlight it
in the way that we've designed the
framework then another important thing
to know is not only what is the the
minimal representation of the state but
how does that state transition over time
and so all you do is search for the word
set state and you know all of the places
where your state will transition we make
this very very explicit so when you go
in and reread your code and try to find
a bug it's very clear all the places
that you need to look and so by
rendering you know every time the data
changes it's very simple you don't have
to track down every single place where
that count is rendered it's always
guaranteed to be up-to-date and we do it
without setting up magical data binding
so nowhere did we set up a computed
property nowhere did we you know
register things for change tracking or
set
some sort of data binding we do it
without expensive model dirty checking
with just re-rendering and of course no
more explicit Dom operations everything
is declarative everything is declarative
it seems like a pretty bad idea right
because it seems really expensive to be
calling these render methods over and
over and if we destroy the Dom every
time the data changes if you're in the
middle of typing a comment your text is
going to be the lost or your scroll
position will be lost or you're going to
get that flash of unstyled content every
time the data changes and it's just
going to be really not performant so we
can't do this to the real browser Dom we
can't be rerender so what we did is we
built a virtual Dom which makes rerender
on every change really really fast I
talked about a lot of reasons why we
can't just do this rear end during but
we can rerender to the virtual DOM and
it's optimized for memory footprint and
and just high performance so I'm going
to talk to you a little bit about what
happens behind the scenes when we do
that update so on every update we
generate a new virtual dom subtree this
basically means that we call that render
method again and we take the the return
result or the return value then we take
the old return value and we dip it with
the new return value by doing that we
can compute the minimal set of Dom
operations needed to bring the UI
up-to-date and then we put those into a
queue and then when the time is right we
batch execute all of that the operations
in the queue at once there's any game
developers in the audience you will
understand that this is a lot like a
game engine so there's a great series of
blog posts online about how the doom 3
engine works so at a very high level
you've got something called a world
state which is basically a series of of
user input events and the current state
of the world that gets dumped into the
game logic or the front end of doom 3
which basically says here are the
rulz here's how people move around in
the environment here's how doors work
here's the set of weapons you can use
then that generates something called a
scene intermediate representation which
is a description of what the user should
see so the user should see you know this
enemy at this XYZ coordinate at this
point in the map and the door should be
50% of the way open then that goes to
the back end of the rendering engine
which generates opengl operations and
flushes those to the graphics card make
sense
here's reacts architecture we have
application state and browser events so
that get initial state method and then
we have events coming in from the
browser you know clicks or key presses
or whatever then rather than game logic
and you know 3d levels we have your
react components that you've described
that's the business logic of your
application that renders to this virtual
Dom then we do that diff on the back end
and we compute the minimal set of Dom
operations and then we flush that at the
appropriate time to the browser rather
than OpenGL operations to a graphics
card and this is actually really fast
and one of the reasons this is really
fast is because JavaScript is extremely
performant relative to the Dom so every
time you touch the Dom with a few
exceptions um you're paying you know a
pretty heavy price so if you add a Dom
node you have to recap the style and
that can cause cascading changes so the
fact that react computes minimal Dom
operations really saves you a lot of
performance now keep in mind that react
is not magic and not a silver bullet
here so react will not suddenly make
fundamentally slow operations faster
this is kind of equivalent to you know
you can always beat a C compiler if you
write an assembler but the fact is is
that you can write code with react and
out of the box it'll be pretty
performant and one of the real
advantages here is that we batch read
and writes for optimal Dom performance
so if you're doing manual Dom operations
to really squeeze that last ounce of
performance out of the Dom it's very
hard to do that at
scale and by scale I mean for a big
application worked on with lots of
people and the reason for that is that
there's a phenomenon called layout
thrashing so I'm not sure if this is
there's there's a couple great blog
posts about this but basically when you
write to the DOM and then you read
certain properties off of the Dom so you
measure the height of something that
forces the browser to basically update
the Dom compute where all of the
rectangles are and then return the
measurements for you and then if you
write to the Dom again it may trigger an
additional layout Frash so if you're
doing manual Dom operations it's very
hard for you to basically enforce that
hey we should do all of our reads
together globally and then we should do
all of our Dom rights together globally
and we should not fresh but what react
does is since react operates only on a
virtual Dom it can manage those reads
and writes for you so it's basically
optimizes globally for your application
all of your reads and writes and batches
them together and because of this we
usually be manual Dom operations and
there's some other cool performance
tricks in there as well so if you're
familiar with a technique called event
delegation it's a way to manage memory
of event listeners so imagine you have a
big data table with a button on each on
each line the naive way to listen to a
quick event on those buttons is to add
an event listener for every button
however you have to pay a little bit of
a memory penalty for each event listener
you add so the high performance way to
do it is to add a single click listener
on the whole table and then when that
gets a click event look at the event
target and figure out which button was
clicked with react we have a full
virtual DOM and a full virtual event
system so we implemented bubbling and
capturing ourselves in JavaScript you
can go see it on github and we do this
top-level event delegation for free and
because we have our own implementation
of events you actually get full w3c spec
html5 events as far back as IE 8 which
is pretty cool so
let's say that react react is pretty
fast for most applications but sometimes
you really need to squeeze that last
ounce of performance out so we have some
hooks for custom updates where you can
tell react hey this part of my
application is going to be largely
static so don't even worry about
managing it normally for most
applications we don't need to use this
but if you do it's usually these methods
are usually about one line of code and
they can get you know a 10 times speed
up depending on on what kind of
application you're doing but at the end
of the day we really really value
performance and we look at performance
in terms of dropped frames so you can do
all of this at 60 frames per second even
on a mobile device and for us you know
Mobile is is really where a lot of the
growth is these days and so if it
doesn't work on mobile then you know
it's not worth doing so I'm going to
show you a little video demonstrating
reacts performance on this example is
also on github what I'm going to show
you is react doing this virtual Dom diff
and rendering and flushing every single
requestanimationframe which means that
realistically it has to execute in under
10 milliseconds I want to point out that
there's not a single CSS animation or
transition in this and there's no
overflow scrolling so what react is
doing is there's a great library called
Zynga scroller which can interpret touch
events and then give you the scroll
position and what react is doing is
taking that scroll position updating a
state variable and then doing that
virtual Dom diff and rendering so I
don't really use PowerPoint that much
but I hope it works so this is a left
nav remember there's no CSS animations
we're actually animating two content
areas one that's that's blurred and one
that is not blurred to simulate a
frosted glass overlay effect and we're
doing um kind of some 3d transforms
there but we're writing it all in a very
declarative style so it's not like oh
this interaction needs to be
high-performance so we can't use you
know our reactive data flow the point is
that while you can do this in any
library you usually have
step outside of the the reactive flow or
the data binding system but with react
this is the level of performance we
really strive for and it makes you know
creating these sorts of applications a
lot easier because it's declare writing
your code in a declarative style is just
really nice so there's some other fun
things that we can do we can run in
node.js and this is actually really
really interesting I think so I think
that the the term that people are using
now is called them isomorphic JavaScript
but basically there's a little bit of a
problem when you do a lot of client
rendered you is that when Google hits
your page it doesn't really see any
content it just sees a mostly empty HTML
page with some script tags in it and
then it ranks you really lowing it on
the search results so what a lot of
people are doing these days is basically
if they see Googlebot they'll render
their page in something like phantom j/s
which is a headless version of WebKit
and then they'll send down an HTML
document just to Google the problem is
you can't do that at scale it costs a
lot it's just booting up a Dom for every
web request is really expensive and you
also kind of can't benefit from from
giving that same experience to your end
users so if you were to send down a
static HTML page to your end users they
could start interacting with your page
immediately and then when the JavaScript
boots up it would respond to
interactions and that's what what react
can do so react can generate a static
HTML file send it down to the client and
then when you call that render component
method it'll look at the mark or a
little look at the Dom and say hey it
looks like I rendered this on the server
I don't need to generate any Dom nodes I
just need to attach my event listeners
and get started so you get a really fast
initial page pagelet experience which is
great we can do some other cool things
too so since you're not rendering to a
Dom you're rendering to a virtual Dom
and the things that you're rendering our
components that represent the language
of your application we can do some
optimizations based on how your
component structure is changing so for
example if you click on a button that
navigates you from say
your timeline or newsfeed sorry from
your newsfeed to your profile page we
can say look and say hey a high-level
component type is changing we should
probably use a certain strategy for
clearing out a large subtree of dom and
replace it with this other other one and
we get that rich information because
you're building with components not
building with templates that are tied to
the Dom I mentioned this before when we
were talking about modular components
but you get testability for free what I
mean by this is since we don't depend on
the Dom you can simply fire up a react
component and render it to a string with
a certain set of properties and then you
know write your assertions on that you
don't have to do like a selenium or
webdriver kind of setup to get that that
rich testing because again we're very
very divorced from the browser my
colleague Sebastian who's sitting over
there did some great work with building
SVG vml and canvas support for react as
well so like I said we render to a
virtual Dom not a browser Dom so we can
have a new virtual Dom implementation
that represents the canvas rather than
the Dom primitives so you can use react
to build not only the rich interactive
UI of your web app but also drive the
same interactive charts or graphics that
you know maybe you're in newspaper and
you want to do a visual data
visualization or something just one
paradigm works works on multiple ways to
render and I have an experimental branch
that runs your whole application in a
web worker again virtual DOM and virtual
event system means that we can swap out
all of this stuff and run it in an alien
environment so this this branch was
about a hundred lines of code and all
that we had to do was basically
serialize the browser events from the UI
thread to the web worker and then send
the Dom operations from the description
of the Dom operations from the web
worker to the UI thread and then update
my in the UI thread now I'm not sure if
this is a good idea but it's interesting
anyway and it has the promise of maybe
you know reducing the amount of work on
the UI thread and having more responsive
browser interactions
all right so let's review kind of what
I've talked about build components not
templates rerender don't mutate the
virtual Dom is simple and it's fast and
there's one other thing so we announced
that we were open sourcing react at Jas
comp us and this is our first time at
Jas conf Asia so we wanted to announce
something here too so we're going we
basically are on the verge of open
sourcing our react dev tools which lets
you inspect this virtual Dom
representation in the Chrome web
inspector and we'll be giving demos of
this you know after I guess after the
talk or something just go find us so
here are the the chrome dev tools that
you know and love and if we zoom in on
the bottom here you see some markup and
it's it's a little bit unwieldy so when
you switch to the react tab now we see
the language of our application here so
as a developer I can go in and say oh
you know there's my image block layout
or there's my story and then if I were
to change that property on the
right-hand side viewer has liked from
false to true that little heart would
show up on the on the UI indicating that
I liked it and my name would also be
added to the list of people that liked
the photo because react guarantees that
your app is consistent so that's about
all I have to say today I really
appreciate you guys having me and I hope
that this was was helpful Thanks
all right so does anyone have any
questions
hi how does this compare to web
components that's a great question so
web components is a big constantly
changing specification and it's there's
a lot there's a lot to say about it one
of the things that we focus on a lot is
composability so really really deep
building components out of other
components and I don't think that
historically web components has been
focusing on that aspect and there's a
lot of nuance there so data flow between
you know a parent component and a child
component
additionally web components is a bunch
of different technologies so shadow DOM
is one big part of web components and
that's a that's a really interesting
important part of kind of pushing the
web forward and that's something that we
could take advantage of one kind of
philosophical difference between web
components and react is kind of how we
perceive the Dom so web components fully
embraces the DOM and adds new api's
react kind of hates the Dom and puts it
away in its own little corner and we
only interact with it through message
passing basically and one kind of
advantage of that is that we can do
things like render on the server and get
a faster initial page load experience I
don't think that web components has
solved the problem of rendering on the
server and basically doing a
non-blocking like page experience is
there any way of doing transitions
between brenda's so like CSS animations
yeah any kind of transition so we have a
component called react transition group
actually that will look at kind of how
its children are changing so if you add
a list item for example you can
implement a custom transition behavior
so the default one that we have behaves
a lot like an animation library for
angular called ng animate so we'll add
CSS classes for you so it makes it kind
of trivial to add kind of fade in
behaviors and that kind of thing you can
override that behavior and have
some transitions between Dom States if
you'd like though hi um I was wondering
if you have non react code running on
the page like you have a jQuery plug-in
that goes in adds a class to a Dom
element directly um
and then react thing rear Enders how
does it figure out or does it figure out
that it should leave that class there or
does it say oh the difference that class
was removed um this is a great question
so react kind of from day one had to
interoperate with with legacy code so we
have a set of lifecycle hooks that
basically you know they look a little
bit like the objective-c cocoa API so we
have component did mount and component
will unmount which basically tells they
fire when the component is initialized
on the page and there's a Dom node
available and they fire when it's about
to be destroyed so what you can do is in
you render a div for example as a react
component and then in component did
mount you boot up your jquery plugin and
then we have another hook that says
component did update which means there's
new data available so then you can
bridge from the react the new data that
react has gotten and tell jquery hey the
data has changed and then in component
will unmount you just destroy your your
new jquery plugin um maybe this seems
like a really obvious question but if
this um renders really fast on mobile
does that mean it's going to be find its
way into a new like reborn facebook
hybrid application um i don't work on
the the facebook mobile site team so i
don't know what their road map is it's
used all over Instagram calm though like
the web properties
Thank You peep go the cleanse for tea
please</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>