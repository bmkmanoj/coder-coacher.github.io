<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Mark Dalgleish: The End of Global CSS - CSSConf.Asia 2015 | Coder Coacher - Coaching Coders</title><meta content="Mark Dalgleish: The End of Global CSS - CSSConf.Asia 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Mark Dalgleish: The End of Global CSS - CSSConf.Asia 2015</b></h2><h5 class="post__date">2015-12-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/W17YAEmjeqY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everybody as you heard my name is
Marc devilish I'm here from Melbourne
Australia
and I'm here today to talk to you about
the end of global CSS which is a lofty
title but hopefully by the end of this
you'll understand why a lot of things
have been changing in the CSS space a
lot of people trying new things and it's
definitely something I've been a part of
and I'm really excited today to share
some of the work myself and a few others
have been doing to really try and
rethink how we build our applications
with CSS so to put all of this in its
proper context I think I first need to
take you back to the beginning really to
the beginning of my career essentially
for me personally it all began with this
book now this book is not a classic it's
just a random HTML book I picked up in
99 I wasn't a programmer I wasn't
dreaming of becoming a programmer I just
loved the web and I wanted to be part of
it somehow and this for me was a natural
place to start now it has a chapter in
there chapter 13 which is all about CSS
now at the time in 99 CSS wasn't quite
ready for primetime and that's what this
summary says but everyone knew that CSS
was really gonna change the way we think
about styling our our websites it's
already been covered this morning
actually that CSS is in garden is
something that was was really what
convinced me that that CSS was something
you could really fall in love with CSS
Zen garden the whole concept as you
already heard today was was about taking
a document and completely restyling it
just by swapping out the CSS so just by
changing the CSS you could go to a
completely different look and feel and
this really you know in it at the time
proved out a completely opposite
approach to what we were doing with
things like table based layouts where
and font tags where the design was
tightly coupled to the markup so CSS Zen
garden presented a really great way
forward for us as a web community but as
we move forward in time we get a bit of
a clash between the the techniques
presented in CSS Zen garden and how you
build a complex web application
while one is just a basic document
basically a glorified version of what we
were doing in things like word web apps
are a very different environment and
entirely and the problem with that is
that when you when you're restarting a
document the global scope of CSS is a
good thing you want to be able to
restyle any element on the page very
quickly very easily but that comes with
a maintenance cost when you get into the
world of big complex applications with
lots of nested components over the years
in the CSS community we've come up with
a lot of techniques to try and tame the
the problems inherent with CSS at scale
we've got things like oo CSS which
arguably kicked us off other techniques
like smacks BEM suits and now
controversially in the react community
inline Styles is actually a feasible
solution to this problem but they are
arguably the most popular solution out
in the wild is been block element
modifier and ultimately it's just a
naming convention it's a way of
restricting yourself in in the way that
you use your CSS so that you can make
this technology scale and you can scale
it over a long period of time and have a
code base that's actually able to be
maintained able to be refactored which
for legacy CSS code bases was basically
impossible when you apply BEM to your
markup you get something that looks like
this it does get quite a bit noisy so
obviously there was a bit of a cost in
terms of the pure aesthetics of working
with them but for those of us that kind
of got over that that initial distaste
of the markup we ended it was something
that was definitely a big step ahead of
where we were with CSS in the past the
the challenge here though is that CSS at
scale when you're using something like
them feels completely different to what
you were doing in the world of CSS is in
garden the techniques you had to adopt
were completely different and there was
definitely a learning curve people who
were good at CSS were not necessarily
good at CSS at scale and that was a real
problem particularly when you're working
in a team environment but this problem
of scaling interfaces is not unique to
CSS of course this question has been
asked everywhere and in the in
javascript community in particular in
particular we've now basically arrived
in what I call the age of components if
you look at the landscape at the moment
and what people are using to build rich
single page page applications you've got
of course web components landing is a
standard part of the web platform
you've got polymer poly filling nuts you
can try to use that today angular is is
all about directives and directives are
about basically turning HTML to a DSL
powered by components but the one that
I've been focusing on lately it's been
getting a lot of traction is react for
me the big reason I've picked react is I
can render it on the server so I get all
the benefit of components without
sacrificing progressive enhancement
which i think is very very important but
components are nothing new components
were not invented on the web but even in
the earliest days of the web we had a
basic set of components you had things
like select select box with options in
it its html5 date input these things
came with a lot of inbuilt behavior you
just got for free you just drop a simple
tag in your markup and all of this rich
run interactivity is now provided to you
and the interface is very very simple
but the the important thing to note here
for the purposes of this talk is that
CSS and images are private to a
component at no point do you have to
worry about the styling or the images
that a browser might need to render
these things they're completely abstract
it away from you and that of course came
to a screeching halt the second you
wanted to use a third-party component so
taking the canonical example of the
jQuery UI date picker
just having a date picker you've got
over a dozen files images CSS JavaScript
and it's your job to integrate this into
your project which was not necessarily
the simplest of tasks certainly doable
but a lot more work than should be
necessary
and now El tools reflected this model
for the longest time you look at a build
tool like gulp for example and the
standard way we would work our gulp
files would look something like this you
might have a task for your JavaScript
that runs it through something like
browserify maybe uglify you've got your
CSS tasks which might run it through
sass or less or post CSS you've got your
images tasks as well and so on
you were you would definitely sort of
encourage to separate everything by file
type and everything was in these silos
this of course continued into tools like
SAS where you know ultimately SAS only
cares about your CSS so what that ends
up causing is something like this an
index dot s CSS for example where
essentially it's just a wall of imports
because SAS has to know the full tree of
styles in your app but seth has to start
somewhere and this is your entry point
but what do we do in the component age
like is there a way that we can rethink
our tooling and luckily for us there's a
really great example in the form of web
pack web pack is basically the default
choice in the react community and for
really good reason because web pack
encourages us to think in terms of a
single dependency tree across all of our
asset types so rather than the standard
folder structure in your in your project
where you might have JavaScript over
here CSS images and fonts in a different
place you're much more likely to
structure up like this where you've got
a components directory may be nested
levels of components directories as well
and inside each of those we have a
folder for each component that component
has the JavaScript or CSS and any images
it needs to render and web pack gives us
a really great way to manage this
because if you look at here we've got a
basic react component the very first
line we're actually requiring a CSS file
so we're making it very explicit that
this component depends on some CSS in
order to render correctly whereas
previously that that dependency between
the markup and the CSS was basically in
your head and scattered throughout your
entire project the great thing about web
pack is it can traverse these links or
even into your CSS so web pack follows
follows the lead into that CSS file and
it can see that you've got a background
image here of an icon SVG and web pack
knows that it now needs to include that
image in your in your final output so
here we have one build tool traversing
multiple asset types and you can figure
that with loaders so you've got things
like style loader CSS loader post CSS
less sass URL and there's a whole bunch
more and this is the way you tell teach
webpack about how to understand these
different file types you can figure it
like this you don't have to understand
this to to any large degree right now
but the point is that you tell webpack
if you CSS c s CSS file i want you to
run it through this chain of loaders go
through post CSS CSS style and so on but
what's great is that when you use these
components you maintain the simple
interface you just import a component
and render it if you're building a
reactor and all of the internals of the
different asset types are obstructed
from you so how does BEM fit into this
world of components well luckily a block
in BEM is really the same abstraction as
a component in something like react it's
dealing with the exact same problem in
basically the same way so this leads to
a very simple rule of thumb which is
that you should never use a block in BEM
outside a component of the same name so
that looks something like this again if
we revisit this folder structure we've
got our component directory with the
JavaScript the CSS in the image if you
look inside that CSS file it's called my
component dot CSS and inside you'll
notice every single selector starts with
my component we're essentially emulating
local scope here that file only affects
the the JavaScript in the same file in
the same folder so to visualize that
what we've got is for every CSS file in
this project we've got a matching
JavaScript file that forms a natural
component boundary and the great thing
about components of courses that they
compose really nicely into a tree
structure forming the basis of your
whole UI so now we've got a way of
scaling our CSS really really nicely now
this is where personally I thought I was
going to end with this technique for
quite a long time I wrote about it in a
blog post called block element modifying
your JavaScript components and this was
something that I thought was going to do
us well for a long time work really
really well but luckily in the meantime
some really interesting developments
were happening in the web pack space web
pack landed in its CSS loader and an
experimental feature called local scope
and it basically looked something like
this
whereas in the previous example I just
required a CSS file and it was a pure
side-effect it was just telling web pack
include the CSS file what you would do
in
you would actually import something from
that stylesheet into the scope of your
JavaScript so now you're importing
styles from the stylesheet
now you might look at that as I did and
wonder what exactly is going on here
like what does this Styles thing we've
imported from a stylesheet evaluate - so
to answer that first let's look at the
CSS this is what you would see in the
matching CSS file this was a new syntax
custom syntax introduced into web pack
you'd put colon local and wrap it around
the selector so here we've got a local
dot header and a dot footer so what that
means now is that if you go over to your
react component in this case we have
access to Styles header and styles dot
footer and these are just strict class
strings that we're putting into our
template so now we're being even more
explicit in the link between this
javascript file requiring CSS and then
what classes it actually wants to use
from that CSS file I'm sure you can
imagine this is gonna scale even better
than what we were looking at before so
to understand what happens as part of
the build process if you look at that
simple CSS file or the local header and
a local doc footer once it's come out
the other end of web pack what you end
up with is a hash globally unique class
name so what what happens when you
import it is that you get an object that
maps from the name you gave it don't
header to the global hash which I'm not
going to try to pronounce of course the
amazing thing here is that we have no
more naming collisions you're free to
have a dozen dot headers in your app and
and dot root and footer dot title dot
logo you can just call them basic
classes like the good old days you don't
have to worry too much and if you for
whatever reason particularly in
development you might want to give your
classes nicer names than just hashes you
have full control over it so you can
configure the web pack loader to say
that you want the identifier to be the
the name of the file two underscores and
the name of the local so in this case
what's happening is we're basically
having web pack right our Bend classes
for us we don't have to do it by hand
anymore now I work at a company in
Australia called seek which is basically
the number one job site there it's a
household name and a new project we were
working on was leveraging these
techniques we were doing it in the the
style mapping to classes and as soon as
we saw this local scope we really
couldn't help ourselves but port our
entire app across to local scope it was
a natural fit it was doing exactly what
we were already doing in our application
so what that resulted in is any CSS file
in our application you would open it up
and you would see this a wall of local
local local local every single line with
very few exceptions and that led to a
very interesting question which was what
if locally scoped CSS was the default
why do we have to opt in every single
selector into this when really when you
look at any other sane module system
local scoping is the default and global
is the exception you should have to say
I want a global select it not I want
everything to be local specifically
every time what if we could write this
instead we opened up a new tab in our
editor and we just wrote what we wish we
could write and ultimately all that was
was deleting all of the colon locals now
when we came to what you see on that
last line there one of the very few
exceptions where we needed a global
class because of the way transition
group works and react we needed access
to a global class so we flipped the
model around we said if we say : global
we want that class to be global but
everything else is local now we were
able to achieve this quite easily with
post CSS which Lockland just covered in
great details so obviously I don't have
to go into too much detail here but post
CSS is a really great tool for allowing
you to do this sort of work where you
want to have your own custom
transformations on the CSS so as a
result on the train ride home from work
that day I was the same day I asked the
question I was very it didn't take long
to hack together an open-source project
called post CSS local scope and
ultimately all it did was it turned dot
class into a colon local doc class and
it turned : global dot class into class
because that doesn't need to be hashed
IRA I was very excited about where this
was going
I wrote a blog post called the end of
global CSS just like this talk and to my
surprise it picked up a lot of traction
got a lot of views people were really
excited about what we were doing with
CSS in our application arguably the most
important person to get excited about it
was tobias koppers the creator of
webpack he reached out to me and he said
i hope it's okay if i integrate your
post CSS local scope module into the CSS
loader and of course the obvious answer
the answer to that is yes so we started
talking about doing exactly this very
shortly after this CSS loader landed a
new feature and another experimental
feature called module mode so you just
added question mark module to the end of
your loader config and this became part
of the way it worked you didn't need to
use this post CSS plug-in with a post
CSS pipeline it was all internal to the
CSS loader and it all just worked for
you out of the box as part of my blog
post one of the things I talked about as
a potential future was I said we could
start generating shared classes between
components automatically treating style
reuse as an optimization at compile time
what I meant by that was you know if you
if you look at what's happening when you
import the style object you've got an
object that says styles dot foo maps to
this global class in this case of BEM
style class but when you use that in the
template you know there's really no
reason that that class could actually be
a one-to-many mapping when you say
Stiles dafu why does it have to be one
class it could be three or four or a
hundred for all you know you actually
don't care and that creates a really
interesting way for us to allow people
to change their markup without having to
change their CSS sorry without having to
change the mark-up necessarily this
feature then very quickly landed in web
pack again under the name of composition
after like much black shedding and it
looks something like this so when you
write a selector like dot foo inside of
that you can say composes heading from
typography and it composes box from
layout and what that means now is that
you this class is actually made out of
three classes if you drill down further
your typography CSS has a dot heading
class again it's just locally scoped and
layout CSS has a dot box these in the
end end up being globally unique hashes
but for in day-to-day development you
don't have to worry about the names so
again to really make this clear when you
import the styles from this style sheet
Styles dot foo is
three classes from three different files
and you don't have to do all that work
of putting all these classes into your
HTML it's just kind of done for you now
I was really excited about what we were
doing here but my big fear was that this
was at the time really just a feature
embedded within web pack not everyone
uses web pack tools come and go but the
ideas we had here I thought could really
have a big impact on the future of CSS
so I reached out to Tobias copper's and
I said have you thought about writing a
standard for CSS modules that others
could implement I was particularly
interested in where this could take the
CSS community in the future when you
look at something like NPM and what's
happened to the JavaScript community
there because everyone agreed on a
module system I'm hoping that we can get
there with CSS and this is really the
first step we need to agree on a module
system so the next step of course was a
new repository a new organization on
github called CSS modules the initial
commit you can see here which was a big
readme describing what a CSS module is
and this got started to get a lot more
visibility from people now that it had a
name the missing thing of course was a
logo which I threw together first as a
joke but it kind of stuck and and it's
now available in web packs official CSS
loader as no longer no longer marked as
experimental its CSS modules mode and
everyone who's using webpack today we're
CSS loader already has the ability to
plug CSS modules into their pipeline
today which is really exciting one of
the big contributions I made was
creating the CSS modules web page demo
this runs through all the different
features and tells you how they work and
you get to get a sense of what it looks
like in a in a somewhat more realistic
application now an obvious question that
might come up here is you know do we
have a hard dependency on react here and
the answer here luckily is no of course
you've seen it working with react but it
really works with any JavaScript
framework you've got it works in mercury
which is very similar to reactor we've
got examples in angular angular 2 as
well backbone and we've seen examples in
just vanilla J's writing inner HTML or
creating Dom nodes on the fly because as
long as you can import styles into a
JavaScript context you can use CSS
modules the next obvious question from
there is does that mean CSS modules has
a JavaScript dependency I said I was a
big fan of of progressive enhancement
how do how does it work if we need
JavaScript to be able to understand our
Styles and luckily the answer to this as
well is no there is no JavaScript
runtime dependency only at Build time as
an example of one way of many that you
could solve this problem I created a
project called static site generator web
pack plug-in and it basically lets you
run JavaScript at Build time to output a
set of static HTML files but you get all
the benefits of web pack including CSS
modules so if you look at the source
code for the web pack demo that I showed
you earlier it actually has no
JavaScript running in the browser it's a
pure static bundle of HTML and CSS no
JavaScript and if you view source you'll
see that you basically have a bunch of
BEM style classes that are very similar
to what you would have written by hand
but at development time it's all locally
scoped CSS no manual BEM written out
it's all done for you at Build time now
the future of course it is going to
require a lot more work because while we
have a dependency on JavaScript at the
moment we're really interested in
solving the problem of taking CSS
modules to the broader web community you
know how does this fit in with things
like rails for example what's the answer
there we've got a bunch of ideas we're
going to start a bunch of experiments
and by way of course I mean the CSS
modules team so we've attracted a lot of
interest some really smart people
helping us out with this including Glenn
Madden who's also here today as a
complete coincidence I swear and yeah I
think the future looks really bright for
CSS
even if it's not necessarily CSS modules
but what we're kicking off here I think
is really really important so we've got
it in web pack today but most
importantly I think we've proved that we
can spread it beyond a single tool we've
also got it working in browserify
JSP m and again if you feel like your
build tool or your environment is
missing from this list by all means
please help us out and try to spread CSS
modules beyond where it is today I think
it's a fair response to this for a lot
of people would be that this looks
complicated you know we're making CSS
feel a lot more heavy and tall driven
but there's a really important point
here I want to want to hone it on this
model here of a component with
everything localized is actually a much
simpler model to work with and I think
it's much easier for beginners
importantly all of these CSS
methodologies come with a very steep
learning curve for people who are new
and I think that this is actually a nice
a starting point for people because each
one of these components is a miniature
CSS is in garden everything's
everything's nice and simple within that
boundary and you're basically back in
the in the simple days of the early web
where it was just basic pages and that
scales really really nicely the main
point I want to stress is that I think
we need to have smarter tools not
stricter methodologies these
methodologies mean that onboarding
people and upskilling people in CSS is a
lot harder than it should be and if we
get the smarts into the tools I think we
can have a much better environment for
beginners as well as solving the problem
of scaling CSS so together I think with
things like CSS and thinking more about
scoping things together we can make big
CSS feel like small CSS and that's what
CSS modules is really all about that's
it for me thank you so much for having
me hey the buggin work you debugging
yeah so so for me the fact that I can
name my classes based on the file name
and the local name is how we debug in
our application and so what that means
is that in development mode when you
open the dev tools you can very quickly
get a sense of where in your application
it were in which file these selectors
are coming from but the cool thing is
that because it's completely
configurable in your website config we
actually have minified class names in
production we have five character hashes
so that's that's we found that that's
actually plenty for us to debug
we haven't neat had any need for
anything like source maps or anything
like that
just being curious what happens when you
have some global style
absolutely have to include like like
bootstrap or foundation CSS yeah so I
guess there's a couple answers to this
question like in our application we
started with with the classic like Eric
Meyer CSS reset that of course has to be
global its styling tags so what we do is
we wrap that we we wrap that in : global
and just say all of these Styles have to
be in the global scope the other I guess
there's a broader answer or more of a
discussion around something like
bootstrap where I think the probably
that one of the things I really want to
focus on after this conference is is
looking at how we can better support
something like bootstrap so to use your
bootstrap classes you would have to
explicitly import them you can't just
assume they're in the global scope but
the I'd like to argue that if we
introduce a module system to CSS I think
that will need to usher in a new era of
frameworks that are built you know
understanding that there's a module
system in the same way that that
JavaScript kind of went through the same
thing where every library assumed it was
in the global scope and then slowly move
towards things like commonjs now that we
have NPM I think we might if CSS modules
really takes off I'm hoping we'll see a
similar transition where you have CSS
frameworks that introduce classes that
you never actually use in Europe you
just compose from their classes and
build up your own language on top of
them for example but yeah how about
documentation and customization of each
of the component stylesheet so I'm not
sure I understand I mean if I use the
third-party CS module to my component
how how do you suggest as as an author
of the third-party module how do we
document the usage and how to customize
it
yes so I'm not sure if I understand the
question but basically it's it's not
that different to how you might document
a JavaScript project for example where
you'll need to explain in what things
you can import from that library you
know what basically what's the public
API of this thing and for a CSS module
you know in the way that I was just
talking about we
might have a framework of things that
you can pose your classes from you might
document and say you know say there's a
grid system you can say you can compose
your class from these grid classes and
and and that's kind of how you document
the link between what what what are the
building blocks that you provide in your
in your CSS modules your package okay
so let's say I don't want to use jQuery
UI is 2,800 line of JavaScript
datepicker and I want to you say
something that you you know you built
that's a component that's up there but I
have a gigantic already existing CSS
JavaScript how quickly can I get that
running from npm install blank date
picker to that thing working in my site
that's that's a really good question and
I'm not sure that we have a good answer
for that yet web pack is a really great
tool but in my opinion it's not that
strong when you're crossing like package
boundaries like you publishing something
that depends on web pack to NPM in a way
that you could install it and just use
it in your app I don't think the story
is that strong there and I think that's
probably where development in the future
is going to have to go to make that a
better experience</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>