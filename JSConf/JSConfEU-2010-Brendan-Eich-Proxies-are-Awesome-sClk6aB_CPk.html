<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>[JSConfEU 2010] Brendan Eich: Proxies are Awesome! | Coder Coacher - Coaching Coders</title><meta content="[JSConfEU 2010] Brendan Eich: Proxies are Awesome! - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>[JSConfEU 2010] Brendan Eich: Proxies are Awesome!</b></h2><h5 class="post__date">2013-06-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sClk6aB_CPk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let me know if you can't hear me so I'm
going to talk about some work that we're
doing in the atma task force that was
just mentioned in the previous speech
it's actually called technical committee
39 and I think we've got a good group
that's now working harmoniously together
so I wanted to talk about one of the
best things that I've seen coming out of
it
which is already implemented in Firefox
and that's this notion of proxies but
I'm stung because the a query crew
implied that I was just playing some
YouTube videos and goofing around my
last chance conf so I'm not going to
play any videos this is getting very
technical they'll be a lot of code we're
also up against beer I'm in the Alex
Russell slot so I won't I won't keep it
too long but I will give you a test
afterwards liquor is weird I showed
people at work this episode where they
had like the Quadra box with the four
talking heads and then this heart-shaped
window in the middle with John Resig in
it and and you know unicorns or
something and it was people were very
confused by it they don't really
understand our community I'm trying to
explain it to them
html5 is like the flying unicorn that
craps skittles out of its rear end
javascript doesn't meet that kind of
stuff we're awesome
without the unicorn so about res it's
cool so thank you so let me talk about
voluntary talk about this is based on
work by Mark Miller of Google and Tom
van could some of the Free University of
Belgium and it's it's got a long history
in the research community that is pretty
cool I'll talk about that too so to
review we have managed to produce
something called the fifth edition of
ECMO script and it's called es5 for
short because no one wants to really say
Eckman
and it has things in it that have been
in some browsers for a long time like
the array map and for each and other
methods it has JSON based on Dougs JSON
- it has strict mode which we hope will
be an Internet Explorer 9 it has this
metaprogramming API for defining getters
and setters again there was some prior
art there that when in Mozilla like 11
years ago and got into other browsers
actually founded other browsers really
fast what happened was that that I
believe the first version of Live Maps
launched in I think it was 2005 and it
was based on Atlas which was like
Microsoft's answer to Ajax which was
kind of cool was just an 8x library the
way it worked though was that it assumed
that browser was IE and if it couldn't
detect document dot all or something
like that it would then say oh I'm going
to assume it's Firefox if it's Firefox I
can use you know double underscore
define getter double underscore defined
setter and sure enough it did that and
so live Maps works great in IE and work
great in firefox didn't work in Safari
or opera and I happen to know some from
some prints those companies that within
a week there was a fire drill you know
Steve Jobs was using certain words and
and people added define get a defined
setter and lookup getter look up said
her to JavaScript core in the WebKit
they added it to operas engine at the
time futhark because they needed to make
live maps work and that's how you get
rapid evolution on the web I I don't
like being the number two browser having
to force them to do it and then some of
my Apple friends are sensitive to this
because they don't like being forced to
do it but on the other hand you know I
he forced us all to do stuff so it was
good
WebKit has like less market share than
Missoula and they forced us to do stuff
and it's good so if it's good let's do
it I don't mind having to do it in a
hurry though I have said I didn't have
to do anything on a weeks notice to make
live Maps work so maybe I would feel
differently if I did but the define
getter and setter stuff was all about
making properties that had code behind
them so you could run a function when
somebody gets a property you can run in
their function when somebody sets the
value of the property and that got
cleaned up and rationalized and sort of
synthesized into the metaprogramming API
and es5
five and you could think it is like
java.lang reflect only javascript line
reflect and less painful to use it also
lets you control whether a foreign loop
will see the properties you define it
lets you walk down properties against
mutation and objects against extension
and people worry that that's too you
know alien to javascript it's certainly
not the way javascript was when I
created it I made it so you could monkey
Padgett because I knew it needed
patching I was doing such a rush job I
made almost everything mutable I think
only the the built-in constructors
prototype properties could not be
overwritten but everything else
including those global bindings for
object and array could be replaced and
that was intentional that was because it
needed the ability to be upgraded by
library authors such as yourselves but
now we're in a different world one I
think that having control over mutation
extension configurability is important
and we've got that in es5 so this is
actually in a Firefox 4 it's coming
along in the WebKit nightlies and it's
in an IE not into large extent so we
should just try to keep going and get it
all done
here's a quick slide on what the
metaprogramming API looks like it has
some methods on object because it's not
really possible to extend object up
prototype yet so you get these methods
with sometimes long names stylized names
like get own property descriptor you can
see that if you have a point and it has
a getter for R the radius you could
actually query for it at the bottom when
you get on property descriptor point R
in quotes you get back a descriptor that
says this thing's got again and said the
set happens to be undefined there's no
setter so it's really constant and by
the convention that it was defined in
the object initializer using that get R
open paren close paren syntax its
innumerable you'll see in the foreign
loop it's configurable you can you can
mess whether you can delete it mainly
you can replace it and that's just how
properties defined by object
initializers happen to work but you
could you could do more you could say
I'll get that define property
try to create a Z that is enumerable but
defaults that's what the grayed out part
implies - not writable and not
configurable and in that case that Z
cannot be deleted and it cannot be
rewritten to have a different value than
zero it cannot be replaced by a getter
and when you query for it you'll you'll
find out that's that's the case you'll
get back different descriptors and
here's an example at the bottom showing
another api object.create where you can
specify the prototype for the new object
you're creating as well as what's called
a property descriptor map which looks
like an object initializer whose keys
are the names of the properties and the
values are the individual descriptors
that include things like value or get
set and the boolean enumerable
configurable writable etc instead of a
big API it's got a lot of optional
parameters so it made sense to use
objects as arguments and let you write
object initializers and you can read all
about it in the spec or in documentation
that's kind of online that the mozilla
developer center in other places that
try to make it easier to read the net
respects but it's it's very powerful and
when you create such an object you get
this property descriptor map telling you
how how these properties should be bound
and object create does that if you want
to make an object that can't be messed
with there's a trio of methods on object
that are progressively more restrictive
prevent extensions object but prevent
extensions says the argument object
after that successfully returns cannot
be extended with new properties you can
still delete old properties if there are
writable properties in that point you
can reassign them reconfigure them if
they're configurable but you cannot add
new properties if you then go further or
instead of calling for an extensions
call object seal you get the effect not
only it prevent extensions but you get
all the existing properties made non
configurable so that they can't be
deleted or replaced with getters things
like that finally if you use object of
freeze that's the real power
tool that does effectively free
extensions
seal and then it goes through and it
makes every property non writable and so
these are the the sort of ways of
increasing the integrity of your objects
so that you can be sure no one's mess
them up even your own code accidentally
sometimes this is useful people argue
this is good for security and it is it's
not a silver bullet on the other hand
you might use this just for your own you
know programming sanity and there are
certain objects that should be constant
there's certain things in the language
it should be constant you can use these
these api's to do that so now I'm going
to turn to proxies and why we're adding
more metaprogramming you know why do you
need more meta it's possible to really
go crazy with meta programming and a lot
of language research has the api's that
are in the 5th edition only goes so far
we still have some things out there in
the field like spider monkeys no such
method handler which is like small talks
does not understand and there's a little
example it shows if you make an object
with no such method in spider monkey if
the value of that double underbar no
such method double any of our property
is a function taking the identifier of
the method and the arguments to it you
can see that calling some non-existent
method will actually trap to that
function and it will sure enough print
the identifier and the arguments as an
array people like this this is something
that the Beck guys use in their sort of
small talk on JavaScript Ajax library VM
thing it's it's one of the sort of
inputs to the standards process where we
see there's an extension we added its
fills a need and something needs to be
standardized now you can be sure with
double-under VARs on the name it's never
going to get through the Standards
Committee but this was informative to
the proxies work that Mark and Tom did
and there are good reasons that you want
to do this you want to make virtual
objects objects that aren't really there
that they front for some database or
some object that's in a persistent store
or on another machine and you ideally
want to get rid over tame this this
weird corner of the atma spec called
host objects which I was there when this
was written this was written mainly
because the I Dom
to some extent every browser store has
these objects they're implemented in C++
they reflect in the JavaScript but they
don't act quite like objects in
JavaScript have acted till now they may
have non configurable and non writable
non extensible properties they may have
weird bugs where if you you know asked
what the type of some thing like alert
is until ie 9 you get object instead of
function they may have the problem if
you touch them in the wrong way they'll
actually throw an exception at you those
are just bugs but but still host objects
have leeway in the atmosphere to do
weird-ass
and and that's bad but it's also good
that people need to extend JavaScript
not only with C++ with lots of security
issues but with JavaScript itself they
need to be able to keep extending the
language and the libraries in ways that
looks like built-in objects and that can
substitute for built-in objects that can
virtualized built-in objects and that
that becomes important as you build
libraries and as you try to manage
incompatibilities across browsers and
across browser versions so that's a
motivation for dynamic proxies and
there's some precedent for it that you
could say well maybe we don't really
need to go much further than the es5
getters and setters based on the prior
art maybe we just need to add gathers
and setters but really every getter and
setter defined using the es5 api or the
declarative syntax in object literals
like in the middle of slide has to pin
down the name of the property the access
to property the property with the getter
and setter and that's not general it's
ad-hoc and it hard codes the name you
can do it if you know exactly the names
of the properties you want to meta
program if you don't you're out of luck
and it's pretty verbose so perhaps you
could go a little further you could use
object.create and you could use another
api get own property names object get
own property names we'll take any object
and give you all the direct property
names whether their innumerable or not
in an array and then you could use nice
for each this shows all the es5
additions for each array X
passing a function so for each direct
property named own property name you can
then get the descriptor of that property
and you can wrap that property with a
getter and a setter that will do the
logging for you that way you don't the
hard-code the names that's better
but it's a one-time wrapping operation
and you won't catch new added properties
that are extended on the object after
this this make logger function has been
called you won't catch changes to
property attributes so it's not complete
so here finally is what we're working on
for the harmony version of JavaScript
it's new API instead of capital object
as the locus of create and other meta
programming methods we have a new
built-in class called proxy and it has a
create method which can take two things
the first is conventionally passed as an
object initializer it's the handler and
the second is the prototype for the the
new proxy object you can think of these
proxies as blank objects these are
objects that you give code to to answer
questions about properties to act on
changes to the object but but otherwise
the proxy itself is kind of empty and
the cool thing is the handler is is
isolated in the meta layer from the
proxy that the handler is your own
object maybe it's a shared object
initializer maybe it's some object that
you create maybe it's another proxy
which we'll get to
and there isn't necessarily a an object
backstage of it it could be a remote
object it could be just doing
computations to answer gets and sets but
this way you can handle all the possible
evolutions of of an object if you're
willing to create it as a proxy from
from birth and so make logger now
finally has managed to make a logger and
it's captured obviously the object that
it's being logged in its closure as an
argument so it does in fact have a have
an object that it's fronting for but
again that's that's incidental that's
not required
so you'll see this kind of diagram
throughout there's a base layer and
there's a metal layer metal layer is
like backstage at the play basis is what
the audience is seeing so when the
handler is there doing its thing the the
user the proxy with only a few
exceptions really can't tell that
they're not dealing with a regular
JavaScript object everything can be done
almost seamlessly and there's a few
important cases where that's not true
but I'll get to those and so one of the
things that this dash line divides is
correspondences between the meta layer
and the base layer so here you have a
base reference and expression property
of foo that turns into handler duck get
passing the proxy and the name foo as a
string so a base expression that assigns
hand without phooey quills 42 turns into
ham sorry proxy about foo equals 42
terms at the handler dot set proxy
string foo and 42 and calling proxy up
foo with an argument list turns into a
get essentially followed by an apply
it's kind of an internal apply and so
you can see how almost everything you
could do to object maps from proxy to
Handler and indeed if you reference
proxy yet you're just getting the name
yet from the from the proxy if I calling
the handlers get method and proxies can
have prototypes this is important for
instance of for things like that
but it's up to the proxy to delegate to
its prototype there's no automatic
delegation done by the the JavaScript VM
the proxy is responsible for somehow
answering for all its properties both
the own or direct ones and any that
might come from its prototype or some
other object and the handler you know
can have a prototype too if you want to
build a corresponding tower in the meta
level and it's not just for property
accesses you can do things like in
expressions which turn into handler that
has these methods on the
handler we call traps by analogy of
operating system traps to distinguish
them so the jargon is that proxy has a
handler that's associated at creation
time otherwise not discoverable from the
proxy the handler has traps there's a
suite of them 13 I think if you delete
proxy dot foo that calls handler dot
delete with the name foo if you write a
foreign loop over a proxy the handlers
enumerate trap is called and it returns
an array of all the innumerable keys and
if you do metaprogramming using those
es5 object dot defined property all
those somewhat long the methods on
object in fact those have handler traps
too because it's important that you be
able to masquerade almost seamlessly you
should be able to intercede on any
behavior that an object can have and
that includes the metaprogramming API s
so there's a hand without defined
property but there's a few things that
we don't want to break these are
invariants in the language that are
important to preserve so triple equals
notice that there's a base expression
proxy triple equals Saabs there's no
handler call for that it's object
identity for objects that's all it is
you cannot intercede there with a
handler trap object not get prototype of
which is kind of like the read-only form
of double under our proto this other
extension there's no way to lie about
that that's the proto that was given to
proxy dot create and we'll get into this
a little more but I mentioned instance
of is also looking at proto and type of
for a proxy that's not a function proxy
that that's what's coming next is object
always object in the future we might be
able to do something it would be a
different thing from proxies themselves
but it would be closely related would
let you make value types we're looking
at that but it's not not harmonious yet
whereas proxies are and then are
implemented so the full handler API
looks like this it's it's quite a lot to
take in
I'll let you stare at it but you can see
on the left are the base level
expressions and on the right are the
meta-level handler trap calls with the
arguments that you expect and there's
there's a bunch of these that are for
the metaprogramming API and es5 there's
some of them for the old delete and the
es3 in operator things like that the
foreign loop and to break it down a
little further some of these traps are
called fundamental because if you
implement them the derived traps could
be constructed for you by the virtual
machine at some loss of efficiency so
derive traps are there to allow a
handler to optimize a little harder but
they are not required derive traps have
some interesting properties one of them
that we've just been discussing this I
think on its way to harmony status is
instead of just enumerate which gives
you an array of all the keys for
innumerable properties when someone is a
foreign loop on a proxy there should be
a way on a very large object or an
object that is a proxy for some
indefinite stream of values to iterate
lazily over those those values without
having to make an array that has you
know a billion elements in it and so
there's a separate
derived trap optional trap called
iterate it returns an iterator and this
is very much like the Python iteration
protocol it's based on the work we did
in json' 7 and it's cleaned up a bit and
it fits right into proxies it's a
perfect fit for dealing with the very
large object case or the infinite stream
value stream case now functions in
JavaScript are a little different from
objects it's all mysterious at first why
this is maybe it's not because you write
functions especially they have closures
things like that so there are function
proxies that you have to create
differently because they have two
additional traps beyond the ones that
are in the handler and these are passed
as separate arguments to proxy to create
function and these are the call and
construct traps and construct is
optional if you don't provide it then
the usual way that operator new works on
a function is is used with the call trap
so a function proxy has call ability
there's fun props
three and that turns into the call trap
passed as an argument to proxy attack
rate function being invoked with the
arguments new phone proxy one to three
calls the construct trap and getting the
prototype of a function proxy you might
want to do that
we'll call handler get which is the same
trap you have with with object proxies
works for function proxies so function
proxies are an extension of object
proxies and type of doesn't lie and
cannot lie type of always says function
for a function proxy finally as you
expect when you when you call get
prototype of you get function dot
prototype these things look like
functions type of says it get prototype
F says that you can find apply and call
on their proto chain therefore those get
trapped so you could always do something
weird there's a little dilemma I wanted
to talk about that that came up when we
were doing no such method and that's
that if you don't separate traps for
getting a value of a property from
getting that value whatever it is in
order to invoke it as a method then you
end up having to create a method on
every call which kind of expensive so
you end up having to memorize or cash
memo eyes that that method so that you
don't have a million calls construct a
million methods and so at one point in
design we had this invoked trap it
doesn't seem necessary and it has some
undesirable technical properties so we
got rid of it it does mean that if if
you're worried about this issue you're
going to have to cash you have to
memorize and again it when we were doing
this kind of meta programming it's
important to hold fast to some
invariants like triple equals should
work and this invariant you know it's
not exactly written in my blood anywhere
but it is important for existing code
we've seen this on the web and it ought
to be preserved we think in the absence
of other evidence so we got rid of the
invoked trap now proxies can do
everything almost everything except lie
about type of
get prototype of that an object can do
but what's really cool is how they give
you the developer's power that
previously has only been in the domain
of I would say that the browser
implementers who write C++ not even the
ecla committee because we're kind of the
people who formalize what the browser
vendors do and now in this era of
harmony we're trying to actually work
together to prototype the next
generation that ends up being
implemented in C++ code but there's no
good reason why this should have to be
in C++ code you know everything from
java javascript everything for the 90s
was done in a hurry was done backwards
while java actually took five years i
don't know why they didn't do it right
small talk did it right small talk took
decade but it got to the point where
everything was bootstrapped on a very
small amount of native machine code or
native assembly or basic originally and
it was mostly mostly written in small
talk which is beautiful and wonderful i
kept things honest and preserved the
uniformity and meta programmability of
the system it got rid of weird host
objects exceptions and loopholes and
more's the pity javascript wasn't built
that way but there wasn't time on the
other hand with proxies we can kind of
rebuild the world incremental ii and we
can give you the power to do it by
writing handlers creating proxies and
doing selective interception so you know
it's been great fun haha not really I'm
being sarcastic to write a bunch of C++
native code that shows up as JavaScript
objects it's really not fun it's
constantly taking your life in your
hands with security and in memory leaks
and all sorts of problems every browser
vendor faces this there's no no one is
safe no one is innocent but javascript
has been debugged that may have noticed
it's got law faster putting this ability
to selectively intercept it do this kind
of stratified dynamic proxies
metaprogramming in the hands of
developers actually is not unsafe
compared to writing more sequel code +
code it's it's more safe and it again
will help with distributed innovation in
extensibility so this is what we hope to
do and then we we have to draw a hard
line between the C++ code still and the
JavaScript code
we want self-hosting we want to rebuild
the world that small talk had
incrementally with all your help we want
to get to the mostly self-hosted very
little native code nirvana it's going to
take a long time don't know if I'll make
it but props you seem like an important
ingredient otherwise I don't see how
we'll get there we do not want random
objects created for the Dom or I don't
know JavaScript a reg X of object to
suddenly start sprouting handlers that
can change their behavior from what
existing code expects what programmers
expect so that's why proxies have to be
created fresh as kind of blank objects
with this behavioral intercession power
you cannot tap a handler onto an
existing object and that's an important
design point so here's a simple example
of a forwarding proxy it's given an
object it captures it the property on
this so it's meant to be called via new
you could do with closures to not worry
about this or new and this handler will
simply forward all the fundamental traps
or the ones I cared to write to the
target object so it's just a pass
through and it's just a way of creating
a sort of a no op proxy and it's handy
to have these things around when you
need to stick a proxy somewhere that's
not going to do anything or you want to
sort of build on its bones to add some
logging or some something so this is
kind of the sort of proxies my first
proxy example and at the bottom you see
how proxy dot create is given the
handler which is constructed by calling
this this constructor and the prototype
of the target object so that the proxy
looks like it has the same prototype and
here's a somewhat less vacuous example
this one will actually count all gets
and it it has to be able to start from
an undefined count it so count all
access is actually and returned them in
a stats property that there's a getter
for the the idea of counting all gets
here could be
otherwise you could write a bunch of
counters one for each kind of trap that
might be a little tedious but you could
do it and you can make a simple profile
or just counting gets in this case could
be handy
just seeing the counts of operations
enzymes helps you find bugs now in es5
there's a way to freeze seal prevent
extensions these turn into something
called the fix trap and all three of
these work through the same trap there's
no difference because as I mentioned
earlier it's prevent extensions that
actually is fixing the object so that
cannot be extended and the other ones go
through all the properties and do
further things like limit their
configurability limit their write
ability seal limits configurability
removes it and freeze does that and
removes write ability makes things
read-only so those those can be
expressed in other traps but it's the
fixed trap that is the fundamental one
for all these three of these these new
es5 methods for hardening objects and
what's really suck about this is another
small talk-- thing in order to make fix
work we actually do something at mobile
calling brain transplants we make a
brand new object that's frozen that's
based on the property descriptors that
are returned by fix so you can you can
specify what the object becomes when
it's fixed and it doesn't just get those
properties it becomes that object this
read become primitive it's not in the
language it's it's one of these things
that's that's definitely backstage of
reality in the VM it swaps the guts or
the brains of two objects so that the
object identity of the of the proxy
being fixed is preserved but it
literally stops being a proxy it stops
being this magic object that can call
traps on it from its handler and becomes
a plain old object and the plain ol
object that was created here of course
becomes the proxy and then becomes
garbage collected because it's it's it's
not retained there's no reference to it
that's pretty cool and that guarantees
that that you will never go back from
being fixed
and yet you preserve the identity of the
proxy once it is fixed and becomes a
regular object okay so this sounds kind
of cool maybe it sounds a little
abstract it sounds like I don't know you
know
platon ism or something something weird
like Gnosticism but there is a meta
level that is above or backstage of the
reality and this meta programming lets
you get it and proxies in particular let
you make an object behave like anything
and if if you write all these traps you
can do that and that that's that's 13
traps that's a mouthful but what's what
this will blow your mind what you can do
if you're if you don't want to do that
is you can make a proxy whose handler is
a proxy so you can climb up the meta
ladder so-called put up the meta ladder
one rung and write a new handler I think
that's legal Unicode identifier for the
handler so the proxy has a handler the
handler is a proxy it has a handler and
every time the handlers traps are called
by the virtual machine when you do some
base level operation on the proxy the
handler calls turn into meta handler
traps get traps so the meta handler only
needs to have the get trap and then it
can do whatever it needs to do to create
or find those 13 traps and that that
actually is handy for if we go back to
this example of counting see where it is
counting get operations remember that
one the the example here only trapped
get and I said you could write out get
set has they're all 13 of them but you
don't have to instead you can exchange
this example so that it uses a proxy as
the handler and the that meta handler
has a get and all it does is count the
named operation
it's being trapped by the handler so
it's meta meta we're getting meta on
meta but that's cool and there's there's
some great power there in not writing
things out too long and also in sort of
automating construction of rappers or
what are called membranes and so let me
talk about that these are actually used
in Firefox for security for cross-site
scripting for the privileged Zul scripts
to isolate them from the unprivileged
web content we have like seven flavors
of these and we've got them all kind of
rationalized and they've all been
rebuilt in Firefox 4 on top of how many
proxies there's a good history research
here mark Miller's thesis and he writes
org
it's obviously fed directly into google
kaha the capabilities secure a subset of
JavaScript that uses membranes also the
simplest use case in the object
capability world is that you want to
limit the authority of objects you want
to use the principle least authority but
when you when you give your logic throw
you do it by giving them an object
reference well what if you want to take
that away later that's hard to do unless
you have something like a revocable
membrane some-some way of saying no more
access something like a proxy so you can
share enough build membranes with with
proxies and here's a fine object ability
diagram showing how you can do this it's
kind of artistic I'll leave you leave it
to people to figure out what's going on
there but when we get no unicorns so so
the code is what everyone's going to
read because I know you want to read
code before you have beer what's really
cool is that I'm going to start with
this and build in toward the middle this
is an example that the mark and Tom had
it shows the power of the meta handler
the ability to to rift traps from the
handler into the meta level with one
piece of code so we're going to wrap
some target objects and it better be an
object and it's printer we're just going
to get it back we're going to make a
forwarding hands
I saw that already it's the snow
pastoring thing we're going to make a
revoke Handler and it has a rope handler
that is a proxy reveal Candler is proxy
up creative handler that is a proxy and
its handler has only a get trap and that
get trap whatever it's being called with
remember it's only being called with
whatever is calling the handler and
unless you do something to the handler
that's only going to be one of those
thirteen trap names so get set has that
name is going to be one of those
searching names you're going to wrap
that base handler and reflect it back
into the the base level and you have to
handle functions differently of course
so there's a special case for create
function otherwise this thing will just
sort of recursively wrap an object you
give it in a membrane and the membrane
will make sure that all the traps
whatever they are go through something
that I haven't shown yet which is coming
wrap function and what does wrap
function do well it's normally going to
just apply the trap let you do your
membrane thing which is the forwarding
thing this is the capability you've
given that you want to go to revoke it
but if the enabled flag has been set to
false then it's going to throw an error
and that's that's revoked so this simple
one-page example shows it's not that
simple but it's pretty simple
this shows how you can use proxies to do
something that is taken for me we did it
C++ it's a lot of C++ it's very bug
prone it's conceptually simple but but
complicated to implement but here is
it's it's fairly comprehensible it's
very pretty
and you don't have to write out those
thirteen trap names you just use this
this meta handler and you have a
revocable membrane so this is all based
on Tom Marx very good work and that's
based on prior work Tom van cooked some
others his colleagues at the Free
University of Belgium and other places
have been working on ambient talk which
is in the small talk family in the e
family and they had a meta programming
system that was called mirages based on
mirrors mirrors is a old paper from
David hunger and Gilad bracha about how
when you do meta programming you want it
to be strapped
I've been using that word what does that
mean well it means no more double
underbar proto double underbar no more
double underbar no such method the
blonde or because for one thing sticking
those properties at the base level means
you can't intercede for those names what
if somebody has a database or a JSON
file and they have double wonder or
Frodo in it they're kind of hosts
stratification means that there's a
mirror backstage of reality and you
reflect the object off of it and that's
how you do meta programming you kind of
bend the mirror so this isn't a complete
picture of the prior work but it's the
directly influential for our work it
does go back to small talk like almost
everything and you know the number of
traps in these systems varies but 13:8
bad take it from me
Java seems like the winner here with one
trap but it's not really a trap it's a
whole no class I'm not sure that this is
counted fairly and anyway Java sucks so
so why are we doing this why am i
telling you about this I hope that this
is interest interested you and piqued
your curiosity we're trying to solve
some problems as browser vendors and as
responsible stewards of JavaScript we
want to make host objects saying and we
want to give programmers the power that
is so far been only in the domain of the
C++ browser hackers proxies look like
they're sufficiently powerful to do this
they allow us to self host more and more
we're using them for these security
wrappers in Firefox for the handlers our
C++ by the way that we're not that crazy
but we're going to get there I think
we're going to get to the promised land
of almost everything written in
JavaScript with the performance work
that's going on and and this kind of
meta programming work in principle
there's no reason why we can't get rid
of this you know megabytes of native
code that were burdened with from the
past now you could say host objects
still can do you know weird-ass stuff
that they shouldn't do or maybe that
might be good the proxies can't do so
we're thinking about should we make
proxies even more powerful
maybe we should somehow make host
objects only as powerful as proxies and
we're serious about this in every
javascript engine including spider
monkey there's something like the proxy
api but it's not quite as clever it
doesn't have this becomes primitive I
probably doesn't have all the es5 traps
but it has you know virtual methods for
calling get and set on arbitrary objects
and that's how people implement things
like you know the Dom or a live connect
the Java reflection we would like in
spider monkey to make that API that
internal virtual method table be proxies
only proxies so there's nothing that
hosts object can do that a proxy can't
do and we're serious about this and will
help us with with maintainability and
sanity it would make life better for us
and for all the JavaScript developers
and I think people in equities 39 from
other browser vendors see this too I
know I've talked to Allen worse Rock and
Microsoft about this and Travis Lee head
of Microsoft I think they get it it
might take a while
but it looks good to those of us who are
working on it so this was presented this
past year at tc39 meetings there was a
lot of good obvious at prior work and
small talk in an academic research it
actually got approved in our sort of
semi formal process it became harmony
proposal so it's very likely to get into
the next edition of the language and the
spec is excellent Tom and Mark did great
work
tom has followed through on a number of
points diligently and what's even more
gratifying is on address gal ran off and
implemented it in like a weekend in
Firefox in SpiderMonkey in this past
spring and we started using it for our
security wrappers this was ahead of what
I thought would happen and it's also
being used for something called Zaphod I
don't know if anybody's heard of Zaphod
cool yeah
I'll talk about that after that is the
old narcissus meta-circular evaluator I
wrote as a Firefox plugin you can
substitute in place of spider monkey and
run is a very slow scripting engine for
your webpage but you can use it as a
research VM you can extend the language
very easily because it's JavaScript you
can hack in new syntax you can you know
do what you want
Zaphod this on a Don Sutton's law that
Oregon sand add-on it's on github you
know safe hovels kind of vain too so we
kind of went with narcissus theme he had
two heads there's a big picture point
here I want to make and this is
important for other standards bodies to
learn from it's it's not perfect Annette
MA we're not bragging but right now we
have something that seems to be working
we need to roll with it because the
alternative doesn't look good it looks
like individual innovation where other
people have to catch up which we've done
of necessity I think we didn't want to
just do nothing but what we're doing in
tc39 is we're taking well-informed
practically oriented academic research
and researchers we're taking the
attitude that standards must evolve
because there are gaps in the language
there are problems that need to be
solved for JavaScript developers for
browser vendors you cannot solve these
problems by going into the tower and
writing some perfect paper and then
coming out with with a standard you have
to do a prototype implementation due to
prototype implementation to test
interoperation ideally do do more
- and you need a lot of user testing
because it's a large search space to
cover the API here to cover all the
corners so it's not like you're going to
write the test suite even if it has
thousands of tests and really learn
everything you need to you need to
release this into the world from the lab
and that's what we're doing in Firefox
for even sticking with a named proxy you
know in JavaScript we don't have this
Moz or WebKit prefix convention we
haven't as much experience as the CSS
guys do using such a prefix on the other
hand they tend to use it and then forget
to get rid of the prefixes over time
we're going to try to bet on the harmony
continuing so that proxy actually sticks
and so far it hasn't collided on the web
you can always reassign it just like any
other global name but we're shipping
proxies in Firefox for as far as I know
and I think we should so we're going to
reach users at scale and we're going to
feedback what we learned the committee
if we have to change something I hope
it's not big it probably won't be will
tweak it the early adopters can probably
cope and will standardize based on that
learning and that's how I the best we
can do for web standards that actually
evolve that keep up with growing use
cases demands of developers or old
demands gaps in the language left over
from the dark ages and this is actually
a strong commitment in the committee
right now it means that we're not going
to go blindside each other and do
something weird you know bugs aside
we're not going to go do something we
haven't explained to our friends in the
committee because that would make for a
pretty icy dinner conversation just a
little micro benchmark this is from the
spring I think it's gotten better
proxies if they're just doing forwarding
like that no op proxy do have some cost
this is the very first implementation we
have not done anything to optimize the
trap call the cool thing about tracing
which we haven't trace monkey is you can
inline small functions aggressively so
if traps are very small like these
forwarding ones we can inline them so I
expect that this kind of profile result
will go squeeze down toward toward one
and there will be almost no slowdown and
and the overhead of having proxies in
your VM when you're not using them
should be effectively 1 and here it is I
mean there's some noise there and some
minor things that we've had to work out
since then but proxies don't cost and
like I said we're actually using them as
the basis for all our our host objects
as we go forward so proxies are awesome
they give you this ability to intercede
and create new behavior with code in a
handler for an arbitrary object you
create you can even do functions you can
make virtual objects that have no peer
object behind them no wrapped object you
can make wrappers which are important
for things like testing security
profiling one of the things that I think
we should try to build with this and
we're going to try to get going on this
soon is you know how replay VMs and
debugging through time traveling has
become popular this goes back to Ma C I
think it was named after the hacker
Michael Elizabeth Chastain I think he
did this cool debugger that used Linux's
debugging API to capture all the inputs
and outputs of your program he would
actually login like imagine a VCR
running and recording all the i/o you do
including a map including P trace it
would follow all the pointers and then
you could rewind and play back that
input to the program and if the program
was deterministic it would evolve to the
same state so you could you could do
kind of brute force replay debugging you
guys could build that with proxies
somebody here should go do that we're
going to try to do it too because that
would be really awesome to have like a
slider on your debugger or you could
just rewind it especially if you could
capture all this Dhamma FEX this is a
little challenging there's a lot of
hidden effects there and those damn host
objects but if you could capture them
all treat them as transactions and roll
them back invert them if they're
invertible save order state if you have
- if there's destructive operations you
could do a replay debugger with proxies
and and you could do that slider and you
could see Gmail kind of reef lowing back
to where it was before it hit your bug
and you could find the bug and I think
we're going to try to build it and see
how it goes and I think proxies are
going to be key to this the API uses
stratification so we're past adding
double underscore names we are careful
to preserve a few important invariants
in language we of course do the es5 meta
programming properly support frees and
so on and as I showed there's really no
performance
done on proxy objects so beyond all this
you know proxies are awesome this does
show two things I mentioned the
committee and the browser vendors and
you developers are working more in
concert than I've ever seen we should
push on this we should do even more
without you know overreaching I think we
should get this stuff rolled out use it
get feedback standardize it and do it
again I don't know how else to improve
the web and I think it's working so
let's let's do it and really javascript
is the revenge of small talk and I
intend to see that come to pass in full
and with that I'll just show you
Zaphod if I can this is here's the code
on github you can see it uses proxies
this is narcissus when I wrote our
sisters there weren't any proxies so I
had the hack in double underscore
defined property meta methods on an if
def build a spider monkey it was bad you
couldn't host narcissus in full on a
browser people took the parser and they
ported it to Ruby and you know spread it
all over but now with proxies you can
actually do what you need to do with
supported to be standardized harmonious
api's
and I hope this works this is kind of
bleeding edge so here's here's CNN and
it has some scripts on it narcissus is
god-awful slow we haven't done nothing
to optimize the performance I'm actually
thinking that we can make it a lot
faster once we get proxies in our CSS we
can stop doing you know basically AST
walking tree walking to interpret it we
could start doing tricks that would make
it actually perform really well there's
a little Mozilla head added by Zaphod
the add-on down at the bottom if you
mouse over it says Jas Engine equal
SpiderMonkey if I click that I have just
swapped narcissus which runs in spider
monkey for spider monkey as the
JavaScript engine that handles
application JavaScript text JavaScript
all those arm types if I now reload and
knock on wood I probably locked it up
but yeah it's it's now running the
scripts on cnn.com which are not that
challenging through narcissus
it doesn't run Gmail yet it's just
there's still some things missing and
performance is really atrocious but this
is Zaphod in action and it's kind of
crazy we actually made an application
narcissus mimetype we haven't register
we're not going to register but Zaphod
recognizes that so if you want to write
test pages that actually choose to use
the narcissus engine through Zaphod they
can target it with script I people's
applications are CSS I think it loaded
Wow
DMS let's see if everything works yeah
it's slow yeah there we go I believe
this is written yeah this is running in
their sis's so right here is a glimpse
of the future of the bootstrap
self-hosted small talk world we can get
to if we just keep working on it
it's too damn slow right now anyway
thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>