<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Olov Lassus: The story of when assumption met a magic hat | Coder Coacher - Coaching Coders</title><meta content="Olov Lassus: The story of when assumption met a magic hat - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Olov Lassus: The story of when assumption met a magic hat</b></h2><h5 class="post__date">2012-11-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yk6t4kRN53w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm going to tell you the story of how
assumption metamagic hat and my name is
all of lasses and can you see that all
the way back I hope the text size is
good enough so so you'll find on Twitter
a solo and so I'm going to start up by
talking a bit about correct code so
correct code is a great thing write code
that works as we intended it to work
that's perfect that is what we are
striving for is programmers code that
crashes needs improvement it's clearly
not correct unless we intend it to crash
but at least it crashes so we we know
that there is an issue with a bit of
code so we can go back and correct it
the real issue is when we have incorrect
code that keeps on running that is a
recipe for disaster I think I strongly
believe it is and I strongly believe
that we sometimes as programmers focused
too much about creating programs that
doesn't crash while that should never be
our main goal our main goal should be to
produce correct programs and in the
choice of a program that doesn't crash
that keeps on running while it's
incorrect and a program that crashes
early phase fast so that we know that
there's an issue I always pick that one
so I guess what I'm saying is that
crashing it's a good thing we should
crash more we can tell our buses you
know crashing that's a good good thing
and fail fast as an ID that is actually
key to making the robust programs not
only fail fast in robust system you know
where we have like redundancy that kind
of junk but also in you know the normal
day-to-day code we write fail fast I
think it's something that makes coding
more fun and eat better better programs
of course it's no silver bullet in
itself right so another code is that we
actually need to write code that works
getting the code right not necessarily
from the beginning but we need to
iterate on its order it actually works
some time but hey let's admit that we
make coding mistakes all the time and
that has nothing to do with whether we
have worked with this language that
we're now using for a year or two where
it would done it for two decades or
whatever you know we make coding
mistakes all the time of different types
and ironically we even make a lot of
mistakes when we are troubleshooting
code when we are in the kind of debug
mode will go back to code base and try
to fix things
we do a lot of mistakes and a lot of
mistakes that makes us you know that
stops us from actually identifying the
correct correct issue but also that
makes this fixed issue in the wrong ways
and the reason for this is because I
think it's most has a lot to do with
with assumptions so today's systems are
so complex and that we need to rely on a
lot of abstraction to get things done
and that's when we are using other
people's called results when you're
writing code we need to do it with a lot
of abstractions and we need to rely on a
lot of assumptions so for instance when
it comes to languages there if I use a
language that has a program in contract
that looks very similar to other
languages are used before I kind of
assumed that it works the same I would
be very surprised if an if statement had
you know a negated condition in a
language when I'm used to working in
some ways and more or less every
language created before it and it's also
the same with libraries right so we we
design libraries and ap is with
different patterns and if we are in node
and and Sony and we start using in a
library that doesn't really follow the
standard patterns API patterns of known
modules we get surprised sometimes we
model our libraries after other popular
library like a query but you let them
work slightly different people will get
surprised and and it would be hard to do
things so the way I like to think of my
brain is that basically it's like a
cache pretty small cash but fast it's an
l1 cache or something that can only keep
so much things in my brain and again
therefore I need to rely on a lot of
assumptions to get things done now
unfortunately there's often a big
disconnect between assumptions and
reality meaning assumptions what I think
the program does in reality what the
program really does it might be small
truth once like misspelling width and
height which always seem to be a problem
at least when we will try to identify
the problem because it's masked by our
brains it off by once you know when we
loop one too much or 12 little the
different corner cases when we're
implementing an algorithm or two and we
don't cover that we thought that it
would be in the general case but it
wasn't there's a disconnect there and
and in design in general I think the
most obvious case on
on that there actually is such a
disconnect and how is the problem is
when we are debugging when we are but we
know that there is an issue in our code
perhaps for some reason like a core dump
or a crash log or whatever it is we know
that there is an issue in this function
it's a function of 10 lines of code or
something and we have taken upon us the
task to fix that bug right so we take
that up in our edit or we put a full
screen on the screen and we just go line
by line trying to read it out trying to
reason with ourselves what it's tough
dust and it should really work right I
have no idea what it doesn't work
because it should so if this was C and
it was in like the early 90s or
something that we could blade in the
compiler because the compiler was always
wrong you see how to bugs sometimes in
code generations we can all say hey it's
a compiler mistake so I guess the
analogy for today is that we should
blame guys like Eric and the slob on
others in the VA team or or whoever
right because the vm might be wrong but
often it isn't often it's actually our
mistakes we are just not able to find
the issues in that code because we have
already have our assumption of how it
works what you can do then is that you
can ask a friend or click or whatever it
is perhaps a friend and a colleague and
ask both of them to come ask them that
person to come sit right next to you so
you could you could explain the code to
him or her if you start doing that and
you start it's playing so this is the
function it's called blah blah you know
first of all I set up my variables here
and I have this this in that object a
senator at module and I get something
back and then adjust and then you pause
because that's that's the moment of
enlightenment this the silent moment of
enlightenment when you realized exactly
what issue was and your friend you don't
have to do anything because what
happened was that you force yourself to
kind of step outside of your own
assumptions because you knew that your
friend didn't have the same context of
this of this program like you did so you
have to explain it in more detail and
you have to go reevaluate those
assumptions in your own brain one more
time and that made you fix the bug how
many have you know anyone else but the
mean that I had done that sometimes many
of you yeah does anyone know the
technique it has a name Oh all of you
knows it okay pressure should just end
this Tokyo you know this already so
rabid up computing
you have this rubber tag instead so you
cannot have your friend and your
colleague and your rubber duck or
perhaps in the same cut all of them
freebie this I don't know you can have
them you can just talk to a rubber duck
hey Doc I have this issue and you know
things will sell themselves okay so
that's for disconnect the brain is a
beautiful device right the beautiful
thing can you read this I mean can you
read it and can you see it and can you
read it you can't read it can you see
that it's you can see this right so we
can read it it's according to recent
research the human brain is perfectly
able to blah blah blah it's a weird
thing because our brain is so good at
pattern matching and at at fixing errors
so the trick here is that you fix the
first and last letter in each and every
word in the sentence and you can swap
the others around you need to keep
letters but you can swap them around but
the brain just fixed it for you that is
exactly why it's hard sometimes to find
the width and the height that was
misspelled and to fix them unless we use
tolling for it so the brain tries to be
your friend tries to fix things so thank
you very much brain sometimes that is
really really helpful at other times it
isn't and I think you know this
assumption this Robert a computing
debugging case if what's another one
what's one of those cases why am I
saying all this well what I'm getting to
you is that we should think much more
about making our programs easier to
reason about that should be a priority
of ours when we start coding and when we
you know when you design our code and we
when we maintain it we talked very much
about how to optimize it how to use for
a fancy programming construct how to use
the latest library the latest framework
latest language Slater's language
language the latest mythology you know
scrum leme x space and all the rage
these days used to be but now it's TDD
still and we talk so much about all the
different technique and stuff we can go
and read about them download and use
some stuff but we seem to not
communicate that much about kind of
other core issues here when we are
programming about the fact that we make
mistakes we make mistakes all the time
if we could reduce those mistakes we
would be much more productive it might
not sound like a super sexy thing to
talk about but it's really really
important and it's not boring at all
either it actually makes our jobs
our hobbies much more fun I think so
easier to reason about is increasingly
important now I guess in this community
with JavaScript because we have
JavaScript on the server we know that we
have it in the browser and especially in
browser I mean things have changed
dramatically right from being small
things to two apps that are moving all
the way to the client straps really
scale in terms of size of the code base
but also in terms of size of the teams
when we scale it inside so the team's
these things with assumptions becomes
even harder because we need to find a
way to communicate them between each
other it's not enough anymore that I
have my ADIZ or how I should write code
we need communicate it also so we need
to think about stuff like there's no
suitable for this we need to think about
stuff like motorized in our code putting
it into different modules making sure
that they have it discreet
responsibilities so that we can maintain
stuff we need to think about stuff like
a style guide if we are on a team now
how do you write code and why do we do
it if you missed Angus talk yesterday
which it was an awesome talk I think the
most important takeaway from that was
that we shouldn't listen to gospel we
shouldn't just take gospel as truth
because there's so much gospel in the
world right in programming from both
sides from all sides and but we should
take informed decisions and we are
adults so we should allow ourselves to
take whatever decisions we feel are
right for us and for our teams but at
least they need to be informed we need
to be to understand the trade-offs there
because there is always a trade-off so
you give something by using for instance
the language construct with or whatever
it is and you lose something by doing
that perhaps so that's just some of the
things and I'm going to talk more
specifically about subsetting language
for this but before that i'm going to
talk about assert how many hair here
have used a cert or are used insert in
the DJ s awesome how many are using
asserts for something that isn't in
their test suite but in there normal
code okay quite a few but not that money
and that's what I want to talk about
using a cert but not in your test suite
but in your code directly that is how we
actually started out using insert when
we created this programming construct
not for JavaScript but for other
languages that we were using certain on
our test Suites so the idea assert is
based
it's a statement and you feel it an
expression the expression is an
assumption to say hey I assert this this
is my assumption this needs to be true
in a difference if it isn't then the
following code you know can I have no
idea what it does in that case I can
take no responsibility for that boss so
you know this needs to be true and it's
a way of documenting their that
codifying that assumption but getting it
verified because once it runs what
happens is that assert just check this
expression and if it's truth Lee nothing
happens the program just continues but
if it's false e then the program crashes
and crashes fast instantly it crashes
directly there and it gives you the
information you need because not only
does it crash in the realest certain
limitation but it also prints out your
log or whatever it is the string ified
representation of your expression to get
rid of function line and file name so
you can easily see from the log you know
where things went wrong so what happens
is that we can document and verify our
assumptions and we cannot fail faster
this is very powerful and very easy to
use so here are just three you see those
three examples how you can use them for
instance you can assert that an object
state is free so perhaps I'll be
pressing made a custom allocator or like
an object pool or something I now pick
this object as candidate for giving out
to someone like a cached new or
something and but before that I just
want to verify that it's actually tied
as free because otherwise i will now
start writing over something else its
way or just protecting me from what i
know should be the case but I'm since
I'm only 99 percent sure that the code
currently works that way I actually
documented for me and for others in the
future we can also do other stuff india
is like assert organs length 3 plickers
to that sounds pretty stupid I think to
too many why would you assert on your
ornaments length that's like user input
and everything well first of all this
isn't in a public API there's this shoot
you can search more about that on the
web about using a certain that we're not
talking about the search now and talking
about internal api's but for instance
when i do refactoring in jazz so when i
when i change the air over function in
JS from like two to three or from three
to two arguments and most of the time
when i do that i'm pretty confident that
I casual the cold side today update then
too but sometimes I'm not one hundred
percent confident that I do that
and we're not one hundred percent
confident that my tests actually catches
that in that case I just drop in a
search there you know it cost me like
five seconds to write it and I keep it
until the I do the next commit because
if one call site now when I run all the
tests and when I when I try the program
out if one call site actually
accidentally was not updated then a cert
will fire immediately and I can just
remove it it's very cheap the last third
example is just you know type of cast it
should be a number and by the way it
should be a real number it shouldn't be
infinity neither the positive or the
negative one and should certainly not be
an an and if you got a man in your
program by the way in jas that's more or
less always a sign that you in that your
code is incorrect rarely do we write
code where we actually do get man and
that that's the intended result is
Morris always that we have like user
data or something that we didn't
sanitize enough or just another code a
mistake so that's how a cert works we
can use it in in jas we can use it when
you string inside representation so
there's a link there I'm going to post
the slides later for for an example how
to choose a framework I created to to
actually do real asserts in JS what it
gives us is that it makes the code
easier to reason about but because now
we have codified our assumptions it's
there for me like in an hour when I
forgot what I right but I wrote or for
me a month from now when I really forgot
what i wrote or for my team members to
read and understand my assumptions it's
really powerful the code becomes more
robust because it fails fast just like
you want it because we certainly don't
want the code that just keep on keep me
running it very much so simplifies
refactoring and code changes because now
I I am confident in the code I'm
confident that thanks to all these
asserts together with my test suite you
know when I do stuff when I change stuff
internally in my api's if they if I do
things incorrectly then their search
will fire most likely overall it gives
us more confidence i think it invites us
to do more changes through code but
sometimes when we feel that code is a
bit fragile we're afraid of that as a
side effect which I realized very
recently after getting and point out to
me it's sometimes actually makes it
easier to write our units tests too
because if we go really far and do the
various search rich programming includes
resurgence in our code then our units
ethically focus more about providing
input through functions and seeing you
know if the function doesn't crash then
then it could be okay so it's not that
extreme but but some artists can become
easier and it doesn't slow you down
trust me if you haven't tried using a
search this way it never slows you down
it speeds you up because writing that
search takes very little time if you
don't write it I can assure you that
when you read the code when you write a
code your anyway is going to have the
conversation with yourself you know what
is the code real doing well I think it's
doing that you're going to do that you
know over and over again and your
colleagues have no clue what your
assumption was so it speeds you up other
assumptions Yammer's in das you know
every language has its awesome parts and
it's you know less awesome parts it's no
different there here are some assumption
jammers for me something that increases
the disconnect gap for me undefined and
all we have two of them which
complicates things a bit the books types
which doesn't play at all nicely with
the primitive types so we therefore most
don't use them the functions go first is
the block scope we all know about that
it's an assumption Yammer for many
especially those new to the language but
it can be actually be an assumption
Yammer for those who are working for
many years to surprises me once in a
while still the global pollution is more
less a fixed problem with these five
strict mode the faulty values we have so
many of them why do we have that but we
just have so many false values it's a
bit more complicated to have them in our
heads they keep on running the sign of
jay is in general it's very much keep on
running or keep on tracking that's how
it's designed so it's it's it's not
designed to fail fast it's opposite of
it I was thinking about saying that is
the it's the not equals to fail fast but
I realize that I might put in the queer
Singh operator so it might be a still do
the same thing so but keep on running
and and then you can mix drinks and
numbers in arithmetic operation that's a
huge assumption jammers in Jas not only
can you do that but you can actually mix
any type and any type in your arithmetic
operations actually in more as any
operation you use you can use any type
and that's what I'm going to talk a bit
more about now plus is the ultimate keep
on running thing in Jas so plus exactly
like our brain before an example in
order to swap characters that piped into
the brain
as a stream plus says let me fix that
for you I think I know what do you mean
you gave me all know and gaming
undefined but hey you know I know what
do you mean you wanna have a man seldom
do you want to have a man I mean Nance
should be your more or less prohibited
in the language they are more less
always the result of a coding mistake
but it is what it is right and we have
learned to deliver this and some some of
us say that hey you know it's so
expressive the plus is so expressive and
so is minus by the way it's very
expressive I can do anything with it I
would like to see that anything and
because I think that it's just you know
it just more error-prone while there are
so many dynamic beautiful parts of jay
is that really helps us do real
expressive stuff and i think again in
angus presentation yesterday like weed
you can actually do more expressive
stuff by using but there are drawbacks
to you too plus and other operators you
know our are very not failing fast but
keep on running but they don't give us
much in return and for science see my
now stroke slice it was that correct it
should be part of my french i hope it
was but weak typing in a dynamically
type language is not very helpful at all
it just isn't and i think we need to
think about that too in the jays
community I think we need to talk about
that and I think we need to talk about
that that is a very rare thing very very
few other than ample type language share
this property Oh ours and we need to
think about that so look at Ruby or
Python or most other lisps at least
after the 60s look at the proper closure
for instance where is all of them are so
it's not a binary the screen whether
you're weak or strong but they are very
much so stronger typed than J is so weak
typing in this context basically means
that if you take an operator like a
binary operator taking two operands in a
weakly typed language they will try to
do something with the type of the type
convert them implicitly what we call
type creations in the jas to do
something good with it exactly is a plus
tries to do and I argued that that is
the wrong thing to do it doesn't help us
at all in the plus case can you read
this in the past case a plus B what it
does is that first of all it converts a
and B to primitives so primitives and j
is then we have undefined know
all a boolean a number or straight
that's what we get now it does so by
calling a value of and then a two-string
it calls a two-string unless a value of
return the primitive so if you return an
object from that why you should do that
it's going to call it to string two
unless a is a date because de tarso
picker india is that we actually deeply
embedded those in the semantics of the
language so if it's a date we're going
to do it in opposite direction opposite
order and then if at least one of them
is a string that we can work the other
two a string and we concatenate them and
if they otherwise we convert both two
numbers and we add them and I must admit
that first time I realize this coming to
jay is my head exploded my head exploded
when I realized that under the hood when
I do when I perform the first operator
j/s Matt might do a string to number
conversion implicitly for me because
that was unheard of for me from all of
the other language I worked with and I
thought you know that can't be very
helpful at all that gives the illusion
that you can mix drinks in numbers and
produce meaningful results while you can
you can't do that in any kind of larger
scale there's the double equals in
triple equals thing right again Angus
talked about that and I'm so so my
position that is that I prefer to Bleak
walls because I understand its semantics
easily and i can tell that to you now
while double equals is more complicated
I think there's exactly one use case for
double equals and it's safe and Angus
talk about that too it double equals
know if you really think that it's
important to say double equals null and
you meet button by that meaning equal to
null or undefined and you prefer the
short notation instead of creating a
function or something for it then by all
means do that we can statically verify
that you're actually just doing a double
equals null and that's safe for others i
personally prefer triple equals it's
yours to keep my question is where is my
triple plus has anyone seen it I found a
double plus but it didn't really do what
I intended to do so where is my triple
plus you know what when I searched for
it I finally sold magic hat full of
surprises in jas so on the top row i
found the comparison operators and then
the art mythix and then the bitwise and
the shifts the euro- and increment
decrement wow there's so many surprises
in there because they accepted
anything I gave them in a game is
something in return that was mostly not
useful unless the input was useful so my
question then was what if we could
restrict the hats to something less
surprising could we ask you to do what
we wanted to do and nothing more here's
my suggestion let's take the first row
and let's say that for ordering for
comparison operators they accept strings
or number but never mix so a number less
than a number we know what that's
supposed to do number the number
conversion and a string less than a
string you shake lexical ordering right
that is everything that makes sense we
don't need to accept anything else so if
you give it a mix a string in a number
which should give them a null and
something or none define or something
that would just crash we say it fast
because we know that we have an issue
now in our program for plus we lacks a
bit more we give it a stringer number in
any combination why is that why can't we
say number plus number is addition
string string string concatenation well
because you often do swing plus number
and by that you mean a convert to number
two string and then concatenate them so
let's allow that still for everything
else numbers that's it why would you
ever want to do anything other than
numbers on these guys it doesn't make
any sense so for all those so for them
for bitwise operators and the shifts and
the increment decrement just do it with
numbers how would we do that well we
would instead of writing VAR x 1 equals
1 plus y we would say x2 equals dunder
add 1 comma y and we would create
Thunder AB with two assertions and then
return the plus so that would be
slightly inconvenient right because now
we have to rewrite our entire programs
so press we can't change plus after all
and here is when I try to do a demo can
you see this is it visible yes
hallelujah okay so let's create an
average function so for now let's just
say that we have some kind of translated
version to the right even though it's
going to a very rad what is happening to
my average x and y
okay so average that should be returned
X plus y divided by 2 huh there we go oh
it looks the same ok so it's some kind
of translation going out but it seems to
be the same for now doesn't matter let's
print something to the to the console in
the blow let's print average 0 1 &amp;amp; 2
what is that any 11.5 let's do it yay
whoa go Jay is 1.5 okay really in 1.5
okay good let's try it with something
else to try it with you engage we can
mix ring some numbers freely and jas
actually fixes that for it so the
average of one is ring too it's also
it's six so here's just the realization
we cannot mix strings the numbers freely
we always need to know whether a
variable is to string or number and if
we fool ourselves into thinking
something else you know that's a recipe
for disaster we don't want to do that so
it's six why is it six because you take
you take it one number 1 plus ring too
what happens you have a string
conversion number one becomes string
num1 you concatenate them into the
string 12 string 12 / number two then
you do the implicit string to number
conversion so you get a number 12 / 2
and you get a six other cases that are
really coming in jayus is like we have
this variable that we forgot to
initialize like X for instance so say
that we didn't initializer we've got an
undefined from from a function or we we
are looking at the object property that
doesn't exist we're going to undefined
and when we do that we get whoops when
we do that we get man we have this
useless man that doesn't help us
remember thing we would prefer to have a
crash right so here's how I crash this
so instead let's just add a directive
here let's say use restrict how many
have used es5 strict mode okay use
restrict works similarly you can add the
directive to your top of your program or
through two parts your program to
function now you see what happened there
translator replace plus and division to
this function called the down recalls
that has the type assertion if you're
not run this we're down to find we're
going to get BAM restrict mold plus
called me a number not define you get a
exception thrown and you're going to get
you're going to get precise information
about line and everything if you do it
with a to this ring to same thing you're
going to get an exception you're going
to get an error and you're going to be
aware of their in this case you actually
don't get exception on the plus because
in restrict mode we actually allowed a
number plus dream because you would like
to do that but we got it on the X on the
division a string / a number that's not
allowed so that's how we can try to fix
this so the idea very strict mode n is
to say I promise to limit myself to a
subset I use a checker that translates
my code and you search this type of
search and in my program and of course I
then execute the checked verse and while
I'm being while I'm developing I still
keep my tests this is no replacement for
tests whenever I break through a subset
promise the program phase fast so I'm
informed of the issue and I can correct
my program and the beautiful thing is
that all the semantics I described to
you that's a subset of the existing
semantics in in the language today so we
don't add anything we just remove parts
which means that once our program is
correct we can just deploy the original
program you don't need to deploy the
translator one it takes six it executes
identically in restrict mode and normal
nodejs what do we gain the program is
easier to reason about now because when
i read source code that has to use
restrictor active I have a certain
understanding I know more about
semantics I know more about the meaning
of the program just like a search it's
the same thing and whenever I need to
fix bugs in it the Assumption versions
reality disconnect just became a lot
smaller I know now for a fact that we
can't get a non out of that unless we
fed a man into the plus operator we
can't get a man out of it for instance
so my program becomes more robust is
this the right subset I mean anyone
could create a subset right so I guess
the way to evaluate it is that it can't
get in a way we need to be able to write
their programs like like we would like
to do and he should work and apply it to
existing product the subject mismatch
should be tiny so then just very very
briefly now but I tried to you know just
take a big piece of code take that slab
the use restrictive on top of it run
everything to the translator and then
execute the test suite for the program
just to see you know how many errors do
we get and this this is in code that
actually works so the errors should be
indicative of a subset mismatch you know
somebody wanted to do things that is not
allowed to interest Rick mode if he
advanced you know no big mismatch
whatsoever I had to change a handful of
lines it found a bad practice in
cracking yeah works fine it catches the
old man back the undefined plus
something would produce the man in
jQuery great match to and actually found
a bag which we fixed in case Lane very
very good match to found a debatable
practice I I said it bad practice but
then we did a degree in it so it's the
debatable to practice so from this
experience yeah and finding issues was
very unexpected this is kind of driven
under hood by a framework called yet
shaper sources source rewriting an
engine that i created a year and half
ago it's only a shaped org MIT license
you can download and play with it it
runs you know you can run in a browser
and actually you can now even run it on
the fly you can get your stick mode
checking on your program in your on the
fly if you want to thank you some AMD
magic there is strict mode checker is a
plug into this there are others to
assert that we talked about that's what
will give you nice good assertions bit
wiser watch your a yielder which
transforms your yield style code to
normal code time for me to wrap up if
you want to use restrict go through
sigma dot orgs let's try downloading a
shaper put it in your tool chain if you
don't want to run it each and every time
you run your program because perhaps you
don't like the idea of having a tool
chain or in you know slowing down your
tool chain at least you can run it
before you're executing your tests
doesn't really cost you anything but it
might help you expose something if it
matches or doesn't match your subset let
me know i'm really interested in hearing
that there's no luck in you can just
remove the use restrictor ecting no one
needs to know that you enter in the
first place you know but it gives you
just a subset it just is still just
JavaScript to wrap up this whole idea
easier to reason about so choose your
subset you know consider the pros and
cons of different subsets consider pros
or cons of different constructs and
style guides and choose your together
with your team if your own team
definitely consider using tools to help
verify those such as jess hint or or
restrict mode or whatever it is consider
this idea of sprinkling a surgeon's in
your code it might be a good thing you
might like it a try it absolutely
prototypes getting your API is right
challenge your assumptions especially so
when you are in debugging
old I if you don't have a rubber duck
handy and room remember that reading
code is the skills so keep practicing
practicing it and learn from others and
have fun so this was a story about how
assumption met a magic hat denial of
Leicester's thank you I'm not sure
whether we have time for question one
question am I got you so let's see em
what are you thinking about checking
indexes on the race using some kind of
this transformation as well yeah so you
could do that another question often get
is you know should we check for it to to
change truthiness it should we check
that so in terms of toothless now that's
very very deeply burden language is hard
to do anything sure we could do that we
could override the the index operator
and create a add under index function
I'm not sure how much that would give us
because in das it's I mean it's common
practice to to reference a property that
doesn't exist say dot something and
check what is undefined so that would be
really surprising is that started
crashing I'm not sure how how common
practice it is actually to index an
index in an array that doesn't exist and
see whether it's undefined or not but I
think it's common enough that it will
kind of you know get people a bit
worried about using this subset
otherwise I think it's a good idea it
could be an option okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>