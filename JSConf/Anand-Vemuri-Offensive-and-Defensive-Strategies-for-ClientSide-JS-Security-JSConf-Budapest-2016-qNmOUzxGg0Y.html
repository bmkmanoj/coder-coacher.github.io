<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Anand Vemuri: Offensive and Defensive Strategies for Client-Side JS Security - JSConf Budapest 2016 | Coder Coacher - Coaching Coders</title><meta content="Anand Vemuri: Offensive and Defensive Strategies for Client-Side JS Security - JSConf Budapest 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Anand Vemuri: Offensive and Defensive Strategies for Client-Side JS Security - JSConf Budapest 2016</b></h2><h5 class="post__date">2016-06-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qNmOUzxGg0Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">sorry I don't mean to okay sorry about
that um so yeah this is who I am and so
we're going to be talking about security
best practices today and they say that
you know in defensive security you have
to like prevent against a lot of
security vulnerabilities and I find that
the easiest way to really prevent
against your you know security
vulnerabilities on your application is
to have a really good understanding of
the offensive perspective so we're going
to take a little bit of an offensive
stance today as we go and go ahead and
break the web so just a quick raise of
hands how many of you guys are are
hackers how many of you have worked with
security either developing secure
software or just loosely like using
using some kind of security concept just
raise your hand awesome and that's that
that's good i'd like to see a lot of
people doing that because i mean that
we're developing secure content which is
good for me as a user to know but yep so
I'd like to take you on a story that was
kind of the motivation for this this
talk really and it starts with this
vulnerability called cross-site
scripting these cross-site scripting is
a vulnerability that it's it's basically
you know people make a very big deal out
of it it's considered to be one of the
most critical vulnerabilities and it's a
very serious vulnerability as well and
it it's a it's a vulnerability that
attacks users you can think of it as a
client side JavaScript eject injection
attack so basically if somebody is a
user I can inject my arbitrary script
into their browser and have their
browser run whatever I want it you're on
if an application is vulnerable now I
would not do anything malicious
personally but I know that there are
many people out there who if given that
ability would use it for no good so we
want to prevent our applications from
these kind of attacks so how does it
work well it starts with a really evil
guy and this guy sends a malicious
request to an innocent victim the victim
will then click on the link or whatever
it might be maybe it's stored in the
payload
hidden the DOM and the content has done
served the user and the script executes
and this is a typical scenario that we
see for cross-site scripting so coming
into the application security space I
was very excited by these kind of
vulnerabilities I would you know before
I had any real formal training and
application security i would i would
read up about these vulnerabilities and
feel very very elite and a hacker like
because i was able to inject JavaScript
into my friends pages and just be in the
elite hacker so when I when I one of a a
client assessment that I was working on
I came into a very interesting scenario
and you know it would be fun for me to
tell you about it but it would be even
more exciting for me to show you so I'd
like to start hacking and quick shout
out to my colleagues Ken Toller and
jelly Bedoya for creating a open-source
vulnerable node.js application so you
guys can this github link is the is the
repo and you guys can use this for your
own hacking pleasure it's it's
completely intentionally vulnerable so
you can practice all your skills on it
okay so i think i have this thing
started on my localhost 3000 okay and
this is the application and what i'm
going to be doing is I'm going to be
using a intercepting proxy called burp
suite and what burp suite is is
basically every time I submit a request
to the server from the client rather
than actually authenticating it's going
to sorry rather than actually sending it
directly to the server it's going to
it's going to go through my proxy and
then my proxy will send the request to
the server so let me try logging in okay
and there you see my password but this
is the this is the login request to the
server and so we can interest let the
intercept go through and we're testing
the application and it's basically like
it's a fork of the wine cellar backbone
tutorial app written in node but it's
got some added features because it's
vulnerable and you know we're just kind
of when you're starting to test the
application we're just kind of looking
around to see get it getting a feel for
things and we see like okay like we can
edit these fields and so okay well why
don't I do like just type something in
for fun and see see what happens I'll
turn my interceptor on and I'll save and
my request comes through and it looks
like it's a JSON request that's sitting
up put to my server in back okay this is
this is the expected behavior now let's
try to do something malicious and
JavaScript starts with a script i
believe and we'll put a pop-up notifying
our users that they have been hacked
i'll hit save okay nothing looks like it
really happened not super exciting oh
look our pop-up just fired so this this
is a clearly vulnerable to cross-site
scripting now we've injected a malicious
about malicious URL into or script into
our page moreover every time we load
this page again it's going to come back
again this is a stored cross-site
scripting attack and so I'm sitting here
and I'm really excited now because I'm
able to go to my client and tell them oh
my gosh like we found stored cross-site
scripting on your application this is a
really serious deal this is I mean this
is like their bug bounty programs that
pay upwards of ten thousand dollars for
finding you know flaws like this on
their application so I am extremely
excited and I tell my client this and
I'm expecting them to be you know
writing me a million-dollar check and
getting
no a public news article about how I
saved their infrastructure and I'm just
really excited about this unfortunately
the customer is not really impressed and
I'm wondering why is it that you know
you might not be impressed by this
vulnerability I mean this is a really
critical vulnerability and I was able to
easily demonstrate it so I'm like no
this is actually a really serious
problem you should you should take a
look at it and they they're like no and
there's two reasons why they don't care
about it the first reason is that fur
starters the the request that I've
demonstrated happens in a you know in a
put request and so there's a vulnerable
parameter in the put request and the
only way for me to actually attack the
application is if I were was able to
intercept the put request and inject my
malicious content and send it to the
server right now this process is really
difficult to do unless you're just
attacking yourself this is the clients
logic as well I mean there's there's no
way that a user who we trust to use our
server would would do this to themselves
so I don't really think that this is a
big deal I don't really see any huge
need to fix from this so unless you can
show us something else I think you
should just try harder secondly the
application is not even exposed to the
public internet it's a private server so
you know I can't even go to their
application and test it i have to go
through some kind of VPN that only they
have access to so i'm a little dejected
by this because i put a lot of effort
into this vulnerability and it didn't
really make much of an impact and in
fact they're they're thinking about
letting this vulnerability just go and
slide without really demonstrating any
real impact from it and so I feel a
little dejected off by that but I sit
back and I ask myself two very important
questions one how do we exploit
vulnerabilities that require victims to
attack themselves so to speak secondly
how do we attack web applications on a
private network like that we can't even
access I mean is application security
limited to just
public things so after doing a little
bit of googling and research and study I
came across this class of a text called
to surf attacks on Caesar for tax are
kind of the vulnerability that many
people might not have heard about but
can actually be used in very crucial
situations to really deliver some very
cool cool results so Caesar stands for
cross-site request forgery so what this
basically means is if we look at how
this works is if we have you know our
attacker mallory and our victim bob and
let's say that bob is on the internal
network or maybe has access to a server
and we want to make bob do something to
attack himself essentially or send off a
request as though we were Bob what we
could do is Mallory can set up a
malicious URL from a third-party domain
and because both people have access to
the public Internet when Bob goes to
this domain and interacts with it that
page will then submit a state changing
request to the third part to the
original domain that we never had access
to so this is the same kind of logic
that we use if you go to facebook com or
gmail com in one browser and then you
open up another tab and then you you go
to facebook com you don't have to keep
real authentic eating because the
cookies are stored in your browser and
every time you send a request to that
domain the cookies are sent with that
request even if you're not necessarily
your origin isn't that that domain and
so we're basically leveraging this
fundamental flaw that was you know the
internet was developed with to attack
users who we can't really access you
know privately so let's let's see how
this works okay well I have here on a
public server a
there we go so here is a public page you
might have gotten a pop-up like this
before when you were casually browsing
the web and this is a just you know a
third-party domain it's completely not
associated with our med seller
application but it is very convincing I
would like to get 1 million dollars and
it's on the internet so it can't be a
lie so so I'll turn my interceptor on
cuz I'm a little cautious I want to see
what's actually happening behind the
scenes I'll submit this request if you
take a look here what's happening is
we're sending a post request to register
an admin user by the name of lolcatz
until let's just see if this works and
we're actually redirected to the Maine
med seller page so let's try logging in
with our new user LOLOL and of course
we're hacked but now as you can see we
are we're logged in as an administrative
user because we've exploited the Caesar
phoner ability on this application now
one thing to note is that the way that
this application works is that there are
admin users and normal roles and so
we've actually created an admin account
which is why we're able to see all of
the medicines even the prescription
medicines in this case and so this is a
you know we've just kind of exploited
this vulnerability using a boner ability
that we didn't think was possible before
and so we're really happy and we go back
to the clients and we tell them you know
we've used to surf and now we are able
to attack your application even if
you're not publicly accessible so we're
making progress they come back to us and
they say you know that's cool but we use
web services and everything is handled
by a JSON request and so the whole logic
behind your attack is that you're
forging an HTML reform to be submitted
to my server and because we can't forge
an HTML form to send json requests this
is really not an issue for us either so
try harder and so it's a little bit of a
setback now because even though we found
we've made progress we're still not able
to you know completely convince them
that we can chain exploits together and
make danger happen but then we start
thinking about things and the way that
the JavaScript works and JavaScript
servers handle requests and we realize
that you know JSON posts are not
completely safe if you think about how
you know the server handles request
server-side you'llyou'll most of you
have probably written if you've written
server-side code you've probably written
a function similar to this we have fun
can request response and then you're
setting some body parameter from your
post under request body and request body
is actually a JSON so what what's
interesting here is that well you know
even though the application is expecting
something that looks like this which
with encoding type JSON if you don't
specifically say that I'm only going to
accept JSON objects and I'm not going to
accept anything else if you send a
request that looks like this of text
type plane it'll still come as a request
object and you know and the server side
it handles it as a JSON so we can
theoretically you know use use our
exploit to you know forge an HTML
request as though we're in HTML form and
and exploit the server but this time
let's have some fun because we've
already discovered that there's a
cross-site scripting vulnerability and
that's really what we're after how to
exploit that and I'll site scripting is
a very serious problem and in order to
help us facilitate the exploitation of
cross
scripting we have what's called browser
exploitation framework which if you guys
haven't heard of this before is really
really cool it basically makes
exploiting cross-site scripting almost
like a point-and-click kind of thing and
so we're going to use this now and we
have here very conveniently we have
okay so this is another seesaw request
and this is a even more convincing
argument in the last because we didn't
win anything last time but telling us
this time we will actually win let's
take a look at what this is actually
doing flips view the page source and if
you can see over here we have you know
we're constructing our form but inside
the name parameter we actually have a
cross-site scripting payload which is
injecting this seemingly harmless script
into our page so let's see what happens
when we do that we are going to submit a
JSON request now while our request by
HTML form and we get a JSON response
back because that's what happens when
you send a JSON request and you know if
I was just a user and had no idea what I
clicked on I'm just really bummed that I
didn't win a million bucks right now for
the second time thought I'd learned the
lesson the first time but if you look at
our browsed meds we see this interesting
guy here and this is a this is we've
just created a new medicine and we see
that this script is here and I mean
there's no pop up there's no there's no
real indication that we've been hacked
if I didn't really look at this page I
wouldn't know what's happening but as it
turns out secretly enough I have a
server here that is running Kali Linux
which is an offensive security linux
distribution and by the way if you ever
walk into a coffee shop and you see
somebody using kali linux disconnect
from the internet and run away because
there is no reason for somebody to use
this unless they are professional
penetration tester or like doing
something that's not you know good so we
will check out what's going on in the
world of beef
okay and now we see that our IP address
is online and we actually have remote
access our to our browser and we see all
of our browser information here we see
that it is a you know Mozilla Firefox
little LA and so this stuff is pretty
cool but what's really interesting is
that we have some commands that we can
kick off and let's see so there are some
very interesting exploits here you can
find the session cookie for the users
you can install a keylogger you can do a
lot of really cool stuff but you know I
never really get a chance to demonstrate
any of the more fun ones and because
we're at JS conf we can kind of have
some fun with this so let's try to play
a sound so I can try to stream my
content through another person's browser
so I'm going to kick off this this audio
file and if all works well let's put the
button and we're just casually browsing
so we've just demonstrated that I mean
we're now doing this all remote as well
so we're able to kick off our own audio
stream on to the clients browser and
this is just one of the many instances
we can control their webcam we can
control you know do a key key logger get
their session we can do quite a bit with
with cross-site scripting and caesar
combined together it's a very dangerous
combination
so so how do we fix this because I mean
if we're getting to a point where I can
play my music on your computer they're
using your web application during work
hours I'm sure many companies wouldn't
be very happy about that so we want to
work on fixing this vulnerability so
that we don't have to worry about you
know these kind of attacks in the future
and the way to do it is really what's
called a sea surface oken which is a
cryptographically secure synchronizer
token pattern so what what this means is
that when the browser sends a get
request to the to the web server ideally
you'd want to create some kind of token
as either a cookie or a hidden field or
a header or something that just
basically authenticates the browser to
the server and says hey this is the
right browser this is the browser that's
intending to make this request if if not
then you want to completely disregard
the request so when we submit post
requests or stain changing operations we
want to see that see surf token along
with the request otherwise we would
reject the request a secondary defense
mitigation that you could potentially
have and when we're talking about
security vulnerability is there's really
no silver bullet there's just a lot of
barriers you could potentially bypass
one so it's a good idea to have multiple
defense mechanisms in place and so a
secondary defense a quick band-aid if
you discovered this in your application
is by setting the origin header so if
you do then you're pretty much ensuring
that only if you validate for the origin
header which basically says that you
know only accept requests from the
origin so you know then you don't have
to worry about third-party attacks and
finally we have CSP which is another
potential secondary measure CST is a
very big topic content security policy
these are basically headers that you can
set in your browser to prevent you know
malicious scripts from being injected
it's very good for cross-site scripting
mitigation and you know other injection
attacks it's a fairly complicated
process which marathon talk on its own
so if you want to learn more about this
please do either tweet at me or hit me
up at lunch or anytime you see me and
before we leave I want to make three
points regarding Caesar
one is that random is not the same thing
as cryptographically secure and so
cryptographically secure mean i mean
when you talk about computers there's
really no such thing as real randomness
everything a pseudo-random and so if you
have you know master andum is generating
32 numbers which you then uses your sis
your token that might seem very
uncrackable but the problem is is that
when you're dealing with very large or
very large computational devices they
can use you know the NSA would have the
computational power to crack that
because it's not cryptographically
secure there's a pattern behind it so as
much as possible if you have to develop
your own custom Susur which I don't
recommend but if you have to use
whatever's cryptographically secure
secondly implementation of a good C surf
mitigation is really difficult because
there's a lot of things to worry about
method interchange is when you're able
to submit post requests as get requests
and if you're able to submit post
requests get requests well guess what
typically a lot of your state changing
operations are just post but if you're
doing it as yet then there's no real
protection that some frameworks can
offer against that attack so you can
bypass your mitigation just almost by
switching the verb you could also have
see sort of token replays in where the
token will you know if one token can be
reused multiple times and so if you
generate a large number of tokens and
then just you know send them out you can
potentially have you know the same token
being used multiple times it's not a
very robust approach to securing your
application the token must be tied to
the user session on the server so if you
could imagine like if Facebook allowed
for you know you need to find my C surf
token and then construct a CSF request
for your account I could post statuses
on your behalf by forging a request
because I could just use my token so
that wouldn't be a very effective
measure so we want to make sure that the
token must be tied to the user session
you know so only you can use your token
and if you are using CS or tokens
exposed in your get parameter as a get
parameter then the problem that you run
into is that you could potentially have
you know logs or some other network
traffic's see the SI sirve token in the
network traffic itself and intercept it
that way and so even though it's you
know still something you could it's just
kind of a decoration on top of what the
what the attacker really has to do to
exploit so implementation for this is
quite difficult and finally the cross
origin recut resource sharing so this
header is something that's very
interesting I see this very frequently
with some of the applications that are
very enterprise level so what you
usually see is this header the access
control allow origin this allows your
application to be accessible by
third-party resources and so what this
means is you can essentially send xhr
requests from a third-party domain to
your application if you've set this
header to allow for that now if you do a
wild-card approach and you allow for you
know any origin whatsoever the problem
that you run into is that you could
potentially have a situation where you
have you know an attacker submitting an
xhr request and forging a request from
you know from the third-party browser or
third-party application to your ear
application but because you're allowed
to use JavaScript in this case you can
get a call back to so whereas
traditional CSF is just for data our
state changing operations if you enable
cross-origin resource sharing you could
potentially even get data exfiltration
so you get requests become vulnerable at
that point so make sure that like this
this wildcard header it's not a good
thing you should always try to make sure
that you're able to allow only the
domains that you need to access your
application that you trust so here are
some resources for different JavaScript
based servers that you can use a
middleware that you could just plug and
chug into your application that makes
this whole ceremony very very easy to
fix you have like see surf khoa happy
express you surf I use these all the
time and you know javascript is very
lucky in the sense that you can you know
middleware is very easy so if you were
doing this in other languages it might
be more difficult and more of an
architectural shift in your application
but you can do this very simply
and it has a very tremendous security
impact if you do that so a major
takeaways that I'd like to deliver here
are that application security
vulnerabilities can be used in
combination so as we saw even though we
had like a low severity cross-site
scripting if we were able to combine
that with a cross-site request forgery
attack then those two vulnerability is
combined could then deliver a very
dangerous attack vector and so just
because something might seem like it's
not a very big threat I think the
important thing to take away from
application to application security is
that the context really matters and so
it really depends on what else is
President the application no state
changing operation should be get
requests if you're doing state changing
operations as get requests in your web
application then you're kind of
complicating the security of your
application because you have to protect
see surf on get requests which is never
easy so as much as possible try to avoid
this make sure that the csr token is
cryptographically secure even if you're
using a trusted like trusted middleware
provider evil you know krypter krypter
graffiti evolving and so what might be
secure now might not be secure 10 years
from now so if you're seeing a browser
or a paper from 1999 telling you to use
a certain algorithm you might want to
double check that for today's standard
and finally see search middleware saves
lives so please do you know fixed
implement as much as you can mitigations
for this vulnerability so thank you so
much if you have any questions you can
always tweet at me or hit me up at any
time outside thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>