<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Rektide de la Faye - HTTP2 Push and WebPush – JSConf US 2015 | Coder Coacher - Coaching Coders</title><meta content="Rektide de la Faye - HTTP2 Push and WebPush – JSConf US 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Rektide de la Faye - HTTP2 Push and WebPush – JSConf US 2015</b></h2><h5 class="post__date">2015-12-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ac-qBrG5wVc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello hello everybody my name is Matthew
foul I'm here to give you a talk on web
push away this talk features htb to
using push and there's a fantastic
protocol that is kind of the reciprocal
dual to there's a new push API for
getting content to the browser in an
asynchronous manner and this is kind of
the dual back-end technology that backs
that up so welcome to web push away this
is web push generic event delivery using
HTTP push it's pretty rad this talk is
pretty rad I think that I excuse me it
is rad because uh web pushes itself a
web q something that we haven't really
had before in this capability Hugh's
themselves are a pretty great technology
we seek Hughes getting use throughout
the industry in the back end and it's
something that we haven't really been
able to use as a resourceful construct
on the web we have technologies like
Kafka and RabbitMQ which significantly
power a lot of our infrastructure and
web push really begins to open that
capability to something that we can
begin to use on the web and that we can
exchange as a resource and trade amongst
our resources a trade amongst our
systems the web is great and one of the
main things that I really think makes
the web great is the fact that it has
that there are resources that the things
on the web exists tangibly because they
have URLs associated with them there's
Tim berners-lee's paper axiomatic sub
the web or actually I don't have the
name off the top of my head but his
axiomatic sub the URL where he discusses
the how valuable URL is so a web q a web
q is something that should be pretty
great web push as a web q has some
capabilities it has magic it has HTTP to
magic it has push magic it has really
great magic it's not actually magic it
is actually push and it's probably still
great I do think it's definitely
something that is worth talking about
probably great
probably great it's a solid model for a
cue it's the first time that I've seen
somebody has really stamped out and said
what kind of URLs you should be hitting
to use a queue and that's really that is
the fundamental of like what resourceful
means to me it has interesting
innovative techniques the push not magic
it has an interesting application for
getting data into the client whether or
not that client is connected to the
Internet at that time or not that a
queue part of a queue is that you push
stuff into a queue and you get stuff out
and we'll look at how that can happen in
different fashions then online real-time
and it is making itself nicely through
standardization it was an effort formed
by Mozilla and it's now being
implemented and the spec is co-authored
by Microsoft who's doing some they're
doing some very interesting
optimizations to really allow a huge
number of concurrent push subscriptions
to exist all at the same time pardon my
formatting here on this one Oh looks
great over there I do please pardon the
extra bar at the top that's that's where
we're at right now I thank you for your
forbearance 'as looks a little different
on the screen right now related transfer
technologies the web's used web hooks
for a long time if you want to push to
something you just send whoever needs to
do the pushing a URL and then you just
post the content and that's kind of an
implicit construct there's no real
reception out of that system there's no
no way to withdraw from that it's like a
single ingestion acceptance way of
getting data in and it there's not
really like a well-defined content type
for that web hooks been very valuable
but it has some severe limitations also
notably you cannot web you cannot push
using web hooks to a browser there's no
URL for you to hit to send data to a
browser there have been some very
interesting experiments opera had a
program opera unite which really was
about trying to give a web identity to
the browser and that kind of flipped the
table and would have made something like
web puffs web hooks more viable for the
client this talk outline this is the
opening thank you very much for being on
the opening thank you very much for
being at web push away we're going to
talk a little bit about the model of
what web push protocol protocol is
we're going to talk about the technique
HTTP to push that powers this all we're
going to look at an application which is
the push API the front end application
that consumes this and binds to it we're
going to look at my little
implementation just a couple glossy
highlights of things that happen when I
was making a node server and then we're
just going to end up with a little bit
of talk on a synchronous bidirectional
web and how great web push is going to
be so please enjoy it learn a lot please
take away and enjoy the resourceful
model come and enjoy the asynchronous
HTTP two world that we're entering into
yes application please this is going to
be like a little bit of the reason for
like why this all came about and should
help really solidify the idea of what
this Q can kind of do and then the
implementation is my own and this should
be pretty epic the model web push is a
queue so what is a queue stuff goes in
stuff comes out we kind of have an
existing model for you if i can get my
mouse scroll working or inverse scroll
so this is kind of what i think of as a
cue stuff goes in stuff comes out of q
and in this particular case it happens
eventually in the portal and that's kind
of an instantaneous effect but a queue
often has to hold data for some amount
of time as well great so what about a
web push q it's just resources it's
things with URLs that are running
somewhere this q exists on some server
or set of servers and it has endpoints a
subscription resource is the first kind
of is the overarching concept that
encapsulates the sub resources that make
up a queue you're going to ask for a
subscription resource you're going to
get back a bunch of different sub
resources for that subscription that are
the capabilities that you can work do
with that subscription and then the push
resource is what you use is that sub
resource that you use to actually send
in to send into the queue it seems
pretty simple a pretty basic concept
with only a little bit of not magic
involved in the middle not magic again
push
uh oh sorry um please forgive me I
didn't catch myself going through that
the subscription resource is actually
the service that you use to withdraw out
of it and the push resource is actually
the resource that you use to send into
it so that's the pushing and getting the
overarching resource that I was speaking
of is the push service or no not even
note we're not there yet the push
message subscription is the actual q
constant construct and you get your push
message subscription from a push service
which is a service that gives you push
message subscriptions AKA cues but now
on to the we were there forgive me i
guess we're going to note we're still
going into models again step one we need
to create the cue we're just going to
push to the queue pushing this is per
the api contract all you do is push to
the via push service and the push
service returns you the three different
three different resources that you get
three different resources to use it you
get a push resource you get a receipt
resource and you get the actual push
message subscription resource and those
three different resources are ways of
putting stuff in hearing that the data
got sent and then getting the data out
this contract should be it but the
different links are different tools that
are used for pushing for the person
pushing data in and then the final
resource that you get out is what you
need to listen to to get messages out of
the queue with these are these all
created we have a queue and it's kind of
up to us to decide what we want to do
with that queue there's not really any
specified order at this point in the
protocol ordering even though you're
going to see sequence diagrams that show
ordering you can kind of start doing
whatever you want with the queue we're
just going to pick push and then these
are these quotes come from the web push
protocol spec so this is requesting
message delivery and this is just kind
of the words that they give the words
are fairly technical and they correspond
closely to the glossary but in short
it's pretty simple we just push to the
resource that we just got back from when
we made the subscription message service
and we push the content that we want in
in reply we get back a success created
response and it has a location for that
response and so later on we're going to
be asking has this message gone through
have what messages have gone through and
we want to know the messages the stream
of messages that are gone through this
location is really going to be that key
it's going to tell us okay this is that
we're going to see this URL come back at
us us the pusher a in the receipt stream
saying this has gotten to the client the
the intermediating server where we've
just posted to is going to we're going
to be listening to it and it's going to
tell us this URL is found and
reciprocally also the clients is also
going to be seeing this whoever is
consuming is also going to be seeing
this URL and is going to be using that
that same URL to talk about that message
that message is server generated so like
that's something that we've gotten back
as a location from doing this post all
we've had to post ourselves into this
single post resource with the content
and then we've gotten back the location
of that content after we posted it this
is just more about this is more out of
the spec these are two optional fields
that can be used when we're pushing data
in we've been talking a little bit about
the resource about asking for
acknowledgement and so the bush receipt
header field says when I do get the
receipt back when I do get noticed that
this resource is successfully made it to
a destination the first header the push
receipt just says this is who I want you
to notify this is like a different Q
it's it really is practically a cue that
you're sending the push receipt q this /
or the bottom header that's who that's
going to be the Q that is going to
provide that receipt that
acknowledgement and then secondarily we
have a time to live
better if you're pushing stock quotes
you don't want to be pushing stock
quotes minute after minute after minute
after minute at while your client is
disconnected for four days in Florida
that you're going to have a huge buildup
of data and so TTL is an optional field
which gives you the parameter to say
this Q should only last for this long to
be able to really subscribe to the
there's a little bit of indirection we
just saw in the previous that the push
receipt has this / our endpoint and
that's a very specific or that's a broad
scale Q here we see it we're going to
post to / receipts and that's something
that we got back when we made the push
message subscription that's a like
top-level construct that's specific to
this subscription there's a little bit
of indirection here where we're getting
back a we have to push to that and then
we get back this /r and that allows a
bunch of different push message
subscriptions to share this same /r and
that way when we want to listen to the
receipts we can have a whole bunch of
different listens that are all listening
to the same receipt and it kind of it
it's another level of the resourceful
system it's kind of complex it really is
for that late binding concept it it
really just is a scalability factor
that's been added so this is kind of the
recap this is what we did to be able to
create the queue in the first place and
we can see the put the how we put stuff
in how we get stuff out and we can see
the resource that we're going to use to
get receipts another recap this is how
we actually create this is how we get
back how we like figure out what channel
we're going to use to be listening for
resources what our particular bind is
going to be and then this is how we
actually push which is again just a post
and that wasn't really that was how we
got data in getting data in didn't
really we didn't have to talk about HTTP
to at all receiving on the other hand is
the pole sequence that we have to do
to be able to really talk about this we
have to talk a little bit about HTTP too
we have to talk a little bit about push
and it's totally cool if you're not
familiar with any of this stuff it's
going to be a pretty high level but
understanding the concepts and starting
to get conversent and familiar with HTTP
two is something that I think we should
get a good job of here to pull to a
queue data we get from it and on the
location we have that subscriber excuse
me it's from that location that we got
from the subscribe response and when we
fire this when we fire this off the
server never replies to that response we
make this get and nothing happens the
server leaves that reply unanswered and
instead in a normal HTTP scenario that
would consume a TCP connection that
would consume there would be like this
connection open that is keeping that
that is preventing any other use of that
connection but because this is HTTP too
it's a non-blocking environment and
we're going to talk a little bit about
that so we're going into HTTP to HTTPS
about frames it is a messaging protocol
for http and HTTP is a respect request
response message protocol so what is the
message protocol what our frames it HTTP
two is kind of encapsulating the
individual things that the protocol of
HTTP would say but it's giving them
containment boundaries it's giving them
isolated little chunks that somebody
else on the other side of that wire is
going to know how to process and know
what the means are and this is kind of
another more reference this is really
good like reading and material into the
HTTP to spec this will really like help
immerse but like these these components
are the frames that we're sending are
things that make up normal HTTP traffic
so the headers frame is something that
you probably already kind of
conceptually have an idea of headers
frame is just the headers part of the
HTTP transmission and as a client
talking to
server I can just start sending header
frames for numerous numerous requests to
the server the server is going to be
able to understand that these different
header frames that it's getting our part
of different conversations each of these
header frames is the prequel to a stream
and then that stream of data the things
that happen after the header after the
you know get / subscribe like after and
then the headers that follow that that
is something that conceptually like the
server understands as a request and it's
going to use the same frames to be able
to reply back to the client when it has
data to send back it's a pretty big
hefty specification HTTP two has a lot
of things about how to deal with and
manage streams you have to figure out
how to be able to set streams and tell
streams to cancel how to be able to do
priority to decide what to send there's
a lot of things going on but it really
is messaging in eight it's about being
able to launch multiple streams of
conversation and that's what this pushes
really has the amazing power to take
advantage of its a great problem to have
when you can have these different
conversations on going at the same time
when they're you sharing the same
channel and push promise is one of those
new frame types that says I'm going to
send you a stream it's a frame it's kind
of a parallel to the header frame the
header frame is what the client says to
get data I guess the parallel is a
little bit weak the push promise is I'm
going to send or a resource to you and
inside of this is going to be normal
content like this is it really is just
like the server is sending a reply
although the client has never made a
request oh sorry oh I'm so sorry I may
have been off on my frame count here
back to our example we've just issued
this get request to the server it's not
going to send anything back we've talked
about how it's just going to leave this
request open and that's going to make
sure that the TCP connection stays open
nothing the the server and the client
are still engaged with each other by
leaving this request open however the
server is going to now have the
information it needs to know that it can
start issuing these push promises back
to the client but it's free to start
sending data and from there this is just
kind of more of the specification this
is we've changed form this is kind of
the same HTTP diagrams this is the
factor the layout factor of record the
common way that people show HTTP two
frames whereas like we've been using the
HTTP 1.1 nomenclature to kind of show
the data and familiarize how request and
response work this is the same like
request and response thing and we can
kind of see the structure here the push
promise has the method path and
authority Authority is really it's like
host more or less and so that's really
just saying that it is initiating a push
for this particular resource and we can
see it's a / D which is going to be one
of those message resources so the server
is sending a message and then it has
some headers that it's going to send
along with that message and then it has
the data of actual message so the client
the the server has pushed data and then
the client has come back around and is
now going to receive this push promise
frame from the server and see this data
content in and content out and that's
really the win due to its totally worth
this is this is exactly how web push
works this is cues there is also
receipts we want to be able to know that
messages got there received add this
additional slightly of complexity but we
kind of do the same thing we've just
pushed the push promise
the next step is a there's kind of a
two-step process once the client gets a
push promise once it starts seeing this
content it has this address it needs to
be able to issue a delete on that
resource once it gets it and that delete
is just telling the server okay I've
gotten this thing you can like delete
this message resource and that's the
information that the server needs to
know to be able to say okay like
somebody's seen this I can acknowledge
this it's going to assume that nobody
has seen this message until the client
turns around and issues this delete on
the message resource and then once it's
done that once it's done that then the
server the pusher is also listening on
the receipt on the / our endpoint and
the now the pusher the person who's push
this data out is also going to be
awaiting more push promises it's going
to be awaiting its own stream where it
starts seeing push promises itself again
for this delete resource and that its
cue that okay this message is made it
across the wire this message is
successfully sent and this is kind of
cool there's a symmetry here because we
have two different people using push
promises we have the people who are
sending using push promises to hear the
acknowledgments of the things they've
sent we also have the people listening
for the messages in the first place
using asynchronous HTTP to push
technology to get these messages and so
that's really like that those are the
components of the web push protocol
we're going to look a little bit about
very briefly at the push API which is
it's the client API it's what you as a
web developer are going to be using to
be able to create a new cue to be able
to have a server if you have an
application server it's what you're
going to be using on your application
server to push data to the client it's
what you're going to be using in the
client to get the data out of this it
doesn't specify anything about
implementation technology there's no
it's a it's only a front-end to
interface a well specified front-end to
interface for how to access this push
technology and so web push is really
this backing component that gets used to
make this happen
this is a pretty this is a great
sequence diagram and it it models we're
going to see a lot of these components
if we look at the double view this is
the web push protocol on the left and
this is the push API on the right and
there's a lot of symmetry here in both
cases well we'll take it from the web
push protocol side we're creating that
we're issuing a subscribe to create this
queue resource and then there's this
monitoring monitoring open cute that's
happening that's allowing the push
service and the UA the user agent to be
able to exchange for the user agent to
be able to get this data out the user
agent has to take responsibility for
sending that push resource the user
agent has just gotten this queue all
this information all these endpoints
about this queue it has to send some of
those data across the wire to your
application server so that your
application server can then know who to
do the push message to so it has once
you send the URL across then the
application server is free to open the
push endpoint and begin to push data and
it's up to the push service and the user
agent who's listening to be able to hear
and listen and get that data from the
push service so the push service is
acting as an intermediary for all of the
data going through it and that's the
decoupling that allows the client to be
disconnected for long extensive time
while the application server has already
pushed the data to the push service so
the push service can hold on to the data
and then much later down the road way
more asynchronous this push message can
go through so we see the exact same
pattern here this is the push API we
create the queue we have to subscribe to
the queue in this case to create the
subscription we have to distribute the
resource back to the application server
and then the push message goes from
application server to the push resource
and now we add a little bit more depth
as we start really modeling how this Q
gets consumed the user agent takes this
message the user agent has to send it to
a service worker and then the service
worker is has runs
i encode which is what you have to do
like it which is where you finally get
the data so it's a very similar
structure there's a little bit more
depth to it just because there's more
more agents in play but they are like
identical flows these two were made hand
in glove to fit one another and that's
that's what it is as for using the push
API this is how the push API works in
the browser this is pretty simple right
like you're you're inside a
serviceworker somewhere oh yeah there's
a little bit of connection establishment
once your service workers created but
after you say that you need a
subscription from that point on all your
service workers global scope context has
an on push event that you can bind to
and you get data out and that event is
just you're just going to find the data
inside of event data and this is copied
verbatim I'm sorry I the hyperlink is
missing on this one but this is copied
directly out of the push api
specification we're going to talk just
briefly about my implementation web push
pump this is a node app that I wrote I
wanted to be able to in the first case
bridge from IRC to HTTP to push I just
wanted a way to keep sending IRC into my
browser on a real-time basis so this is
a standalone server that I wrote and it
has separate bridge client applications
that actually push the IRC data into it
but there were some really really really
fun things I really liked how web push
is so resource oriented that it really
explicitly calls out the resources for
pushing and for getting out and I really
felt very influenced by the URLs that
were specified in the web push protocol
and to that effect I kind of created a
top-level construct for the application
that just builds collections of these
base resources and this is something
that just really simplified my
application development to conceptually
have a domain model that's so explicitly
and tightly matched exactly what my
protocols model was and so when a user
doesn't subscribe at the very first
thing I'm going to add a new subscribe
object
into into the very first object and
subscribe is going to have a push
elements associated with it and I want
to push that that /p element into the /
PQ the the push receipt elements are
going to go in the push recede element
etc etc and then from there it made
things like for this subscriber quest it
made this very easy for me to to kind of
build the structure I created there's a
request i'm using khoa for this i made a
request context just off of in khoa this
object this is a node this is a method
handler like this is what you're going
to tell khoa like run this code when
somebody sees to subscribe and this is
going to be like heavily used by a lot
of different constructs anyway I the the
request context is going to be the
specific like where I start aggregating
and building the information pertaining
to this request and on that I've already
pulled in this context as the context
here and then I can just kind of well I
for creating the subscribe I just create
a new subscribe object I passed in the
request ctx it's mostly empty it has a
little bit of metadata the time of the
this will have like a time stamp on it
at this point but other than that like
this is like basically empty it creates
the subscribe object and I add it to the
request context and then there's other
things that I have to create like when
you're issuing this post to subscribe
you also have to create the push
resource and you have to create the
receipt or source and so I create those
and those get passed in this request
context which now has the subscribe
context and so it's it I can just
continually pass the same piece of
context into these constructors and end
up with these new resources that I'm
getting out and this was just a pattern
that took me a lot of like iteration to
kind of winnow down and get rid of as
much code as I could until I kind of
ended with this base core and it really
made things like really simple and it
was a really cool pattern for me the
next kind of capability that I added
was a created of projection view system
using mutation observers which r.i.p
rest in peace are no more but they're
pretty easy to you re implement with
proxies and this is really this was a
really cool concept so I you're going to
have all these /s resources that i have
to like deal with and manage and look up
and rather than kind of like maintain
the indexes for this myself manually i
created this projection tool which
allows me to just uh if this is that the
it's vista ass the contexts s but so for
this list of /s azure for this object of
/s is this will create a mapping from
the S will have the dot s will
understand and have a link to the parent
subscribe the the main queue and so it's
going to pull out the mapping is going
to be so I'm creating a mapping from to
something so it's creating the mapping
from the s dot subscribe from the
mapping from that like subscribe
property of this s collection out to the
primary key for this s object s symbol
is like a primary key that so that this
becomes a functional mapping where I can
if I need to figure out what s is do I
have the tie to a subscribe I can just
ask for that subscribe ID and it will
get back all of these esas and this this
is like an index that because of
mutation observers keeps itself up to
date I found that this really like cut
down on the amount of code that I had to
maintain and keep going all the link
relationships that I needed to keep
having I also just kind of as a
premature optimization opted to use
symbols as all of my primary keys in
JavaScript symbols are a new es dot star
feature that rather than kind of look up
objects with string based identifiers
there's a new symbol identifier which
supposedly perhaps maybe frees you from
some of the kind of task of like having
to look up and hash or string to figure
out where in the object you have to go
look
it up it's kind of like a somewhat of a
performant it's a potential performance
optimization that just allows things to
go simpler it also just kind of kept me
honest it made sure that I wasn't using
passing around string data and that I
did that since i can't really like look
at symbols it just made sure that the
links all had to it it's hard for me to
I guess to equivocate that one but it
gave me some additional checks that I
had to look at when I was developing it
um that's most of the like really cool
things with a web push pump protocol the
rest of it is a pretty regular khoa
application but I thought those were
some pretty awesome gems that kind of
shook out from developing this overall I
see web Porsche is really an advancement
towards an asynchronous and
bi-directional web it has some small
bits to it we noted that the pushes were
hope ache when we pushed in the server
kind of replied to us with the URL for
what we had just pushed in and told us
what that receive that resource the
identity after it was pushed in and so
that that kind of explicitly means that
we can't be pushing resources we have to
like if we wanted to push a resource
we'd have to come up with like some JSON
or a message pack encoding for what an
HTTP resource might look like and push
that like encoded resource out if we
wanted to like be web full if we wanted
to be resourceful with the things that
we are sending we can't explicitly say
what it is that we're sending and so
that's that's a constraint that's
something that was kind of designed into
the web push protocol that's how it's
supposed to work but it's it still kind
of keeps us a little bit away from
really a web where we have like a fully
asynchronous web or where we can really
begin to talk about sending data in
really different ways and second this is
really the only way this is not a
critique on web push per se but it was a
really extensive chart of activity that
like this diagram is what it took for us
to be able to start pushing data to the
browser there's like a lot of different
agencies at play there's a lot of
different work at play and this is all
just so that wet HTTP to push could get
used so that we could start pushing
resources and that the client could get
notified when these resource
were pushed to it we've talked a little
bit about how it's asynchronous and
decoupled and how like the client might
not be connected but when the client is
connected and sitting there it's still
like a very important use case that the
client wants to be able to get real-time
data to it and that's something that we
spent a lot of effort and work doing
we've built server server sent events we
built web sockets and this is web HTTP
to push kind of proposes something a
little bit different for what HTTP do
you can do and this is a really very
complex set of technologies web push is
a complex set of technologies that have
to kind of work very carefully together
to make that possible but it doesn't
tell us it's still there is kind of a
little bit of a workaround like if you
do really want to be able to just push
the client you can push to the client
and then have the client via some out of
bands method just ask the server
directly very straightforwardly have you
pushed any resources to me we can use
server sent events for example so you
can use HTTP to push and then
out-of-band say by the way I've pushed
you all of this data so that's kind of a
workaround that an alternative path that
you might Forge if you wanted to do push
in a way outside of web push without
these very specific browser imposed
constraints in this very specific
formulation if you just want to have an
open push connection and see data out of
it you there's no ways that the there's
no way as the client to explicitly be
told that you're getting these pushes
happening to you if you're not using web
push but you can open a connection and
start creating your own protocols to say
by the way I've pushed you some data you
should look I'm really excited for web
push I really think this is like a new
era in web development that htb to
really begins to open up a new set of
capabilities I think push is
fantastically interesting and like web
push is a great demonstration I think
we're also going to see HTTP to push
used within the data center to start
replacing some of the existing means
that we have like Kafka and RabbitMQ
those are more like larger technologies
HTTP two is really just a protocol but I
I think it serves a great basis to kind
of do a lot of things that we've been
doing while doing it in a more web way
without having to have outside paths
doing that I'm super excited to talk to
you about web push away I think the
future is very exciting and I look
forward to seeing all the great things
that everyone goes out there and does
thank you all so very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>