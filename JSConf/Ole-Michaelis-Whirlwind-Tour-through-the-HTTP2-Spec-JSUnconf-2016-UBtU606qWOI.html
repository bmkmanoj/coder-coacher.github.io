<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ole Michaelis: Whirlwind Tour through the HTTP2 Spec - JSUnconf 2016 | Coder Coacher - Coaching Coders</title><meta content="Ole Michaelis: Whirlwind Tour through the HTTP2 Spec - JSUnconf 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ole Michaelis: Whirlwind Tour through the HTTP2 Spec - JSUnconf 2016</b></h2><h5 class="post__date">2016-05-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UBtU606qWOI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you okay I can fulfill this so
this talk was designed to be like 45
minutes it's mentioned woven talk so i
guess i can go pre fast and i will go
pretty fast if it's too fast just raise
yen and we get the sordid I just tried
to speak slow just skip more slides
first question who of you is using HP to
in production hands up it's like five
hands almost it's great appreciate that
for the other side before we start I
really want to get the most important
question sorted so first question is if
you really done what do you think yeah
yes raise your hands is it done well
it's three hands really like yeah it's
done sense of what you hear and I even
mentioned this in my pitch by anyway so
it's ssl mandatory yes raise your hands
oh that's good fifty percent it's not
but actually all implementations you
will see in the wild they are only ssl
so in IRL it's all encrypted but the
specs say you can also use a plain text
is it made by google no one great no
it's not what speedy well it's just a
different protocol is it plain text no
it's not binary I had asked impressed
yeah they are my favorite question so
will you won't still work you think sure
it will write and we will break the web
even HP one it's still supported by the
browser's all right in order to
understand why HP to is kind of like
great and amazing and so mind-blowing we
have to understand what are the problems
with the protocol we have in order to do
that we need to take a look at the
histories so in 1989 and 90-89 sorry Tim
berners-lee invented or came up with
this idea of the World Wide Web so where
every researcher the CERN can share the
results to other universities and wishes
research centers and stuff and only two
years later
the first version the first version of
HMG HTTP so version 09 was released
going on in history just a few years
later version the first version draft
came up and four years later they
released the first version what's
actually pretty funny is that just one
year after the release of the first
version they figured that it was not
that good and they released a patch so
since then we have HP 11 which is what
most of you still use today then in 1998
there was RFC where you have 23 26 who
knows what this RC is about ends up one
awesome so this RFC specifies how
machines interconnected network should
react on request on making coffee and
this is where the HPT status for 118
comes from I'm a teapot so its
neighborhoods full RC check it out it's
pretty it's pretty funny to read it's a
good read so going on in history we have
another version of a TV 11 because they
figured the first version was also but
has a few flaws but it's basically not
that much semantics change so it was
more like a like writing changes in this
draft and then there was a lot of stuff
happening lots of like improvement in
different RFC's I haven't listed here
and then in 2007 the ift forms the HTV
boost working group and as far as Google
told me business latin for to and this
group's task was to to get some some
like structure in the 11 draft and in
early 2012 there was a call for
proposals fetch v2 and Google jumped in
here and proposed speedy as less as a
base as a base draft to use and to work
on this is how speedy and age which will
relate to each other so speedy is the
base where the iterated over and created
HP to so when we go on in 2014 so two
years ago now that was hp11 split this
was the result of the a tubeless working
group and they split it all the
different RFC's which have been out
there in
just six different ones each dealing was
a different sub part of the protocol so
all information on HP 11 you can find in
this RFC's then in may 2015 issue 2 was
finally released and at the end of the
last year twenty two percent of all web
traffic was already hb2 due to the fact
that s i mentioned only ssl traffic is
supported 4g with you it makes sense to
look at this number as well and on
Firefox 35 percent of all HTTPS traffic
was already a tree to I think this is
pretty amazing so far so in order to
them start at the Edit like at the same
plate at the same point I really want to
talk really quick about the HTTP basics
so first one HP one is plain text so I
can just spin up my terminal and then
opening up a TCP connection to google
that common port 80 and then just write
the characters for the status line at
the host header and Google will reply
with an actual response so you can just
do this stuff with HP 1hp was a issue
one is stateless and to us as well and
it's super flexible and it's used
everything right it was invented for a
completely different thing it was
invented to share documents tim burton's
the idea was even that browsers could be
like editors this idea is completely
gone now almost but a tree has changed a
lot since then right we use it for all
different kinds of stuff we use it for
streaming we use it for database
connections we use it for lots of
different things but it was not designed
with this gnosis task in mind so hv1 has
a bunch of problems the web matric and
if we take a look in the last four years
the size of requests and the number of
requests almost doubled and if we take a
look at average website every connection
has 38 every page load has 38 different
connections TCP connections just to load
one page and when we know talking about
the mobile web the latency is pretty
high
and this leads to a problem often
referred as request melantha and what I
mean with that is a issue you see every
day so what you see here is you have the
browser and server and the browser is
requesting some sign of asset so in this
case it's requesting the next HTML the
server response and the browser pauses
it and find some more assets so then the
browser's asking again for some more
assets in this case for CSS file and
then the server response the browser
path of it and then it might find an
image or in our case which is like a
little bit unrealistic it finds
JavaScript acid and then it's going to
request this one as well so this is a
lot of round trips right we have to do
and this adds a lot of latency right
especially if we are now talking about
the mobile web throughput is pretty good
when we talk about LTE or 4G the
throughput is pretty good but the
latency is still not that good and it's
like chili and I want to illustrate that
so I got a little bit a little video
here so i wanted to load the verge this
video is a bit older it might not be
that accurate anymore it's like half a
year but if you want to just load the
website and take a look at the network
tab let's do this together so we loaded
you see the initial request and what you
now see is like this huge waterfall
while I'm here on there on the right
side right there's lots of stuff lots of
assets loaded every essay triggers more
assets and it takes a long time this is
real time by the way so it's like 10
minutes to load we're at 10 seconds
echo moderate know it's a 12 seconds and
it's 1.5 megabyte to load the verge
that's like ten percent of my daily
mobile plan l my monthly mobile plan
that's crazy I got it the same video but
a little bit slower so there's not real
time anymore and we can take a look on
what's going on there so we see the
initial request the document here then
we see in parallel triggered some more
requests going on then here's a lot of
like pause so I assume there's a lot of
pausing going on from the essence
livered here and all this stuff you can
read but it's all tracking and bad stuff
so I don't have a blocker for this
example right so it's the page was
loaded from you expected but it was not
a complete page load and even my browser
loading any kata was still spinning at
this time so I got a little bit angry on
that so I treated them they didn't reply
at all I don't know if they even fix it
now your first response might um yeah
you can just fix this with loading SS in
parallel and this is true but this
suffers one problem and this is head of
line blocking what is head of line
blocking exactly well let's have a look
at loading essence in parallel you would
just request them in parallel but the
index lost so the initial document might
take the longest time right because it's
like done dynamically rendered and the
other ones just static assets but due to
the fact that we requested this in this
order the server we are forcing the
server to reply in the same to reply in
the same order if we are sharing one tcp
connection because HTTP has no way of
identifying resources in the response so
the only way to identify that this acid
is this requested acid is to keep the
order so you had the head blocks right
this is head of line blocking and it's a
little bit recap on this so the head of
line blocking is the other matters the
slowest request blocks there are almost
no workarounds for this because it's an
issue of the protocol right and due to
that fact that's often unused so a lot
of browsers just turn this off as
developers
David Wright to changes and I think this
was like the best option we had at this
point but that could have been like if
we would just invest more efforts we
could have jumped into the protocol
specs and try to work on this on this
side but we did the other way we
improved our tooling so we came up with
ideas like spriting concatenating domain
sharding my slides are slow domain
charting the weirdest inlining hacks or
preloading hacks I've seen so many
applications they have the application
JavaScript on the landing page just
though the application could look pretty
fast this violates almost all rules on
software design I know right this is a
really bad idea we did cookie free
domains this is great keep this oh this
is even a great idea on HP to on we so
really try to save all the requests so
we optimized again for the throughput
but not for the round trip time but I'm
not here to talk about the problems we
have I'm rather here to talk about hd2
and the solutions we have to this
problem mention first of all HP two is
compatible so it's not going to break
the web the scheme will stay so you'll
never see an hd2 in your browser bar it
will stay hph vs the semantic stay like
headers message request response cycle
all this day have a look at the upgrade
right how does operate works first the
non-secure way this is just a
theoretical one using the upgrade header
due to time constraints and try to go
with this pretty fast so we'll just send
the upgrade header HTC see as plain text
or clear text then we sent the settings
along of the server will reply with an H
to view 11 101 switching protocols and
then upgrade to the protocol and then it
will just start running a binary so
let's take a look and how it how it
would work on a secured connection so
this is how it would work on all your
laptops I see around here it's actually
using an extension for TLS so it's TLS a
OPN lpns application layer protocol
negotiation which is just newer version
of NPN which is the next protocol
negotiation which was the protocol
invented by Google for speedy anyway
it's an extension CLS and it's using
this part of the TLS protocol
where they exchange protocols both sides
support and they can just negotiate
which one to use and the protocol
shorthand h2 is the short version for hv
two on a secured connection the funny
side funny side note is that HTC is
actually registered in the name space of
for a LPN but due to the fact that is
clear text it's not even used in the APN
so this led to a few problems ok so a 22
is multiplexed what does this means so
we have one more or less physical TCP
connection which has logical streams on
it and on this their RTC like the data
frames and each frame belongs to a
stream so this model makes the most
sense even though on a more technical
term it's frames directly on one
connection so these frames are binary
and they follow a certain layout so they
can be passed by service more easily so
they have a length they have type flags
they have a type that have flags they
have a 1-bit which always have to be set
to 0 then the stream identifier of 31
beds and then their sexual payload I was
wondering what this little bit means
because the specs is this one has to be
there and it always has to be 0 ignoring
like what it's actually for it's
actually four platforms which do not
support unsigned I'm 31 bit integers so
they can just use 32-bit integers ok
anyway so let's take a lot of different
types of frames we have the first one in
the one you will see most of the times
the data frame it has a padding length
padding a security feature and then
there's the data and the padding their
priority frames to reprioritize package
on the fly that's reset screen which
resets one stream of one connection
their settings to transfer settings from
the server to the client they're also
bunch more I have a little example here
but as I said we have to be really quick
what you see here is the length of the
body so the lengths always ignores the
initial frame so we have the ping that's
the type of the of the package it has
the flag
set so this flag on the pink frame means
that the server has to send back or the
other side has to send back a punk frame
hopefully without the flag because this
would lead to like ping pong then we
have this troll bit and we have this
scream at you the cool thing is that i
can say with this one that this frame is
from client because client always have
no this from the server because client
always have odd numbers so each each
server and clients maintain their own
stream IDs and then there's some epic
data which is like necessary by the
protocol let's talk about the HP two
features first one I want to talk about
a server push and I think this is going
to be the the biggest change and the
change with the biggest impact but on
the same hand it's also the change we
haven't made use of yet and we really
should because this is going to improve
our applications as I mentioned by pitch
right so what is server push so ever
push is initiated by push frame and
seven push actually comes in place where
a visitor who has never seen your web
app it's going to see your app for the
very first time so it has a complete
empty cache and requesting a sign our
document like in the next HTML and now
imagine your server could tell the
client without further requests the
essence it will need so the server the
client asks for an XHTML and your server
could respond like oh I know this page
you will need the application CSS and
the application JavaScript as well so
the push promise frame is basically I
can add a frame but is it's a head of
frame what's the transportation
mechanism without an request and this is
one of the biggest change from even in
semantics right from HP 12 hp to it also
supports flow control so all assets all
requests all connections or all streams
on one connection are sharing one actual
TCP connection and in order to transfer
some assets faster than others every
stream has dependency and they use
weighted dependency in order to
determine which stream
should be transferred first so let's
look at how they implemented it the use
a technique called priority three so
here we have the stream id0 stream 83
and three depends on 0 then we have the
stream 85 they both know the three has a
weight of 128 and five hundredweight of
64 and then there's some wall streams in
here and this is a the complete picture
for the like for the priority three and
now take a look that 16 down here is the
default weight of every stream so if you
don't specify it it's always 16 and the
priority of the stream is determined by
the relative proportion of weights so
stream 83 should receive two thirds of
the available resources and stream it is
seven should receive half of the
resources of three minute three if this
makes sense this is very theoretical but
what really blew my mind when I was like
researching into it taking a look and
how it's actually implementing it and
firefox at the moment has the most
efficient implementation so let's take a
look on how they do it so first off this
initial stream is simply 0 and the first
thing they do without transferring
anything on the data they set up the
dependency tree then they transfer the
HTML in this remedy 13 then they order
the CSS on this page that's the CSS from
the head out in the Hat and then there's
the javis group in the Hat then we have
some images they go on a different sub
tree with a different priority and
different waited and then there might
also be some JavaScript at the bottom of
the page which um goes below here i can
tell you why they made the decisions
even if it love if i could do but I
didn't have the I didn't had the chance
to talk to any of them or didn't like
make myself enough time to do that but I
know that they do it this way and that's
the most efficient one it's the most
efficient one we
Google still uses the dependency tree
that invented for speedy which was a bit
different and they didn't change it yet
and what I found pretty interesting is
that the in the next door don't make use
of this at all so they support it but
it's like flat thing so it's not a tree
everything depends on stream of the 0 so
hd2 is also compressed headers which
will reduce the size of every request
this is how a header looks like so it
has the padding again that has this
interesting 0 bit the stream IDE I'm a
weight and the header block fragment the
header block fragment is specified in a
different RFC its specified in RFC 75 41
and I really want to go pretty quick
into that because I found this one
pretty interesting and how they do it
they use a static they use a header
compression table for this it consists
of static and dynamic table and this is
how the compress or encoded headers
looks like so here you see the master
for example is referenced as ID too so
whenever you have this method header
it's always this ID too and you will
just find this too in the encoded
headers and for value is not known it's
using Huffman encoding and what I also
think is pretty interesting on this is
that here the statelessness is a little
bit it's a little bit violated because
header compression is stateful so the
state belongs to one connection and the
dynamic table builds up her connection
so for example the user agent probably
won't change on one single TCP connector
right so this one is a header which will
end up with the dynamic here pretty fast
and it's up to the compressor of the
header which headers go into their go
into this dynamic table I actually
implemented this list HP algorithm
myself so if you want to like know more
details about this ask me later about
this I think it's pretty interesting and
it's pretty efficient for HTV two
headers let's take a really deep joke
until half an encoding I want to do it
in one minute let's see who she knows it
already happen encoding well that's half
the audience it's
aight i didn't do it might be for myself
when i found an awesome youtube video
expanding in like seven minutes so i try
to break this down into one minute let's
see if this if this works so we have
this drink mississippi river and these
are 17 characters each character's 8-bit
so we have an initial string length of
136 bits first thing we do we just count
the characters or the occurrences of the
character then we order them by
occurrence so I 5s for p 2 and so on and
then we start building up a tree we
always take the lowest numbers and
concatenate the characters and some of
the numbers so we do this for the whole
tree always using the lowest and with
this technique we're building up this
tree right and next step we do is we
enumerate the branches so the left
branch is always 0 where the right
branch is always one and next step is
you walk down every possible branch and
you end up with this table and this is
actually the compression table you can
use it follows the idea that characters
which occur often take less space in the
compressed string so the eye which
occurs five times only takes up two bits
right while the space or the v while the
space only takes four bits yeah this is
the compression table and with a
compression table the result will be 46
bits plus the table so on this string we
have all around seventy percent we
compressed which is I think pretty great
and in hv to the header the header table
of the Halfmoon encoding table is part
of the protocol so it's not not
something which has to be transferred
all the time it's just you just have to
copy it and when you're implementing it
okay now I want to talk about and I'm
tuned in the real world and important
for me is that it's already here and if
I have if I would have more time we'll
do a demo here but I don't so let's take
a look at the implementations and we are
at jas I'm conf so let's take a look at
the browsers and what do we do
need to know if you can use the future
not you going to can i use and this is
the actual usage chart it's two weeks
old um let's for activity two and you
see it's almost all green and the
current versions right I mean this is
opera mini and Android stock and can I
use also has a different view on this
chart but i think is more useful they
also display the usage of the extra
browser versions so we have this and so
this is iOS they were the last ones
adapting but due to the great adoption
rate of iOS devices with the recent iOS
version 9 to it they had they shipped
support and you see this one right and
when i asked at the beginning who many
of you how many of you are using HP to
now there were like five hands and I
want to know why are you optimizing for
this your whole asset pipeline you hold
asset concatenation ugly firing
packaging in line hacking it's for
this don't have this your bosses right
the super inefficient but I will come
back to this later first let's take a
look at the server side in order to know
how important one implementation is the
market share might be interesting so
here's the market share diagram what I
found pretty interesting that the google
web server is already two percent of the
whole web traffic this is not something
you can deploy on your own right it's
not like apache you can install
everywhere and they take up two percent
of their server landscape for the google
web server it's not known when they
implemented it by they said that job
speedy in February last year so probably
they adopted since then Apache the said
since July last year engine extent
September and I is even does this as
well so all major browsers supported at
the moment and in order to enable it on
your setup it's pretty easy let's take a
look at the attached
Apache one first you would need the heo
to module and that's it yeah that's this
is optional this is just the login part
so it's a one-line change find genetics
it's even better it's like a five
character change so you'll have this
line anyway right it's opening up its
binding the port address so you just
have to add this keyword here and have a
recent version and then you're
supporting it so don't tell me it's too
complex to support it right it's not I
think you're holding it wrong right you
should stop concatenating you should
stop spriting you should especially stop
the main sharding and i really want you
to trash your asset pipeline the one too
far sorry um yeah you should really
trash your asset pipeline remember the
graph I showed you the browser
supporting it and you are still like
concatenating all your assets into one
big chunk destroying all server caching
mechanics right if you have 11 line
change in your JavaScript and you have
your one point five megabits application
j has changed the browser's have to
redownload it again even if it's in cash
it's just 11 line changed and hd2 is you
don't get a penalty for more resources
so the more resources you have the
better you cashing works right and you
don't get you don't get even one
millisecond of penalty for having more
assets so just like split your
javascript against with your CSS again
and just make the whole development
process easier again right so I want you
to start using it the best right now not
only upgrading because and you might
have seen the blog post articles as well
right if you just upgrade your
performance may decrease and this is not
the fault of the protocol and the
company's operating often say that if
this makes me so angry because they are
holding it wrong as well if you still
concatenate all your assets sure it will
get slower or it
should change like it shouldn't change
but it it's it's not you're like really
holding it wrong you're just doing it
wrong and I want you to just start using
it understand the protocol and optimized
for this and this what's true on this is
that customers using one one will see a
performance decrease so they will get
slow off of them but the others will get
an increase which is way higher than the
people using 11 and for JavaScript
features you're doing it all the time
right you want users to upgrade the
browser so you can use I don't know es6
modules which is this part in one
browser and this one is a way more
bigger impacting change and I see way
too little talk about this and you
should really make use of the features
and not just upgrading I want to change
my company I want to know I don't want
to change it sorry i want it i want to
thank it i want to thank my company
because they gave me all the time to
research on this yeah this one is gone
now all this ok if you want to appear
here like next year you can just stay in
this room awesome colleagues of mine
will follow here my name is Alicia Ellis
we had talked about this you can follow
me on twitter if you're into this thing
you can just follow me on github if it's
a prayer anything you do I don't do that
you can just read my blog which is like
currently super outdated or grab a
sticker of the side projects I run and
this is all I got thank you very much
for your attention
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>