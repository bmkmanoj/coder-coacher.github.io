<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Txus: The Power Of Small Abstractions | JSConf 2015 EU | Coder Coacher - Coaching Coders</title><meta content="Txus: The Power Of Small Abstractions | JSConf 2015 EU - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Txus: The Power Of Small Abstractions | JSConf 2015 EU</b></h2><h5 class="post__date">2015-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4dwZ-WIJCSo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">All right, so, hi everyone, I'm really glad
to be here at JSConfEU, I'm really sort of
an alien here, it's not my usual crowd, I
don't code JavaScript for a living, so I might
bring in a bit of a different perspective
of things, especially less about code and
more about the understand lying concept. So
... also if you've been at Stephanie's talk,
you'll see some of the same concepts explained
a bit of a different way. So hopefully it'll
be interesting. This is me with some hair,
that I don't have anymore and this is how
you pronounce my name, Txus, if you read phonetics
(Laughing) so I work at ::Codegram an agency
in Barcelona and we put on quite a cool conference
as well in Barcelona called full stack FEST,
check it out next year, if you want, it's
pretty nice. So we're here to talk about abstraction
and abstraction, we have sort of a love/hate
relationship with it. We love it because it's
what our programs are made of, we hate it
because when there's too much of it, when
we think there's too much of it we're just
frustrated, we fail to see sort of the essence
of the problem. But, I would argue that actually
it just about the level of abstraction we're
comfortable with, and like everything it can
be trained and you can learn about being comfortable
with higher levels of abstraction, so, we'll
see a bit more about abstraction with an example.
What do you see in these two pictures? In
a way they depict different things, but in
other ways they are the same thing, right?
A computer would have a hard time maybe finding
out that they are the same thing. But, we
already know look at these pictures and says,
yes, of course, I know what it is, it's a
dog. You've never met these two particular
dogs here, these two, but, you already know
a lot about them, you know what they eat,
more or less or they like to go for walks
and they don't like cats, maybe they do, but
in general, probably they don't. So, it's
pretty useful, you see two dogs and you've
never seen before and you already know a lot
about them, just because you identify them
as a dog,this concept you have in your mind
with a lot of semantic knowledge attached
to it. You're forgetting their differences
just to sort of understand the essence of
them. Now, I'd like to share a story that
I didn't write, but I really like this Argentinian
writer Forge Luis Borges, you should read
it. He has a story called Funes the Memorius,
are in this story, basically there's Funes
a young man who once fell off a horse and
just hit his head with the rock or something
and then from that moment his memory became
perfect. He could no longer forget anything.
So every instant of everything he would just
remember forever. That means every smell,
everything he saw or heard or anything. And
that brought him to experience the world in
a very different way. So for example he started
undertaking in this by star experiments. For
example he started devising his own numerical
system, Borges a character in this story asked
Funes, so, what is this thing you're working
on? This numerical system. Funes said, well,
I'm assigning a name to every number, so the
number 4 is dog and number 7 is staircase
and so on and he just wrote them down in his
notebook. And Borgls was confused, why would
you do that isn't that the opposite of a numerical
system? You cannot reason about this if do
you have thousands and thousands and millions
of numbers with different names you cannot
do arithmetic or anything useful with them.
But Funes was not interest in the that he
brought up a point that John lock philosopher
he envisioned an imposable idiom a language ‑‑
every instance of every branch has it's own
name ‑‑ everything has it's own name
there, was no such thing as Aleve, it was
this leaf and that leaf and that. They all
had different names, of course Locke dismissed
that as sort of useless, he thought you cannot
reason about anything or talk about and communicate
to another human being if everything has it's
own name, so you cannot talk about things,
but Funes Reacted to that than Borges expected.
He said that system is to general. Every instance
of these objects should deserve it's own name,
it's essentially different, it changes over
time, so to him a dog seen from the side,
at 3:00 p.m. had a different name from the
same dog seen from a different angle one minute
later. They were just different things, arguably
they are, it's not a solved problem in philosophy,
identity. So we tend to think that we know
identity, we look at a thing and two seconds
later we treat it as the same thing. We look
at a person, we meat them, ten years later
we know it's the same person, but is it? I
don't know. It's not a solved problem. But
it's sort of a useful abstraction that we
have. And Funes couldn't abstract over that.
as smart as Funes seemed to be with his incredible
memory, Borges made the point he thought Fun
res wasn't really capable of thinking, thinking
is to forget differences, to generalize, to
abstract Borges argues. So we'll see that
abstraction is something way deeper than just
forgetting differences and losing detail,
it gives us something in return. So, yeah,
arguably dogs actually losing detail with
dogs is sort of a shame because different
dogs might behave differently, might have
different properties that he're interested
in, 234 the world of programming we have much
simpler domains, some of those have really
interesting properties that and abstractions
that it's really interesting to discover them.
We'll start with one of the simplest things
we can think of. It's addition, so we'll start
by adding two numbers, we all know how to
add two numbers, and we also know how to add
two strings by Cactonating them. Then to us,
it's actually the same as just Cactonatinb
to lists, it's not a problem, we understand
that, you can do this with lists, strings
and numbers, in numbers it means addition.
Then we could say that these things, you can
add them together and you get a thing of the
same kind. It's a different thing, but it's
a thing of the same kind. We also have an
interesting property in addition, it's associative,
no matter where you put the parenthesis, you
always get the same result. In numbers, it's
true, in strings it's also true. And in lists
it's also true. So we're starting to see a
thing that is common to these three seemingly
completely different things. Associativity,
now it gets interesting. There's this number,
it's called zero and it's really interesting,
it hasn't been around for very long, but it
has an interesting property, if you add it
to another number you get the original number
back, so it doesn't do anything. That might
seem boring, but, we have the same four strings
and the same four lists, so what's interesting
about this number? Well, this Element where
we call the neutral Element or the sort of
zero, if you add it to another thing, you
get the other thing back. By knowing that
something adds associatively and has a neutral
Element, be it a list, a string or a number,
we can, for example, fold or reduce over list
of those things. Starting by the operation,
addition, then the neutral Element, in this
case zero and a list of numbers, we can do
the same with strings, folding over lists
of strings starting from the empty string,
we can do the same with lists. This is sort
of pseudo code, but it would be reduce in
the JavaScript, and a plus operation. So we
see that if these things have these properties
we just described you can fold over list of
them. The important thing that we only assume
these two properties of those things, so we
don't know that they are numbers or lists
or strings, it doesn't matter. Well, that's
too easy, well, like, yeah. (Laughing) so,
I had to put an animated give because I didn't
have any in my presentation and everyone had,
so I put this one, I hope achose well. So,
this is too easy, number strings, lists this
all just sounds very primitive, probably it's
a coincidence that they behave the same way.
But, I don't think so, I'll show you something
a bit different, really radically different
than number strings and lists that behaves
the same way. What happens when we compose
two functions? We can understand that as adding
two functions together, because we get a function
at the end that is somehow the addition of
both. So if we compose two functions with
a plus, let's just imagine that's the composition
operator, you get the same as applying G to
X and then F to the result of that. Now, functions
add associatively as well, or compose associatively,
so yeah, that works out the same way. And
interestingfully we need a new elmented for
functions, that's a bit different. What's
a zero for functions? A function that does
nothing. Well, that would be the identity
function that just returned it's argument.
That really does nothing. So, if you compose
F with the I deputy function you get F back,
it's the same the ‑‑ identity function
you get F back. Same thing holds for functions
as well. So theoretically we could fold over
list of functions starting with the identity
function and it works. The point here is that
it's not only about functions or lists or
strings, it's just about these two properties
that we know of them. So there are many other
things that in your code bases you can see
and you can identify as things that add associatively
and have a neutral Element. You just need
to get a little creative. Just squint your
eyes a little bit and say, I think this behaves
like that even if it's completely different.
These two properties associative addition
neutral Elements sort of a mouthful to say
all the time. So someone gave them an name,
it's a scary name, but not square scary once
you understand what they are. Just like these
two things people call monoknowed, things
that have these two properties, Monoid) we
have arrays lists and sets today, or maybe
just arrays like most of the time. Let's abstract
over that and just talk about collections
of things, the collection of T collection
of integer. Collection is a thank represents
zero or more things, we can map over them
with a function, right. So that is a way to
transform the Elements in a collection. The
interesting thing is that if the collection
is empty, nothing happens. You get an empty
collection back, that might seem normal and
just boring Evan, but it's interesting, we'll
see why in a minute so as you expects if you
map interempty list you get an empty list
that's easy enough. Then we have a different
kind of collections that represents zero or
one Element. And those we call optionals or
options or maybes, depends on language. Now,
we can also map over those because they are
sort of the same sort of container, so we
can transform the Element if it's there, and
don't do anything if it's not there, it's
like an empty list, right. So we can map increment
over someone and get sum two or just over
none you get none back. So it's sort of like
a list of one Element. But then there's something
a bit different that behaves exactly the same,
and it's futures. Futures are just things
that represent an Evanual value, so eventually
&quot;X&quot; or an error. So it's something in the
future that will either return a value or
yield a error. But we can also map over those
because if we think of them as just these
sort of containers we can transform the value
when ever it exists and just don't do anything
if there's an error or do something else.
Now this is cannot with a coincidence ‑‑
this cannot be a coincidence. They're wildly
different, especially a future from the rest
of the things they behave the same with the
function map, there must be a function map
that capture it is essence of this operation,
mapping over a thing to understand that we'll
start calling these sort of different things
like futures, collections and optionals we'll
start calling them boxes or pots in like in
Stephanie's talk. So let's talk about boxes,
doesn't matter what it is, just a box. So,
just knowing that a box be it a future, optional
or collection, if we map over it with a function
in a place the F function to whatever's inside
the box in a way the box sees fit. Each box
has it's own semantics, returns it all in
the same kind of box. Now, I cannot stress
enough in a place a function in the way it
sees fit. We do not get to see, no, I apply
the function two times for the first Element,
three times for the Element that we'll be
eventually whatever. The box knows what to
do. It applies functional how ever many times
it wants and exactly when it wants, if at
all. So it has a lot of power. It's not just
a dumb container of things. Encapsulation,
if you've done OO this is sort of a holy cow
ofOO, it is for a good reason. In these boxes
have also sort of the same properties, you
shouldn't reach into them and try to get the
values out of them. If you have an empty list
and you try to get the first Element, what
do you get, nil, null, undefined an error
your computer freezes, you don't want to go
there. The same way with optionals if you
have a non, a thing that has nothing in it,
if you try to extract the value what to you
get F you try to wait for a future, basically
means blocking a thread till the future realizes
it's value, which is not ideal, you should
never block the thread, I shouldn't have to
say this here. So ... let the box decide.
That's the whole point of boxes, so it doesn't
matter what the box is, it will do the right
thing. That's a powerful thing because the
only thing we need to learn is just the function
map. And with that we can do all sorts of
things with futures, optionals and lists and
many more things. Now, this has a name, these
boxes are called Functors, in sort of a, I
don't know academic‑speak. So if you ever
see this word, it's just boxes, nothing else,
boxes that you can map over with a function.
So no problem there. Now, this is quite a
lot of power, the map function, but it's not
the only function that we can use, there are
other things. Especially there's a case where
a function yields another box so you end up
with nested and nested and nested boxes. If
you have box of T and a function from T to
box of U if you have more of those functions
you end up with just nested boxes and that's
just not, you cannot just map over that. I
mean that's not always a problem, but it usually
is. So more concretely we have a collection
of strings, and a function from string to
collection of strings. Let's say we have this
string and we want to split it by comma. And
then split it by dot, each of those Elements,
we end up with a nested list. The problem
with a nested list is that if you want to
keep processing it, you need to know at which
depth you're operating where are the strings
like at the first step or second. This is
not a good thing because this basically doesn't
compose, if you pass it to another piece of
code, the code now knows which depth it needs
to operate at. Which is not good. So we want
to do this, there's this handy function, Flatmap.
That basically like map, but it Coconates
the results at the end, it flattens the collection,
so we get instead of map, we use Flatmap and
we get on with our life, everything is platenned
and you can keep processing each Element.
If you have optionals, an option address and
function address and option street number,
because everything from address is uncertain,
you end up with a nested sum or like a nested
option, and that's not good, you might even
end up with a nested ‑‑ or with just
a non, nonasset or non, nonsomething so you
don't even know determinationically what's
going to happen like what depth are you going
to have to operate. That's a No‑Go. If you
do the same with optionals because they behave
like listest basically you can also Flatmap
over them and Coconate ‑‑ which means
just flatten the whole thing. Which would
be a non, or sum if it's actually a sum. And
finery the same thing can be done for futures.
If we had a code that calls an API and gets
a future of Repository from GitHub and then
a function that takes a Repository and knows
how to pitch it's followers from the API as ‑‑
knows how to fetch it's followers from the
API as well. If you keep going back and forth
we wean with the API you end up with nested
futures, it's a mess, what you want is Flatmap,
it's exactly the same. We see that it flattens
the future just as if it was a list. Now,
Flatmap for boxes means that it applies F
to whatever's inside the box in the way the
boxes fit just like map and then flattens
the results presumably a nested box into a
single flat box with it's own semantics, futures,
wait until one future returns and do the next
thing or just optionals basically take ‑‑
give you a sum if everything went well and
none if something went wrong. That's each
box has it's own semantics. So when ever you
find yourself with a thing, a box, and then
function from T to box of U or function from
V to box of U to V and so on, it's sort of
deep functions what you want is Monads, is
exactly the Flatmap function, that's all it
is, it's all called bind in some other languages,
but it's called Flatmap in Scalla and other
sort of ‑‑ there's so many names for
the same thing, whatever. Flatmap is good,
it makes you think of map and then flatten.
So ... now, as a recap we saw that just by
knowing these two things associative addition
and neutral Element, of anything, we can fold
a real list of those anythings. We don't need
to know anything else about it. Then we know
that if we have a box, doesn't matter what
kind of box it is, and I assure you this'
hundreds of hundreds of different kinds of
boxes you can use map, with your function
and it will work, the way you intuitively
expect. And with Flatmap, it works when you
have functions that create nested boxes and
you want a normal box back. So, now that you've
seen all these abstractions, you only need
to go to your own code bases like, just make,
like this, a little bit, and see in your own
code, oh, this looks like a box that you map
over. Or this looks like a thing that produces
a nested something. And even though you didn't
have names maybe some of you did, but many
of you didn't have names for that before.
Now you know what they're called and you will
recognize them in your own code. And then
you will know there's map and Flatmap to your
rescue, basically. So, I dare you to go to
your code bases and look for these patterns,
and also, to Monads we were talking about
for example you could think of validation
errors as things that add associatively and
have a neutral Element, which would be the
lack of errors. And then you could just fold
over the list of validation errors and have
just a bigger validation or just a success.
So things like that. Be creative with identifying
spotting things in your own code. Finally,
I'd like to thank Jessica Kerr for encouraging
me to do this talk and guiding me through
the sort of the topics. And I actually, I
don't think we have time for questions ‑‑
or do we?</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>