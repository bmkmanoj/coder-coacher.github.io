<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Guy Bedford: Package Management for ES6 Modules [JSConf2014] | Coder Coacher - Coaching Coders</title><meta content="Guy Bedford: Package Management for ES6 Modules [JSConf2014] - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Guy Bedford: Package Management for ES6 Modules [JSConf2014]</b></h2><h5 class="post__date">2014-07-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/szJjsduHBQQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it's really amazing to be able to speak
with you all today so thank you for the
opportunity this talk is really about
package management for the browser and
the reason why the focus is on es6
modules Israeli because they currently
been drafted into the es6 specification
and they're being reviewed right now so
it's it's something on the way and the
reason why I first got interested in es6
modules myself was because I got very
frustrated with the fact that we have
all these different module formats and
the common jeaious in global scripts I
just wanted to see if there was a way
that we could unify these and it's very
much something that es6 is bringing to
javascript through the specification
it's it's a specified module syntax and
it's it's built to support bridging the
different module formats we have today
so I've got a lot of hopes for that at
the same time in the process it's it's a
whole new way to reconsider what we what
we want to think about in terms of
package management for the browser so so
that's what really excites me about es6
modules at the moment the project I want
to show you is called JSP m and it's an
experimental project exploring what's
package management for the browser can
be and the the starting point for this
idea was let's look at a package manager
for the es6 module loader
think about where we want to package
management to be where it could be and
explore that and and the core package
might into an idea you want to start
with is that installing something you
should just do a one-line install and a
one-line require so anything more than
that and you've added unnecessary
complexity and I think the argument is
that to really get to that point where
you can have a single line required and
a single line install you need to have a
package manager that understands the
loader so by having a package manager
that knows how the loader behaves you
avoid all the problems around
configuration friction so that's the
really the core idea so so let's go into
the first thing we need is a module
loader so how can we actually start
using this es6 module loader today well
there's a polyfill called the ESX module
loader party votes on github and it's
it's a complete polyfill for the way
that the es6 module loader specification
is written right now so that actually
allows us to start working with es6
modules today in the browser and no J's
on the server it's a seven kilobyte
polyfill so it's actually suitable for
production so just to explain what it
does it obviously gives us support for
the module syntax like you can see here
and but the really key thing that the
spec authors have done is they've
created this module loader pipeline so
just to explain how it works a little
bit that they've they based it on this
extensible web principles and the idea
is that they've solved the really hard
problems around modules things like how
to deal with circular references how to
deal with interrupts between AMD and es6
and common J's but then they've they've
left the exact solutions to those
problems up to hooks in the spec so we
have these loader hooks normalized
located fetch translate instantiate and
most users don't come up against the
hook but but the point is that you can
construct
customized the es6 module loader with
with new functionality and and how to
interpret modules so for example if i if
i customize the fetch hook i can
customize how to fetch jquery in the
example above in the browser your fetch
hook would be an HTTP request get
request and in the on ojs it would be an
FS read file maybe you want it to be an
FS start read file and if it doesn't
exist you loop through the node modules
folder so it's it's opened up those
exact implementations through these
hooks to actually use this loader in the
browser we need an initial version of
the hooks
that'll work in the browser so we need
to have that fetch hook implemented in
all the rest and that's the system
browser loader and it's actually a
separate specification so the the system
browser loader is currently based on a
mozilla sudo implementation and it's a
promise of space loader if you are
familiar with AMD loaders it is exactly
the same sort of usage apart from the
fact that it's promises based you can
basically load module names you can load
es6 modules and this is given to you by
the polyfill T is six module little
polyfill and then I started this project
called system J s and the idea was
system jeaious was we've got this basic
loader that can load es6 but we want to
make it something useful that we can
actually use today we've got the ability
to support MD common just in Global's
let's start doing that so I started
creating compatibility layers for the
loader to actually load MD load common
J's and and dealing with the edge cases
like things like circular references and
common J's circular references act
differently to MD circular references
and getting all that in as I say it's
it's it's very much what you would get
if you took in one of the existing AMD
loaders and rebuilt it on top of the cr6
hooks
it's got map it's got shim it's got a
plug-in system for asset loading and
bundles which was a new feature in
requires yes and then there's other
thing called versions which I explained
a bit more later
so yeah this is system dis it's a it's a
seven killer by minified and gzip
project so together with the module
loader you're getting 14 kilobytes in
production you've actually got this
dynamic loader based on the technologies
that are specified for the loader in the
future that we can use today through
these polyfill techniques so that's the
lowdown the other side of it now is
package management so if you've got this
loader can we create a package manager
to really simplify the process of using
it and the first thing I want to think
about is the sort of time scale you're
looking at four years six is actually
very similar time scale to HTTP two and
and widespread speedy and HTTP 2 so you
actually in this kind of thinking
bundling is an anti-pattern we want to
be thinking beyond bundling and and
that's there's a good reason why
bundling isn't catered for in the es6
specifc specification because it's it's
it's something we're actually going to
move away from over time and yes it will
be a while still it'll be a few years
but in that's where we want to be and
not only will that make our build
simpler but the other benefit you get is
fine grained caching so if you have a
large application you have a build of
that application you have to resend a
lot of assets again just when you make a
minor change if you can have fine grain
caching with version URLs you can just
update the versions that have changed
and the other assets remain in the cache
of your users so it is much less
redownload in you do upgrades but in
order to properly take advantage of this
we want to allow unique version URLs you
want to have a node modules folder that
you can drag onto your CDN host it as
your static assets but have those URLs
versioned so that your users can get
them cached and you can just update the
versions and the URLs and then and then
the real high problem around package
management is is obviously the
dependency management principles and
it's not enough to just assume that you
can solve every version count
you will reach a point where you have
two dependencies that you've loaded into
the page and they're both dependent on
another dependency but they need
different versions of it and you have a
version conflict and when that happens
what are you going to do you can't let
that break down the entire workflow if
you really want to get a proper package
manager going you need to be able to
deal with version conflicts and and the
way to do that is to have the multi
version support you have to be able to
run two versions of the same library at
the same time and then as much as
possible minimise that duplication so we
know the range is that every package is
allowed to be installed in two and then
we try to minimize the duplication of
versions and find the best version
solution that's going to going to work
for that the other thing we can do is
use cember and the more people can use
cember the less duplication there will
be assembler is nothing more than a
commitment to backwards compatibility
and and if you think about that when
you're building your API is and if we
think about that is we're writing
software this whole process will be a
lot easier for everyone because when I'm
in a development mode and I'm installing
dependencies into my project I can
install them to the latest versions and
know that the API is maintaining their
contracts but even with all these things
you will still still reach a point where
dependencies don't quite match up to
what you want you'll be one library that
needs jQuery one and another library
that needs jQuery two and you can't
expect the system to resolve everything
for you at some point you want to just
be able to manually override everything
that's going on and say well I just want
to make sure that the only version of
jQuery in this application is jQuery 2.1
and you want to be able to override that
at a global level so the idea was to
have a central dependency manifest a
single place where your entire
dependencies are mapped out that you can
kind of control and and have have final
say over the whole process so just to
summarise looking at package management
for an es6 module loader so trying to
build on the principles of tomorrow and
make something that we can use today
support existing modular formats and
registries flat multi version support so
you get the fine-grained cache
benefits of HTTP to a central dependency
manifest so that the developer has final
say over the full dependency tree but
then allow production bundling today so
we have those workflows that we can
actually use modules today so I'm gonna
dive straight into a demo and show you
exactly the sort of thing I'm talking
about with us
so when I was thinking of a demo the
sort of thing I was thinking of was
something that it resembles a future
workflow so something that we want to be
doing in the browser and a good example
seems to be web components using an es6
module so first we need to install JSP m
and we can do that with NPM this talk
does use the internet so if you can
please take it easy on the Wi-Fi that
were you really appreciated
I can now install this components with
JSP m install and I actually hosted this
component on github so I'm gonna install
it straight off of github so the naming
system here is is a consistent naming
system that is used throughout and when
I write this the first thing it asks me
to do is set up a local package to JSON
for the project where to download all
the dependencies into this JSP M
packages folder the config file to
create then it goes to github it checks
the tags looks for the latest cember
tags uses that as the stable version
installs the dependencies downloads the
es6 module loader polyfill the system
J's loader that contains the AMD common
J's compatibility layers and that's our
single line install if I want to
actually use this now on the page let me
just create a test page to use it so I'm
just going to load in the system J's
loader which is was downloaded as the
JSP and packages folder and it's a
versioned loader file this will
automatically include the polyfill
itself so we don't need to do anything
more than that and now what I have is
the system browser loader extended with
the functionality we want so I can now
use system that import and import year
six and different modules so for this
application I'm gonna have a main
application entry point that I'm going
to load
so I'm just gonna say load app and
that's it and that'll load app from the
local folder so I'm gonna edit an app
dot J's file and I installed this
components as github guy Bedford
markdown components the same name that I
used to install is the same name that I
want to use to require so common J's
really is the simplest way to write
modules so I'm just going to do a comedy
require in this example so I'm going to
require the exact same name I'm not
thinking about versions or any of those
problems and so now we've loaded the the
components and to actually use this
component it's a it's a web component
and what it does is it passes markdown
within the web component tag and also it
also features syntax highlighting so let
me just show you this
so I'm just going to create a code
example as well
right and oh I've also got to include
there was a generated configuration file
so I need to include the generation the
generated configuration file in the page
so that's that's kind of all we need to
do and hopefully it'll work so is the
one-line install one-line require and
there it is so that's a markdown
component thank you
it's yeah let me let me try and explain
exactly what's going on here and how
this is all fitting together when I when
I first downloaded the components it
downloaded into that JSP and packages
folder into into a versioned folder so
it's J's pin package --is github for
everything that was loaded from github
and then just the name of the repo with
the version so it's a version URL and if
you look inside this folder we have
exactly the same files that are on
github so here's the github repo and the
two files I want to show you is packaged
the JSON and markdown component jeaious
if we look at the package that jason
we're actually using the package JSON to
declare the dependencies and the way we
can do this without conflict with NPM is
by interpreting the dependencies in
combination with a registry property in
the package so Jason
so when J's PMC's that you've got
registry JSP m it knows it can interpret
the dependencies if you do not like the
idea of overwriting the dependencies
speak to me em but you can actually also
use the prefix so we could have a JSP m
prefix within the package to JSON and
that would also work and then now that
we we know that we're dealing with the
JSP m registry the dependencies are
listed first by the name that they're
required by within the code of this
package so whenever this package refers
to showdown this is what it's referring
to so that that's what the dependencies
just as you'd expect showdown there's
the markdown passing and it's also
loaded from github Samba compatible with
version or point 3.1 prism does our
syntax highlighting and it's also loaded
from github at the github pages branch
which is the branch that Lee ever uses
to publish it on I don't have to enter
in the full path to prism because it's
actually in there's there's a shortening
service that JSP offers just like the
bio registry so it stores short names
against their longer name so when there
is no name given with the github colon
part at the beginning it knows to just
look it up from the the the short list
registry and then we have this CSS
module as well so those are the three
dependencies and here's the code so this
is the component the first thing to note
is that web components are really nice
to write in es6 modules because of the
fact that when you run document register
element what you're actually running it
against is a class so class you're going
really really helps with that so we can
create this class x markdown component
normally we'd have to have an object
with a prototype that has a created
callback property the class sugar just
makes that a lot nice that's right we
can extend the HTML element very simply
and that gives us the this stock query
selector all that we call all over here
which is really convenient and then we
just do the the syntax parsing with a
bit of really bad whitespace
manipulation using es6 features and then
we do the the code highlighting so it's
a relatively straightforward component
but the thing i want to show you is that
the imports so how are these imports
working we're importing show down and
we're importing prism and the name we're
importing from is exactly the same name
in the package to JSON dependencies
showed um i think one of them is a
global one of them is an MD module we
don't need to we don't want to think
about the in syrup and the point is that
by allowing each package to configure
itself you can avoid the in syrup issues
and and and just get to a point where
you could require from packages directly
and that's really fundamental to that
that zero friction approach and then the
next thing we have is we import the CSS
file this is the CSS file within prism
to do the code highlighting style so
we're actually injecting CSS within the
module system the benefit of this is
that I can deal with abstracted names in
the file I can call it prism I don't
need to think about where prism is what
version it is and then I can actually
start loading files from within that
that folder again if you're familiar
with AMD familiar with those kinds of
loaders the the module names are exactly
the same principle the reason why we're
able to have these short names it's just
map configure it's exactly the same
ideas AMD and the way I'm loading CSS is
a plugin just like you'd get a plug-in
in an AMD loader the one thing I did was
I moved the exclamation mark to the end
so basically when it comes across an
asset that has an exclamation mark in
the name it reads the extension of the
file and then it looks for a module with
the same name as the extension and uses
that to do the asset injection and that
was the CSS module CSS is something
really fundamental so potentially it can
be brought into core at some point but
because the way the injection works is
still kind of developing it's nice to
have it as an isolated module so it's
not even really part of JSP m it's it's
anyone can create their own plugins to
do like template passing or other types
of injection and the way the injection
works is it simply injects a link tag
against the head waits for the onload
event and when the unload events fired
that returns the fetcher in the loader
hooks so plugins just override the load
hooks of the ESX loader and then it's
taken is loaded so none of this code
here will run until that CSS has been
injected into the head and completely
finished loading and in that way you get
this really nice dependency tree of
multi asset types with the abstracted
naming and its approach it's an approach
that I really like you don't have to use
it it's not it's not man
but it would allow me to do the nice day
all right so let's let's take make this
site look a bit nicer what I want to do
now is install bootstrap just to give it
a bit bit more of a nicer theme so again
I just want to install it by name I
don't really I want to think any much
more than that so I'm just gonna say
Jess for install bootstrap and
bootstraps also on github
it's got releases on github so it
actually downloads from the release
archive but it does the same tag lookup
works out the versions and all the rest
and then for the dependencies the reason
why bootstrap can install is because it
does have some JSP m metadata in the
package that JSON now that I'm installed
bootstrap in my app file I need to
require it so I'm just gonna say require
bootstrap so it's the same name and then
let's just see that we've got it in the
page
okay so there again injecting the CSS
dynamically through the module loader
alright so now we want to take this site
and put it into production if you look
at the network tab at the moment this is
obviously not at all suitable for
production we are passing es6
dynamically in the browser so that the
system jeaious is loading in tracer to
do the parsing which itself is 500
kilobytes there's a lot of stuff going
on that we don't want to be happening in
production we've got a 21 separate
requests of all these files so how can
we take this and make it something that
we can actually put into production
today and that can work so we do need to
do a bundling approach for this so to
make a bundle what I need to do is
create a bundle of a specific module and
in this case we have that app module
entry point so I'm just gonna bundle app
and again the naming system is exactly
the same naming as you would use in your
requires so I can actually bundle any
module within my current required tree
bundle app and that's called the file
app build jeaious so that will go into
app trace the dependencies and bundle
everything together into one file
transpiling the is-6 in cs5 and so that
we have the build and then I need to
include this in the page so I'm just
gonna say include Apple J's because I
use the new six component that used
class syntax I actually need to include
the tracer runtime as well it has a
class helper called create class which I
need to include through the tracer
runtime so I need to add that ideally
you wouldn't actually you ideally if I
wasn't using es6 modules I wouldn't need
to do this at all so if I was just using
AMD and Collins yes this wouldn't be an
issue
okay so now if you look at the network
tab the same the same code is now
running in the page but we're only
loading we're loading everything from
the single bundle
so that's transpiled er6 comma J is MD
all running together in a single bundle
in a way that supports all their
circular references together and just to
give you some idea of what it looks like
it uses this two variations of system
dot register and it's just kind of
wrapped everything up in these wrappers
so that's how it works
all right then there's one other example
I want to show you which is how we can
load from other registries and and also
what happens when you have deeper
dependency trees all right so what I'm
going to do is install a demo directly
off of MPM this is a demo created by
McCullough lysenko so it's a he's
finally given permission to use it and
I'm just gonna go ahead and install that
it's got quite a big dependency tree so
it's going to take a while to install
I'm just going to leave that going on
the side so let's get that going
and I'm just gonna add a button to the
page so that I can click this button and
load the stuff dynamically
I'm gonna be kind of lazy and just an
on-click event I wouldn't actually do
this normally so the thing I want to
import is exactly the same name I just
installed which is MPM voxel demo all
right so it's gone through the
dependency tree and installed and
resolved versions and done all that
stuff let's have a look at the page so
we got this button and this is the one
where it's quite fun to watch the
network tab go it's about it's over 60
modules about 120 requests so let's run
that and you see it runs they're all
common J's modules loading in the page
and there it's finished let's see that
so yeah it's it's a full WebGL demo
running in the browser it's using the
same node libraries as browserify so
it's pretty much replicating those kind
of principles and dynamically compiling
that all in the browser again how do I
actually use this in production so how
can I take this into production well I
can do a bundle just like I did just now
actually before I do that I want to just
speak about the configuration file and
show you what's going on with all of
this so here's the configuration phone
if you're familiar with AMD it's simply
map and pause config all the way through
so we have positon fixed setting up when
I said NPM box will demo its loading
from JSP and packages NPM so it's just a
pod set up and then the way that I can
load for example just bootstrap by name
is map config so we have global Mac
config that says when I require
bootstrap what I'm actually loading from
is github Twitter bootstrap version 3.1
point 1 and then the next thing we have
is contextual map config and this is
really valuable it's the way that we can
abstract the naming so bootstrap can
refer to jQuery by name and something
else can refer to jQuery by name but
they can have different names and this
was pioneered I mean this stuff was all
developed within the AMD world we're
just
redoing it here there's nothing really
new
so here's bootstrap version 3.1 point
one and you can see it's loading jQuery
and when you write jQuery what you're
actually getting is github components
jQuery 2.0 so its global map config
which is the one without the object this
one and then contextual map config so
with in bootstrap these are the names so
every every package can have its own
names and that's how you can easily do
the multi version stuff we've got quite
a deep tree now because I installed all
that stuff from NPM and then at the very
bottom we've got this versions and this
is the final version solution currently
for everything every package in the page
so we can see every version and there's
actually when I installed from this NPM
module it created a few version folks
that come up as arrays in the version
map so for example geo shader we're
currently running no point six no point
no point six and no point 0.5 together
in the page I don't want to be doing
that so what I can do is I can check
this configuration file into version
control there is no state in the JSP and
packages folder there's no information
about versions in there it's it's a
universal kind of property and I can
just modify this this versions config
here and say I actually just want to be
using GL shader version or point 0.6 and
this is how I can go through and
manually manipulate my own version tree
the problem is I'm going to now have
some unfulfilled dependencies so I'm
just going to search through them the
dependency map and see what is using
version or point 0.5 that I saw that I
can remove it so here's the first thing
that's using GL shader is calling it by
named Yoshida and actually getting this
full version no point 0.6 where's the
next one here so NPM error shader is
actually using GL shader compatible with
version or point 0.5 and that's what was
causing us to need to fork and run the
second version so I'm just going to
update this here to no point 0.6
we can now check that into version
control and that's a version up
I've changed the dependencies sub
dependency but because the full version
manifest is in one place I can have
final say over that so I'm just going to
rerun the page one more time we're now
running just that no point 0.6 version
we've resolved the fork and then I can
now test it and see if it's still
working and it is so we know that that's
worked and that's how I can have full
control over the dependency tree so now
I want to bundle this for production so
I'm just going to do JSP and bundle
again and the same name so the name that
I'm writing here will still go through
all those map config things and etc and
let's call this voxel bundle J's so that
creates a full bundle like a browserify
bundle but we only want to load this in
the page so someone might never click
that button you know it might be a
pop-up that features new functionality
or something so you might not want to
load everything up front I just want a
load in that new functionality when
someone clicks the button so what we can
do for that is something called bundles
config and it's it's a feature in
require.js today so again I didn't
invent it at all so we call this box
whole bundle was that the name I gave it
yes so the local name I would type
import voxel bundle to load that bundle
so I used that name and now I can say
what the bundle contains so what modules
are inside the bundle and what that
means is anytime I request one of these
modules that upfront has been declared
as belonging to the bundle it'll make
sure it's loading from that single
bundle I have to now enter in fully
normalized names because bundles contain
normalized module names so I'm going to
load in nor point 1.0 so voxel demo nor
point 1.0 is contained within this
bundle if there were other things like
if I put jQuery into that bundle I could
also add it to this list so as soon as
there's a requester it will go to the
bundle and with some luck I think that
should do it now
so if you look at the network tab we
load the initial page with our app build
that we did just now and when I click on
the new functionality it it didn't work
so why didn't that work I think it's no
point 0.1 so you do have to get the
exact name and exact version right all
right so when I click the button it just
loads that single bundle if you can see
it on in the network tab there and it's
then just like a browserify
bundle loading the full common J's tree
from within that so yeah that's it
that's pretty much what there is - it's
it allows you to kind of package manage
your existing modules today and and
bundle them up with these kind of
workflows using any a6 module loader
right and then there's one other thing I
want to talk about which is how we
looking at the future workflows of HTTP
- so I said at the beginning bundling is
actually an anti-pattern it's it's it's
something that we're going to be moving
away from how can this work when we're
actually going to be looking beyond
bundling and one way we can do this is
we basically take that JSP in packages
folder host it on your local assets
server and put that into production
effectively and because of the fact that
the the files of versioned you get
everything running through that and
there is actually a CDN set up as well
so you can actually run directly through
that and and that core thing is that the
config manages your full dependency tree
and the exact resolutions right so
that's it some of the next things I want
to work on include conditional loading
for example in reality I wouldn't just
load a web component I would want to do
a conditional check on my environment to
check that the environment supports web
components if it doesn't load a polyfill
and have that conditional loading baked
into the module
system itself and then to look at builds
around it and also thinking about
internationalized builds and how you can
do builds around different languages and
mobile build tooling for plugins as well
so this look at the kind of things that
I'd really like to work on next yeah so
that's it
the I'm not telling you all to go off
and start writing years six web
components what it's really about is
focusing on an approach that can be
based on the ideas of year six and you
can use it for AMD common J's and
existing workflows today and I mean the
real path to es6 is it is much more
nuanced than than just using these kind
of approaches but by basing the by
basing ourselves on these approaches we
can we can find a stable workflow that
can that can make package management
really easy and that's that so yeah
check out the projects let me know what
you think if you like it if you hate it
are we great to hear so thanks so much
for your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>