<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Matthew Eernisse: Heaven &amp; Hell JavaScript ... everywhere? | Coder Coacher - Coaching Coders</title><meta content="Matthew Eernisse: Heaven &amp; Hell JavaScript ... everywhere? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Matthew Eernisse: Heaven &amp; Hell JavaScript ... everywhere?</b></h2><h5 class="post__date">2013-01-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RM1jHROQtgQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">right so this is the jeaious everywhere
thing I think we're all JavaScript
people so we're pretty happy to see
JavaScript popping up in all these new
and interesting places I'll start off
with a little bit of self introduction I
work at Yammer I am a web dev I've been
doing building stuff for the web for I
guess kind of a long time at lots of
different places in the web stack but my
home has pretty much always been
JavaScript so I'm really excited to see
what's happening in technology now with
JavaScript taking over in all these
different places right so talking about
JavaScript everywhere the good news and
the bad news the the agony and the
ecstasy I guess the good news is if
you're a JavaScript guy you get to use
JavaScript now in all these new and
interesting places right bad news is
that you have to make your code run in
all of these different places right so
kind of like people who are using Linux
as a desktop operating system before the
abuta guys came along the good news was
that you could configure your OS to your
heart's content but the bad news was you
had to configure your OS right so it's a
very similar story and I guess probably
the Linux guys would point out that the
opposite and equal corollary applies on
the Mac side right you kind of can't
configure anything right so everywhere
I'm gonna be talking a little bit about
desktop and mobile a little tiny bit
about system tools JSON the server and
then browser just for completeness we
don't really need to talk about that
because you've been doing it for such a
long time right so what to expect from
this talk first of all you're not gonna
see a bunch of JavaScript D triumphalism
I don't think that's probably very
necessary anymore this trend of
JavaScript encroachment has been going
on for a really long time I can remember
early in 2007 a guy named Steve Yeager
wrote a post he entitled NBL which was
talking about JavaScript as the new big
language
and I remember at the time myself being
fortunate enough to already be doing
lots and lots of JavaScript it was
really exciting for me because I kind of
idolized Steve to see that he was seeing
it too Jay is the language of the
browser the browser is your viewport
into this interconnectedness of the web
and so pretty simple equation and it's
just a matter of sort of marching
forward inevitability right another
thing not to expect is a lot of Pat
answers because this is all very new
we're it's it's been going on for a long
time but the mainstreaming of this is
still relatively new we're kind of
making still sort of making this stuff
up as we go along kind of light some
parts of this talk right so the obvious
benefits of using javascript knowledge
different places probably don't have to
sell you guys on on some of this
although I see that there are lots of
guys coming into jeaious from other
places and they're finding out whether
they were Python people or Java people
or Ruby or what that javascript is is a
pretty good language to use right we
like it it's fun and surprisingly for me
more important than the code reuse which
is which is nice is not having to switch
back and forth having finished my first
sort of large full stack JavaScript
feature at Yammer in the past couple of
months it was really really amazing how
much more productive you become when
you're not suddenly needlessly paranoid
about white space in your front-end code
or needlessly inserting semicolons on
your server side code it's a good
feeling and you you it's a lot easier to
achieve a sort of flow state where
you're just building the thing it's a
really great feeling so we'll be talking
about desktop jeaious and mobile Jay
Mobile Jas I'm going to kind of lump
those together reason being that despite
the fact that you your UI constraints
are a little different and the the
screen size is a little bit different
the the method of developing these apps
is still pretty much the same whether
you're working on the desktop or mobile
there's four sort of categories of apps
and because of what we've done at Yammer
specifically with our desktop client I'm
going to be focused
very specifically on writing in j/s this
thing of sort of launching a minimal
browser its installed out but it's still
sort of runs like a browser it's a bunch
of way to build apps but they're the
same whether it's desktop or web so
focusing on an installed app I think
it's probably at least worth touching on
I don't want to derail the JavaScript
everything thing too too much but it's
worth at least talking about this
discussion of whether you should be
building a native client or not because
something a lot of people are talking
about had a very long and involved
discussion with one of our engineers
Kota Hale on Saturday during our data
center move about the problem with
native apps versus non native apps so
it's at least worth mentioning this
whole discussion and was kind of
crystallized in a blog post by Alex
Payne formerly of Twitter basically
decrying air as a development
environment and the TLDR of his blog
post was essentially that if you're
deploying an air app you don't care
about your customers that was sort of
the takeaway from his blog post and I
think he backpedaled a little bit when
there were some responses to his blog
post he backed backed off on some of the
more incendiary pieces of it the point
is is is valid but I think the question
of whether or not to develop this kind
of an app is affected by two very very
important and practical things the first
one being the simple practicality of
what do you do if you need to ship an
app right you can't necessarily hire
someone for every environment that you
that you want to ship for maybe you can
you know maybe you can't contract out
maybe it's too hard to manage the
relationship with your contractors or
ensure you're actually not getting crap
right or just don't ship an app one of
the responses from the guy who does the
spazz Twitter client which is a JSF I
think he has a very good point it's it
may be easier to develop a bad app using
one of these frameworks but being native
there's plenty of crappy native apps if
you've ever used Windows shareware it's
very very easy to build crappy
crappy app whichever thing you're using
maybe a little bit harder to do a nice
app with something like air but it's not
it's not like it's impossible so the
second point and this is maybe the more
salient
what does Native even mean when the app
that you're talking about is first and
foremost or is originating as a web app
right so here's a very good example
Facebook has released an update to their
iOS client that uses that renders the
feed with the same markup and JavaScript
as their generic mobile site right
Facebook is a web app so what do you do
when your app is sort of inextricably
linked with the web and anything you do
interacting with with the app or lots of
things take you to other parts of the
web right so it's not entirely clear
that native is native is better I don't
think it's it's maybe up for debate and
this was sort of my just my discussion
with coda the crappiness of this
environment how much of it is because
it's kind of web --is-- it's neither
fish nor fowl problem or how much of it
is just that the implementation is it
very good and I don't think there's a
clear answer for that in any case we we
have now a new desktop web app it's an
air app using all of the same j/s that
powers our web our website so there are
some sort of environmental constraints
building an app like this and then there
are also some sort of macro level
impacts on your development process that
come from from having this kind of an
app specific to the the environment
obviously you're dealing with an older
version of the browser you end up with
some either crippled or sort of
non-standard implementations of things
that you come to expect in a modern
browser like no eval after document
onload means say for example you can't
use ejs right if you're if you're
wanting to use ejs you're Sol you have
you have the a relatively nice mechanism
of communicating between windows but
it's not post message it's this other
sort of weird thing the sandbox bridge
thing that's separate so you end up in
your J's code with you know the crappy
browser block the good browser block and
then the other air block now you have
yet this other not either one
environment that you
have to support and of course the biggie
is that the tools are still not there
and this is kind of a continuing refrain
that we'll see over and over debugging
is terrible we're kind of spoiled with
the tools that we have in the browser so
at the macro level the what the impact
that it can that it has on your
development process because of course
now this code is all distributed out in
people's desktops and they may or may
not have the wherewithal to to upgrade
their app you have to be a lot more
careful the people developing the web
j/s have to be a lot more careful with
their development process because you're
syncing up at points in time with with
the desktop code base the corollary to
that of course is that you can't simply
push a bug-fix on the front end and on
the back end you can make changes to
your back-end code you can make changes
to your web code but it has to be
backward compatible which ends up being
kind of a pain in the ass in some cases
so I guess this is probably yeah you
could sort of shine a spotlight on this
this is the this is the take away
versioning is really really important if
you're going to be doing this sort of
cross environment development and not
necessarily simply adding a tag it's
very important to make sure that
everyone understands what the
ramifications of the various tagging
scheme might be so are we going to do
the odd and even thing are we going to
you know how do you know when the API
breaks essentially right so is it is it
one two three and then go or is it you
know one two and then go on three so the
next one is also important or is bigger
than just a desktop jazz thing but it it
is very important in that environment
which is wrapping things that are
utilities that you expect to use in
these various environments so a good
examples for us we have a thing called
yam global that points to the global
object so whatever environment we happen
to be in we know that that's what that
is meaning your developers off of these
magical things that are just existing in
the global space I'm having a single
entry point where you can in your code
where you can push in the dependencies
rather than expecting them just to be
out there
the air privates privates are nice but
sometimes you need a monkey patch so
that you can just ship it's not
necessarily pleasant but it's reality
and it's nice to have that tool at your
disposal so I like private methods but
sometimes they can be problematic the
last one is probably the most
problematic
we found simply because it's really
really onerous if you're a web jazz guy
just set up one of these other
environments to test it right but it's
and this is still not solve prom for us
it's really really important I myself
have been guilty you guys know of making
some change happily making some change
in the codebase knowing that there's
absolutely no possible way it could
affect the desktop but sure enough
because I'm not firing up the desktop
and because we have no automated tests
on that yet right so this is the other
refrain in this besides tools is testing
I ended up breaking stuff so for system
tools the system tools bit I'm only
going to talk about one thing and that's
simply because I have a lot of personal
experience with it this is the Jake
build tool so if you're used to some
tool like rake it will feel very very
familiar does all the stuff that you
would expect a build tool to do or most
of the things there's one add one
interesting addition because it's built
for node it supports asynchronous tasks
of course it's asynchronous it supports
or it's built for node and unlike other
projects that I may or may not have
worked on this is actually maintained
and bug fixed yeah okay so this is what
a task would look like or the
description of this is what you would
find in a Jake file these are some
examples it's pretty straightforward you
can see in the bass task it's passing
dependencies as an array it's all pretty
straightforward you notice that it's
console dot during the arguments so you
can actually pass arguments and if you
go look at the readme and the github
project you'll see how to how to do that
there's a nice way to pass
in this is what an asynchronous task
would look like you just pass a flag to
the to the task set up it's an optional
flag that says it's asynchronous and you
call the complete manually when you're
done it also has a bunch of this stuff
that people that rake users would expect
like tasks taht execute invoke reenable
a global fail etc right so the thing
that we were all kind of here for we're
also super excited about is finally
having like real decent usable
JavaScript on the server
um the interesting thing is if you
notice the picture and I love the fact
that this book is still available on
Amazon right
so I don't know what year this thing
came out it would be late 90s but JSON
the server has been around for actually
a really long time here's a nice long
list starting with the original gangster
s SJS with Netscape Microsoft IAS so I
wrote my first server-side JavaScript
probably in the early 2000s in a classic
ASP app right hell mo which is still
around is a rhino based solution they
did some interesting stuff with
prototypal inheritance in the ORM white
beam was a spider monkey in XML then
there was this thing called Zemke does
anybody remember Zemke at all yeah
they if I remember correctly it was
spider monkey and the i/o was all mod
Perl something like that they were also
very interesting in that they were the
first group of people I ever saw trying
to do something like a development
platform as a cloud service this was
before the word cloud was being batted
around like it is now jax-ur I want to
make some kind of a joke like yo dog I
see you like Mozilla and you like server
so I put Mozilla in your server but
couldn't couldn't think of a good way to
do that but the last ones are all
projects that seem to be ongoing now JVM
Bay a bunch of JVM based solutions and
then of course nodejs
which makes us all very happy as
JavaScript developers and then the very
at the very very last item here at the
bottom just because it's very
to what we're doing Amur is these
embedded solutions where you can stick
v8 in some in something else right so
it's so exciting now to have feature
parody get it no no okay that's that's
terrible I'm I'm deeply deeply sorry but
it is it is very exciting to have
feature parody now with the server you
don't have to switch to something else
you don't have to keep these different
semantics in your mind switching back
and forth between the two things it's
really really exciting to be able to
console dot log in the middle of your
work or and and you don't know you you
can't remember which environment it's
going to be the out the output is going
to be you're gonna be seeing the output
in or forgetting whether you should be
refreshing the browser or restarting the
server it's it's a good it's a good
problem to have and it's it's very
exciting to be a JavaScript developer
now so some some of the very obvious
benefits of our code sharing we
mentioned that a minute ago these are
the sort of the the sort of obvious
places you would want to share code and
for me the big win here is validation
just because it's the fiddle iasts
probably bit of your of your code and
it's really irritating trying to
remember to keep them both in sync you
make a change to the client-side
validation and forget to go do it in
Ruby land or Python land or wherever it
is you have to you have to go so to
bring forward an example of that right
the Getty web framework it's not dead
it's it's just resting we are using some
pieces of this in production at Yammer
and the pieces that we're actually using
or are well maintained the rest of it
apologies not so much I'm hoping to have
a chance to work on that so here's a
good example this is a model from the
server and if you've ever used active
record or data mapper or any-any or I'm
like that this should look very very
familiar to you right this is just a
model with some with a validation added
and this is the same model this is the
same model on the browser right so let's
do that again
server browser right it's really nice
because it's exactly the same and when
you're when you create a getty app and
you create a resource then you run the
script that that creates one of these
scaffolds that has all the UI code it
literally takes the server-side model
changes a line and copies it from app
models into public J's models that
simple it's really really beautiful if
your JavaScript guides it's it's really
really nice so of course it's not all
sunshine in unicorn poop we have the
problem we've been talking there have
been a bunch of talks about this through
the last couple of days
modules talking about the problem of how
to get the code into the runtime and of
course the java scripts historic ties to
the browser means that sometimes it's
kind of hard to get away from the dom
right so much code assumes the dom so if
you were to ask a work a day like
anything you know generic language
program or what's the JavaScript library
obviously the answer would be jQuery
which is intimately intimately tied to
the Dom so a nice way to share code if
you have very very little code to share
between the two environments you might
actually be able to get away with the
stupidest possible solution which is
this right some common sensical naming
convention in both server and browser
and checking to see if there's a module
that needs to where you can export your
food namespace that you've created right
the problem with that of course is this
ad hoc in your code oftentimes turns
into sort of a big mess of crap and
sadly this is code that is still in use
in the Getty model stuff you can see
with the require sis that it's pretty
old and it could probably be done a lot
nicer but this is what happens if you
try to start minimal and you don't
actually plan so thankfully there's a
bunch of work being done on modules to
improve that a bunch of there were
numerous talks about that in the past
couple
so there's no real need to go over it
with the sole exception of saying this
is nice it's good to see all this work
going on but when you have a large and
very very complicated front-end code
base like we have a Yammer taking
something that's written like this a
very familiar pattern for creating some
you know module of code and then getting
it into the browser runtime it's when
you have a lot of this it's really hard
to turn it into turn it all into this
right it's a pretty big change and it's
a really ugly API to know no disrespect
intended i i've looked at this a lot and
thought about it a lot and it's hard to
imagine how you could do this any
differently but it is kind of awkward
it's an awkward api maybe server-side
pre-processing i don't know it's worth
considering so on this this is just here
for completion for a completeness it's
not something that we're really using it
Yammer we're still dealing with just
rendering templates but it's worth
mentioning that there's a lot of
interesting and solid work going on in
this area so what we are using is this
thing called the ruby racer which embeds
a v8 process in in ruby it's a very very
simple interpreter there's no IO for
dances there's no window you all you get
is a simple interpreter and there are
some niceties for getting variables from
Ruby land into into your JavaScript so
would JavaScript be the peanut butter or
the chocolate I've been kind of thinking
about this what do y'all think this
JavaScript more like the peanut butter
or the chocolate no votes nobody cares
what what's that that's probably the
peanut butter yeah I think so too
Ruby's more like chocolate maybe okay so
anyway you get you run your code and you
get back some value in in Ruby here's an
example of what some of the code might
look like you can see we're shimming out
the window object because we you you
look at how the code is loaded in runs
you basically have global loading
and global execution that's it so it's
very it's a lot more similar to the
browser model than it is to the stuff we
have on the server so shimming out the
window creating this goofy logging
string thing because there's no real way
to log except log outputting that that
log string at the end it's really sort
of back to the late 90s where you're
like sticking a div on the page and like
outputting stuff to just hidden do it's
very very similar to that right which
brings us to the last big piece and I
have to confess I had to make some
serious changes to this at the end in
the last couple of days because I was
anticipating just sort of throwing this
grenade out into the room and hoping
that I could escape in the confusion
because it's a really ugly question
still so initially this was my gonna be
my slide my one slide
anybody know kind of yeah alright so
this guy is he's obviously a Klingon
your geeks right you should know you
should recognize at least a Klingon
right he's really really good at meeting
out punishment to the appropriate
parties right so this is sort of my go
to internet meme for anything punishing
that you're having an engaging and
comprehensive multi environment
javascript testing is really really
punishing it's really awful it's getting
better but it's terrible so the question
is why what's what what's wrong first of
all obviously j/s is historically the
you know the thing that's given it so
much strength is that it's closely
connected to the browser but everyone
thinks of javascript testing is or maybe
less so now but traditionally it was
very very tied to the UI and testing the
UI is really brittle and really really
hard to do you have tools like selenium
or windmill that make it a little less
horrible but it's still brittle and it's
always integration testing and there's
always a bunch of environmental stuff
you have to setup to get it to work now
of course we have lots of business logic
API logic stuff living both in the
browser potentially in CERN potentially
then in the server too and then you have
all of this code that's sort of in the
spectrum
between so sometimes it's a little
difficult to tell what method of testing
you should be applying to which pieces
of your code so is this unit testable
code is this something that I have to
actually mock a bunch of stuff out to
test if I mock all this stuff out how
can I be how can I be sure that I'm not
actually just testing my mocks right and
then on top of all of that now getting
the code into the runtime is really
irritating in all these different
environments because it's different so
when I first started working at Yammer
one of the first things I did because I
wanted to test code and all these
environments was I wrote this thing
called Logan that was a test runner and
the code to actually load I think this
is the browser adapter I tried to make
require work essentially as a global
synchronous in include of the code and
it works I mean this works but it's
terrible you just look at that it's
awful and you look at that and you can't
help but think that there's got to be a
better way to do this and unfortunately
there are a bunch of smart people
working on this so the other problem is
getting people to agree on what the
requirements are for testing because
everybody has a different idea about
testing which probably explains why
there's so many testing frameworks so
for us at least the the main
consideration was that it had to be easy
to run without a bunch of extra extra
setup without a bunch of ownerís like
setup and installation of stuff simply
because the more impetus there is the
harder it is to convince people to
actually run the tests regularly right
we also of course because of that wanted
it to be automatable and ideally you'd
like it to be automatable in the browser
if you can that's a that's a nice to
have on it it's it's nice at least to
get it running under something like
Rhino or node but it would it's even
better if you can actually be automating
it in the browsers because if you're not
testing in the actual environments
you're not really testing tests that say
only run under node with continuous
integration or it's good it's better
than nothing but you're still not really
testing your code right so over the last
couple of days there been a couple of
projects that are finished enough for me
to start looking at and start wanting to
do something with Bob
Mieke sitting over there has mostly
finished up Foo Unit it's looking really
promising I've rewritten all the Getti
model tests for the code that we use at
Yammer with Foo Unit Adam Christian had
a great presentation yesterday with
jellyfish which is browser launching and
code injection which is the which is
sort of the other half of the puzzle or
other piece of the puzzle so hopefully
with the two of those it looks like it's
going to be pretty easy to plug in the
Foo unit tests the jellyfish and will
will actually be able to move forward so
this is an example of what a unit test
would look like with Foo Unit and I can
already run it in node and run in the
browser the only thing now is actually
plugging it into a continuous
integration with jellyfish so I'm really
really excited about this because it's
so much better than what we had what
we've been trying to trying to work with
so sort of a wrap up I guess yeah so if
you've been watching what's been going
on since the early 2000s it's pretty
obvious that the JSE genie is out of the
bottle right there's no putting the
toothpaste back in the tube no matter
how much other server-side language
people might prefer it's pretty much
done Jas is everywhere and it's going to
be you're gonna be seeing it in even
more places and even more environments
it's awesome to have this real easy to
use fast powerful server-side JavaScript
it's a joy to work with it's it's I
can't even explain how happy it makes me
to be able to to be able to use that it
makes code reuse really possible so we
have this version of the desktop app
that we're shipping with all the
JavaScript from our our web app and we
add new features to the jet to the to
the web app and we essentially get them
for free in the desktop app as well it's
great the tools are still pretty awful
but if you remember what it was like if
there's anyone here who remembers what
it was like in the early 2000s or even
the late 90s trying to build complicated
JavaScript front ends how awful how
terrible the tools were then I'm looking
at what we have now we're really kind of
spoiled I guess I could
it's like the whole I had to do alerts
in IE uphill both ways and I was
grateful for it or whatever mixing my
metaphors but they are the tools and
testing are getting a lot better and I'm
confident that in all these new
environments it's going to get easier
and easier as well it's good and it's
yeah it's very exciting stuff so if you
want to follow me on Twitter I talked
about this stuff a lot I can point you
to the appropriate developers at Yammer
who are specialists in these different
areas all of this information was
compiled from a bunch of different
people inside VM or not just not just me
we have a brand new developer center
thanks to michael rogers who has joined
Yammer and has been working hard the
past couple months on this it's very
exciting to see that yeah I guess that's
it unless there are questions questions
it's a lot did you remember the baby Oh
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>