<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Dan Callahan: Practical WebAssembly | JSConf Budapest 2017 | Coder Coacher - Coaching Coders</title><meta content="Dan Callahan: Practical WebAssembly | JSConf Budapest 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Dan Callahan: Practical WebAssembly | JSConf Budapest 2017</b></h2><h5 class="post__date">2017-12-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bac0dGQbUto" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you so much
so the title of this talk in the
schedule is practical web assembly
unfortunately since this technology is
only six months nine months old it's
much more reasonable to talk about
possible web assembly because everything
I show you is possible today but the
tooling is still somewhat rough so I
don't want to focus too much on the
specifics of how to to build a web
assembly module but rather give you the
conceptual understanding of what I would
simply can do what it's good at when you
should think about using it versus when
you should stick to JavaScript my name
is Dan Callahan I'm Callahan on Twitter
I work for Mozilla and Mozilla works for
the web and what I mean by that is that
Mozilla is the only major browser vendor
that's a non-profit and we exist and we
create the Firefox family of web
browsers so that we can act as a
counterbalance against the world's three
largest publicly traded for-profit
companies who control the other major
browsers and that we can make sure that
we advocate for the web that respects
human interest public interests that's
based on standards that's interoperable
that's open and by implementing the web
itself we can do that advocacy as a peer
rather than purely from a kind of
theoretical standpoint or ideological
standpoint we make other things to rust
servo pocket we just acquired mdn but
today I'm going to be talking about a
technology that Mozilla's helps create
called web assembly web assembly is a
direct successor to a technology and
experimental technology Mozilla built
called as MJS where we're trying to
build a higher performance lower level
version of javascript and and I only
have 30 minutes and I'm going to go
along and I apologize it's it should
only be by five or ten minutes but if
you want to spend time reading about
whether somebody and really kind of
digesting what this is and how it works
I strongly recommend looking into the
articles and the talks by Lynn Clark you
can find her Twitter as Lynn Clark she's
done Illustrated introductions to web
assembly to shared array buffer she give
a talk on what web assembly means for
react all these are phenomenal resources
she's an excellent engineer and even
better educator
check out her work so what is
webassembly at its core whether somebody
is a compiler target for programs on the
web and we'll get into what that means
in a second but but what this is useful
for is it opens up new avenues of
portability and performance both in the
browser and in server-side runtimes like
node when we talk about portability
we're typically referring to source
level portability so you write a program
in portable C and you can compile it to
Windows or to Mac or to Linux without
having to change your code and that's
really great because we can do things
like did you this terminal hang on
that's a binary I don't want to edit
that like this program which I found I
don't I don't know C and I don't know if
in GL but I found this 12-year old file
it's it's open source and it sets up a
3d cube it makes it rotate and it's all
colorful it's about 100 lines of code
and if I compile that that's legible
pass up the source code say spit out a
binary I get a fifth power 14 kilobyte
file that's a Macchio 64-bit executable
and so I can take this this binary I can
give it to anyone else that has a Mac
and it'll run and it'll show you a
little spinning cube and that's exciting
to me because my educational background
is in geology and so all of this is just
a wizardry like I do I understand the
rocks that go into the silicon on the
chip I don't understand the computer
itself but it made us spinning cube and
that was neat and I can recompile that
and I can run it on Linux and I can
recompile it and I can run it on Windows
and you don't have to have a C compiler
installed you just you can take this
binary and just run it but the platform
I care about is the web and and up until
recently I couldn't take this code and
put it on the web I'd have to redevelop
it I'd have to re-implement it well the
simply fixes that so if I say make wasm
I'm going to use a different compiler
and scriptum instead of playing
pass it the same source file and this
time I'm going to tell it to spit out
kind of an HTML shim if they look at
that I have a 15 kilobyte webassembly
binary if I look inside that I mean this
is just absolute gobbledygook and we're
gonna feed that to the browser and good
things are gonna happen which is not
usually what happens with things that
look like that build HTML same exact
program no changes to my source and now
I can run it in the browser and it's not
just in Firefox this is a technology
that also works in browsers like Safari
and in Chrome and an edge and because
it's it's a it's for the web it doesn't
matter that I'm on Windows or a Mac or
on Linux the same webassembly file can
go anywhere talk a little bit about that
later but the important thing is that I
now have a compiler which lets me take
existing code and run it on the web and
so game engines have started
implementing export to web assembly so
this is a unity demo that and drive
around in and I can win because I have
web assembly and I didn't need any
plugins I didn't need any any downloads
or any native binaries I can just go to
URL and play a game and it runs about
native speed thank you for the AV people
for turning that down I'm sorry I didn't
do that for you so those the Unreal
Engine and some people complained or the
the Unity engine some people complain
that it's not a real engine because it's
started as a browser plug-in and this
and that so the Unreal Engine has also
added support for web assembly where
just like you can export from these
engines to Windows or to Mac OS or to
Xbox or to PlayStation you can now also
export to the web and again I can just
visit URL and it takes a minute to
launch because it's a modern game engine
but this is the full Unreal Engine
rendering in real time in my browser
with
any plugins without any modifications
and if I you know click the cell
interactive so once the camera finishes
panning zoom in on the fishpond and
probably swarming algorithm will kind of
follow my cursor and all this again
these are experiences that the web
previously hadn't hadn't been capable of
just this level of performance in the
fidelity and not having to invent it
twice once for the web and once for
desktop we can now just do it once and
export for the web so I think that's
pretty cool
I talked about compiling for Windows or
Mac or Linux and and how that meant
source level portability but not binary
level portability but it's more complex
than that because you're not just
compiling for Windows or Linux you're
compiling for a specific CPU
architecture on one of these operating
systems so you might be compiling for
32-bit windows and Intel 32-bit Linux
and you might also compile for armed on
Linux which is the the CPU architecture
on your phone it's what's in a Raspberry
Pi and so if I want to support all these
platforms I can but I have to recompile
dozens of times to cover every possible
CPU that exists now or might exist in
the future let's talk about sass CSS
conference yesterday who here likes and
loves and uses sass half the hands there
should be more it's great absolutely
great library it it's a preprocessor for
CSS that lets you write shorthand and
and more humanely manage a lot of your
style sheets the problem was it was
written in Ruby and Ruby is a great
language like JavaScript but it's a
dynamic language it's a high-level
language it requires its own runtime I
can't just send somebody sass dot exe
and have them run it they also need to
install Ruby and if I'm writing a
JavaScript program and I want to use
sass well now I have to manage a program
written in JavaScript I'm program
written in Ruby and it just it gets
complicated so some people rewrote sass
they were implemented as libsass in C
and C++ because these lower-level
languages don't make as many assumptions
about where and how they'll be running
in this case you can compile Assaf saath
exe and pass it around and it'll work
and because it's written in this the
level language it's easier to call it
from other languages so there are
bindings from Java to sass from
JavaScript to sass from Lua to sass from
Python to Ruby etc and I want to look at
the node version node sass great project
tries to create this conceptual model
where you have a JavaScript API but at
the core is libsass C and you don't have
to know that because you're just
interacting with the JavaScript layer
but they didn't have to rewrite sass in
JavaScript they could just reuse that c
version
the problem is sass is only libsass and
only portable at the source level so if
you go to the github release page for
notes fast they've got this matrix of
operating systems CPU architectures and
node versions and for every release of
libsass they have to build a separate
copy of that library for each of these
these platforms and each one's a couple
megabytes and it just goes on and on and
on so every release is hundreds of
megabytes binaries and you can't put
that in your npm module nobody would npm
install that so we knew npm install node
sass it goes out to the web and tries to
fetch the right binding for you the
trick is something really important's
missing they don't build for arm
I knit libsass builds on arm but they
don't provide the binary and so if I'm
trying to install this on a Raspberry Pi
I also need to install a C compiler I
also need to install a bunch of headers
and there's a pre-installed hook that
tries to compile it for me and that's
kind of a pain in the button that's not
that's not what I love about jobs here
boy I love about JavaScript is it's
universal and it works everywhere and so
what they were trying to create was was
that experience of one library shared
core across multiple languages etc but
what actually happens is you have 70
different compiled binaries depending on
what platform you're looking for and
like I said that doesn't cover
everything who knows what the next
version of node will do in terms of ABI
changes who knows what the next CPU
architecture that becomes popular will
be I don't think anyone predicted the
rise of arm over Intel ten years ago so
we've got this combinatoric explosion
source level compatibility is great
but you have to compile a lot of times
what webassembly does is it introduces
another architecture a virtual
architecture and I know what some of you
are thinking because you've told me this
as I was rehearsing your think about
this xkcd about I know will create
another standard and now we have another
standard instead of one standard to rule
them all
the reason this is difference is
different is because webassembly isn't a
physical processor specification it's
not a real architecture it's a virtual
architecture and the the basic
instruction set and web assembly is
designed to be kind of the the least
common denominator all the commonalities
of the popular real world silicon CPUs
that are out there so we take things
that are common to x86 - arm - MIPS and
we've kind of abstracted that out which
means it's really easy to go from web
assembly to any of those other
instruction sets just like you might
think about a you know a flash movie or
a Java jar we have a bytecode that the
end computer is responsible for
translating down to whatever the
physical hardware is but it's low-level
so that it's a very quick and efficient
translation webassembly is supported by
default in node 8 which means for for
libsass for node SAS instead of shipping
these eight different binaries for node
eight and then eight more for node nine
then eight more for node ten they really
could replace that with a single libsass
tile Azzam maintain the same javascript
api your code has no no need to know
that the implementation is in something
anything other than JavaScript but now
they could shift X would be a single
file and it worked everywhere and it
works wherever no it goes because it's
implemented on top of that VM it's
implemented kind of on top of the the
JavaScript runtime I think someone
should do this I want to do that but
then I got busy so I'm starting to put
in my talks and hopes that someone else
will do it
file a bug show someone the recording
this this potential to start taking
these native libraries and bringing them
to the server side in an easy way you
don't have to worry about
you don't have to worry about compiler
tool chains I think holds a lot of
promise because it means that all of a
sudden the the whole web ecosystem not
just on the server side not just know
but also the browser has access to this
universe of of new libraries and when I
say sit it's an open standard I say well
this simply is an open standard
supported by all major browsers I mean
it as of this month even edge is
shipping whether simply on by default in
their current release Safari on iOS if
shipping love is simply on by default in
their current release this is real it's
here it only appeared in March and yet
we now have cross browser adoption in
every major platform the web is not used
to moving this fast and and that's why
I'm giving this talk today is to
hopefully inspire you and make you aware
of this new capability that exists so we
have a new universe of portable
libraries there's no need to
re-implement Sasuke s to bring it to the
browser we can just recompile the C++
and that's that's cool but how does it
do it what is web assembly doing what
makes it fast what makes it useful the
key to all this is that web assembly in
contrast to JavaScript Java scripts a
very high level text based format it's
meant to be read and edited and used by
humans and written by humans
well of assembly is a low-level binary
format it's you're not intended to write
whether assembly by hand instead you're
supposed to write in a language a
low-level language like C or C++ or rust
and compile that to web assembly so
let's do some of that and see if the
network holds up so if I go to also
tabby cat the best extension randomly
generated cats so have a little tool
called the lazarum explorer which lets
you kind of type in C they make this a
little more visible for people and it
will compile it to web assembly in in
the browser we're not actually shipping
the compiler to the browser though
that's possible but it'll post your C to
a back-end that will compile it and
it'll give you either simply back so I'm
gonna write a c function called foo that
takes an int X and returns X divided by
4
and when I compiled that I get the
webassembly representation this is this
is a text form and for reading but the
actual web assembly itself is in binary
and then this column over here on the
right is the native code so you give the
browser the middle column and say here's
this intermediate virtual instruction
set this virtual program please compile
it that last mile - to the native
silicon on this computer as a developer
this is kind of like minification
uglification you'll never actually deal
with these day-to-day but it's
interesting to know that they're there
and see what what they're doing you'll
Smoove us your time in the in the
high-level language on the left so
whether somebody's a stack-based
language it also has static imports and
exports and it's strongly typed so in
here we can see we have a function foo
that takes a parameter that's a 32-bit
end and it returns a result that's also
a 32-bit end and the way it works is it
gets that first parameter it gets X puts
it on the stack it gets four puts that
on the stack and then calls divided
underscore s which is a signed integer
division so it pops those off divides
them puts the result back on the stack
and you're done the interesting thing
about about getting to here from a lower
level languages we can add more type
information Java Script is a really
dynamic language and so when you're
running JavaScript if you employed the
same function in JavaScript your browser
wouldn't know going in is this an
integer or is it a floating-point number
or is it a string I don't I don't know
and I'd have to check and I'd have to do
a lot of profiling and and the browsers
JIT compiler kind of guesses at these
optimizations and then every time you
call the function it tries to validate
was i right about this optimization know
all right throw it out profile it again
but if we have this type information
upfront for instance if we say these are
unsigned integers they're always going
to be positive then instead of a divided
by four I shift right by two because for
positive integer if you move all the
bits over by two places that's the same
as dividing by two each each place you
move so if you move twice it's dividing
by four and this is a much more
efficient operation a much simpler
operation for your CPU to implement
so that's cool let's go ahead and
download that just for kicks you can
also look at this if I change this to a
floating-point number you'll see it
instead of a 32s we're now dealing with
64-bit floating-point numbers f/64 x'
and we're multiplying X by 0.25 what
assembly only knows about numbers it's a
really low-level language you've got 32
and 64-bit floats and ents and that's it
whether somebody doesn't know about
strings it doesn't know about objects it
doesn't really know about arrays but if
you're doing computation this actually
you don't need those things and you can
can have this really thin layer between
the web assembly world in the JavaScript
world and the way I do that over my
browser if I say if I say fetch test
azzam and then that's going to return
that visible here I'll move it a little
little higher on the screen there we go
so I do that and then I get a result and
I'll turn that result into an array
buffer and then with that buffer I'm
going to call web assembly dot
instantiate buffer so all I'm doing is
I'm going in downloading this binary
file turn you into a byte array and
passing that byte array to the web
assembly instantiate function it gives
me a promise that eventually gets
fulfilled into an object with two
properties the web assembly instance in
a web assembly module the instance is
this is the running copy of the code the
module is this right side so the module
is kind of here's your compiled
executable the instances
here's that but it's running it has
memory it has state it's kind of the
difference between an exe and something
in your process manager let's go ahead
and pop this instance out into a global
variable so we can get it more easily it
has a property on it called exports and
on that as our function foo and so if I
call foo of 64 I get back 16 and that's
that's the C we wrote over here running
in the browser
and if I go and look at this this is the
binary that we sent to the browser it's
tiny it doesn't know anything there's no
JavaScript here and yet we're able to
call that function as though a were a
JavaScript function and we're able to
pass it data and it's able to return
information completely transparently you
don't have to know and you wouldn't know
unless I told you that the
implementation of foo was in a language
other than JavaScript which is cool cuz
it gives you that ability to take that
common core that common library wrap it
in the JavaScript API and now you can
reuse the core you get some more
performance out of it those those
performance things like doing the you
know the unsigned integer again your
your browser may eventually arrive at
that if you wrote it in JavaScript but
with web assembly you can compile that
in up front and hand the browser
optimize code at the start this is
really useful if you have something
that's CPU bound or something that's
really performance intensive because you
have complete manual control over how
you use memory and that's really
important for game engines for audio
codecs video codecs things where it's
much better for instance it's better if
a game engine runs at a steady 30 frames
a second but if it's sways between you
know five frames a second sometimes and
120 other times because as humans we
perceive the differences and we see that
stuttering and it becomes really
uncomfortable but there's no way around
it because JavaScript such a high level
language you can't opt out of garbage
collection you can't opt out of how
javascript represents things in memory
you don't have that low level control
you do with web assembly it's an
interesting example of this there's a
program called web or a library called
web DSP that implemented a whole bunch
of different video filters identically
in JavaScript and in C++ and they just
do a feature detection query does web
assembly exist in browser okay use the
web assembly version otherwise use the
JavaScript version and in most cases
javascript is fast enough but if you're
doing a lot of computation on each frame
like trying to do edge to
detection it's pretty Jinky we're taking
about 250 milliseconds every frame so
we're getting four frames a second but
if I switch over to the webassembly
version because it's able to reuse
memory it's able to control exactly how
memory is allocated and freed we're
running a steady 60 frames a second
again you may not need this in many
areas but if you have a performance
bottleneck in your JavaScript
application you now finally have the
opportunity to drop down to a lower
level language to address that does that
make sense to people I can see some
nodding some nodding all right things
could go fast now but why do we need it
we need it because plugins were the only
way you could do this before and they
were dying because plugins were an awful
security situation and they didn't have
a replacement and we couldn't just say
compile everything to JavaScript because
JavaScript was hostile to certain types
of optimizations javascript is is a
really lovely language it's a very
expressive language but that extra civet
e in that dynamism in it makes it hard
to run quickly it makes it hard to
compile ahead of time and that meant
that we couldn't effectively reuse
existing code on the web so things like
Adobe's PDF Reader I don't know how many
human years have been invested into that
that engine it doesn't make sense to
rebuild it for the web it makes sense to
take that code and bring it to the web
in a way that like Java Script is safe
and Universal but that runs as quickly
as native code and that provides
consistent predictable performance so
those those were our goals were
webassembly and trying to do this in a
way that allowed code reuse between the
web and native platforms and we did it
it worked and so so if you're interested
in this anyhow performance problems or
or you want to reuse code between two
libraries or you want portability
between platforms
you may not have there may not be a
libsass that you can import but you may
want to code the core logic of your app
in in a language like rust and compile
that to web assembly and also compile it
to other languages or to run on other
platforms and now you can share that
common core between the front-end in the
backend and native and web and that's
really exciting and we're starting to
see this technology be picked up by game
engines Mozilla is using both assembly
prototype a new browser our new codec
for videos in the browser so we can
actually ship the the video decoder as a
wasm file and render it out to a canvas
and it works
AutoCAD can run the browser now through
web assembly all sorts of crazy things
and it's it's possible because we've
designed web assembly as a
general-purpose virtual architecture
there's despite the name web there's
nothing specifically webby about it what
we did is we we looked at the way
JavaScript engines are currently
constructed in there they're really
complex virtual machines where you've
got a JavaScript engine v8 or or spider
monkey that comes with a garbage
collector it comes with a JIT compiler
it comes with all these these capability
that kind of is a virtual architecture
unto itself and the way it interacts
with the outside world or through API is
so the browser provides things like
WebGL WebRTC and X DB node provides
things like sockets and and file system
access but we had this really good VM
and had the JIT compiler and had the
profilers and it had the optimizers but
javascript is really hard language to
work with and the the whole purpose of
something like v8 or spider monkey is to
take JavaScript and try to get it as
close to native code as possible and
then for things that are constantly and
frequently called to compile just those
bits into native code and so with
weather symbol we can actually just put
it right alongside JavaScript and say
well hey you're trying to get to this
point anyways we've done it for you we
did it ahead of time I compile it on my
laptop it's already optimized just run
this and it works because we can reuse
the existing architecture this also
means that web assembly is running with
the same sort of security properties as
any other JavaScript running in the
browser or on node where you don't have
access to raw sockets you don't have
access to to things that the web
platform doesn't give you access to and
and that's okay because web platform is
capable and because this also minimizes
the attack surface you don't have to
worry about like when I go to a random
web site I trust my browser to prevent
the code running on that site from
deleting all the files on my hard drive
I don't have that same trust if I
download a random binary from somewhere
and run that but webassembly kind of
splits the difference you get a binary
but it runs in the browser sandbox it's
fast it's safe
so so what is all this
at its core web assembly is a compiler
target for the web
it's a low-level binary format for
programs built on an open standard with
cross browser support it's a direct
successor of Mozilla's experience with
Azam's yes and it's a general-purpose
virtual architecture so much like node
took a JavaScript engine and took away
the browser layer and just said well we
can take this engine when you put some
different api's on it and that's great
well obviously works in both node in the
browser and someone could conceivably
build another runtime that's derived
from neither of those that's tailored
just to web assembly it's truly a
general-purpose virtual architecture to
target programs ad and this is
interesting because well it doesn't
replace JavaScript like not everyone is
going to go and write C++ today because
they saw this in the same way that node
actually exists despite the option to
write C++ on the server different tools
are good for different different tasks
but this expands what the web can do
because previously the web only allowed
you to to act at the high level and now
we can have these hybrid designs where
the core logic the core functionality
might be in a lower level language like
web assembly but the application logic
might live in JavaScript it means that
for compilers the web is just another
platform it's here today it really works
and it's got a bright future we're
working on adding things like
multi-threading garbage collection
better tooling sem d support many other
things to webassembly over the next next
few years I think the ability for us to
go from zero browsers supporting it to
all browsers supporting it within the
space of a year is really encouraging
and I think I think speaks to the fact
that this will continue to evolve and
you'll be able to use the things that
come out in the future a couple of
questions that people have asked me that
I want to want to cover before I close
people here about this like I can
finally stop using javascript or is
JavaScript dead and no Java scripts
alive but it's client-side monopoly is
dead the the notion that you can only
use javascript in the browser is no
longer true you can use
any language that you can compile but
these complement each other well this
simply is low-level it's binary
javascript is high level in its textual
there's a place for both makes new
things possible what about older
browsers well I said that web assembly
started as a direct successor to as MJS
as MJS is just JavaScript but with some
weird little annotations that let
certain engines edge Firefox etc run it
faster but it still is JavaScript so it
does work everywhere and so you can use
it as a fallback the most common
compiler chain right now they use dim
script them take C or C++ or rust
compile it to as MJS and then compiles
the azzam js2 web assembly you can just
save them and you know inscription does
the first step in re n does the second
step we're working on adding native
support to web for web assembly to LLVM
should be coming soon ish but for now
you can just save the as MJS and the web
assembly and say well do you support web
symbol use that if not use azzam j/s
it'll still work it just won't be as
fast other people ask well web
assemblies so fast can I compile my
JavaScript for my typescript - what
assembly no don't do that just like if
you wrote a program in JavaScript or a
program in Ruby or a program in Python
you have to distribute the runtime with
it compared to a program in C where you
can just send the binary around you'd
have to ship your own JavaScript runtime
you'd have to ship your own equivalent
to v8 or spider monkey if you did this
cuz well as immed uhz n't know anything
about java javascript it doesn't know
anything about modules or arrays or
objects and your browser already has a
really good runtime for javascript it
knows all the dirty tricks so so trying
to re-implement that isn't going to get
you very far but what web assembly is
good at is different from what java
scripts good at other people ask what
about type errors so web this simply has
the the well defined by 32 I 64 F 32 f
64 types well I can JavaScript the
browser courses types at that boundary
and a compile time you can check to make
sure there are no tight mismatches
within web assembly Eckler script has
really well-defined rules for what
if you passed the wrong type to a
function that is expecting something
else so in the same way that you're not
worried about like calling the square
root of hello world crashing your
browser it's not gonna crash a web
assembly program either that string is
going to get turned into a number that's
gonna be passed to a function if it
wants a number it works there are rules
you can learn them it's fine
but I've been talked about about these
interesting hybrid applications a lot of
a lot of the initial work in web
assembly has gone into trying to take
desktop apps game engines import them to
the web and they can just render on a
canvas you don't have to really care
about anything in terms of I guess web
enos it's kind of like flash it's not
accessible it's not indexable but it
works and you can play it the web's
getting more capable and some really
interesting things are happening so so
something I saw that is webby in a
different way this may take a minute to
boot some folks built DOSBox
which is a window or which is a 16-bit
Intel emulator runs Doss they ported
that to web assembly they got it to
render to a canvas they're using that
canvas as a texture inside a webview our
environment so while this boots you know
I can look around and it's actually
fully multi-user so that that little
smartphone you see flying there is
another tab I have open in case the
internet didn't work so this is gonna
finish loading and let's see so it's
gonna try to make a dial-up connection
do to do come on windsock so we'll mute
that but so so the person that built
this demo has this talking over a
WebSocket emulating tcp/ip so you can
actually get to the outside world but
for now I can do things like I can run
solitaire and I can
to do paintbrush and this is running on
a Windows emulator on a 16-bit Intel
emulator in my browser so we all
compiled web assembly so it works
anywhere like my computer is Intel based
but it also works on my phone which is a
completely different architecture which
which gives you that magic that the web
is supposed to work everywhere and you
know this works I can say hello
Jas comp Budapest and yeah go spray
paint tool give it some some sparkles
yay but we can we can preserve some of
our digital Heritage's this way which i
think is also really really fascinating
but you can take all these existing
programs and all this existing software
and you can bring it to the web and it's
not locked into a platform specific
binary anymore if you can bring the
platform itself to the web and so I look
at this and I think about the potential
here it takes way too long to load you
can also load Netscape which is kind of
ironic running Netscape inside Firefox
it'll take a minute but
but I look at this and I think about the
potential that we have in terms of we in
the web community in the JavaScript
community learning from and leveraging
all of the software and all the
knowledge that's out there in the C and
C++ worlds and then creating new things
with them and teaching them about the
web and creating these hybrid
experiences that leverage the strengths
of both platforms there's a great
initiative right now on the rust foreign
language to make web assembly one of
rusts primary tier one platforms so that
if you want to build for the web you
build in rust and compile it to web
assembly and I think that'll be again a
really positive development if we can
can manage to come together and bridge
these these two communities because we
know things that they don't I mean the
Unity engine knows a little bit about
the web the Unreal Engine they're used
to being able to come on DVDs or come on
like massive Steam downloads or a
multi-gigabyte you can't do that on the
web you have to be able to stream your
assets you have to be a smaller smaller
package and we can teach them how to do
that obviously home DM kaam kaam is not
going to load and also anything over SSL
is not going to work because we don't
support TLS 1.1 Netscape 3 but you get
the idea right
brand-new things are possible web
assembly is here it's real please come
talk to me please experiment this keep
your eyes out the web is it's just
amazing today thank you so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>