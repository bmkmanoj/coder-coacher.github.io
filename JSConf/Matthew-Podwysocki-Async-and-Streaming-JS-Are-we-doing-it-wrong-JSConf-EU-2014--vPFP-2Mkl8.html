<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Matthew Podwysocki: Async and Streaming JS - Are we doing it wrong? | JSConf EU 2014 | Coder Coacher - Coaching Coders</title><meta content="Matthew Podwysocki: Async and Streaming JS - Are we doing it wrong? | JSConf EU 2014 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Matthew Podwysocki: Async and Streaming JS - Are we doing it wrong? | JSConf EU 2014</b></h2><h5 class="post__date">2014-12-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-vPFP-2Mkl8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">know everyone and welcome to my talk on
acing dive and streaming JavaScript are
we doing it wrong
of course the answer is always going to
be yes else why am i standing on stage
here and what what better picture than
to show John McCarthy telling us we are
exactly doing programming wrong so
before I get started I actually want to
thank the organizers very much because I
of course this is my first time speaking
here but I've been coming here since
2010 and without a a conference such as
this things like node no DJ house on
Windows might not have happened or it
might not have happened as quickly as it
did so it's with this very conference
that really really is amazing stuff to
me so what I'm talking about a sinker or
a sinker or event based program I think
of myself well I thought I had a problem
so I know I'll solve with callbacks and
events now have now problems too I yeah
hmm crap yeah concurrency bugs I've been
bugging me since I've started doing
JavaScript and what this talk will not
be is it will not be a monad tutorial
there will be no mentions of category
theory it doesn't require to you to know
much about functional programming to
really get started to learning new
abstractions for for asynchronous
programming so no they're not like
burritos and no there are not like any
other silly metaphor that you can think
of to describe monads so Who am I I am a
software engineer and self-described
open-source
you can find me on the on Twitter and
and github pretty much using the same
same tag I'm fairly unoriginal that way
and I work for this the small startup
out of the Seattle Washington area I
don't know if you've heard of them but
they're called by Microsoft and I like
to think of myself as putting a little
bit of metal back in Microsoft Adam
routes to anything automatically turns
it into metal so I work on a project
called the reactive extensions and I've
been working on this since 2010 the idea
behind the reactive extensions is really
to to to create a nice program
programming language agnostic way of
dealing with asynchronous programming
and yes I'm Matthew Potter sake and rx
pusher
now really what I want you to get
through first is that I want some some
quotes that'll help us in our learnings
today the first one is to be conscious
that you are ignorant is a great step
towards knowledge the next one is
ignorant never settles the question and
the third one is the best way to be
acquainted with a subject is to write a
book about it or in my case get up here
and give a talk about it and this was
given by the the Prime Minister of the
UK back in the 19th century so let's
just face it asynchronous programming as
we know it today is annoying because by
themselves you have every library and
every certain thing doing its own thing
whether it's call backs and promise
promises doing one thing where it's
yielding a single value versus events
where there's dealing with multiple
values so each concept is covering its
own little piece of the story not the
whole piece so just to kind of give you
an example here I you certainly wouldn't
call a promise on a on an event that you
expect from more than one of just as you
wouldn't do you wouldn't
we need a collection to describe a
single value but even more than that how
about if I want to make a web request
and then combine combined that with
getting the key the key press events so
that I can send my data over to that and
then we need to make sure that we're not
overloading the server how do we think
about that when we're just talked about
promises callbacks timers etc how do we
deal with that is there a better way
that we can think about asynchronous and
event based programming well we had a
very forward thinking presidents in the
United States who in the early 60s came
to this very city and said ich bin ein
Berliner but what he also said is we
choose to solve asynchronous / of
programming and do other things not
because they are easy but because they
are hard
citation needed daemons Wikipedia so
callback hell is very much a real thing
so when you're dealing with callback
hell you've you've got nested function
after nested function where you're
trying to accomplish something linearly
so for example here I might want to to
play a movie what that Inc what that
entails is making sure that the players
initialized that I'm authorized to do so
and then when I'm then when I'm done
done it authorizes me with a movie
tickets and what you end up with is a
cow's head all your code code all it
looks like is just a cow's head at that
point somewhere the logic gets lost and
it's evil so I don't know about you but
whenever I write code like that this
usually happens and it's it's not easy
to recover from those from getting
burned like that and just as well event
based programming is just as annoying
say for example we want to create a drag
event a custom kind of event that we we
do on our own
so what we would need for that is we
would need to say whether the mouse is
down or not and have some state as to
where where the mouse is then in the
mouse down we would have to say okay
Mouse is down here so here's where we
started mouse move we go okay
Mouse is down let's do some calculations
and on the mouse up we say everything's
done we're good to go and then we have
to of course not only add the event
listeners but we also have to remove
them as well
and that gets pretty darn annoying and
so when you're dealing with that much
states once again you're juggling and
you just can't hold it especially when
you're true when you're just trying to
do something else add something new to
your program that's what you end up with
so let's talk a little bit about the
asynchronous programming landscape as it
were so we have well the programming
landscape in general we'll have two
accesses one to describe synchronous and
want to describe asynchronous behavior
and one one part to say whether it's a
single value and one to say that it's
multiple so for example when you're
dealing with a value that's what you get
you call a function or you assign it a
value that's a value good an iterable is
a collection so in JavaScript we have
arrays we have maps sets arguments
anything that's iterable here and then
we can apply higher-order operations
such as map filter and for each on them
but what about asynchronous single
values of course we have callbacks but
we also have promises now promises are
very interesting and the fact that now
instead of this callback function what
you have is you have a first-class
object that you can pass around the
people that describes what that value
eventually will be and that's not
something you can necessarily do with a
callback I can't hand you a call back
and say now this or this represents a
value doesn't work that way and then
what I'll put in the fourth quadrant and
final quadrant
is observable now observable as you will
see is asynchronous in its in its very
nature so you can take the same stock
stock data you can filter it you can map
it and you could for each it no code
changed at all in terms of what you're
coding on the clients nothing none
whatsoever
and that's very very intentional about
what we're what we've done with the
observable design so if you know how to
program against collections then you
know how to program against observables
what I like to say a lot of the times is
that your mouse is also a database so
it's a database of coordinates that you
will get eventually when the mouse moves
therefore it should be as queryable as
an iterable sequence is so the thing
that I like about these abstractions is
that they're first class and then what
they means by first class is the fact
that I can pass one of these objects
whether it's an observable or it's or
it's a promise to to a function and I
can also return it from a function and
so what that gives us it gives us a lot
of flexibility when it comes to to
querying something or for testing for
mocking whatever else it is it's really
nice for for us to do that now promises
I'm sure you've heard a lot about I hear
already I've seen it mentioned in a good
number of talks already now promises are
great because they're pretty much in
every single library that's that are out
there nowadays and they have pretty much
the same behavior outside of jQuery I
which you have is you have very uniform
behavior so you can think about them all
pretty much the same handlers done
asynchronously and once it's done it's
done you're good
everyone gets the same answer so we can
take the previous thing that we talked
about the the callback hell and all and
distill it down to the player initialize
authorizing the movie or for handling
the login error playing the movie or
saying your unauthorized boom no more
any of these
to finish and detecting whether this
state is available or not but there are
some problems I have at least when that
when it comes to promises promises don't
solve everything so for example
cancellation is not a part of the
contract for promises in es6 why well
they're in a good number of reasons is
because you want most people to fall
into the happy path and be pretty
productive but it's very much the case
when you deal with a lot of things such
as such as dealing with i/o where
cancellation is a normal part of what
you do and what about situations like an
autocomplete where you just don't care
about the value that comes back so in
this particular case here are my how do
I cancel that again I don't I don't not
really interested in this anymore
so do I create a cancellation promise
and I subclass the regular promise do I
pass in a cancellation token do i or do
I just use a library like last from
Dominic de Nicola any of those are
perfectly valid valid options now when I
talk about reactive programming so
reactive programming is a very kind of
fuzzy definition just like functional
programming is everyone says well
functional programming application of
functions not helpful so what we're
trying to do is trying to figure out
what exactly we could call reactive
programming so the dictionary says
readily response to the stimulus I'm
like well isn't that just normal
programming what else is interesting
about it well reacting to events is
certainly one thing that that reactive
applications do but they also react to
loads so the fact is that you can spin
up more instances to handle data you can
determine whether you need to drop data
and so forth you can react to failure so
if at any point that you need to to to
handle some errors and return it from
cache you can certainly do that
to me most importantly is reacting to to
your user the last thing you want to do
is have your your JavaScript page be
unresponsive to a particular user and
what I'd like to say is it is you know
the reactive extension stuff that I've
done has played a little bit of the role
but you know there are there are a lot
of there's a lot of hype obviously
around there with Gartner and so forth
in reactive programming but when I'm
talking about reactive programming here
I'm just talking about observables so
why don't we actually take the previous
example of that mouse mouse drag and
kind of turn it in inside out and turned
it into an observable solution what
would it look like well if we had this
first class object of the mouse down we
can take that and combine and start to
do a calculation so flatmap will
basically it will take a sequence and it
will flatten it into into a single value
or a single stream of values rather then
we can calculate the offset of where we
started
for every mouse down now we can start to
take the mouse moves by once again using
functional programming things that we
already know with using arrays and the
array extras we can say take the mouse
move which is also another first-class
object map it so we can decide to give
the left on the top so the total
differential between the two okay pretty
good so the problem is we'll be going
along like this and then forever it'll
keep on going because it never responds
to it to the mouse up well we can fix
that by saying take until Mouse up so
mouse up once again a first-class object
we can say whenever this fires stop the
sequence we're done and it even holds a
little bit more promise suffice it to
say when you're dealing with promises so
what if we want to take some some input
for our as it were take the inputs value
and then we're going to to call make a
dig an autocomplete scenario here so
what we want to do is we don't want to
overload the serve
because caught our bandwidth is time and
money quite honestly so what do we need
to do to fix that well we have things
such as throttle throttle or debounce as
most people know it where where you can
type type type type stop for half a
second and then suddenly it'll fire
excellent so if when we're thinking
about observables we're thinking about
once again back to that axis there we
have the observable and we have the
observable and we have the notion of a
synchronous or time-based then we can
get the value make sure it's distinct so
it hasn't changed and then what we can
do is we can call a service which might
be a promise only getting the last one
so the one of the biggest problems with
asynchronous programming is is what is
that you are dealing with with the fact
that you could get out of order
responses and this fixes that so and
then you'd bind that to the UI and
you're good to go
and even more complex things and I'm not
going to even bother explaining all of
this but even more complex things such
as pulling for row updates yeah that's
that's pretty complicated but rx handles
it just fine what we need to know is
everything's a stream good it's a very
zen-like moment you're like yes I got
this this is not to be confused with FRP
so FRP is is a notion of continuous time
behaviors are our objects with a
continuous piece of data time and a
continuous value whereas events are
different events only have values when
they fire and most of those that what it
is not it is not just any old library
that has map filter and reduce on
observables and so most FRP libraries
aren't so what about generators so I'm
sure that a lot of people have seen what
generators can do and so yield suspends
the function and resumes when you
actually get the value back and a number
of libraries already support this
well the library that I work on does it
as well as well as kyouko and a number
of those things so once again you can
say retry three times here and you still
get the benefit of observables but yet
you get a very Linear's imperative style
CSP yeah I'm okay on I it's interesting
but a lot of people seem to love core
dot async and they seem to think that
it's a good win like I said I'm not all
that amused by it because it makes air
handling very manual that makes resource
management very manual not a family
async/await also is is very worthwhile
in terms of discovering what's new in in
JavaScript so what we have is we have
async await which has has been approved
for es 7 at least the first stage so
what we can do is we can now take some
some animations and we can start to
await each one as it comes through
that's pretty powerful so it makes it
explicit that we're dealing with an
asynchronous function so we don't have
to deal with this function star and
yield stuff it makes it very very
obvious now let's quickly talk about
stream processing now when you're in
node I don't know how many people dealt
with streams one but let's face it
they're awful the pause didn't data just
started immediately
you can't consume a number of bytes you
did everything just got shoved at you
and pause and resume or just impossible
you know it was basically this
so then we catch streams too which
landed in in 0-9 and then eventually in
the stable of 0 10 and then supported
object mode now and everything was good
then we also got readable writable
classes and so forth duplex and pass
throughs and then streams 33 and a third
whenever they decide to to land in an 12
E 0 12 I'm sure that'll laughs that'll
solve everything - but cork uncork
pretty cool stuff in terms of being able
to to deal with maps data rights but
still to me I it's too complicated so
the what wygor W what WG streams what
they're trying to do is trying to
standardize a lot of this for the
low-level api's for what what's going
into into the browsers so Dominic who is
here he he is working in that and right
now it's currently focused on low-level
IO and its unicast in nature meaning
only one one person reads one person
writes etc it's interesting but could we
could we take and generalize what he's
trying to do what we're trying to do
here into a more general kind of thing
where we're talking about like
observables and the answer is yes and
the and the the answer unfortunately is
darts dart is doing those kinds of
things where asynchronous programming
they do with futures and streams
automatically so futures great streams
unify IO and events together so
literally your open read and you're out
you're on click same thing you can use
the same API throughout all of them now
reactive streams is a is an effort
that's going on because a lot of people
in the observable world say well you
can't do back pressure can you
I mean cuz come on you deal with with a
lot of people handling your data we
can't possibly we can't possibly have to
know how to deal with this you know a
node and others have it very easy where
you have one one coming in one going out
that if you kind of crimp the hose
that's fine no but no big deal
but when you're dealing with a multicast
situation it kind of is a big deal so
with observables we actually do have
notions of back pressure they could be
lossy for example I could be possible
sampling them throttling them whatever
they can be lossless so I can buffer
them possible buffered so pause and
resume or control so for example here I
can take my chatty observable possible
buffer it then pause and resume and I
anything that happened in between those
pause and resumes I still get and just
as while we're building it into the very
core part so each subscription will then
be able to say I want to request n
number of items so once again back
pressure is something that we have
definitely under our belt now where do
we go from here I think there's actually
a lot of places that we can go because
because of the fact that async/await all
these other things are kind of pushing
the envelope I and that's a really cool
thing but what if we could go even
further
so in es7 Jafar Husain who is a member
of the tc39 ECMO script standardization
committee has proposed I a sync async
generators in which we could take that
very same Mouse drag and put it into the
for on kind of syntax so you could say
let mouse down on element Mouse downs
which is once again that first class
object document dot mouse moves once
again first class object tot take until
document Mouse ups yield the mouse move
good so that to me is very very
interesting and I think there are a lot
of places that we can go with with these
kinds of approaches so I will be
upstairs if anyone has any questions or
if anyone wants an Rx sticker come find
me
I want to thank you very much for your
time
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>