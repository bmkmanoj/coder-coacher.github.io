<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Kassandra Perch: Modular Application Architectures in Javascript [JSConf2014] | Coder Coacher - Coaching Coders</title><meta content="Kassandra Perch: Modular Application Architectures in Javascript [JSConf2014] - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Kassandra Perch: Modular Application Architectures in Javascript [JSConf2014]</b></h2><h5 class="post__date">2014-06-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cTcdtfUjflI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">funny story I'm I've been super nervous
all day and a friend of mine gave me the
advice that I should come up on stage
and beatbox for a minute and that would
make me less nervous I'm not gonna do
that but I found that telling Santa
story to make someone laugh makes them a
lot less nervous and I think I think
that happens to be true so just a
forewarning
just before warning there are a lot of
opinions in this slide deck and if you'd
like to talk to me about those opinions
I will be hopefully in a light-up dress
at the party like broadcasting myself as
much as possible so feel free to
approach me and talk to me about these
things because they are important so
JavaScript especially the programming in
general that I'm finding JavaScript is
falling more and more into a fanaticism
problem we invest in one framework one
tool one way of one way of coding and we
we use it for everything in anything and
it's we're actually starting to see
alternatives to our way of doing things
as adversaries whether rather than
alternatives whether rather than ways to
benefit our lives and our code I
definitely see a lot of the when you
have a hammer everything is a nail
problem we use our favorite tools even
when they might not necessarily fit well
or maybe something would be a little bit
better or a little bit easier to use not
just for ourselves but when we're
working on teams we tend to pick our
favorite tools maybe at the expense of
those were working with and I truly
believe fanaticism prevents us from
building the best software we can
possibly build we're limiting ourselves
to singular frameworks singular tools
and we're
missing out on all the possibilities
that are there I'm not saying we should
learn everything I'm saying we should
keep our lines open it's not just that
we miss new tools to hold on to what we
what we already know the new and shiny
effect is something I see very
pervasively in j/s I saw this a lot with
grunt when gulp came out a lot of people
immediately jump to gulp and just
started just thrashing grunt and it was
just it was it was quite confusing to me
to see two perfectly valid tools but
because one was newer it must have been
better I didn't quite see it so if you
need an example of this kind of
fanaticism there's nothing like waking
up the morning of your talk to a blog
post saying that the premise of your
talk is bunk
I was absolutely dumbfounded this
morning when I saw a blog post about it
and I I definitely liked Isaac's
response to this and I hate to read off
my slides but I'm going to read this
there's this myth that a single rule or
the rejection of one will make software
developments simple or easy and that's
full and I I happen to really agree with
that so today I'm really here to talk
about modular I could text here but keep
what I've already said in mind keep keep
the problems of fanaticism in mind when
I talk about this because it will come
up from time to time so one of the
things that I find for modular
architecture is I get this question a
lot I've spoken about flight which is a
front-end framework from Twitter and I
get this question all the time when I
speak about that framework and I find
it's a valid question but asking how is
flight like ember how is flight like
angular how is flight like polymer which
follower isn't even really you know
comparing it doesn't--it's it should not
be the basis for selecting a framework
or a tool we shouldn't be asking
ourselves how are things like each other
in the JavaScript ecosystem we should be
asking how will this tool this framework
this piece of code make my life better
as a developer make my team's life
better make my process better these are
the kinds of questions I find we're not
asking nearly as much but we could be
and we should be
and before I say before I get the
argument of oh well that means we just
shouldn't become attached to anything
that's that's entirely not true we
should definitely be passionate about
the tools we use blog posts
documentation pull requests tests these
are all things we could be doing to show
our passion for the tools that we like
to use now we just need to apply some
critical thinking as a group and I'm
sure not all you know not all of you
fall for this but I have I've caught
myself doing this recently so we need to
remember to be passionate but not a
fanatic about the tools that we use the
frameworks that we use we need to keep
open minds another problem I see is
common developer assumptions jQuery
I love jQuery I really do I consider it
to be a common developer assumption that
mean you know it nests it it requires
some thought before you start your next
application think about what you're
going to use and don't just assume that
because you've always used a particular
tool that it needs to be in place and
I'm certainly not saying don't use a
framework ever
I like frameworks I in particular you
know I like quite a few different
frameworks for different tasks so I'm
definitely not saying don't ever use a
framework I'm simply saying we should be
much more judicious about when and what
frameworks we happen to use I like to
consider the following when I'm
considering any tool but especially
tools that require a large amount of
buy-in is it bringing in functionality I
don't need can I bring it in in outside
code easily this is one of the more
important ones and my one of the ones
that I feel especially with teams is
what's the investment to reward ratio
how much am i how much work am I going
to have to put in to learn this
particular tool in order to get what I
need out of it one way to kind of help
determine what kind of tools I
definitely am a big fan of building
proofs of concepts like to do MVC
definitely an indie a good way of seeing
how to build a tool right more than the
hello world with whatever tool you're
happening to proof of concept I see this
a lot where where I've done it where
I've written a hello world in a tool and
I've just dismissed it based off that
you're gonna want to actually get your
hands dirty with whatever tool you're
evaluating before you make any decisions
about it
positive or negative make sure you're
just building a proof of concept for the
tool you're trying to evaluate if you
bring in three different tools and try
to use them together and it turns out to
be horrible maybe one of those tools or
all three of those tools are actually
fantastic it's just using them together
was a pain so definitely try to isolate
your proof of concept to kind of
actually evaluate the tool at hand and
keep your teams as centricity is in mind
this is especially important when you're
not working by yourself
I've gotten into and argued with my
co-workers about semicolons for two
hours so you have to keep other people's
development in mind because it will make
your life better if they're happier
so I usually get to this point in the
conversation with people before actually
starts to pop up an awful lot so what
I'm going to do is go over the three
most common arguments I hear against
using a modular architecture and
building from the ground up and kind of
counterpoint or even admit to the
possible downfalls of this sort of kind
of this sort of building the first one I
get is that module systems cause
spaghetti code um you know cobbling all
these little tiny pieces of code
together causes an completely
unmaintainable application and it's just
impossible to understand how
everything's working together and the
worst part is no one's code is the same
style so you're writing different styles
of code around your application the the
counter did this would be a framework
would solve this by including everything
or having a plug-in system some sort of
unified language or way of doing things
my response to that is we should be
separating our module choices from our
code in our frameworks from our like our
business logic we shouldn't be you know
tightly coupling these either way
whether we're using a framework or
whether we're using a modular structure
I do believe in the practical use of
abstraction layers I used to scoff at
them just as much as some of my friends
and some of my respected peers but I
actually believe abstraction layers been
used in in proper settings are quite
beneficial functional mix-ins as opposed
to inheritance I've also found is a very
valid tactic for keeping code separated
and keeping it loosely coupled while
maintaining well being
able to use the functionality within
that code and then architecture
assistance I'm gonna talk a little more
about how I really feel about frameworks
and where where my thoughts come from on
that
so with extraction abstraction layers I
find a really good example of this as
premise if you've ever used it for node
it's a it's a web socket abstraction
layer for different protocols and if you
want to use different protocols for your
web sockets all you have to do is change
one line of configuration it gives the
standard API to all of the WebSocket
configurations so that way if you need
to switch if you need to make a
technology change and you don't have to
rewrite your entire application you just
change one line I think this is
definitely something we can consider for
pieces of functionality creating an
abstraction layer if it's severe using
third-party code creating that layer of
the things we need I also find writing
the abstraction layer before choosing
your module can actually help you make
the decision quite well you could say
okay I need these things out of my out
of my query selectors and either out of
my animation tool I need these things
it's even you have the API that you need
it makes a little easier to select the
tool that you want and what we'll do the
tool that will do what you need it to do
as for functional mix-ins I can't really
go into the details of how they work
because that would be a whole nother
talk anga scroll has written a lot about
these and I actually did I find that
they fit javascript is a language right
quite well and it's a very interesting
way to augment your code with other
codes functionality without necessarily
type tightly coupling that code as for
architecture assistants I do mean
frameworks in this sense and I I usually
fall back to the definition of the word
framework when I'm considering that and
the definition of the word is an
essential supporting structure the basic
structure and a lot of frameworks out
there do everything and that's cool
I really only care about the part where
they're you know providing a structure
for my code the rest of the stuff can be
evaluated separately and the other thing
I like to consider when I'm thinking of
the definition of the word is is a
framework giving me structure or is it
giving me a gilded cage from which I if
I want to do
something outside of the ways of the
framework am I going to have to fight it
I've seen and I've been on teams they've
fought their framework endlessly and
instead of considering dropping the
framework for a modular sort of
architecture they'd spend even more time
than rebuilding the application fighting
that framework some good examples of
frameworks that provide architecture
exist assistance and not much else
include flight and backbone for the
front end and Resta phi for the back gun
though rest by starting to kind of
branch out into more functionality I
think generally it does provide that
architecture assistance if you're doing
a breast API if you're doing a web app
not a you know definitely like I said be
judicious about what frameworks you use
and when so what you get with with
keeping your code your business logic
separate from your modules is you can
swap out your modules with minimal work
you need to write it to the abstraction
layer and that's it you don't need to
worry about every particular piece of
code that's calling that module because
you've used that tertiary layer and
especially for testing you can test
through your abstraction layer and
you're done when you swap out a module
you don't need it you don't usually need
to rewrite your tests sometimes there
may be extenuating circumstances but to
the general point when you do it this
way you can swap out modules swap out
even technologies without worrying about
rewriting your entire test suite without
worrying about rewriting most of your
code so the second argument I get a lot
is that my framework has everything my
team needs
I don't need outside sources I don't
need to worry about looking at 50
different tools and picking one my my
framework does this for me and having
it's got my best interest in mind and
etc and that's definitely a good point
I mean frameworks can do a lot for you
especially if you align with what the
framework is concerned about and
basically developer efficiency is
something that is brought up a lot I my
team rates faster when I'm in a
framework because everything's there
every you know you can learn the
framework and then you're done you've
got you've got all the knowledge you
need to build web applications from that
framework and this is definitely the
argument where I see fanaticism really
start to leak through I have given two
talks about flight at conferences and
the same thing has happened both times I
immediately
down and someone runs over to me with a
laptop and shows me my sample code
rewritten in another framework I asked
them how long it took one said five
minutes and once in ten minutes so I
think to myself if you came running over
the second i sat down us-- missed the
last five or ten minutes of my talk
about another framework to prove me
wrong by writing it in your framework
this is my response to them just about
every time because I just feel like
that's great that's great for you that
you know your framework that well that's
great that your framework is that
efficient and you really showed me but
you missed my point
you missed the you missed an entirely
new opportunity in a way a new tool and
a new way of thinking about things
because you were mired in what your
favorite already was all-in-one
frameworks to me they have a lot of
buy-in and that makes me wary I have a
personal metric I'm sure someone else's
thought of it before me I call it the
time to first hello world metric and the
time to first non-trivial and those are
both rather high for a lot of the
all-in-one frameworks that I've
experimented with not just for myself
but I've asked around and other people
have seem to have high time to first
worlds and hi non-trivial times and that
to me it leaves devs in the dark for a
lot longer so when you talk about dev
efficiency it's about whether they need
to learn things in increments or whether
they need to learn all about a framework
at once and then they're done so you're
not putting it one isn't easier than the
other I think I think it's the both the
same amount of work it's just in what
increments you put those work in finally
when it comes to picking a framework
versus picking modules I feel sometimes
that when you're talking about
frameworks it feels kind of like a
negotiation of oh well this framework
does this this and this well but we have
to put up with these two things that
don't go well with our app or you fight
the app so that or you fight the
framework or whatever you're using so
that you can you can accomplish those
two things decently but how much time
did you put into that definitely to me
it feels like you're kind of holding
pieces of your application is like
bartering tools it's like okay if we can
get a B and C out of this framework we
can put up with D and E being
look terrible to implement the last
argument is what was the most solid
argument but I think now it's actually
kind of a moot point
I really think third party module
management has come a long long way in
JavaScript since when I started
JavaScript development and I'm my
favorite joke about this is we have the
technology we have ways of managing
module upgrades versioning keep
installing dev environments quickly and
easily wewe have they're not of course
they're not perfect
but I certainly think we have these to a
workable state of course I'm talking
about MPM and feelings aside about Bower
it is a package management tool and it
does its job so feelings aside those two
tools have really stepped forward in
terms of managed managing third-party
modules in terms of keeping versioning
saying in terms of keeping your
application structured and and in terms
of what code goes wearing what version
it is and as for module loading on the
in the browser again we have a litany of
tools that need a litany of needs and
es6 is coming and that has module
loading natively which is fantastic I
think so with these combined and with
continuous integration tools such as
Travis CI that clear to manage and you
know alert you when you have a
dependency that's fallen out of version
or when you you know you can run your
tests quickly and you can run your
configurations quickly I think there's a
significant reduction in nightmares
there will always be nightmares with
managing third-party modules I won't
deny that there will always be a reason
to worry about it but I think we
significantly reduced that worry over
the past few years so to reiterate be
passionate but not fanatic about the
tools that you use definitely be a
little more judicious of and sceptical
of tools with a large amount of BI and
I'm not saying don't use them I'm simply
saying evaluate them to the fullest and
then consider your needs all of your
needs not just some of your needs pick
the right tool for each task and if you
like I said if you use a framework be
judicious now why bother with all this
you know some of you may be out there
and still feel that modular
texture is still a pain it's still more
difficult than framework what do you get
out of it
abstractions for me and my team create a
common language and a common way of
doing things so that all the developers
can still speak the same language even
though we've got several pieces of
third-party code everything you need and
nothing you don't and nothing really
getting in your way that you didn't need
in the first place and testing when you
have self-contained modules it's much
easier to test its I've found testing
against a an application built on a
framework I end up testing the framework
more than I end up testing my own
application code with a modular with a
modular set up you're much more likely
to you can see your code in smaller bits
and it's easier to see okay what's my
code and what's the module I'm using and
test therefore because developer heads
I've been saying this a lot and this
developer happiness is contagious when
you're happy your team's happy and when
you're all developing code that is
easier to maintain and easier to track
keep track of everyone's happier I have
a couple of thank-yous to make Chris
Williams and and the Jas comp staff for
putting on such an amazing conference
I've had a miraculously fun time I'd
really like to thank RetailMeNot I'm an
engineering evangelist for them they let
me speak at conferences and they fly me
all over the place and they let me have
these fun experiences and I'd like to
thank my friend and mentor ray I often
say I don't know where I'd be without
him but I do know that my life is a
better for him in it thank you for
listening like I said if you have
questions or comments feel free to track
me down at tonight's party I should be
wearing a light-up dress that's my
twitter handle my email address and
again I'm an engineering evangelist at
RetailMeNot thank you very much for
listening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>