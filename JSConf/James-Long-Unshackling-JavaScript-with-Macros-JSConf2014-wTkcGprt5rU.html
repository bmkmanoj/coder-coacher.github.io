<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>James Long: Unshackling JavaScript with Macros [JSConf2014] | Coder Coacher - Coaching Coders</title><meta content="James Long: Unshackling JavaScript with Macros [JSConf2014] - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>James Long: Unshackling JavaScript with Macros [JSConf2014]</b></h2><h5 class="post__date">2014-06-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wTkcGprt5rU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in 1995 JavaScript was created by
Brendan Eich in 1997 ACMA produced the
first standards document under the name
Atma scripts this wasn't much like the
JavaScript that we know of today
it did have prototypical inheritance and
that's probably about the the main cool
thing about it at that point
unfortunately we were already stuck with
a lot of the bad stuff that we know of
today
it's just with it automatic semicolon
insertion and double eagles oh well in
1990 a Tekamah script - was released
just a minor revision in Equus script 3
was released in 1999 this one was a big
release this came with the triple equals
operator exceptions at the error object
and a whole lot of stuff most notably
functional or function expressions so
you have closures so Java scripting have
closures for four years it's crazy
in 2001 script for started the effort
for it started unfortunately it was just
too big in too little time and it failed
it promised a lot of cool stuff though
like type annotations variable D
structuring classes and logical stuff
according to the ECMO archives ECMO
script for just never happened
i consecrate v was released in 2008 I
came a lot of cool features such as a
prettier spud page so we're we have
colors now we're not in the 90s anymore
it did have a bunch of cool stuff like
use strict and a lot of things like
getters and setters and JSON parsing but
it's really just an incremental
improvement it was it was to set the
stage for bigger things to
and that's where we are right now we
almost have the finalized version of
Ekman script 6 and this brings back a
lot of what we lost in es for things
like generators and classes and
variability structuring a lot of really
cool stuff the problem is that web
developers can't use these features yet
because we have to wait for all of the
browser's to implement them several
versions back it has to have the
majority of the market share for a
normal web developer to use these maybe
you're lucky and that you can only
target the latest version of chrome of
Chrome and Firefox but most web
developers have to wait a long time for
these things to be implemented so a
quick poll how many of you all use
variable D structuring in your
JavaScript today
yeah like 2% of people so 14 years later
after we wanted this we still don't have
it I mean I understand why I don't blame
anybody it's it's a hard process
especially JavaScript because there's so
many really advanced implementations and
engines but this is a simple feature
that could let that could make your
codebase looks so much cleaner it's
crazy so what can we do well we can
write you has six code and compile it to
es five projects like tracer enable this
and this is really cool this is a great
idea tracer implements a host of es6
features I think pretty much most of
them I think there are a few things that
depend on the additions to the virtual
machine that we just can't compile to
what tracer does most most everything
else and this is awesome this is really
helped with early adoption of es6
features and that's great but it's an
all-or-nothing proposition there's
something technically wrong with it but
I think a better culture comes when you
enable smaller and more independent
modules so if if tracer is missing a
feature like variable D structuring
which it's not but if it's missing a
feature you just have to wait for that
feature to be implemented there's no
there's no it's it's hard for the
community to take to participate and
fill in the gaps we all know that
smaller independent modules are a better
way of doing things where JavaScript
folks we live and die by our modules so
the question is is it possible to have
language features a smaller more
modules so as with anything in computer
science this was solved in the 60s and
the 70s this is a hard problem so it's
probably completely solved but I think
that it was pioneered way back when I'm
James long and I work on Firefox
developer tools for Mozilla and I'm
gonna show you how how this could work
so to show you how how we can do this we
need to take a quick look at Lisp
Lisp has deep roots and simplicity it
started out as a small but a powerful
language with a simple syntax in 1963
Timothy Hart was a way to keep the
language small but users add their own
forms and extend the language you could
do this with a new special form called
macro macro later called
def macro allowed the community to
evolve Lisp just like adding new AP eyes
they could add new semantics the Common
Lisp object system see loss which was
the object system specified with Common
Lisp was inspired by two other systems
that had already been widely used common
loops and flavours these were systems
way back in the I think the seventies
maybe the sixties that had been
implemented as libraries so users could
just download these things add them to
their project and use it and they added
new special forms to define objects who
defined methods on these objects these
these libraries had already fleshed out
these these ideas for they cut these
ideas for the OP these object systems
and it it was a highly influential in
the design of C loss which was the later
the object system which was included in
the specification which is pretty cool
that you can use them in the real world
before they're actually specified so
here's how you define a method with
flavors you'll probably recognize a
little bit more in JavaScript so
obviously this is not valid JavaScript
method is a special form it's somewhat
similar to function but a little bit
more specialized it takes the type that
you're adding the method to takes the
name of the method and the arguments in
the code so current currently there's no
way to add this special form method you
have to write your own compiler to do it
but if you do that you can't use any
other language extensions that anybody
else writes and don't don't focus too
much on the actual feature don't cringe
at the actual method this is probably a
terrible way to do methods
but it's just an example of a new
special form so sweet GS is a new
powerful macro system from Java or for
JavaScript from Mozilla now these aren't
your run-of-the-mill C macros sweet just
provides a powerful pattern matching
language for matching on code and
sophisticated mechanisms for expanding
into new code it'd be trivial to
implement that method new special form
and really easy for you just to use it
you just add it to your project and it's
available the great thing is they can
add any number of modules that have
macros and users macros alongside of the
method macro you're not binding yourself
down to one compiler so if you formalize
a way to add new semantics just like you
add new features it makes it really easy
to extend the language and really easy
to make the community participate in the
language evolution so I have a new
language that I want to announce called
emoji scripts this is an example for you
guys the emoji script features emotion
as a value so currently in JavaScript
you can't actually use emoji which is a
real shame you have to quote it but then
you deal with strings and it's really
just a second class citizen but you
moved your script lets you embed emoji
in into JavaScript so you can actually
assign it to a variable and you can use
it so emotion literals are cool so now
with a swift Google search for emoji
finding what you want and then copy and
pasting in that single emoji into your
code you can do things like emotional
algebra there's a having person plus
fire equals a person's scream in fear
and a happy person plus a punch in the
face equals a crying person a happy
person plus a drop of water equals a
happy person with a different foot water
I'm not really sure what that one is you
can compare emotions so happiness things
better than sadness emoji script
enforces good practices it actually this
allows the use of the double equals
operator now maybe you just really
needed to use it maybe you just loved it
too much and you can use it any motor
script so if you want to use it you have
to use the poop operator
they this has the exact same semantics
as double equals except it's poop so
there's also a better way to a more
tourist way to throw errors instead of
having to type out throw new error you
can just use the angry face and that
throws the error with that message
there's also features automatic cat
insertion so why would you terminate
your statements with semicolons when you
could terminate your statements with
cats so now now you now you get this
better expressive language where you can
do things like if the user is not happy
then you can yell at them to be happy
there's not really a way to make him
happy with software so if you want to
use emoji script you just npm install it
this actually works you could do this
right now and you use the script emo to
compile your file so a MIDI script is
actually just a set of macros each of
those individual features were
implemented is just separate J's files
you can see there's the algebra there's
the poop macro I never thought I'd be
talking about poop when my first J's
comp talked but so as a disclosure I did
have to patch sweet GS to support emoji
which is unfortunate but let's just for
an example so you can pick out
individual features that you want to use
this command uses the the standard sweet
J's compiler which is SJS and it uses
the - M argument which means you you can
pass a module to sweet GS to load macros
from and it will use those macros to
expand your file so this just uses the
poop feature now I knew the irony of me
telling you not to use compilers and
then telling you to go download this
week is compiler technically technically
yes it's a compiler but it's really an
expander a macro system as a new phase
for the parse compile and execute
pipeline of a program the expand phase
and it happens before anyone before
anything else it's really just
formalizing this the way that we want to
extend the language and now that since
we formalized it we just have one
compiler and everything else just works
together really well and you get a lot
of good things like automatic source
Maps so all of the macros automatically
are automatically generated source maps
for free sweet J's compiler it takes
care of that if you're writing a macro
you don't have to worry about it at all
if you're using
macros you know it you're going to get
accurate source maps which I think
that's I think that's a pretty awesome a
pretty awesome thing so here's here's a
more realistic example I have a project
called es6 macros it implements
individual es6 features as macros you
can pick up the whole bundle or you can
just choose one or two features that you
want from it and of course you can use
any other macros there's some really
cool stuff that some people are doing
like pattern matching and things like
this so this is an example of the fat
arrow module if you use the fat arrow
module you can use es6 headers and which
are really cool because they keep the
outer this context so what my macro does
is it just expands it into a function
expression but it calls dot bind with
this on it so you get that with just a
pretty small macro there's also ad
structuring module where if you include
this you can use variable structuring
which I still don't understand like why
people don't use this more or like at
least use tracer to compile this because
it makes your code so much cleaner this
is the class module so you can actually
CSS classes my module supports the
constructor and as well as super as well
which is not in the example but if you
call super within move it'll actually
walk up the prototype chain and called
and move that's your parent so this
expands out to this which is kind of the
familiar class and takes the class
function that you're used to so here's
here's an example of interoperable
features if you just wanted the the poop
operator and the fat arrow operator you
could just npm install both of those
projects but just pass the poop and the
federal module to SJS and it'll expand
your file just with those operators it
it interoperates just fine so ready
macros is far easier than writing
compilers have fun experiment and play
with things that javascript might might
want to do in the future things that we
don't even know about this is more than
just a better way to adopt es6 features
es7 is coming as well and javascript
will always be evolving we should make
it easy to experiment in to try new
features
and they're all small independent
modules that are easy to write and to
use together so currently this is the
abstract process of adding the feature
to JavaScript there's proposal to tc39
there's discussion there's my
finalization there's implementation and
there's maturation the maturation phase
is basically its existed out there long
enough to where it's taken over enough
browser market share so it's existed in
browsers several versions back because
most web devs as you know have to
support you know 96% of the of the
browser market share so this takes
forever even if we can speed up the
discussion and finalization pieces this
creates a gap between the Ekman
committee named tc39 and the community
actually building stuff because it's six
years maybe even decades no I I think we
got stuck on es6 on es6 because this is
so large and I know tc39 is working on a
ways to push through features faster
more frequent smaller respects but the
implementation the maturation phases are
always going to take a long time so I
think one way to help with this is to
let the tc39 give the community features
early on as well as making it easy for
the community to create features imagine
if every TC tc39 proposal came with a
working macro anyone of you excited
about this in the community could go and
just use that right now and test it and
flush it out and see see how it actually
feels in real-world code yes you can do
this with compilers but what I'm saying
is it's really only scalable it's only
really a good solution if you if you
could do it as independent modules is
every feature posted to the mailing list
has an attachment that's a macro to make
it work and even better if the everyone
in the community who is excited about an
idea could actually try it out they
could actually write a macro to extend a
language and see how it works and so the
community has a greater participation so
I think I think it helps close the gap
between the community and committees
like tc39 of course not everything has
to be standardised in fact I think it's
better if we keep JavaScript from
getting bloated by standardizing all the
things there are huge advantages to
simply using libraries instead of
depending on platform feature
it works because it works the same
everywhere instantly I mean there might
be a possibility that you're depending
on a runtime API that's only available
in a specific version but when you when
you release a library anyone you don't
have to worry if they're working in
Firefox or Chrome or anything like that
it's just a library that you just
download and use the main advantage to I
think is that you don't have to worry
about backwards compatibility so any
feature that goes into a browser
requires a lot of thought because
they're thinking up mmm this doesn't
break any existing feature right this
doesn't break any existing syntax in
addition to that this isn't going to tie
us down into one thing in the far future
because the browser is always completely
backwards compatible which i think is
awesome but it kind of constrains the
language in some ways if a breaking
change if you if you if you release a
feature as a macro and you need it a
breaking change you could just either
fork the library or do like a major
version bump and maintain two different
libraries because it's a library it's
not hooked down to the jeaious engine so
they give a formalized way to treat new
language features of libraries and a lot
of community to experiment and use
things that will probably never be other
dogs have standard or will the widget
script be ever beyond the standard it
might be but in all seriousness changing
language semantics should should not be
taken lightly
don't use macros just for inlining code
don't use macros just to remove curly
braces honestly if you're thinking of
writing the macro right now you probably
shouldn't I mean how how can I say this
after everything I just said I think
it's because we need to be grounded
don't don't experiment on your company's
codebase don't cut off the community by
using weird features only write a macro
if the feature is unique enough and you
have time to invest in teaching people
why it's useful Common Lisp in my
opinion kind of felt fell prey to this
it's just way too common to write macros
if you're working on your web app you
probably will write some macros to do
something this just creates too much
confusion too much divisive nough speak
of the semantics are changing just too
much my opinion closure did it right
they have just enough built in
functionality so you don't always have
to be writing macros and the culture
actually discourages macros in fact
which i think is what
need to do as well but we can't simply
discount macros completely don't be
afraid
closure was able to release a library
called core async which has is somewhat
similar to generators they're different
in many ways but the core functionality
is that they can pause and suspend
execution of a function they were able
to do this as a library because they
implemented a go block which is a new
special form and it compiles the code
inside the go block into a state machine
that they can control it's all just a
library when they release it everyone
can download it and just immediately
begin using it they don't have to wait
for a whole standardization process and
ten years from now might be able to use
it so I think this is especially
important for JavaScript the language is
the language evolution is already
happening I mean looking angular they're
talking about this extension to es6 to
make es6 plus where they have this
dependency injection weird stuff and you
know i think this is fine i think it's
so good to think of ways that we can
improve our code but i think they're
planning on 14 tracer i could be wrong
with that or they're playing around
forking a compiler and adding some
extensions the more and more you do that
the more and more you're styling
yourself away from the JavaScript
community I think javascript needs
release valves because it's just such a
massive language it's used everywhere so
macros can be useful even if you don't
change semantics the emoji script poop
feature disables double equals and this
is how that works
I'm not going to go into the details but
I'm able to throw a syntaxerror within
my macro so whenever the double equals
operator is invoked my macro is invoked
and my macro throws a syntax error so at
expand time it's just throws a syntax
error and says that's not allowed so
this is an interesting way to not only
expand the language but kind of
restricted as well in fact if you wanted
to use macros but you didn't want
anybody on the team especially that
overeager college grad that you just
hired to create macros and go crazy and
change things out from under you you can
just disable macros entirely across your
projects just create a macro called
macro and throw the syntax here and say
you know aloud so here's another example
of macros that don't introduce new new
semantics macros allow certain forms of
aspect or unit programming which means
you can change behavior or add behavior
too so
parts your code without actually
changing it I kind of just made that up
I don't really know what aspect-oriented
programming is technically but look at
the wiki page I mean a macro that traces
all function calls it overrides the
function keyword and injects a console
that log at the beginning calls the
function immediately and gets the return
value and then adds another console dot
log of the return when the return is
happening and I'm able to pick off the
name of the function this is actually
just one part of the macro that the real
macro that it wrote is a little bit more
sophisticated it's able to pick off the
name of the function even if it's like a
an object property you know so I took
this macro and I ran it through and I
ran and I ran jQuery with it so it
expanded jquery with this and so with
this it's really interesting i was able
to run this jQuery code and say with it
what does the execution look like within
jQuery so I can grab an element with the
idea of app and I can set the HTML of it
with of it with to the div with a class
box and I can kind of see the shape of
what's going on within jQuery so if I
wanted to learn what jQuery was doing
maybe I wanted to start working on
jQuery I just immediately see this
interesting functionality now a certain
dev tools I think are starting to
implement things like tracers but youyou
wrote this for your app for your code
and project and you know what you're
wanting to look for so you could do all
sorts of things with macros that are
specific to your app for debugging your
app and logging your app and doing all
sorts of interesting things but don't
actually change semantics right there
just adding interesting logging
capabilities so nobody else on the team
doesn't even have to worry about what's
going on so here's something a little
crazier this does this does add new
semantics can we implement a simplistic
stack allocated type system so we can
get bit something basic working I think
first let's allocate one big typed array
our stock and create various type two
views into it and my stack a located
type system allows you to write code
like this you can define a record type
so you have point which with fields and
they all have types and these types are
just kind of the machine low-level types
like double and float and you went and
int and short
but now now you can accentuate one of
these records and it essentially
allocates it on our set which we is that
big techhdarre
and this sets the X&amp;amp;Y to 180 this
expands all the way down do this so I
grab I grab the current side pointer and
that's essentially my stack allocated
objects it's just a pointer and I move
the stack pointer and then I set the
pieces in my stack to 180 and I'm
accessing it through the float
float64array and you can see the pointer
so the first one is my my cyclic a to
object pointer and the the second value
Y is that plus 8 because it's 8 bytes
wide so we can have typed allocated
structs and compile it down to this this
lets you avoid all those pesky
allocations if you're writing like heavy
graphics code it's a very interesting
way to kind of interleave this this is a
haven't put a whole lot of time you do
this if a new type theory better I'd
probably do something little bit
different if you want it to like return
this you can do that you but you could I
essentially copied it onto the heap if
you wanted to do that but there's a lot
of times when you're writing graphics
code and you just want a bunch of local
vectors to do some computationally heavy
work and always doing the object literal
x and y is just hitting a garbage
collector for no reason so who knows
maybe one of these features does turn
out to be so useful that it does become
standardized something that we wouldn't
have thought to propose at first and now
it will be based on real world usage and
most of the problems with backwards
compatibility will already have been
solved it would be neat if JavaScript
even integrated sweet GS itself natively
but if that does happen that's probably
a long ways off
but I think it could be need to do
something like a browser add-on that in
that integrates it automatically and
then for production you just pre compile
or could of course some levels really do
you require a platform level integration
just things like weak Maps but I think
those are actually relatively rare so
let's let's look at what sweet GS if you
wanted to actually write macros some of
the features that it gives you to to
actually do this because I haven't
showed you any of the actual code so if
features a pattern matching various
expansion strategies and hygiene so
these are fully hygienic macros so if
you're familiar with macros you know
that that's pretty much necessary for a
real world
her system so PI R imagine you've you've
seen this to some extent this is just a
basic pattern matching you have a list
of rules and the sweet jest system will
invoke your macro so it's you have a
macro named bar your macro will be
invoked when it hits the keyword bar in
the code and then it will walk down your
rules top to bottom and see see if it
matches a rule and if it doesn't matter
rule it'll throw in my chair and when it
does the first rule that matches it will
expand into the code that's within that
rule so this is a basic basic variable
destructuring array so you can see that
the first rule has a curly brace and
then a name and then of multiple
repeated names and then equals object so
you can bind current syntactic elements
to pattern variables with the dollar
sign so that basically says whatever is
here just bind it to me and then the the
dot dot means match repeated elements
and just a brief overview so that's
that's the roll macro this is a rule
makkal you just have a list of patterns
there's a a let macro which is
essentially the same as the rule macro
except you define it saying let var
equals macro and what this does is by
default recur macros are recursive so
when a code is expanded it will
reexpansion var keyword you couldn't do
that let macro does not recursively
expand oh I'm sorry it does it but I let
my grow if you the VAR that we've
referenced within the macro doesn't
reference my macro it references what
what it was defined as before my macro
which was the built-in var so this will
not recursively infinitely loop which it
would do with a normal macro there's in
fix macros which let you specify a pipe
or a bar in your pattern and that means
you can look and that that bar indicates
where that macro matched and that means
you can match before the syntactical
element that you've been invoked on so
for the arrow function syntax the FATA
is we need this because we need to look
back and grab the arguments and so
that's this is a basic file
this is actually most where all of the
fat arrow
macro you you get this like you get fed
arose with this macro
I think it's actually missing one rule
for one one style of photos but this is
how tiny it is you don't have to write
compilers this is a little bit more
complex but there's um there's a special
form called operator which defines a new
macro but it's but it's has a little bit
more semantics so this overrides the
plus operator it takes the precedence
and the associativity so 12 is the
president's level so if you think of
operators they all have our precedence
level like where they where they group
together so plus I'm doing it 12 which i
think is what the what the default is
and then a left associativity so you can
see that it expands is you a function
call add so 1 plus 2 Plus 3 plus 4
expands into this and it groups 1 &amp;amp; 2
first if I change the associativity to
right then it's going to group 3 &amp;amp; 4
first and then expand out from there so
this is why you need this special form
operator because it has the precedence
and the associative 'ti and things that
you can do with what the other macros
and this is the last one this is the
most complex one and one that should
rarely be needed really it's case
mappers these macros actually let you
run arbitrary JavaScript within the the
rule so it takes a pattern this is a
little bit different it takes it takes a
syntactic element that it bound on as
the first argument or as the first piece
in your pattern and then you have your
whole pattern but then you can actually
any JavaScript within this expanded code
so I can check if this condition isn't
true then throw a syntax error and this
lets you do things like break hygiene
gum which I'm about to talk about so so
hygiene like I said these are hygienic
Macker this is like crucially important
it's a basic thing that you need for any
macro system that's going to be used as
modules so the problem with macros
typically is we've defined this square
macro if it square X expands out to
these two lines of code which have
another suit var X so if it was just a
naive macro system I would have to two
variable declarations with the name X
and they would collide and they
overwrite and it leads to really strange
bugs and there's just you really need
hygiene to actually have a sound
macro system so a sweet J's says it
actual
renames the variables so the first X is
renamed X dollars 21 and the second one
is rename X are assigned to so it
removes everything to make sure that
it's right so this is the very last
thing I'm going to talk about you might
be sitting there thinking like well this
is totally all cool I would use this
except for one thing and that that's
that it breaks my syntax highlighter in
my editor so I looked at a lot of some
nice highlighters and they're actually
pretty loose most of them are regular
expression based you can do a lot of
weird operators and stuff this is
IntelliJ I just chose it because it's
just a really random one that I thought
would be a little bit more intrusive
about how it's actually parsing the code
but it actually worked fine I didn't
really throw any enters errors most
editors are pretty flexible and they're
just looking for the keywords and
they're just looking for a basic
delimiter is so that it can indent the
code right and it just pretty much
ignores everything else there are a few
exceptions jst mode in Emacs actually
little literally parses the JavaScript
code in your buffer so that it does
break that but honestly the more I think
about it the more I think that some of
those things aren't worth the return
because I really don't use like it tells
me when I'm missing a semicolon and
that's cool but J's hint can tell me
that or it's somewhat somewhat I think
and tell me that some kind of build time
that that's happening I'm starting to
think that something's like that might
actually end up holding back Java
scripts because a lot of people don't
use es6 because not only is ESX not
implemented you could use it with trace
or something but a lot of these other
tools haven't implemented like editors
haven't implemented like the fat arrow
syntax so it the the editor breaks so
I'm actually starting to think that
things like editors the looser the
highlighting is the better so I'm I mean
maybe I'm a little bit biased because I
do like to use macros but I've actually
seen like vim works great with the with
different operators and stuff like that
basically anything on a new line that is
still part of the previous previous
expression is just intended like two or
four spaces and they just kind of
doesn't care what it is so just a quick
recap javascript is under a lot of
pressure to evolve and suite just
provides powerful macros for adding
these features as libraries and we can
test them out early we can try them
early and see if they work compilers
can't work together there they're great
for some things but for specifically
language extensions there
a little bit more they tend to create
silos and we can help tc39 we can help
liberate javascript so we don't have to
wait 14 years for a variable destruction
that's it
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>