<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Sam L'ecuyer: Code without Keywords | JS.LA May 2016 | Coder Coacher - Coaching Coders</title><meta content="Sam L'ecuyer: Code without Keywords | JS.LA May 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Sam L'ecuyer: Code without Keywords | JS.LA May 2016</b></h2><h5 class="post__date">2016-06-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LG-ozmTnhdI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey so thank you for having me the name
of this talk is code without keywords I
think this is like my third presentation
ajla a little bit about myself my name's
Sam let's call me a computer scientist
because that makes me sound way smarter
I am I organize another meetup called
papers we love that meets the night
before JSL a we talk about computer
science papers and I do front-end
eSports stuff at Yahoo so uh you've
you've all done javascript I assume
you've seen the new JavaScript been
doing JavaScript for probably about
seven years now you know I've seen the
number of reserved keywords kind of go
up and down not all of these are
currently reserved keywords in
JavaScript but a lot of them are some of
them are historical there are a lot of
these aren't there they're a lot or
they're like too many does JavaScript
have too many keywords now okay cuz you
know I'm like keywords new keywords
which ones you even use people are
talking about VAR let some people talk
about ELPS do people use eltz okay well
anyways I think that we can do better
and so you know when we talk about how
many keywords does JavaScript have we
should talk about like why do we use
them where do we where do they come from
we see them in places like bar a equals
1 let B equals hello if hello return 5
and so this comes from something that we
call the great divorce or I've heard
other terms but basically JavaScript the
designers separated statements from
expressions so when you save our equals
1 you then have a variable and that's an
expression and you have a value 1 and
that's an expression but the the
statement VAR
k equals one doesn't actually have a
value that's undefined and so you know
keywords like to appear in statements if
you think about like if that's a keyword
return that doesn't have a value that's
a keyword these are all these are all
statements so let's not use them so I'd
like to go through kind of keyword by
keyword and see how we can use fewer of
them so if we start with function as you
probably know JavaScript es6 added the
fat arrow function so where you would
have had to say function add three
return X plus 3 you can just skip the
function put the X in parenthesis and
this is actually sort of a twofer
because if the body of your function is
just an expression you don't even need a
return and so you can just have add 3x
in parenthesis X plus 3 bar and let you
don't need them and i'm not talking
about const how many of you know what
let d sugaring is how many of you have
ever heard the term let d sugaring I see
a hand it's a lisp thing when you let
variables to declare them in a scope or
in a block scope like you would with
JavaScript that is actually implemented
in Lisp typically as a macro because it
is not fundamental to the language
there's a technique where anytime you
are declaring a variable you can
actually just wrap that whole thing in a
function and that is its own scope and
so any time you'd have VAR a equals B 15
VAR b let's see you can just have an
anonymous function have two parameters a
and B those are accessible and then pass
15 and 30 you're following wrong we're
all on the same page ok cool so a little
bit of a tangent because i love tangents
and i'm terrible at segways
so yeah so this is something I sort of
discovered by accident with a co-worker
a few years ago and we talked about it
and then we both kind of looked at each
other and we joked like oh yeah you
could do this and then I looked it up
and you you actually can do this so this
is a real thing where you don't need
variables to have data structures you
can have basically closures and so we
can declare like a fundamental data
structure as a pair which is actually a
function that takes two values returns a
function that takes a function that
takes two values if if you're confused
by that it'll be more obvious as we're
going along so basically to create a
pair you would just call pair with two
values and then pairs because they
return functions we should have two
functions to pass into it so we can have
first and second and so if you pass
first it'll always return the first
parameter that's given second will
always return the second so you can take
a pair and you can create it and then
pass first or second and that will
return the value we're all on the same
page okay great because we're just going
to keep digging deeper this is pretty
basic to this talk so then if you if you
know any Lisp and you've heard of car
cons cutter basically we want to have a
function that we can pass a pair rather
than have the pair be the function that
we pass anything else so we can wrap
that by saying car as a function that
takes a pair and then applies that pair
to first and cutter takes a pair and
applies it to second and then we can
just alias and this is basically you can
build up a list of like 1 2 3 4 5 and
then say give me the second of the
second of the first of the first and
we'll give you 3 or the first of the
first of the second of the second and
it'll give you a 3 is that makes sense
mind blown I thought that this was
absolutely crazy when I first found out
about this so a quick aside on currying
if you don't know what currying is
basically instead of having a function
that takes like five parameters you just
keep having nested functions and they
keep returning functions that take like
one extra parameter so basically instead
of having like pair a and B you have
pair a return a function that takes be
that takes f that makes sense we're
going to be doing this notation a lot so
yeah tangent number two if if we're
trying to eliminate if statements it
seems sort of difficult to remove
control flow right from your programs
that that's hard but you can kind of
think of branching as like a data
structure because you have a test you
have like do this first thing and then
you have do the second thing in formal
logic we call it like the antecedent the
consequent and an alternative but it
kind of looks like a pair right it's a
pair of things and then something that
tells you which one to do and so this is
just that more verbose lee tests can be
a function that returns the first or
second part of a pair and so true is
like you know car and false is like
Qatar and the pair is actually just is
your program so void is just useful will
you'll see it again it just takes an
argument and passes it through and does
nothing with it and then you can see
that true basically takes a consequent
and alternative and vert and invokes a
consequent false does the opposite and
then if takes you know a test a
consequent and an alternative and then
passes those through so if you say if as
a function call if true and then you
know two parameters this you know worked
or if false it will return the second
one
is that is that crazy that you can do
that okay so okay let's I'm moving on to
numbers at this point you might say
numbers aren't really a keyword I know
they aren't but I'm having fun so but
before we get to numbers we're going on
there tangent about pno axioms do people
know piano axioms okay well i will
explain them basically these are a set
of rules that define like natural
numbers you know positive integers
cardinal numbers ordinal numbers call
them what you are we use them to count
and so i think they're like a dozen
dozen key axioms but they can all
basically be boiled down to zero is a
natural number and every natural number
has a number that comes after it so you
can think of numbers not as one two
three four but as zero and the one that
comes after that and the one that comes
after that and the one that comes after
that so back to numbers if you're
wondering where we went with that little
tangent on piano axioms because we're
going to talk about church numerals this
is named after Alonzo Church he was Alan
Turing's doctoral advisor at Princeton
he actually advised a lot of really
famous you know foundational computer
scientists and mathematicians so when
you think of counting basically when you
don't really use numbers apart from
counting two things and so there isn't
anything like inherently great about the
number five except that it's like you
know one more than than for right or
it's the number that your product
manager asked you to put items on the
page but anyways you you just you keep
iterating and that's really what you use
numbers for is iteration so we can
define zero as basically a function that
takes a function and like a zero value
and it just returns the 0 value so
it's like don't do anything with that
function just return whatever was passed
in and then its successor can be defined
as a function that takes a number and
then returns a number that actually just
applies that function to the number so
this is actually a lot like reduce
you'll it will make more sense so you
can think of one is the successor of 0 2
is this a successor of one so on so you
can convert back to native numbers in
JavaScript by basically passing a
function that adds one to whatever it
takes and then 0 so if you convert 0
it'll skip this function and it'll just
return 0 otherwise with one it'll add
it'll pass in 0 it'll add one to that
and then return 1 and you just keep keep
wrapping it and it will keep unwrapping
itself like an onion so that makes sense
ok cool cool so because we know that the
function isn't called for the case of 0
this makes it very convenient to check
through 0 because we can just pass in
true and then have a function that
returns false if it's ever called and so
if you pass in 0 it'll always return
true and if you pass in anything that
iterates it'll always return false so
given that we have represented numbers
with functions we can actually add those
because we're already we're already
iterating right and what is what is math
or what is arithmetic except for like
iterating I'm sure a mathematician would
disagree but we're simplifying things so
basically addition is just do something
n times and then do something M times
and then multiplication is like do
something n times but every time do em
you guys know arithmetic right like
we're all adults yeah so if if you think
about success
sir we already have a function that adds
one so we can tweak that slightly to
basically take two numbers and then do
it do F end times and then do it m times
so you can add one and three and then
convert that back to a number and you'll
get for this shouldn't be like
surprising that like addition is you
know a thing but then if if you want to
multiply we can tweak it so that
basically you can apply em to the
function and then do that end times so
you're just wrapping and so this is all
you know valid JavaScript you can follow
along and then we can add one more
definition so subtraction is basically
ends predecessor M times right but we
haven't talked about finding a
predecessor piano axioms don't really
define a predecessor because everything
starts at zero and goes up but we can
basically add an axiom that says 0 is
its own predecessor and every every
natural number has a predecessor right
so 4 is the successor of three but it's
also the predecessor of 5 or yes 5 and
so this is sort of complicated i didn't
actually derive this i took this from
matt mites blog he's a professor and at
university of utah very smart guy but
basically this will take a and return
the function that represents the number
before it and then when you want to
subtract two you basically just have
this predecessor function and you pass
it to em and then pass that to end so
the predecessor of 3 is 2 and then if
you subtract 4 or subtract three from
four that's one not surprising but
following along ok so if we want to
write code without any keywords
then we can basically define a block
scope and you know take all these
parameters to find them down below and
and then you know some of these
functions depend on functions that we've
already defined so you can't really do
is zero until you have true or false
like it one depends on the other and
then once you execute all of this you
can say like if one is zero then ask why
otherwise send health and this
definitely asks for you to send help but
so you notice everything here is
anonymous right nothing nothing can name
itself which is a problem because they
can't call themselves so you can't have
a function that is totally anonymous
that is unnamed that also somehow knows
how to name itself and then call itself
right they you know years ago this is
sort of based on the lambda calculus
which was developed like in the 20s and
30s and it was it was meant to be a
system of representing formal logic they
wanted to perform proofs in the lambda
calculus and so in order to do that they
really needed to make sure that it was
tried and true and tested and that it
works and it turns out that they found a
paradox in the lambda calculus that you
actually can represent anonymously and
it was sort of it was actually a huge
con for controversy at the time it
started with the you Combinator because
this is very simple you you can wrap a
function in a function and then just
pass it to itself and so you might have
a function add that takes a parameter
called add and that might not be useful
because you would want to probably add
and not just call yourself but you can
so they created so I won't go too far
into the Y Combinator because it is
probably one of the most beaten to death
proved things in math and computer
science but basically what they want to
do is have a function that takes a
function that when it keeps calling
itself it doesn't return new values so
if you keep like wrapping the the output
and sending it back through you get like
a fixed point it won't it won't
fluctuate so you know when you this this
function matches that requirement it's
got a huge problem because it
immediately calls itself and doesn't
stop until your program dies so you can
add a little bit of indirection so that
it doesn't immediately call itself it
returns a function that takes a function
and so basically they you can expand
that out and then you can't have Y in
the definition because it needs to be
anonymous right you can't you can't know
your own name so using the you
Combinator they they basically came up
with this function that says you can you
can wrap a function in this and it will
it will pass in the function so that you
can call itself and that will make more
sense in just a second because we can
put it all together and so this you've
all you've seen before like the is 0 but
up here we take a function called
factorial and so factorial is passed in
and it is defined as the Y Combinator
wrapping a a function factorial or a
parameter factorial and a parameter n
and if n is 0 then return 1 otherwise
multiply n by the factorial of ends
predecessor right we all know and
and at the very end just passing this
this little number back to like back to
the native number and then call call
factorial of 5 and native does anybody
know what factorial 5 is at the top of
your head because it is 120 that's that
is code without keywords there there's
some some further reading on this the
fixed-point combinator you can look up
on Wikipedia Matt might wrote a really
really good blog post that I used a lot
of his code but upgraded cs6 I wrote a
little blog post about this and then you
can find all the slides here and follow
me on on Twitter yeah cool it's a real
website I promised I would love to
answer questions yeah definitely okay
Austin I to your questions that all
right yeah all right oh god this one do
you have all the additions in education
i own none of them I know I know yeah
someone actually told me yesterday that
Gerry Sussman and like how Abelman did
this in a talk and I didn't know it
existed it's very similar okay and also
second thing if you implement double as
a function you can make your
multiplication function blogging times
and because we're doubling each time
when it's an even number that's an odd
oh okay that's that's a good idea yeah
performance here by the way you are you
you are adding in linear time so yeah
it's don't do this Trotter yeah but
you're did you have a question or so
yeah well it's kind of also kind of a
two-parter this is for fun thing right
this is not really oh yeah no like
really don't do this understand how it
works and know that it's possible but
don't like don't do this at home but not
at work right like was there so here yes
because it it ran I'm not sure in line
12 you don't have to use like the plus
you mean yeah the X plus 1 don't you
have to do like suck of one or no no no
so this is being passed in as my
function native and so you compute
factorial of 5 and then you convert it
to a native function and return that and
so that's how we get 120 at the bottom
otherwise you would wind up with a huge
function that nobody understands and
would be very difficult for me to tell
you all is 120 numbers not right but
that's too kind of i'm going to native
JavaScript land for this moment yeah
yeah that that's that's to be fair
though you could've
this is like a subsequent calls to
successor in which you printed one like
the word one up to the word 120 or
something and then didn't F using
keywords that's all I see that that
turns it into actually the number one
yeah yeah and so that's how we get a
result and not just like right right yes
there any other questions okay cool I
hope you had fun so Falkor is actually
it's a it's a new framework that's out
from netflix it's designed around a new
concept is called Jason graph which
we'll get into in a moment and it's all
it's meant to be a way to simplify the
data that's actually being sent to your
client so whether that be a mobile phone
a tablet a desktop only requesting the
data that you need is the key component
to what Falkor is really about and being
able to request multiple attributes from
multiple microservices at the same time
so</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>