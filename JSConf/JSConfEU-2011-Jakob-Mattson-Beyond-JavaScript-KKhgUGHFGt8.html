<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>[JSConfEU 2011] Jakob Mattson: Beyond JavaScript | Coder Coacher - Coaching Coders</title><meta content="[JSConfEU 2011] Jakob Mattson: Beyond JavaScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>[JSConfEU 2011] Jakob Mattson: Beyond JavaScript</b></h2><h5 class="post__date">2013-06-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KKhgUGHFGt8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">ok let's try to get started my name is
Jacob and I work at a company called
Burt we're a Swedish startup in the ad
tech industry doing add analytics and
well being a startup these days means
that you're usually following some some
lean principle like running a lean
startup and we're doing agile
development and promoting agile
advertising for our customers and we're
using dynamically typed programming
languages and and scrum and everything
everything is just so dynamic
all the time except for one tiny tiny
thing javascript is not and sure
javascript is dynamically typed but it's
not really a dynamic programming
language so I will use this talk to
describe what I mean to to make you
understand my thoughts here but I will
start by by explaining how i came to
this conclusion or brother which
experience took me took me through this
i started developing in in high school
and I learned that static checking was
good because I was programming c++ a
horrible first language and I read all
the books by burner in particular design
and evolution of C++ which goes into the
detail of the language itself and this
made me interested in in languages but
the theme kind of one of one of the
things that really stuck with me was
that casting was evil because casting a
variable from one type to another was a
design flaw you've made some mistake in
your code since you have to change
something from one thing to another and
i thought this for years and I i
programmed C++ for maybe three four five
years without
learning any other languages but later I
got some new perspectives when I got
into web I learned SQL I learn PHP Perl
all these wonderful things and in
particular i discovered the Haskell and
if if there are some people here who who
don't know what Haskell is it's a purely
functional programming language which is
statically typed but all the types are
in third so you almost never have to
write the types but still the program
will or the compiler will tell you if
you've done something inconsistent and I
thought hey this is cool but Haskell is
purely functional and that makes it hard
to use and think like you usually do so
I thought why not take the ideas from
Haskell this type inference to some
language that is well more more useful
in general and since I started doing
some web development I had recently
learned javascript and found it to be a
nice little language and it should be
possible to put like a type inference
layer on top of JavaScript was my idea
so so let's combine the best of two
words like type inference and tiny very
useful language and the the idea was
good but the problem was that there are
some features in JavaScript that you
can't really infer at at runtime we're
at at compile time I mean so the the
project was bound to fail I mean it's
not possible to do static checking on
evow on with on looking up keys in an
object using using a string rather than
the dot notation and so on and I thought
that well that wouldn't matter much
because those those features are kinda
creepy right you shouldn't really use
eval and with that's no no no that's
that's bad but the reason it faded the
reason I couldn't just exclude those
things where that most libraries
actually use one of one or another
somewhere somewhere deep in the code and
if you can statically check your
libraries you can't statically check
your own code and the whole thing breaks
so it didn't work but it made me realize
that the real benefit of dynamic
programming language it's not that who I
don't have to write the types it's it's
so easy I don't have to think I can just
experiment and we will see if it blows
up at runtime the real benefit is that
it allows you to do certain things that
you can't do in a static language and I
mean can it's impossible like doing the
eval things and and with and so on and
it made me think that what what other
features are there like this what are
the dynamic languages in the world
actually providing for us what can we do
if we use them instead so I thought
let's learn Ruby Python Lisp all of
these and yeah I was I was just
disappointed they didn't really do what
I expected them to do they didn't use
the full potential of being dynamic so
to speak let me give you some examples
and the top is JavaScript as you as you
probably notice and the second piece of
code is Ruby and the last one is hasco
and well Ruby and javascript is a little
more bloated than the last one and and
why is this you you could reason as much
as you want about why it looks like this
but but the fact is that you can't
change it you can't alter JavaScript to
get a behavior light like the Ruby line
or or like the Haskell line you're stuck
with function you're stuck with return
you're stuck with the parentheses
and the bracket or the curly braces I
mean it's impossible to change the
language itself into accepting something
else even though why is it that way why
does it have to be like that and then we
can look at the operators well in
JavaScript you can't really do anything
with operators at all you can't define
your own you can change them you can't
really you can't really change the
syntax of JavaScript in any way and
these two operators are particularly
nasty because they do lazy evaluation or
a short circuiting if you will which
means that the the or operator will not
evaluate the second argument if the
first argument evaluates to true and
that is also something that's impossible
to do yourself you can't create that
behavior unless you add a lot of sugar
like your rabbit in a function and make
it a lot more complicated why and then
there's this thing everyone keeps
yelling that all these modern
dynamically typed languages in in them
everything is an object everything is an
object I can manipulate the strings the
numbers everything everything but
everything is not an object I'm not sure
what your definition of everything is
but my definition of everything is
everything in JavaScript function the
keyword function that's not an object
the parentheses the dots these things
are not objects they could be if the
function function keyword was an object
we could assign it to something we could
say F equals function and then we could
write F when creating functions rather
than writing functions function which
would be a lot easier and well we can't
everything is not an object so I
actually changed my mind when it comes
to thinking about what what the language
can do what's a good and a bad language
because instead of thinking like let's
call the language blob
if you read anything by yeah exactly by
Paul Graham thanks you recognize the
name so this is my anonymous language
instead of asking yourself what can blob
do that that don't ask that
question ask yourself what is it that
that blob can't do because if you see
what a language can do you you start
like discovering what's possible it's
hard to make up new scenarios if you
don't think that way and also I think
it's it's not very easy to to design the
language by sitting down and thinking
what do I want to do because it's not
about a particular solution you're not
trying to solve a particular problem
you're creating a programming language
that's like the most generic thing you
can build it's the language will be used
to build a framework which will be used
to build an application that someone
else we use and so on like the language
is at the very bottom it should be as
generic as possible so you can't really
put a task 2211 guy or girl to like our
create a programming language and think
of all the kinds of scenarios that all
we as developers will want to use it for
you can't do that you can solve a
particular thing that's the job of a
framework so instead it's about doing as
little as possible do the easiest thing
you can and that's not that's not easier
actually because what you have to do is
that you have to find the set of
primitives that are the most generic
ones that allows someone to shape your
language into whatever they want to use
it for and they have to be as few as
possible because the more things you put
into the language the more you encode
like ideas and concepts and everything
that you want like the way you want the
user to think or the programmer I mean
so if you don't put a lot of stuff in
you don't force the programmer to behave
in a certain way and that's kind of the
main value as i see it of a programming
language that a dynamic language or well
preferably at any language but it has to
be dynamic to satisfy this is that it
should be malleable and moldable which
means that you should be able to change
it into whatever you want if you don't
like writing function when you create
your functions then you should be able
to change that and you should also not
just be able to everything should not be
fluid all the time like water you should
be able to to fix it when you want to
like make something fixed which is
exactly what I mean when I say that it
should be moldable so a language should
be like a dough you're like massaging it
and and making something out of it but
it's not predetermined what what that is
and that's actually the best part the
best part when with a good language is
that you don't know what the best part
will be because you leave that up to
someone else to decide they can use your
dough to create something awesome
themselves and this is where where the
fact comes in that you as a language
designer cannot create the perfect like
the perfect solution to everything
yourself you have to create something
that others can change to actually map
onto a problem and solve something so
now we are wondering this conference is
about JavaScript who brought this guy
here what is he talking about and
there's there's three reasons why I
think that these questions are
interesting when it comes to JavaScript
when you try to like think of a new
language think of what you would like to
do and the first one is regarding like
what's what the language does and what
it should do what it shouldn't do and I
mean javascript is just so full of
so there's so many bad
balls like don't do this don't do this
don't do this don't do this very very
much to learn from and secondly and this
might be the most important point is
that currently it's like a platform for
everything and now i'm using everything
in the same sloppy sense that everyone
else is using everything because it's
not a platform for everything but when
you're doing web these days you have to
work with javascript because javascript
is known the language the runs in the
browser and more and more things come to
the world of the browser these days so
if you want to make a new language that
targets the browser you will have to
think of javascript how will this new
language play with javascript how can we
make them interact with each other in
order to reuse all that's already out
there and third javascript actually has
some amazing ideas it contains a lot of
good good stuff like functions are first
class objects behave like caches or hash
maps you can look up all the properties
and functions and everything like a hash
and it's very tiny in general it's not a
big bloated language and the prototyping
is at least to me a more pure idea of
inheritance than the classical model
employed by Java or C++ because you can
build something that behaves kind of
like classical inheritance using
prototyping but you can simplify the
classical model if that's what you have
so it has a lot of good ideas and I
think that will play well with a new
language that could create that embodies
these new ideas and and the new things
that I'm thinking of the primitives that
you would really want in a language to
make it really really dynamic really
moldable are those are three things as
well and the first one of those is to
have called by name instead of call by
value all or call by reference and if
not all of you understand what that
means it's passing a value to offer
like a copy of the original value that's
called by value called by reference
means that you pass a reference to the
original object and call by name means
that you pass the actual name of what
you're sending in the symbol or the
expression itself which allows you to do
things that don't evaluate immediately
but for example think of this like tank
of severed do kodesh JavaScript the code
where we have a lazy function which
doesn't evaluate its arguments when they
are first passed in but rather can use
some kind of executes statement to to
actually evaluate those if we had that
and well if we had could could assign
values to operators we could implement
the end operator ourselves because we
would not have to evaluate be if a is
false and the cool thing is that if you
have this functionality you can
implement the regular one because if you
just take all the arguments and start by
evaluating them left to right you get
the regular function behavior like the
everything is evaluated before the
function starts so this is a more
generic primitive to construct your
language from secondly we need operators
and I don't just mean having operators
like in JavaScript I mean operators on
freaking steroids so so they can do
anything you want we're not anything but
more things and i took this example from
from well Ruby or coffee script or other
languages has the the unless statement
maybe you used coffee script and and
seen this what it means is that we will
assign V to be a plus B unless X is
larger than y so that's kind of an
operator a lazy one again it evaluates
the right part first and then it runs
the left part if depending on the
truthiness some of the right part and in
CoffeeScript this has
has been like a put into the language
they have entered the unless statement
into the grammar of the language itself
which is exactly the wrong way to do it
in my opinion if you really want an
unless statement and you have to create
a new language to get it what does that
tell you then you're not really solving
the problem by doing what CoffeeScript
does you're just saying I have a better
idea I will provide the people with this
solution and they can use that instead
and if that idea is not awesome or
someone else has a good idea well then
you're screwed again you haven't solved
the actual issue so what I would like to
do instead is to be able to say that at
runtime like I want the word unless to
behave like an operator and I wanted to
evaluate either the left or the right
side first and I wanted to have this and
these proceedings so it gets executed
before or after other operators as I
want to so it when it's actually run
turns into something that looks more
like this not actual code again but just
so you can think of what it does so
unless would then be a method on the
boolean type so as long as you define
unless as an operator and you create a
function that's called unless it will be
invoked well like this if everything
works the way you you intended it to
sorry
so that's exactly one can you hear me
well none is it good it's okay thank you
so this is the thing you have to find
the primitives that will allow you to
create the new features that you want by
not creating a new programming language
but bending the one you have into new
into a new shape so that was called by
name and it was operators the third one
is syntax unification which is what
leads make sense at this is this is like
the whole thing that is list everything
looks the same you have your parentheses
and that's it then you can play with
them the bad part about this place that
you have to play with the parentheses
you can't add operators you can't make
things that read better than a whole
bunch of parentheses and well just lots
of nested statement but we still need
that part as well because then we would
be we would have the possibility to
actually implement something that looked
like this that I showed you in the first
code example if filter would be a
function that was taking its arguments
in the lazy way and not just evaluating
them right away this would be okay to
begin with because it wouldn't evaluate
the arguments and argument this kind of
invalid so it's not okay to to evaluate
it but when it passes it to the to the
function it should not just pass like
this dream greater than zero it should
parse that as if it were a program which
we want it to be and create something
like this like this is a message and it
has a name and it has a list of
arguments and the arguments could be new
messages doing new things it could be a
whole freaking program in there
and then you pass that to the function
and instead of saying like execute
evaluate this statement or this
expression you you send the expression
to an object so here we're we're
implementing filter by creating a new
empty array and looking through this
array and for each element we send this
this expression that we received to this
object so so he becomes the target of
the expression we sent in and suddenly
it's meaningful e greater than 0 and if
it is we push it onto our and what
return our when we're finished so as
long as every statement in the program
is parsed to to a syntax tree like like
this or something like it and not just
looked upon as a piece of like like a
string which we have in JavaScript with
the eval statement we can pass a string
to it and we can evaluate arbitrary code
but if we actually parsed it and got the
data as it looked we could manipulate it
in more more meaningful ways and we
could change things a lot in here we
could not just send the message to a
target object but we could manipulate
the message first we could change the
zero in in the argument to something
else or we could could reshape it in
some other way and and as you see I I
don't really know what we could use it
for but that's the point it gives you
power to do things and it gives you the
power to make up what you should use it
for it it's not my job to say what what
you should do with it so that's the
third point so to start like wrapping up
we're not really there yet we're not
using the full potential of dynamic
languages we are just like scratching
the surface and I think the reason is
most of the languages we use today were
developed quite a long time ago like
javascript is like 16 years old now ruby
was created in the beginning
the 90s JavaScript as Java as well even
if it's not one of the dynamic languages
and that age put certain restrictions on
the performance people thought that well
it has to at least be kind of fast but
we know now that there's room for
different languages there's room for
four options I mean everything we use
don't have to be performant all the time
if it would had have to we would still
be using assembler so when people say
well what about safety and and what
about performance I just say well safety
go back to using Java come on if you
don't want to shoot yourself in the foot
you shouldn't even be using javascript
to to begin with the same thing applies
here if you want safety you create it
yourself you write tests you follow
conventions you learn from other you
avoid the Troublesome parts of the
language and so on if safety is what you
want don't use our dynamic language and
if you use a dynamic language stop
caring about safety don't say it's not
safe if you can manipulate everything
and change everything and no one
understands what you're doing that's
just not valid and then as for the
performance like I said performance it's
just a matter of time you can't really
you it's going to be optimized over time
compilers become better our Hardware
becomes better we're always taking new
steps so we would still be doing like
assembler or see if if we never thought
about new languages so once again don't
ask yourself what your language can do
for current language or your ideal
language ask yourself what is it that I
can't do what what would happen if I
could do those things because let's face
it every program
language today is turing-complete they
can all solve the exact same set of
problems except changing themselves only
a truly dynamic programming language can
do that Thank
two things if you're interested in
seeing what what's becoming of these
thoughts follow me on Twitter and I will
keep you updated I promise there will be
something open source very soon secondly
I would love to answer all of your
questions but I think it's much more
interesting to take while and discuss it
so just come up to me after this and ask
anything you want and we'll talk about
it and all of you can do it if you want
to so thanks again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>