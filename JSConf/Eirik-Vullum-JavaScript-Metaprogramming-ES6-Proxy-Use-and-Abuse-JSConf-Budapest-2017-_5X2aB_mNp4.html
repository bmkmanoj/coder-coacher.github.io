<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Eirik Vullum: JavaScript Metaprogramming - ES6 Proxy Use and Abuse | JSConf Budapest 2017 | Coder Coacher - Coaching Coders</title><meta content="Eirik Vullum: JavaScript Metaprogramming - ES6 Proxy Use and Abuse | JSConf Budapest 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Eirik Vullum: JavaScript Metaprogramming - ES6 Proxy Use and Abuse | JSConf Budapest 2017</b></h2><h5 class="post__date">2017-12-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_5X2aB_mNp4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- sound yeah okay yeah thanks so much
for having me
just to get a slight feel how many of
you have ever done any metaprogramming
show me a hand so it's sort of a trick
question because I'm I'm pretty sure if
you've ever programmed in JavaScript
you've done some meta programming just
don't know it I'm Eric I'm an
independent consultant and JavaScript
trainer from Oslo and I spent most of my
days either building things in
JavaScript or teaching JavaScript and
the react stack and for a while now I've
been pretty hung up on meta programming
and when I think about meta programming
I think about these guys Wizards doing
wizard II things because at first at
least it feels a lot of it feels
indistinguishable from magic
but what is meta programming so I try to
ask Wikipedia and ditka pedia says that
meta programming is the ability to treat
programs as data and the ability to read
generate analyze or transform other
programs and even modify itself while
running so I think I'll go with that
and there's two main branches of meta
programming one of them is macros and
macros enables you to create your own
syntax so here's an example where we use
sweet J's which is a macro system for
JavaScript to create some custom syntax
so I'll make my own syntax here and I
can use that syntax in my code and
before that code actually runs it gets
compiled to whatever that syntax means
and you can also make your own operators
so let's say that I'm really tired of
saying dot then I don't like writing dot
then
chaining promises so I'm making my own
operator for that so now I can use that
operator in my code and before that code
actually runs its compiled down to
actual promise chaining so you can use
macros then to sort of extend your
language create your own dream language
and all of this stuff happens during
compile time or possibly and something
called macro expansion time at least it
happens before your code runs and that
second branch is reflection and
reflection has some sub branches where
one of them is introspection meaning
that you can the code connects inspect
itself during runtime
you have self modification meaning that
you can change your code during runtime
and then you have this thing called
inner session meaning that the code can
intercept and intervene with itself so a
simple example of introspection would be
let's say we have an object with some
properties here and I use object keys to
check which properties exist on this
object and it gives me a result back so
this is some of the one of the simplest
examples of introspection and then you
have self modification let's say that I
have a function I have a grumpy some
function that usually returns the sum of
a and B but if you ever pass an A that's
larger than five it'll just rewrite
itself to just return zero so if I pass
one plus one that's two if I pass ten
plus one that's eleven but then it just
starts returning zero so we've actually
changed the functionality here during
the runtime while our code is running
and then we have inner session
intercession is something that you can
do in JavaScript already sort of by
using object defined property
so let's say we have a hero here and he
has a health property but we also want
to have a status field that is somehow
based on his health so we'll define a
new property status and we'll define a
getter for that saying that if his
health is larger than 50 he is fit like
a champ otherwise he's badly hurt so
here we have a property which functions
based on the runtime conditions but this
sort of of intercession in JavaScript is
pretty limited so all of this reflection
stuff happens during runtime while our
code is running and that brings us over
to it's a very natural question now is
why is all of this useful why do we need
this so I went and asked Wikipedia again
and Wikipedia's answer is in some cases
this allows programmers to minimize the
number of lines of code to express a
solution and thus reducing the
development time I think I think I'd
rather say that the reason why this is
very useful is because we want as much
expressivity as possible to model our
problems and what we want is these
elegant and developer friendly
interfaces and this brings me to an
interface that I'm pretty sure that a
lot of you are familiar with which is
proxies in the form of proxies on the
web so a proxy is usually a server
placed in front of one or more servers
and this is to abstract the way
complexity and to provide a single
interface for the consumer so this
enables you to actually intercept any
any interaction with the interface and
the use cases might be load balancing it
might be delegating based on where the
resources are and so on but the main
thing is that you're providing a single
unified interface for the consumer
hiding all these implementation details
and we can apply this concept more
generally it doesn't have to be servers
so we could instead place a proxy in
front of a set of objects we can
intercept any type of access to these
objects and provide an abstraction to
hide implementation details and this is
what is made possible with proxies that
was introduced in es6 and what this
enables is a much more powerful form of
intercession among other things in
JavaScript and generally this means that
we are now able to intercept and define
custom behavior for fundamental
operations on objects so that means
properly lookup assignment enumeration
even function invocation and so on and
this is a very interesting feature for
another reason as well because this is
one of the few features that essentially
requires engine support unlike most of
use six which is syntax sugar that can
be transpiled using Babel for example
this isn't actually viable with proxies
but thankfully the support has become
pretty good except ie
which hopefully yeah doesn't stop you
so the proxy in JavaScript has its own
constructor and the constructor takes a
target object and a handler object and
this target object can be any type of
object it can be a plane object it can
be an array it can be a function because
functions are objects in JavaScript
it can even be another proxy so you can
proxy a proxy another important thing
about proxies is that they're completely
transparent so if I say that I'm
creating a proxy here with a plain
object as the target if I check type of
of this proxy it'll give me object so
there's no such thing as a proxy type
it's entirely transparent and then
there's the handler object and this is
where we define so-called traps for all
of these operations that you can do on
objects and here's an example with a
getter trap where we say that if you
ever try to get a property from this
object we'll just return 37 so we can
create a new proxy using that Handler
and if I try to access a from this
object or B from this object it'll just
keep returning 37 and for any available
fundamental operation there is a
corresponding trap so you have a getter
trap you have a setter has apply and so
on and you also have this accompanying
new api called the reflect api which can
be used to perform all of these
operations on objects and an example of
this is let's say we have an object here
with a property we can use reflect get
to say that we want to get the health
property from this hero object so in the
same way that there is a trap for every
operation there is
a corresponding method in the reflect
API so if we do a complete one-to-one
mapping here you'll get a proxy that is
just a pure relay it doesn't do anything
it'll behave the object will behave just
as it would have if you didn't wrap it
in a proxy so the nice thing now is that
as I said you can have overload a lot of
these fundamental operations like the
dot operator the equals and the function
call and one example of this is let's
say we wanted to add some
instrumentation to our code so we'll
create a function that's called log
access to properties it takes an object
and we return a proxy with that object
as the target object and then we pass it
a handler object with a getter trap
saying that ok if you ever try to get
something from this object I'll log out
whatever you try to get and then I'll
return a result of actually getting that
and we can also add a setter trap saying
that if you try to set something will
log out whatever you try to set and then
we'll set that on the object and the
nice thing here is that the object that
is being wrapped in a proxy doesn't know
about it and the proxy doesn't have to
know anything about the object it's
wrapping so it's completely decoupled so
if you use this now we can create an
object a bit like here we can create an
object with some properties and then we
can create a proxy using this function
log access to properties so whenever I
try to access a property here now it'll
log out the access and if I try to
change something it'll log out whatever
you changed and we can also use proxies
to make observable objects pretty easily
so let's say we create us as a function
called observable which takes an object
that you want to observe and then it
takes an unchanged function
we'll call whenever something changes
we'll return a new proxy put the object
in the target putting a handler which
has a set trap so whenever you try to
set something on this object will
actually set it and then afterwards
we'll call the unchanged method with
whatever you updated so if you want to
use this this isn't actually as useful
as true observables because we have to
overwrite the original object but now we
can create an object here that is
observable so if I ever change if I
change the name here it'll log out name
change to Frank if I change the age
it'll log out the age change to 40 so
all of this is nice but it's not really
something that would revolutionize how
you write code in JavaScript so I tried
to I try to think about I didn't really
want to do this talk before I had
something useful to do do you use
proxies for so for the last year I've
been working on a client project with a
lot of people where we have a large
amount of real-time data
think something like firebase and we
have a lot of data that looks like this
let's say we have we have a collection
we have a collection of stories and
every story has an ID it has a title it
has an author it has a list of people
that have liked this story that have
read this story and so on and what you
can see here is that it's just
references and we can also imagine that
we have another list here of people and
these people have authored books they
have read books they have liked books so
what we see here is that these
references are actually pointing to
different objects so the person one here
is pointing to person one in our
in our people collection and story one
here is are all pointing to the first
story so what we really have here is
it's sort of a graph so if we just
consolidate this into an object we have
a collection of stories and we have a
collection of people and they're all
connected together in different ways so
what does it look like if you want to
traverse this thing let's say you want
you need to traverse this thing very
deeply so we can start out then let's
say we want to find we want to find the
name of the first person that liked the
first story so we'll go into the graph
we'll pull out the first story we'll
pull out the array of references but to
people who have liked it we'll have to
map it so that we can actually map it
over to the actual objects and then
you'll have to choose the first element
of that and then we can pull out the
name or if you want to find the title of
the first like story by the author this
is getting pretty deep now we'll have to
get the right collection based on this
reference we'll have to find the correct
author and then we can pull out the
title from there this gets really
tedious it would be so much better if we
could just access this like it was a
plain object so that we can go into the
first story we can go into the like by
list and then just assume that that's
the actual object not just a reference
and the same thing with the title here
so this is really this would be a much
better interface to interact with this
graph so what we really want our data to
look like is something like this because
what we have is just a reference here we
are
we're in story one and it has an author
but what we really want is that author
to be that object and again that has a
list of stories that the author has
liked and we would just rather have that
be the actual story and so on
and this goes on infinitely right
because this is circular so we need some
kind of way of transforming this object
that contains only references to an
actually populated object here so let's
imagine that we could create an
interface a function called populate
which would take the graph as an
argument and then the node you wanted to
populate so as an example we we would
want to have a populated version of the
first story in our list but how could we
ever implement this so the naive
approach would be that okay I'll just
use something like object a sign and
just I don't know just keep filling this
in recursively and until something just
blows up right because it's infinite
it's not possible it's just not possible
to to do this in something that needs to
evaluate upfront but this is a really
nice use case for proxies
so with proxies you can actually make
this work because even if it seems like
we have to do this upfront really really
don't have to because with proxies just
like with proxy web servers we could
just say that okay I'm in story zero and
I access the author but instead of
actually returning the reference we
could just redirect you to that actual
object in the people collection and if
you then access the story there we would
just
we direct you back so now using proxies
we can actually have this nice interface
by pretending that this is an infinitely
nested object except it's just too flat
lists in JSON and I'm wanted to show
some code examples for how to do this
but they just did not fit in to the
slides in any a reasonable way so if
anyone wants to take a look there's a
open-source version of this and now I
felt really excited because for the
first time I felt that I had some proper
use case for proxies because this was
something that you couldn't do without
proxies so I started to think about
other things that I could use this for
and thing I got a really good idea
because we all have a beef with
JavaScript right undefined it's not a
function and cannot read properties
something something of undefined and and
yes I know about typescript and flow but
there's no fun in that so with this as a
starting point I figured all right I'm
done with undefined not being a function
so first up I want to redefine undefined
so this is my own undefined and it's
actually going to be a function the
target object is a function just the
empty function and I'll declare that
this is gonna have a getter trap so
whenever I try to get something from
undefined notice that there's one kind
of Lee key thing here is that functions
need to have names so I had to kind of
shim the name in here so that if you
ever access name this doesn't you can't
change any further on that but I'll just
return undefined again so if you try to
access something
and then just get another undefined and
if you ever tried to call undefined as a
function I'll just return undefined
again so now I figured we just need to
make some seat belts for JavaScript so
we have a function here that takes an
object and it returns a proxy of that
object and says that if you ever try to
get something from this object will
check does this property actually exist
if it does if it doesn't it's an object
will return another seat belt wrapped
version of that object so that you can
get this recursively but if that
property doesn't exist meaning that it's
undefined or no we'll just return our
new undefined here and if it does exist
we'll return the property that you tried
to get so we can create a an object here
now using the seat belt function just a
plane object that has some properties
with some values seems to work fine I
can access foo I can access this nested
field I can access name and so on but I
can also do this now I can access
something that's not here and something
other that's not here that definitely
isn't a function call that as a function
and then pull out something else and you
know what function is not undefined it's
actually a function so now you can do
things like this so no more crashing
you've got seat belts but as I was I was
pretty pleased with myself this was I
don't know 4 a.m. some
but there's just one bump in the road
and that is I figured so this is nice
but I still have to use this seatbelt
thing I don't want to do that I want
this to be automatic so I tried to do
this I wanted to set the prototype as a
seatbelt object and it turns out that it
turns out that someone smart had figured
out that this is not good
and now this prototype object the bottom
level prototype is a so-called exotic
object so you cannot override the
prototype I even tried to look for any
version that implemented proxies but not
this exotic object and I even considered
compiling my own v8 for node and then
making this work but I figured I'm just
too far down the rabbit hole this is
ridiculous so I figured I'm taking it
too far but it would have been fun so
with this I was really sad about that
but in conclusion you can use proxies
for a lot of good things you can make
really powerful abstractions and you can
add a lot of functionality transparently
but the bad thing is that you can also
just mangle things completely and
introduce a lot of magic so that
JavaScript doesn't really behave like
JavaScript anymore but all in all I
think this is another great tool in your
toolbox to build your dream interfaces
so you should go ahead and figure out if
you have some kind of thing you want to
solve that just doesn't work in plain
JavaScript you should try to see if
proxies can help you with that and
that's it
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>