<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Myles Borins: Node.js Versions - How Do They Work? - JSConf.Asia 2016 | Coder Coacher - Coaching Coders</title><meta content="Myles Borins: Node.js Versions - How Do They Work? - JSConf.Asia 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Myles Borins: Node.js Versions - How Do They Work? - JSConf.Asia 2016</b></h2><h5 class="post__date">2016-12-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3gkm7oafWxs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">salamat petang thank you so much all for
being here I put this in front of every
one of my presentations it's a lot of
fun and I'll just stare at it can we get
the house lights lowered please pardon
so I look up at this cat and I just kind
of reach I just do this generally not
this long but again I'm just stalling
for the lights and it calms me down as
long as you keep laughing I'm going to
keep doing it
okay that seems good I'm so much more
relaxed now okay so let's let's talk
about node versions so my name is miles
I work for a small disruptive startup
called IBM and I contribute to a small
platform called nodejs it's worth
mentioning you'll see cut at the bottom
here the opinions in this talk are my
own you know you got to just say that if
you're ever up on stage I advise that
you say that always cover yourself but
so version how do they work so it turns
out you know versions are versions are a
lot like magnets and stick with me on
this for a second versions versions are
a lot like magnets primarily in the way
that many people are pretty darn
confused about how they work like how do
magnets work I don't know how two
versions work well I do know so that's
why I'm here I'm going to tell you about
it but you know real talk this stuff is
complicated there's a lot of moving
parts and trying to hold it all in your
head at one time can be really hard
especially if it's not something that
you're used to but you know the nice
thing here is that you don't actually
need to understand everything to
contribute in a meaningful way I think
this is a really great takeaway for
software in general or even just you
know like life but you don't need to
understand everything to make a
difference to contribute and to help
make a difference so what we're going to
do is we're going to start with a small
piece we're going to break it down and
figure out how this becomes something
bigger and the first small piece to talk
about is semantic versioning Rico is
awesome and brought it up earlier and
you know we see this in any of you have
written code how many of you have have
heard of semantic versioning before can
I just see hands that's awesome that's a
lot of you for those of you who haven't
any time you see a version number that
version number can be semantic
versioning I'll say can be because some
people just like to put random numbers
in front of their code and it doesn't
mean anything but what semantic
versioning is is it's a contract it's a
contract from the people who
we're developing the code to the people
are using the code to let them know how
the code works and what kind of changes
to expect them between versions we have
the major the minor and the patch
version numbers and so let's talk a
little bit about what those are
assembler a patch is any change which
does not add new features and does not
break any expected behavior a patch
change can be an update to documentation
it can be an update to a test it can be
an optimization to make something faster
it could be a bug fix there's a whole
list of things that can come in
assembler patch and basically as I was
saying the only thing that's important
is it's not a new feature and it doesn't
change behavior what's a minor so a
minor is anything that adds any new
functionality to a piece of code this
can be a new function this can be an
extended API this could be this could be
a new feature that isn't even something
that you directly call on but it just
kind of changes the way things work any
time that you add something new to a
code and you're doing a release you
should do that release as December minor
a December major is any change that's
breaking that could be changing the name
of a function that could be changing the
functionality of a return in the node
project we even consider changing error
messages assembler major because of how
many people rely on our error messages
for making decisions or for checking
things you may be doing like a catch and
then making a change based on the catch
of a throw so we'll get more into
examples of things that are breaking a
little bit later so node has a number of
different release lines we have the
current release line which is most
recently released v seven point two
point zero that was released on Tuesday
or as I've learned on Wednesday in
Singapore we have active LTS there's
versions 6.9 point 1 and version four
point six point two these are two
different release lines v4 has been
being released a little bit longer and
v6 is a little more is a little newer v6
was actually moved in
LTS about a month ago and we'll talk a
little bit more about what LTS is it
stands for long-term support and we have
maintenance LT LT s and you're going to
see these 0 1217 you'll notice that V 0
10 is not on there anymore which is
really great 10 was around for a long
time and it's it's great that we don't
need to maintain it anymore because it
was very different than all the other
releases and we'll talk about why so as
I said the 0-10 is no longer mint
maintained and v-0 12 is actually going
to be end of life in December so if any
of you are running note and production
at your company's and you currently have
stuff running on V 0 10 or V 0 12 you
should work on getting that upgraded as
soon as possible and we'll talk a little
bit later about what versions to use and
and why so you know we were talking
about V 0 10 and then V 0 12 and then
all of a sudden we jump to v4 and v6 so
where the heck did V 1 through 3 go and
what's the deal with 12 and where's 5
there's all these different numbers what
do they mean so when node when the node
project was started you had even an odd
releases and the even releases were
stable releases and the odd releases
were unstable releases and for a very
long time you would have you know like
v08 and that was a stable release and it
was expected not to have any breaking
changes on it and then you would have V
0 11 we're more experimental things
would happen v9 we're more expensive
things would happen and then when they
were ready for a bump they would bump up
to an even number again you're going to
notice there's an interesting pattern in
cember if you do not have a 1 in the
first digit your sembra minor digit
actually becomes December major digit
and you're cember patch digit becomes
your sin ver minor digit and you end up
losing the granularity of even having
the idea of assembler patch this is a
problem if you want to follow some ver
direct like to the key and the spec and
that's why actually a lot of people
suggest that you start your code at
version 1 point 0 which may not be
entirely intuitive based on practices in
the past many people would wait until
their code base was stable and reliable
before going to one and using going to
one as a way to signal that personally I
think having that extra grand
molarity and the ability to stick
December is way more important people
will know the stability based on your
documentation so it started taking a
really long time to get to v-0 12 the
0-10 was the stable version of node for
almost two years in the path 20 12
wasn't entirely clear and even more so
than that the path to v1 was like
completely people had no idea when node
was going to go to v1 and start being
able to properly follow cember and a
number of people on the project fed up
with waiting fork the project in
December of 2014 it's hard to believe
that it's almost been two years since I
ojs when they forked the project they
did what is actually interestingly the
correct cember thing and they released
it as one point oh so this new I ojs
project came out it came out with
version 1 point 0 they still released
binaries that were called node and you
could have the choice to go and download
node V 0 10 or you could go and download
I ojs one and so as that project moved
forward it just did more releases in the
februari of 2015 right before node
summit joint released v 0 12 v 0 dot 12
did not have any of the updates that
were happening in the I ojs project and
had a slightly updated version of v8
which was still quite old unfortunately
and I had some updates to
internationalization which was very
useful but it had still continued to go
further away from the direction that a
lot of the community had been working on
so during this time the I ojs project
move forward in n cuts version 1 2 and 3
based on semantic versioning they had an
extremely aggressive release process
where basically anytime that something
was agreed on that it should be landed
it just landed and when they cut a
release they would just cut a release
with the appropriate December to signal
the release line this is really great as
a way to move a project forward quickly
and there was a lot of ground to catch
up on the node project but this isn't
the best way to do something when you
have a project that's being run in
production by companies such as NASA and
paypal and netflix they need something
that's a little bit more reliable and
you can't be expecting your teams to do
assembler major bump every other week
and have to fix broken stuff so node was
put in a foundation
and the projects I ojs and node were
merged as version four point oh in
September of 2015 this is around the
same time that I started working on the
project so what we have up here is our
release schedule for nodejs so what you
can see up here is node 0 10 which ended
maintenance in October 2016 we could see
that 0 12 had a current release and a
top in October 2015 and moved into
active LTS and then it was a maintenance
until December at which wich point
december 31st of this year we're going
to be deprecating node V 0 12 you'll see
we have master here and we'll talk a
little bit more about that and how we
manage the different versions and we
have knowed v4 note before is the is the
first LTS release of node it is
currently in an active LTS release
process we'll talk a little bit more
about that in a bit and in April of 2017
that will move to maintenance node v5
was a current release from October 2015
until a little bit after April 2016 so
the way that it works right now is we
have our current release line every six
months we do a cember major bump and
every even release is a release that's
going to go into into LTS and have you
every odd release is a release that
would be deprecated after the release
process so you can see lower down how we
have the same release process for v6 and
we have v7 which is the current release
which will be end of life you know in in
October when we bump to v8 so what
you'll notice on here is that we have an
active LTS in a maintenance LTS so long
term support lasts for 30 months after
the branch has moved out of the current
release stream you have 18 months of
active back boarding and 12 months of
maintenance back boarding so let's take
a little bit more into that so current
which right now is v7 gets every commit
that lands on to master that is in
cember major so every week or every
other week depending on how many commits
are sitting on master will cut a new
version of the current release line that
will get a bump to either cember minor
or cember patch depending on the commits
that are in that are sitting on master
everything gets in there these can be
updates that may actually have the
potential of a regression
the purpose of this is that by living on
the current release lining going out
into production for individuals we can
catch regressions that we're not
catching in our review or testing
process quickly and before it ends up
reaching in LTS so active LTS is the
process of back porting commits that
have landed into the current release
line onto our active release line so are
right now v4 and v6 are both active LTS
and so we go through when we audit every
commit that's landed on on master that
have moved into current that's been in a
release for at least two weeks the idea
here is that what these can be updates
to tests updates to documentation and
bug fixes we generally do not backports
ember major commits assembler december
minor commits to LTS but if something
makes sense and has a very very low
probability of causing breakages we have
a working group that will vote on it and
sometimes we'll backports ember minor
stuff an example of that would be we're
in the process of releasing some new
symbols for openssl to windows so
there's a lot of hacks that exist in the
ecosystem right now to be able to act to
access some openssl symbols when writing
native modules on windows and buyback
porting this we're able to actually get
this fixed in production we have
companies such as PayPal who have come
to us and told us that they're floating
these commits already in production on
the LTS release lines so we know that
it's stable we know that there's a very
low chance of breaking things so it
makes sense to backport it so we also
have maintenance LTS that's the last 12
months of the 30-month cycle maitenance
LTS is not going to have the same active
back porting we're not going back and
getting as many things as possible
landed what we're doing is we're making
sure that if there's major security
vulnerabilities or major bugs that are
found that we're patching them in
releasing security updates so this
happens whenever there's a cv for
something like openssl which there's
been a couple releases on v12 and v10 in
the last six months for those this could
be a bug that's found we've had security
releases for our own modules for HTTP
we've had security releases for a number
of other other dependents that we ship
this is really important we want to make
sure that if you go and put something
into production on note if you went and
put something in production on node V
for when it when LTS a
year ago you're going to have three
years of support where you don't have to
worry about things breaking or about
vulnerabilities well you have your code
in there and we believe that that's
enough time to give you an upgrade path
for your things that you have sitting in
production so what about master we've
talked about master a little bit but I
didn't talk too much about how we land
things master is a special case any
commit that gets approved lands directly
into master we don't have a dev branch
we don't have any special branch for
master we have master and then our
release lines that branch off of that
any cember major commit any sin ver
patch commit any sin ver minor commit
they all just go right into master and
then we cherry pick off of master to our
release lines when we're ready to do
releases what this means is if you're
ever running off the nightly version of
node that's built off the head which
would right now be a nightly a v8 you
have the opportunity or potential of
getting major changes that are sitting
there we tend to not land december
majors right away all the time we give
it a lot of time but we also cut off
cember majors landing on to master about
a month before we're about to cut a
release so that we have the proper time
to run an air RC + beta + test the
things aren't going to break things for
people so how do we manage all of this
magic mostly and particularly
particularly we do it with get magic and
what I really love about get magic is
that get magic is magic with trees and
that basically makes us elves which I'm
really into but so we maintain release
branches and this is what's important we
have a zero 12x French a 4x branch a6x
branch and a7x branch these are our
release branch lines we also have
staging branches 12x staging 4x staging
6x staging and 7x staging each of these
staging branches are where we'll we'll
cherry-pick commits off of master in
between releases so most changes as I
said have to live in a release for at
least two weeks before they'll be back
ported to the LTS staging but as soon as
something lands on master it can land on
7x staging now the only time where this
is an entirely
true is for documentation updates or
sometimes for tooling updates we won't
actually wait for things to go out
because we need to like for a tap
reporter update for example we need our
entire CI release working on all of our
different branches so it's not a like
fast and hard rule but for anything that
has any potential of breaking things it
needs to be in production before we
landed on LTS so let's do a little bit
of a demo and I'm going to be having a
screen up here so if you can't read it
just all of you together just scream
enhance and I'll zoom in a little bit so
you can see but see here's here's the
nodejs repo and I'm going to show you a
little bit of how our release process
works so we can go here to pull requests
and you know I'm just going to go and
grab a random pull request that I
definitely haven't audited or thought
that I'm going to use as an example here
this is by my friend Francis it's a new
commit that allows test dot pi to use
the full path of a test so this is
actually really useful for us we have a
test runner and the test runner is
written in Python if you go to run that
test runner you can run individual tests
unfortunately the test runner was
designed that you can't actually pass
the full test so if we take a look here
if we had the word test in front and the
dot J s at the end the test runner
actually wouldn't recognize that path
what it would recognize is without the
test directory and without the j s at
the end and that's not really useful if
you're working on your own machine and
one or on your own test so Francis went
through and basically all it does is
normalize the path in case you have
tests in front and gf's at the at the
end and this allows us to now run
individual tests so what we can do here
is we can go and grab this commit and we
could copy the link this is a really
cool thing will go and look at when we
open it here we could see the commit so
github actually has this amazing feature
where you can add dot patch to the end
of a commit they broke it actually so
you need to like I have a little regex
that fixes that but now we get this get
mail message come and grab me later if
you want to learn more about what a mail
messages but it's the old way in which
the gate project used to pass around
commits and you can float a mail message
directly onto a tree without having any
expected changes happening to that tree
so it's really great about this is we
can take those mail messages pass them
to get a.m. and it's going to patch it
directly onto the head of the tree so we
can go we can take this link we can go
here on master and we can patch it and
we've applied it to the head so now we
can go and look at the commit and we can
see that we have this commit here in a
commit message but it's missing the
metadata that we use in the project so
what I can do is I can go back here to
the original pull request and we have
this little utility that we use going to
just refresh this really quickly
so the utility is deciding not to work
in that version of Chrome so as we've
seen with live coding today being fun
let's try it here for a second we press
this it's going to generate the metadata
that we need for the commit we're going
to go back in here we're going to paste
the metadata into the commit we're going
to save that we're going to close it
we've now made the commit and then we're
going to push to master so we've just
updated note and so what I'm going to do
is I'm going to go and grab that commit
I'm going to go back to the to the thing
here i'm going to say you know where it
landed and i'm going to close it so
we've actually landed a pull request on
two nodes master branch so because this
is a commit that doesn't affect anything
that's problematic we can actually go
ahead and start back boarding it on to
our various release lines so we can look
here at the head we can grab this and we
can check out the seven point x staging
okay and now we can cherry-pick it so
now we can see it's sitting on on the
staging branch for the next release and
we could push that and as long as no one
else has put anything on the stage one
branch we should be good which we are so
now we've updated and put it into
staging but we can also do is take it a
step further we can look here at v 68 we
can update the tree so we could get the
commits that are sitting in master and
just what we're doing that I'm going to
update d for as well and can go you can
grab this commit grab that link address
we can patch it on v6 we catch it on v4
and we can push upstream to both the v6
staging and the v4 staging so now we've
gone ahead and we've we've landed this
update into all of our release lines so
I can go and market so that we know that
it's ready to go so we've gone ahead and
taken this commit that fixes our tooling
we've updated all of our release lines
and it's ready to go in all of our next
releases for node so this is kind of an
example of what the release process
looks like so if any of you have more
questions about how we manage that
release come and grab me but this is the
process of landing code onto node and
updating our different release processes
so when we're ready for a release we'll
go and we'll branch off of the four
point x six point X or seven its
branches and then we'll cherry picker
commits that are sitting on staging
ready to go into the release how do we
know which trick which commits we're
going to cherry pick we primarily know
through github labels so every commit
the December major has a label every
commits the December minor has a label
we also have LTS watch labels and we
have don't land labels so if I go back
to the repo here for a second and we go
to our pull requests here we could go
here and we can say hey what's
everything that we have unlike on the
floor point LTS watch for v4 point X and
we're going to see all the stuff that's
ready to land there and we can do LTS
watch for six point X as well and now we
have a list of all the commits that are
ready to land on both that have closed
and already landed on master we have a
big list here so we can go back here and
we can see that there's another commit
that I was that i was looking at which
is this right here which changes a
deprecated deprecated method that isn't
supposed to exist but still does and we
can see that this was landed by Franzi
who's sitting in the audience right now
and she landed it in eighty nineteen
forty one two and so I asked her if it
should be backboard and she said that if
it lands cleanly we can so we can go
ahead and we can copy this commit that's
ready to land and we can run our
to command but it didn't work which is
unfortunate but expected so we can
actually just say please and now we're
going to use a three-way merge strategy
instead of the git merge strategy and we
push it upstream and we can see there's
the commit and I think that it's already
landed so now we can go back to v4 and
we can try to patch it and we're going
to see a wait it didn't work so we can
see what's going on we can see there's
actually a diff in note CC and we can
see that there's actually some stuff
that exists on this tree that doesn't
exist in v4 and generally when we start
touching c++ and changes that I'm not
familiar with I get kind of nervous so
what I'm going to do is I'm actually
just going to abort this I'm going to go
back to this I'm going to switch the tag
for LTS v6 and let them know that we've
landed it but I'm also going to do is
again a lamo label to say don't tool and
don't land it on v4 because it didn't
land cleanly we're going to see those
labels update we're going to go down
here and I'm going to just messaged
frenzy and just say you know landed
cleanly on v6 but not before please feel
free to manually backport so now we've
gone it's landed on six it's ready to go
in a 6 release it didn't land on for so
we put a label so that we know that it's
not going to land on the four in the
future but we've messaged someone to
give them the opportunity to land it
later if we'd like so this is how we go
through and we have tools that we can
use that can automate going through all
of these different labels so if we're on
the six right here we can use this tool
called branch diff and we can say hey
you know what's the difference between
the 6.8 staging and v6 point acts and
it's nothing which was fun but we could
then go and say well what's the
difference between v6 and master it's
going to go through and it's going to
grab every single commit it's going to
compare them based on labels and what's
really cool about this tool is instead
of doing it based on the tree which is
what a git diff usually does it does it
based on our metadata and it does it
based on the titles of the commit so
what it can do is we actually care about
atomic change atomic change is not the
same thing as the changes in which we
have in a get
tree so a diff between two trees that
have different changes are going to be a
diff but we care about are the actual
commits so now what we can see here are
all the commits that are a master that
are not on v6 and there's a whole bunch
and a lot of them are cember major so
what we're able to do is actually make a
whole bunch of different labels and you
can see here if I go to github com to my
gists I maintain a gist of various
audits that I'm doing and we could see
the audit of v6 this is the command that
includes excluding labels and these are
all the commits that still need to be
labeled they have not yet been labeled
they live on master not yet on these six
and i go through periodically you know
once every two weeks or so and audit
these the last time i actually did a
live stream of it and explained commits
what was going through what was
happening if you follow me on twitter at
the alpha nerd I'll tweet on there
whenever I'm going to be doing these
these live sessions and if enough of you
from Singapore interested because I have
a really weird sleep schedule I totally
be up for doing it at a time it's like
reasonable for you but so now that we
have these labels were able to use tools
like I was talking about release tools
including branch diff to find the
difference release tools such as
changelog maker which can use that the
diffs between the branches and generate
our change log for us we also have
various scripts that we use during the
release and all of those allow us to do
our release process and automate it so
we got a little bit of time left so
we're going to talk a little bit about
what is a breaking change I love this
one I really hope no one got hurt but
it's just that's pretty glorious just
good I know I just said I don't have a
lot of time but I'm just gonna watch it
anyways so as we talked about before
what's December major change what's a
breaking change it's a change in
behavior generally a change in behavior
is obvious but sometimes we can be
really surprised and we're going to talk
a little bit about how we figure out if
we have breaking changes and then look
at an example of one that's unexpected
so how do we avoid breaking changes you
know there's obvious ways continuous
integration and a large testing suite
but we also do something called smoke
testing so one of the utilities that
I've worked on is called
canary in the gold mine what it will do
is it will actually go and grab the
tarball from github of a module it will
untie it it will NPM install it and then
it will run npm test it will then take
the results of that test and give us the
results so you can npm install this npm
install g you can see I TGM and start
running test Suites on your laptop if
you want but what's interesting is it
also comes with the lookup table of the
top 70 modules in the ecosystem that
we've derived for a number of different
reasons we then run that in CI and we
can run the test suite automate the test
suite of 70 of the top modules in n p.m.
and then get those results to see if
something's broken and we can run that
test on any arbitrary commit of node we
are now at the point where we will not
land December major change or do a
release if anything is broken and canary
in the gold line so what this means is
that anytime someone sends a commit
that's questionable we can run canary in
the gold mine and we can tell whether or
not we've actually broken something in
the ecosystem so once upon a time canary
in the gold mine found some failures
there was a failure in Jade and a
failure and body parser so it turned out
that Jade just moved their args their
orgs and did an update their
package.json so this was an example of
where we didn't actually break anything
but the modules themselves broke
something and this has been an awesome
side effect of canary on a gold mine
that wasn't expected was that when we
actually have were able to test that
these orgs have broken things we can
actually give a heads up to people hey
your module is broken and they like they
love it two days ago we actually found
that ember CLI pushed some stuff that
was unexpected that broke note in a
weird way just on v4 and we were able to
let them know within like two days of
their release and they were able to get
an update out in about 30 minutes
because they were so adamant that they
would be tested in canary in the
coalmine that they worked with us super
quickly so the next one that broke was
body parser how many people here know
what body parser is can I see a number
of hands how many people here know what
Express is cool so Express is a tool
that's used for running all sorts of
servers it's used inside a paypal's
Kraken so an idea of how much it's used
so there was an optimization to query
string parse that took a length and
this is the change that came in and we
can see just like right here essentially
originally we just checked if the max
keys was larger than the length and then
we just cut it and instead we realize
that you can too stringed up split you
could pass a max length and in doing so
we were able to have an optimization and
not create lots of garbage so one thing
we didn't account for was infinity
because based on the spec the number
that you give for max length is actually
an integer and when infinity gets
inferred to be an integer it infers 20
so body parts are actually had a test
for this and we found out that basically
what would originally have passed one
with this code started passing zero so
this was a code that was a small
optimization it was something that
easily would have been backported we
would have had no idea that this could
have broken code in production but I
mean this is an extremely hot code this
could have broken the world but Canarian
the gold mine found it smoke testing
save the day so with the change the
change had landed on master but not
going on out in a release yet so we were
able to land to fix before it even hit
userland so let's quickly wrap up which
version should you use forex has had the
while on LTS to stabilize 6x has been on
LTS for about a month and it's getting
ready for a third LTS release and v7 is
always getting the latest and greatest
things so why use V for hardened by an
ongoing release process you already have
an app in production that's working you
probably should just stick to vie for
right now why use v6 and it's going to
have the longest support cycle of all
the LTS releases that are out right now
and it's the closer to master of all the
LTS releases it also comes with v8 5.1
which has a much larger coverage of es6
than 4.8 which was in node v4 and it has
the inspector api i don't know if you've
used that yet some people have talked
about it earlier this conference it's
awesome do you have to use LTS you know
no you can do whatever you want I'm not
the boss of you but if you want to use
6x what you're going to get is v8 5.4
you're going to get a little bit of yes
2016 you know you can use two stars for
doing exponents which is super cool
you're going to have the latest and
greatest stuff but if you use in
production I'm going to be really scared
so you know be prepared for breakages if
you're in
doctor and that's just kind of the
message that will leave you with their
so thank you all so much this is a dog
surfing</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>