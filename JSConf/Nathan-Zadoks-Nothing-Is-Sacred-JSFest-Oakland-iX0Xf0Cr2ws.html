<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Nathan Zadoks | Nothing Is Sacred | JSFest Oakland | Coder Coacher - Coaching Coders</title><meta content="Nathan Zadoks | Nothing Is Sacred | JSFest Oakland - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Nathan Zadoks | Nothing Is Sacred | JSFest Oakland</b></h2><h5 class="post__date">2015-06-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iX0Xf0Cr2ws" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">uh yeah so hi I'm Nathan I'm here to
talk to you about the future of
operating systems I didn't have the
chance to finish my slides and I woke up
late this morning so I don't actually
remember my slides so this is going to
be fun all right I reinvent wheels
because I think we could use some better
ones so I'm working on a colonel and
that's a research project and some guy
on the internet did that to you also he
seems to have gotten somewhere so I'm
hoping that works at uh so primer about
kernels if you're running linux or mac
OS or some other funky thing you're
probably looking at using something like
the thing on the left so all of your
stuff runs in kernel mode and rings out
0 where everything has to be absolutely
perfect if anything crashes you're
screwed and you get a kernel panic and
life is terrible and you will throw your
computer at the wall and some guy had
opinions on this
and argued with the other guy so we have
the situation like this where like if
you want to write the kernel module the
code has to be perfect and you kind of
have to poke it into the kernel you
can't just run it separately you can't
build modules over your own if you have
a new idea on how things should work
well you're you can kind of shove it and
like if you want to do something that's
within the framework of what your kernel
provides then you're fine and
everything's easy way easier than if you
were using a more modular system but
because there's a cost to modularity but
we decided that wasn't worth it we pick
something with a small core that's why
we're all here and we picked came up
with a way to manage modularity and I
run out of slides here but uh so
actually I need this slide some people
figured out that there might be a better
way to do this and came up with micro
kernels in the middle you separate these
things you make you move with all things
into user space where they run those
normal processes they can crash like
your filesystem can crash now your file
system doesn't work that's rather
annoying maybe your network driver
crashes you know I've known at work but
your systems still running and it can
restart these things and everything will
be better again so in the early 90s I
think this was a really popular idea and
nobody really actually made popular
implementations of it so because it
turns out it's way easier to write
everything as
one big bunch of code and I think in
part that is because of you Luke the
micro kernels we already have some of
them like they have still for something
that should be very simple they're very
large API surface they're complicated to
talk to so nobody actually wants to
write the modules and some of them are
slightly more practical there's minix
which is written by Andrew Tannenbaum
who who gives computer science and
operating systems design at the
University he retired recently but
that's a that's a research operating
system nobody uses it seriously and it
doesn't go far enough in my opinion it
makes in preconceived notions like Halle
file system works I'll file system
should work how network works and I want
to put that all these bits so we go down
to things like l4 which is a really
really fast research microkernel that
actually has some traction it's used in
some niche applications but it still has
a very large and complex API I have no
clue how to program for it and I started
writing my own thing I decided that C
wasn't good enough it needed to be a
safe systems language so i went for rust
where you can strike kernel with so in
rust you have unsafe blocks where you
can do all the crazy things you can do
and see like the reference null pointers
and do pointer arithmetic and do stupid
things and those need to be perfect but
if you can isolate the unsafety to those
blow
and you can build save obstructions
around the tricky stuff you can start
right you can write a kernel without
actually knowing that much it becomes
much much easier to reason about and
unwilling to build the kernel that
provides the absolute minimum you get
processes which have their own memory
spaces so you can poke into you on the
other people's memory as usual they can
map memory to each other so they can
share a memory your programs do this
pretty much all the time this is why
your graphics are in uber slow because
everything's being copied every frame
stuff like that and they get channels to
communicate with each other some of you
are probably familiar with goes channels
and the basic approach is not only
modularity like NPM style also separate
your modules in to their own runtime
spaces so you're getting more of an
erlang style thing or micro services and
the moment you have something like that
you can you're operating like your
kernel provides no preconceived notion
of how an operating system should work
so if you want to if you want to file
system that's cool you can do that I
think file systems are just terrible
databases I'm not going to have one if
you want to have tcp/ip or x 25 or
carrier pigeons right the thing for it
I'm not too interested i want crazy
anarchist decentralized networking
protocols and i can build that because
my operating system no longer has the
preconceived notion of how that stuff
should work
and let's see what's fun too okay so if
you if nobody if the operating system
provides no preconceived notions of how
things should work what you start having
is the things that are compatible are
just the things that talk through the
same interfaces rust has a nice
mechanism for defining interfaces
unfortunately I don't have a slide for
that but you Annie sell things is
interoperable interoperable if they
agree and that's pretty powerful that's
how in p.m. works we all agree like on
something like Cole back lost and
everything works together for that or we
all agree on function resurrect for our
HTTP servers and everything works
together for that and we see people
innovating with these like we all use
resurrect and next now for our
middleware that's already like taking
that and just everyone agreeing that
that's a good idea we'll stick with it
and that means you can write much much
smaller modules because you just need an
in an input interface that's agreed on
an interface that's agreed on and that
means i can write a thing that just
figures out how to place looks on the
disk it's the minimal basis you need for
a file system but also for a database so
you can have your file system and it can
work on the same disk sharing space with
the database but the database no longer
is forced to be layered onto the file
system which i find a terrible thing I
yeah I didn't actually prepare well for
this so
english questions and questions at the
end very questions edge yeah I'm not
sure where to go from here uh must uh
yeah right uh so my Colonels cold sulfur
because it's a terrible chemistry joke
but it's not public right now because
the code is kind of terrible and it
doesn't do much right now it pretty much
like it doesn't even right to the screen
right now because I'm hacking on the
paging code and hardware sucks so right
now it writes to the serial ports didn't
not see it uh yeah it's also they you
can write note bolts in an environment
where you have literally no systems
libraries or memory allocation writing
memory allocators is actually hard uh
right so what you want like sub slack
talks about Mad Science no comfy you I
don't know how many of you have seen the
talk basically like mad science is what
we do in node where we make small
modules small packets of functionality
that aren't prescriptive that can be
recombined in new and surprising ways
and that is mad science making new and
crazy things combining modules pieces of
functionality in ways you remember the
authors are never envisioned before
because this modularity allows for it so
I'm hoping people will come up with some
new crazy way of how operating systems
will work and I'm just trying to provide
base for them I'll write my own
operating system on top of it because I
might as well if I have a kernel that
allows me to do that easily but I think
everyone should come along and mix up
their own operating system and figure
out how their computer should work for
them and that's pretty much it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>