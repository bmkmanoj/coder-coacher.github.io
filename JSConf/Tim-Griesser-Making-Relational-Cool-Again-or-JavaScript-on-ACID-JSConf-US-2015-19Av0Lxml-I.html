<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tim Griesser: Making Relational Cool Again (or: JavaScript on ACID) | JSConf US 2015 | Coder Coacher - Coaching Coders</title><meta content="Tim Griesser: Making Relational Cool Again (or: JavaScript on ACID) | JSConf US 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tim Griesser: Making Relational Cool Again (or: JavaScript on ACID) | JSConf US 2015</b></h2><h5 class="post__date">2015-06-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/19Av0Lxml-I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so yeah I'm really excited to be here
talking about making a relational cool
again and the subtitle is or JavaScript
on acid and like I said my name is Tim
dreicer T Gryce are on Twitter github
and IRC and I'm really excited to be
here today talking about sequel or is it
SQL I was actually kind of concerned
about this as I was putting together
these slides because I know it's an
issue that sort of divides programmers
like how to pronounce SQL so of course I
googled it and the first result I came
across was this English language and
usage stack exchange which I thought was
sort of fitting giving that a program
conference that it's like a stack
overflow derivative and the first thing
you'll notice is that I'm not a member
of the English language in usage so if I
make any mistakes up here you'll you'll
know why but the the answer was that it
was in fact first called the structured
English query language and so that
acronym was sequel and then the name was
changed to structured query language
abbreviated addressed as SQL so it was
supposed to be sequel and then now it's
a matter of preference and then I guess
there's an urban legend saying that the
structured query language was actually a
sequel to the previous query language
which is like the worst urban legend
I've ever heard
but I thought this is good answer I
don't know how true it is so I gave it
an upvote and now I'm a member so that
was I learned something new and now a
member so that was that was a big day
but I think it's really appropriate that
we're talking about relational databases
at a JavaScript conference because I
think there's a lot of similar features
between the two and so at a language
level maybe not so much you've got
relational you know sequel is static and
strongly typed declarative and in some
ways procedural and then JavaScript is
like as loosely typed as you can get
while still being like a real
programming language and it's got you
know this weird hybrid of functional and
prototypal object-oriented which lends
to some some interesting debates on how
to write the code correctly but and and
also it shares some of the same
operators but even we know in JavaScript
the operators don't do what we want some
of the time so so what do I mean when I
say that there's a lot of similarities
between between sequel and and
JavaScript
well they both sort of share this
similar quality that is not often
attained by all languages which is what
I like to term languages that will
probably never die and as much as people
try to kill off JavaScript with with
different other languages that will
supersede it it sort of has this
monopoly being that it's the language of
the web it's the language that runs in
web browsers and similarly sequel has so
much momentum you know it's been around
since the 70s and it has just been
around forever and this is a slide that
we often show when we're talking about
JavaScript just sort of illustrating
that it runs everywhere it's in the
browsers but also your television and
your server and your node BOTS and
copters and also on your phones and I
think the same could be sort of said
about sequel is that it powers the
largest websites in the world it's you
know behind Facebook and and Wikipedia
and also down to sequel Lite which is a
flat file storage which is in more
places than you'd imagine on your
computers and phones and so when coming
to - no js' a couple years ago I was
sort of surprised like it it seems like
these two would be such a great fit
they're both everywhere and why why is
there not more support for it and I
think the reason is that node starts
with no and no is the beginning of no
sequel and you know actually around the
time that node came out it was sort of
like let's rethink the entire way that
we're writing server-side applications
with this event at i/o model and there
were at the time it was sort of let's
rethink the standard relational database
because we're hitting web scale and we
need to get past that and so around the
time that the sort of the height of the
the no sequel phase or movement it's
still going of course but I think is is
when node came out and that's why there
was so much of this so all the tutorials
I felt like for node were sort of node
Mongo getting started they have
literally taken the software and web
industries by storm
and all of the stacks are like the mean
stack you've got Mongo Express angular
node which everyone has probably heard
of and then maybe not so much the LeBron
stack which is my
at the level leveldb browserify NPM
slam-dunk
says Jen and what like what happened to
a relational algebra right this this is
proven time-tested and sequel works
great for a lot of things and this Stack
Overflow post that I that I came across
sort of summed up what I was thinking
coming to node from outside it is
relational our relational database is a
poor fit and this is sort of long so let
me just pick out a few things there's
sort of a degree of antipathy toward
relational databases is observation that
you could make of the node community and
that they're poorly supported compared
to non relational databases and I sort
of agree with this you know listening to
the the node up podcasts and hearing
about all the uses with couchdb and with
Mongo it was sort of like well yeah I
guess relational databases aren't cool
anymore so I talked a little further and
I found out that there are actually
really great libraries out there for for
working with sequel in node so no you
know all the popular open source as well
as MS sequel and an Oracle now came out
with an official one but the problem I
guess or the difficulty with these
libraries is that there's not a common
database API for all of them so node
didn't assume that a relational database
was a given so in other languages and
ecosystems there's sort of a standard
for how you're interacting with common
patterns of a database like how you
connect how you disconnect and that
doesn't exist so what that lends to is
that all of the different clients have a
different way of dealing with these
things that should be pretty common and
there's also I guess the the next thing
I noticed was that the higher level
abstractions were lacking a little bit
and what I mean by that is that a lot of
them were database specific so there was
a great query builder but it works for
Postgres specifically or there's a
another great one for another language
and there's no way to use the same for
both different api's or there is a mix
of an ORM layer and a query layer so
there's no ability to drop down and use
just vanilla sequel if you need to
one that was big for me is the lack of
transaction API so there wasn't any
mention of transactions in any of the
higher-level libraries that I had seen
at the time and that's sort of what the
the second sub title of the talk is the
that I'll get to in a little bit then
there was the jack-of-all-trades where
it's sort of like hey you can use the
same save API to save your to Redis or
demongo or to your relational database
or to the file system and it's like well
you know if you're have the same API for
all these different specialized data
stores then you're really not taking
advantage of the the best use cases for
each of them or there's sort of what I
call the the DIY I like it it gets you
most of the way but like modularity so
like you have to assemble all these
different pieces yourself like the the
pooling and the query construction and
the abstracting the database API so the
ecosystem I would definitely agree with
the with the Stack Overflow post that
there there is sort of need there that
needs to be filled and but I really
wanted this to happen so I really love
writing JavaScript and I was like okay
well maybe maybe we can do something
better and at the time I've been running
a lot of PHP this is back in 2012 in a
framework called laravel which some
might have heard of and it actually
makes running PHP like pretty like
tolerable but but and I was also using a
lot of backbone so I was thinking okay
well maybe I could take some of the
ideas from both of these and I sort of
translated the query builder from
laravel into this project called
connects Jas and this sort of
illustrates what pieces were taken from
each but the eloquent ORM from laravel
and some of the ideas from backbone into
into bookshelf and then mixing some
promises and so I'm going to talk a
little bit about these two libraries
that I have put together connection
bookshelf so the first is is connects
and if you're not familiar with where
the name comes from it's this it's this
toy that was sort of popular like in the
90s and it's sort of like a cheaper
version of Legos you can assemble all
these little little pieces together and
build pretty cool-looking things and you
know actually it's also really great if
you're procrastinating making conference
slides
I decided to make this little like
motorcycle here and all right Jess cough
but the the reason that I think what
what connects tries to do is standardize
the some of the inconsistencies in
sequel so sequel is a is a language and
an SI language specification but it's
not like it is what we're used to with
with like es5 or es6 and beyond where we
sort of have this compatibility table
and we can see that babbles in the head
of everything else in terms of
implementing all the different features
but it feels more like the can I use
where it's sort of it's more like a
language guideline and so there's
features that exist in some dialects and
not others you can you know wrap DDL
statements and transactions in Postgres
but not in my sequel but it doesn't fail
but it fails sometimes or did different
inconsistencies that connects tries to
sort of paper over and this is sort of
an illustration of the different pieces
as they're coming together internally
have things like connection pooling so
to make sure that you're you're getting
connections that you don't have to
continuously reconnect to the database
every time that you issue a query mixes
in some of the grammars from the
different dialects and then creates a
client which is used in the in the
schema and the normal query building as
well as transactions which I just sort
of break out entirely cuz I'm going to
spend a little bit of time on those and
and then on top of that we have some
higher-level api's for doing some
familiar migrations and seeding as you'd
see in something like rails so how you
get started with connects is to just
give it a connection string if you want
to configure the pool you can do that
and it works against a number of
different databases including Oracle
which is pretty cool somebody just open
a pull request and it was like oh I
don't use Oracle but that's awesome that
you have a floor request yeah open
source and it also supports web sequel
but I don't really recommend that
because that that's deprecated I guess
browsers sort of killed it off but what
it tries to do is make it so that you
don't have to concatenate strings to
build sequel so it's sort of sequel as
you drive it so select all from
counts where activated is one and then
he called then on it and it has the
familiar promise chaining API so it
issues that query and returns the result
of the query and then you can catch the
error if that happens in the standard
standard promise it's it's actually
great that I don't have to argue too
much in favor of promises now that
they're actually in the spec but when I
was starting out that was the thing that
it was still up for debate whether that
was whether you should use that also
does joins and I don't have to read it
out too much but joins with multiple
clauses and then sub queries so anywhere
so here we have a wherein clause and
anywhere that you might want to use a
sub query the general rule of thumb is
that you can pass a function and then
use the context of that closure as a new
sub query and then from there I'm not
going to dive into all the features
because that's what documentation is for
but you can do raw queries like if you
have a specialized query that you don't
want to maybe does some things that
aren't supported I can actually can
issue those aggregates sub queries
saying and what it really tries to do is
is tries hard not to let you screw up
like it tries to catch different errors
or paper over things for you so you
don't don't make too many mistakes and
so the subtitle of the talk as I
mentioned is or JavaScript on acid so
this is not the the acid test which some
are probably familiar with oh I've
mentioned this to someone they're like
oh you mean like the the browser suite
and I was like oh no let me look that up
though so it's good to know that chrome
is passing the acid3 test as of today
but what I mean is a de Missa tee
consistency isolation and durability and
these are the principle I'm not going to
go into each of them because that could
be like a separate talk about each of
the individual terms but transactions I
sort of sum up that and what they do is
give you the ability to have a sort of
snapshot state of the world as you're
working with your database so what it
allows you to do is roll back to a
certain point in time and also prevent
other connections that might be working
at your
a basis from altering rows as you're
working with it within a single atomic
unit of of state and this is kind of
difficult to to do a node like you have
to think about this API in advance
because in order for this to work you
have to have the same database
connection passed to every single query
that you're working against and so it's
not like in synchronous languages where
you can just sort of say like okay start
transaction here and then all of these
will run right here and then end it
right here because you sort of with with
the evented i/o model and you sort of
lose that context as you go with the
callback you don't really know what's
happening so the connection explicitly
has to be passed to every query so let's
think about a situation where we would
actually want to use transactions so
here's a simple user flow situation
where somebody's registering for a
website and they register and you give
them an ID and then you have to send
that to a third-party service and then
you have to create maybe some other rows
for that user and then it's all done
they're all registered so let's think
about like what could go wrong in in
these four steps so first you might
depend on a module which like doesn't
follow semantic versioning and so
something breaks and it's like
completely out of your control or the
third party API they're working against
sort of shuts down and your data gets
into a bad state so in order to deal
with that then you know after step two
if that fails then you'd have to undo
what happened in step one or in step
three where you're creating additional
rows to deal with that new user maybe
one or a few of them failed and so then
you have to make sure the ones that did
go through get rolled back and then you
have to unregister the user and then say
hey something messed up and that ends up
pushing a lot of logic into your
application code that you have to deal
with all of these potential bad states
or you just don't deal with it and then
you have potentially like that data in
your application because you want this
whole register user flow to to happen as
one atomic event or here's another
situation that can't be handled by the
last one is that like your servers just
catch on fire halfway through halfway
through registering the user and
actually I like created these
so I would one day have the ability to
use this graphic in in a keynote and no
but uh so what can X tries to do is you
can say connects transaction and then
you have a connection aware connects
instance that you can just treat as a
normal query builder instance but it
knows what connection it's supposed to
be on and the fact that it's inside a
transaction so then you can pass that to
other functions which can then utilize
it and work with it as if it's just the
normal API but you behind the scenes
have a have a transaction that you're
dealing with and originally the API was
that you would just have to pass this
explicitly to every single query that
you built so you had like the
transaction object and then you could
call commit or rollback at the very end
but that seemed to be kind of
error-prone that users would sort of
forget to pass it to every single query
necessary and then they would have sort
of queries not working on the same
connection and it caused all sorts of
errors so this is the new API and like I
said Connexions tries to tries to make
it hard to screw up I guess and so then
this this is a little boilerplate right
here that every time we're calling
commits at the very end and rollback and
this is a promise so we can just return
the promise into the transaction and
then we know if the entire promise chain
fulfills the transaction should be
committed and then if it fails the
transaction should be rolled back so
that's pretty simple
nesting transactions is new and it's the
idea that you shouldn't have to worry
about whether the client is already
inside a transaction so if you call if
connects transaction on something that
is already a transaction connects it
should just create a save point and so a
save point is sort of sort of like a
save point like a video game like where
you get to a certain point and if
something fails beyond that you don't go
back to the very beginning but you go
back to just right here and so it does
this transparently you know for you and
you don't have to you don't have to
worry about worry about it too much
so connects likes to take what I call
the the batteries included approach
where it does a lot of this stuff for
you and it also provides a lot of
different interfaces like
callbacks and streams and events and to
String you know the different things
that you'd want to work with in a in a
nice manner so that that's pretty much
just a high-level overview of connects
now I'm going to jump in the bookshelf
which is an ORM which stands for object
relational mapper and in short what that
tries to do is take care of standard
sequel queries for you especially for
common at operations so when you're
building an app there's a lot of things
that are that are pretty standard like
insert return fetch save dealing with
relating different rows of of data and
you don't want to have to write all of
this by hand so it sort of abstracts
that for you a little bit and takes a
little bit of the flexibility away but
gives you a nicer higher-level piece to
work with
so the different Association types are
pretty familiar if you've ever worked
with the know RM in another language
it's get one-to-one one-to-many
many-to-many polymorphic which I don't
know if these are necessarily a great
idea but sometimes they can be useful I
guess so it supports those and it builds
on top of Connect so that's where I was
talking about having a separation
between like a query building layer and
an ORM layer that you should be able to
just write raw sequel when you want and
then have something higher-level that
that works on top of that and also
allows you to drop back into it when you
need so this is sort of what it looks
like to create a few models with
associations and you can also sort of
filter with so here we have comments
which is as many to a comment but we
also have moderated comments and we can
automatically add in the where moderated
is is true and it also supports either
loading which is avoiding the n plus one
query problem which is when you're
trying to load data on to a collection
of data that if you have 26 items then
you're having 26 extra queries so it
tries to do like one and then another
query for the extra related results
so an example here is to find an account
with all the posts under the account and
then all the comments under those posts
and then all the accounts that actually
made the comments on the posts for the
account so that's what that would look
like to provide with related and it's
dot notation for each of the relations
pretty pretty simple and this is all in
the
mutation so I'm going to sort of jump
jump through this a little bit it also
allows you to constrain eager loads so
you can dynamically constrain relations
and then load things after the fact so
if you want to fetch one row or a
collection of rows and then only load
onto one it allows you to do that as
well and then as I was mentioning
earlier that it allows you to tap into
the query chain to dynamically add
things that are maybe a little more
sequel specific under the hood as you're
building the the Select statement or
other statements for the for the model
and so transactions in bookshelf aren't
quite where they are in connects where
you still have to pass the explicit
object to each of the async calls it
turns out it's a little harder to
retrofit that where you have like a
transaction aware bookshelf object but
that's that's where it's going in the
future but transactions are absolutely
supported in bookshelf
and just a little bit of where bookshelf
sort of came from I mentioned that it it
came from some of the ideas from
backbone models and collections and
ultimately the idea was to see if we
could reuse some of the same models on
on the server and client and this was
back in like 2012 and this was back
before I even knew there was like a term
for for doing this which I'm not going
to say because he already covered it
last year but and I actually sort of got
there I was able to swap out bookshelf
models and collections for like the
backbone to do MVC and actually use it
targeting web sequel which was kind of
cool I guess I don't know I built a
to-do list and that's pretty special I
don't know but but really I think like
shared models sound great but it's not
really as great in practice because you
have to know a lot more or the there's
sort of a limit to what you can do you
have to load all the data and you lose
out on a lot because you don't need as
much of what you would need on the
server on the client if you're just
displaying it so it sounds great not as
great in practice and it's something
that I'm sort of moving away from some
of the model and collection conventions
from from backbone based on some of the
things I've learned having been out
there for a little while so you can read
more in the docs I'm not going to go too
much further into it but I think one
thing I'd like to point out is that
connection bookshelf are not the first
to do this so I mentioned earlier there
was already higher-level sequel
abstractions in in JavaScript that I saw
and I was like oh build these instead
and hopefully it's not the last to do
this so a few other projects open record
is a really great project that's using
connects under the hood and it provides
more of an active record like syntax and
sequel eyes was the big one and is still
still a big one and it didn't have
support for transactions it had a really
the api's were sort of rough and since
then it's it's come a long way I've been
really impressed with a lot of the
development going on with sequel eyes so
if you haven't taken a look at it and
while definitely take another look
they're doing some really really cool
things especially around the the new
Postgres features features that are
coming out a new one that I just saw
recently it was actually by someone who
had been frequently commenting on on
bookshelf and connects projects and I
guess maybe had some opinions that were
different created this Azul jeaious and
I was looking through and it's really
impressive it does transactions it
doesn't have quite the separation
between the query building and the ORM
layer but it it does a lot for you at
the at the ORM layer so that's another
one worth worth checking out
sequel bricks I guess it is pretty
similar to connects but with different
opinions any DB sequel node sequel which
is by Brian Carlson who does the
excellent node Postgres driver even the
drivers have come a really long way
since since I had initially looked at
them in 2012 the node my sequel driver
has just a ton of documentation
improvements and a lot of features added
and it's really impressive how far it's
come in the in the last couple years
there are different projects built on
connects connects query lab which allows
you to demo this in the browser and have
it spit out the sequel bookends sort of
does data nested data loading and
querying really well it's on top of a
bookshelf and then there's endpoints
which is a JSON API compliant library or
framework I guess that has connection
bookshelf under the hood
and then there's larger stack
implementations like like sales which
has their own ORM but I know they were
talking about potentially using connects
as the query builder under the hood and
so they're also targeting you know all
the different sequel drivers and you
know that's just some of what's out
there but I really don't think this is
enough so we're still sort of like at
this stage where node is a really young
ecosystem and a lot of times we'll hear
don't reinvent the wheel like it's
already been done but I sort of disagree
with this I think that people should
absolutely be reinventing the wheel with
an asterisk just not on the client-side
because like react already did this now
I'm kidding there but like we should
have more more experiments out there
because I think the types of
conversations we're having since react
are really different a bit about just
the web in general and and because they
questioned a lot of opinions so I think
that you know take a look at other
libraries take a look at other languages
which is what you know a lot of what
Java scripts about in Java scripts sort
of late to the party of being on the
server and a lot of the great ideas
coming out around async and e s7 and the
essayed are looking at the best of
what's around in other languages so I
think it's really important like as I
mentioned these were adapted from from
the laravel query builder and ORM in PHP
and I'd really like to move a lot
further toward like sequel alchemy model
of ORM and query builder so I've been
looking a lot at those but there's a lot
of great stuff out there but I what I
really would love to see is just node
become more of a target for traditional
crud web applications and to sort of
prove that stack overflow question wrong
and more so to just get awareness out
there that that you can do this type of
boring traditional website development
in node and I think the more that that
becomes a something that's that's well
known the more people will be writing
JavaScript and then more it goes into
the ecosystem so that that was sort of
the the goal of creating these two
libraries to sort of say like hey you
can do this and hopefully that there's a
lot more that that comes out of this so
that's everything</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>