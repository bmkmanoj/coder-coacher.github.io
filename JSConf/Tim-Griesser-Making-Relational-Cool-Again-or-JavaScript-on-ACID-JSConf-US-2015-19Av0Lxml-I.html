<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tim Griesser: Making Relational Cool Again (or: JavaScript on ACID) | JSConf US 2015 | Coder Coacher - Coaching Coders</title><meta content="Tim Griesser: Making Relational Cool Again (or: JavaScript on ACID) | JSConf US 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tim Griesser: Making Relational Cool Again (or: JavaScript on ACID) | JSConf US 2015</b></h2><h5 class="post__date">2015-06-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/19Av0Lxml-I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so yeah I'm really excited to be here
talking about making a relational cool
again and the subtitle is or JavaScript
on acid and like I said my name is Tim
Grasser T Gryce her on Twitter github
and IRC and I'm really excited to be
here today talking about sequel or is it
SQL I was actually kind of concerned
about this as I was putting together
these slides because I know it's an
issue that sort of divides programmers
like how to pronounce SQL so of course I
googled it and the first result i came
across was this english language and
usage stack exchange which I thought was
sort of fit in giving the word a program
conference that it's like a stack
overflow derivative and the first thing
you'll notice is that I'm not a member
of the English language in usage so if I
make any mistakes up here you'll know
why but the the answer was that it was
in fact first called the structured
English query language and so that
acronym was sequel and then the name was
changed to structured query language
abbreviated a desk as SQL so it was
supposed to be sequel and then now it's
a matter of preference and then I guess
there's an urban legend saying that the
structured query language was actually a
sequel to the previous query language
which is like the worst urban legend
I've ever heard but I thought this is
good answer i don't know how true it is
so i gave it an upvote now i'm a member
so that was i learned something new and
now a member so that was that was a big
day but I think it's really appropriate
that we're talking about relational
databases at a JavaScript conference
because I think there's a lot of similar
features between the two and so at a
language level maybe not so much you've
got relational you know sequel is static
and strongly tight declarative and in
some ways procedural and then javascript
is like as loosely typed as you can get
while still being like a real
programming language and it's got you
know this weird hybrid of functional and
prototypal object-oriented which lends
to some some interesting debates on how
to write the code correctly but and and
also it shares some of the same
operators but even we know in JavaScript
the operators don't do what we want some
of the time on so so what I mean when I
say there's a lot of similarities
between between sequel and and
JavaScript
well they both sort of share this
similar quality that is not often
attained by all languages which is what
I like to turn languages that will
probably never die and as much as people
try to kill off JavaScript with with
different other languages that will
supersede it it sort of has this
monopoly being that it's the language of
the web it's the language that runs in
web browsers and similarly I sequel has
so much momentum you know it's been
around since the 70s and it has just
been around forever and this is a slide
that we often show when we're talking
about JavaScript just sort of
illustrating that it runs everywhere
it's in the browsers but also your
television and your server and your node
bots and copters and also on your phones
and I think the same could be sort of
said about sequel is that it powers the
largest websites in the world it's you
know behind facebook and and Wikipedia
and also down to sequel light which is a
flat file storage which is in more
places than you'd imagine on your
computers and phones and so when coming
to to know DJ s a couple years ago I was
sort of surprised like it it seems like
these two would be such a great fit
they're both everywhere and why why is
there not more support for it and I
think the reason is that node starts
with no and no is the beginning of no
sequel and you know actually around the
time that node came out it was sort of
like let's rethink the entire way that
we're writing server-side applications
with this event at IO model and there
were at the time it was sort of let's
rethink the standard relational database
because we're hitting web scale and we
need to get past that and so around the
time that the sort of the height of the
the no sequel phase or movement it's
still going of course but I think is is
when note came out and that's why there
was so much of this so all the tutorials
I felt like four node were sort of node
Mongo getting started they have
literally taken the software and web
industries by storm and all of the
stacks are like the mean stack you've
got Mongo Express angular node which
everyone is probably heard of and then
maybe not so much the LeBron stack which
is my
favorite the level leveldb browserify
npm to slam-dunk says jen and what like
what happened to a relational algebra
right this this is proven and
time-tested and sequel works great for a
lot of things and this stack overflow
post that I that I came across sort of
summed up what I was thinking coming to
node 4 from outside it is relational our
relational databases a poor fit and this
is sort of long so let me just pick out
a few things there's sort of a degree of
antipathy toward relational databases is
a observation that you could make of the
node community and that they're poorly
supported compared to non-relational
databases and I sort of agree with this
you know listening to the the note up
podcasts and hearing about all the uses
with CouchDB and with Mongo it was sort
of like well yeah I guess relational
databases aren't cool anymore so I dug a
little further and I found out that
there are actually really great
libraries out there for for working with
sequel in node so no you know all the
popular open source as well as ms sequel
and an oracle now came out with an
official one but the problem i guess or
the difficulty with these libraries is
that there's not a common database API
for all of them so node didn't assume
that a relational database was a given
so in other languages and ecosystems
there's sort of a standard for how
you're interacting with common patterns
of a database like how you connect how
you disconnect and that doesn't exist so
what that lens too is that all of the
different clients have a different way
of dealing with these things that should
be pretty common and there's also I
guess the next thing I noticed was that
the higher level abstractions were
lacking a little bit and what I mean by
that is that a lot of them were database
specific so there was a great query
builder but it works for postgres
specifically or there's a another great
one for another language and there's no
way to use the same for both different
AP is or there is a mix of an ORM layer
and a query layer so there's no ability
to drop down and use just vanilla sequel
if you need to
one that was big for me is the lack of
transaction API so there wasn't any
mention of transactions in any of the
higher-level libraries that I had seen
at the time and that's sort of what the
the second sub title of the talk is the
I'll get to in a little bit then there
was the jack of all trades where it's
sort of like hey you can use the same
save API to save your to Rhetta sword
imago or to your relational database or
to the file system and it's like well
you know if your have the same API for
all these different specialized data
stores then you're really not taking
advantage of the the best use cases for
each of them or there's sort of what I
call the DIY like it gets you most of
the way but like modularity so like you
have to assemble all these different
pieces yourself like the pooling and the
query construction and the abstracting
the database API so it the ecosystem I
would definitely agree with the with the
stack overflow post that there there is
sort of a need there that needs to be
filled and but I really wanted this to
happen so I really love writing
JavaScript and I was like okay well
maybe maybe we can do something better
and at the time I've been running a lot
of PHP this is back in 2012 in a
framework called laurelville which some
might have heard of and it actually
makes writing PHP like pretty like
tolerable but but and I was also using a
lot of backbone so I was thinking okay
well maybe I could take some of the
ideas from both of these and I sort of
translated the query builder from
lauraville into this project called
connects jas and this sort of
illustrates what pieces were taken from
each but the eloquent ORM from Laura
Bell and some of the ideas from backbone
into into bookshelf and then mix in some
promises and so I'm going to talk a
little bit about these two libraries
that I have put together connection
bookshelf so the first is is connects
and if you're not familiar with where
the name comes from it's this it's this
toy that was sort of popular like in the
90s and it's sort of like a cheaper
version of Legos you can assemble all
these little little pieces together and
build pretty cool-looking things and you
know actually it's also really great if
you're procrastinating making conference
slides
I decided to make this little like
motorcycle here and all right Jess cough
but the the reason that I think what
what connects tries to do is
standardized the sum of the
inconsistencies in sequel so sequel is a
is a language and an SI language
specification but it's not like it is
what we're used to with with like es5 or
es6 and beyond where we sort of have
this compatibility table and we can see
that babbles in the head of everything
else in terms of implementing all the
different features but it feels more
like the can I use where it's sort of
it's more like a language guideline and
so there's features that exist in some
dialects and not others you can you know
rap ddl statements and transactions in
Postgres but not in my sequel but it
doesn't fail but it fails sometimes or
did different inconsistencies that
connects tries to sort of paper over and
this is sort of an illustration of the
different pieces as they're coming
together internally have things like
connection pooling so to make sure that
you're you're getting connections and
you don't have to continuously reconnect
to the database every time that you
issue a query mixes in some of the
grammars from the different dialects and
then creates a client which is used in
the in the schema and the normal query
building as well as transactions which I
just sort of break out entirely because
I'm going to spend a little bit of time
on those and and then on top of that we
have some higher-level api's for doing
some familiar migrations and seating as
you'd see in something like rails so how
you get started with connects is to just
give it a connection string if you want
to configure the pool you can do that
and it works against a number of
different databases including Oracle
which is pretty cool somebody just open
a pull request and it was like oh I
don't use Oracle but that's awesome that
you have a floor request yay open source
and it also supports web sequel but I
don't really recommend that because that
that's deprecated I guess browsers sort
of killed it off but what it tries to do
is make it so that you don't have to
concatenate strings to build sequel so
it sort of sequel as you dry it so
select all from
outs we're activated is one and then you
call then on it and it has the familiar
promise chaining API so it issues that
query and returns the result of the
query and then you can catch the error
if that happens in the standard standard
promise it's it's actually great that I
don't have to argue too much in favor of
promises now that they're actually in
the spec but when I was starting out
that was the thing that it was still up
for debate whether that was whether you
should use that also does joins and I
don't have to read it out too much but
joins with multiple clauses and then sub
queries so anywhere so here we have a
we're in clause and anywhere that you
might want to use a sub-query the
general rule of thumb is that you can
pass a function and then use the context
of that closure as a new sub query and
then from there i'm not going to dive
into all the features because that's
what documentation for but you can do
raw queries like if you have a
specialized query that you don't want to
maybe does some things that are
supportive i can actually can issue
those aggregates sub-query saying and
what it really tries to do is is tries
hard not to let you screw up like it
tries to catch different errors or paper
over things for you so you don't don't
make too many mistakes and so the
subtitle of the talk as i mentioned is
or javascript on acid so this is not the
the acid test which some are probably
familiar with all I've mentioned this to
someone they're like oh you mean like
the the browser sweet and I was like oh
no let me look that up though so it's
good to know that chrome is passing the
acid three tests as of today but what I
mean is Adam icity consistency isolation
and durability and these are the
principal I'm not going to go into each
of them because that could be like a
separate talk about each of the
individual terms but transactions I sort
of sum up that and what they do is give
you the ability to have a sort of
snapshot state of the world as you're
working with your database so what it
allows you to do is roll back to a
certain point in time and also prevent
other connections that might be working
at your day
basis from altering rose as you're
working with it within a single atomic
unit of of state and this is kind of
difficult to to do a node like you have
to think about this API in advance
because in order for this to work you
have to have the same database
connection passed to every single query
that you're working against and so it's
not like in synchronous languages where
you can just sort of say like okay start
transaction here and then all of these
will run right here and then end it
right here because you sort of with with
the event at i/o model and you sort of
lose that context as you go with the
callback you don't really know what's
happening so the connection explicitly
has to be passed to every query so let's
think about a situation where we would
actually want to use transactions so
here's a simple user flow situation
where somebody's registering for a
website and they register and you give
them an ID and then you have to send
that to a third-party service and then
you have to create maybe some other rows
for that user and then it's all done
they're all registered so let's think
about like what could go wrong in in
these four steps so first you might
depend on a module which like doesn't
follow a semantic versioning and so
something breaks and it's like
completely out of your control or the
third party AAP either you're working
against sort of shuts down and your data
gets into a bad state so in order to
deal with that then you know after step
2 if that fails then you'd have to undo
what happened in step 1 or in step 3
where you're creating additional rows to
deal with that new user maybe one or a
few of them failed and so then you have
to make sure the ones that did go
through get rolled back and then you
have to unregister the user and then say
hey something messed up and that ends up
pushing a lot of logic into your
application code that you have to deal
with all of these potential bad states
or you just don't deal with it and then
you have potentially like that data in
your application because you want this
whole register user flow to to happen as
one atomic event or here's another
situation that can't be handled by the
last one is that like your servers just
catch on fire halfway through a half way
through registering the user and
I like created these libraries so I
would one day have the ability to use
this graphic in a keynote and no but so
what connects tries to do is you can say
connects transaction and then you have a
connection aware connects instance that
you can just treat as a normal query
builder instance but it knows what
connection it's supposed to be on and
the fact that it's inside a transaction
so then you can pass that to other
functions which can then utilize it and
work with it as if it's just the normal
API but you behind the scenes have a
have a transaction that you're dealing
with and originally the API was that you
would just have to pass this explicitly
to every single query that you built so
you had like the transaction object and
then you could call commit or rollback
at the very end but that seemed to be
kind of error prone that users would
sort of forget to pass it to every
single query necessary and then they
would have sort of queries not working
on the same connection and it caused all
sorts of errors so this is the new API
and like I said connects tries to tries
to make it hard to screw up I guess and
so then this this is a little
boilerplate right here that every time
we're calling commit at the very end and
roll back and this is a promise so we
can just return the promise into the
transaction and then we know if the
entire promise chain fulfills the
transaction should be committed and then
if it fails the transaction should be
rolled back so that's pretty simple
nesting transactions is new and it's the
idea that you shouldn't have to worry
about whether the client is already
inside a transaction so if you call it
connects transaction on something that
is already a transaction connects it
should just create a save point and so a
save point is sort of sort of like a
save point like a video game like where
you get to a certain point and if
something fails beyond that you don't go
back to the very beginning but you go
back to just right here and so it does
this transparently you know for you and
you don't have to you don't have to
worry about worry about it too much so
connects likes to take what i call the
the batteries included approach where it
does a lot of this stuff for you and it
also provides a lot of different
interfaces like callbacks and streams
and events and
to string you know the different things
that you'd want to work with in a in a
nice manner so that that's pretty much
just a high-level overview of connects
now going to jump in the bookshelf which
is an ORM which stands for object
relational map and in short what that
tries to do is take care of standard
sequel queries for you especially for
common at operations so when you're
building an app there's a lot of things
that are that are pretty standard like
insert return fetched save dealing with
relating different rows of of data and
you don't want to have to write all of
this by hand so it sort of abstracts
that for you a little bit and takes a
little bit of the flexibility away but
gives you a nicer higher-level piece to
work with so the different association
types are pretty familiar if you've ever
worked with an ORM in another language
it's get one-to-one one-to-many
many-to-many polymorphic which I don't
know if these are necessarily a great
idea but sometimes they can be useful i
guess so it supports those and it builds
on topic index so that's where i was
talking about having a separation
between like a query building layer and
an ORM layer that you should be able to
just write ross equal when you want and
then have something higher level that
that works on top of that and also
allows you to drop back into it when you
need so this is sort of what it looks
like to create a few models with
associations and you can also sort of
filter with so here we have comments
which is it has many to a comment but we
also have moderated comments and we can
automatically add in the where moderated
is is true and it also sports either
loading which is avoiding the n plus one
query problem which is when you're
trying to load data onto a collection of
data that if you have 26 items then
you're having 26 extra queries so it
tries to do like one and then another
query for the extra related results so
an example here is to find an account
with all the posts under the account and
then all the comments under those posts
and then all the accounts that actually
made the comments on the posts for the
account so that's what that would look
like to provide with related and it's
dot notation for each of the relations
pretty pretty simple and this is all
the documentation so I'm going to sort
of jump jump through this a little bit I
also allows you to constrain your loads
so you can dynamically constrain
relations and then load things after the
fact so if you want to fetch one row or
a collection of rows and then only load
onto one it allows you to do that as
well and then as I was mentioning
earlier that it allows you to tap into
the query chain to dynamically add
things that are maybe a little more
sequel specific under the hood as you're
building the the Select statement or
other statements for the for the model
and so transactions in bookshelf aren't
quite where they are in connects where
you still have to pass the explicit
object to each of the async calls it
turns out it's a little harder to
retrofit that where you have like a
transaction where bookshelf object but
that's that's where it's a going in the
future but transactions are absolutely
supported in bookshelf and just a little
bit of where bookshelf sort of came from
I mentioned that it it came from some of
the ideas from backbone models and
collections and ultimately the idea was
to see if we could reuse some of the
same models on on the server and client
and this was back in like twenty twelve
and this was back before I even knew
there was like a term for for doing this
which I'm not going to say because he
already covered it last year but and I
actually sort of got there I was able to
swap out bookshelf models and
collections for like the backbone to do
MVC and actually use it targeting web
sequel which was kind of cool I guess I
don't know I built a to-do list and
that's pretty special I don't know but
but really I think like shared models
sound great but it's not really as great
in practice because you have to know a
lot more or the there's sort of a limit
to what you can do you have to load all
the data and you lose out on a lot
because you don't need as much of what
you would need on the server on the
client if you're just displaying it so
it sounds great not as great in practice
and something that sort of moving away
from some of the model and collection
conventions from from backbone based on
some of the things I've learned having
been out there for a little while
so you can read more in the docs I'm not
going to go too much further into it but
I think one thing I'd like to point out
is that connection bookshelf are not the
first to do this so I mentioned earlier
there was already higher level sequel
abstractions in in JavaScript that I saw
and I was like I'll build these instead
and hopefully it's not the last to do
this so a few other projects open record
is a really great project that's using
connects under the hood and it provides
more of an active record like syntax and
sequel eyes was the big one and is still
still a big one and it didn't have
support for transactions it had a really
the api's were sort of rough and since
then it's it's come a long way I've been
really impressed with a lot of the
development going on with sequel eyes so
if you haven't taken a look at it and
while definitely take another look
they're doing some really really cool
things especially around the the new
postgres features features that are
coming out a new one that I just saw
recently it was actually by someone who
had been frequently commenting on on
bookshelf and connects projects and I
guess maybe had some opinions that were
different created this zul je s and I
was looking through and it's really
impressive it does transactions it
doesn't have quite the separation
between the query building and the ORM
layer but it it does a lot for you at
the at the ORM layer so that's another
one worth worth checking out sequel
bricks I guess it is pretty similar to
connects but with different opinions any
DB sequel node sequel which is by Brian
Carlson who does the excellent node
postgres driver even the drivers have
come a really long way since since I had
initially looked at them in 2012 the
node my sequel driver has just a ton of
documentation improvements and a lot of
features added and it's really
impressive how far it's come in the last
couple years there are different
projects built on connects connects
query lab which allows you to demo this
in the browser and have it spit out the
sequel bookends sort of does data nested
data loading and querying really well
it's on top of bookshelf and then
there's endpoints which is adjacent API
compliant library or framework I guess
that
has connection bookshelf under the hood
and then there's larger stack
implementations like like sales which
has their own RM but I know they were
talking about potentially using connects
as the query builder under the hood and
so they're also targeting you know all
the different sequel drivers and you
know that's just some of what's out
there but I really don't think this is
enough so we're still sort of like at
this stage where node is a really young
ecosystem and a lot of times you'll hear
don't reinvent the wheel like it's
already been done but I sort of disagree
with this I think that people should
absolutely be reinventing the wheel with
an asterisk just not on the client side
because like react already did this now
I'm kidding there but like we should
have more more experiments out there
because i think that types of
conversations were having since react
are really different a bit about just
the web in general and and because they
questioned a lot of opinions so i think
that you know take a look at other
libraries take a look at other languages
which is what you know a lot of what
javascripts about in javascript sort of
late to the party of being on the server
and a lot of the great ideas coming out
around a sink and es7 and esate are
looking at the best of what's around in
other languages so i think it's really
important like as i mentioned these were
adapted from from the lauraville query
builder and ORM in PHP and I'd really
like to move a lot further toward like
sequel alchemy model of ORN and query
builder so I've been looking a lot at
those but there's a lot of great stuff
out there but I what I really would love
to see is just knowed become more of a
target for traditional crud web
applications and to sort of prove that
stack overflow question wrong and more
so to just get awareness out there that
that you can do this type of boring
traditional website development in node
and I think the more that that becomes a
something that's that's well known the
more people will be writing JavaScript
and then more goes into the ecosystem so
that that was sort of the the goal of
creating these two libraries to sort of
say like hey you can do this and
hopefully that there's a lot more that
that comes out of this so that's that's
everything</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>