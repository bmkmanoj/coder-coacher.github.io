<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>[JSConfEU 2010] Douglas Crockford: Loopage | Coder Coacher - Coaching Coders</title><meta content="[JSConfEU 2010] Douglas Crockford: Loopage - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>[JSConfEU 2010] Douglas Crockford: Loopage</b></h2><h5 class="post__date">2013-06-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IqyFFupJrxw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning recently I was reading a
white paper which was describing for
comparing to application platforms one
developed in C++ and one developed in
Java and they went piece by piece
comparing the two and when they got to
garbage collection they described
garbage collection as a programmer
convenience and they counted the number
of lines of code and the C++ system that
was explicitly disposing of memory and
concluded that that was a very small
percentage of the entire code base and
therefore garbage collection was not a
significant convenience and should not
be considered in comparing these two
systems which was completely wrong
because that's not what garbage
collection is it's not a programmer
convenience it's a reliability mechanism
it's a way of guaranteeing that a large
important class of dangling pointer
errors cannot occur and it's only when
you have garbage collection that you can
consider a very rich family of
algorithms which are just too dangerous
to consider without it so basically the
conclusion of the paper was that it was
okay for C++ programmers to be
completely ignorant about Java and
that's just wrong we'll come back to
that later it's never good to be
ignorant about anything but today we're
going to be talking about loops this is
a loop statement we don't have a
statement quite like this in JavaScript
where you've got loop and you've got a
block and you do the things in the block
over and over again I kind of wish we
did for a couple of reasons one is most
of my loops seem to exit out of the
middle that you know the book says
you're supposed to always exit out of
the top or the bottom and JavaScript has
conveniences for that but I tend to
break out of the middle and you can
write that in JavaScript using while
true or for semicolon semicolon but they
both look stupid I'd rather have a
fundamental thing because that's
ultimately what I'm trying to do is I'm
just trying to go round and round but
the the more important reason is
it allows us to have sort of a smaller
core language and then Express
higher-level things in terms of that
Brendan gave us an example of that last
night with the meta object stuff that
sort of takes some of the magic out of
the language and allows more of the
language to be developed itself and
another approach to doing the same thing
is to have simple primitives which then
could be syntactically expanded or D
sugared into more expressive patterns
for example a while statement could be
transformed into the equivalent loop
statement and in looking at that
suddenly realize while doesn't actually
accomplish very much you I wouldn't miss
having it similarly we've got do while
which looks completely different but we
can see its expansion to loop it's just
the same thing except the if is on the
bottom now hello we've got the for
statement which confuses beginners
learning the language because you've got
these three clauses and it seems really
arbitrary which is which the equivalent
loop statement is pretty easy to
understand now another way that you
could think about loops is to turn them
into recursive functions so here I'm
turning a while into a function that
calls itself and continues to call
itself until the condition is met this
doesn't quite work in JavaScript right
now for two reasons one is the body
cannot be or the the body of the loop
which is a block can't be turned into a
function body if it contains this or
arguments or return or break or continue
so you sort of a special case but the
more important restriction is that
JavaScript does not currently implement
tail recursion optimization so you'll
run out of stack space in most cases
before this loop concludes and I'd like
to get that fixed some day two we'll
come back to that so the main loop i'm
here to talk about today is the
event loop the event loop is the most
important of all loops so the browser
has an event queue which contains
callback functions and those functions
get triggered by the timer on set
timeout or set interval x UI events
clicking and mousing and keyboarding and
by the network or onload and other
things in an event loop driven system
which the browser is everything happens
in turns so if the beginning of a turn
an event handler gets started it will
run to completion and then the next turn
happens and within your turn you can be
confident that you'll never get
interrupted so you don't have to worry
about anything else kind of spoiling the
environment while your turn is going on
now that puts a huge restriction on the
use of the system which is you've got a
prime directive in a turn you must never
block you must never wait and you must
finish fast because everything else in
the system is waiting for you to
complete nothing else can go until you
are done the event loop is one of the
best parts of the browser there are lots
of things that the browser got wrong
this is one of the parts that the
browser got brilliantly right with a
couple of exceptions there alert and
it's sisters block and so they're okay
to use for debugging but they should
never be used in applications because
they stop the main browser threads and
no other work can happen until the user
dismisses it also xhr was created with
asynchronous mode which blocks you while
you're waiting for the network to return
a result which is terrible so you should
never ever be using that either but with
those restrictions the browser got all
of the asynchronous operations for the
event loop correctly at being a
mathematician she thought should be
assigned a code breaking instead she was
sent to Harvard to work on the bark one
it
was a computer operated by the Navy
skins so when looks good me when she got
there her first assignment was to take
the machine apart figure out how it
worked figure out how to program it and
then write the manual so that other
people could program it so she was one
of the very first programmers and she
completed that task very successfully
after the war she went to work for the
first commercial computer manufacturer
which built the UNIVAC at that time and
for a long time computers were extremely
expensive there were millions of dollars
and the development of software was
extremely slow and difficult basically
programs were written as a sequence of
numerical codes it's just very very
tedious work and the thinking at the
time was that the hardware costs were
going to dwarf the software costs
because human life is cheap by
comparison to vacuum tubes so we'll just
throw as many people at it as we need in
order to make all the software that's
required she had the insight that that
wasn't going to work that programming
looks just too difficult and finding
enough amazing people like you to do
that level of work for the UNIVAC they
were not going to be able to sell enough
machines to make the business go so she
had this amazing idea we can use
software to make it easier to write
software so she developed a program
called a zero which was the first in the
a series serve an indication of how
smart a programmer she was she called it
a zero she didn't call it a one it was
the first compiler she called it a
compiler we call things compilers today
because of a 0 0 her idea was to have a
library of subroutines and that you
could call for those subroutines and
assemble them into a program and then
the program that you assembled could
also go into the subroutine library and
other people could build on that the
reason we call a collection of useful
software a library is
because of this the reason we call a
function you know why do you call a
function a function isn't anything like
a telephone call it's because of the
library metaphor that you call for a
book every book has a call number you
can call for the document and get it
that's the sense she had so there were
two kinds of subroutines in her system
open subroutines which today we would
call and include you just take the whole
text of the subroutine and stick it
right in the middle and then a new idea
the closed subroutine which you could
jump to and then jump back so you could
use it from multiple places in your
program but it only occurs once in
memory so in modern terms a zero was
more like a linker or a loader than it
was a compiler but this was the first
compiler and it went through iterations
which eventually led to modern
programming languages a later evolution
was a 282 was the first open source
project a two was given to univ ax
customers and they used it and some of
them modified it and gave back the
changes and suggestions for for further
improvement open source is almost as old
as computers but not quite the thing it
had to wait for was mass production
prior to univac every computer was one
off they build it mostly as a research
project and as a result of having built
it they figured out how to build the
next one better so it wasn't until
univac that you had lots of people using
similar machines and then open source
becomes a reasonable thing a to led to a
3 which led to a t3 which was later
renamed as mathematic it was one of the
first programming languages that we
would recognize today as a programming
language about the same time IBM
developed Fortran which turned out to be
the winner in this particular race now
turns out Fortran made programmers much
much more productive but some of the
best programmers of the day completely
rejected that idea
they said that programming took too much
creativity and dexterity for the human
being to be replaced by a very machine
they were manipulating they just didn't
understand what it was that Fortran was
supposed to be doing for them that it's
going to make them more productive make
their lives better and this is going to
be a recurring theme that very often
programmers are the last to understand
the the benefit of an improvement in
software technology so one of the
characteristics in both math magic or
mathematic and Fortran was blocking read
and blocking right so you got to a read
statement the program would stop it
would then go off to the card reader the
tape drive her wherever was getting the
data because the program had nothing to
do until it got the data anyway so it
would just block until the i/o operation
was completed the model for i/o and in
the early programming languages was sort
of based on the black box hardware model
we've got an input and an output and you
do some processing in between when we
went to time sharing the of that model
just came right along so you had read
and write statements that now talked to
teletypes and interactive devices so
programs became highly modal because
that each read statement the program
would be expecting one particular input
and the user couldn't type anything else
at that point or it'd be an error so the
flow of the dialogue was dictated by the
program not by the user and so the
programs were significantly harder to
use than today's programs time-sharing
economically dependent on the block and
read because while one task was stopped
on a read that time could be given to
other users and so that's how they they
had a machine that was much slower than
the device you've got in your pocket and
it'd be shared over a hundred people and
that was how they gave the illusion that
people were getting more time than they
actually got so since then virtually all
programming languages have had blocking
io every language has read and write
with only a couple of exception
see had no I Oh at all which was
actually an amazing advance because it
made the language much more flexible you
could use it in lots of different
environments including embedded systems
where you had completely different
notions of how I oh was supposed to work
unfortunately it also came with standard
IO and that's pretty much the only thing
people use so effectively it has
blocking io meanwhile some people were
starting to recognize that there are
other ways of managing io which which
were much more effective this was
happening particularly in research labs
like at Stanford Research Institute and
at Xerox PARC also people developing
text editors started coming up with a
notion that if you had just one read
statement for the entire editor that
gave the user a lot more flexibility in
how they can enter their commands also
people who are developing the earliest
computer games also made the same
discovery that they'd never wanted to
block on Io that they just want to have
one particular place where they could
get stuff and change the state of the
program based on what was entered that
didn't reach that idea didn't reach
mainstream programmers until nineteen
eighty-four in 1984 Macintosh which was
the first reasonably priced computer
based on an event model became available
and a lot of programmers looked at it
and couldn't figure out how to program
it they complain that you have to write
the programs inside out Wow it's just
too hard it's impossible to think about
it so we should go back to the command
line that's the way God intended us to
write programs that this kind of inside
out stuff is just wrong Apple released a
program called mac app which was a
skeleton of a Macintosh application
which had the event loop built into it
and affordances for creating menu bars
and all the other things you have to do
you just had to plug your code into that
they weren't buying it was still way too
hard to think about so event loop
programming might have died out at that
point except for hypercard Bill Atkinson
who developed quick
quickdraw and Mac Paint wrote a
multi-level macpaint in which he could
have many planes and imagery available
and you could switch from one to another
in each of those claims in addition to
having pixels on it could also have
buttons and fields and those buttons and
fields could have script attached to it
and the whole thing was avenged Riven
and it really took off because
non-programmers found that they could be
incredibly productive in HyperCard they
just draw a picture of something and add
a little bit of script to make it work
and boom they had an application and
people were developing all sorts of
things then the professional programmers
kind of looked at what the amateurs were
doing a guy in the ok yeah I guess we
could do that too and then suddenly
there was an explosion in programs for
the Macintosh am for windows which has a
similar model so HyperCard was all about
events it was so event oriented that you
didn't have to write the event loop
yourself it was built in so all you had
to write was he gun handlers so programs
which it called stacks were written as a
collection of event handlers attached to
visible objects cards fields and buttons
and events bubbled up as they do in the
browser and some of the event names may
look very familiar to you like on Mouse
up on key down on card enter in the
browser became onload you all remember
that on Idol was an event that it sent
out whenever there was nothing going on
when the event queue became empty it
would send on idle people figured out
that they could do animation with that
which worked fine for the first
generation of Macintoshes but when the
next generation came out which was
faster all the animation went crazy so
hyper car didn't anticipate that people
would be animating with it because the
CPU is at that time were so slow that
wasn't really an option but people did
it anyway so the lesson was if you don't
provide a right way the street will find
its own way we've certainly seen that
played over and over in the browser
so HyperCard had a big impact on the on
the evolution of the browser basically
netscape navigator to was combining
ideas from hypercard and combining ideas
from the original web browser and it
turns out that javascript is really well
suited to this model and that's not by
coincidence because javascript was
designed specifically to do this and
it's actually very very good at it so
the dom is awful i hope i'm not
surprising anybody anybody not aware
that the dom is awful but as awful as it
is with javascript the dom is really
effective and if you put an ajax library
on it like Yui 3 it becomes really
effective almost Pleasant so one of the
reasons why javascript is really good at
this and one of the reasons why you are
really good at this is because
javascript does not have read it's one
of the only modern programming languages
one of the only programming languages in
the history programming languages that
doesn't have blocking read built into it
this has always been seen as a big
disadvantage all JavaScript awful
because you can't read files with it but
that turns out to have been a good thing
because it means it's easier for you to
work with the event driven model than it
is for people who have practice with
other languages because you've never
blocked and so that the urge to want to
have to block and to find alternatives
to it it's not a problem for you you've
always done it right and you know read
is a problem in this model because we
eat blocks in blocking is bad for event
loops so JavaScript programmers are
smarter about using event loops than
programmers of other languages so
congratulations you're all smarter so
the event loop is just one approach to
concurrency we have a need to do lots of
things at the same time event loops are
one way to do that another is to use
threading and threading is the most
popular approach
of most programmers today so
everything's a trade-off there nothing
is perfect in technology so let's look
at the trade-offs with threading on the
pro side no rethinking is necessary so
you don't have to write your programs
inside out you can take any sequential
program put it in a thread it still
works so that's a huge advantage those
programs can block in fact they're
supposed to block the reason we have
threads isn't so we can do multiple
things at once it's so that we can stop
doing things and do other things while
that's still going on so can execution
will continue as long as any thread is
not blocked from the con side you have
to allocate stack memory for each thread
that was a problem once it's not a
problem now because memory is so
abundant a bigger problem is that if two
threads use the same memory a race may
occur and that is a big problem so here
we've got to JavaScript programs each is
only one line long each is going to run
in its own thread and they're both going
to run concurrently at the same time so
what would be the result of this program
one possible result would be the array a
and B and the other would be the array B
or a does everybody see how that could
happen because either those threads
could happen first and so you can't
predict ahead of time which is going to
win but that's not the big problem the
big problem is that there are two other
cases that could occur where after you
run that program you've got just a or
you've got just be that data has been
lost a hazard in thread programming is
any time you have a read-modify-write
which is basically all we do there's a
chance for collision so you can think of
threads as being cars or but they're
invisible cars so they can't see each
other but if they're ever in the same
place at the same time they crash so let
me show you what went on here
so when we append something to the end
of an array we can do that at one
statement in JavaScript but what
actually happens could be viewed as
several statements and so each of those
threads has those statements and they
could be interleaved in any possible way
there's no way to predict how they're
going to the interleaved and in this
case with this particular interleaving
the result is B because a gets clobbered
the last guy to write to the length wins
and this is terrible you know you
couldn't look at that program and see
you know what happened why'd our data
disappear well how did we command
consistent how do we become insecure
unreliable it's about all you can do is
say oh you're using threads there's your
problem so it's impossible to have
application integrity when subject to
race conditions now there's a solution
to raise conditions it's called mutual
exclusion so you can take some critical
section of code some set of statements
or some data structures and say only one
thread is able to have access to this at
a time and this has several names it's
sometimes called semaphores or monitors
or rendezvous in Java it's called
synchronization all these things are
pretty much equivalent this used to be
operating system stuff only people
writing operating systems ever cared
about this application programmers were
always exempt from it but it is leaked
into application space because of
networking because the delays now of
going over the network can be really
long and so having blocking I over the
network is intolerable and also because
of the multi-core problem that we have
lost the ability to make CPUs go faster
so to make systems go faster we have
more cpus and so now it's up to the
application developers to take advantage
of
that in order to make the machines go
faster because the hardware guy is have
given up and it turns out to be really
hard keeping multiple CPUs busy all at
the same time with one application is
something that is still an unsolved
problem but you're expected to do that
so under mutual exclusion only one
thread can be executing in a critical
section at a time and other threads that
are winged to execute in the critical
section are blocked if the threads don't
attract them the programs run at full
speed but if they do interact then races
will occur and less mutual exclusion is
employed but then there's another
problem there's the deadlock problem
where you've got two or more threads
which are waiting for another thread to
complete before they can proceed and
somehow they get into this deadly
embrace where they're waiting on each
other a real world example of this would
be gridlock we've got a bunch of cars
that all went into the intersection at
the same time this is Sal Paulo Brazil
about two blocks from the Yahoo office
they're all stuck everybody's waiting
for everybody else this is deadlock so
you don't want your programs doing this
and it turns out when you're doing
threads and synchronization deadlock is
really easy to cause and it's very
difficult to reason about so deadlock
occurs when threads are waiting on each
other races and deadlox are really hard
to think about they are the most
difficult problems to identify a debug
and correct one of the things that makes
them so hard is you can't predict when
they're going to occur and once they've
occurred that it may be impossible to
recreate so that they're the worst
possible kinds of bugs so managing
sequential logic which is what we do is
hard managing temporal logic is really
really hard and there are not many
people who can do that well so going
back to the cons if if two threads use
the same memory a race may occur and
that's actually worse than saying a race
will occur because if it if it does
occur predictably then you can
fix it but it may be that the temporal
signature of your program is really
different under test than it is in
production so it may work really well in
development but it fails when you show
it to your investors or it works really
well in in the early stage but fails
when you start to scale or it fails when
you're showing it to the MNA guys from
mega Corp they tend to go wrong at the
worst possible time there's some
overhead in thread management that it
doesn't come for free there's the threat
of deadlock which will just kill threads
and could possibly cascade to kill other
threads eventually strangling the whole
system thinking about reliability is
extremely difficult and ultimately what
we have is system application confusion
in my view the biggest design error in
Java was that it couldn't make up its
mind if it wanted to be a systems
language or an application language in a
systems language you have to have
threads in an application language you
should never have threads but because
they tried to bridge both they require
use of threads at the application level
and I think that's deadly fortunately
there is a good alternative to to
threading and that is that and that
alternative completely avoids all the
reliability hazards of threads and that
is the event loop or friendly event loop
it actually does all the stuff better so
again there are trade-offs the pro is
that it's completely free of races and
deadlox which is a huge huge advantage
you can be much more reliable turns out
you can also be much more efficient
there's only one stack which gets reused
on every turn that saves memory but
again that's not important anymore very
low overhead you don't have task
switching you're not doing memory faults
you're not doing any thread locking all
that expensive stuff you're just doing
computation as fast as machine can go
all of the idle time has been squeezed
out
just have pure computation the thing
that computers do best and it's
resilient if any turn fails the program
can still go on whereas in a thread
based system if any stack fails there's
a chance that that may cause cascading
failure of other threads as well now
comes with some cons cons are that the
program is never block you have to obey
the prime directive you have to program
inside out Wow but again your good of
this and turns must finish quickly this
is probably the most important
restriction says that not all
applications are well suited to running
as event loops but it turns out at very
large class of applications are so for
long running tasks like if you have to
factor pie in your web application which
is not something most of us have to do
there are two solutions for managing
that one is to use a technique called
iteration in which we break the task
into multiple turns and keep
resubmitting those turns to the event
queue for example you could have a
process in which you do one step of the
computation then do a set time out of
zero passing in the function which will
cause the next step in that computation
to happen you just keep doing that until
it finishes now that could end up taking
a very long time but each turn will be
very short and so the liveliness of the
system is maintained and all is good the
other thing you can do is move the task
into a separate process or worker and
that's a brilliant thing too one of the
advantages of workers is there's no
requirement that they actually be in the
same machine so we could send them
across the network and wherever we gots
their capability we can we can put them
and so that becomes a really powerful
model and in the event driven system
being fully distributed comes as a
fallout another approach people take to
doing io in programming languages over
the network is the remote procedure call
which combines two great ideas functions
and networking produces a really bad
idea like read it attempts to isolate
programs from time but the effect of
that is that the program blocks blacks
out it has last lost time so when you're
reading the program it's very difficult
by design by intention to see where it
is that time is being lost because the
blocking network calls are made to look
like local function calls you just can't
see where the time is going and that can
result in a very terrible experience for
the user because they see you know the
program blacks out and so the user is
going are you dead hello and that's it's
rude and disrespectful we should never
do that to human beings but it's hard to
avoid doing that when when you've got a
remote procedure call so we should be
doing the opposite we should be doing
latency compensation we want to give the
user feedback as early as possible the
leptin note were we were listening to
you we're working for you we tried to do
things we don't ever want to lock up the
browser of the client while we're
waiting for the network to do anything
in some applications the client can
predict what the server's response is
going to be and go ahead and do it so
the user gets immediate feedback and if
it turns out that the prediction was
incorrect then correct it later for
example if you have a game or chat
application being played over the net
the user makes a move and locally you
can determine that's a valid move or if
it's just a chat message go ahead and
display it as though it was accepted in
a few seconds you'll get the feedback
from the server telling you whether that
happened or not and if it did then you
can ignore that and if it didn't
than you correct it so security is
always important and and you really
can't have security if you don't have
reliability and we don't have your
liability when we have threads so we
have a much more secure model with the
event loop now just having event loops
does not guarantee that you're going to
be secure for example the browser is an
event loop driven system and were
subject to cross-site scripting attacks
which is terrible this is the worst
problem that we have in the browser
cross-site scripting has two causes the
sharing of the global object so every
piece of script no matter where comes
from gets in the same global object
which gives it all the same privileges
that your own site does including the
ability to interact with the entire
document to talk to the user if the user
is looking at the anti addition chrome
the chrome will say yeah legit gives you
the ability to talk to the server if
there's an SSL connection you get access
to the SSL ssl connection you get access
to all the cookies everything really
terrible there's also misinterpret
misinterpretation of HTML HTML is such a
complicated language with other
languages inside of it that it's very
difficult to determine if a piece of
code is going to be safe tragically
html5 ignores and worsens the xss
problem in recently the html5 editor
said that html5 doesn't ever have markup
injection vulnerabilities which is wrong
completely wrong so we can't expect help
from w3c but they're apparently not even
aware that there's a problem not
understanding the problem they're
unlikely to ever give us a solution so
the browser is a loaded gun aimed at
your head and that's what pulls the
trigger so page templates
are you know like PHP ASP JSP all those
Peas used to be a good way to develop
web applications but it there are some
problems with them now that one is that
the a template is to Richard a framework
that we're now building extremely
dynamic pages out of lots of components
coming from lots of different places and
putting them all into a simple template
really doesn't work very well but worse
than that it's way too easy to insert
text into a context where it might be
misinterpreted and executed completing
an XSS attack so can we do better by
using javascript on the server and there
are some obvious advantages to being
server side JavaScript one is that we
can take advantage of our new
understanding of JavaScript that turns
out javascript is a powerful expressive
programming language we can apply that
to server-side programming as well it
turns out this is not a new idea
netscape offered a server-side
JavaScript product in 1996 and it was
awful it used it was modeled after PHP
so it had a server tag in which which
looked like a script tag except it was
gripped that was going to run on the
server side and it had a write function
for inserting stuff into the outgoing
HTML stream it's just like document
right except on the server just as bad
so it had all the disadvantages of the
other page template assist amande at the
time really slow JavaScript engines so
what if we did it right what if we model
the server side using the same things
that we learned work so well on the
client side what if we had an event loop
in the server and it turns out that's
what no Jas is and there there are other
people doing similar stuff nodejs is the
the front-runner right now
and and there's really well worth
looking at so no Jas implements a web
server in a javascript event loop it is
a high-performance event pump it it
takes the event queue and pulls things
out and and doesn't really fast it
optimizes the event loop dispatch you
can get a lot of work done very quickly
all of the overhead is squeezed out so
the event queue is just pure computation
it got read right so filesystem read
takes a call back so it doesn't block
which is perfect that's exactly how we'd
should work everything in the no jsapi
is non blocking except there are some
synchronous functions which do block
there are non blocking versions but
there shouldn't be anything that blocks
and also require is blocking I think
that was a mistake as well it the model
really requires that everything be non
blocking but other than that no jf seems
to have gotten everything right so one
of the advantages of this is that you
can run your code on both sides of the
network so we have Yui 3 now running on
though j/s with a pseudo Dom so we can
now run exactly the same code in both
places and we can take advantage of of
why you eyes communication manager on
the server to go out and talk to say 10
different services which are going to
send back data which will get assembled
into your page and we can make all of
those requests simultaneously and so the
net cost is the max of all of those
requests whereas in PHP the net cost is
going to be the sum of all those
requests which is going to be a much
larger number now it turns out in PHP
you can do it the hard way but nobody
wants to do hard in PHP right that's it
that's not what it's for whereas in
JavaScript under Yui it is easy you just
wait for all the event handlers or all
the callbacks to fire and once they've
all fired on with the show so it's
really brilliant also we're finding that
we've got a really nice fallback story
now
we can if we sense where the browser is
a piece of crap like I don't say for
random ie6 and we're tired of supporting
ie6 we can run it all on the server and
just send them page views or if we
decide that our startup is taking too
long because we've got a huge amount of
code we might want to do the first view
on the server so that people can be
looking at that while the rest of the
script is loading on the browser we can
do that as well you don't have to write
everything two or three times to
accomplish all those things you only
have to write at once and with a good
library under you it just works so we've
got a lot of mobility a lot of
flexibility so good stuff they're
looking a little deeper looking at the
network itself we've got this stack of
protocols at the bottom we've got IP
which can deliver a packet from any
computer in the world to any other
computer in the world almost all the
time which is an amazing thing then on
top of that we've got TCP which provides
sessions reliability packet reordering
which is good stuff then we've got HTTP
which is really a document delivery
protocol which is stateless then on top
of that we're trying to do messaging in
Ajax but we have to do it on top of me
HTTP which has a lot of beneficence e in
it and it wants to be stateless but we
really want to be stateful because we're
doing session applications and so it'd
be really nice if we could just get rid
of HTTP and runny Jack's on top of TCP I
don't think we're ever going to be able
to do that because there's so much
arthritis or built into a network
now you know all the various proxy
servers and firewalls and stuff like
that that'll probably never work which
is really a shame so let's sort of go
back to the beginning of time so first
there was a browser and there was a
server and the browser makes requests to
the server and documents go back then we
got to the point where the demand on the
server was so large that a single server
couldn't do it anymore so there are
various implementations of having some
kind distributor which goes in front of
the site which can then direct traffic
maybe on a round-robin or at least used
or whatever basis to other servers
that'll actually do the work and then
they all go to a common database
initially that tends to be some kind of
SQL machine and if you're at all
successful that's going to fail because
it won't scale big enough to meet what
you have to do so you do tricks to make
SQL scale you'll you know splinter it or
do other things which violate the
relational model but you don't have to
rethink anything and that turns out to
be the most important thing but the
other approach is to consider a no SQL
database and I love these things so
we've got like couch and Mongo and a
whole bunch of others which are just
acting brilliantly there it turns out
yahoo has had a massive homegrown no SQL
database in productions of 1996 so these
are really good things so then we put
Ajax on top of this and now in addition
to the persistent state that you want to
keep in the database you've got a
femoral session state you know choose
sort of stuff that you're talking about
that isn't ready to commit yet where do
you put that stuff in this model where
you have the distributor you can't keep
it in the servers because each request
might end up going to a different server
so you end up having to put this
ephemeral information in the database
which is maybe the worst place in the
universe
you want to put it another approach to
that is something that you see in the
Elco server developed by chip morning
star in which the browser connects
initially to a session director and the
session director will then appoint some
server to be the place where the session
will live and from that point on the
browser connects only to that particular
server that server can then keep it's
ephemeral state in the most efficient
place in the world which is in
JavaScript variables which are
enclosures bound to the event handlers
in the event queue in the server so that
the overhead for getting at at session
state is zero it's absolutely free
there's no api for getting that stuff
because it's just in variables so it's
extremely efficient so i was talking to
a good friend of mine recently well
really smart guy about javascript and
what we might do with it and i was
talking about how i would like to see us
implement the tail recursion
optimization i talked about earlier in
the language that would allow us to do
recursion for looping which would have
some efficiency benefits also what
allows to have new styles of programming
available such as continuation passing
style and his answer to that was that
he'd never used continuation passing
style so he didn't see the value of it
and I immediately recognized that as a
stupid answer and I knew it was a stupid
answer because I have made that same
stupid arguments many times in my career
and I've been hearing that same stupid
stuff as long as I've been a programmer
I've heard that argument used to explain
why we shouldn't do event programming
why we shouldn't use high level
languages why we don't need recursion
why we don't need closure and functions
I don't understand it never needed it
what good is it I can do my job
perfectly well without knowing any more
than what I know
and that's a really dangerous thing so
when Grace Hopper are we've come a long
way in software engineering since Grace
Hopper started us on the road of using
software to develop software and we have
a long way yet to go and in my view we
should be a lot farther along by now
than when we are and I think it's mainly
because we get our own way that
basically to take the next step forward
we have to wait for a generation of
programmers to die off before we can get
critical mass of brains on the powerful
no idea to go forward and we're now in
this really interesting position where
we're about to take the next step
forward in application development and
the language which is leading the way is
JavaScript which is amazing javascript
has transformed from this horrible
little language that we can barely
tolerate to language which we're
embracing and is now leading everyone
else so um show of hands anybody having
strong
let's try one more what do you think of
this all opposed let's see two or three
hands okay how about that Wow now how
about this one I think it is too soon to
call I see Microsoft doing some really
good work on ie9 I've seen some
applications which are running better on
ie9 than any other browser so kudos to
Microsoft for that but then we got that
bombshell last night when Pete from
Microsoft told us that they don't intend
to implement all of equus script five in
that standards compliance is apparently
not important to them I'm really
distressed by that so in my view the
only web standard that matters is the
aircon script standard because the DOM
is crap right does everyone everybody
knows that the standards for the Dom are
crap it's always been crap we have
terrible portability terrible
reliability it's at the wrong level of
abstraction everything about it is wrong
but with JavaScript somehow we've made
it work javascript is sort of the
ultimate workaround tool whatever crap
the browser can throw at us we can
manage it with javascript and there a
couple of reasons for that one is that
javascript actually got a lot of stuff
right it's actually a brilliant language
despite its its defense you know deep
down there is brilliance in the core of
the language the other thing is that
it's extremely portable that if you
stick to the core part of the language
you know that's sort of the giant subset
of the language it runs everywhere it it
keeps the write once run everywhere
promised that java failed to keep and so
that's why it's so distressing that
Microsoft is now saying that standards
compliant
with the only web standard that matters
is no longer important now they haven't
shipped ie9 final yet so there's still
time for Microsoft to do it right I hope
that they will so on that optimistic
note thank you and good night
oh yeah so Tom well time are you
demonstrating or time are you here I'm
crowd cheering you in the room oh okay
oh they are so are you talking about
this this afternoon
okay so you're going to be talking about
the ability using Yui 3 on nodejs you're
not talking about that oh okay so don't
go to his cock anyway we have a
demonstration of for example we've got a
calendar widget and Yui and you run Yui
3 in the browser and you can click on a
date and the date opens up and so on you
can do exactly the same thing on the
server side using exactly the same code
you just configure it so that instead of
that you take the thing that it created
on the server side serialized it taking
its inner HTML and setting that to the
browser instead so with a you know just
a little bit of new library code you can
have your application run on either side
of the network or on both or you could
also set up your application as a web
service so if it's called in a
particular way instead of building a
pageview would only builds a div which
you could then transport so it becomes
much more flexible we used to have to if
we want to get something like this have
to write the application several times
and now we only have to write up once
anyone else yes
a continuation passing is something that
was developed with skiing and it's a way
of you express a contact as a function
and you can pass that along and so
you've got a thread of execution in
which functions never return that
they're always going forward and and
passing along the function that should
return that should be given the result
of the computation so far and so it's
always going forward and because it
never returns eventually you'll you'll
have you'll exceed the stack so in order
to make that work you need to be free of
the stack and the tail recursion
optimization or proper tail calls
accomplish that so I I'm not certain
that it's appropriate for all
applications but for some of the stuff
particularly some of the server side
stuff that we're looking at where you
get these really convoluted nesting of
you know this callback in that one and
that one having continuation passing
would be another set of tools they would
have for managing that complexity it's
something that we've talked about in in
tc39 which is the echo script committee
the trade-off here we should talk about
this because in certain cases we don't
have to remember a a stack trace going
backwards debugging becomes more
difficult because you'll get to
someplace in the debugger and you can't
see how you got there because we're not
tracking that information anymore so
that's a trade-off some people have
suggested we just turned that off while
you're debugging but that means any
algorithm that would fail without tail
recursion would fail when you're
debugging and so that doesn't actually
solve anything so it's a hard trade-off
and up until this point we've decided
not to do it now it might be that being
aware that this is going on a smart
debugger could instead of relying on the
stack to keep its state could be doing
something else instead so it's not
necessarily a hard trade-off but at this
point the people who are most opposed to
it our browser makers got probably
because they can't determine what the
cost of that's going to be to them yeah
javascript is moving beyond its role as
the language of the browser to be the
language of the browser and the server
and the synergies that will be available
to the development community I think
will be significant yes
the thing I would like to change about
html5 is I think they should have
corrected the cross-site scripting
hazard before adding powerful new
capabilities so in my view html5 makes
the problem worse in three ways that it
increases the attack surface because
it's huge and complicated anytime you
have something that's huge and
complicated and knew that means that
they're more places that the attackers
can figure out that the get happened
cause harm the second is that even using
the existing attacks which we saw
Twitter taken down last week right so
this is still an ongoing problem the
attacker now gets powerful new
capabilities that get access to your
local database now and there's no
restriction on what they can do to that
database that's huge they now have new
tools for getting out to the network in
causing greater damage behind the
firewall or wherever else and that's
huge then the third is because html5 is
so big and complicated and fuzzy it may
take years before it's finished and I
think we have to wait for that until we
can get to a correct solution so it's
postponing doing the right thing in
addition to doing the wrong thing that
said there are a lot of good ideas in
html5 and it's nice that we're moving
the web forward but I think they got
their priorities wrong and they're doing
things out of water it's really
attractive to add shiny new features to
a system it's much harder to correct the
fundamental problems in the system and
they chose not to do that and I think
that was a tragic mistake yes
thank you p I appreciate that and and I
do very much hope that idea or that
Microsoft excuse me does do the right
thing on this that in particular equi
script five isn't a standard that was
forced on Microsoft out much like pretty
much all of html5 ones that Microsoft
actually participated in tc39 right was
helped desiring echo script five
Microsoft was the editor of the equity
script five standard Microsoft voted yes
at the General Assembly I would like for
Microsoft to follow through on their
development and good work on the script
by thank you ok I think we're we're good
with it with the questions now got to
move on what duck will be around so you
can ask them more questions later on
Thank You doc that was wonderful</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>