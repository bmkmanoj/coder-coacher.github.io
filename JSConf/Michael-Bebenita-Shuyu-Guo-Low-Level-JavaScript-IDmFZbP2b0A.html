<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Michael Bebenita &amp; Shu-yu Guo: Low Level JavaScript | Coder Coacher - Coaching Coders</title><meta content="Michael Bebenita &amp; Shu-yu Guo: Low Level JavaScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Michael Bebenita &amp; Shu-yu Guo: Low Level JavaScript</b></h2><h5 class="post__date">2012-10-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IDmFZbP2b0A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm Michael is the shoe here we both
worked on Lola with JavaScript and I
guess it's a programming language right
it's not the mobile world's most
beautiful programming language it's
still JavaScript however so you can so a
low-level JavaScript now well JavaScript
program will just part us as a low-level
JavaScript program so you can actually
it's just JavaScript with semantic type
annotations and what is it for what's it
good for well it's only the real purpose
of it is to let you write sort of memory
efficient code in JavaScript a little
bit less painfully and of course it
compiles to JavaScript so here's my
favorite data structure that I learned
when I started computer science it's a
linked list so can anyone see the the
code all right so this is how I would
write a linked list in JavaScript now if
you wanted to create say a linked list
of 40 million JavaScript objects which
is quite impressive that you can do it
so quickly it takes about two to four
seconds in either spider monkey spider
monkey or and v8 which is pretty good
but if you actually look at what's going
on here is the JavaScript every
individual JavaScript object is quite
fat right it has a as a header which
contains some sort of type information
either pointed to the prototype or some
data structure that maintains this
information about the object perhaps
some GC flags it has several properties
in it so on a little in the linked list
example we had only we were only seeing
two properties but it may be that the
object when it was first created had
more properties in it perhaps slots to
hold these four properties because
objects are extensible and each
individual property within the object
could sometimes be up to four bytes long
eight bytes long right because you can
have a store into double perhaps a
reference so they're quite fat so if you
look at what this looks like in memory
you just end up with these very fat sort
of JavaScript objects and you can
represent this much more efficiently
with using some sort of an array data
structure right so you can just allocate
little notes than the array and then you
can use you can treat pointers offsets
within the array and you do some like
really ugly JavaScript
code to sort of manipulate this data
structure now you can do is very
efficiently so one thing we learn from
em scripting is that using typed arrays
you can add some model memory pretty
efficiently so I guess I don't have to
explain typed arrays but it's actually
just a real quick just allow me to
overlay different views on an array
buffer so essentially the way although
Jess work so we just you sort of request
a memory module what allocates so you
want 32 megabytes or so and then it
gives you ability to read and write in
this data in this write buffer using
these views now okay so the previous
example if you want to write it in c
like way you basically write this kind
of JavaScript so here you essentially
like p you disappointed to the first
object and the p glass is supporting
index to the last object in the
ArrayList into the in 32 array and you
need to sort of like manual pointer
assignments and so on now if you ran
this kind of code in spider monkey or in
v8 it's about 10 times faster than the
previous example so which is quite a big
difference now this is obviously for
several reasons so but what is more
interesting is the memory usage so I
sort of an I used that addy trace probe
to sort of measure an amount of memory
that's requested form the operating
system by both spider monkey and v8 and
for the an example with objects it's
about two point four gigabytes right the
actual amount of data that we really
need is about only about 300 megabytes
right but the amount of the matter of
sort of memory requested is much much
larger so it's about 8.2 four times and
spider monkey and if v8 it's about 13 or
so now this does this is virtual memory
so I'm not saying the vengers really
used this much memory but you know it's
still quite significant if you were to
program the same thing using structs you
would end up with only about a 1.3 x
sort of memory overhead so in either
case both like the difference between
using objects instructs is about 8x
somewhere between four and eight X which
is quite significant I think so
basically we want to do is like can you
just write this kind of code in
JavaScript
and I understand it's extremely ugly to
seek seek pointers and arrows and stuff
right but it kind of fits into the
syntax we really only need to do is just
sort of add these like see style type
annotations in front of variable
declarations okay so we sort of tweeted
about this we worked on it for like
three weeks tweeted and then could
imagine like the tweets right so what
have we done the world just wrapped
around and swallowed its own tail this
is my favorite sometimes you just want
to tell people please instead of doing
this go volunteer a soup kitchen or
something and I totally agree it's crazy
crazy all right so how this all get
started well when I was working on
Broadway Jess I was really surprised the
fact that like you can actually write a
codec in JavaScript and without any sort
of like interruptions I mean the frames
were like I mean it was not as efficient
obviously a see but you had no GC pauses
which is kind of really important for
doing that kind of programming so we
sort of looked at I'm script and so can
we just take sort of the good parts of
em script and I mean it's great but it
still relies on a C and C++ to change so
if you want actually want to integrate
write some code like this in your
JavaScript program so you have to rely
on the C and C++ toolchain and then use
llvm and compile to JavaScript so can't
we just sort of why not just take the c
and java script and add them together
and we came up with LHS this is sort of
well originally named of star yes but
then everyone complained that they
couldn't google it so we changed it like
the next day all right so what do you
really get well the first thing you get
is there's no more of our statements it
just lets write this is sort of make it
look more like me now c c sharp java and
so on block scoping you get machine
types so if you declare a variable y
which is the maximum injure sighs and
you add one to it you don't get sort of
overflow into a double you just end up
with zero you can declare structs like
you would expect and C in C the C basic
well sort of see ish with declaring your
functions within the stroke
and here I should have done is
overridden this sort of to mean a
pointer to the vector struct rather than
JavaScript is but so essentially this
what this looks like right you can you
can have constructors it's this is a
much more efficient representation it's
only takes about eight bytes right for
the two floats and property axis is a
lot faster because when you say
something like Carville ah sativex you
don't have to do point I chasing to get
the objects and then request properties
you just compute an offset into the car
sort of data structure we also have a
raise likessee Ras multi-dimensional you
can just compute offsets until very
quickly unions some people also wanted
these bit fields that people do in C
actually even know this was possible but
so well I guess we'll try and see if we
can do that as well of course you also
have pointers so declaring code like
this when you say you have a swap
function takes two pointers so you can
do all this weird see pointers you can
also take addresses of local variables
right so the way how do we implement
this right you can't get an address to a
javascript thing so if at any point you
take a verse of a reference of
JavaScript object well variable we just
allocate on the stack so we emulate the
stack using this SP variable we
decrement it out of the mouse works but
so this would be like a method
activation frame we just subtract the
stack pointer and then we allocate X
variable at the first stack location and
then the next one at the following one
you can just stack and heap allocation
of structs so you can for example write
code like let vector V 0 and then you
can call a constructor and this comes oh
by the way for the on the right side
okay on your right it's what we compile
to and on the left is LJ s good so you
can declare for example two vectors on
the stack and if you want to assign one
vector to another since the use of value
types we just made a mem copy operation
of course you can also declare you can
allocate things on a heap so you can say
new vector so here new means something
else because we know what the type of
vector is it's a it's a struct type then
we just they made a Mallick followed by
a call to the constructor the delete
operator is also over in to mean
something else in this case it calls
free on the allocate address of course
this means you have to implement your
own on malloc and free and we have I
read the sea can get our book and I try
to understand how malik like we just
copied exactly the same implementation
of malik and pasted it in analogous and
more or less worked all right so i think
this is shoes so she's going to talk
about sort of the more implementation
details hello not great all right so i'm
going to talk more about the
implementation sign the compiler so what
do we get with kind of emulating the
heap using a giant typed array well my
other things we get safety in quotes
since we have the entire memory in a
typed array it means we cannot get
crashes in the traditional sense like if
you read out of bounds or something that
your your program crashes basically all
you get here is well you get your
program probably just as a bug is your
reading memory that you didn't intend to
but this allows us to basically have the
C type system and let you do unchecked
casts and memory operations they are
unchecked and that everything's in
reinterpret cast like in the bottom here
you can cast anything to a pointer
there's really no complaints and but
you're not going to get any crashes the
compiler itself is fairly
straightforward we've used several very
useful open source tools like a spring
line Nia's cochin to hook into basically
a couple transformation passes but most
of the stuff we use was was is available
to to the web we use we extend ass prima
to with the ability to parse type
annotations and some other see
constructs then we run a couple
transformation passes and then we pass
it off to yes coach n to serialize to
JavaScript if any of you has had the
misfortune of writing a sea front end
you will know that cast expressions are
a pain in the ass to deal with because
they are ambiguous between function
calls and cast expressions you don't
really know until you have parsed the
entire program what is a function and
what's a type and yeah it suggests just
a little aside that's not everything and
c is nice and clean and simple so what
what do pointers compiled down to in ljs
on the left column the leftmost column
you see ljs code in the middle column
you see ljs generated javascript and in
the rightmost column you see em script
and generated JavaScript so basically we
have three pointers of varying sizes the
I means it that it's signed and the 32
means how many bits it has and then 16
and eight and so forth and then we
assign them to each other and we do some
dereferences now typed arrays as you
know allow you a couple of use such as
32 bits and 16-bit into nate biton's and
what it doesn't really allow you outside
of data view which is slow but it
doesn't really allow you is unaligned
memory access you can basically only
read things at sixteen byte 16-bit
boundaries a bit boundaries 32-bit
boundaries and what this allows us to do
when generating pointer code is to
instead of storing byte addressable
addresses as inside the pointers we can
store the indices into their respective
heaps into respective views on the same
heap so instead of instead of scaling
the address when we're indexing into the
array we only scale it in ljs when we're
assigning into the pointer so this lets
us save a few operations we're basically
betting on the fact that you're probably
going to be accessing memory a lot more
than doing people doing pointer
mutations between different widths and
scripting does as little differently
whereas they always scale the address
when they access but then since
everything is byte addressable they
don't need to scale the addresses when
they assign the pointers to each other
this is just the trade-off between
what you think your program is going to
be doing more another nice thing about
things like I'll jsm scripting is that
when you compile your code that now the
hat that has machine types you're
generating code that's much more
friendly to your jets than normal
JavaScript now jets including the
JavaScript Jets really like monomorphic
code meaning if your program happens to
basically only work on one type ever
your variables are basically monomorphic
instead of polymorphic they can annotate
or sorry they can optimize much better
and we have higher level information as
the Ojays program that this thing is in
fact an enter this thing is in fact the
you int or whatever and we it'd be nice
to tell the engine somehow that you know
we know this for a fact so you shouldn't
emits a overflow checks for addition in
javascript because in javascript we
don't we only have one number type of
course the engines represent them is
either and in 32 which eventually
overflows to a double or something but
to the JavaScript programmer there's
only one there's only one number type
and addition it's not closed on the
integers for instance and it'd be really
nice if we can tell digit that it is for
this program closed on the on the
integers then it can emit more efficient
code so in things like ljs we can do
things such as compile ends down all
accesses of variables that are declared
to be ends with a bitwise or 0 this has
the effect of telling the engine that
every use of this variable is truncated
to 32-bit ins and you can just kind of
forget about the overflow checks among
other things this lets you have more
predictable performance because a chitet
language usually have dynamic checks for
soundness and they end up recompiling
doing this lets you also sometimes get
rid of those dynamic checks all right so
that's basically what we have in the
language fairly simple and how we
compiled them I thought we compile the
more interesting bits this is just an
example code for how would we might use
it this is a
struct of a 4 by 4 matrix with some
accompanying multiplication function
that does simple matrix multiplication
but this is not so nice to use all we
have a destruct so maybe we can write a
thin wrapper that has one field which
basically makes the new struct and then
use some casts here and there to call
the multiplication method that we
defined so we end up having a more
JavaScript e interface note that we
actually manually cast dis de m and
other not em back to capital m star
because once we're in JavaScript land
the types are gone that the type system
is simply not strong enough we don't
want it to be strong enough to be able
to somehow infer that this dynamin other
dem are in fact mstars so here you have
to write some manual interfacing code
but then this leads the question now
that you're manually managing memory you
can have memory leaks so what do you do
well maybe you can have a free function
which then calls the delete operator
which then actually frees the memory
allocated in the end of the heap but we
can't do that either well we can but you
have to do this manually will be nice if
we had some language level support but
we're no longer relying on the GC if the
language could expose finalizes then we
can do this but we can't expose
finalizes for reasons of not exposing GC
state already 5 weak references it'd be
nice if we could do that too but we
don't have weak references either with
requite with weak references we can tell
if something is about to be collected
much as with finalizes so now we have
but but we've gone through this before
with see without the without the memory
problems and the double fries and the
remembering not remembering to free over
the summer one of our interns Tim Disney
of sweet j/s fame haven't checked out
his macros work you already should he
worked briefly he wrote this in like two
weeks or something he since now the heap
is a JavaScript object and so easily
instrumental he basically wrote the
equivalent of a valgrind like tool for
ljs which then detects these things
that's pretty cool
another interesting property of
something like knowledge is is is that
since it is not dependent on the entire
C and C++ to chain it seems like it
should have better interoperability with
JavaScript but we cannot yet store j/s
object in the LG as heap because typed
arrays only take basically those machine
types and they do not take any arbitrary
object we have a couple ideas on how we
might do this maybe we can have an
object ID mapping when we need to store
an object maybe we can have a shadow
heap that only stores object that is not
a typed array a shadow heap of normal
JavaScript array but it's in the works
and yeah but interop is basically pretty
hard so some general concluding remarks
this is kind of crazy as that as to as
the tweets have shown but it's not a
general purpose tool we're not asking
you please write all your j/s this way
it's it's that that's asking you to go
back to like 1960s so but if you have a
few bit of bits of code in your in your
little game or whatever application
you're working on that really needs that
memory compactness that actually lets
you write real data structures that have
higher structure overhead if you have if
you have like prefix trees with a lot of
links with very little data per node
that's going to kill you when you
allocate a ton of little objects in
JavaScript this lets you get around that
and if you really miss you know assembly
and stuff and you're not lucky enough to
work on the jet engines this gets you
back in touch with the bits and bytes so
the status of this project right now is
that we have a research prototype which
really is just a nicer way of saying
it's really buggy but it works for the
most part we have a nice if you have
note installed it has a command-line
compiler that you can use it ships with
some with you know the ke andar malik
implementation which is the probably not
the Mallik you want but it works we have
at least two users me and Michael but
apparently this was made known to known
to us via Twitter the other day so so we
rewrote this entire language though you
you have manual memory management so you
can have compact you know nice efficient
code and the first thing that someone
writes and publicly tweets is a marking
sleep GC it's quite amazing all right
thank you for listening happy to take
any questions
sorry
so right now the the oh sorry the
question was if i want to write part of
my program in normal javascript and a
little another little part of my program
in LG s what hoops do i have to jump
through to get them to work together
right now the command line compiler
generates a module pattern around your
ljs code which then is just normal
javascript code the problem is the types
are erased in the generator JavaScript
code so you have to basically have a
little exports father you write yourself
to preserve the types when you need to
use it from elsewhere like in the matrix
example that we showed in the prototype
that malfunction when you get this time
out you don't know that it's a M star
and you have to basically cast it back
but otherwise is I mean we just generate
normal JavaScript function so you can
just call it it's parameterize around
the typed array heap and you can choose
how big you want that to be when you
generate the code
for example when when I malach or free
something is it just to make sure that I
got it right yeah you have implemented
your own heat which is a typed array and
there are all the memory operations
performed on right yeah so I mean it's
essentially keeping a free list
internally so every like allocate when
you send new it just finds the next like
free list know it and then like it gives
you a sort of it has to put the malach
header in front right so I mean it's
just it's like arm position dialogue you
know regarding the alignment of areas
you talked about what happens when I can
you go back to the align the alignment
slide when I takes the let's say the X
array it which is an ia32 array and
constituent I 16 array then I can access
unaligned memory right so so you
determine up casting a pointer or Yeah
right and I'm you can never cat because
basically when you when we shift over to
like scale the pointer addresses then
you basically just lose the precision so
two pointers you know on top of each
other I mean they basically have to be
aligned to the widest all right that
would be I guess Toby
right that would be a problem we can we
can fix them well just put them
different places research prototype yes
yeah actually like just a minute ago I
realized that we if someone throws an
exception like we don't do anything
about the stack pointer to like fix it
yeah okay question um and point a
ruthless II am there you just lied for
that or example is it even necessary or
I mean I mean do you want what you want
to do that yeah i mean if used to
writing your array traversal code using
bumping pointers instead of using that
index you can do that is fine i mean
it's it's the generator codes not too
bad to read either because they're
you're not kind of crossing this
alignment boundary you're just bumping a
pointer of the same alignment so it's
actually just a bump in the an increment
in the generator javascript code also
it's not it's not too bit of course the
rest of code is going to be hard to reap
is it's all going to be it access into
the memory so what lessons are you gonna
take from this if any and put them in
normal spider monkey what do you mean
like like the features language or no no
but like what can we do you how can you
make spider monkey faster you know you
seem like some of the original examples
in some ways you do know the types yeah
and you can always do things like trick
so i can say you can met do pattern
matching on like the kinds of code they
generate i think so for this particular
pattern i can like have a fast
optimization like the example with over
0 yeah i think with em scripting and
especially its its is driven in the new
in the new spider monkey janiyah monkey
there's there's analysis to look for fit
wise operations and things that truncate
to 32 bits and
and omit overflow checks and and boxing
and stuff like that so we should be
doing lots of bitwise operations and and
so on shifting by two instead of
dividing by eight things like that I'm
gonna say no because that's gonna make
your code look a lot worse if you want
to do that as like an extra bill pass
feel free but like you know it seems bad
to have the programmer to jump through
hoops to optimize for a specific it
seems like all right you so you talked
about the memory overhead in just
vanilla JavaScript objects I'm curious
if there's a crossover point where the
cost of you malloc and free implemented
in JavaScript becomes higher than the
cost of memory allocations and garbage
collections that are implemented in C++
probably typically in most of the
engines do you have any data on that
like in other words how much random
allocation and freeing what I have to do
for the overhead of the regular objects
to actually be smaller than the overhead
of allocation and freeing that you guys
have to do manual in JavaScript well I
don't think it's America's family matter
of like because I mean the GC is really
really fast right so it's not about fat
in particular is that you don't have any
GC pauses so even if it's about the same
speed it would be sort of a smoother
really are talking primarily about
pauses so if we like if insiders we got
the pauses down to negligible speed we
will be faced the on par with the goals
that you trying to accomplish yeah is
that I could but I don't think it'd be
hard to keep it sort of consistent speed
I mean sometimes like you want to
control exactly if you have if you're
drawing frames maybe you want to trigger
GC exactly at this point in time so that
your animation looks a little bit
smoother even if you get your GC to be
extremely fast it's unlikely that
they'll exposed that level of control
right I mean you can always just do like
region allocation scheme so you can do
your own Melek you just wipe out the
whole thing when you're done with that
so sorry didn't you see the disco de
looks more like C code herbs and
JavaScript code and in this case I think
more efficient right Collins the simple
truth and to use node.js model right on
sibley spoofs no crash k repeat on what
you make right you're modest for not
just in on the Clean Cities blues and
didn't you think that it's very empty
will be more affection since this no
utrom le writing actually running in C++
modules and then I think bindings to
good job well I mean should certainly
that's much more efficient no Jess but
if you want to run on the browser
something I didn't see benefits from
this variant from this Ze'ev around but
they run so I mean detection running
native code right you can just are
writing a native code and the writing
and using some foreign function
interface to use it inside now or I'm
not familiar with what exactly you're
asking the node stuff
004 noches I mean I think you're better
off just writing you know he's writing a
seed right but if you want to needed to
run in the browser yeah
right right this is I mean the compiler
is in JavaScript for you while you can
bundle the compiler on your page and
whatever the rest of things the nice
thing do you get with all JavaScript
solutions ok great ok so I think that's
it for this thank you very much you and
Michael</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>