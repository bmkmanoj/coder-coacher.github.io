<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Refactoring CSS Without Losing Your Mind&quot; - Harry Roberts | Coder Coacher - Coaching Coders</title><meta content="&quot;Refactoring CSS Without Losing Your Mind&quot; - Harry Roberts - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>&quot;Refactoring CSS Without Losing Your Mind&quot; - Harry Roberts</b></h2><h5 class="post__date">2016-12-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kbGYPm9uYfk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well good afternoon everyone um
today's been amazing it's so good to be
here the quality of the talks has been
absolutely astounding which puts a lot
of pressure on my shoulders for the last
talk yeah it's quite a long talk it's
quite a lot slide so I'll try not to run
over refactoring CSS without losing your
mind quite a scary topic refactoring any
kind of code kind of scary CSS is
particularly difficult so in this talk
we're gonna look at some fairly
philosophical stuff how do we prove the
business case for refactoring CSS how do
we go to our product owners that were
project managers and get the time to
refactor stuff what should we refactor
what do we decide to refactor what can
we leave alone for a bit longer
that's gonna be the philosophical stuff
and then we're gonna move on to some
fairly practical tips and tricks and
some weird stuff to help us actually
refactor our CSS yeah so hello again
from me it's my first time ever in
Argentina so obviously my first time
when Azhar is such a cool city having so
much fun um I'm Harry I'm from the north
of England which is probably why I'm
really hard to understand very specific
weird accent I am CSS wizardry online
get Herbeck cetera but my job is I'm a
consultant front-end architect so I deal
with CSS architecture uh performance and
I usually tend to do this at scale I
tend to work with fairly large companies
which means bigger code bases more
developers bigger teams
long-running projects which also means
that there's more reason for requirement
or a necessity to refactor things and
unfortunately I hate refactoring CSS
anybody here refactored some CSS before
yeah most of us keep your hands up hands
back up keep your hands up if you
enjoyed that experience yeah exactly I
don't trust you one person in this room
enjoys refactoring CSS so yeah it's
awful it's a horrible job because CSS
you can't really write tests for it so
if you modify one thing you don't even
gonna break everything else
so hopefully in this talk we'll look at
some ways of making the refactoring
process a little bit simpler a little
bit safer I'm not gonna promise you
it'll be an enjoyable experience but it
will at least be a little easier let's
start off then what do we talk about
when we talk about refactoring there's a
really nice definition from a very very
clever man called Martin Fowler and he
says that refactoring is the process of
changing a software system in such a way
that it does not alter the external
behavior of the code yet improve the
internal structure so right away what
I'm getting from this is that
refactoring doesn't benefit our users
it's not for them it's for us it's a
business decision it's a decision that
developers product owners they make it
so that we can have a nicer environment
to work in so it's not initially for our
users however I would argue that given
enough time it will ultimately benefit
our users because we'll be delivering
better quality software we'll be
delivering software with hopefully fewer
bugs or errors we'll be able to add
features quicker so we'll be able to
deliver features to our customers now it
uses much more quickly so refactoring
starts off as a business decision that
ultimately will benefit our users as
well to my mind and at least for the
purposes of this talk I consider kind of
three separate types of refactoring
there's a kind of as you go refactoring
which everybody in this room every
developer in the world should be doing
this one all the time this is like when
you need to build a new feature so you
chilled a prototype you hack it together
and it works now of course you're not
going to leave it in that kind of
condition you would go back and add
comments you add documentation you dry
it out you perhaps start using variables
from the wider project to kind of make
this code or more lean we should be
doing this all the time but if we don't
manage to do this if we don't manage to
capture everything at this point we
might end up with refactoring our
technical debt technical debt I'm
finding really interesting at the moment
because I'm working with clients who
have got quite a lot of it
technical debt is kind of when you do
what you can right now when you do you
build a feature given a certain of
limited time on knowledge
information but you know that you need
to go back and tidy up later so you
built something with all the available
information but you need to go back in
future and tidy things up if we don't
capture things at this point we end up
getting on to the third type of
refactoring which is actually more like
a rewrite this is where you've ignored
your technical debt for long enough that
you can't refactor anymore it's too
messy to start refactoring it's going to
be cheaper to actually just tear it all
down and start again
anyone ended up in this situation before
okay a few of us yeah it happens many on
big projects and the rewrite takes two
years and it's still not as good as when
you started and it all goes wrong and
it's a very expensive error-prone ever
of pronet process unfortunately as you
get further into a project the type of
refactoring is likely to change right
the longer you spend on a project the
type of refactoring you need to do is
probably going to change and
unfortunately it gets progressively more
expensive more costly it becomes a much
bigger operation this talk is mainly
going to discuss technical debt and the
rewrites and overhauls it's all going
it's also going to discuss that kind of
bit in the middle how can we capture a
technical debt before it becomes a
rewrite or how do we rewrite something
before it becomes a complete overhaul so
we'll look at that kind of thin seam in
the middle a quick aside on technical
Batman have you all heard of the phrase
technical debt you heard of technical
debt oh cool half of us maybe for
anybody who hasn't heard the phrase
technical debt the URL on this slide is
definitely worth checking out I will
share the slides at the end of the talk
but a technical debt is when you decide
to do something right now to kind of
take a shortcut so you do something
right now to take a shortcut but you
have to understand that that's like
taking a loan that shortcut isn't free
that shortcut will cost you something in
the future except it won't just cost you
the shortcut it will incur some interest
probably the quickest most succinctly of
technical debt is when you're working on
a product and there's a problem and
using important we'll fix that problem
now typing important takes about four
seconds right so four four second
you can fix a problem that's really
cheap but that's alone right that is
technical debt because fixing the
important in six months time isn't going
to take four seconds it's gonna take you
four days so four seconds now is
technical debt you're getting a loan
you're fixing the problem immediately
but the repayment of four days in six
months time is what technical debt is
it's going to happen though technical
that happens on nearly every project you
work on you will need to get a release
out of the door you'll have a bug that
is on the live site you'll have to do
something right now to get a quick win
so technical debt is guaranteed to
happen on any project of sufficient size
the thing is we need to make sure we
keep up our repayment so if you ignore
the debt you end up going bankrupt your
interest increases you end up going
bankrupt so what you need to do is
schedule in constant bug fixing every
sprint you have you need to guarantee
that you can get some time to fix bugs
tidy up the codebase and sort of fix up
your technical debt but that means
bigger problems that brings problems you
know what do we refactor when do we do
it how long can we wait before we
refactor something now the easy answer
here is that we should always be
refactoring something but in more detail
we should refactor things if the
projected cost of maintenance or the
projected cost of maintaining a feature
is higher than refactoring it
the problem is tech debt and refactoring
is that you have to be very good at your
estimates and developers hate giving
estimates you have to project the cost
of maintaining a feature and if you
think it's going to cost you 20 weeks
over the next four years to maintain
something but maybe 15 weeks to rewrite
it those are the kind of numbers you
have to work out and take back to the
business you should only refactor things
if the current version is actually
slowing you down if the current codebase
isn't actually causing any problems even
if it might be ugly like their update if
if it's not actually slowing you down or
causing you problems you probably
shouldn't refactor it you try and leave
alone a little bit longer and from the
flip side you should refactor something
if the new version gives you actual
actual
tangible benefits if the new version is
going to be measurably better than the
old version
perhaps you should refactor a minor kind
of change in naming convention might not
change the way you work upgrading to a
new version of a framework might have
huge impact so you need to make sure
you've got measurable benefit looking at
an example of kind of proving the
business case or going to the business
let's imagine we've got a project right
now and a client rings up and they want
to add a theme they want to add a theme
to this website and the site was never
built to have theming involved at all on
the left hand side we've got the
existing code base and the cost of
hacking a theme into the existing code
base might be two days then in a month's
time another client rings up and says oh
we saw that they had a theme and we want
that and you've said to your product
owner well it'll take two days again
we'll hack a theme in and just make it
work out across two days and three
months time maybe hacking it in costs
two and a half days because we created
enough mess that it's actually taking
progressively longer by the time we've
added these sort of themes these four
themes they overall cost within nine
days the way of making a business case
for refactoring or kind of deciding when
to refactor is if you can make the
projections that you can make it cheaper
in the long run if we were to add the
theme and refactor the CSS to have
theming involved as a first-class
citizen it might cost us seven days
which to the business looks more
expensive they've got an option you can
spend seven days on it or two days on it
the business wants to pick the two day
version but what we can see is if we
actually build theming in as a
first-class citizen it might cost us a
quarter of a day every single time it
might become really really quick to add
that feature so in the long run
refactoring now actually works out
cheaper but you don't get that return on
investment until the features being
asked for a number of times so if you
think there's something might be asked
for just once perhaps don't refactor if
you think something might get Rieff
asked for several times refactor and
invest the opposite of debt is
investment so you can have technical
investment where you actually invest
more time than you need right now in
order to make things very very quick in
the future
okay when shouldn't we refactor this is
an interesting one I have clients who
ask me a lot about you know we need to
refactor this or we want to rewrite this
part of the project and a lot of the
time I end up telling them not to bother
if a part of the project isn't actually
slowing you down perhaps it didn't need
refactoring if it's just ugly or nasty
code or not nice to look at I have to
leave it alone
only refactor if it's actually causing
you problems if it can be ignored or
avoided this sounds like terrible advice
now I'm saying out loud but if you can
ignore it or avoid it do so leave it as
long as it works just leave it alone for
as long as you can if you have to work
with it every single day and it's really
hard to work with that is causing you a
problem you need to refactor it I've got
a couple of examples of when not to reef
like some specific examples if something
is gonna be captured by a rewrite later
on so I've had clients who've said you
know we're gonna rebuild the entire
platform next year but we want to
refactor it now what well why do it
twice just leave it a bit shitty for a
year and like you know just rebuild it
next year so unless you actually need to
immediately leave it alone refactoring
is largely a business kind of case right
and it's cheaper to leave it alone so
one example um a client asked me we want
to rewrite all of our CSS onto the BEM
naming convention now I love them I
really really love them but I don't
think taking two weeks out of product
work to refactor your CSS onto the BEM
naming convention is going to pay itself
back very quickly rewrite in your entire
CSS architecture is a very costly
refactor it kind of it could potentially
introduce a lot of bugs I don't think
that just rewriting your CSS on to a
certain naming convention is gonna be
worth perhaps two weeks of your time if
you disagree or if you can prove that
you know having a better naming
convention will speed you up by more
than two weeks over the life of the
project and perhaps is the correct thing
to do but if the numbers don't agree
with you you need to hold off
refactoring another example I got a
client so me we think that code for this
nav is pretty ugly and I took a look at
the code and it was pretty ugly it was
awful
disgusting um so I said to the client
well do you actually need to refactor at
how many times do you actually open up
the nav like CSS JavaScript APIs you
know how often do you actually work with
it and they said well we don't if a user
adds a new page in the CMS it just
appears in the page and I said well so
you don't actually have to edit any of
this code like no we don't we don't
really edit it at all okay what problems
is it causing you right now is it not
working in certain browsers is it
inaccessible and like what's accessible
it works but why spend time and money
refactoring it leave it alone until you
need to redesign the nav completely if
you could ignore parts of the codebase
to save the time save the money and
don't refactor them okay right I want to
talk to you about a concept that I came
up with earlier this year this concept
is called the refactoring tunnel a
refactoring tunnel represents like the
tunnel itself represents the workload of
refactoring something if you pick a
thing a part of your project project to
refactor you should see that piece of
work as being a tunnel and on day one
when you start refactoring you step into
the tunnel you can't see the end of a
tunnel you don't know where the light is
at the end you can see the light where
you just came in and day two day three
you progress further into the tunnel now
the problem is we can pick tunnels that
are way too long we could pick a tunnel
on day four we can't see the light at
the end of the tunnel but we can't see
the light at the entrance either hasn't
he only had that before when you've
started refactoring something like I
don't know where I am anymore
I don't know how much more work there is
to do this I call these refactoring
tunnels a long refactoring tunnel is
basically a refactoring project that is
too big it had too much surface area it
touched too much of the project and it
leaves you really confused
you stepped into the tunnel with good
intentions but you got lost and after
three four five days maybe even a couple
of weeks you're so lost that you end up
doing something like this and just
saying just forget it just undo
everything the navs broken the foot has
disappeared on three pages people got
login anymore everything's
Giroud broken and you just throw it all
in the bin how expensive is that you may
have just lost five days of time and
money by picking off a part of your
refactoring or part of your project was
too big
always avoid long refactoring tunnels a
long refactoring tunnel is basically any
bit of work with a large surface area
and what I mean by a large surface area
is does it touch a lot of the project
so perhaps refactoring your nav has a
tiny surface area affects the nav but
upgrading from bootstrap 3 to bootstrap
4 have an enormous surface area that
touches your entire project so try and
avoid refactoring anything that has a
surface area that big avoid long
refactoring tunnels long refactoring
tunnels as well as just being a bit
scary and a bit confusing and a bit
difficult to work with have some very
specific problems if you try refactor
all of your site from bootstrap 3 to
bootstrap 4 there's gonna be a lot of
stuff to merge back into master that
huge deltas of things you need to merge
back into your master or trunk branch
the chance of naming conflicts is
enormous the front of sorry not naming
conflicts but just getting merge
conflicts when you do a huge refactoring
job getting it back into trunk is really
really difficult and there's also the
problem that if you're taking down a lot
of the sites there's a chance that
you're gonna break some of the things by
accident introduce new bugs if anyone's
ever taken a bike or a car apart and you
put it back together and you've got a
suspicious pile of screws like they
should be in that car somewhere right
that's exactly what happens when you try
and take down your entire site and
rebuild it instead we should pick off
things with a limited and clear scope
find something that you know will be a
short refactoring tunnel for example
just pick the now for right today I'm
gonna refactor the nav get that work
done make sure it's correct get it
merged back in and then you've got two
choices you can get back onto product
work and start building features again
or you could pick another refactoring
turn off you could today well now I'll
just do the buttons and rinse and repeat
and keep doing this and before you know
it the site has kind of refactored
itself
you didn't refactor your entire project
onto a naming convention you reflected
the buttons onto a naming convention
then the nav onto a naming convention
the carousel and it kind of reef actors
itself by virtue of doing these small
bits constantly these small bits we need
to make sure we refactor these in
isolation I've seen a lot of people
struggle with refactoring projects
because they try to rebuild the same
feature back into the same project you
need to get a completely fresh start
pick the feature you're going to
refactor open jsfiddle or copán and
rebuild it there if you try and refactor
a feature back into the same codebase
you're going to taking advantage of
legacy CSS right you'll be using the
Cascade from CSS that might get
reflected in future you need to start
with a completely blank slate and build
it as perfect as you can don't try and
recycle already out-of-date environments
then once you've refactored that in
jsfiddle or code and copy and paste it
back into your project and fix any
problems at that point there let's say
the Guardian want to refactor something
and they pick the header in a refactor
the header today and then they finish it
they go to jsfiddle they get it
completed as you can imagine as soon as
you try and pull this header back into
the project things are gonna go wrong
there's gonna be some things will go
wrong they'll be a leaky selector that
breaks the link in the cut other colors
of the links right or they'll be a high
specificity selector that does something
weird with the display we will get some
breakages there's really nifty quite new
technique or tip I guess for dealing
with this and that's all initial who's
heard of all initial like three people
let's get a beer later where the cool
kids write all initial oh this is
amazing and all initial it effectively
stops inheritance all initial sets every
single CSS property back to its initial
value this means that things don't leak
into the Dom right you Styles don't leak
into any other part of the project if it
has all initials somewhere in there this
is a very progressive way of defending
against legacy now the reason I
mentioned progressive is because we will
need to discuss browser support in two
slides time there is a very nice way of
preventing I'm sorry protecting
your newly refracted work against the
effect of legacy hopefully we can see
this not hmm yeah not really um here
we've got a paragraph that's red and
bold it's red and bold because the HTML
and the div elements have got red and
bold applied to them the paragraph
itself has no styles directly applied
but because of inheritance it turns red
and it goes bold as soon as we put all
initials on that paragraph it goes back
to being black and font-weight:normal so
we can stop things leaking into parts of
the dom by using all initial there are
some weird caveats with all initial so
let us say we are refactoring our nav
and we want to make sure that nothing
from the outside project gets in if we
were to write our CSS like this the font
size and the font family rules here
wouldn't actually cascade down into the
link because the link also has all
initial on it it will stop inheriting
from its own parent the simple way
around this we just have to write those
style rules those declarations on the
leaf node we have to move them down to
here because they will not inherit from
an ancestor ya browser support it's
actually not terrible but it is still a
kind of a progressive way of dealing
with legacy all all that all initial
will do is buy you a bit more time it
will stop legacy styles appearing for
all chrome users or Firefox users and it
will stop the leakages for that for
those people if you're still go back and
fix anything that is broken so all
initial just buys you a little bit more
time but I do a little bit more time to
fix these leaky Styles so it's quite a
progressive way of defending against
legacy now the next tip I want to share
with you I actually implemented with a
specific client earlier this year the
defense CSS is like an internal open
source project for any company or any
team that is transitioning from old code
to new code
it basically answers the question what
happens when you need to run reflected
code and legacy code side by side and
that question was asked of me by a
company called Skype I actually used to
work for sky about three years ago
thought
and they got back in touch with me at
the end of last year because they wanted
to modernize their UI toolkit they had
an existing toolkit but the design
language had it dated they wanted to
change the architecture a little bit so
I kind of went back in to help them we
developed a new toolkit but sky is
pretty enormous sky has about 30,000
people working for them they're a big
broadcast company in the UK so they deal
with television ISP you know your
internet service so this is a very very
big project so what we have to do is
pick a candidates that kind of prove the
business value of this this bit of work
so we picked the homepage itself run
roll it out everywhere we started off by
implementing the new toolkit on the home
page then after that what the teams
could start rolling out on their
products and they could start adopting
the new look and feel I had the problem
is we had to run old and new in tandem
certain sites were using an old toolkit
and a new tool a new toolkit at the same
time and as you can imagine trying to
put two different CSS frameworks
together in the same project leads to a
bit of a mess things just weren't
sitting right things just weren't really
working well at all we've got these two
projects that were kind of in conflict
and they just would not meld together we
couldn't get them to work nicely so what
I end up doing is introduce this kind of
internal open source project just called
defense dot CSS and defense dot CSS was
a polyfill that would tidy up all the
mess between old and new and allowed
them to sort of sit together a bit more
nicely defense dr. CSS was an entirely
new project it's a new dependency
so the reason we run it like an open
source project is because other teams
needed to consume it and contribute to
it if another team wanted to run the new
toolkit as well they would need to
install defensive CSS to fix the kind of
problems between old and new the reason
we wanted it in a third project or a
separate file or so that when we
transition completely to the new toolkit
we can just hit delete right we don't
want to leave any legacy stuff behind
which want to remove the dependency
advanced CSS and have all greenfield CSS
and the stuff inside this file is
horrible it's just horrible horrible
stuff it's just typing until things look
right
it's full of hacked it's full of really
nasty stuff it will be important in that
this is the worst CSS you will ever
write but that's completely fine it's
temporary
it is designed to be deleted I I want to
show you what's in this file but um I
can't
I had to pixelate is that bad it's that
offensive it probably violates the Code
of Conduct it's really that bad but I
hopefully you can see it is quite
pixelated all these red bits they're
important yeah defense CSS if you need
to transition from old to new kind of in
a very layered manner or if you're going
to be running old and new at the same
time consider moving all the fixers to a
third project that can be rolled out to
other teams it can be versioned it can
be it could track your kind of your
version of your old toolkit your version
of your new toolkit and you can run it
like a proper sort of dependency managed
project oh the next tip I want to talk
to you about is RF classes RF classes
this is a really simple tip basically RF
classes any refactored class just put an
RF - in front of it this is just so that
the net developers can see that alright
RF nav has been reflected I don't need
to touch this is new code but would also
do some pretty clever stuff with this
like we could write a selector like this
I mean say if a class has RF - in it
just put a green box around it that
means it or me you look at our dev site
we might see this we can see that the
nav and the content blocks have been
reflected right this is this is work
that we've done this is work that has
been completed this is new greenfield
CSS on the flip side we could say find
me a class but is a class that doesn't
contain RF - put a red box around that
and you can just hide these behind a
config switch in your sass somewhere if
we turn this selector on we can see that
okay write anything with a red border
around it is not refactored here we can
see that the the temperature in London
all that information that little masked
head has been refactored we can see
that's clean
all the other red stuff is our to-do
list this represents the worker it's
still left to do that's just a really
simple tiny tip just put our F - in
front of refactored classes once you've
finished the refactoring project if you
can just kind of run a global find and
replace there's a strip RF - back off of
those classes and you've got a
Greenfield codebase the net tip this is
one of my party tricks
I actually don't come to one of my
parties have boring with this b-but
refactoring specificity right if you're
refactoring old CSS there is every
chance you're trying to remove IDs you
can I remove overly nested selectors
this often means that any new CSS you
introduced to the project might have
collisions with specificity old
selectors might be using IDs that might
accidentally override your new work so
dealing with specificity and legacy
project is not fun we could just start
throwing importance in there but we
really really don't want to start
putting importance into brand new
greenfield CSS we're instantly accruing
tech debt on a brand new project it's
what we can do is we can hack
specificity with minimal side effects
there's some kind of funky things we can
do to hack specificity around if we take
a real simple snippet of HTML a link
with a class of foo and an idea of bar
and throw this CSS at it we've got three
very different selectors here but we can
probably all work out that hash bar is
what's gonna win it's an ID it's
infinitely more specific than a class
who is infinitely more specific than an
element so even though we've got these
written in a certain sauce order they
will be applied in the opposite order to
what we kind of expect well not expect
but the last one is the least likely to
get applied so all of these selectors
are working against their sauce order
this is gonna be a definite definite
problem when we are refactoring at our
CSS so what we can do is be hacked our
specificity around without changing the
selector at all or rottweiler without
changing what we are binding on to
without changing the HTML we can rewrite
all of that CSS so that every
element has of every story every single
selector has the exact same specificity
if we were to write ID equals bar as an
attribute that's a class equivalent of
specificity we need to prefix that with
an element so we can have an element and
class equivalent specificity there the
second one the class just stays as it is
we put an element in front of that so
that's got an element and a class worth
of specificity and the final one staff
that offers an element it was just an
element we need to get that to have a
class as well what we can do is we can
just use the root pseudo element the
root pseudo selector which just
represents the HTML element in an HTML
document or the SVG element in an SVG
document and this also carries a class
worth of specificity so now all of a
sudden the last selector wins it can
beat the ID I just pull this out into a
more kind of digestible slide rewriting
IDs as attribute selectors who will
bring their specificity down to a class
we've actually chained the same class
with itself to increase its specificity
by doubling it if we had got food food
food
it would triple the specificity we can
do that for forever it'll just keep on
going and we can also use the root
element to introduce a class worth of
specificity without ever having to worry
about where the Dom node actually lives
it's really important to remember that
these are hacks these are disgusting
these are horrible ideally we would
refactor our CSS so that there wasn't a
problem at all realistically we might
have to use a few of these hacks I've
used the double class one quite a lot of
times we should never lean on things
like important we can use things before
things get that bad I'm not saying never
use important what I said in the first
talk and Twitter kind of set on fire
with that one but yeah we can avoid
using important for a lot longer by
learning how to hack specificity around
so if your legacy code is causing
problems perhaps you use one of these
techniques
the next thing I wanna talk about is
Shane CSS as an unheard of Shane CSS
yeah a few of you I wrote about this a
few years ago and I still really enjoy
it because I just like making people
write code in a file called shame the
idea of shame dot CSS is that you have a
totally new style sheet reserved just
for your hockey code code that you have
to write to get a release out on time
but code that makes you feel a bit bad
right because you just kind of
disappointed with yourself hang your
head in shame you could call it bugs CSS
or like hacked CSS died of shame dot CSS
is so that people see it and they're
kind of intrigued like what's in here
but it's just a dumping ground for all
the nasty bits of CSS that you're a
little bit ashamed of there are several
benefits to having all your hacks in a
separate file it's important to isolate
our hacks I'm not naive enough to think
that I don't write any hacky CSS ever
we're all good developers we all have to
write hacked at some point in our
careers we have to hack something around
because a deadline is looming this is
technical debt right I writing a hack to
fulfill a deadline is exactly what
technical debt is that's kind of a loan
that we take that we have to repay later
what we need to do is keep a balance of
our debt right we keep shamed up CSS as
a file to reminders of what we need to
refactor later so it makes it very easy
to find and fix things that are wrong an
example like chunk from i ashamed CSS
file every bit of CSS in shame doc CSS
should have the hack itself but should
have a comment explaining what the
problem is that you're fixing why you
had to fix it and what you would do to
fix it properly if you had enough time
and then you can optionally leave kind
of details that people can get in touch
with if they need to ask you about it
here you can see that I'm using the dot
BTN BTN trick to force the button class
just to have a higher specificity to
override dot promo right it's a nasty
hack but I had to do it so the benefits
of having this this file is this is a
self writing to-do list all of your
to-do zarnow exist
one foil he don't have to chase them
around the project when you have a
refactoring task or a sprint dedicated
to refactoring open this file and start
there it keeps your good code nice and
clean it keeps all the messy stuff away
from people who are working on
Greenfield code this is actually really
important has anybody heard of the
broken windows theory oh cool a few of
us right the broken windows theory kind
of loosely suggests that um it's like
her the example uses a New York kind of
state like council if there's an
abandoned or like vacant public building
and somebody smashes a window New York
Council sends someone around immediately
to fix that window even if that building
is going to be vacant for the next ten
years they will fix the broken window
immediately because as soon as there's
one broken window someone else will
throw a rock through another window
another one until the building falls
into disrepair it's kind of this this
social kind of theory about snowballing
effect the exact same thing happens in
in software projects someone will use
the first important and if they leave it
in at the next developer comes along and
sees an important and thinks wife they
did it I'm gonna do it
and before you know it you've gotten
messy spiraling codebase so what we need
to do is if we do need to add any
importance if we need to add any hockey
CSS took it away to one side so that for
90 percent of the time when you're
working on good clean code you're not
reminded of all the bad stuff that's
going on it just keeps you with a nice
view of your project this is an
interesting but you can see which parts
of the codebase are problematic
there's anybody being given a design to
build or being given a feature request
and you immediately think this is going
to be awful right this is going to be
really hard to build this is gonna be
really happy yeah all of us with CSS
developers of course that is basically
what our job is right we get given these
designs that are really nasty and
horrible and we just think I can't build
this nicely this is going to be happy
we're gonna have to use this and this
I'm gonna have to polyfill it with
JavaScript and you've got back to your
product owner or your project manager
and you say hey look I actually think we
shouldn't do this I think that this is
bad idea because it's gonna really
negatively affect the quality of our
code base and they probably say
something like well the clients happy to
pay for it and you're like fine if you
put all the hacks for that particular
feature inside your shamed CSS file when
that feature is finished you can go to
your product owner and say two weeks ago
this file had 17 lines of CSS in it now
I finished that feature it has 212 lines
of CSS in it
this feature directly contribute bhai
made their awkward numbers I have to do
some math now it's like 198 lines of CSS
that you've added to the project you can
actually start to prove with numbers
just how much technical debt particular
features add to your project it remains
the next time somebody asks for a weird
feature you can say look last time we
did this I told you it'd be a bad idea
this is what happened I'm keen to avoid
that happening again at the final good
thing about shame dot CSS is it's easy
to run get blame over a single file
I was really nasty when I say this I'm
not doing this in order to catch people
out I've actually got quite an
interesting story of how this really
helped me on a project about two years
ago I was kind of the lead consultant
and lead developer on phase one at a
fairly big elearning platform it's a
really exciting project it turns a fun
and I built kind of phase one and it's
my job to hand it over to another team
we had a full like proper handover
workshop where I talked him through the
architecture how everything worked and I
was like do you understand and they're
like yes we understand and I left and I
came back about two months later just to
check in and see how things were going
and I said oh cool I'm gonna take a look
through the codebase and see if there's
anything we need to discuss and all of a
sudden ashamed of CSS file it got it got
enormous and I ran get blame across it
and it's just one developer it was all
his work and at first I was like he said
he understood and he lied and at first I
was kind of angry but then I realized
that a way all of this CSS in here is
around the grid system that's the thing
I explained the least so what this
taught me or what this told me was that
I hadn't explained something very well
the guy was hacking around stuff that
already existed hadn't really made it
obvious so it was a quick case of I said
like dude can we grab a coffee for 58
for 15 minutes like I want to show you
some stuff about how the grid system
works and basically what this allowed me
to do was learn who struggles with which
parts of the project as a lead developer
or as a senior developer that's really
useful information to have if you can
see that this person is struggling with
the nav or the carousel or something it
means you can start sharing knowledge
with the right people about the right
things that's it for the kind of the
tips I just wanna close on quite um
there's an interesting thing that
happened to me again about two years ago
I had a very very interesting point of
view given to me by a developer that I
was talking to and it's about second
chances this is kind of weird I never
really do this kind of philosophical
ending to a talk but I think it's quite
poignant it was basically that second
chances I was running a workshop in
London and I always asked the attendees
like well where do you work what do you
work on what kind of stuff do you do and
and one guy said that I'm brand new to
web development I'm like I've been a
developer for like two months and I said
oh cool how are you finding it are you
enjoying it and he said oh it's amazing
I used to be a civil engineer so he used
to build bridges and roads and that kind
of stuff and I said so how are you
finding the transition to web
development and he said oh it's
incredible because web developers have a
chance to refactor things I am a civil
engineer I can't refactor a bridge
it's either perfect first time or 200
people died and I was like yeah you're
right that's incredible
like yeah I never even thought about
that you can't refactor a bridge it's
like oh like what that's me going
to prison yeah as a civil engineer I
don't get the chance to or as civil
engineers we don't get a chance to
refactor our architecture and I was like
oh my god like I've always looked at
refactoring as a horrible job I've
looked at refactoring as a chore
something that I had to do something I
resented
what refactoring actually there's a
second chance that most industries don't
get it's a chance for us to learn about
our product as we build it it's a chance
to respond to changes in requirements or
changes in use it's a chance for us to
learn from previous mistakes or learn
from new knowledge to make even better
stuff surgeons can't refactor a heart
surgery right you die civil engineers
can't read factor a bridge pilots can't
refactor a failed flight web developers
we can be like yeah well this
architecture is not good enough let me
spend a week fixing it so rather than
seeing refactoring is a nasty job
perhaps we should see it as a kind of a
second chance that is actually kind of
cool I've actually gone 10 minutes over
my time I think so I need to start
wrapping up um okay let's leave on this
then remember um prevention is cheaper
than the cure if we can start
refactoring things as we spot them as we
are working we're going to keep things
cheaper in the long run we don't have to
tear things down and start again
technical debt is fine right a lot of
people avoid technical debt completely
that's quite naive technical that is
going to happen it's bound to happen
which need to be very very careful very
diligent in keeping up repayment so that
we don't go bankrupt and have to rebuild
the entire site I'm only refactor things
once we can see tangible benefits try
and avoid refactoring something just out
of a sense of pride only refactor
something if is actually slowing you
down if it's causing problems if it's
costing the business money avoid long
refactoring tunnels do not pick
refactoring tasks that have a large
surface area pick off tiny granular jobs
complete them as quickly as you can and
move on to the next one and any hacks or
refactored code any code that are even
remotely interesting to other developers
highlight it Aref
in front of your refactored code hacky
code inside shame dot CSS the very last
thing I want to say to you or leave you
with is this quote by Sir Robert
baden-powell Robert baden-powell is the
founder of the Boy Scouts a movement
or was he's dead now and he said he
famously said to his Boy Scouts always
leave the camera
cleaner than when you found it I'd like
to think that as developers we have the
same responsibility to leave the
codebase cleaner than when we found it
thank you very much for your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>