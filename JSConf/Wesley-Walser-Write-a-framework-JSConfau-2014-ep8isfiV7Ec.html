<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Wesley Walser: Write a framework | JSConf.au 2014 | Coder Coacher - Coaching Coders</title><meta content="Wesley Walser: Write a framework | JSConf.au 2014 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Wesley Walser: Write a framework | JSConf.au 2014</b></h2><h5 class="post__date">2015-02-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ep8isfiV7Ec" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">about the fact or the idea at least to
start a conversation about you writing a
framework I'm Wes I write JavaScript
atlassian there's a twitter handle but
not really much happens there the i
guess the premise is that whether you
write something that's micro or
monolithic something that's supposed to
handle something very small or handle
things that are really big i think that
you can make some lives easier so first
i think it's useful to define framework
for the sake of the talk wikipedia for a
long time helpfully define framework the
word framework in the programming
context as a buzzword so that didn't
help but actually over the last about a
year and a half there's been a really
sort of healthy debate around what
pieces of things make up a framework or
what differentiates a framework from
libraries or api's I'm not going to use
that frame that that definition strictly
but what I do want to talk about is
sorry just to say the idea of taking
moving from a place where as app
application developers we think about
our apps as our app and the whole code
is our appt to thinking about how we can
up level things to be sort of a level up
out from our app and be sort of upstream
from us and our app doesn't change that
code our app maybe hand stuff to that
code and it handles maybe control flow
or something for us or it it helps us
out in some way but it's above the app
so the app doesn't sort of modify its
internals so basically going from one
big app to having something upstream
from us I'm going to talk about how we
can begin thinking about doing that and
I know they're certainly people here
already doing that but I want to talk
about and encourage you to if you're not
already to start doing that and what
sort of things I think about when I'm
going through that process and how I
think it helps helps you up level as a
developer
and so yeah it's there's nothing I guess
about my definition that differentiates
you from from an API or from libraries
except that whatever that layer is it's
something that may encapsulate multiple
things and then expose a single API to
itself again the Wikipedia article
insinuates that there must be some
inversion of control right where the
framework handles lifecycle I don't
think that's necessary right out of the
gate as you begin pulling components out
of your app and putting them up stream
what I think is important is that
whenever you take those components
libraries or interfaces you put them all
inside of a container and then interface
only with that container so that's the
definition I'm going with for now so
yeah why what should you why should you
framework what should you framework how
should you go about it how do you think
when you're writing framework code and
then I'll do a little I think advocacy
around the Java JavaScript community
specifically because I think we're
positioned in an interesting place right
now so work for atlassian atlassian
rights I think about eight different
applications all but two of them are
just big java applications and whenever
you read Java code and one of the sort
of interesting transitions that I had
when I came to the company I was in a
place with a lamp stack before that I
was very comfortable if I met a bug that
could potentially be in the framework
level with just walking the stack trace
up to that point and you know modifying
it if I needed to or understanding that
abstraction better whereas JavaScript
avada developers tend to really trust
their abstractions and I think that
that's in some part due to the maturity
of that of that group but it's also
something that I think the JavaScript
community is getting to a place where it
could be it that comfortable as well so
and in in a recent project I've been
writing what is essentially a single
page app and if you go
to the server the only thing that's
really there is a REST API for
persistence you know we're using we're
using the server to persist data the
client is doing most of the heavy
lifting for business logic and whenever
you look at the rest endpoints for this
application if you go to look at one
specifically you'll get to a place where
another sex sorry okay there we go
you'll get to a place where the um where
the rest in point is implemented and in
the comment above that method it's just
going to be a method and in the comment
above it there will be a part of the
comment that tells you it's an
annotation and it will tell you exactly
the route that is required for an HTTP
request to invoke that method and then
the parameters to that method are going
to be the get or post parameters that
are sent as a part of that call and then
the return value is just an a Java
object there's nothing special about it
and all the serialization d civilization
all the parts of an HTTP request headers
cookies sessions all that's just handled
for you and it's hidden from you and you
just trust it and it works and so you
see things like this and you think man
frameworks are really useful so you go
back to your JavaScript friends and
you're like frameworks we're gonna write
a framework and they kind of look at you
like framework and I think that
JavaScript developers so far have been
really skeptical of frameworks it's no
accident that backbone is so popular
it's it's popular because it's simple
it's also no accident that just huge
parts of huge numbers of Java JavaScript
developers have this death grip on
jQuery as the thing that they're going
to use in their framework it's because
you can go and read a hundred percent of
that code you can go and understand all
of it really really easily and it's
because they don't trust their
abstractions so why do I think we should
move beyond that and begin building
either bigger pieces of things and trust
that code to handle a lot of the major
repetition pieces for us I'm going to go
with sort of a soft argument and then a
hard argument
so and hackers and painters Paul Graham
encourages this encourages us to think
of our trade as a craft and to consider
our code art and to take on that art and
to consider ourselves artists to take on
the hard decisions in the the trade-offs
and treat them as things that have
subtlety to them another artist Kurt
Vonnegut was written to by a primary
school classroom and they were asking
essentially had a how to be awesome like
he is I don't know what they asked but
they asked something and he writes back
to them which is pretty cool and his
advice is essentially to just practice
any art whatever your art is to practice
it no matter how well or badly you're
going to go at it to practice it and his
main advocacy is to do it for the sake
of the experience of becoming not to not
to put it on github for the world to
consume but just to experience becoming
just a little better at that thing he
goes so far as to advocate that you tear
it up right after you're done with it
like I said I think for a lot of us that
looks like putting it up on github you
know there's the bin or the whole world
can view it whatever so that's that's
the soft side right that's the I think
you should do this in order to practice
there's also like much more pragmatic
matters which is I think it makes you a
better developer so application
developers in my experience and as an
app developer mice like it someone who
writes is concerned with applications on
a regular basis myself I'm very
interested in how to make my box
transparent and how to fit that cat into
the box and how to get that to the
market and how the market is going to
respond to that cat in that box and as a
framework developer I think you have to
think about how you're going to build a
system that is going to make transparent
or opaque boxes depending on what the
people using it need and how it's going
to fit any sized object so it teaches us
how to be intentional about the edges
that we expose to the rest of the world
applications tend to
be built with concerns separated but
then as you go about writing them you
end up using the things so each of these
objects expose a number of AP is and
they basically serve one concern but all
the other pieces need to interoperate
with those concerns and so you end up
with an undirected ace of the graph of
objects and I think that in writing
frameworks in learning how to think
about writing a framework you sort of
uplevel into thinking about how you can
better encapsulate those concerns so in
an app integration can be tight because
there's only one instance of this thing
in the world and when a feature needs to
be implemented and this is where some of
those extra lines come from whenever a
new feature needs to be implemented you
just add one more connection right you
just add one more line in order to eke
out that one new thing you want it to do
and you stretch the limits of your
originally intended boundaries and I
think that in learning to move things
upstream from ourselves we'll learn how
to go about taking those separated
objects and packaging them up and then
from that package of objects exposing
one coherent API I think that it teaches
us also how to go into this process with
eyes open about how what we expose will
affect those that consume the framework
so I guess this is I don't I didn't put
a lot of thought into what each of these
things says but I suppose if you were
building if you were a company that was
concerned with sending email well and
you always wanted your email to generate
statistics so that your customers could
come look at when it was sent and when
it was opened and all that you would
have something that looks something like
this and if you built a framework out of
this and expose those things to the
world and then someone wanted to send an
email without tracking it you know maybe
that would be a problem I don't know
because you've expressed that opinion
write the opinion being that messages
when they're sent get statistics
attached to them but that's that's the
eyes open part that's where you go in
knowing
if i make you know i can either make
generating statistics really easy for
everyone who uses my framework or i can
add make them do a little more work and
then anyone who uses this framework can
send it with or without statistics so
those are the sorts of trade-offs that I
think make this into an art so what what
to framework so I'm standing on stage in
front of a room full of JavaScript
developers and JavaScript frameworks
there are a few of those they've been
around for a while and I'm not
advocating that you build a new
framework to build web applications I
think that's been done in a pretty good
article defending not invented here
syndrome Joel sapolsky says that you
should reinvent things even if they've
been invented you should reinvent them
if it's something that differentiates
your application from the rest of the
applications in the world if that's your
defining factor if it's what makes you
in the market you should probably
reinvent it because chances are you're
very concerned with doing it better than
anyone else so if you're at an org that
because of the industry you're in needs
to send faxes you know maybe you write a
framework that makes all the apps that
send faxes do it in the same way right
if you're sending email similarly maybe
you really want how you send email to be
done better and again since I'm not
using the inversion of control
definition of framework I don't want you
to be too concerned with when you up
level things when you push them upstream
about whether or not they need to handle
the whole lifecycle of your app and I
think that that actually comes out in
reality a lot of really great frameworks
have come out of individual products
where the creator of that product began
to slowly pull library after library out
of their product and into something
upstream and that eventually that that
thing that they were building upstream
from their app became a framework and
began to take on control of the sort of
operational control of how the app runs
and became sort of sovereign
full-fledged frameworks so don't be i
guess don't be allowed don't be
learned about letting things build
organically and pulling more more stuff
into your upstream so how'd it go about
building a framework I'll talk this
isn't I'm not about to go on a tutorial
for how to build frameworks but I will
go through some practical steps that I
find myself thinking about when sort of
trying to pull things upstream from my
application so I guess consider which
pieces of code our framework in which
are downstream from your from that
framework oh sorry I'm going to start
with reading code so I'm going to talk
about reading other frameworks and how I
think that's a good practice to learn
how to think in sort of framework level
terms then it's deciding what to pull up
stream and what to push downstream so
what to push on to implementers and what
to pull into a framework and then I'll
talk about how that decision has to be
gone into with with intention and
knowing that you're making trade-offs
and knowing that you're making decisions
about the complexity that either you'll
take on or your consumers will take on
so you should read a lot of code that's
probably just generic advice across all
programmers if you want to become better
you read lots and lots and lots of other
people's code I would assume that though
that I get paid to output new features
and new programs in to fix bugs actually
spend a larger portion of time reading
other people's code than I do out
putting my own and in reading framework
code you're going to wet out every now
and then it's going to be a little
confusing here and there because
framework developers do crazy stuff in
order to sort of automatically connect
things that are just named similarly
right like they're going to concatenate
that function name with this other
function name and then use them as an
array look up in this hash that contains
methods and call invoke that
the function that is the concatenation
of those two things that a user passed
in in order to connect you know the
route to the controller and but I guess
the point being that wedding out when
you are reading framework code is rarely
the result of bad code it's often an
opportunity to learn something it's
often doing something pretty cool
reading the dependency injection stuff
in angular can kind of do your head in
but it's pretty sweet when you realize
what all the pieces are doing if it's
actually bad code just remember
everyone's every bad idea was someone's
good idea and it was more likely a
compromise this is just generically
truer across all all programming right
when you're reading someone else's
garbage code it's because they had to
make trade-offs right they needed to get
it out the door on time where they
needed to to shim that thing into a
system that already existed if you're
going to read code if you're going to
read framework level code for the first
time backbone is just an amazing place
to start I wasn't trashing it earlier
when I said that it's popular because
it's simple it's great because it's
simple it's simple it's also a great
place to start if you're just starting
out in reading framework code if if
you're comfortable with the language and
you're comfortable reading sort of if
you've read frameworks and other
languages you can have a really good
reading of backbone in a single sitting
like an honest I really understand
everything that's going on and why these
pieces exist in about probably three
hours if you're new the language you're
slightly uncomfortable with it or you've
never read frameworks before it's really
easy to set up to split up into
conceptual pieces and read each one a
night for four or five nights make sure
you're reading the annotated source the
authors were super intentional about how
they come at their code and how they go
about documenting it so that you can
understand each chunk so that's reading
next we'll talk about how you or how I
think what sort of types of things I
think about when I think about pushing
things upstream from my app so this is
the this is a well-understood model if
you're writing node
replace the word client with server if
you're writing browser-based code you
always sort of understand that you
interoperate with AP is that our
upstream from you so you your
application sits below sort of the
client and the the goal being to take
things that are repetitive or that are
causing pain or that make things painful
for new developers on your team and put
it in between your the client and the
application so that if you're writing a
sort of a sovereign framework then you
sort of constancy start to consider that
your application is interfacing with
this framework and then that hides stuff
from the client right like the
application almost never talks to
directly to the client for stuff anymore
it talks to the framework if you're just
building if you go back to the examples
with sending email right like maybe your
app no longer ever talks to the message
queue it never talks to the statistic
subsystem it always just talks to the
framework that handles that stuff for
you the goal is just to find pieces that
need to be up leveled so look for code
that's being repeated at every every
turn things that are repeated multiple
times and are consistently hard pieces
that caused problems for new developers
if you know if the new guy if every time
there's a new guy for the first month
they write bugs and X X could probably
be moved upstream and made easier right
you could make doing something hard easy
for people if you're going after domain
specific problems think about the domain
specific solutions that your company
offers are that your application offers
over its competitors so if you're trying
to not reinvent things that have been
invented elsewhere you know what are the
things that set your appt apart one
really convenient place I've found to
start thinking about what things need to
be moved upstream from the application
is well sort of two pieces it's in
testing so
for one for one thing you should always
consider your test downstream from your
app if your if your tests are sort of
just a part of your app you're probably
going about it slightly wrong and
especially if you find yourself
modifying application code for the sake
of testing so this is both a good way to
begin thinking about the boundaries
between components but it's also a good
way to find things that could be moved
upstream from the app so if there's
something that needs to be mocked in
every test it should probably be
upstream and then just the framework
tier needs to be mocked if there's
something that the setup function in
every test does then whatever that's
doing can probably be moved upstream
from your application and then that
framework can be tested and then all the
other applications within your
organization don't need to do that
duplication in their tests they just
need to use that framework so that's
reading code and that's how I out some
sort of pragmatic tips around how I
think about beginning to separate how to
move how to begin moving things upstream
from your application and now it's sort
of the art piece of it so when deciding
what opinions to express from a
framework you're basically deciding what
complexity to push downstream so every
time you separate a new component and
you say this thing is only concerned
with this one task you're essentially
pushing complexity into someone
downstream so the fewer opinions your
framework expresses the more complexity
you're pushing to the implementer so
this this is a system that has very few
opinions right each of these things is
isolated it has its own separate
concerned but everything else that needs
to have anything to do with that concern
takes on the complexity of connecting
all the different pieces whereas this is
something that's quite opinionated right
so yes internally these things are
connected to one another and they're
coupled they are coupled it's just a
fact they're pieces of your of your
framework are going to be coupled but
the interface that they push out to
consume
allows them to allows those consumers to
take on less complexity so just go in
with eyes open about that and there
there's a whole range of these in the
JavaScript world as things exist so
backbone philosophically doesn't take on
many opinions it's the goal was not to
make application development easy the
goal for them was to take to make a set
of components that every web app needs
so they were trying to find the minimum
viable set that are generically useful
all web apps need x y and z whereas on
the other end of that opinion spectrum
is something like ember where their goal
was to codify common idioms so this is
the one true way that we've decided that
framework has decided that you need to
go about doing things and then you only
focus on what differentiates you are at
from other apps so there they've been
quite opinionated about their framework
and that all essentially comes back to
you know if you're writing backbone code
and your controller needs to take on
multiple pieces from your model and then
push things out to views whereas ember
might automatically connect the route
Model View and controller during its
bootstrap phase so JavaScript
specifically I think we're an
interesting position as a community
historically it's people have been
interested in languages that are either
server only or client only so for a long
time we weren't doing a whole lot of
heavy lifting in decline at all and you
had a couple of different languages but
it was Java Ruby Python PHP and I assume
Java was the first one to do it fairly
well where you would implement a Model
View controller on the server and then
use the client is essentially
done paint and that's how the web's the
web worked for just a very long time so
the the server is where all the business
logic is performed data is sent to the
client and it's used to paint that that
data and then it also has some concerns
around user input right the user clicked
on position to 39 x 48 and that's a
button so we're going to send this the
information about the the form that
we're going to send a post thats related
to that form back to the server and then
the server recalculates what it needs to
draw in response to that and sends it
back for another paint then we started
doing sort of single page apps or doing
a lot of heavy lifting on the the client
and we realized we could do a lot of our
JavaScript had become good enough or
maybe it was good enough all along I'm
not sure but we had it had become good
enough that we can begin doing our
business logic in the in the client and
we began to use the server as
essentially a dump data store so it's
it's there for persistence you know the
user has done some things our model has
changed let's sync it you know it's
essentially a sink call the business
logic is a base is essentially contained
inside the the client and this is not
entirely true if you were doing more
complex stuff on top of that data sync
right like if your server was doing some
hard number crunching you could have
things in the server but by and large
for simple crud apps that were doing
heavy lifting in the client the data was
just or the server was just there for
data access and persistence and now now
we're building things in node and well
this is splat side NBC but really it's
it's splat side splat right does it need
to be MVC I don't think we're all
convinced or at least I hope no one's
convinced one because NBC is sort of a
bad term and otherwise because I don't
think we found I don't think we've
arrived I don't think we're there yet so
I think that the JavaScript community is
uniquely positioned itself because we're
comfortable writing code both on the
server and on the client
we have an opportunity to build complete
into in solutions to a problem that's
consistently hard and we have the
opportunity to make that easy and it's
essentially if I make writing code that
can run in either place I think that
meteor and Derby are the closest
approximations to this so far I don't
think that neither of those projects are
done by their creators standards so you
can go get involved in them or you can
begin writing frameworks that are
similar to them so we're still driving
towards solutions and I don't think
anyone thinks that we've arrived but go
take a look at one of those if you
haven't already they're essentially
doing you know major major pieces of the
lifting on both sides depending on what
you want to do there are also some
components that are doing things quite
well doing one thing quite well and have
the opportunity to evolve into the
canonical way of doing something so
reacts already been presented on here
but it's something that does views very
well and it's a new approach to drawing
the view with the virtual Dom I couldn't
find a logo for 4q but venable promises
are coming about as a new and interests
or not new but they're an interesting
way of going about doing a sink
programming and a node the node devs
have opinions about that but it's
certainly a new and it and an
interesting way of going about acing
programming moment is obviously it like
of the things that do that do times it's
probably the one doing it the best at
this point and if a framework comes
along that needs to draw to the dom
maybe it'll take on react is the
canonical way if at some point the
community decides that that's a great
way to do it I'm pretty consistently
using venable promises in in all of my
code just because I'm fairly sure it's
better than callback passing to method
to methods but I guess what I want to
say about that is that if we move into a
space where we're solving into n
solutions will need
solutions to these individual problems
that are quite good and we may be
getting close to some of those so if you
if you decide to write a framework
that's going to be exposed to the rest
of the world go about doing the
individual things well go consume pieces
that already exist on the web and are
done well and that's it for me</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>