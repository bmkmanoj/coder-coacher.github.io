<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>[JSConfUS 2013] Peter van der Zee: Real Time Recompilation of Running JavaScript | Coder Coacher - Coaching Coders</title><meta content="[JSConfUS 2013] Peter van der Zee: Real Time Recompilation of Running JavaScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/JSConf/">JSConf</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>[JSConfUS 2013] Peter van der Zee: Real Time Recompilation of Running JavaScript</b></h2><h5 class="post__date">2013-08-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9HfWmdp9_I0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm Peter and I'm going to talk to
you about a recompiling JavaScript
without restarting it I'm a Dutch
JavaScript developer I you might have
heard me from JS 1k I organize that and
I build a variety of tools JavaScript
related tools I work for a company
called surf Lee they do remote desktop
in your browser but that's not what I'm
going to talk about today so first we
start with a demo and so we're going to
start with reloading oh dear Lord no so
we're going to start with Riaan abling
endings
it's really exciting I know it's like
and there we go I hope there we go all
right so on the right inside you see a
small animation basically right the
point is that it turns and it moves and
whenever I edit anything even like
adding a space it's going to restart
this code there's a loop down here
sorry's not intended i seems i forgot
that if i change it it will it will
reload the code and will restart from
scratch so now let's look at how that
will look if you recompile it apparently
took crashes Wow all right so it doesn't
cool um okay sure no problem
so let's open it comes all try bigger
and bigger and all right so it's going
to repeat repeating and whenever it's
going to start it's going to do foo I'm
sorry I had a visual thing and it's
apparently not working so whenever I
want to change it now it's not going to
print foo and if it would fool it would
print food and the program what if we
started as you can see in the console
it's a well printing out the new stuff I
can do pretty much anything even like
closures but that's let's just quit
twice something quickly such a pity oh
well okay so no fancy demo there let's
continue with the slide basically what
it is is it's compiling JavaScript on
the fly while maintaining access to
closures which is something that's not
that trivial to do obviously no restart
of the application is required so if
you're like building a game then you
wouldn't have to go through your Start
menus and whatever to see your change up
and running immediately it's the library
of this is a lazy evaluation so it's
compiling once and it's only going to
really compile when you change it and
it's a generic approach meaning that it
will work with pretty much any
JavaScript there are obviously some
limitations but i'll cover those later
so when I talk about compiling in
JavaScript what do I mean when you have
a function you're actually compiling
JavaScript because you're preparing code
to be ran so when you're creating a
function to be invoked later you're
actually compiling javascript so that's
what I mean when I say compiling in
JavaScript all right so I'm going to do
this live coding thing it's gonna be
awesome I'm sure just like the previous
demos so this
this one so we have a simple set
interval and it's printing hello JS calm
and add a forgotten five on the
millisecond and so that's what it does
now in the first step because i'm going
to recompile those functions is I'm
going to wrap those functions so i'm
going to create a new function called
well you know and it's going to return
that function and I just sliced out so
this is the same as I had before you
know what I should probably
so this is the original code that were I
press a button
I shouldn't be pressing buttons okay so
whatever um so this is the first step
and of course it still works still does
the same thing except I sliced out the
way that the function is being passed on
so the next step would be to actually
compile the function and how do we
compile function in JavaScript
dynamically evil evil is evil so let's
just use the semantically more
appropriate way to do it through
function so we're going to do like that
and that should return the same function
that we had before so let's try it out
still working all right okay so let's
abstract is a bit I putting it in a
global variable so that we can access it
later so this is still the same things
before just a bit of abstraction and
still works all right so let's make this
into a function ID parameter a subpoena
passed on 0 because it's still the first
function in disarray still works now are
we able to recompile at this point
because basically all we'd have to do is
change this right because this is being
evaluated and executed so let's just see
if that works
since we have a global we can accept
access it Oh capital it doesn't work off
why does it doesn't why is it not
working this function get function is
only being invoked once it's not being
repetitively being invoked so when I
change this this isn't being picked up
so I need to do is I need to return a
function that does a recompilation so
now we can see that is recompiling but
not executing so in order to fix that we
can recompile we compile and we
immediately invoke all right that's what
these these are going to do so now we
can see it as compiling and printing
alright so now is it going to work if i
try to recompile yes so this is
recompilation as its most basic
primitive form you're changing a runtime
you know without actually restoring the
code not at sea we need to properly in
focus because if we're going to do
arguments then this is not going to work
in fact what are other things that might
go wrong here I mean if you're looking
at recompilation in this approach what
kind of code if we're looking for
generic support what kind of code might
not work anybody all right good thing I
put a few up so function arguments are
not going to work because they're simply
being ignored right now closures aren't
going to work because you don't have
access to it and that's probably like
the prime thing in this whole approach
function declarations don't return a
value so if you would wrap those or
replace those then that would be pretty
much dead code named function
expressions are a special case because
the name of the names function
expression is it's handled in a slightly
different way and of course there's
performance because if you're going to
repetitively
to evil code it's going to hurt your
performance so let's try to fix those
cases first four arguments so arguments
is quite simple we're going to change
this structure into a set of objects I
shouldn't be typing objects
alright so it's going to be arks and
then function accepts multiple
parameters and only the last one is
supposed to be body so let's do args and
change this with body let's just still
work and still do the same thing as
before note that we're just passing on 1
arcs as a string that we were going to
fix it later now it's still working
hello Jess calm so arguments let's say
we take a new demo I of course prepared
a few of those so let's try to use this
example this is it of course still a
simple example and it's going to
repetitively print ad or call a log
function which is an alias which has one
argument text so if we're going to
replace that the same way as we did
before we need to slice out the body
copy that into our data structure as
before we're going to add a text
parameter then we have get function 0
because it's the first function that is
going to exist in this data array and
then the second object has no arguments
I mean function and so they did i do
everything on
alright so now we have basically to get
function calls and ergo going to return
well the functions are generated through
whatever is in disarray so let's see if
this works it doesn't work and why
doesn't it work anyway to see that look
at these two characters what's missing
here the actual arguments so remember
that this function is a function is
being returned and being invoked where
the original function would have been
invoked all right so if you look at the
original code I've replaced this
function basically with this function
and so that's being invoked and in order
to pass on the arguments as originally
intended I need to change this piece of
multi snippet to the standard apply
context and then
array.prototype.slice.call arguments 0
or whatever way you want to do this so
in a nutshell this now is going to
invoke this generated function as if it
was invoked originally same context same
arguments as far as a running code is
concerned nothing changes and now it
should work Go Go okay so now we can
still update this so we have data 0 is
this text or this body and let's try to
change that I say just depending some
kind of argument
and it's failing because oh no wait it's
in quotes oh because I'm not quoting it
huh ya know all right now I know why dis
isn't working so I change the data
structure and now it so I've changed a
runtime from hello text and just
appended II Foo without restarting the
application so arguments are preserved
and we can mess with that alright so
that's one step so then if we have had
arguments the next step would be
closures alright so we have we fix for
function arguments let's look at the
closures closures is going to be dis
snippet of example let's put it up here
so we are going to have a function
that's going to repeat whatever is being
passed on so this function will be
called below and then set interval will
repetitively log out whatever is being
passed on so note that text in here is a
closure over the text that's being
passed on so if I just going to replace
it as I did before which I don't think i
need to replace the first one because
it's still locked text so that's remains
the same except for the function let me
for the argument because that's now in
the second function which is the whole
so this is like the second function now
it's going to wrap this get function
alright so now let's see if this works
nope because text isn't isn't defined
and the reason it's not defined does
anybody can anybody figure it out like
right now why text would not be defined
there okay so yeah its function I heard
somebody say it over there function is
actually a indirect evil all right so it
only has access to the global scope if
you look at direct evil and indirectly
availed the main difference at least in
this context is that direct evil will
have access to the lexical scopes and
because we're using function over here
it's not working so let's change this to
evil so we're going to change evil we
need to add the function boilerplate now
arguments body closing parts and the
rest remains the same sorry all right so
let's see if this works now it still
doesn't work what did we forget so evil
is lexical scope so even though we're
doing direct evil right now it's not
going to be able to access text because
text doesn't exist in this function it
doesn't exist in this function and
doesn't exist in global scope so that's
why at this point it's still throwing a
failure so in order to solve this we're
going to do something like this let me
just give me a second
well let's do it in order so we're going
to add a compiler let me just do this on
anyone
okay the rest pretty much remains to be
the same thing here and leistes and then
whenever they get function we pass on
this compiler as an argument and this
requires now a argument because I mean
this Cole is this you know the best song
so rather than evil we're going to use
this compiler to compile stuff and in
global scope we just pass on evil
because we don't care about direct or
indirect from global okay so is it going
to work now I certainly hope so all
right okay so at least it's working now
so let's see if we can actually change
the closure because this text over here
is a closure remember that this function
doesn't have a closure a text argument
so let's just try to change it not
remove it change it and see if we can
mess with it so body equals dot
and it works so we're able to we're able
to recompile code now even though there
were closures in there so it maintained
access to those scopes so we fixed
closures now the next part is function
declarations of function declarations
require a preprocessor step so if we
have like a function foo then what we
actually need to do is rewrite this too
VAR foo is function they're equivalent
and the only other thing you need to
take into account is that you need to
move this line to the top of the scope
because that's basically what javascript
does as well so jobs will hoist those
function declarations and you can just
use any kind of parser to rewrite this
this part and make it equivalent in
terms of JavaScript semantics so that's
the for me at least that's a very simple
trivial way of getting rid of the
function declaration problem use a
parser for named function expressions
it's slightly more complex so you'd have
sorry so you'd have like this case
actually it's not set into it so the
right way of doing the you know the
paint loops with with timers if you were
going to use timers anyways would not be
set interval but set set timeout and you
do like and of course this would be like
the you know computer depending on
whatever okay it doesn't matter so this
is how you would do your paint loop and
then the problem with this approach in
terms of recompiling is that you don't
get to change repeat any more so that
value of repeat is is just being
executed over be just being assigned
once on top of that of course name names
of names function expressions have more
weird semantics but that's the main the
main point the main problem here so what
we do here is we're going to rewrite the
name function expression as well and so
rather than this we're going to do a
actually we're going to rattle in the
function so
so we're going to do this and then this
would be the actual code and then we're
going to return this function so we're
going to basically rewrite rewrite this
and that way we get rid of the named
function expression while maintaining
the runtime semantics of a name function
expression and this way we can actually
use our recompilation stuff so let's
quickly try this just to prove that it
does work sorry so we'd have this and
then we're going to wrap this body again
there are no arguments to this function
and the name we don't need anymore
because that's going to be abstracted
away in our rewrite right I should have
written it first all right
so this is a rewritten part of the set
timeout and now I need a rabbit I can
still maintain the first part i guess
and then use get function 0 this is
still the first first function up here I
think this is good and then we're going
to wrap the new function as well of
course and so it's going to be good
function one of course we need to pass
on a compiler
and of course the compiler here as well
and I no arguments I think this will
work I hope anyways let's see if it
works doesn't work does it need to be
invoked a measly now
all right well I guess you're just going
to have to assume or take my word for it
that works I don't think I'm going to be
able to solve that any like right now
anyways that the solution does work
because the semantics should be
equivalent alright so we've solved the
name function expressions and then for
ya for performance we can actually
extend a postpone it so let me refer so
that we had it well it was before I
think this was working yeah okay so and
we can change that to this yeah so what
we do is instead of compiling it every
time in this step basically we cash the
function that's being that's being
invoked and then we check whether it's
up to date so we're going to add a
closure or actually to closures I guess
that's the function and Nesta version
we're going to do a version check
no not evil to our local version and
then we're going to check whether
function exists is all for like the
first time and if it doesn't or if
either of the cases isn't true whatever
then we're going to compile it catch the
function let's see we need to move this
away sorry update the version I think
this is fine and then apply return funk
apply now only to do is update d sorry
I'm gonna end yeah that's correct so
sorry and I need to add the version to
the data object which can be just like a
alright so now it's only going to update
the compilation and we can sort of prove
that I suppose by just by checking in
here and so this this step should only
be invoked now so the actual calling of
eval should only be cold now when the
code has changed I'm not sure what does
twice right now but whatever but as you
can see it doesn't compile now and so
what we can do now is we can change the
body of the code and it doesn't
recompile because it doesn't see a new
version so as soon as we do dad and it
can be anything I mean it can be foo if
it doesn't really matter just doesn't
need to be the same as before and now
you can see recompile and it actually
recompile so it's the sort of lazy
evaluation and still you know rii
compiling ok so that was the last part
of the the main issues I just lied for
this also so direct the first is direct
in evil the trick the main trick to this
approach is basically a indirect direct
evil all right you're cashing a function
well that's what we're doing in this in
this moment in this part right we are
creating a function on any scope of our
new functions and that makes the dollar
sign compiler variable available on any
scope and that's why we can do the get
function compiler here which basically
just returns this function and because
this is a direct evil at that point it's
going to have access to all the
variables and that's why I closures are
working there's actually one problem
with this snippet of code can anybody
see what what's what's going to happen
at runtime at some point
I doubt Douglas Gophers going to use
this at all all right so what happens if
we do if we compile this and we do s
that's what's going to do it's going to
see that variable because it has access
to the closures and because we're adding
a new function it's actually kind of
adding a new scope and if we declare
variables in that scope they're going to
show up in this recompiling step so
changing the version we can now see that
has actually printing out the vlog so
we're polluting the scope of course
we're also gluttonous cope with a
compiler function but it's a something
that I can't fix for this one you can
fix it by simply removing his argument
and saying art I mean you're already
using evil right so might as well these
arguments all right so now it works and
if we change it to that it's going to
cry because as is no longer available of
course we can still print out say
compiler but that's again you know used
like Greek letters or something I know
as this is undefined and I was just
going to print out that that a compiler
function but this is the so medicine
main trick create a function that has a
direct evil and maintains access to the
local scopes yeah
so basically recap it's a approach that
works generically it works for pretty
much any kind of code you can recompile
you can change it on the fly if you seen
Brett Victor's talk inventing on
principle he does is like you know at
some point he does a this loop and he
changed it and he changes the number of
iterations to I don't know whatever to
change the number of leaves in the tree
and first time I saw that I was like
it's not possible you can't do that and
then later I had to disprove myself of
course because it's possible it's just
you know it takes magic bit of magic so
on every scope you inject a new function
compiler function which has a direct
evil and by which you have direct access
to all the Scopes which maintains access
to closures and know that makes it work
and inside that you have some rewriting
magic for like function declarations and
other nasty things that might screw this
up so some open issues the bigs the
biggest problem here is inserting new
functions because you're mapping
function is one on one right and I have
the library where I did it you know I
abstracted everything away so you can
just as you can sort as you can see in
the Recon powder demo that doesn't
really work you can you know you can
type here and it will replace all the
codes but it's going to assume that
these functions are going to be a
certain order so if you add a new
function you know injected some how it's
going to trip up simply because it's
going to run to put this body actually
no this body into this body and so
that's it's something that I don't think
it's very easy to solve I've try to you
know I've tried to do a diff the
different help will be only so far
because there might be changes that are
spread on multiple parts in the code and
in that case you don't know which
functions to replace so that's like the
biggest problem with this approach but
as long as you're not as certain any new
functions everything's going to be fine
the minor issue is of course the
variable clashes that I explained before
and it's actually very hard to explain
people's don't see
to get that you can't really go ahead
and change the global code right I mean
if there's no way that if I would a
runtime at least if I will do this for
flu is bar and run and run time I would
recompile this and to say it is like gee
it won't be picked up because it's only
picked up by code that's really valuable
backs that are going to be reevaluated
actually re invoked at some point any
other code which includes any global
code it's it's not going to work or at
least it's not going to be useful it's
going to work but it's not gonna do
anything so it that seems to be hard to
get across unfortunately so the code is
going to be available on github as usual
I will push it later if github allows me
to and otherwise I'll you know slides
will be in there as well and yeah so are
there any questions I have like zero
minutes left so that should be fine okay
otherwise I'll be out there and ya thang
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>